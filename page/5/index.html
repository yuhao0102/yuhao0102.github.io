<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
<meta property="og:type" content="website">
<meta property="og:title" content="Hao Yu&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
<meta property="og:locale" content="zn_CH">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="HPC PC IA">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zn-ch'
  };
</script>

  <title>Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/14/Intel_MPI%E6%89%8B%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/14/Intel_MPI%E6%89%8B%E5%86%8C/" class="post-title-link" itemprop="url">Intel MPI library developer reference for Linux</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-14 15:04:00" itemprop="dateCreated datePublished" datetime="2021-12-14T15:04:00+08:00">2021-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-07 14:09:50" itemprop="dateModified" datetime="2022-01-07T14:09:50+08:00">2022-01-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Intel-MPI安装"><a href="#Intel-MPI安装" class="headerlink" title="Intel MPI安装"></a>Intel MPI安装</h1><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><ul>
<li>加载 mpivars.[c]sh 脚本。</li>
<li>创建文本文件 mpd.hosts ，其中保存有集群的节点列表，每行一个名字<ul>
<li>(只针对开发者) 确保环境变量 PATH 中包含有相应的编译器，比如 icc。</li>
<li>(只针对开发者) 使用适当的编译驱动编译测试程序，比如 mpiicc。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiicc -o test test.c</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 mpirun 运行测试程序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -r ssh -f mpd.hosts -n &lt;# of processes&gt; ./test</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h2><ul>
<li>保证在PATH环境变量中编译器设置正确。使用Intel编译器，确保<code>LD_LIBRARY_PATH</code>环境变量中含有编译库的路径。</li>
<li>通过相应的 mpi 命令编译 MPI 程序。比如调用 mpicc 使用 GNU C 编译器：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpicc &lt;path-to-test&gt;/test.c</span><br></pre></td></tr></table></figure>
(支持的编译器都有对应的以 mpi 开头的命令，比如 Intel Fortran (ifort ) 对应的为 mpiifort).</li>
</ul>
<h2 id="运行MPI程序"><a href="#运行MPI程序" class="headerlink" title="运行MPI程序"></a>运行MPI程序</h2><h3 id="设置-MPD-守护进程"><a href="#设置-MPD-守护进程" class="headerlink" title="设置 MPD 守护进程"></a>设置 MPD 守护进程</h3><p>Intel MPI 库使用 Multi-Purpose Daemon (MPD) 任务调度机制。为运行使用 mpiicc 编译的程序，首先需要设置好 MPD 守护进程。</p>
<p>与系统管理员为系统中所有用户启动一次 MPD 守护进程不同，用户需要启动和维护自己的一组 MPD 守护进程。这种设置增强了系统安全性，并为控制可执行程序的环境提供了更强的灵活性。</p>
<p>设置MPD的步骤如下：</p>
<ul>
<li>设置相应的环境变量和目录。比如，在 .zshrc 或 .bashrc 文件中：<ul>
<li>保证 PATH 变量中包含有<code>&lt;installdir&gt;/bin</code>或者Intel 64 位架构对应的<code>&lt;installdir&gt;/bin64</code>目录，其中<code>&lt;installdir&gt;</code>指的是 MPI 的安装路径。可使用 Intel MPI 库中带有的 mpivars.[c]sh 来设置此变量。</li>
<li>确保 PATH 中包含有的 Python 至少为 2.2 或以上版本。</li>
<li>如果使用 Intel 编译器，确保<code>LD_LIBRARY_PATH</code>变量包含有编译器的库目录。可使用编译器中带有的 {icc,ifort}*vars.[c]sh 脚本来设置。</li>
<li>设置应用程序所需要的其它环境变量。</li>
</ul>
</li>
<li><p>创建 $HOME/.mpd.conf 文件，设置 MPD 密码，需要在文件中写入一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secretword=&lt;mpd secret word&gt;</span><br></pre></td></tr></table></figure>
<p>不要使用 Linux 登陆密码。<code>&lt;mpd secret word&gt;</code>可为任意字符串，它仅仅在不同的集群用户对 MPD 守护进程进行控制时有用。</p>
</li>
<li><p>使用 chmod 设置 $HOME/.mpd.conf 文件的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 600 $HOME/.mpd.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>保证你在集群的所有节点上 rsh 命令看到同样的 PATH 和 .mpd.conf 内容。 比如在集群的所有节点上执行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rsh &lt;node&gt; env</span><br><span class="line">$ rsh &lt;node&gt; cat $HOME/.mpd.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>保证每个节点都能够与其它任意节点连接。可使用安装中提供的 sshconnectivity 脚本。该脚本使用提供所有节点列表的文件作为参数，每个节点一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sshconnectivity.exp machines.LINUX</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>集群使用的是 ssh 而不是 rsh:</p>
<pre><code>- 需要确保任一节点与其它节点连 接时都不需要密码。这需要参照系统管理手册。
- 在启动 mpdboot 时需要加上调 用参数 -r ssh 或 --rsh=ssh
</code></pre><ul>
<li><p>创建文本文件 mpd.hosts , 其中列出了集群中所有的节点，每行一个主机名。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; mpd.hosts</span><br><span class="line">node1</span><br><span class="line">node2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 mpdallexit 命令关闭上一次的 MPD 守护进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpdallexit</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 mpdboot 命令启动 MPD 守护进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpdboot -n &lt;#nodes&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果文件 $PWD/mpd.hosts 存在，则会被用作默认参数。如果没有主机名文件，启用 mpdboot 只会在本地机器上运行 MPD 守护进程。</p>
</li>
<li>使用 mpdtrace 命令检查 MPD 守护进程的状态：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpdtrace</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其输出结果应该为当前进行 MPD 守护进程的节点列表。该列表应该与 mpd.hosts 文件中节点列表符合。</p>
<h1 id="网络结构选择"><a href="#网络结构选择" class="headerlink" title="网络结构选择"></a>网络结构选择</h1><p>Intel MPI 库会动态选择大部分适用的网络结构以便 MPI 进程之间进行通讯。设置环境变量<code>I_MPI_DEVICE</code>为下表中的某个值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>I_MPI_DEVICE 值</th>
<th>支持的结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>sock</td>
<td>TCP/Ethernet/sockets</td>
</tr>
<tr>
<td>shm</td>
<td>Shared memory only (no sockets)</td>
</tr>
<tr>
<td>ssm</td>
<td>TCP + shared memory</td>
</tr>
<tr>
<td>rdma[:]</td>
<td>InfiniBand, Myrinet (via specified DAPL provider)</td>
</tr>
<tr>
<td>rdssm[:]</td>
<td>TCP + shared memory + DAPL</td>
</tr>
</tbody>
</table>
</div>
<p>要保证所选择的网络结构可用。比如，使用 shm 只有当所有进程可以通过共享内存进 行通讯时才行；使用 rdma 只有当所有进程可以通过单一的 DAPL 相互通讯时才行。</p>
<h1 id="运行MPI程序-1"><a href="#运行MPI程序-1" class="headerlink" title="运行MPI程序"></a>运行MPI程序</h1><p>运行使用 Intel MPI 库连接的程序，使用 mpiexec 命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec -n &lt;# of processes&gt; ./myprog</span><br></pre></td></tr></table></figure><br>使用 -n 参数设置进程数，这是 mpiexec 唯一需要明显指定的选项。如果使用的网络结构与默认的不同，需要使用 -genv 选项来提供一个可以赋给 I_MPI_DEVICE 变量的值。</p>
<p>比如使用 shm 结构来运行 MPI 程序，可执行如下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec -genv I_MPI_DEVICE shm -n &lt;# of processes&gt; ./myprog</span><br></pre></td></tr></table></figure><br>比如使用 rdma 结构来运行 MPI 程序，可执行如下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec -genv I_MPI_DEVICE rdma -n &lt;# of processes&gt; ./myprog</span><br></pre></td></tr></table></figure><br>可以通过命令选择任何支持的设备。</p>
<p>如果应用程序运行成功，可将其移动到使用不同结构的集群中，不需要重新链接程序。</p>
<h1 id="MPI错误代码对照表"><a href="#MPI错误代码对照表" class="headerlink" title="MPI错误代码对照表"></a>MPI错误代码对照表</h1><ul>
<li>00CA : no resources available　　</li>
<li>00CB : configuration error　　</li>
<li>00CD : illegal call　　</li>
<li>00CE : module not found　　</li>
<li>00CF : driver not loaded　　</li>
<li>00D0 : hardware fault　　</li>
<li>00D1 : software fault　　</li>
<li>00D2 : memory fault　　</li>
<li>00D7 : no me age　　</li>
<li>00D8 : storage fault　　</li>
<li>00DB : internal timeout　　</li>
<li>00E1 : too many cha els open　　</li>
<li>00E2 : internal fault　　</li>
<li>00E7 : hardware fault　　</li>
<li>00E9 : sin_serv.exe not started　　</li>
<li>00EA : protected　　</li>
<li>00F0 : scp db file does not exist　　</li>
<li>00F1 : no global dos storage available　　</li>
<li>00F2 : error during tra mi ion　　</li>
<li>00F2 : error during reception　　</li>
<li>00F4 : device does not exist　　</li>
<li>00F5 : incorrect sub system　　</li>
<li>00F6 : unknown code　　</li>
<li>00F7 : buffer too small　　</li>
<li>00F8 : buffer too small　　</li>
<li>00F9 : incorrect protocol　　</li>
<li>00FB : reception error　　</li>
<li>00FC : licence error　　</li>
<li>0101 : co ection not established / parameterised　　</li>
<li>010A : negative acknowledgement received / timeout error　　</li>
<li>010C : data does not exist or disabled　　</li>
<li>012A : system storage no longer available　　</li>
<li>012E : incorrect parameter　　</li>
<li>0132 : no memory in DPRAM　　</li>
<li>0201 : incorrect interface  ecified　　</li>
<li>0202 : maximum amount of interfaces exceeded　　</li>
<li>0203 : PRODAVE already initialised　　</li>
<li>0204 : wrong parameter list　</li>
<li>0205 : PRODAVE not initialised　</li>
<li>0206 : handle ca ot be set　</li>
<li>0207 : data segment ca ot be disabled　</li>
<li>0300 : initialisiation error　</li>
<li>0301 : initialisiation error　</li>
<li>0302 : block too small, DW does not exist　</li>
<li>0303 : block limit exceeded, correct amount</li>
<li>0310 : no HW found　</li>
<li>0311 : HW defective　</li>
<li>0312 : incorrect config param　</li>
<li>0313 : incorrect baud rate / interrupt vector　</li>
<li>0314 : HSA parameterised incorrectly　</li>
<li>0315 : MPI addre  error　</li>
<li>0316 : HW device already allocated　</li>
<li>0317 : interrupt not available　</li>
<li>0318 : interrupt occupied　</li>
<li>0319 : sap not occupied　</li>
<li>031A : no remote station found　</li>
<li>031B : internal error　</li>
<li>031C : system error　</li>
<li>031D : error buffer size　</li>
<li>0320 : hardware fault　</li>
<li>0321 : DLL function error　</li>
<li>0330 : version conflict　</li>
<li>0331 : error com config　</li>
<li>0332 : hardware fault　</li>
<li>0333 : com not configured　</li>
<li>0334 : com not available　</li>
<li>0335 : serial drv in use　</li>
<li>0336 : no co ection　</li>
<li>0337 : job rejected　</li>
<li>0380 : internal error　</li>
<li>0381 : hardware fault　</li>
<li>0382 : no driver or device found　</li>
<li>0384 : no driver or device found　</li>
<li>03FF : system fault　</li>
<li>0800 : toolbox occupied　</li>
<li>4001 : co ection not known　</li>
<li>4002 : co ection not established　</li>
<li>4003 : co ection is being established　</li>
<li>4004 : co ection broken down　</li>
<li>8000 : function already actively occupied　</li>
<li>8001 : not allowed in this operating status　</li>
<li>8101 : hardware fault　</li>
<li>8103 : object acce  not allowed　</li>
<li>8104 : context is not su orted　</li>
<li>8105 : invalid addre 　</li>
<li>8106 : type (data type) not su orted　</li>
<li>8107 : type (data type) not co istent　</li>
<li>810A : object does not exist　</li>
<li>8301 : memory slot on CPU not sufficient　</li>
<li>8404 : grave error　　8500 : incorrect PDU size　</li>
<li>8702 : addre  invalid　</li>
<li>D201 : syntax error block name　</li>
<li>D202 : syntax error function parameter　</li>
<li>D203 : syntax error block type　</li>
<li>D204 : no linked block in storage medium　</li>
<li>D205 : object already exists　</li>
<li>D206 : object already exists　</li>
<li>D207 : block exists in EPROM　</li>
<li>D209 : block does not exist　</li>
<li>D20E : no block available　</li>
<li>D210 : block number too big　</li>
<li>D241 : protection level of function not sufficient　</li>
<li>D406 : information not available　</li>
<li>EF01 : incorrect ID2　</li>
<li>FFFB : TeleService Library not found　</li>
<li>FFFE : unknown error FFFE hex　</li>
<li>FFFF : timeout error. Check interfac</li>
</ul>
<h1 id="MPI的命令"><a href="#MPI的命令" class="headerlink" title="MPI的命令"></a>MPI的命令</h1><h2 id="编译命令列表"><a href="#编译命令列表" class="headerlink" title="编译命令列表"></a>编译命令列表</h2><p>本节提供有关不同命令类型以及如何使用这些命令的信息：</p>
<ul>
<li>编译命令列出了可用的英特尔® MPI 库编译器命令、相关选项和环境变量。</li>
<li>mpirun 提供了mpirun 命令的描述和示例。</li>
<li>mpiexec.hydra 提供有关 mpiexec.hydra 命令、其选项、环境变量，以及相关的功能和实用程序。</li>
<li>cpuinfo 提供了 cpuinfo 实用程序的语法、参数、描述和输出示例。</li>
<li>impi_info 提供有关可用环境变量的信息。</li>
<li>mpitune 提供有关 mpitune 实用程序的配置选项的信息。</li>
</ul>
<h3 id="编译器命令"><a href="#编译器命令" class="headerlink" title="编译器命令"></a>编译器命令</h3><p>下表列出了可用的英特尔® MPI 库编译器命令及其底层编译器和编程语言。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Compiler Command</th>
<th>Default Compiler</th>
<th>Supported Languages</th>
</tr>
</thead>
<tbody>
<tr>
<td>Generic Compilers</td>
<td></td>
<td></td>
</tr>
<tr>
<td>mpicc</td>
<td>gcc, cc</td>
<td>C</td>
</tr>
<tr>
<td>mpicxx</td>
<td>g++</td>
<td>C/C++</td>
</tr>
<tr>
<td>mpifc</td>
<td>gfortran</td>
<td>Fortran77<em>/Fortran 95</em></td>
</tr>
<tr>
<td>GNU* Compilers</td>
<td></td>
<td></td>
</tr>
<tr>
<td>mpigcc</td>
<td>gcc</td>
<td>C</td>
</tr>
<tr>
<td>mpigxx</td>
<td>g++</td>
<td>C/C++</td>
</tr>
<tr>
<td>mpif77</td>
<td>gfortran</td>
<td>Fortran 77</td>
</tr>
<tr>
<td>mpif90</td>
<td>gfortran</td>
<td>Fortran 95</td>
</tr>
<tr>
<td>Intel® Fortran, C++ Compilers</td>
<td></td>
<td></td>
</tr>
<tr>
<td>mpiicc</td>
<td>icc</td>
<td>C</td>
</tr>
<tr>
<td>mpiicpc</td>
<td>icpc</td>
<td>C++</td>
</tr>
<tr>
<td>mpiifort</td>
<td>ifort</td>
<td>Fortran77/Fortran 95</td>
</tr>
</tbody>
</table>
</div>
<p>编译器命令注意事项</p>
<ul>
<li>编译器命令仅在英特尔 MPI 库软件开发套件 (SDK) 中可用。</li>
<li>有关所列编译器的支持版本，请参阅发行说明。</li>
<li>要显示编译器命令的小帮助，请在不带任何参数的情况下执行它。</li>
<li>编译器包装脚本位于<code>&lt;install-dir&gt;/bin</code>目录中，其中<code>&lt;install-dir&gt;</code>是英特尔 MPI 库安装目录。</li>
<li>可以通过获取<code>&lt;install-dir&gt;/env/vars.[c]sh</code>脚本来建立环境设置。 要使用特定的库配置，请将以下参数之一传递给脚本以切换到相应的配置：release、debug、release_mt 或 debug_mt。</li>
<li>确保相应的底层编译器已在您的 PATH 中。 如果您使用英特尔® 编译器，请从安装目录获取<code>vars.sh</code>脚本以设置编译器环境。</li>
</ul>
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p><code>-nostrip</code>：使用此选项可在静态链接英特尔® MPI 库时关闭调试信息。</p>
<p><code>-config=&lt;名称&gt;</code>：使用此选项来获取编译器配置文件。该文件应包含要设置与指定的编译器一起使用的环境设置。对配置文件使用以下命名约定：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;安装目录&gt;/etc/mpi&lt;编译器&gt;-&lt;名称&gt;.conf</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;compiler&gt;=&#123;cc,cxx,f77,f90&#125;</code>，取决于编译的语言。</li>
<li><code>&lt;name&gt;</code>是底层编译器的名称，其中空格被连字符替换；例如，<code>cc -64</code>的<code>&lt;name&gt;</code>值为<code>cc--64</code>。</li>
</ul>
<p><code>-profile=&lt;profile_name&gt;</code>：使用此选项指定 MPI 分析库。<code>&lt;profile_name&gt;</code>是配置文件的名称，加载相应的分析库。配置文件取自<code>&lt;install-dir&gt;/etc</code>。英特尔 MPI 库为英特尔® 跟踪收集器提供了几个预定义的配置文件：</p>
<ul>
<li><code>&lt;install-dir&gt;/etc/vt.conf</code> — 常规跟踪库</li>
<li><code>&lt;install-dir&gt;/etc/vtfs.conf</code> — 故障安全跟踪库</li>
<li><code>&lt;install-dir&gt;/etc/vtmc.conf</code> — 正确性检查跟踪库</li>
<li><code>&lt;install-dir&gt;/etc/vtim.conf</code> — 负载不平衡跟踪库</li>
</ul>
<p>您还可以将自己的配置文件创建为<code>&lt;profile-name&gt;.conf</code>。您可以定义以下环境配置文件中的变量：</p>
<ul>
<li><code>PROFILE_PRELIB</code> - 在英特尔 MPI 库之前加载的库（和路径）</li>
<li><code>PROFILE_POSTLIB</code> - 在英特尔 MPI 库之后加载的库</li>
<li><code>PROFILE_INCPATHS</code> - 任何包含文件的 C 预处理器参数</li>
</ul>
<p>例如，使用以下几行创建文件<code>myprof.conf</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROFILE_PRELIB=&quot;-L&lt;path_to_myprof&gt;/lib -lmyprof&quot;</span><br><span class="line">PROFILE_INCPATHS=&quot;-I&lt;paths_to_myprof&gt;/include&quot;</span><br></pre></td></tr></table></figure></p>
<p>使用相关编译器包装器的<code>-profile=myprof</code>选项来选择此新配置文件。</p>
<p><code>-t</code>或<code>-trace</code>：使用<code>-t</code>或<code>-trace</code>选项将生成的可执行文件链接到英特尔® 跟踪收集器库。使用此选项与<code>-profile=vt</code>选项具有相同的效果。您还可以使用<code>I_MPI_TRACE_PROFILE</code>环境变量到<code>&lt;profile_name&gt;</code>来指定另一个分析库。例如，将<code>I_MPI_TRACE_PROFILE</code>设置为<code>vtfs</code>以链接到故障安全版本的英特尔跟踪收集器。</p>
<p><code>-trace-imbalance</code>：使用<code>-trace-imbalance</code>选项将生成的可执行文件链接到负载不平衡跟踪库。使用此选项与<code>-profile=vtim</code>选项具有相同的效果。要使用此选项，请在<code>VT_ROOT</code>环境中包含 Intel Trace Collector 的安装路径</p>
<p><code>-check_mpi</code>：使用此选项将生成的可执行文件链接到英特尔® 跟踪收集器正确性检查库。默认值为<code>libVTmc.so</code>。使用此选项与<code>-profile=vtmc</code>具有相同的效果</p>
<p>您还可以使用<code>I_MPI_CHECK_PROFILE</code>环境变量给<code>&lt;profile_name&gt;</code>指定另一个库。</p>
<p>要使用此选项，请在<code>VT_ROOT</code>环境中包含 Intel Trace Collector 的安装路径变量。</p>
<p><code>-ilp64</code>：使用此选项可启用部分 ILP64 支持。英特尔 MPI 库的所有整数参数都被视为 64 位值。</p>
<p><code>-no_ilp64</code>：使用此选项可明确禁用 ILP64 支持。此选项必须与 -i8 结合使用</p>
<p>如果您为使用英特尔 Fortran 编译器的单独编译指定 -i8 选项，您仍然必须使用用于链接的 i8 orilp64 选项。</p>
<p><code>-dynamic_log</code>：将此选项与 -t 选项结合使用可动态链接英特尔跟踪收集器库。</p>
<p>要运行生成的程序，请将<code>$VT_ROOT/slib</code>包含在<code>LD_LIBRARY_PATH</code>环境变量中。</p>
<p><code>-G</code>：使用此选项在调试模式下编译程序并将生成的可执行文件链接到英特尔 MPI 库的调试版本。有关如何使用附加的信息，请参阅<code>I_MPI_DEBUG</code>。默认情况下，优化的库与 -g 选项链接。</p>
<p>在运行时使用<code>vars.&#123;sh|csh&#125; [debug|debug_mt]</code>加载特定的 libmpi.so 配置。</p>
<p><code>-link_mpi=&lt;参数&gt;</code>：使用此选项始终链接指定版本的英特尔 MPI 库。查看用于详细参数描述的<code>I_MPI_LINK</code>环境变量。此选项会覆盖所有其他选择特定选项的选项。</p>
<p>在运行时使用<code>vars.&#123;sh|csh&#125;[debug|debug_mt]</code>加载特定的 libmpi.so 配置。</p>
<p><code>-O</code>：使用此选项可启用编译器优化。</p>
<p><code>-fast</code>：使用此选项可最大限度地提高整个程序的速度。此选项强制英特尔 MPI 库的静态链接方法。此选项仅受 mpiicc、mpiicpc 和 mpiifort 英特尔® 编译器包装器支持。</p>
<p><code>-echo</code>：使用此选项可显示命令脚本执行的所有操作。</p>
<p><code>-show</code>：使用此选项可了解如何调用底层编译器，而无需实际运行它。使用以下命令查看所需的编译器标志和选项：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiicc -show -c test.c</span><br></pre></td></tr></table></figure></p>
<p>使用以下命令查看所需的链接标志、选项和库：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiicc -show -o a.out test.o</span><br></pre></td></tr></table></figure><br>此选项对于确定直接使用底层编译器的复杂构建过程的命令行特别有用。</p>
<p><code>-show_env</code>：使用此选项可查看调用底层编译器时生效的环境设置。</p>
<p><code>-&#123;cc,cxx,fc&#125;=&lt;编译器&gt;</code>：使用此选项可选择底层编译器。下表列出了可用的 LLVM 和 IL0 编译器选项以及用于调用它们的命令。<br><img src="/img/1639492360.jpg" alt=""></p>
<p><code>-nofortbind, -nofortran</code>：使用此选项可禁用 mpiicc 与 Fortran 绑定的链接。这与<code>I_MPI_FORT_BIND</code>变量具有相同的效果。</p>
<p><code>-v</code>：使用此选项打印编译器包装器脚本版本及其底层编译器版本。</p>
<p><code>-norpath</code>：使用此选项可为英特尔® MPI 库的编译器包装器禁用 rpath。</p>
<p><code>mpirun</code>：启动 MPI 作业并提供与作业调度程序的集成。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun &lt;选项&gt;</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li><code>&lt;options&gt;</code>：<code>mpiexec.hydra</code>选项，如<code>mpiexec.hydra</code>部分所述。这是默认操作模式。</li>
</ul>
<p>使用此命令启动 MPI 作业。 mpirun 命令使用 Hydra 作为底层进程管理器。<code>mpirun</code>命令检测 MPI 作业是否是从使用<code>Torque*</code>、<code>PBS Pro*</code>、<code>LSF*</code>、<code>Parallelnavi* NQS*</code>、<code>Slurm*</code>、<code>Univa* Grid Engine*</code>或<code>LoadLeveler*</code>等作业调度程序分配的会话内提交的。<code>mpirun</code>命令从各自的环境中提取主机列表，并根据上述方案自动使用这些节点。在这种情况下，您不需要创建主机文件。使用系统上安装的作业调度程序分配会话，并在此会话中使用 mpirun 命令运行 MPI 作业。</p>
<p>例子<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -n &lt;# of processes&gt; ./myprog</span><br></pre></td></tr></table></figure></p>
<p>此命令调用 mpiexec.hydra 命令（Hydra 进程管理器），该命令启动 myprog。</p>
<p><code>mpiexec.hydra</code>：使用 Hydra 进程管理器启动 MPI 作业。</p>
<p>句法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpiexec.hydra&lt;g-options&gt; &lt;l-options&gt; &lt;executable&gt;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpiexec.hydra&lt;g-options&gt; &lt;l-options&gt; &lt;executable1&gt; : &lt;l-options&gt; &lt;executable2&gt;</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li><code>&lt;g-options&gt;</code>：适用于所有 MPI 进程的全局选项</li>
<li><code>&lt;l-options&gt;</code>：适用于单个参数集的本地选项</li>
<li><code>&lt;executable&gt;</code>：<code>./a.out</code>或可执行文件的路径/名称</li>
</ul>
<p>描述</p>
<ul>
<li>使用 mpiexec.hydra 实用程序通过 Hydra 进程管理器运行 MPI 应用程序。</li>
</ul>
<p>使用第一个简短的命令行语法以单个参数集启动<code>&lt;executable&gt;</code>的所有 MPI 进程。例如，以下命令对指定的进程和主机执行<code>a.out</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec.hydra -f &lt;hostfile&gt; -n &lt;# of processes&gt; ./a.out</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;# of processes&gt;</code>指定运行 a.out 可执行文件的进程数</li>
<li><code>&lt;hostfile&gt;</code>指定运行 a.out 可执行文件的主机列表</li>
</ul>
<p>使用第二个长命令行语法为不同的 MPI 程序运行设置不同的参数集。例如，以下命令使用不同的参数集执行两个不同的二进制文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec.hydra -f &lt;hostfile&gt; -env &lt;VAR1&gt; &lt;VAL1&gt; -n 2 ./a.out : -env &lt;VAR2&gt; &lt;VAL2&gt; -n 2 ./b.out</span><br></pre></td></tr></table></figure></p>
<p>注意您需要区分全局选项和本地选项。在命令行语法中，将本地选项放在全局选项之后。</p>
<h2 id="Global-Hydra-Options"><a href="#Global-Hydra-Options" class="headerlink" title="Global Hydra Options"></a>Global Hydra Options</h2><p>英特尔® MPI 库的 Hydra 进程管理器的全局选项。全局选项应用于启动命令中的所有参数集。参数集由冒号“:”分隔。</p>
<p><code>-tune &lt;文件名&gt;</code>：使用此选项指定包含二进制格式的调优数据的文件名。</p>
<p><code>-usize &lt;usize&gt;</code>：使用此选项设置<code>MPI_UNIVERSE_SIZE</code>，它可用作<code>MPI_COMM_WORLD</code>的属性。</p>
<ul>
<li><code>&lt;size&gt;</code>定义 Universe 大小</li>
<li><code>SYSTEM</code>设置大小等于通过主机文件或资源管理器传递给 mpiexec 的内核数。</li>
<li><code>INFINITE</code>不限制大小。这是默认值。</li>
<li><code>&lt;value&gt;</code>将大小设置为 ≥ 0 的数值。</li>
</ul>
<p><code>-hostfile &lt;hostfile&gt;</code>或<code>-f &lt;hostfile&gt;</code>：使用此选项指定运行应用程序的主机名。如果主机名重复，则此名称仅使用一次。有关更多详细信息，另请参阅<code>I_MPI_HYDRA_HOST_FILE</code>环境变量。</p>
<p>注意使用以下选项更改集群节点上的进程排布：</p>
<ul>
<li>使用<code>-perhost</code>、<code>-ppn</code>和<code>-grr</code>选项通过循环调度将连续的MPI 进程放置在每个主机上。</li>
<li>使用<code>-rr</code>选项使用循环调度将连续的MPI 进程放置在不同的主机上。</li>
</ul>
<p><code>-machinefile &lt;机器文件&gt;</code>或<code>-machine &lt;机器文件&gt;</code>：使用此选项可通过机器文件控制进程放置。要定义要启动的进程总数，请使用<code>-n</code>选项。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ./machinefile</span><br><span class="line">node0:2</span><br><span class="line">node1:2</span><br><span class="line">node0:1</span><br></pre></td></tr></table></figure></p>
<p><code>-hosts-group</code>：使用此选项可使用方括号、逗号和破折号设置节点范围（如在<code>Slurm*</code>工作负载管理器中）。有关更多详细信息，请参阅 Hydra 环境变量中的<code>I_MPI_HYDRA_HOST_FILE</code>环境变量。</p>
<p><code>-silent-abort</code>：使用此选项可禁用中止警告消息。有关更多详细信息，请参阅 Hydra 环境变量中的<code>I_MPI_SILENT_ABORT</code>环境变量。</p>
<p><code>-nameserver</code>：使用此选项以<code>主机名:端口</code>格式指定名称服务器。有关更多详细信息，请参阅 Hydra 环境变量中的<code>I_MPI_HYDRA_NAMESERVER</code>环境变量。</p>
<p><code>-genv &lt;ENVVAR&gt; &lt;value&gt;</code>：使用此选项可为所有 MPI 进程将<code>&lt;ENVVAR&gt;</code>环境变量设置为指定的<code>&lt;value&gt;</code>。</p>
<p><code>-genvall</code>：使用此选项可以将所有环境变量传播到所有 MPI 进程。</p>
<p><code>-genvnone</code>：使用此选项可禁止将任何环境变量传播到任何 MPI 进程。</p>
<p><code>-genvexcl &lt;环境变量名称列表&gt;</code>：使用此选项可禁止将列出的环境变量传播到任何 MPI 进程。</p>
<p><code>-genvlist &lt;列表&gt;</code>：使用此选项可传递带有当前值的环境变量列表。<code>&lt;list&gt;</code>是要发送到所有 MPI 进程的环境变量的逗号分隔列表。</p>
<p><code>-pmi-connect &lt;mode&gt;</code>：使用此选项可选择进程管理接口 (PMI) 消息的缓存模式。<code>&lt;mode&gt;</code>的可能值为：</p>
<ul>
<li><code>&lt;mode&gt;</code>：要使用的缓存模式</li>
<li><code>nocache</code>：不缓存 PMI 消息。</li>
<li><code>cache</code>：在本地 pmi_proxy 管理进程上缓存 PMI 消息，以最大限度地减少 PMI 请求的数量。缓存的信息会自动传播到子管理进程。</li>
<li><code>lazy-cache</code>：带有 PMI 信息的请求传播。</li>
<li><code>alltoall</code>：信息在所有 pmi_proxy 之间自动交换，然后才能完成任何获取请求。这是默认模式。</li>
</ul>
<p>有关更多详细信息，请参阅<code>I_MPI_HYDRA_PMI_CONNECT</code>环境变量。</p>
<p><code>-perhost &lt;# of processes &gt;</code>、<code>-ppn &lt;# of processes &gt;</code>或<code>-grr &lt;# of processes &gt;</code>：使用此选项可以使用循环调度在组中的每个主机上放置指定数量的连续 MPI 进程。有关更多详细信息，请参阅<code>I_MPI_PERHOST</code>环境变量。注意在作业调度程序下运行时，默认情况下会忽略这些选项。为了能够使用这些选项控制进程放置，请禁用<code>I_MPI_JOB_RESPECT_PROCESS_PLACEMENT</code></p>
<p><code>-rr</code>：使用此选项可以使用循环调度将连续的 MPI 进程放置在不同的主机上。此选项等效于<code>-perhost 1</code>。有关更多详细信息，请参阅<code>I_MPI_PERHOST</code>环境变量。</p>
<p><code>-trace [&lt;profiling_library&gt;]</code>或<code>-t [&lt;profiling_library&gt;]</code>：使用此选项，使用指定的英特尔® 跟踪收集器<code>&lt;profiling_library&gt;</code>来分析您的 MPI 应用程序。如果未指定<code>&lt;profiling_library&gt;</code>，则使用默认分析库<code>libVT.so</code>。设置<code>I_MPI_JOB_TRACE_LIBS</code>环境变量以覆盖默认分析库。</p>
<p><code>-trace-imbalance</code>：使用此选项通过使用<code>libVTim.so</code>库的英特尔® 跟踪收集器来分析您的 MPI 应用程序。</p>
<p><code>-aps</code>：使用此选项可使用应用程序性能快照从 MPI 应用程序收集统计信息。收集的数据包括硬件性能指标、内存消耗数据、内部 MPI 不平衡和 OpenMP* 不平衡统计。使用此选项时，会生成一个包含统计数据的新文件夹<code>aps_result_&lt;date&gt;-&lt;time&gt;</code>。您可以使用 aps 实用程序分析收集的数据，例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -aps -n 2 ./myApp</span><br><span class="line">$ aps aps_result_20171231_235959</span><br></pre></td></tr></table></figure></p>
<p><code>-mps</code>：使用此选项仅从使用应用程序性能快照的 MPI 应用程序收集 MPI 和 OpenMP* 统计信息。与<code>-aps</code>选项不同，<code>-mps</code>不收集硬件指标。该选项等效于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -n 2 aps -c mpi,omp ./myapp</span><br></pre></td></tr></table></figure></p>
<p><code>-trace-pt2pt</code>：使用此选项来收集有关使用英特尔® 跟踪分析器和收集器的点对点操作的信息。该选项要求您还使用<code>-trace</code>选项。</p>
<p><code>-trace-collectives</code>：使用此选项来收集有关使用英特尔® 跟踪分析器和收集器的集合操作的信息。该选项要求您还使用<code>-trace</code>选项。</p>
<p>使用<code>-trace-pt2pt</code>和<code>-trace-collectives</code>减少生成的跟踪文件的大小或消息检查器报告的数量。这些选项适用于静态和动态链接的应用程序。</p>
<p><code>-configfile &lt;文件名&gt;</code>：使用此选项指定包含命令行选项的文件<code>&lt;filename&gt;</code>，每行一个可执行文件。空行和以“#”开头的行将被忽略。命令行中指定的其他选项被视为全局选项。您可以在默认加载的配置文件中指定全局选项（<code>&lt;installdir&gt;/etc</code>中的<code>mpiexec.conf</code>、<code>~/.mpiexec.conf</code>和工作目录中的<code>mpiexec.conf</code>）。其余选项可以在命令行指定。</p>
<p><code>-branch-count &lt;数量&gt;</code>：使用此选项来限制 Hydra 管理进程启动的子管理进程的数量。有关更多详细信息，请参阅<code>I_MPI_HYDRA_BRANCH_COUNT</code>环境变量。</p>
<p><code>-pmi-aggregate</code>或<code>-pmi-noaggregate</code>：使用此选项分别打开或关闭 PMI 请求的聚合。默认值为<code>-pmi-aggregate</code>，表示默认启用聚合。有关更多详细信息，请参阅<code>I_MPI_HYDRA_PMI_AGGREGATE</code>环境变量。</p>
<p><code>-gdb</code>：使用此选项可在 GDB*（GNU 调试器）下运行可执行文件。您可以使用以下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexeс.hydra -gdb -n &lt;进程数&gt;&lt;可执行文件&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>-gdba &lt;pid&gt;</code>：使用此选项将 GNU* 调试器附加到现有的 MPI 作业。您可以使用以下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec.hydra -gdba &lt;pid&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>-nolocal</code>：使用此选项可避免在启动<code>mpiexec.hydra</code>的主机上运行<code>&lt;executable&gt;</code>。您可以在部署专用主节点以启动 MPI 作业和一组专用计算节点以运行实际 MPI 进程的集群上使用此选项。</p>
<p><code>-hosts &lt;节点列表&gt;</code>：使用此选项指定应在其上运行 MPI 进程的特定<code>&lt;nodelist&gt;</code>。例如，以下命令在主机 host1 和 host2 上运行可执行文件 a.out：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec.hydra -n 2 -ppn 1 -hosts host1,host2 ./a.out</span><br></pre></td></tr></table></figure></p>
<p>注意如果<code>&lt;nodelist&gt;</code>仅包含一个节点，则此选项被解释为本地选项。有关详细信息，请参阅本地选项。</p>
<p><code>-iface &lt;interface&gt;</code>：使用此选项可选择适当的网络接口。例如，如果您的 InfiniBand* 网络的 IP 仿真配置为 ib0，您可以使用以下命令。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec.hydra -n 2 -iface ib0 ./a.out</span><br></pre></td></tr></table></figure><br>有关更多详细信息，请参阅<code>I_MPI_HYDRA_IFACE</code>环境变量。</p>
<p><code>-demux &lt;mode&gt;</code><br>使用此选项可为多个 I/O 设置轮询模式。默认值为轮询。</p>
<ul>
<li><code>&lt;spec&gt;</code>定义多个 I/O 的轮询模式</li>
<li><code>poll</code>设置 poll 为轮询方式。这是默认值。</li>
<li><code>select</code>：select 作为轮询模式。</li>
</ul>
<p>有关更多详细信息，请参阅<code>I_MPI_HYDRA_DEMUX</code>环境变量。</p>
<p><code>-enable-x</code>或<code>-disable-x</code>：使用此选项来控制 Xlib* 流量转发。默认值为<code>-disable-x</code>，表示不转发Xlib 流量。</p>
<p><code>-l</code>,<code>-prepend-rank</code>：使用此选项可在写入标准输出的所有行的开头插入 MPI 进程编号。</p>
<p><code>-ilp64</code>：使用此选项预加载 ILP64 接口。</p>
<p><code>-s &lt;规格&gt;</code>：使用此选项将标准输入定向到指定的 MPI 进程。</p>
<ul>
<li><code>&lt;spec&gt;</code>定义 MPI 进程等级</li>
<li><code>all</code>使用所有进程。</li>
<li><code>none</code>不要将标准输出定向到任何进程。</li>
<li><code>&lt;l&gt;</code>,<code>&lt;m&gt;</code>,<code>&lt;n&gt;</code>指定一个确切的列表并仅使用进程<code>&lt;l&gt;</code>、<code>&lt;m&gt;</code>和<code>&lt;n&gt;</code>。默认的值为零。</li>
<li><code>&lt;k&gt;</code>,<code>&lt;l&gt;-&lt;m&gt;</code>,<code>&lt;n&gt;</code>指定范围并使用进程<code>&lt;k&gt;</code>、<code>&lt;l&gt;</code>到<code>&lt;m&gt;</code>和<code>&lt;n&gt;</code>。</li>
</ul>
<p><code>-noconf</code>：使用此选项可禁用对 mpiexec.hydra 配置文件的处理。</p>
<p><code>-ordered-output</code>：使用此选项可避免混合来自 MPI 进程的数据输出。此选项影响标准输出和标准错误流。注意 使用此选项时，每个进程的最后输出行以行尾 ‘\n’ 字符结束。否则应用程序可能会停止响应。</p>
<p><code>-path &lt;目录&gt;</code>：使用此选项指定可执行文件的路径。</p>
<p><code>-tmpdir &lt;目录&gt;</code>：使用此选项为临时文件设置目录。有关更多详细信息，请参阅<code>I_MPI_TMPDIR</code>环境变量。</p>
<p><code>-version</code>或<code>-V</code>：使用此选项显示英特尔® MPI 库的版本。</p>
<p><code>-info</code>：使用此选项可显示英特尔® MPI 库的构建信息。使用此选项时，将忽略其他命令行参数。</p>
<p><code>-localhost</code>：使用此选项可显式指定启动节点的本地主机名。</p>
<p><code>-rmk &lt;RMK&gt;</code>：使用此选项可选择要使用的资源管理内核。英特尔® MPI 库仅支持 pbs。有关更多详细信息，请参阅<code>I_MPI_HYDRA_RMK</code>环境变量。</p>
<p><code>-outfile-pattern &lt;文件&gt;</code>：使用此选项将标准输出重定向到指定的文件。</p>
<p><code>-errfile-pattern &lt;文件&gt;</code>：使用此选项将 stderr 重定向到指定的文件。</p>
<p><code>-gpath &lt;路径&gt;</code>：使用此选项指定可执行文件的路径。</p>
<p><code>-gwdir &lt;目录&gt;</code>：使用此选项指定可执行文件运行的工作目录。</p>
<p><code>-gumask &lt;umask&gt;</code>：使用此选项为远程可执行文件执行<code>umask &lt;umask&gt;</code>命令。</p>
<p><code>-gdb-ia</code>：使用此选项可在特定于英特尔® 架构的 GNU* 调试器下运行进程。</p>
<p><code>-prepend-pattern</code>：使用此选项可指定前置到进程输出的模式。</p>
<p><code>-verbose</code>或<code>-v</code>：使用此选项从 mpiexec.hydra 打印调试信息，例如：</p>
<ul>
<li>服务进程参数</li>
<li>为启动应用程序传递的环境变量和参数</li>
<li>作业生命周期中的 PMI 请求/响应</li>
</ul>
<p>有关更多详细信息，请参阅<code>I_MPI_HYDRA_DEBUG</code>环境变量。</p>
<p><code>-print-rank-map</code>：使用此选项打印出 MPI 编号映射。</p>
<p><code>-print-all-exitcodes</code>：使用此选项打印所有进程的退出代码。</p>
<p><code>-bootstrap &lt;引导服务器&gt;</code>：使用此选项可选择要使用的内置引导服务器。引导服务器是系统提供的基本远程节点访问机制。 Hydra 支持多个运行时引导服务器，例如 ssh、rsh、pdsh、fork、persist、slurm、ll、lsf 或 sge，以启动 MPI 进程。默认引导服务器是 ssh。通过选择 slurm、ll、lsf 或 sge，您可以使用相应的 srun、llspawn.stdio、blaunch 或 qrsh 内部作业调度程序实用程序在各自选定的作业调度程序（Slurm<em>、LoadLeveler</em>、LSF<em> 和SGE</em>）。</p>
<ul>
<li><code>&lt;arg&gt;</code>字符串参数</li>
<li><code>ssh</code>使用安全shell。这是默认值。</li>
<li><code>rsh</code>使用远程shell。</li>
<li><code>pdsh</code> 使用并行分布式shell。</li>
<li><code>pbs</code> 使用 Torque* pbsdsh。</li>
<li><code>pbsdsh</code> pbs bootstrap的别名。</li>
<li><code>fork</code> 使用fork调用。</li>
<li><code>persist</code> 使用Hydra服务</li>
<li><code>slurm</code> 使用Slurm* srun。</li>
<li><code>ll</code> 使用LoadLeveler* llspawn.stdio。</li>
<li><code>lsf</code> 使用LSF blaunch。</li>
<li><code>sge</code> 使用Univa<em> Grid Engine</em> qrsh。</li>
</ul>
<p><code>-bootstrap-exec &lt;引导服务器&gt;</code>：使用此选项可将可执行文件设置为用作引导服务器。默认引导服务器是 ssh。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec.hydra -bootstrap-exec &lt;bootstrap_server_executable&gt; -f hosts -env &lt;VAR1&gt; &lt;VAL1&gt; -n 2 ./a.out</span><br></pre></td></tr></table></figure></p>
<p>有关更多详细信息，请参阅<code>I_MPI_HYDRA_BOOTSTRAP</code>。</p>
<p><code>-bootstrap-exec-args &lt;args&gt;</code>：使用此选项为引导服务器可执行文件提供附加参数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec.hydra -bootstrap-exec-args &lt;参数&gt; -n 2 ./a.out</span><br></pre></td></tr></table></figure></p>
<p>要与 Slurm* 调度程序紧密集成（包括对挂起/恢复的支持），请使用 Slurm 页面上概述的方法：<a href="http://www.schedmd.com/slurmdocs/mpi_guide.html#intel_mpi。有关更多详细信息，请参阅`I_MPI_HYDRA_BOOTSTRAP_EXEC_EXTRA_ARGS`。">http://www.schedmd.com/slurmdocs/mpi_guide.html#intel_mpi。有关更多详细信息，请参阅`I_MPI_HYDRA_BOOTSTRAP_EXEC_EXTRA_ARGS`。</a></p>
<p><code>-v6</code>：使用此选项可强制使用 IPv6 协议。</p>
<h2 id="Local-Hydra-Options"><a href="#Local-Hydra-Options" class="headerlink" title="Local Hydra Options"></a>Local Hydra Options</h2><p>本节介绍英特尔® MPI 库的 Hydra 进程管理器的本地选项。局部选项仅应用于指定它们的参数集。参数集由冒号“:”分隔。</p>
<p><code>-n &lt;进程数&gt;</code>或<code>-np &lt;进程数&gt;</code>：使用此选项可设置使用当前参数集运行的 MPI 进程数。</p>
<p><code>-env &lt;envar&gt; &lt;value&gt;</code>：使用此选项将<code>&lt;envar&gt;</code>环境变量设置为当前参数集中所有 MPI 进程的指定<code>&lt;value&gt;</code>。</p>
<p><code>-envall</code>：使用此选项可传播当前参数集中的所有环境变量。有关更多详细信息，请参阅<code>I_MPI_HYDRA_ENV</code>环境变量。</p>
<p><code>-envnone</code>：使用此选项可禁止将任何环境变量传播到当前参数集中的 MPI 进程。注意 该选项不适用于本地主机。</p>
<p><code>-envexcl &lt;list-of-envvar-names&gt;</code>：使用此选项可禁止将列出的环境变量传播到当前参数集中的 MPI 进程。</p>
<p><code>-envlist &lt;list&gt;</code>：使用此选项可传递带有当前值的环境变量列表。<code>&lt;list&gt;</code>是要发送到 MPI 进程的环境变量的逗号分隔列表。</p>
<p><code>-host &lt;nodename&gt;</code>：使用此选项指定要在其上运行 MPI 进程的特定<code>&lt;nodename&gt;</code>。 例如，以下命令在主机 host1 和 host2 上执行 a.out：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec.hydra -n 2 -host host1 ./a.out : -n 2 -host host2 ./a.out</span><br></pre></td></tr></table></figure></p>
<p><code>-path &lt;dir&gt;</code>：使用此选项指定要在当前参数集中运行的<code>&lt;executable&gt;</code>文件的路径。</p>
<p><code>-wdir &lt;dir&gt;</code>：使用此选项指定<code>&lt;executable&gt;</code>文件在当前参数中运行的工作目录</p>
<h2 id="gtool-options"><a href="#gtool-options" class="headerlink" title="gtool options"></a>gtool options</h2><p><code>-gtool</code>：使用此选项可通过<code>mpiexec.hydra</code>和<code>mpirun</code>命令为指定进程启动英特尔® VTune™ Amplifier XE、英特尔® Advisor、Valgrind<em> 和 GDB</em>（GNU 调试器）等工具。 此选项的替代方法是<code>I_MPI_GTOOL</code>环境变量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-gtool &quot;&lt;command line for tool 1&gt;:&lt;ranks set 1&gt;[=launch mode 1][@arch 1]; </span><br><span class="line">        &lt;command line for tool 2&gt;:&lt;ranks set 2&gt;[=exclusive][@arch 2]; </span><br><span class="line">        … ;</span><br><span class="line">        &lt;command line for tool n&gt;:&lt;ranks set n&gt;[=exclusive][@arch n]&quot; </span><br><span class="line">        &lt;executable&gt;</span><br></pre></td></tr></table></figure></p>
<p>or:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -n &lt;# of processes&gt; </span><br><span class="line">    -gtool &quot;&lt;command line for tool 1&gt;:&lt;ranks set 1&gt;[=launch mode 1][@arch 1]&quot; </span><br><span class="line">    -gtool &quot;&lt;command line for tool 2&gt;:&lt;ranks set 2&gt;[=launch mode 2][@arch 2]&quot; </span><br><span class="line">    …</span><br><span class="line">    -gtool &quot;&lt;command line for a tool n&gt;:&lt;ranks set n&gt;[=launch mode 3][@arch n]&quot; </span><br><span class="line">    &lt;executable&gt;</span><br></pre></td></tr></table></figure></p>
<p>在语法中，分隔符<code>;</code>和<code>-gtool</code>选项可以互换。</p>
<p>参数</p>
<ul>
<li><code>&lt;rank set&gt;</code>：指定工具执行中涉及的进程范围。用逗号分隔等级或使用“-”符号表示一组连续的进程。 要为所有进程运行该工具，请使用 all 参数。注意如果您指定了不正确的排名索引，则会打印相应的警告，并且该工具会继续为有效的排名工作。</li>
<li><code>[=launch mode]</code> 指定启动模式（可选）。 有关可用值，请参见下文。</li>
<li><code>[@arch]</code>指定工具运行的架构（可选）。对于给定的<code>&lt;rank set&gt;</code>，如果指定此参数，则仅为驻留在具有指定架构的主机上的进程启动该工具。该参数是可选的。注意相同<code>@arch</code>参数的进程集不能重叠。缺少<code>@arch</code>参数也被认为是不同的架构。因此，以下语法被认为是有效的：<code>-gtool &quot;gdb: 0-3=attach;gdb:0-3=attach@hsw;/usr/bin/gdb:0-3=attach@knl</code>。另外，请注意一些工具不能一起工作，或者同时使用它们可能会导致不正确的结果。</li>
</ul>
<p>下表列出了<code>[=launch mode]</code>的参数值。您可以为每个工具指定多个值，这些值用逗号“,”分隔。</p>
<ul>
<li><code>exclusive</code> 指定此值可防止工具在每个主机上启动超过一个进程。</li>
<li><code>attach</code> 指定此值以将工具从<code>-gtool</code>附加到可执行文件。如果您使用调试器或其他可以以调试器方式附加到进程的工具，则需要指定此值。此模式仅通过调试器进行了测试。</li>
<li><code>node-wide</code> 指定此值以将<code>-gtool</code>中的工具应用于<code>&lt;rank set&gt;</code>所在的所有进程或在所有进程的情况下应用于所有节点。也就是说，该工具应用于比可执行文件更高的级别（应用于 pmi_proxy 守护程序）。将<code>-remote</code>参数用于<code>rank</code>以仅在远程节点上使用该工具。</li>
</ul>
<p>以下示例演示了使用<code>-gtool</code>选项的不同场景。通过 mpirun 命令启动英特尔® VTune™ Amplifier XE 和 Valgrind*：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -n 16 -gtool &quot;vtune -collect hotspots -analyze-system \</span><br><span class="line">-r result1:5,3,7-9=exclusive@bdw;valgrind -log-file=log_%p:0,1,10-12@hsw&quot; a.out</span><br></pre></td></tr></table></figure></p>
<p>此命令为在代号为 Broadwell 的英特尔® 微架构上运行的进程启动 vtune。每个主机只启动一个 vtune 副本，索引最小的进程会受到影响。同时，为在代号为 Haswell 的英特尔® 微架构上运行的所有指定进程启动 Valgrind*。 Valgrind 的结果保存到文件<code>log_&lt;process ID&gt;</code>。</p>
<p>为不同的rank set设置不同的环境变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -n 16 -gtool &quot;env VARIABLE1=value1 VARIABLE2=value2:3,5,7-9; env VARIABLE3=value3:0,11&quot; a.out</span><br></pre></td></tr></table></figure></p>
<p>示例 3通过<code>-machinefile</code>选项为特定进程应用工具。<code>m_file</code>中有如下信息<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ./m_file</span><br><span class="line">hostname_1:2</span><br><span class="line">hostname_2:3</span><br><span class="line">hostname_3:1</span><br></pre></td></tr></table></figure></p>
<p>以下命令行演示了如何使用<code>-machinefile</code>选项来应用工具<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -n 6 -machinefile m_file -gtool &quot;vtune -collect hotspots -analyze-system \</span><br><span class="line">-r result1:5,3=exclusive@hsw;valgrind:0,1@bdw&quot; a.out</span><br></pre></td></tr></table></figure></p>
<p>在此示例中，使用<code>-machinefie</code>选项意味着索引为 0 和 1 的进程位于<code>hostname_1</code>机器上，进程 3 位于<code>hostname_2</code>机器上，而进程 5 位于<code>hostname_3</code>机器上。之后，如果<code>hostname_2</code>和<code>hostname_3</code>机器具有代号为Haswell 的英特尔® 微架构，则vtune 仅应用于rank 3 和5（因为这些rank属于不同的机器，所以exclusive 选项匹配它们）。同时，Valgrind* 工具适用于在<code>hostname_1</code>机器上分配的两个进程，以防它具有代号为 Broadwell 的英特尔® 微架构。</p>
<p><code>-gtoolfile &lt;gtool_config_file&gt;</code>：使用此选项在配置文件中指定<code>-gtool</code>参数。所有相同的规则都适用。此外，您可以使用分节符分隔不同的命令行。例如，如果<code>gtool_config_file</code>包含以下设置：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env VARIABLE1=value1 VARIABLE2=value2:3,5,7-9; env VARIABLE3=value3:0,11</span><br><span class="line">env VARIABLE4=value4:1,12</span><br></pre></td></tr></table></figure></p>
<p>以下命令为进程 3、5、7、8 和 9 设置<code>VARIABLE1</code>和<code>VARIABLE2</code>，并为进程 0 和 11 设置<code>VARIABLE3</code>，而为进程 1 和 12 设置<code>VARIABLE4</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -n 16 -gtoolfile gtool_config_file a.out</span><br></pre></td></tr></table></figure><br>注意选项和环境变量<code>-gtool</code>、<code>-gtoolfile</code>和<code>I_MPI_GTOOL</code>是互斥的。选项<code>-gtool</code>和<code>-gtoolfile</code>具有相同的优先级并且比<code>I_MPI_GTOOL</code>具有更高的优先级。命令行中的第一个指定选项有效，第二个被忽略。因此，如果您未指定<code>-gtool</code>或<code>-gtoolfile</code>，请使用<code>I_MPI_GTOOL</code>。</p>
<h2 id="cpuinfo"><a href="#cpuinfo" class="headerlink" title="cpuinfo"></a>cpuinfo</h2><p>提供有关系统中使用的处理器的信息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpuinfo [[-]&lt;选项&gt;]</span><br></pre></td></tr></table></figure></p>
<p><code>g</code>：关于单个集群节点的一般信息显示：</p>
<ul>
<li>处理器产品名称</li>
<li>节点上的包/套接字数</li>
<li>节点上和每个包内的核心和线程数</li>
<li>SMT 模式启用</li>
</ul>
<p><code>i</code>：逻辑处理器标识表，相应地标识每个逻辑处理器的线程、内核和包。</p>
<ul>
<li>ThreadId - 内核中的唯一处理器标识符。</li>
<li>CoreId - 包内的唯一核心标识符。</li>
<li>PackageId - 节点内的唯一包标识符。</li>
</ul>
<p><code>d</code>：节点分解表显示节点内容。每个条目都包含有关包、内核和逻辑处理器的信息。</p>
<ul>
<li>包裹ID - 物理包裹标识符。</li>
<li>内核 ID - 属于此包的内核标识符列表。</li>
<li>处理器ID - 属于该包的处理器列表。这个列表顺序直接对应于核心列表。括号中的一组处理器属于一个内核。</li>
</ul>
<p><code>c</code>：逻辑处理器的缓存共享显示共享特定缓存级别的大小和处理器组的信息。</p>
<ul>
<li>大小——以字节为单位的缓存大小。</li>
<li>处理器- 括在括号中的处理器组列表，它们共享此缓存或不共享其他缓存。</li>
</ul>
<p><code>s</code>：微处理器签名十六进制字段（英特尔平台符号）显示签名值：</p>
<ul>
<li>extended family</li>
<li>extended model</li>
<li>family</li>
<li>model</li>
<li>type</li>
<li>stepping</li>
</ul>
<p><code>f</code>：微处理器功能标志指示微处理器支持哪些功能。使用 Intel 平台符号。</p>
<p><code>n</code>：表显示了有关 NUMA 节点的以下信息：</p>
<ul>
<li>NUMA Id - NUMA 节点标识符。</li>
<li>处理器 - 此节点中的处理器列表。</li>
<li>如果节点没有处理器，则不会显示该节点。</li>
</ul>
<p>cpuinfo 实用程序打印出可用于定义合适的进程固定设置的处理器体系结构信息。输出由多个表组成。每个表对应于参数表中列出的单个选项之一。</p>
<p>cpuinfo 实用程序可用于 Intel 微处理器和非 Intel 微处理器，但它可能仅提供有关非 Intel 微处理器的部分信息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ cpuinfo -gdcs</span><br><span class="line">===== Processor composition =====</span><br><span class="line">Processor name : Intel(R) Xeon(R) X5570</span><br><span class="line">Packages(sockets) : 2</span><br><span class="line">Cores : 8</span><br><span class="line">Processors(CPUs) : 8</span><br><span class="line">Cores per package : 4</span><br><span class="line">Threads per core : 1</span><br><span class="line">===== Processor identification =====</span><br><span class="line">Processor Thread Id. Core Id. Package Id.</span><br><span class="line">0         0          0        0</span><br><span class="line">1         0          0        1</span><br><span class="line">2         0          1        0</span><br><span class="line">3         0          1        1</span><br><span class="line">4         0          2        0</span><br><span class="line">5         0          2        1</span><br><span class="line">6         0          3        0</span><br><span class="line">7         0          3        1</span><br><span class="line">===== Placement on packages =====</span><br><span class="line">Package Id. Core Id. Processors</span><br><span class="line">0           0,1,2,3  0,2,4,6</span><br><span class="line">1           0,1,2,3  1,3,5,7</span><br><span class="line">===== Cache sharing =====</span><br><span class="line">Cache Size   Processors</span><br><span class="line">L1    32 KB  no sharing</span><br><span class="line">L2    256 KB no sharing</span><br><span class="line">L3    8 MB   (0,2,4,6)(1,3,5,7)</span><br><span class="line">===== Processor Signature =====</span><br><span class="line">_________ ________ ______ ________ _______ __________</span><br><span class="line">| xFamily | xModel | Type | Family | Model | Stepping |</span><br><span class="line">|_________|________|______|________|_______|__________|</span><br><span class="line">| 00      | 1      | 0    | 6      | a     | 5        |</span><br><span class="line">|_________|________|______|________|_______|__________|</span><br></pre></td></tr></table></figure></p>
<h2 id="impi-info"><a href="#impi-info" class="headerlink" title="impi_info"></a>impi_info</h2><p>提供有关可用英特尔® MPI 库环境变量的信息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impi_info &lt;选项&gt;</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li><code>-a | -all</code>：显示所有 IMPI 变量。</li>
<li><code>-h | -help</code>：显示帮助信息。</li>
<li><code>-v | -variable</code>：显示所有可用变量或指定变量的描述。</li>
<li><code>-c | -category</code>：显示指定类别的所有可用类别或变量。</li>
<li><code>-e | -expert</code>：显示所有专家变量。</li>
</ul>
<p>impi_info 实用程序提供有关英特尔 MPI 库中可用环境变量的信息。 对于每个变量，它打印出名称、默认值和值数据类型。 默认情况下，会显示一个简化的变量列表。 使用 -all 选项显示所有可用变量及其说明。 impi_info 输出示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./impi_info</span><br><span class="line">| NAME                 | DEFAULT VALUE | DATA TYPE |</span><br><span class="line">====================================================</span><br><span class="line">| I_MPI_THREAD_SPLIT   | 0             | MPI_INT   |</span><br><span class="line">| I_MPI_THREAD_RUNTIME | none          | MPI_CHAR  |</span><br><span class="line">| I_MPI_THREAD_MAX     | -1            | MPI_INT   |</span><br><span class="line">| I_MPI_THREAD_ID_KEY  | thread_id     | MPI_CHAR  |</span><br></pre></td></tr></table></figure></p>
<h2 id="mpitune"><a href="#mpitune" class="headerlink" title="mpitune"></a>mpitune</h2><p>为给定的 MPI 应用程序调整英特尔® MPI 库参数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpitune &lt;options&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>-c | --config-file &lt;file&gt;</code>指定一个配置文件来运行一个调整会话。</li>
<li><code>-d | --dump-file &lt;file&gt;</code>指定存储收集结果的文件。 该选项用于分析模式。</li>
<li><code>-m | --mode &#123;collect | analyze&#125;</code> 指定 mpitune 模式。 支持的模式是收集和分析：<ul>
<li>收集模式运行调整过程并将结果保存在临时文件中；</li>
<li>分析模式将临时文件转换为英特尔 MPI 库使用的 JSON 树，并生成一个表，以人类可读的格式表示算法值。</li>
</ul>
</li>
<li><code>-h | --help</code>显示帮助信息。</li>
<li><code>-v | --version</code>显示产品版本。</li>
</ul>
<p>mpitune 实用程序允许您根据集群配置或应用程序自动调整英特尔 MPI 库参数，例如集合操作算法。</p>
<p>tuner迭代地启动具有不同配置的基准测试应用程序，以测量性能并存储每次启动的结果。基于这些结果，tuner为被调优的参数生成最佳值。</p>
<p>注意从英特尔 MPI 库 2019 更新 4 版本开始，您必须指定两个 mpitune 配置文件，它们的模式和转储文件字段不同。一种更简单的替代方法是使用英特尔 MPI 库附带的单个配置文件模板之一。在这种情况下，您必须使用命令行来定义模式和转储文件字段。</p>
<ul>
<li><code>-mode</code>选项定义两种可能的 MPI 调优模式之一：收集或分析。</li>
<li><code>-dump-file</code>选项定义处于分析模式时临时文件的路径。该路径在第一次迭代后由 mpitune 返回。</li>
</ul>
<p>配置文件应指定所有tuner参数，这些参数通过<code>--config-file</code>选项传递给调优器。典型的配置文件由主要部分、指定通用选项和特定库参数的搜索空间部分（例如，用于特定集合操作）组成。要注释一行，请使用#。<code>&lt;installdir&gt;/etc/tune_cfg</code>中提供了所有配置文件示例。请注意，英特尔® MPI 基准测试的配置文件已经创建。调优过程包括两个步骤：数据收集（收集模式）和数据分析（分析模式）：</p>
<ul>
<li><code>$ mpitune -m collect -c &lt;path-to-config-file2&gt;</code></li>
<li><code>$ mpitune -m analyze -c &lt;path-to-config-file1&gt;</code></li>
</ul>
<p>另一个变体是：</p>
<ul>
<li><code>$ mpitune -m analyze -c &lt;path-to-config-file1&gt;</code></li>
</ul>
<p>其中第一步中接收到的转储文件的路径在包含模板的配置文件中使用。调整结果以 JSON 树的形式呈现，可以使用<code>I_MPI_TUNING</code>环境变量添加到库中。</p>
<p>以下选项也可以用：</p>
<ul>
<li><code>-f &lt;filename&gt;</code>指定包含主机名的文件。</li>
<li><code>-hosts &lt;hostlist&gt;</code>指定以逗号分隔的主机列表。</li>
<li><code>-np &lt;value&gt;</code>指定进程数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mpitune -np 2 -ppn 1 -hosts HOST1,HOST2 -m collect -c &lt;path-to-config-file2&gt;</span><br><span class="line">$ mpitune -np 2 -ppn 1 -hosts HOST1,HOST2 -m analyze -c &lt;path-to-config-file1&gt;</span><br></pre></td></tr></table></figure>
<h3 id="mpitune-Configuration-Options"><a href="#mpitune-Configuration-Options" class="headerlink" title="mpitune Configuration Options"></a>mpitune Configuration Options</h3><h4 id="Application-Options"><a href="#Application-Options" class="headerlink" title="Application Options"></a>Application Options</h4><p><code>-app</code>：为要启动的命令行设置模板以收集调整结果。命令行可以包含声明为<code>@&lt;var_name&gt;@</code>的变量。使用其他选项进一步定义变量。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-app: mpirun -np @np@ -ppn @ppn@ IMB-MPI1 -msglog 0:@logmax@ -npmin @np@ @func@</span><br></pre></td></tr></table></figure></p>
<p>注意应用程序必须产生输出（在标准输出或文件或任何其他目标中），调优器可以解析这些输出以选择要调整的值和其他变量。有关详细信息，请参阅下面的<code>-app-regex</code>和<code>-appregex-legend</code>选项。</p>
<p><code>-app-regex</code>：设置要计算的正则表达式以从应用程序输出中提取所需的值。使用正则表达式组将值分配给变量。变量和组关联使用<code>-app-regex-legend</code>选项设置。例如，要从此输出中提取<code>#bytes</code>和<code>t_max[usec]</code> 值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#bytes #repetitions t_min[usec] t_max[usec] t_avg[usec]</span><br><span class="line">0      1000         0.06        0.06        0.06</span><br><span class="line">1      1000         0.10        0.10        0.10</span><br></pre></td></tr></table></figure></p>
<p>使用以下配置：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-app-regex: (\d+)\s+\d+\s+[\d.+-]+\s+([\d.+-]+)</span><br></pre></td></tr></table></figure></p>
<p><code>-app-regex-legend</code>指定从正则表达式中提取的变量列表。变量对应于正则表达式组。调优器使用最后一个变量作为启动的性能指标。使用<code>-tree-opt</code>设置指标的优化方向。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-app-regex-legend: size, time</span><br></pre></td></tr></table></figure></p>
<p><code>-iter</code>使用一组给定的参数设置每次启动的迭代次数。更多的迭代次数会提高结果的准确性。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-iter: 3</span><br></pre></td></tr></table></figure></p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><h2 id="编译环境变量"><a href="#编译环境变量" class="headerlink" title="编译环境变量"></a>编译环境变量</h2><p><code>I_MPI_&#123;CC,CXX,FC,F77,F90&#125;_PROFILE</code>指定默认的分析库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_CC_PROFILE=&lt;profile-name&gt;</span><br><span class="line">I_MPI_CXX_PROFILE=&lt;profile-name&gt;</span><br><span class="line">I_MPI_FC_PROFILE=&lt;profile-name&gt;</span><br><span class="line">I_MPI_F77_PROFILE=&lt;profile-name&gt;</span><br><span class="line">I_MPI_F90_PROFILE=&lt;profile-name&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;profile-name&gt;</code>指定默认的分析库。</p>
<p>设置此环境变量以选择默认使用的特定 MPI 分析库。这与使用<code>-profile=&lt;profile-name&gt;</code>作为 mpiicc 或其他英特尔® MPI 库编译器包装器的参数具有相同的效果。</p>
<p><code>I_MPI_TRACE_PROFILE</code>为<code>-trace</code>选项指定默认配置文件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_TRACE_PROFILE=&lt;profile-name&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;profile-name&gt;</code>指定跟踪profile-name。默认值为 vt。设置此环境变量以选择要与<code>mpiicc</code>的<code>-trace</code>选项或其他英特尔 MPI 库编译器包装器一起使用的特定 MPI 分析库。<code>I_MPI_&#123;CC,CXX,F77,F90&#125;_PROFILE</code>环境变量覆盖<code>I_MPI_TRACE_PROFILE</code>。</p>
<p><code>I_MPI_CHECK_PROFILE</code>为<code>-check_mpi</code>选项指定默认配置文件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_CHECK_PROFILE=&lt;profile-name&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;profile-name&gt;</code>指定检查profile-name。默认值为<code>vtmc</code>。设置此环境变量以选择特定 MPI 检查库，以与 mpiicc 或其他英特尔 MPI 库编译器包装器的<code>-check_mpi</code>选项一起使用。<code>I_MPI_&#123;CC,CXX,F77,F90&#125;_PROFILE</code>环境变量覆盖<code>I_MPI_CHECK_PROFILE</code>。</p>
<p><code>I_MPI_CHECK_COMPILER</code>打开/关闭编译器兼容性检查。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_CHECK_COMPILER=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li>enable  |yes | on | 1 启用检查编译器。</li>
<li>disable |no| off | 0 禁用检查编译器。这是默认值。</li>
</ul>
<p>如果<code>I_MPI_CHECK_COMPILER</code>设置为启用，英特尔 MPI 库编译器包装器会检查底层编译器的兼容性。正常编译需要使用已知版本的底层编译器。</p>
<p><code>I_MPI_&#123;CC,CXX,FC,F77,F90&#125;</code>设置要使用的底层编译器的路径/名称。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_CC=&lt;compiler&gt;</span><br><span class="line">I_MPI_CXX=&lt;compiler&gt;</span><br><span class="line">I_MPI_FC=&lt;compiler&gt;</span><br><span class="line">I_MPI_F77=&lt;compiler&gt;</span><br><span class="line">I_MPI_F90=&lt;compiler&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;compiler&gt;</code>指定要使用的编译器的完整路径/名称。设置此环境变量以选择要使用的特定编译器。如果编译器不在搜索路径中，请指定编译器的完整路径。注意某些编译器可能需要额外的命令行选项。注意 如果配置文件存在于指定的编译器中，则该配置文件是源文件。有关详细信息。</p>
<p><code>I_MPI_ROOT</code>设置英特尔 MPI 库安装目录路径。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_ROOT=&lt;path&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;path&gt;</code>指定英特尔 MPI 库的安装目录。设置此环境变量以指定英特尔 MPI 库的安装目录。注意如果您使用的是 Visual Studio 集成，则可能需要使用<code>I_MPI_ONEAPI_ROOT</code>。</p>
<p><code>VT_ROOT</code>设置英特尔® Trace Collector 安装目录路径。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VT_ROOT=&lt;path&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;path&gt;</code>指定 Intel Trace Collector 的安装目录。设置此环境变量以指定 Intel Trace Collector 的安装目录。</p>
<p><code>I_MPI_COMPILER_CONFIG_DIR</code>设置编译器配置文件的位置。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_COMPILER_CONFIG_DIR=&lt;path&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;path&gt;</code>指定编译器配置文件的位置。默认值为<code>&lt;install-dir&gt;/etc</code>。设置此环境变量以更改编译器配置文件的默认位置。</p>
<p><code>I_MPI_LINK</code>选择特定版本的英特尔 MPI 库进行链接。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_LINK=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>opt</code>多线程优化库（带全局锁）。这是默认值</li>
<li><code>dbg</code>多线程调试库（带全局锁）</li>
<li><code>opt_mt</code>多线程优化库（线程拆分模型具有每个对象的锁）</li>
<li><code>dbg_mt</code>多线程调试库（线程拆分模型具有每个对象的锁）</li>
</ul>
<p>将此变量设置为始终链接到英特尔 MPI 库的指定版本。</p>
<p><code>I_MPI_DEBUG_INFO_STRIP</code>在静态链接应用程序时打开/关闭调试信息剥离。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_DEBUG_INFO_STRIP=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li>enable  |yes | on | 1 启用。这是默认值。</li>
<li>disable |no| off | 0 禁用。</li>
</ul>
<p>使用此选项可在静态链接英特尔 MPI 库时打开/关闭调试信息剥离。默认情况下会去除调试信息。</p>
<p><code>I_MPI_&#123;C,CXX,FC,F&#125;FLAGS</code>设置编译所需的特殊标志。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_CFLAGS=&lt;flag&gt;</span><br><span class="line">I_MPI_CXXFLAGS=&lt;flag&gt;</span><br><span class="line">I_MPI_FCFLAGS=&lt;flag&gt;</span><br><span class="line">I_MPI_FFLAGS=&lt;flag&gt;</span><br></pre></td></tr></table></figure></p>
<p>使用此环境变量来指定特殊的编译标志。</p>
<p><code>I_MPI_LDFLAGS</code>设置链接所需的特殊标志。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_LDFLAGS=&lt;flag&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>I_MPI_FORT_BIND</code>禁用 mpiicc 与 Fortran 绑定的链接。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_FORT_BIND=&lt;args&gt;</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li>enable  |yes | on | 1 启用。这是默认值。</li>
<li>disable |no| off | 0 禁用。</li>
</ul>
<p>默认情况下，即使不使用 Fortran，mpiicc 也会针对 Fortran 绑定进行链接。 使用此环境变量来更改此默认行为。 与<code>-nofortbind</code>选项具有相同的效果。</p>
<h2 id="Hydra-环境变量"><a href="#Hydra-环境变量" class="headerlink" title="Hydra 环境变量"></a>Hydra 环境变量</h2><p><code>I_MPI_HYDRA_HOST_FILE</code>设置主机文件以运行应用程序。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_HOST_FILE=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;hostsfile&gt;</code>主机文件的完整或相对路径</p>
<p><code>I_MPI_HYDRA_HOSTS_GROUP</code>使用方括号、逗号和破折号设置节点范围。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_HOSTS_GROUP=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<p>将此变量设置为能够使用方括号、逗号和破折号设置节点范围（如在 Slurm* 工作负载管理器中）。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_HOSTS_GROUP=&quot;hostA[01-05],hostB,hostC[01-05,07,09-11]&quot;</span><br></pre></td></tr></table></figure><br>您可以使用<code>-hosts-group</code>选项设置节点范围。</p>
<p><code>I_MPI_HYDRA_DEBUG</code>打印调试信息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_DEBUG=&lt;参数&gt;</span><br></pre></td></tr></table></figure></p>
<p>参数</p>
<ul>
<li>enable  |yes | on | 1 启用。</li>
<li>disable |no| off | 0 禁用。这是默认值。</li>
</ul>
<p><code>I_MPI_HYDRA_ENV</code>设置此环境变量以控制环境变量传播到 MPI 进程。默认情况下，整个启动节点环境传递给 MPI 进程。设置此变量还会覆盖远程 shell 设置的环境变量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_ENV=&lt;参数&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>all</code>将所有环境传递给所有 MPI 进程</li>
</ul>
<p><code>I_MPI_JOB_TIMEOUT</code>设置 mpiexec.hydra 的超时时间。以秒为单位定义 mpiexec.hydra 超时时间<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_JOB_TIMEOUT=&lt;timeout&gt;</span><br><span class="line">I_MPI_MPIEXEC_TIMEOUT=&lt;timeout&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;n&gt; ≥ 0</code> 超时时间的值。默认超时值为零，即意味着没有超时。</li>
</ul>
<p>设置此环境变量以使 mpiexec.hydra 在启动后<code>&lt;timeout&gt;</code>秒内终止作业。<code>&lt;timeout&gt;</code>值应大于零。否则环境变量设置将被忽略。</p>
<p><code>I_MPI_JOB_STARTUP_TIMEOUT</code>设置 mpiexec.hydra 作业启动超时。<code>&lt;timeout&gt;</code>以秒为单位定义 mpiexec.hydra 启动超时时间。如果某些进程未启动，则设置此环境变量以使 mpiexec.hydra 在<code>&lt;timeout&gt;</code>秒内终止作业。<code>&lt;timeout&gt;</code>值应大于零。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_JOB_STARTUP_TIMEOUT=&lt;timeout&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;n&gt; ≥ 0</code>超时时间的值。默认超时值为零，即意味着没有超时。</li>
</ul>
<p><code>I_MPI_JOB_TIMEOUT_SIGNAL</code>定义作业因超时而终止时要发送的信号。如果<code>I_MPI_JOB_TIMEOUT</code>环境变量指定的超时期限到期，则定义要发送的信号编号以停止 MPI 作业。 如果您设置了系统不支持的信号编号，则 mpiexec.hydra 命令会打印一条警告消息并使用默认信号编号 9 (SIGKILL) 继续终止任务。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_JOB_TIMEOUT_SIGNAL=&lt;number&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;n&gt; &gt; 0</code>信号编号。 默认值为 9（SIGKILL）</li>
</ul>
<p><code>I_MPI_JOB_ABORT_SIGNAL</code>定义当作业意外终止时要发送到所有进程的信号。设置此环境变量以定义任务终止的信号。 如果您设置了不受支持的信号编号，mpiexec.hydra 会打印一条警告消息并使用默认信号 9 (SIGKILL)。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_JOB_ABORT_SIGNAL=&lt;number&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;n&gt; &gt; 0</code>默认值为 9（SIGKILL）</li>
</ul>
<p><code>I_MPI_JOB_SIGNAL_PROPAGATION</code>控制信号传播。设置此环境变量以控制信号（SIGINT、SIGALRM 和 SIGTERM）的传播。 如果启用信号传播，则接收到的信号将发送到 MPI 作业的所有进程。 如果禁用信号传播，则 MPI 作业的所有进程都将使用默认信号 9 (SIGKILL) 停止。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_JOB_SIGNAL_PROPAGATION=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable | yes | on | 1 Turn on propagation</li>
<li>disable | no | off | 0 Turn off propagation. This is the default value</li>
</ul>
<p><code>I_MPI_HYDRA_BOOTSTRAP</code>设置引导服务器。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_BOOTSTRAP=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>ssh</code>Use secure shell. This is the default value</li>
<li><code>rsh</code>Use remote shell</li>
<li><code>pdsh</code> Use parallel distributed shell</li>
<li><code>pbsdsh</code> Use Torque<em> and PBS</em> pbsdsh command</li>
<li><code>fork</code> Use fork call</li>
<li><code>slurm</code> Use Slurm* srun command</li>
<li><code>ll</code> Use LoadLeveler* llspawn.stdio command</li>
<li><code>lsf</code> Use LSF* blaunch command</li>
<li><code>sge</code> Use Univa<em> Grid Engine</em> qrsh command</li>
</ul>
<p><code>I_MPI_HYDRA_BOOTSTRAP_EXEC</code>将可执行文件设置为用作引导服务器。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_BOOTSTRAP_EXEC=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;executable&gt;</code>可执行文件的名称</li>
</ul>
<p><code>I_MPI_HYDRA_BOOTSTRAP_EXEC_EXTRA_ARGS</code>为引导服务器设置其他参数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_BOOTSTRAP_EXEC_EXTRA_ARGS=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<p>设置此环境变量以指定引导服务器的其他参数。 注意如果启动器（blaunch、lsf、pdsh、pbsdsh）回退到 ssh，请通过调用 ssh 传递参数。</p>
<p><code>I_MPI_HYDRA_BOOTSTRAP_AUTOFORK</code>控制对本地进程的 fork 调用的使用。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_BOOTSTRAP_AUTOFORK = &lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable | yes | on | 1 对本地进程使用 fork。 这是 ssh、rsh、ll、lsf 和 pbsdsh 引导服务器的默认值</li>
<li>disable | no | off | 0 不要对本地进程使用 fork。 这是sge引导服务器的默认值</li>
</ul>
<p>设置此环境变量以控制本地进程对 fork 调用的使用。 注意此选项不适用于 slurm 和 pdsh 引导服务器。</p>
<p><code>I_MPI_HYDRA_RMK</code>使用指定值作为资源管理内核获取可用节点的数据，外部设置进程计数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_RMK=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;rmk&gt;</code> 资源管理内核。 支持的值为 slurm、ll、lsf、sge、pbs、cobalt。</li>
</ul>
<p><code>I_MPI_HYDRA_PMI_CONNECT</code>定义 PMI 消息的处理方法。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_PMI_CONNECT=&lt;value&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>nocache</code> 不缓存 PMI 消息</li>
<li><code>cache</code> 在本地 pmi_proxy 管理进程上缓存 PMI 消息，以最大限度地减少 PMI 请求的数量。 缓存的信息会自动传播到子管理进程。</li>
<li><code>lazy-cache</code> 按需传播。</li>
<li><code>alltoall</code> 信息在所有 pmi_proxy 之间自动交换，然后才能完成任何获取请求。 这是默认值。</li>
</ul>
<p>使用此环境变量来选择 PMI 消息处理方法。<code>I_MPI_PERHOST</code>定义<code>mpiexec.hydra</code>命令的<code>-perhost</code>选项的默认行为。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PERHOST=&lt;value&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;value&gt;</code>定义一个默认用于<code>-perhost</code>的值。</p>
<ul>
<li><code>integer &gt; 0</code> 选项的确切值</li>
<li><code>all</code> 节点上的所有逻辑 CPU</li>
<li><code>allcores</code> 节点上的所有内核（物理 CPU）。 这是默认值。</li>
</ul>
<p>设置此环境变量以定义<code>-perhost</code>选项的默认行为。 除非明确指定，否则<code>-perhost</code>选项隐含在<code>I_MPI_PERHOST</code>中设置的值中。 注意在作业调度程序下运行时，默认情况下会忽略此环境变量。 要使用<code>I_MPI_PERHOST</code>控制进程放置，请禁用<code>I_MPI_JOB_RESPECT_PROCESS_PLACEMENT</code>变量。</p>
<p><code>I_MPI_JOB_TRACE_LIBS</code>通过<code>-trace</code>选项选择要预加载的库。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_JOB_TRACE_LIBS=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;list&gt;</code>要预加载的库的空白分隔列表。 默认值为<code>vt</code>。</p>
<p>设置此环境变量以通过<code>-trace</code>选项选择用于预加载的替代库。</p>
<p><code>I_MPI_JOB_CHECK_LIBS</code>通过<code>-check_mpi</code>选项选择要预加载的库。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_JOB_CHECK_LIBS=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;list&gt;</code>要预加载的库的空白分隔列表。 默认值为<code>vtmc</code>。设置此环境变量以通过<code>-check_mpi</code>选项选择用于预加载的替代库。</p>
<p><code>I_MPI_HYDRA_BRANCH_COUNT</code>设置分层分支计数。设置此环境变量以限制由<code>mpiexec.hydra</code>操作或每个<code>pmi_proxy</code>管理进程启动的子管理进程的数量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_BRANCH_COUNT =&lt;num&gt;</span><br></pre></td></tr></table></figure></p>
<p>参数为<code>&lt;n&gt; &gt;= 0</code>。默认值为16。该值表示如果节点数大于16，则启用分层结构。如果<code>I_MPI_HYDRA_BRANCH_COUNT=0</code>，则不存在分层结构。 如果<code>I_MPI_HYDRA_BRANCH_COUNT=-1</code>，则分支计数等于默认值。</p>
<p><code>I_MPI_HYDRA_PMI_AGGREGATE</code>打开/关闭 PMI 消息的聚合。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_PMI_AGGREGATE=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable | yes | on | 1 启用 PMI 消息聚合。 这是默认值。</li>
<li>disable | no | off | 0 禁用 PMI 消息聚合。</li>
</ul>
<p><code>I_MPI_HYDRA_GDB_REMOTE_SHELL</code>设置远程 shell 命令以运行 GDB 调试器。 此命令使用 Intel® Distribution for GDB。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_GDB_REMOTE_SHELL=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>ssh Secure Shell (SSH). 这是默认值。</li>
<li>rsh Remote shell (RSH)</li>
</ul>
<p>设置此环境变量以指定远程 shell 命令以在远程机器上运行 GNU* 调试器。 您可以使用此环境变量来指定任何与 SSH 或 RSH 具有相同语法的 shell 命令。</p>
<p><code>I_MPI_HYDRA_IFACE</code>设置网络接口。设置此环境变量以指定要使用的网络接口。 例如，如果您的 InfiniBand* 网络的 IP 模拟是在 ib0 上配置的，则使用“-iface ib0”。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_IFACE=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;network interface&gt;</code>设置您系统中配置的网络接口。</p>
<p><code>I_MPI_HYDRA_DEMUX</code>设置解复用器（demux）模式。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_DEMUX=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>poll</code> 将 poll 设置为多 I/O 解复用器 (demux) 模式引擎。 这是默认值。</li>
<li><code>select</code> 将 select 设置为多 I/O 解复用器 (demux) 模式引擎</li>
</ul>
<p>设置此环境变量以指定多 I/O 解复用模式引擎。 默认值为轮询。</p>
<p><code>I_MPI_TMPDIR</code>指定一个临时目录。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_TMPDIR=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;path&gt;</code>临时目录。 默认值为<code>/tmp</code>。</li>
</ul>
<p>设置此环境变量以指定临时文件的目录。</p>
<p><code>I_MPI_JOB_RESPECT_PROCESS_PLACEMENT</code>指定是使用作业调度程序提供的 process-per-node 放置，还是显式设置。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_JOB_RESPECT_PROCESS_PLACEMENT=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable | yes | on | 1 使用作业调度程序提供的进程放置。 这是默认值</li>
<li>disable | no | off | 0 不要使用作业调度程序提供的进程放置</li>
</ul>
<p>如果设置了该变量，Hydra 管理器将使用作业调度程序提供的流程放置（默认）。 在这种情况下，<code>-ppn</code>选项及其等效项将被忽略。 如果禁用该变量，Hydra 进程管理器将使用带有<code>-ppn</code>或其等效项的进程放置集。</p>
<p><code>I_MPI_GTOOL</code>指定要为选定进程启动的工具。 此变量的替代方法是<code>-gtool</code>选项。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_GTOOL=&quot;</span><br><span class="line">    &lt;command line for a tool 1&gt;:&lt;ranks set 1&gt;[=exclusive][@arch 1]; </span><br><span class="line">    &lt;command line for a tool 2&gt;:&lt;ranks set 2&gt;[=exclusive][@arch 2]; … ;</span><br><span class="line">    &lt;command line for a tool n&gt;:&lt;ranks set n&gt;[=exclusive][@arch n]&quot;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;command-line-for-a-tool&gt;</code>指定工具的启动命令，包括参数。</li>
<li><code>&lt;rank set&gt;</code>指定工具执行中涉及的进程范围。 用逗号分隔等级或使用“-”符号表示一组连续的等级。 要为所有等级运行该工具，请使用 all 参数。 注意如果您指定了不正确的排名索引，则会打印相应的警告，并且该工具会继续为有效的排名工作。</li>
<li><code>[=exclusive]</code> 指定此参数可防止为每个主机启动超过一个等级的工具。 该参数是可选的。</li>
<li><code>[@arch]</code> 指定工具运行的架构（可选）。 对于给定的<code>&lt;rank set&gt;</code>，如果指定此参数，则仅为驻留在具有指定架构的主机上的进程启动该工具。 该参数是可选的。</li>
</ul>
<p>使用此选项可为指定进程启动英特尔® VTune™ Amplifier XE、Valgrind<em> 和 GNU</em> Debugger 等工具。</p>
<p>以下命令行示例演示了使用<code>I_MPI_GTOOL</code>环境变量的不同场景。 通过设置<code>I_MPI_GTOOL</code>环境变量启动英特尔® VTune™ Amplifier XE 和 Valgrind*：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export I_MPI_GTOOL=&quot;vtune -collect hotspots -analyze-system -r result1:5,3,7-9=exclusive@bdw; valgrind -log-file=log_%p:0,1,10-12@hsw&quot;</span><br><span class="line">$ mpiexec.hydra -n 16 a.out</span><br></pre></td></tr></table></figure></p>
<p>此命令为在代号为 Broadwell 的英特尔® 微架构上运行的进程启动 vtune。 每个主机只启动一个 vtune 副本，索引最小的进程会受到影响。 同时，为在代号为 Haswell 的英特尔® 微架构上运行的所有指定进程启动 Valgrind*。 Valgrind 的结果保存到文件<code>log_&lt;process ID&gt;</code>。 </p>
<p>通过设置<code>I_MPI_GTOOL</code>环境变量启动 GDB（对于英特尔® oneAPI，这将启动英特尔® GDB 分发版）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpiexec.hydra -n 16 -genv I_MPI_GTOOL=&quot;gdb:3,5,7-9&quot; a.out</span><br></pre></td></tr></table></figure></p>
<p>使用此命令将 GDB 应用于给定的进程集。</p>
<p>注意选项和环境变量<code>-gtool</code>、<code>-gtoolfile</code>和<code>I_MPI_GTOOL</code>是互斥的。 选项<code>-gtool</code>和<code>-gtoolfile</code>具有相同的优先级并且比<code>I_MPI_GTOOL</code>具有更高的优先级。 命令行中的第一个指定选项有效，第二个被忽略。 因此，如果您未指定<code>-gtool</code>或<code>-gtoolfile</code>，请使用<code>I_MPI_GTOOL</code>。</p>
<p><code>I_MPI_HYDRA_TOPOLIB</code>设置拓扑检测接口。设置这个环境变量来定义平台检测的接口。 默认情况下使用 hwloc* 接口，但您可以显式设置变量以使用本机英特尔 MPI 库接口<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_TOPOLIB=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>hwloc</code>：hwloc* 库函数被调用以进行拓扑检测。</li>
</ul>
<p><code>I_MPI_PORT_RANGE</code>指定允许的端口号范围。设置此环境变量以指定英特尔® MPI 库的允许端口号范围。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PORT_RANGE=&lt;range&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;min&gt;:&lt;max&gt;</code>允许的端口范围。</p>
<p><code>I_MPI_SILENT_ABORT</code>控制中止警告消息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SILENT_ABORT=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable | yes | on | 1 不打印中止警告消息</li>
<li>disable | no | off | 0 打印中止警告消息。 这是默认值</li>
</ul>
<p>设置此变量以禁用打印中止警告消息。 在<code>MPI_Abort</code>调用的情况下打印消息。 您还可以使用<code>-silent-abort</code>选项禁用这些消息的打印。</p>
<p><code>I_MPI_HYDRA_NAMESERVER</code>指定名称服务器。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_NAMESERVER=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;hostname&gt;:&lt;port&gt;</code>设置主机名和端口。</p>
<p>设置此变量以按以下格式为 MPI 应用程序指定名称服务器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HYDRA_NAMESERVER = hostname:port</span><br></pre></td></tr></table></figure></p>
<h2 id="I-MPI-ADJUST-Family-Environment-Variables"><a href="#I-MPI-ADJUST-Family-Environment-Variables" class="headerlink" title="I_MPI_ADJUST Family Environment Variables"></a>I_MPI_ADJUST Family Environment Variables</h2><p><code>I_MPI_ADJUST_&lt;opname&gt;</code>控制集合运算算法选择。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_ADJUST_&lt;opname&gt;=&quot;&lt;algid&gt;[:&lt;conditions&gt;][;&lt;algid&gt;:&lt;conditions&gt;[...]]&quot;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;algid&gt;</code>算法标识符<ul>
<li><code>&gt;= 0</code> 设置一个数字以选择所需的算法。 值 0 使用集合算法选择的基本逻辑。</li>
</ul>
</li>
<li><code>&lt;conditions&gt;</code> 逗号分隔的条件列表。 空列表选择所有消息大小和进程组合<ul>
<li><code>&lt;l&gt;</code>：<code>&lt;l&gt;</code>大小的消息</li>
<li><code>&lt;l&gt;-&lt;m&gt;</code>：大小从<code>&lt;l&gt;</code>到<code>&lt;m&gt;</code>的消息</li>
<li><code>&lt;l&gt;@&lt;p&gt;</code>：消息大小<code>&lt;l&gt;</code>和进程数<code>&lt;p&gt;</code></li>
<li><code>&lt;l&gt;-&lt;m&gt;@&lt;p&gt;-&lt;q&gt;</code>：消息大小从<code>&lt;l&gt;</code>到<code>&lt;m&gt;</code>，进程数从<code>&lt;p&gt;</code>到<code>&lt;q&gt;</code></li>
</ul>
</li>
</ul>
<p>设置此环境变量以在特定条件下为集合操作<code>&lt;opname&gt;</code>选择所需的算法。 每个集合操作都有自己的环境变量和算法。以下是各种集合操作及对应的算法</p>
<p><code>I_MPI_ADJUST_ALLGATHER</code>：<code>MPI_Allgather</code></p>
<ol>
<li>Recursive doubling</li>
<li>Bruck’s</li>
<li>Ring</li>
<li>Topology aware Gatherv + Bcast</li>
<li>Knomial</li>
</ol>
<p><code>I_MPI_ADJUST_ALLGATHERV</code>：<code>MPI_Allgatherv</code></p>
<ol>
<li>Recursive doubling</li>
<li>Bruck’s</li>
<li>Ring</li>
<li>Topology aware Gatherv + Bcast</li>
</ol>
<p><code>I_MPI_ADJUST_ALLREDUCE</code>：<code>MPI_Allreduce</code> </p>
<ol>
<li>Recursive doubling</li>
<li>Rabenseifner’s</li>
<li>Reduce + Bcast</li>
<li>Topology aware Reduce + Bcast</li>
<li>Binomial gather + scatter</li>
<li>Topology aware binominal gather + scatter</li>
<li>Shumilin’s ring</li>
<li>Ring</li>
<li>Knomial</li>
<li>Topology aware SHM-based flat</li>
<li>Topology aware SHM-based Knomial</li>
<li>Topology aware SHM-based Knary</li>
</ol>
<p><code>I_MPI_ADJUST_ALLTOALL</code>：<code>MPI_Alltoall</code></p>
<ol>
<li>Bruck’s</li>
<li>Isend/Irecv + waitall</li>
<li>Pair wise exchange</li>
<li>Plum’s</li>
</ol>
<p><code>I_MPI_ADJUST_ALLTOALLV</code>：<code>MPI_Alltoallv</code></p>
<ol>
<li>Isend/Irecv + waitall</li>
<li>Plum’s</li>
</ol>
<p><code>I_MPI_ADJUST_ALLTOALLW</code>：<code>MPI_Alltoallw</code></p>
<ol>
<li>Isend/Irecv + waitall</li>
</ol>
<p><code>I_MPI_ADJUST_BARRIER</code>：<code>MPI_Barrier</code> </p>
<ol>
<li>Dissemination</li>
<li>Recursive doubling</li>
<li>Topology aware dissemination</li>
<li>Topology aware recursive doubling</li>
<li>Binominal gather + scatter</li>
<li>Topology aware binominal gather + scatter</li>
<li>Topology aware SHM-based flat</li>
<li>Topology aware SHM-based Knomial</li>
<li>Topology aware SHM-based Knary</li>
</ol>
<p><code>I_MPI_ADJUST_BCAST</code>：<code>MPI_Bcast</code> </p>
<ol>
<li>Binomial</li>
<li>Recursive doubling</li>
<li>Ring</li>
<li>Topology aware binomial</li>
<li>Topology aware recursive doubling</li>
<li>Topology aware ring</li>
<li>Shumilin’s</li>
<li>Knomial</li>
<li>Topology aware SHM-based flat</li>
<li>Topology aware SHM-based Knomial</li>
<li>Topology aware SHM-based Knary</li>
<li>NUMA aware SHM-based (SSE4.2)</li>
<li>NUMA aware SHM-based (AVX2)</li>
<li>NUMA aware SHM-based (AVX512)</li>
</ol>
<p><code>I_MPI_ADJUST_EXSCAN</code>：<code>MPI_Exscan</code></p>
<ol>
<li>Partial results gathering</li>
<li>Partial results gathering regarding layout of processes</li>
</ol>
<p><code>I_MPI_ADJUST_GATHER</code>：<code>MPI_Gather</code> </p>
<ol>
<li>Binomial</li>
<li>Topology aware binomial</li>
<li>Shumilin’s</li>
<li>Binomial with segmentation</li>
</ol>
<p><code>I_MPI_ADJUST_GATHERV</code>：<code>MPI_Gatherv</code> </p>
<ol>
<li>Linear</li>
<li>Topology aware linear</li>
<li>Knomial</li>
</ol>
<p><code>I_MPI_ADJUST_REDUCE_SCATTER</code>：<code>MPI_Reduce_scatter</code></p>
<ol>
<li>Recursive halving</li>
<li>Pair wise exchange</li>
<li>Recursive doubling</li>
<li>Reduce + Scatterv</li>
<li>Topology aware Reduce + Scatterv</li>
</ol>
<p><code>I_MPI_ADJUST_REDUCE</code>：<code>MPI_Reduce</code> </p>
<ol>
<li>Shumilin’s</li>
<li>Binomial</li>
<li>Topology aware Shumilin’s</li>
<li>Topology aware binomial</li>
<li>Rabenseifner’s</li>
<li>Topology aware Rabenseifner’s</li>
<li>Knomial</li>
<li>Topology aware SHM-based flat</li>
<li>Topology aware SHM-based Knomial</li>
<li>Topology aware SHM-based Knary</li>
<li>Topology aware SHM-based binomial</li>
</ol>
<p><code>I_MPI_ADJUST_SCAN</code>：<code>MPI_Scan</code> </p>
<ol>
<li>Partial results gathering</li>
<li>Topology aware partial results gathering</li>
</ol>
<p><code>I_MPI_ADJUST_SCATTER</code>：<code>MPI_Scatter</code></p>
<ol>
<li>Binomial</li>
<li>Topology aware binomial</li>
<li>Shumilin’s</li>
</ol>
<p><code>I_MPI_ADJUST_SCATTERV</code>：<code>MPI_Scatterv</code> </p>
<ol>
<li>Linear</li>
<li>Topology aware linear</li>
</ol>
<p><code>I_MPI_ADJUST_SENDRECV_REPLACE</code>：<code>MPI_Sendrecv_replace</code></p>
<ol>
<li>Generic</li>
<li>Uniform (with restrictions)</li>
</ol>
<p><code>I_MPI_ADJUST_IALLGATHER</code>：<code>MPI_Iallgather</code> </p>
<ol>
<li>Recursive doubling</li>
<li>Bruck’s</li>
<li>Ring</li>
</ol>
<p><code>I_MPI_ADJUST_IALLGATHERV</code>：<code>MPI_Iallgatherv</code></p>
<ol>
<li>Recursive doubling</li>
<li>Bruck’s</li>
<li>Ring</li>
</ol>
<p><code>I_MPI_ADJUST_IALLREDUCE</code>：<code>MPI_Iallreduce</code></p>
<ol>
<li>Recursive doubling</li>
<li>Rabenseifner’s</li>
<li>Reduce + Bcast</li>
<li>Ring (patarasuk)</li>
<li>Knomial</li>
<li>Binomial</li>
<li>Reduce scatter allgather</li>
<li>SMP</li>
<li>Nreduce</li>
</ol>
<p><code>I_MPI_ADJUST_IALLTOALL</code>：<code>MPI_Ialltoall</code> </p>
<ol>
<li>Bruck’s</li>
<li>Isend/Irecv + Waitall</li>
<li>Pairwise exchange</li>
</ol>
<p><code>I_MPI_ADJUST_IALLTOALLV</code>：<code>MPI_Ialltoallv</code></p>
<ol>
<li>Isend/Irecv + Waitall</li>
</ol>
<p><code>I_MPI_ADJUST_IALLTOALLW</code>：<code>MPI_Ialltoallw</code></p>
<ol>
<li>Isend/Irecv + Waitall</li>
</ol>
<p><code>I_MPI_ADJUST_IBARRIER</code>：<code>MPI_Ibarrier</code></p>
<ol>
<li>Dissemination</li>
</ol>
<p><code>I_MPI_ADJUST_IBCAST</code>：`MPI_Ibcast</p>
<ol>
<li>Binomial</li>
<li>Recursive doubling</li>
<li>Ring</li>
<li>Knomial</li>
<li>SMP</li>
<li>Tree knominal</li>
<li>Tree kary</li>
</ol>
<p><code>I_MPI_ADJUST_IEXSCAN</code>：<code>MPI_Iexscan</code></p>
<ol>
<li>Recursive doubling</li>
<li>SMP</li>
</ol>
<p><code>I_MPI_ADJUST_IGATHER</code>：<code>MPI_Igather</code></p>
<ol>
<li>Binomial</li>
<li>Knomial</li>
</ol>
<p><code>I_MPI_ADJUST_IGATHERV</code>：<code>MPI_Igatherv</code> </p>
<ol>
<li>Linear</li>
<li>Linear ssend</li>
</ol>
<p><code>I_MPI_ADJUST_IREDUCE_SCATTER</code>：<code>MPI_Ireduce_scatter</code></p>
<ol>
<li>Recursive halving</li>
<li>Pairwise</li>
<li>Recursive doubling</li>
</ol>
<p><code>I_MPI_ADJUST_IREDUCE</code>：<code>MPI_Ireduce</code> </p>
<ol>
<li>Rabenseifner’s</li>
<li>Binomial</li>
<li>Knomial</li>
</ol>
<p><code>I_MPI_ADJUST_ISCAN</code>：`MPI_Iscan</p>
<ol>
<li>Recursive Doubling</li>
<li>SMP</li>
</ol>
<p><code>I_MPI_ADJUST_ISCATTER</code>：<code>MPI_Iscatter</code></p>
<ol>
<li>Binomial</li>
<li>Knomial</li>
</ol>
<p><code>I_MPI_ADJUST_ISCATTERV</code>：<code>MPI_Iscatterv</code></p>
<ol>
<li>Linear</li>
</ol>
<p>下表中描述了集合操作的消息大小计算规则。 下表中<code>n/a</code>表示对应区间<code>&lt;l&gt;-&lt;m&gt;</code>应省略。注意<code>I_MPI_ADJUST_SENDRECV_REPLACE=2</code>（“uniform”）算法只能在所有进程的数据类型和对象计数都相同的情况下使用。</p>
<ul>
<li><code>MPI_Allgather</code>：<code>recv_count*recv_type_size</code></li>
<li><code>MPI_Allgatherv</code>：<code>total_recv_count*recv_type_size</code></li>
<li><code>MPI_Allreduce</code>：<code>count*type_size</code></li>
<li><code>MPI_Alltoall</code>：<code>send_count*send_type_size</code></li>
<li><code>MPI_Alltoallv</code>：<code>n/a</code></li>
<li><code>MPI_Alltoallw</code>：<code>n/a</code></li>
<li><code>MPI_Barrier</code>：<code>n/a</code></li>
<li><code>MPI_Bcast</code>：<code>count*type_size</code></li>
<li><code>MPI_Exscan</code>：<code>count*type_size</code></li>
<li><code>MPI_Gather</code>：<ul>
<li><code>recv_count*recv_type_size</code> if MPI_IN_PLACE is used</li>
<li><code>send_count*send_type_size</code></li>
</ul>
</li>
<li><code>MPI_Gatherv</code>：<code>n/a</code></li>
<li><code>MPI_Reduce_scatter</code>：<code>total_recv_count*type_size</code></li>
<li><code>MPI_Reduce</code>：<code>count*type_size</code></li>
<li><code>MPI_Scan</code>：<code>count*type_size</code></li>
<li><code>MPI_Scatter</code>：<ul>
<li><code>send_count*send_type_size</code> if MPI_IN_PLACE is used,</li>
<li><code>recv_count*recv_type_size</code></li>
</ul>
</li>
<li><code>MPI_Scatterv</code>：<code>n/a</code></li>
</ul>
<p>使用以下设置为<code>MPI_Reduce</code>操作选择第二个算法：<code>I_MPI_ADJUST_REDUCE=2</code>使用以下设置来定义<code>MPI_Reduce_scatter</code>操作的算法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_ADJUST_REDUCE_SCATTER=&quot;4:0-100,5001-10000;1:101-3200;2:3201-5000;3&quot;</span><br></pre></td></tr></table></figure><br>在这种情况下。 算法4用于0~100字节和5001~10000字节的消息大小，算法1用于101~3200字节的消息大小，算法2用于3201~5000字节的消息大小，算法 3 用于所有其他消息。</p>
<p><code>I_MPI_ADJUST_&lt;opname&gt;_LIST</code>设置此环境变量以指定英特尔 MPI 运行时为指定的<code>&lt;opname&gt;</code>考虑的算法集。此变量在自动调整方案以及用户希望选择特定算法子集的调整方案中很有用。注意设置空字符串会禁用<code>&lt;opname&gt;</code>集合的自动调整。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_ADJUST_&lt;opname&gt;_LIST=&lt;algid1&gt;[-&lt;algid2&gt;][,&lt;algid3&gt;][,&lt;algid4&gt;-&lt;algid5&gt;]</span><br></pre></td></tr></table></figure></p>
<p><code>I_MPI_COLL_INTRANODE</code>设置此环境变量以切换节点内通信类型以进行集合操作。如果有大量的通信器，您可以关闭 SHM 集合以避免内存过度消耗。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_COLL_INTRANODE=&lt;mode&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>pt2pt</code> 仅使用基于点对点通信的集合</li>
<li><code>shm</code> 启用共享内存集合。 这是默认值</li>
</ul>
<p><code>I_MPI_COLL_INTRANODE_SHM_THRESHOLD</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_COLL_INTRANODE_SHM_THRESHOLD=&lt;nbytes&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;nbytes&gt;</code>定义共享内存集合处理的最大数据块大小。</p>
<ul>
<li><code>&gt; 0</code>使用指定的大小。 默认值为 16384 字节。</li>
</ul>
<p>设置此环境变量以定义每个进程可用于数据放置的共享内存区域的大小。 大于这个值的消息将不会被基于 SHM 的集合操作处理，而是会被基于点对点的集合操作处理。 该值必须是 4096 的倍数。</p>
<p><code>I_MPI_COLL_EXTERNAL</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_COLL_EXTERNAL=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable | yes | on | 1 启用外部集合操作功能。</li>
<li>disable | no | off | 0 禁用外部集合操作功能。 这是默认的</li>
</ul>
<p>设置此环境变量以启用外部集合操作。 该机制允许启用 HCOLL。 该功能启用以下集合操作：</p>
<ul>
<li><code>I_MPI_ADJUST_ALLREDUCE=24</code></li>
<li><code>I_MPI_ADJUST_BARRIER=11</code></li>
<li><code>I_MPI_ADJUST_BCAST=16</code></li>
<li><code>I_MPI_ADJUST_REDUCE=13</code></li>
<li><code>I_MPI_ADJUST_ALLGATHER=6</code></li>
<li><code>I_MPI_ADJUST_ALLTOALL=5</code></li>
<li><code>I_MPI_ADJUST_ALLTOALLV=5</code></li>
<li><code>I_MPI_ADJUST_SCAN=3</code></li>
<li><code>I_MPI_ADJUST_EXSCAN=3</code></li>
<li><code>I_MPI_ADJUST_GATHER=5</code></li>
<li><code>I_MPI_ADJUST_GATHERV=4</code></li>
<li><code>I_MPI_ADJUST_SCATTER=5</code></li>
<li><code>I_MPI_ADJUST_SCATTERV=4</code></li>
<li><code>I_MPI_ADJUST_ALLGATHERV=5</code></li>
<li><code>I_MPI_ADJUST_ALLTOALLW=2</code></li>
<li><code>I_MPI_ADJUST_REDUCE_SCATTER=6</code></li>
<li><code>I_MPI_ADJUST_REDUCE_SCATTER_BLOCK=4</code></li>
<li><code>I_MPI_ADJUST_IALLGATHER=5</code></li>
<li><code>I_MPI_ADJUST_IALLGATHERV=5</code></li>
<li><code>I_MPI_ADJUST_IGATHERV=3</code></li>
<li><code>I_MPI_ADJUST_IALLREDUCE=9</code></li>
<li><code>I_MPI_ADJUST_IALLTOALLV=2</code></li>
<li><code>I_MPI_ADJUST_IBARRIER=2</code></li>
<li><code>I_MPI_ADJUST_IBCAST=5</code></li>
<li><code>I_MPI_ADJUST_IREDUCE=4</code></li>
</ul>
<p>要强制使用<code>HCOLL</code>，请使用上述<code>I_MPI_ADJUST_&lt;opname&gt;</code>值。 为了获得更好的性能，一旦启用<code>I_MPI_COLL_EXTERNAL</code>就使用自动tuner以获得最佳集合设置。</p>
<p><code>I_MPI_CBWR</code>在相同数量的进程的情况下，控制跨不同平台、网络和拓扑的浮点运算结果的再现性。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_CBWR=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;arg&gt;</code>：CBWR 兼容模式</p>
<ul>
<li>0：None <ul>
<li>不要在库范围模式下使用 CBWR。 可以使用<code>MPI_Comm_dup_with_info</code>显式创建 CNR 安全通信器。 这是默认值。</li>
</ul>
</li>
<li>1：Weak mode<ul>
<li>禁用拓扑相关集合操作。集合操作的结果不取决于rank位置。该模式保证了同一集群上不同运行的结果可重复性（独立于rank位置）。</li>
</ul>
</li>
<li>2：Strict mode<ul>
<li>在算法选择期间禁用拓扑相关集合、忽略 CPU 架构和互连。 该模式可确保结果在不同集群上的不同运行之间具有可重复性（独立于rank位置、CPU 架构和互连）</li>
</ul>
</li>
</ul>
<p>有条件数值再现性 (Conditional Numerical Reproducibility, CNR) 提供控制以在集合运算中获得可再现的浮点结果。 借助此功能，英特尔 MPI 集合运算旨在在 MPI 进程数相同的情况下，每次运行返回相同的浮点结果。</p>
<p>在库范围内使用<code>I_MPI_CBWR</code>环境变量控制此功能，其中所有通信器上的所有集合都保证具有可重现的结果。 要以更精确和每个通信器的方式控制浮点运算的可重复性，请将<code>&#123;“I_MPI_CBWR”, “yes”&#125;</code>键值对传递给<code>MPI_Comm_dup_with_info</code>调用。</p>
<p>注意使用环境变量在库范围模式下设置<code>I_MPI_CBWR</code>会导致性能下降。使用<code>MPI_Comm_dup_with_info</code>创建的 CNR 安全通信器始终在严格模式下工作。 例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MPI_Info hint;</span><br><span class="line">MPI_Comm cbwr_safe_world, cbwr_safe_copy;</span><br><span class="line">MPI_Info_create(&amp;hint);</span><br><span class="line">MPI_Info_set(hint, “I_MPI_CBWR”, “yes”);</span><br><span class="line">MPI_Comm_dup_with_info(MPI_COMM_WORLD, hint, &amp; cbwr_safe_world);</span><br><span class="line">MPI_Comm_dup(cbwr_safe_world, &amp; cbwr_safe_copy);</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，<code>cbwr_safe_world</code>和<code>cbwr_safe_copy</code>都是 CNR 安全的。 使用<code>cbwr_safe_world</code>及其副本为关键操作获得可重现的结果。 请注意，<code>MPI_COMM_WORLD</code>本身可用于性能关键操作，而没有可重复性限制。</p>
<h2 id="Tuning-Environment-Variables"><a href="#Tuning-Environment-Variables" class="headerlink" title="Tuning Environment Variables"></a>Tuning Environment Variables</h2><p><code>I_MPI_TUNING_MODE</code>选择tuning方法。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_TUNING_MODE=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>none</code>：禁用tuning模式。 这是默认值。</li>
<li><code>auto</code>：启用自动tuner.</li>
<li><code>auto:application</code>：使用专注于应用程序的策略（auto 的别名）启用自动tuner。</li>
<li><code>auto:cluster</code>：在没有应用程序特定逻辑的情况下启用自动tuner。 这通常在基准测试（例如 IMB-MPI1）和代理应用程序的帮助下执行。</li>
</ul>
<p>设置此环境变量以启用自动调优器功能并设置自动调优器策略。</p>
<p><code>I_MPI_TUNING_BIN</code>：以二进制格式指定调整设置的路径。设置此环境变量以二进制格式加载调整设置。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_TUNING_BIN=&lt;path&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;path&gt;</code>带有调整设置的二进制文件的路径。 默认情况下，英特尔® MPI 库使用位于<code>&lt;$I_MPI_ONEAPI_ROOT/etc&gt;</code>的二进制调整文件。</p>
<p><code>I_MPI_TUNING_BIN_DUMP</code>指定用于以二进制格式存储调整设置的文件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_TUNING_BIN_DUMP=&lt;filename&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;filename&gt;</code>存储调整设置的二进制文件的文件名。 默认情况下，未指定路径。</p>
<p><code>I_MPI_TUNING</code>以 JSON 格式加载调整设置。设置此环境变量以加载 JSON 格式的调整设置。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_TUNING=&lt;path&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;path&gt;</code>带有调整设置的 JSON 文件的路径。</p>
<p>注意 JSON 格式的调整设置由 mpitune 实用程序生成。默认情况下，英特尔® MPI 库以二进制格式加载调整设置。 如果不可能，英特尔 MPI 库会以通过<code>I_MPI_TUNING</code>环境变量指定的 JSON 格式加载调优文件。 因此，要启用 JSON 调整，请关闭默认的二进制调整：<code>I_MPI_TUNING_BIN=&quot;&quot;</code>。 如果无法从 JSON 文件以二进制格式加载调整设置，则使用默认调整值。 如果您使用<code>I_MPI_ADJUST</code>系列环境变量，则不需要关闭二进制或 JSON 调整设置。 使用<code>I_MPI_ADJUST</code>环境变量指定的算法始终优先于二进制和 JSON 调整设置。</p>
<h2 id="Autotuning"><a href="#Autotuning" class="headerlink" title="Autotuning"></a>Autotuning</h2><p>调整非常依赖于特定平台的规格。 英特尔仔细确定了调整参数，并使用<code>I_MPI_TUNING_MODE</code>和<code>I_MPI_TUNING_AUTO</code>系列环境变量使它们可用于自动调整，以找到最佳设置（请参阅调整环境变量和<code>I_MPI_TUNING_AUTO</code>系列环境变量）。 注意<code>I_MPI_TUNING_MODE</code>和<code>I_MPI_TUNING_AUTO</code>系列环境变量仅支持 Intel 处理器，不能在其他平台上使用。 自动调优器功能可让您自动找到集体操作的最佳算法。 自动调优器搜索空间可以通过·I_MPI_ADJUST_<opname>_LIST·变量进行修改。</p>
<p>当前可用于自动调整的集合是:<code>MPI_Allreduce</code>, <code>MPI_Bcast</code>, <code>MPI_Barrier</code>, <code>MPI_Reduce</code>, <code>MPI_Gather</code>, <code>MPI_Scatter</code>, <code>MPI_Alltoall</code>, <code>MPI_Allgatherv</code>, <code>MPI_Reduce_scatter</code>, <code>MPI_Reduce_scatter_block</code>, <code>MPI_Scan</code>, <code>MPI_Exscan</code>, <code>MPI_Iallreduce</code>, <code>MPI_Ibcast</code>, <code>MPI_Ibarrier</code>, <code>MPI_Ireduce</code>, <code>MPI_Igather</code>, <code>MPI_Iscatter</code>, <code>MPI_Ialltoall</code>, <code>MPI_Iallgatherv</code>, <code>MPI_Ireduce_scatter</code>, <code>MPI_Ireduce_scatter_block</code>, <code>MPI_Iscan</code>,<code>MPI_Iexscan</code>。</p>
<p>要开始自动调整，请按照下列步骤操作：</p>
<ol>
<li>在启用自动调优器的情况下启动应用程序并指定存储结果的转储文件：<code>I_MPI_TUNING_MODE=auto</code>，<code>I_MPI_TUNING_BIN_DUMP=&lt;tuning-results.dat&gt;</code></li>
<li>使用上一步生成的调整结果启动应用程序：<code>I_MPI_TUNING_BIN=&lt;tuning-results.dat&gt;</code>或使用<code>-tune Hydra</code>选项。</li>
<li>如果您遇到性能问题，请参阅自动调整的环境变量。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. $ export I_MPI_TUNING_MODE=auto</span><br><span class="line">$ export I_MPI_TUNING_AUTO_SYNC=1</span><br><span class="line">$ export I_MPI_TUNING_AUTO_ITER_NUM=5</span><br><span class="line">$ export I_MPI_TUNING_BIN_DUMP=./tuning_results.dat</span><br><span class="line">$ mpirun -n 128 -ppn 64 IMB-MPI1 allreduce -iter 1000,800 -time 4800</span><br><span class="line">2. $ export I_MPI_TUNING_BIN=./tuning_results.dat</span><br><span class="line">$ mpirun -n 128 -ppn 64 IMB-MPI1 allreduce -iter 1000,800 -time 4800</span><br></pre></td></tr></table></figure>
<h2 id="I-MPI-TUNING-AUTO-Family-Environment-Variables"><a href="#I-MPI-TUNING-AUTO-Family-Environment-Variables" class="headerlink" title="I_MPI_TUNING_AUTO Family Environment Variables"></a>I_MPI_TUNING_AUTO Family Environment Variables</h2><p>注意您必须设置<code>I_MPI_TUNING_MODE</code>以使用任何<code>I_MPI_TUNING_AUTO</code>系列环境变量。注意<code>I_MPI_TUNING_AUTO</code>系列环境变量仅支持 Intel 处理器，不能在其他平台上使用。</p>
<p><code>I_MPI_TUNING_AUTO_STORAGE_SIZE</code>定义每个通信器调整存储的大小。设置此环境变量以更改通信器调整存储的大小。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_TUNING_AUTO_STORAGE_SIZE=&lt;size&gt;</span><br></pre></td></tr></table></figure><br><code>&lt;size&gt;</code>指定通信器调优存储的大小。 存储的默认大小为 512 Kb。</p>
<p><code>I_MPI_TUNING_AUTO_ITER_NUM</code>设置此环境变量以指定自动调优器迭代次数。 更大的迭代次数会产生更准确的结果。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_TUNING_AUTO_ITER_NUM=&lt;number&gt;</span><br></pre></td></tr></table></figure><br><code>&lt;number&gt;</code>定义迭代次数。 默认情况下，它是 1。</p>
<p>注意要检查是否所有可能的算法都被迭代，请确保目标应用程序中特定消息大小的集合调用总数至少等于<code>I_MPI_TUNING_AUTO_ITER_NUM</code>的值乘以算法数</p>
<p><code>I_MPI_TUNING_AUTO_WARMUP_ITER_NUM</code>指定预热自动调优器迭代次数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_TUNING_AUTO_WARMUP_ITER_NUM=&lt;number&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;number&gt;</code>定义迭代次数。 默认情况下，它是 1。</p>
<p>设置此环境变量以指定自动调优器预热迭代的次数。 预热迭代不会影响自动调优器的决策，并允许跳过额外的迭代，例如基础设施准备。</p>
<p><code>I_MPI_TUNING_AUTO_SYNC</code>在自动调优器的每次迭代中启用内部屏障。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_TUNING_AUTO_SYNC=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable | yes | on | 1 将自动调优器与 IMB 测量方法对齐。</li>
<li>disable | no | off | 0 不要在自动调优器的每次迭代中使用屏障。这是默认值。</li>
</ul>
<p>设置此环境变量以控制 IMB 测量逻辑。 由于额外的<code>MPI_Barrier</code>调用，将此变量设置为 1 可能会导致开销。</p>
<p><code>I_MPI_TUNING_AUTO_COMM_DEFAULT</code>用默认值标记所有通信器。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_TUNING_AUTO_COMM_DEFAULT=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable | yes | on | 1 </li>
<li>disable | no | off | 0 </li>
</ul>
<p>设置此环境变量以使用默认值标记应用程序中的所有通信器。 在这种情况下，所有通信器将具有相同的默认 comm_id 等于 -1。</p>
<h2 id="Process-Pinning"><a href="#Process-Pinning" class="headerlink" title="Process Pinning"></a>Process Pinning</h2><p>使用此功能将特定 MPI 进程固定到节点内的相应 CPU 集，并避免意外的进程迁移。此功能在提供必要内核接口的操作系统上可用。此页面描述了固定过程。您可以使用 Intel MPI 库的 Pinning Simulator 模拟您的 pinning 配置。</p>
<h3 id="处理器标识"><a href="#处理器标识" class="headerlink" title="处理器标识"></a>处理器标识</h3><p>以下方案用于识别系统中的逻辑处理器：</p>
<ul>
<li>系统定义的逻辑枚举</li>
<li>通过三元组（包/套接字、内核、线程）基于三级分层标识的拓扑枚举</li>
</ul>
<p>一个逻辑 CPU 的编号定义为该 CPU 位在内核关联位掩码中的对应位置。使用随英特尔 MPI 库安装提供的 cpuinfo 实用程序或 cat /proc/cpuinfo 命令找出逻辑 CPU 编号。三级分层标识使用提供有关处理器位置及其顺序的信息的三元组。三元组按层次排序（包、核心和线程）。请参阅一个可能的处理器编号示例，其中有两个socket、四个内核（每个socket两个内核）和八个逻辑处理器（每个内核两个处理器）。</p>
<p>注：逻辑枚举和拓扑枚举不同。</p>
<h3 id="Default-Settings"><a href="#Default-Settings" class="headerlink" title="Default Settings"></a>Default Settings</h3><p>如果您没有为任何进程固定环境变量指定值，则使用下面的默认设置。 有关这些设置的详细信息，请参阅环境变量和与 OpenMP API 的互操作性。</p>
<ul>
<li><code>I_MPI_PIN=on</code></li>
<li><code>I_MPI_PIN_RESPECT_CPUSET=on</code></li>
<li><code>I_MPI_PIN_RESPECT_HCA=on</code></li>
<li><code>I_MPI_PIN_CELL=unit</code></li>
<li><code>I_MPI_PIN_DOMAIN=auto:compact</code></li>
<li><code>I_MPI_PIN_ORDER=bunch</code></li>
</ul>
<h3 id="Environment-Variables-for-Process-Pinning"><a href="#Environment-Variables-for-Process-Pinning" class="headerlink" title="Environment Variables for Process Pinning"></a>Environment Variables for Process Pinning</h3><p><code>I_MPI_PIN</code>打开/关闭进程固定。设置此环境变量以控制英特尔® MPI 库的进程固定功能。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PIN=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable | yes | on | 1 启用进程固定。 这是默认值。</li>
<li>disable | no | off | 0 禁用进程固定。</li>
</ul>
<p><code>I_MPI_PIN_PROCESSOR_LIST</code> (<code>I_MPI_PIN_PROCS</code>)定义处理器子集和该子集中的 MPI 进程的映射规则。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PIN_PROCESSOR_LIST=&lt;value&gt;</span><br></pre></td></tr></table></figure></p>
<p>环境变量值具有三种语法形式：</p>
<ol>
<li><code>&lt;proclist&gt;</code></li>
<li><code>[&lt;procset&gt; ][:[grain=&lt;grain&gt; ][,shift=&lt;shift&gt; ][,preoffset=&lt;preoffset&gt; ] [,postoffset=&lt;postoffset&gt; ]</code></li>
<li><code>[&lt;procset&gt; ][:map=&lt;map&gt; ]</code></li>
</ol>
<p>以下段落详细描述了这些语法形式的值。注意 postoffset 关键字具有偏移别名。注意固定过程的第二种形式包括三个步骤：</p>
<ol>
<li>源处理器列表在<code>preoffset*grain</code>值上的循环移位。</li>
<li>在<code>shift*grain</code>值的第一步中导出的列表的循环移位。</li>
<li>在<code>postoffset*grain</code>值上的第二步导出的列表的循环移位。</li>
</ol>
<p>注意<code>grain</code>、<code>shift</code>、<code>preoffset</code>和<code>postoffset</code>参数具有统一的定义样式。此环境变量可用于 Intel 和非 Intel 微处理器，但它对 Intel 微处理器执行的优化可能比对非 Intel 微处理器执行的优化多。</p>
<p>语法 1<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PIN_PROCESSOR_LIST=&lt;proclist&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;proclist&gt;</code>以逗号分隔的逻辑处理器编号和/或处理器范围列表。 具有第 i 个等级的进程被固定到列表中的第 i 个处理器。 该数量不应超过节点上的处理器数量。<ul>
<li><code>&lt;l&gt;</code> 具有逻辑编号<code>&lt;l&gt;</code>的处理器。</li>
<li><code>&lt;l&gt;-&lt;m&gt;</code> 具有从<code>&lt;l&gt;</code>到<code>&lt;m&gt;</code>的逻辑编号的处理器范围。</li>
<li><code>&lt;k&gt;,&lt;l&gt;-&lt;m&gt;</code> 处理器<code>&lt;k&gt;</code>，以及<code>&lt;l&gt;</code>到<code>&lt;m&gt;</code>。</li>
</ul>
</li>
</ul>
<p>语法 2<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PIN_PROCESSOR_LIST=[&lt;procset&gt;][:[grain=&lt;grain&gt;][,shift=&lt;shift&gt;]</span><br><span class="line">[,preoffset=&lt;preoffset&gt;][,postoffset=&lt;postoffset&gt;]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;procset&gt;</code>根据拓扑编号指定处理器子集。 默认值为 allcores。<ul>
<li><code>all</code>所有逻辑处理器。 指定此子集以定义节点上的 CPU 数量。</li>
<li><code>allcores</code>所有内核（物理 CPU）。 指定此子集以定义节点上的核心数。 这是默认值。</li>
<li><code>allsocks</code> 所有包/socket。 指定此子集以定义节点上的套接字数。</li>
</ul>
</li>
<li><code>&lt;grain&gt;</code>为定义的<code>&lt;procset&gt;</code>指定固定粒度单元格。 最小的<code>&lt;grain&gt;</code>值是<code>&lt;procset&gt;</code>的单个元素。 最大<code>&lt;grain&gt;</code>值是套接字中<code>&lt;procset&gt;</code>元素的数量。<code>&lt;grain&gt;</code>值必须是<code>&lt;procset&gt;</code>值的倍数。 否则，假定最小<code>&lt;grain&gt;</code>值。默认值是最小的<code>&lt;grain&gt;</code>值。</li>
<li><code>&lt;shift&gt;</code> 为<code>&lt;procset&gt;</code>指定单元的循环调度班次的粒度。<code>&lt;shift&gt;</code>以定义的<code>&lt;grain&gt;</code>单位测量。<code>&lt;shift&gt;</code>值必须是正整数。 否则，不执行移位。 默认值为无移位，等于 1 个正常增量。</li>
<li><code>&lt;preoffset&gt;</code>指定在循环移位之前定义的处理器子集<code>&lt;procset&gt;</code>的循环移位<code>&lt;preoffset&gt;</code>值。 该值以定义的<code>&lt;grain&gt;</code>单位测量。<code>&lt;preoffset&gt;</code>值必须是非负整数。 否则，不执行移位。 默认值为无移位。</li>
<li><code>&lt;postoffset&gt;</code> 指定在<code>&lt;postoffset&gt;</code>值上循环移位后派生的处理器子集<code>&lt;procset&gt;</code>的循环移位。 该值以定义的<code>&lt;grain&gt;</code>单位测量。<code>&lt;postoffset&gt;</code>值必须是非负整数。 否则不执行移位。 默认值为无移位。</li>
</ul>
<p>下表显示了<code>&lt;grain&gt;</code>、<code>&lt;shift&gt;</code>、<code>&lt;preoffset&gt;</code>和<code>&lt;postoffset&gt;</code>选项的值：</p>
<ul>
<li><code>&lt;n&gt;</code>指定相应参数的显式值。<code>&lt;n&gt;</code>是非负整数<ul>
<li><code>fine</code>指定相应参数的最小值。</li>
<li><code>core</code>指定参数值等于一个核中包含的相应参数单元的数量。</li>
<li><code>cache1</code>指定的参数值等于共享一级缓存的相应参数单元的数量。</li>
<li><code>cache2</code>指定的参数值等于共享一个 L2 缓存的相应参数单元的数量。</li>
<li><code>cache3</code>指定的参数值等于共享一个 L3 缓存的相应参数单元的数量。</li>
<li><code>cache</code>：cache1、cache2 和cache3 中的最大值。</li>
<li><code>socket|sock</code>指定的参数值等于一个物理包/套接字中包含的相应参数单元的数量。</li>
<li><code>half|mid</code>指定等于socket/2的参数值。</li>
<li><code>third</code>指定等于socket/3的参数值。</li>
<li><code>quarter</code>指定等于socket/4的参数值。</li>
<li><code>octavo</code>指定等于 socket/8 的参数值。</li>
</ul>
</li>
</ul>
<p>语法 3<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PIN_PROCESSOR_LIST=[&lt;procset&gt;][:map=&lt;map&gt;]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;map&gt;</code>用于进程放置的映射模式。<ul>
<li><code>bunch</code> 进程被映射到尽可能接近的套接字上。</li>
<li><code>scatter</code> 进程尽可能远程映射，以免共享公共资源：FSB、缓存和核心。</li>
<li><code>spread</code> 进程被连续映射，可能不共享公共资源。</li>
</ul>
</li>
</ul>
<p>设置<code>I_MPI_PIN_PROCESSOR_LIST</code>环境变量以定义处理器放置。 为避免与不同 shell 版本冲突，环境变量值可能需要用引号括起来。 注意 此环境变量仅在启用<code>I_MPI_PIN</code>时有效。</p>
<p><code>I_MPI_PIN_PROCESSOR_LIST</code>环境变量具有以下不同的语法变体：</p>
<ul>
<li>显式处理器列表。 这个逗号分隔的列表是根据逻辑处理器编号定义的。 进程的相对节点rank是处理器列表的索引，因此第 i 个进程固定在第 i 个列表成员上。 这允许在 CPU 上定义任何进程放置。例如，<code>I_MPI_PIN_PROCESSOR_LIST=p0,p1,p2,...,pn</code>的进程映射如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rank on a node  0  1  2  ... n-1  N</span><br><span class="line">Logical CPU     p0 p1 p2 ... pn-1 Pn</span><br></pre></td></tr></table></figure>
<ul>
<li><p>grain/shift/offset mapping. 此方法提供沿处理器列表的定义粒度的循环移位，步长等于<code>shift*grain</code>，最后在<code>offset*grain</code>上进行单次移位。 这种换档动作是重复换档次数。 例如：<code>grain = 2</code>个逻辑处理器，<code>shift = 3 个grain</code>，<code>offset = 0</code>。</p>
</li>
<li><p>Predefined mapping scenario. 在这种情况下，流行的进程固定方案被定义为在运行时可选择的关键字。 有两种这样的场景：bunch and scatter.</p>
</li>
</ul>
<p>在bunch场景中，进程尽可能按比例映射到套接字。 这种映射对于部分处理器加载是有意义的。 在这种情况下，进程数小于处理器数。</p>
<p>在scatter场景中，进程尽可能远程映射，以免共享公共资源：FSB、缓存和内核。</p>
<p>要将进程全局固定到每个节点上的 CPU0 和 CPU3，请使用以下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -genv I_MPI_PIN_PROCESSOR_LIST=0,3 -n &lt;number-of-processes&gt;&lt;executable&gt;</span><br></pre></td></tr></table></figure></p>
<p>要将进程单独固定到每个节点上的不同 CPU（主机 1 上的 CPU0 和 CPU3，主机 2 上的 CPU0、CPU1 和 CPU3），请使用以下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -host host1 -env I_MPI_PIN_PROCESSOR_LIST=0,3 -n &lt;number-of-processes&gt; &lt;executable&gt; : \</span><br><span class="line">-host host2 -env I_MPI_PIN_PROCESSOR_LIST=1,2,3 -n &lt;number-of-processes&gt; &lt;executable&gt;</span><br></pre></td></tr></table></figure></p>
<p>要打印有关进程固定的额外调试信息，请使用以下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -genv I_MPI_DEBUG=4 -m -host host1 \</span><br><span class="line">-env I_MPI_PIN_PROCESSOR_LIST=0,3 -n &lt;number-of-processes&gt; &lt;executable&gt; :\</span><br><span class="line">-host host2 -env I_MPI_PIN_PROCESSOR_LIST=1,2,3 -n &lt;number-of-processes&gt; &lt;executable&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意如果进程数大于用于固定的 CPU 数，则进程列表将环绕到处理器列表的开头。</p>
<p><code>I_MPI_PIN_PROCESSOR_EXCLUDE_LIST</code>定义要为预期主机上的固定进程的功能排除的逻辑处理器子集。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PIN_PROCESSOR_EXCLUDE_LIST=&lt;proclist&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;proclist&gt;</code>以逗号分隔的逻辑处理器编号和/或处理器范围列表。<ul>
<li><code>&lt;l&gt;</code> 具有逻辑编号<code>&lt;l&gt;</code>的处理器。</li>
<li><code>&lt;l&gt;-&lt;m&gt;</code> 具有从<code>&lt;l&gt;</code>到<code>&lt;m&gt;</code>的逻辑编号的处理器范围。</li>
<li><code>&lt;k&gt;,&lt;l&gt;-&lt;m&gt;</code> 处理器<code>&lt;k&gt;</code>，以及<code>&lt;l&gt;</code>到<code>&lt;m&gt;</code>。</li>
</ul>
</li>
</ul>
<p>设置此环境变量以定义英特尔® MPI 库不用于在预期主机上固定功能的逻辑处理器。 逻辑处理器在<code>/proc/cpuinfo</code>中编号。</p>
<p><code>I_MPI_PIN_CELL</code>设置此环境变量以定义固定分辨率粒度。<code>I_MPI_PIN_CELL</code>指定 MPI 进程运行时分配的最小处理器单元。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PIN_CELL=&lt;cell&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;cell&gt;</code>指定分辨率粒度<ul>
<li><code>unit</code>基本处理器单元（逻辑 CPU）</li>
<li><code>core</code> 物理处理器内核</li>
</ul>
</li>
</ul>
<p>设置此环境变量以定义进程运行时使用的处理器子集。 您可以从两种场景中进行选择：</p>
<ul>
<li>节点中所有可能的 CPU（单位值）</li>
<li>一个节点中的所有核心（核心价值）</li>
</ul>
<p>环境变量对两种固定类型都有影响：</p>
<ul>
<li>通过<code>I_MPI_PIN_PROCESSOR_LIST</code>环境变量一对一固定</li>
<li>通过<code>I_MPI_PIN_DOMAIN</code>环境变量进行一对多固定</li>
</ul>
<p>默认值规则是：</p>
<ul>
<li>如果您使用<code>I_MPI_PIN_DOMAIN</code>，则单元格粒度为unit。</li>
<li>如果您使用<code>I_MPI_PIN_PROCESSOR_LIST</code>，则以下规则适用：<ul>
<li>当进程数大于核数时，单元粒度为unit。</li>
<li>当进程数等于或小于核心数时，单元粒度为core。</li>
</ul>
</li>
</ul>
<p>注意内核值不受系统中英特尔® 超线程技术的启用/禁用的影响。</p>
<p><code>I_MPI_PIN_RESPECT_CPUSET</code>以进程亲和掩码为准，这里的尊重可能说的是怎样设置mask的优先级高<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PIN_RESPECT_CPUSET=&lt;value&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable | yes | on | 1 尊重进程亲和掩码。 这是默认值。</li>
<li><p>disable | no | off | 0 不尊重进程关联掩码。</p>
</li>
<li><p>如果您设置<code>I_MPI_PIN_RESPECT_CPUSET=enable</code>，Hydra 进程启动器在每个预期主机上使用作业管理器的进程关联掩码来确定应用英特尔 MPI 库固定功能的逻辑处理器。</p>
</li>
<li>如果您设置<code>I_MPI_PIN_RESPECT_CPUSET=disable</code>，Hydra 进程启动器将使用其自己的进程关联掩码来确定应用英特尔 MPI 库固定功能的逻辑处理器。</li>
</ul>
<h3 id="Interoperability-with-OpenMP-API"><a href="#Interoperability-with-OpenMP-API" class="headerlink" title="Interoperability with OpenMP* API"></a>Interoperability with OpenMP* API</h3><p><code>I_MPI_PIN_DOMAIN</code>：英特尔® MPI 库提供了一个额外的环境变量来控制混合 MPI/OpenMP* 应用程序的进程固定。该环境变量用于定义节点上逻辑处理器的多个非重叠子集（域），以及一组关于 MPI 进程如何通过以下公式绑定到这些域的规则：每个domain一个 MPI 进程。 见下图。</p>
<p><img src="/img/1639659501.jpg" alt=""></p>
<p>每个 MPI 进程可以创建多个子线程以在相应的域中运行。 进程线程可以自由地从一个逻辑处理器迁移到特定域内的另一个。</p>
<ul>
<li>如果定义了<code>I_MPI_PIN_DOMAIN</code>环境变量，则忽略<code>I_MPI_PIN_PROCESSOR_LIST</code>环境变量设置。</li>
<li>如果未定义<code>I_MPI_PIN_DOMAIN</code>环境变量，则根据<code>I_MPI_PIN_PROCESSOR_LIST</code>环境变量的当前值固定 MPI 进程。</li>
</ul>
<p><code>I_MPI_PIN_DOMAIN</code>环境变量具有以下语法形式：</p>
<ul>
<li>通过多核术语<code>&lt;mc-shape&gt;</code>的域描述</li>
<li>通过域大小和域成员布局的域描述<code>&lt;size&gt;[:&lt;layout&gt;]</code></li>
<li>通过位掩码<code>&lt;masklist&gt;</code>的显式域描述</li>
</ul>
<p>下表描述了这些语法形式</p>
<ul>
<li>多核形状：<code>I_MPI_PIN_DOMAIN=&lt;mc-shape&gt;</code><ul>
<li><code>&lt;mc-shape&gt;</code>通过多核术语定义域。</li>
<li><code>core</code> 每个域由共享特定核心的逻辑处理器组成。节点上的域数等于节点上的核心数。</li>
<li><code>socket | sock</code>每个域由共享特定套接字的逻辑处理器组成。一个节点上的域数等于节点上的套接字数。这是推荐值。</li>
<li><code>numa</code>每个域由共享特定 NUMA 节点的逻辑处理器组成。一台机器上的域数等于机器上的 NUMA 节点数。</li>
<li><code>node</code> 一个节点上的所有逻辑处理器都安排在一个域中。</li>
<li><code>cache1</code> 共享特定一级缓存的逻辑处理器被安排在一个域中。</li>
<li><code>cache2</code> 共享特定二级缓存的逻辑处理器被安排在一个域中。</li>
<li><code>cache3</code> 共享特定的第 3 级缓存的逻辑处理器被安排在一个域中。</li>
<li><code>cache</code> 选择cache1、cache2 和cache3 中最大的域。</li>
</ul>
</li>
</ul>
<p>注意如果在一台机器上禁用了 Cluster on Die，则 NUMA 节点的数量等于套接字的数量。 在这种情况下，固定<code>I_MPI_PIN_DOMAIN = numa</code>等效于固定<code>I_MPI_PIN_DOMAIN = socket</code>。</p>
<ul>
<li>显式形状，<code>I_MPI_PIN_DOMAIN=&lt;size&gt;[:&lt;layout&gt;]</code></li>
<li><code>&lt;size&gt;</code>定义每个域中的逻辑处理器数量（域大小）<ul>
<li><code>omp</code>域大小等于<code>OMP_NUM_THREADS</code>环境变量值。如果未设置<code>OMP_NUM_THREADS</code>环境变量，则每个节点都被视为一个单独的域。</li>
<li><code>auto</code>域大小由公式<code>size=#cpu/#proc</code>定义，其中<code>#cpu</code>为节点上的逻辑处理器数，<code>#proc</code>为节点上启动的 MPI 进程数</li>
<li><code>&lt;n&gt;</code>域大小由正十进制数定义<code>&lt;n&gt;</code></li>
</ul>
</li>
<li><code>&lt;layout&gt;</code>域成员的排序。默认值是紧凑的</li>
<li><code>platform</code>域成员根据其 BIOS 编号（平台相关编号）进行排序</li>
<li><code>compact</code>根据资源（内核、缓存、套接字等）紧凑，域成员的位置尽可能靠近彼此。这是默认值</li>
<li><p><code>scatter</code>域成员在公共资源（核心、缓存、套接字等）方面尽可能远离彼此</p>
</li>
<li><p>显式域掩码，<code>I_MPI_PIN_DOMAIN=&lt;掩码列表&gt;</code></p>
</li>
<li><code>&lt;masklist&gt;</code>通过逗号分隔的十六进制数字列表（域掩码）定义域<ul>
<li><code>[m1,...,mn]</code>对于<code>&lt;masklist&gt;</code>，每个<code>mi</code>是一个定义单个域的十六进制邮件位掩码。使用以下规则：如果相应的 mi 值设置为 1，则第 i 个逻辑处理器被包含在域中。所有剩余的处理器都被放入一个单独的域中。使用 BIOS 编号。</li>
</ul>
</li>
</ul>
<p>注意 为确保<code>&lt;masklist&gt;</code>中的配置被正确解析，请使用方括号将<code>&lt;masklist&gt;</code>指定的域括起来。例如：<code>I_MPI_PIN_DOMAIN=[55,aa]</code></p>
<p>注意这些选项可用于 Intel® 和非 Intel 微处理器，但它们对 Intel 微处理器执行的优化可能比对非 Intel 微处理器执行的优化更多。要在域内固定 OpenMP* 进程或线程，应使用相应的 OpenMP 功能（例如，英特尔® 编译器的<code>KMP_AFFINITY</code>环境变量）。注意以下配置实际上与未应用固定相同：</p>
<ul>
<li>如果您设置<code>I_MPI_PIN_DOMAIN=auto</code>并且一个节点上正在运行单个进程（例如，由于<code>I_MPI_PERHOST=1</code>）</li>
<li><code>I_MPI_PIN_DOMAIN=node</code></li>
</ul>
<p>如果您不希望进程在多套接字平台上的套接字之间迁移，请将域大小指定为<code>I_MPI_PIN_DOMAIN=socket</code>或更小。您还可以使用<code>I_MPI_PIN_PROCESSOR_LIST</code>，它为每个rank生成一个单 CPU 进程关联掩码（应该在 IBA* HCA 存在的情况下自动调整关联掩码）。</p>
<p>请参阅示例中的对称多处理 (SMP) 节点的以下模型<br><img src="/img/1639662456.jpg" alt=""></p>
<p>上图代表了 SMP 节点模型，在 2 个socket上共有 8 个内核。 英特尔® 超线程技术已禁用。 相同颜色的核心对共享 L2 缓存。</p>
<p>Figure3<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun -n 2 -env I_MPI_PIN_DOMAIN socket ./a.out</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1639662711.jpg" alt=""></p>
<p>在图 3 中，根据套接字的数量定义了两个域。 进程rank 0 可以在第 0 个套接字上的所有内核上迁移。 进程rank 1 可以在第一个socket上的所有内核上迁移。</p>
<p>Figure 4 <code>mpirun -n 4 -env I_MPI_PIN_DOMAIN cache2 ./a.out</code><br><img src="/img/1639662806.jpg" alt=""></p>
<p>在图 4 中，根据常用 L2 缓存的数量定义了四个域。 进程rank 0 在共享 L2 缓存的内核 {0,4} 上运行。 进程rank 1 在共享 L2 缓存的内核 {1,5} 上运行，依此类推。</p>
<p>Figure 5 <code>mpirun -n 2 -env I_MPI_PIN_DOMAIN 4:platform ./a.out</code><br><img src="/img/1639662910.jpg" alt=""></p>
<p>在图 5 中，定义了两个大小为 4 的域。 第一个域包含内核 {0,1,2,3}，第二个域包含内核 {4,5,6,7}。 域成员（核心）具有由平台选项定义的连续编号。</p>
<p>Figure 6 <code>mpirun -n 4 -env I_MPI_PIN_DOMAIN auto:scatter ./a.out</code><br><img src="/img/1639662962.jpg" alt=""></p>
<p>在图6中，域大小=2（定义为CPU数=8/进程数=4），scatter布局。 定义了四个域 {0,2}、{1,3}、{4,6}、{5,7}。 域成员不共享任何公共资源。</p>
<p>Figure 7 <code>setenv OMP_NUM_THREADS=2 mpirun -n 4 -env I_MPI_PIN_DOMAIN omp:platform ./a.out</code><br><img src="/img/1639663013.jpg" alt=""></p>
<p>在图 7 中，域大小=2（由<code>OMP_NUM_THREADS=2</code>定义），platform布局。 定义了四个域 {0,1}、{2,3}、{4,5}、{6,7}。 域成员（核心）具有连续编号。</p>
<p>Figure 8 <code>mpirun -n 2 -env I_MPI_PIN_DOMAIN [55,aa] ./a.out</code><br><img src="/img/1639663084.jpg" alt=""></p>
<p>在图 8（<code>I_MPI_PIN_DOMAIN=&lt;masklist&gt;</code>的示例）中，第一个域由 55 掩码定义。它包含所有具有偶数 {0,2,4,6} 的内核。第二个域由 AA 掩码定义。它包含所有奇数为 {1,3,5,7} 的内核。</p>
<p><code>I_MPI_PIN_ORDER</code>设置此环境变量以定义 MPI 进程到<code>I_MPI_PIN_DOMAIN</code>环境变量指定的域的映射顺序。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PIN_ORDER=&lt;订单&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;order&gt;</code>指定顺序</li>
<li><code>range</code>根据处理器的 BIOS 编号对域进行排序。这是一个平台相关的编号。</li>
<li><code>scatter</code>域是有序的，以便相邻域尽可能共享最少的公共资源。</li>
<li><code>compact</code> 域是有序的，以便相邻域尽可能共享公共资源。</li>
<li><code>spread</code> 域是连续排序的，可能不共享公共资源。</li>
<li><code>bunch</code> 进程按比例映射到套接字，域在套接字上的排序尽可能接近。这是默认值。</li>
</ul>
<p>此环境变量的最佳设置是特定于应用程序的。如果相邻的 MPI 进程更喜欢共享公共资源，例如核心、缓存、套接字、FSB，请使用compact或bunch。否则，使用scatter或spread。根据需要使用范围值。有关这些值的详细信息和示例，请参阅本主题中<code>I_MPI_PIN_ORDER</code>的参数表和示例部分。选项<code>scatter</code>、<code>compact</code>、<code>spread</code>和<code>bunch</code>可用于Intel® 和非Intel 微处理器，但它们对Intel 微处理器执行的优化可能比对非Intel 微处理器执行的优化多。</p>
<p>对于以下配置：</p>
<ul>
<li>具有四个内核的两个socket节点和用于相应内核对的共享 L2 缓存。</li>
<li>您希望使用以下设置在节点上运行的 4 个 MPI 进程。</li>
</ul>
<p>Compact order：<code>I_MPI_PIN_DOMAIN=2 I_MPI_PIN_ORDER=compact</code>。<br><img src="/img/1639663518.jpg" alt=""></p>
<p>Scatter order：<code>I_MPI_PIN_DOMAIN=2 I_MPI_PIN_ORDER=scatter</code>。<br><img src="/img/1639663572.jpg" alt=""></p>
<p>Spread order：<code>I_MPI_PIN_DOMAIN=2 I_MPI_PIN_ORDER=spread</code>。<br>注意对于<code>I_MPI_PIN_ORDER=spread</code>，如果没有足够的 CPU 来放置所有域，则顺序将切换为“compact”。<br><img src="/img/1639663640.jpg" alt=""></p>
<p>Bunch order：<code>I_MPI_PIN_DOMAIN=2 I_MPI_PIN_ORDER=bunch</code><br><img src="/img/1639663678.jpg" alt=""></p>
<h2 id="GPU-支持"><a href="#GPU-支持" class="headerlink" title="GPU 支持"></a>GPU 支持</h2><p>除了 GPU 固定之外，英特尔 MPI 库还支持 GPU 缓冲区（见下文）。</p>
<h3 id="GPU-固定"><a href="#GPU-固定" class="headerlink" title="GPU 固定"></a>GPU 固定</h3><p>使用此功能在 MPI rank之间分配 Intel GPU 设备。要启用此功能，请设置<code>I_MPI_OFFLOAD_TOPOLIB=level_zero</code>。 此功能要求在节点上安装 LevelZero* 库。 设备固定信息在<code>I_MPI_DEBUG=3</code>处的英特尔 MPI 调试输出中打印出来。默认设置：</p>
<ul>
<li><code>I_MPI_OFFLOAD_CELL=tile</code></li>
<li><code>I_MPI_OFFLOAD_DOMAIN_SIZE=-1</code></li>
<li><code>I_MPI_OFFLOAD_DEVICES=all</code></li>
</ul>
<p>默认情况下，所有可用资源都在 MPI rank 之间尽可能平均地分配给给定的 rank 位置； 即资源的分配考虑了rank和资源位于哪个NUMA节点上。 理想情况下，rank将仅在等级所在的同一 NUMA 节点上拥有资源。下面的所有示例都代表具有两个 NUMA 节点和两个带有两个图块的 GPU 的机器配置。图 1显示了四个 MPI 等级<br><img src="/img/1639663898.jpg" alt=""></p>
<p>Debug output I_MPI_DEBUG=3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0] MPI startup(): ===== GPU pinning on host1 =====</span><br><span class="line">[0] MPI startup(): Rank Pin tile</span><br><span class="line">[0] MPI startup(): 0 &#123;0&#125;</span><br><span class="line">[0] MPI startup(): 1 &#123;1&#125;</span><br><span class="line">[0] MPI startup(): 2 &#123;2&#125;</span><br><span class="line">[0] MPI startup(): 3 &#123;3&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="fabric控制的环境变量"><a href="#fabric控制的环境变量" class="headerlink" title="fabric控制的环境变量"></a>fabric控制的环境变量</h2><p>通信结构控制<code>I_MPI_FABRICS</code>选择要使用的特定fabric。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_FABRICS=ofi | shm:ofi | shm</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;fabric&gt;</code>定义网络结构。<ul>
<li><code>shm</code>共享内存传输（仅用于节点内通信）。</li>
<li><code>ofi</code> OpenFabrics 接口<em> (OFI) 网络结构，例如英特尔® True Scale Fabric、英特尔® Omni-Path 架构、InfiniBand</em> 和以太网（通过 OFI API）。</li>
</ul>
</li>
</ul>
<p>设置此环境变量以选择特定的结构组合。常规模式的默认值为<code>shm:ofi</code>，多端点模式的默认值为<code>ofi</code>。在多端点模式下，默认值<code>ofi</code>无法更改。</p>
<p>此选项不适用于 slurm 和 pdsh 引导服务器。不推荐使用 DAPL、TMI 和 OFA 结构。</p>
<p>共享内存控制<code>I_MPI_SHM</code>选择要使用的共享内存传输。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM=&lt;transport&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;transport&gt;</code>定义共享内存传输解决方案。<ul>
<li><code>disable | no | off | 0</code>不要使用共享内存传输。</li>
<li><code>auto</code>自动选择共享内存传输解决方案。</li>
<li><code>bdw_sse</code>共享内存传输解决方案针对英特尔® 微架构代号 Broadwell 进行了调整。 SSE4.2。使用指令集。</li>
<li><code>bdw_avx2</code>共享内存传输解决方案针对英特尔® 微架构代号 Broadwell 进行了调整。使用了 AVX2 指令集。</li>
<li><code>skx_sse</code>共享内存传输解决方案针对基于英特尔® 微架构代号 Skylake 的英特尔® 至强® 处理器进行了调整。使用了 CLFLUSHOPT 和 SSE4.2 指令集。</li>
<li><code>skx_avx2</code>共享内存传输解决方案针对基于英特尔® 微架构代号 Skylake 的英特尔® 至强® 处理器进行了调整。使用了 CLFLUSHOPT 和 AVX2 指令集。</li>
<li><code>skx_avx512</code>共享内存传输解决方案针对基于英特尔® 微架构代号 Skylake 的英特尔® 至强® 处理器进行了调整。使用了 CLFLUSHOPT 和 AVX512 指令集。</li>
<li><code>knl_ddr</code>共享内存传输解决方案针对英特尔® 微架构代号 Knights Landing 进行了调整。</li>
<li><code>knl_mcdram</code>共享内存传输解决方案针对英特尔® 微架构代号 Knights Landing 进行了调整。共享内存缓冲区可能部分位于多通道 DRAM (MCDRAM) 中。</li>
<li><code>clx_sse</code>共享内存传输解决方案针对基于英特尔® 微架构代号 Cascade Lake 的英特尔® 至强® 处理器进行了调整。使用了 CLFLUSHOPT 和 SSE4.2 指令集。</li>
<li><code>clx_avx2</code>共享内存传输解决方案针对基于英特尔® 微架构代号 Cascade Lake 的英特尔® 至强® 处理器进行了调整。使用了 CLFLUSHOPT 和 AVX2 指令集。</li>
<li><code>clx_avx512</code>共享内存传输解决方案针对基于英特尔® 微架构代号 Cascade Lake 的英特尔® 至强® 处理器进行了调整。使用了 CLFLUSHOPT 和 AVX512 指令集。</li>
<li><code>clx-ap</code>共享内存传输解决方案针对基于英特尔® 微架构代号 Cascade Lake Advanced Performance 的英特尔® 至强® 处理器进行了调整。</li>
<li><code>icx</code>共享内存传输解决方案针对基于英特尔® 微架构代号 Ice Lake 的英特尔® 至强® 处理器进行了优化。</li>
</ul>
</li>
</ul>
<p>设置此环境变量以选择特定的共享内存传输解决方案。</p>
<p>自动选择的传输：</p>
<ul>
<li><code>icx</code>用于基于英特尔® 微架构的英特尔® 至强® 处理器，代号为 Ice Lake</li>
<li><code>clx-ap</code>用于基于英特尔® 微架构的英特尔® 至强® 处理器，代号为 Cascade Lake Advanced Performance</li>
<li><code>bdw_avx2</code>用于英特尔® 微架构代号 Haswell、Broadwell 和 Skylake</li>
<li><code>skx_avx2</code>用于基于英特尔® 微体系结构代号 Skylake 的英特尔® 至强® 处理器</li>
<li><code>ckx_avx2</code>用于基于英特尔® 微体系结构代号 Cascade Lake 的英特尔® 至强® 处理器</li>
<li><code>knl_mcdram</code>用于英特尔® 微架构，代号为 Knights Landing 和 Knights Mill</li>
<li><code>bdw_sse</code>适用于所有其他平台</li>
</ul>
<p><code>I_MPI_SHM</code>的值取决于<code>I_MPI_FABRICS</code>的值，如下所示：如果<code>I_MPI_FABRICS</code>为<code>ofi</code>，则<code>I_MPI_SHM</code>被禁用。如果<code>I_MPI_FABRICS</code>是<code>shm:ofi</code>，则<code>I_MPI_SHM</code>默认为<code>auto</code>或采用指定值。</p>
<p><code>I_MPI_SHM_CELL_FWD_SIZE</code>更改共享内存前向单元的大小。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_CELL_FWD_SIZE=&lt;nbytes&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;nbytes&gt;</code>共享内存转发单元的大小（以字节为单位）</li>
<li><code>&gt; 0</code> 默认的<code>&lt;nbytes&gt;</code>值取决于所使用的传输方式，通常应该在 64K 到 1024K 的范围内。</li>
</ul>
<p>转发单元是用于发送少量数据的缓存中消息缓冲区单元。建议使用较低的值。设置此环境变量以定义共享内存传输中前向单元的大小。</p>
<p><code>I_MPI_SHM_CELL_BWD_SIZE</code>更改共享内存后向单元的大小。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_CELL_BWD_SIZE=&lt;nbytes&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;nbytes&gt;</code>共享内存后向单元的大小（以字节为单位）</li>
<li><code>&gt; 0</code>默认的<code>&lt;nbytes&gt;</code>值取决于所使用的传输方式，通常应该在 64K 到 1024K 的范围内。</li>
</ul>
<p>后向单元是用于发送大量数据的缓存外消息缓冲区单元。建议使用更高的值。设置此环境变量以定义共享内存传输中 backwrad 单元的大小。</p>
<p><code>I_MPI_SHM_CELL_EXT_SIZE</code>更改共享内存扩展单元的大小。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_CELL_EXT_SIZE=&lt;nbytes&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;nbytes&gt;</code>共享内存扩展单元的大小（以字节为单位）</li>
<li><code>&gt; 0</code>默认的<code>&lt;nbytes&gt;</code>值取决于所使用的传输方式，通常应该在 64K 到 1024K 的范围内。</li>
</ul>
<p>当前向和后向单元用完时，扩展信元用于不平衡的应用中。扩展单元没有特定的所有者——它在计算节点上的所有等级之间共享。设置此环境变量以定义共享内存传输中扩展单元的大小。</p>
<p><code>I_MPI_SHM_CELL_FWD_NUM</code>更改共享内存传输中前向单元的数量（每列）。设置此环境变量以定义共享内存传输中的前向单元数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_CELL_FWD_NUM=&lt;num&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;num&gt;</code>共享内存转发单元的数量</li>
<li><code>&gt; 0</code>默认值取决于所使用的传输，通常应在从 4 到 16范围内。</li>
</ul>
<p><code>I_MPI_SHM_CELL_BWD_NUM</code>更改共享内存传输中的后向单元数（每列）。设置此环境变量以定义共享内存传输中向后单元的数量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_CELL_BWD_NUM=&lt;num&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;num&gt;</code>共享内存后向单元的数量</li>
<li><code>&gt; 0</code>默认值取决于所使用的传输，通常应在从 4 到 64范围内。</li>
</ul>
<p><code>I_MPI_SHM_CELL_EXT_NUM_TOTAL</code>更改共享内存传输中扩展单元的总数。设置此环境变量以定义共享内存传输中扩展单元的数量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_CELL_EXT_NUM_TOTAL=&lt;num&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;num&gt;</code>共享内存后向单元的数量</li>
<li><code>&gt; 0</code>默认值取决于所使用的传输方式，通常范围为 2K 到 8K。</li>
</ul>
<p><code>I_MPI_SHM_CELL_FWD_HOLD_NUM</code>更改共享内存传输中的保留单元数量（每列）。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_CELL_FWD_HOLD_NUM=&lt;num&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;num&gt;</code>共享内存保持前向单元的数量</li>
<li><code>&gt; 0</code>默认值取决于使用的传输并且必须小于</li>
</ul>
<p><code>I_MPI_SHM_CELL_FWD_NUM</code>设置此环境变量以定义一个 rank 可以同时容纳的共享内存传输中的前向单元格数。推荐值是 1 到 8 范围内的 2 的幂。</p>
<p><code>I_MPI_SHM_MCDRAM_LIMIT</code>更改绑定到多通道 DRAM (MCDRAM) 的共享内存的大小（每列大小）。设置此环境变量以定义共享内存传输允许每列使用多少 MCDRAM 内存。此变量仅在<code>I_MPI_SHM=knl_mcdram</code>时生效。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_MCDRAM_LIMIT=&lt;nbytes&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;nbytes&gt;</code>每列绑定到 MCDRAM 的共享内存的大小，1048576 这是默认值。</li>
</ul>
<p><code>I_MPI_SHM_SEND_SPIN_COUNT</code>控制用于发送消息的共享内存传输的自旋计数值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_SEND_SPIN_COUNT=&lt;计数&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;count&gt;</code>定义旋转计数值。典型值范围在 1 到 1000 之间。</li>
</ul>
<p>如果接收方入口缓冲区已满，则发送方可能会被阻塞，直到达到此旋转计数值。发送小消息时不起作用。</p>
<p><code>I_MPI_SHM_RECV_SPIN_COUNT</code>控制用于接收消息的共享内存传输的自旋计数值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_RECV_SPIN_COUNT=&lt;计数&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;count&gt;</code>定义旋转计数值。典型值范围在 1 到 1000000 之间。</li>
</ul>
<p>如果接收是非阻塞的，则此自旋计数仅用于预期和意外消息的安全重新排序。它对接收小消息没有影响。</p>
<p><code>I_MPI_SHM_FILE_PREFIX_4K</code>更改创建共享内存文件的 4 KB 页大小文件系统 (tmpfs) 的安装点。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_FILE_PREFIX_4K=&lt;path&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;path&gt;</code>定义 4 KB 页大小文件系统 (tmpfs) 的现有挂载点的路径。默认情况下，未设置路径。</li>
</ul>
<p>设置此环境变量以定义共享内存文件的新路径。默认情况下，共享内存文件创建在<code>/dev/shm/</code>。此变量影响共享内存传输缓冲区和 RMA 窗口。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_FILE_PREFIX_4K=/dev/shm/intel/</span><br></pre></td></tr></table></figure></p>
<p><code>I_MPI_SHM_FILE_PREFIX_2M</code>更改创建共享内存文件的 2 MB 页大小文件系统 (hugetlbfs) 的挂载点。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_FILE_PREFIX_2M=&lt;路径&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;path&gt;</code>定义 2 MB 页大小的文件系统 (hugetlbfs) 的现有挂载点的路径。默认情况下，未设置路径。</li>
</ul>
<p>设置此环境变量以在英特尔 MPI 库上启用 2 MB 大页面。该变量影响共享内存传输缓冲区。如果窗口大小大于或等于 2 MB，它也可能影响 RMA 窗口。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_FILE_PREFIX_2M=/dev/hugepages</span><br></pre></td></tr></table></figure></p>
<p>配置大页面子系统需要 root 权限。请联系您的系统管理员以获得许可。</p>
<p><code>I_MPI_SHM_FILE_PREFIX_1G</code>更改创建共享内存文件的 1 GB 页大小文件系统 (hugetlbfs) 的挂载点。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_FILE_PREFIX_1G=&lt;路径&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;path&gt;</code>定义 1 GB 页面大小文件系统 (hugetlbfs) 的现有挂载点的路径。默认情况下，未设置路径。</li>
</ul>
<p>设置此环境变量以在英特尔 MPI 库上启用 1 GB 大页面。该变量影响共享内存传输缓冲区。如果窗口大小大于或等于 1 GB，它也可能影响 RMA 窗口。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_FILE_PREFIX_1G=/dev/hugepages1G</span><br></pre></td></tr></table></figure></p>
<p>配置大页面子系统需要 root 权限。 请联系您的系统管理员以获得许可。</p>
<h3 id="OFI-capable-Network-Fabrics-Control"><a href="#OFI-capable-Network-Fabrics-Control" class="headerlink" title="OFI*-capable Network Fabrics Control"></a>OFI*-capable Network Fabrics Control</h3><p><code>I_MPI_OFI_PROVIDER</code>定义要加载的 OFI 提供程序的名称。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_OFI_PROVIDER=&lt;name&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;name&gt;</code>要加载的 OFI 提供程序的名称</li>
</ul>
<p>设置此环境变量以定义要加载的 OFI 提供程序的名称。 如果不指定此变量，OFI 库会自动选择提供者。 您可以使用<code>I_MPI_OFI_PROVIDER_DUMP</code>环境变量检查所有可用的提供程序。 如果您为可用的提供程序设置了错误的名称，请使用<code>FI_LOG_LEVEL=debug</code>获取正确设置名称的提示。</p>
<p><code>I_MPI_OFI_PROVIDER_DUMP</code>控制从 OFI 库打印有关所有 OFI 提供者及其属性的信息的能力。设置此环境变量以控制从 OFI 库打印有关所有 OFI 提供程序及其属性的信息的能力。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_OFI_PROVIDER_DUMP=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;arg&gt;</code>二元指标<ul>
<li>enable | yes | on | 1 从 OFI 库打印所有 OFI 提供商及其属性的列表</li>
<li>disable | no | off | 0 没有行动。 这是默认值</li>
</ul>
</li>
</ul>
<p><code>I_MPI_OFI_DRECV</code>控制 OFI 结构中直接接收的能力。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_OFI_DRECV=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;arg&gt;</code>二元指标<ul>
<li>enable | yes | on | 1 Enable direct receive. This is the default value</li>
<li>disable | no | off | 0 禁用直接接收</li>
</ul>
</li>
</ul>
<p>使用直接接收功能仅阻止<code>MPI_Recv</code>调用。 在使用直接接收功能之前，请确保将其用于单线程 MPI 应用程序，并通过设置<code>I_MPI_FABRICS=ofi</code>检查是否已选择 OFI 作为网络结构。</p>
<p><code>I_MPI_OFI_LIBRARY_INTERNAL</code>控制随英特尔® MPI 库提供的 libfabric* 的使用。设置此环境变量以禁用或启用英特尔 MPI 库中的 libfabric。 必须在获取<code>vars.[c]sh</code>脚本之前设置该变量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_OFI_LIBRARY_INTERNAL=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;arg&gt;</code>二元指标<ul>
<li>enable | yes | on | 1 使用英特尔 MPI 库中的 libfabric</li>
<li>disable | no | off | 0 不要使用来自英特尔 MPI 库的 libfabric</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export I_MPI_OFI_LIBRARY_INTERNAL=1</span><br><span class="line">$ source &lt;installdir&gt; /bin/vars.sh</span><br></pre></td></tr></table></figure>
<h2 id="Environment-Variables-for-Memory-Policy-Control"><a href="#Environment-Variables-for-Memory-Policy-Control" class="headerlink" title="Environment Variables for Memory Policy Control"></a>Environment Variables for Memory Policy Control</h2><p>英特尔® MPI 库支持在英特尔® 至强融核™ 处理器（代号为 Knights Landing）上具有高带宽 (HBW) 内存 (MCDRAM) 的非统一内存访问 (NUMA) 节点。 英特尔® MPI 库可以将 MPI 进程的内存附加到特定 NUMA 节点的内存。 本节描述了这种内存布局控制的环境变量。</p>
<p><code>I_MPI_HBW_POLICY</code>设置使用 HBW 内存的 MPI 进程内存放置策略。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_HBW_POLICY=&lt;user memory policy&gt;[,&lt;mpi memory policy&gt;][,&lt;win_allocate policy&gt;]</span><br></pre></td></tr></table></figure></p>
<p>在语法中：</p>
<ul>
<li><code>&lt;user memory policy&gt;</code> - 用于为用户应用程序分配内存的内存策略（必需）</li>
<li><code>&lt;mpi memory policy&gt;</code> - 用于分配内部 MPI 内存的内存策略（可选）</li>
<li><code>&lt;win_allocate policy&gt;</code> - 用于为 RMA 操作的窗口段分配内存的内存策略（可选）</li>
</ul>
<p>每个列出的策略可能具有以下值：</p>
<ul>
<li><code>&lt;value&gt;</code>使用的内存分配策略。<ul>
<li><code>hbw_preferred</code> 为每个进程分配本地 HBW 内存。 如果 HBW 内存不可用，则分配本地动态随机存取内存。</li>
<li><code>hbw_bind</code> 只为每个进程分配本地 HBW 内存。</li>
<li><code>hbw_interleave</code> 以循环方式在本地节点上分配 HBW 内存和动态随机存取内存。</li>
</ul>
</li>
</ul>
<p>使用此环境变量为具有 HBW 内存的机器上的 MPI 进程内存放置指定策略。 默认情况下，英特尔 MPI 库为本地 DDR 中的进程分配内存。 仅当您指定<code>I_MPI_HBW_POLICY</code>变量时，才能使用 HBW 内存。</p>
<p>以下示例演示了不同的内存布局配置：</p>
<ul>
<li><code>I_MPI_HBW_POLICY=hbw_bind,hbw_preferred,hbw_bind</code><br>  仅将在用户应用程序和窗口段中分配的本地 HBW 内存用于 RMA 操作。 首先使用英特尔® MPI 库中内部分配的本地 HBW 内存。 如果 HBW 内存不可用，请使用英特尔 MPI 库中内部分配的本地 DDR。</li>
<li><code>I_MPI_HBW_POLICY=hbw_bind,,hbw_bind</code><ul>
<li>仅将在用户应用程序和窗口段中分配的本地 HBW 内存用于 RMA 操作。 使用英特尔 MPI 库中内部分配的本地 DDR。</li>
</ul>
</li>
<li><code>I_MPI_HBW_POLICY=hbw_bind,hbw_preferred</code><ul>
<li>仅使用在用户应用程序中分配的本地 HBW 内存。 首先使用英特尔 MPI 库中内部分配的本地 HBW 内存。 如果 HBW 内存不可用，请使用英特尔 MPI 库中内部分配的本地 DDR。 将窗口段中分配的本地 DDR 用于 RMA 操作。</li>
</ul>
</li>
</ul>
<p><code>I_MPI_BIND_NUMA</code>为内存分配设置 NUMA 节点。设置此环境变量以指定内存分配过程中涉及的 NUMA 节点集。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_BIND_NUMA=&lt;value&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;value&gt;</code> 指定用于内存分配的 NUMA 节点。<ul>
<li><code>localalloc</code> 在本地节点上分配内存。 这是默认值。</li>
<li><code>Node_1,…,Node_k</code>在指定的 NUMA 节点上根据<code>I_MPI_BIND_ORDER</code>分配内存。</li>
</ul>
</li>
</ul>
<p><code>I_MPI_BIND_ORDER</code>设置这个环境变量来定义内存分配方式。设置该环境变量来定义<code>I_MPI_BIND_NUMA</code>中指定的NUMA 节点之间的内存分配方式。 如果未设置<code>I_MPI_BIND_NUMA</code>，该变量无效。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_BIND_ORDER=&lt;value&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;value&gt;</code>指定分配方式。<ul>
<li><code>compact</code>在<code>I_MPI_BIND_NUMA</code>中指定的 NUMA 节点中，为尽可能接近的进程分配内存（就 NUMA 节点而言）。 这是默认值。</li>
<li><code>scatter</code>使用循环方式在<code>I_MPI_BIND_NUMA</code>中指定的 NUMA 节点之间分配内存。</li>
</ul>
</li>
</ul>
<p><code>I_MPI_BIND_WIN_ALLOCATE</code>设置此环境变量以控制窗口段的内存分配。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_BIND_WIN_ALLOCATE=&lt;value&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;value&gt;</code>指定窗口段的内存分配行为。<ul>
<li><code>localalloc</code>在本地节点上分配内存。 这是默认值。</li>
<li><code>hbw_preferred</code> 为每个进程分配本地 HBW 内存。 如果 HBW 内存不可用，则分配本地动态随机存取内存。</li>
<li><code>hbw_bind</code>只为每个进程分配本地 HBW 内存。</li>
<li><code>hbw_interleave</code>以循环方式在本地节点上分配HBW内存和动态随机存取内存。</li>
<li><code>&lt;NUMA node id&gt;</code>在给定的 NUMA 节点上分配内存。</li>
</ul>
</li>
</ul>
<p>设置此环境变量以在<code>MPI_Win_allocate_shared</code>或<code>MPI_Win_allocate</code>函数的帮助下创建在 HBW 内存中分配的窗口段。</p>
<h3 id="MPI-Info"><a href="#MPI-Info" class="headerlink" title="MPI_Info"></a>MPI_Info</h3><p>您可以借助<code>MPI_Info</code>对象控制窗口段的内存分配，该对象作为参数传递给<code>MPI_Win_allocate</code>或<code>MPI_Win_allocate_shared</code>函数。在应用程序中，如果使用<code>numa_bind_policy</code>键指定这样的对象，则根据<code>numa_bind_policy</code>的值分配窗口段。可能的值与<code>I_MPI_BIND_WIN_ALLOCATE</code>的相同。</p>
<p>演示<code>MPI_Info</code>使用的代码片段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MPI_Info info;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">MPI_Info_create</span>( &amp;info );</span><br><span class="line"><span class="built_in">MPI_Info_set</span>( info, <span class="string">&quot;numa_bind_policy&quot;</span>, <span class="string">&quot;hbw_preferred&quot;</span> );</span><br><span class="line">...</span><br><span class="line"><span class="built_in">MPI_Win_allocate_shared</span>( size, disp_unit, info, comm, &amp;baseptr, &amp;win );</span><br></pre></td></tr></table></figure></p>
<p>当您为窗口段指定内存放置策略时，英特尔 MPI 库根据以下优先级识别配置：</p>
<ol>
<li><code>MPI_Info</code>的设置。</li>
<li><code>I_MPI_HBW_POLICY</code>的设置，如果你指定了<code>&lt;win_allocate policy&gt;</code>。</li>
<li><code>I_MPI_BIND_WIN_ALLOCATE</code>的设置。</li>
</ol>
<h2 id="Environment-Variables-for-Asynchronous-Progress-Control"><a href="#Environment-Variables-for-Asynchronous-Progress-Control" class="headerlink" title="Environment Variables for Asynchronous Progress Control"></a>Environment Variables for Asynchronous Progress Control</h2><p>仅<code>release_mt</code>和<code>debug_mt</code>库配置支持此功能。要指定配置，请运行以下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> &lt;installdir&gt;/bin/vars.sh release_mt</span><br></pre></td></tr></table></figure></p>
<p><code>I_MPI_ASYNC_PROGRESS</code>控制进程线程的使用。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_ASYNC_PROGRESS=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;arg&gt;</code>二元指标<ul>
<li><code>disable | no | off | 0</code> 禁用每个进程的异步进度线程。 这是默认值。</li>
<li><code>enable | yes | on | 1</code>  启用进度线程。</li>
</ul>
</li>
</ul>
<p>设置此环境变量以启用异步进度。 如果禁用，则忽略·I_MPI_ASYNC_PROGRESS_*`。</p>
<p><code>I_MPI_ASYNC_PROGRESS_THREADS</code>控制进度线程的数量。设置此环境变量以控制每个rank的进度线程。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_ASYNC_PROGRESS_THREADS=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;nthreads&gt;</code> 定义进度线程的数量。 默认值为 1。</li>
</ul>
<p><code>I_MPI_ASYNC_PROGRESS_PIN</code>控制异步进度线程固定。设置此环境变量以控制本地进程的所有进程线程的固定。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_ASYNC_PROGRESS_PIN=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;arg&gt;</code> 逗号分隔的逻辑处理器列表</li>
<li><code>&lt;CPU list&gt;</code>将本地进程的所有进程线程固定到列出的 CPU。 默认情况下，N 个进程线程被固定到最后 N 个逻辑处理器。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_ASYNC_PROGRESS_THREADS=3</span><br><span class="line">I_MPI_ASYNC_PROGRESS_PIN=”0,1,2,3,4,5”</span><br></pre></td></tr></table></figure>
<p>在每个节点有三个 MPI 进程的情况下，第一个进程的进度线程被固定到 0、1，第二个进程被固定到 2、3，第三个进程被固定到 4、5。</p>
<p><code>I_MPI_ASYNC_PROGRESS_ID_KEY</code>设置用于显式定义通信器的进度线程 ID 的<code>MPI_info</code>对象键。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_ASYNC_PROGRESS_ID_KEY=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;key&gt;</code>MPI_info 对象键。 默认值为thread_id。</li>
</ul>
<p>设置此环境变量以控制用于定义通信器的进度线程 ID 的<code>MPI_info</code>对象键。 进度线程 id 用于进度线程之间的工作分配。 默认情况下，通过第一个进度线程通信。从计算线程的固定中排除进程线程的选定处理器。</p>
<p>如需更多信息和示例，请参阅英特尔® MPI 库开发人员指南的异步进度控制部分。</p>
<h2 id="Environment-Variables-for-Multi-EP"><a href="#Environment-Variables-for-Multi-EP" class="headerlink" title="Environment Variables for Multi-EP"></a>Environment Variables for Multi-EP</h2><p>注意此功能仅支持<code>release_mt</code>和<code>debug_mt</code>库配置。要指定配置，请运行以下命令：<code>$ source &lt;install-dir&gt;/bin/vars.sh release_mt</code></p>
<p><code>I_MPI_THREAD_SPLIT</code>使用此环境变量来控制<code>I_MPI_THREAD_SPLIT</code>编程模型。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_THREAD_SPLIT=&lt;value&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>value</code>二元指标<ul>
<li><code>0 | no | off | disable</code>禁用<code>MPI_THREAD_SPLIT</code>模型支持。这是默认值。</li>
<li><code>1 | yes | on | enable</code> 启用<code>MPI_THREAD_SPLIT</code>模型支持。</li>
</ul>
</li>
</ul>
<p><code>I_MPI_THREAD_RUNTIME</code>使用此环境变量来控制线程运行时支持。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_THREAD_RUNTIME=&lt;value&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>value</code>线程运行时</li>
<li><code>generic</code>启用运行时支持（例如，pthreads、TBB）。 如果在运行时无法检测到 OpenMP*，则这是默认值。</li>
<li><code>openmp</code>启用 OpenMP 运行时支持。 如果在运行时检测到 OpenMP，则这是默认值。</li>
</ul>
<p><code>I_MPI_THREAD_MAX</code>使用此环境变量来设置每个进程同时使用的最大线程数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_THREAD_MAX=&lt;int&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;int&gt;</code> 每个rank的最大线程数。如果<code>I_MPI_THREAD_RUNTIME</code>设置为<code>openmp</code>，则默认值为<code>omp_get_max_threads()</code>。</li>
</ul>
<p><code>I_MPI_THREAD_ID_KEY</code>使用此环境变量设置用于显式定义逻辑线程号<code>thread_id</code>的 MPI 信息对象键。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_THREAD_ID_KEY=&lt;string&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;string&gt;</code>定义<code>MPI_info</code>对象键。 默认值为<code>thread_id</code></li>
</ul>
<h2 id="Other-Environment-Variables"><a href="#Other-Environment-Variables" class="headerlink" title="Other Environment Variables"></a>Other Environment Variables</h2><p><code>I_MPI_DEBUG</code>当 MPI 程序开始运行时打印调试信息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_DEBUG=&lt;level&gt;[,&lt;flags&gt;]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;level&gt;</code>指示提供的调试信息的级别。<ul>
<li><code>0</code> 不输出调试信息。 这是默认值。</li>
<li><code>1,2</code> 输出 libfabric* 版本和提供程序。</li>
<li><code>3</code> 输出有效的MPI rank、pid 和节点映射表。</li>
<li><code>4</code> 输出进程锁定信息。</li>
<li><code>5</code> 特定于英特尔® MPI 库的输出环境变量。</li>
<li><code>&gt; 5</code> 添加额外级别的调试信息。</li>
</ul>
</li>
<li><code>&lt;flags&gt;</code> 以逗号分隔的调试标志列表<ul>
<li><code>pid</code> 显示每个调试消息的进程 ID。</li>
<li><code>tid</code> 为多线程库的每条调试消息显示线程 ID。</li>
<li><code>time</code> 显示每个调试消息的时间。</li>
<li><code>datetime</code> 显示每条调试消息的时间和日期。</li>
<li><code>host</code>显示每条调试消息的主机名。</li>
<li><code>level</code> 显示每个调试消息的级别。</li>
<li><code>scope</code> 显示每个调试消息的范围。</li>
<li><code>line</code> 显示每条调试消息的源代码行号。</li>
<li><code>file</code> 显示每条调试消息的源文件名。</li>
<li><code>nofunc</code> 不显示例程名称。</li>
<li><code>norank</code> 不显示rank。</li>
<li><code>nousrwarn</code> 禁止针对不当用例（例如，不兼容的控件组合）发出警告。</li>
<li><code>flock</code> 同步来自不同进程或线程的调试输出。</li>
<li><code>nobuf</code> 不要将缓冲 I/O 用于调试输出。</li>
</ul>
</li>
</ul>
<p>设置此环境变量以打印有关应用程序的调试信息。注意为所有rank设置相同的<code>&lt;level&gt;</code>值。您可以通过设置<code>I_MPI_DEBUG_OUTPUT</code>环境变量来指定调试信息的输出文件名。每个打印的行具有以下格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;identifier&gt;] &lt;message&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;identifier&gt;</code>默认情况下是 MPI 进程rank。 如果在<code>&lt;level&gt;</code>编号前添加“+”号，<code>&lt;identifier&gt;</code>将采用以下格式：<code>rank#pid@hostname</code>。 这里，<code>pid</code>是 UNIX* 进程 ID，<code>hostname</code>是主机名。 如果添加“-”符号，则根本不打印<code>&lt;identifier&gt;</code>。</li>
<li><code>&lt;message&gt;</code>包含调试输出。</li>
</ul>
<p>以下示例演示了可能的命令行以及相应的输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -n 1 -env I_MPI_DEBUG=2 ./a.out</span><br><span class="line">...</span><br><span class="line">[0] MPI startup(): shared memory data transfer mode</span><br></pre></td></tr></table></figure></p>
<p>以下命令相等并产生相同的输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -n 1 -env I_MPI_DEBUG=2,pid,host ./a.out</span><br><span class="line">...</span><br><span class="line">[0#1986@mpicluster001] MPI startup(): shared memory data transfer mode</span><br></pre></td></tr></table></figure></p>
<p>注意 使用 -g 选项进行编译会添加大量打印的调试信息。</p>
<p><code>I_MPI_DEBUG_OUTPUT</code>设置调试信息的输出文件名。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_DEBUG_OUTPUT=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>stdout</code> 输出到标准输出。 这是默认值。</li>
<li><code>stderr</code> 输出到标准错误。</li>
<li><code>&lt;file_name&gt;</code> 指定调试信息的输出文件名（最大文件名长度为 256 个符号）。</li>
</ul>
<p>如果要将调试信息的输出与应用程序生成的输出分开，请设置此环境变量。 如果您使用 %r、%p 或 %h 等格式，则会相应地将rank、进程 ID 或主机名添加到文件名中。</p>
<p><code>I_MPI_DEBUG_COREDUMP</code>在 MPI 应用程序执行期间出现故障时控制核心转储文件的生成。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_DEBUG_COREDUMP=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable|yes|on|1 启用核心转储文件生成。</li>
<li>disable|no|off|0 不生成核心转储文件。 默认值。</li>
</ul>
<p>设置此环境变量以在分段错误导致终止的情况下启用核心转储文件转储。 可用于发布和调试版本。</p>
<p><code>I_MPI_STATS</code>使用应用程序性能快照从您的应用程序收集 MPI 统计信息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_STATS=&lt;level&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;level&gt;</code>表明收集的统计数据的级别<ul>
<li>1,2,3,4,5 指定级别以指示应用程序性能快照 (APS) 收集的 MPI 统计信息量。官方 APS 文档中提供了对级别的完整描述。</li>
</ul>
</li>
</ul>
<p>设置此变量以使用应用程序性能快照从 MPI 应用程序收集与 MPI 相关的统计信息。 该变量创建一个包含统计数据的新文件夹<code>aps_result_&lt;date&gt;-&lt;time&gt;</code>。 要分析收集的数据，请使用 aps 实用程序。 例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ export I_MPI_STATS=5</span><br><span class="line">$ mpirun -n 2 ./myApp</span><br><span class="line">$ aps-report aps_result_20171231_235959</span><br></pre></td></tr></table></figure></p>
<p><code>I_MPI_STARTUP_MODE</code>为英特尔® MPI 库进程启动算法选择一种模式。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_STARTUP_MODE=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>pmi_shm</code> 使用共享内存来减少 PMI 调用的次数。 默认情况下启用此模式。</li>
<li><code>pmi_shm_netmod</code> 除 PMI 和共享内存外，还使用<code>netmod</code>基础结构进行地址交换逻辑。</li>
</ul>
<p><code>pmi_shm</code>和<code>pmi_shm_netmod</code>模式减少了应用程序启动时间。 使用更高的<code>-ppn</code>值可以更清楚地观察到模式的效率，而使用<code>-ppn 1</code>则根本没有改善。</p>
<p><code>I_MPI_PMI_LIBRARY</code>指定 PMI 库的第三方实现的名称。设置<code>I_MPI_PMI_LIBRARY</code>以指定第三方 PMI 库的名称。 设置此环境变量时，请提供库的完整名称及其完整路径。 当前支持的 PMI 版本：<code>PMI1</code>、<code>PMI2</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PMI_LIBRARY=&lt;name&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;name&gt;</code>第三方PMI库全称</li>
</ul>
<p><code>I_MPI_PMI_VALUE_LENGTH_MAX</code>在客户端控制 PMI 中值缓冲区的长度。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PMI_VALUE_LENGTH_MAX=&lt;length&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;length&gt;</code>以字节为单位定义缓冲区长度的值。</li>
<li><code>&lt;n&gt; &gt; 0</code> 默认值为 -1，这意味着不覆盖从<code>PMI_KVS_Get_value_length_max()</code>函数接收的值。</li>
</ul>
<p>设置这个环境变量来控制客户端PMI中值缓冲区的长度。 缓冲区的长度将是<code>I_MPI_PMI_VALUE_LENGTH_MAX</code>和<code>PMI_KVS_Get_value_length_max()</code>中的较小者。</p>
<p><code>I_MPI_OUTPUT_CHUNK_SIZE</code>设置<code>stdout/stderr</code>输出缓冲区的大小。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_OUTPUT_CHUNK_SIZE=&lt;size&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;size&gt;</code> 以千字节为单位定义输出块大小</li>
<li><code>&lt;n&gt; &gt; 0</code> 默认块大小值为 1 KB</li>
</ul>
<p>设置此环境变量以增加用于拦截来自进程的标准输出和标准错误流的缓冲区的大小。 如果<code>&lt;size&gt;</code>值不大于零，则忽略环境变量设置并显示警告消息。 将此设置用于从不同进程创建大量输出的应用程序。 使用<code>mpiexec.hydra</code>的<code>-ordered-output</code>选项，此设置有助于防止输出出现乱码。</p>
<p>注意 在执行<code>mpiexec.hydra/mpirun</code>命令之前，在 shell 环境中设置<code>I_MPI_OUTPUT_CHUNK_SIZE</code>环境变量。 不要使用<code>-genv</code>或<code>-env</code>选项来设置<code>&lt;size&gt;</code>值。这些选项仅用于将环境变量传递给 MPI 进程环境。</p>
<p><code>I_MPI_REMOVED_VAR_WARNING</code>如果设置了已删除的环境变量，则打印出警告。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_REMOVED_VAR_WARNING=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable | yes | on | 1 打印警告。 这是默认值</li>
<li>disable | no | off | 0 不要打印警告</li>
</ul>
<p><code>I_MPI_VAR_CHECK_SPELLING</code>如果设置了未知环境变量，则打印警告。如果设置了不受支持的环境变量，请使用此环境变量打印警告。如果删除或打印错误的环境变量，将打印警告。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_VAR_CHECK_SPELLING=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable | yes | on | 1 把警告打印出来。这是默认值</li>
<li>disable | no | off | 0 不要打印警告</li>
</ul>
<p><code>I_MPI_LIBRARY_KIND</code>指定英特尔MPI库配置。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_LIBRARY_KIND=&lt;value&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>release</code> 多线程优化库（带有全局锁）。这是默认值</li>
<li><code>debug</code> 多线程调试库（带全局锁）</li>
<li><code>release_mt</code>多线程优化库（线程拆分模型的每个对象锁）</li>
<li><code>debug_mt</code> 多线程调试库（对于线程拆分模型具有每个对象锁）</li>
</ul>
<p>使用此变量为<code>vars.[c]sh</code>脚本设置参数。 该脚本建立英特尔® MPI 库环境并使您能够指定适当的库配置。 要确保设置了所需的配置，请检查<code>LD_LIBRARY_PATH</code>变量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export I_MPI_LIBRARY_KIND=debug</span><br></pre></td></tr></table></figure></p>
<p>设置这个变量相当于直接向<code>vars.[c]sh</code>脚本传递一个参数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ . &lt;installdir&gt;/bin/vars.sh release</span><br></pre></td></tr></table></figure></p>
<p><code>I_MPI_PLATFORM</code>选择预期的优化平台。设置此环境变量以使用预定义的平台设置。 默认值是每个节点的本地平台。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PLATFORM=&lt;platform&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;platform&gt;</code> 预期的优化平台（字符串值）<ul>
<li><code>auto</code> 仅用于异构运行以确定跨所有节点的适当平台。由于跨所有节点的集体操作，可能会减慢 MPI 初始化时间。</li>
<li><code>ivb</code>针对英特尔® 至强® 处理器 E3、E5 和 E7 V2 系列以及以前代号为 Ivy Bridge 的其他英特尔® 架构处理器进行优化。</li>
<li><code>hsw</code>针对英特尔至强处理器 E3、E5 和 E7 V3 系列以及以前代号为 Haswell 的其他英特尔® 架构处理器进行优化。</li>
<li><code>bdw</code>针对英特尔至强处理器 E3、E5 和 E7 V4 系列以及以前代号为 Broadwell 的其他英特尔架构处理器进行优化。</li>
<li><code>knl</code>优化英特尔® 至强融核™ 处理器和协处理器，以前代号为 Knights Landing。</li>
<li><code>skx</code>针对英特尔至强处理器 E3 V5 和英特尔至强可扩展家族系列以及其他以前代号为 Skylake 的英特尔架构处理器进行优化。</li>
<li><code>clx</code>针对第二代英特尔至强可扩展处理器和其他以前代号为 Cascade Lake 的英特尔® 架构处理器进行优化。</li>
<li><code>clx-ap</code>针对第二代英特尔至强可扩展处理器和其他以前代号为 Cascade Lake AP 的英特尔架构处理器进行优化。注意：如果实际平台不是 Intel，则忽略显式 clx-ap 设置。</li>
</ul>
</li>
</ul>
<p>该变量可用于 Intel 和非 Intel 微处理器，但它可能对 Intel 微处理器使用比对非 Intel 微处理器使用的其他优化。 注意<code>auto[:min]</code>、<code>auto:max</code>和<code>auto:most</code>值可能会增加 MPI 作业启动时间。</p>
<p><code>I_MPI_MALLOC</code>控制私有内存的英特尔® MPI 库自定义分配器。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_MALLOC=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>1</code> 启用私有内存的英特尔 MPI 库自定义分配器。 为<code>MPI_Alloc_mem/MPI_Free_mem</code>使用私有内存的英特尔 MPI 自定义分配器。</li>
<li><code>0</code> 禁用私有内存的英特尔 MPI 库自定义分配器。将系统提供的内存分配器用于<code>MPI_Alloc_mem/MPI_Free_mem</code>。</li>
</ul>
<p>使用此环境变量来启用或禁用<code>MPI_Alloc_mem/MPI_Free_mem</code>专用内存的英特尔 MPI 库自定义分配器。默认情况下，<code>I_MPI_MALLOC</code>为<code>release</code>和<code>debug</code>英特尔 MPI 库配置启用，而为<code>release_mt</code>和<code>debug_mt</code>配置禁用。注意如果专用内存的英特尔 MPI 库自定义分配器不支持该平台，则使用系统提供的内存分配器并忽略<code>I_MPI_MALLOC</code>变量。</p>
<p><code>I_MPI_SHM_HEAP</code>控制共享内存的英特尔® MPI 库自定义分配器。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_HEAP=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>1</code> 为<code>MPI_Alloc_mem/MPI_Free_mem</code>使用共享内存的英特尔 MPI 自定义分配器。</li>
<li><code>0</code> 不要将共享内存的英特尔 MPI 自定义分配器用于<code>MPI_Alloc_mem/MPI_Free_mem</code>。</li>
</ul>
<p>使用此环境变量为<code>MPI_Alloc_mem/MPI_Free_mem</code>启用或禁用共享内存的英特尔 MPI 库自定义分配器。默认情况下，禁用<code>I_MPI_SHM_HEAP</code>。如果启用，它可以提高共享内存传输的性能，因为在这种情况下，可以只进行一次内存复制操作，而不是两次拷入/拷出内存复制操作。如果同时启用了<code>I_MPI_SHM_HEAP</code>和<code>I_MPI_MALLOC</code>，则首先使用共享内存分配器。仅当所需的共享内存量不可用时才使用私有内存分配器。</p>
<p>默认情况下，共享内存段在<code>/dev/shm/</code>挂载点上的<code>tmpfs</code>文件系统上分配。从 Linux 内核 4.7 开始，可以在共享内存上启用透明大页面。如果使用英特尔 MPI 库共享内存堆，建议在您的系统上启用透明大页面。要在<code>/dev/shm</code>上启用透明大页面，请联系您的系统管理员或执行以下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o remount,huge=advise /dev/shm</span><br></pre></td></tr></table></figure></p>
<p>为了使用另一个<code>tmpfs</code>挂载点而不是<code>/dev/shm/</code>，请使用<code>I_MPI_SHM_FILE_PREFIX_4K</code>、<code>I_MPI_SHM_FILE_PREFIX_2M</code>和<code>I_MPI_SHM_FILE_PREFIX_1G</code>。</p>
<p>注意如果您的应用程序不直接使用<code>MPI_Alloc_mem/MPI_Free_mem</code>，您可以通过预加载<code>libmpi_shm_heap_proxy.so</code>库来覆盖标准<code>malloc/calloc/realloc/free</code>过程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LD_PRELOAD=$I_MPI_ROOT/lib/libmpi_shm_heap_proxy.so</span><br><span class="line">export I_MPI_SHM_HEAP=1</span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，<code>malloc/calloc/realloc</code>是<code>MPI_Alloc_mem</code>的代理，<code>free</code>是<code>MPI_Free_mem</code>的代理。注意如果共享内存的英特尔 MPI 库自定义分配器不支持该平台，则<code>I_MPI_SHM_HEAP</code>变量将被忽略。</p>
<p><code>I_MPI_SHM_HEAP_VSIZE</code>更改可用于英特尔 MPI 库自定义共享内存分配器的虚拟共享内存的大小（每列）。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_HEAP_VSIZE=&lt;size&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;size&gt;</code> 共享内存堆中使用的共享内存的大小（每列）（以兆字节为单位）。</li>
<li><code>&gt; 0</code> 如果为<code>MPI_Alloc_mem/MPI_Free_mem</code>启用共享内存堆，则默认值为 4096。</li>
</ul>
<p>共享内存的英特尔 MPI 库自定义分配器适用于固定大小的虚拟共享内存。 共享内存段是在<code>MPI_Init</code>上分配的，以后不能扩大。<code>I_MPI_SHM_HEAP_VSIZE=0</code>完全禁用英特尔 MPI 库共享内存分配器。</p>
<p><code>I_MPI_SHM_HEAP_CSIZE</code>更改共享内存的英特尔 MPI 库自定义分配器中缓存的共享内存的大小（每列）。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_HEAP_CSIZE=&lt;size&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;size&gt;</code> 英特尔 MPI 库共享内存分配器中使用的共享内存大小（每列）（以兆字节为单位）。</li>
<li><code>&gt; 0</code> 这取决于可用的共享内存大小和等级数。 通常大小小于 256。</li>
</ul>
<p><code>I_MPI_SHM_HEAP_CSIZE</code>的小值可能会减少整体共享内存消耗。 此变量的较大值可能会加速<code>MPI_Alloc_mem/MPI_Free_mem</code>。</p>
<p><code>I_MPI_SHM_HEAP_OPT</code>更改共享内存的英特尔 MPI 库自定义分配器的优化模式。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_SHM_HEAP_OPT=&lt;mode&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>rank</code> 在这种模式下，每个<code>rank</code>都有自己专用的共享内存量。 这是<code>I_MPI_SHM_HEAP=1</code>时的默认值</li>
<li><code>numa</code> 在这种模式下，来自 NUMA 节点的所有列使用相同数量的共享内存。</li>
</ul>
<p>当每个<code>rank</code>使用相同数量的内存时，建议使用<code>I_MPI_SHM_HEAP_OPT=rank</code>，当<code>rank</code>使用显着不同的内存量时，建议使用<code>I_MPI_SHM_HEAP_OPT=numa</code>。 通常，<code>I_MPI_SHM_HEAP_OPT=rank</code>的工作速度比<code>I_MPI_SHM_HEAP_OPT=numa</code>快，但<code>numa</code>优化模式可能会消耗较小的共享内存量。</p>
<p><code>I_MPI_WAIT_MODE</code>控制超额订阅模式的英特尔® MPI 库优化。建议在超额认购模式下使用该变量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_WAIT_MODE=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>0</code> 优化 MPI 应用程序在正常模式下工作（1 个 CPU 上的 1 个rank）。 如果计算节点上的进程数小于或等于节点上的 CPU 数，则这是默认值。</li>
<li><code>1</code> 优化 MPI 应用工作在超额订阅模式（1 CPU 上多列）。 如果计算节点上的进程数大于节点上的 CPU 数，则这是默认值。</li>
</ul>
<p><code>I_MPI_THREAD_YIELD</code>在 MPI 忙等待时间控制英特尔® MPI 库线程行为。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_THREAD_YIELD=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>0</code> 在忙等待（自旋等待）期间对线程挂起不做任何事情。 这是<code>I_MPI_WAIT_MODE=0</code>时的默认值</li>
<li><code>1</code> 在忙等待期间为<code>I_MPI_PAUSE_COUNT</code>执行暂停处理器指令。</li>
<li><code>2</code> 在忙等待期间执行<code>shied_yield()</code>系统调用以获得线程挂起。 这是<code>I_MPI_WAIT_MODE=1</code>时的默认值</li>
<li><code>3</code> 在忙等待期间执行<code>usleep()</code>系统调用<code>I_MPI_THREAD_SLEEP</code>微秒数，用以线程挂起。</li>
</ul>
<p><code>I_MPI_THREAD_YIELD=0</code>或<code>I_MPI_THREAD_YIELD=1</code>在正常模式下和<code>I_MPI_THREAD_YIELD=2</code>或<code>I_MPI_THREAD_YIELD=3</code>在超额订阅模式下。</p>
<p><code>I_MPI_PAUSE_COUNT</code>在 MPI 繁忙等待时间内，控制英特尔® MPI 库暂停计数以实现线程挂起自定义。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_PAUSE_COUNT=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&gt;=0</code> 在 MPI 繁忙等待时间内，线程挂起定制的暂停计数。 默认值为 0。通常情况下，该值小于 100。</li>
</ul>
<p>该变量在<code>I_MPI_THREAD_YIELD=1</code>时适用。<code>I_MPI_PAUSE_COUNT</code>的小值可能会提高性能，而较大的值可能会降低能耗。</p>
<p><code>I_MPI_THREAD_SLEEP</code>控制英特尔® MPI 库线程睡眠微秒超时时间，以在 MPI 忙等待过程中自定义线程挂起。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_THREAD_SLEEP=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>&gt;=0</code> 线程睡眠微秒超时数。 默认值为 0。通常情况下，该值小于 100。</li>
</ul>
<p>当<code>I_MPI_THREAD_YIELD=3</code>时，该变量适用。<code>I_MPI_PAUSE_COUNT</code>的小值可能会提高正常模式下的性能，而较大的值可能会提高超额订阅模式下的性能</p>
<p><code>I_MPI_EXTRA_FILESYSTEM</code>控制对并行文件系统的本机支持。使用此环境变量来启用或禁用对并行文件系统的本机支持。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_EXTRA_FILESYSTEM=&lt;arg&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>enable | yes | on | 1</code>启用对并行文件系统的本机支持。</li>
<li><code>disable | no | off | 0</code> 禁用对并行文件系统的本机支持。 这是默认值。</li>
</ul>
<p><code>I_MPI_EXTRA_FILESYSTEM_FORCE</code> 强制文件系统识别逻辑。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I_MPI_EXTRA_FILESYSTEM_FORCE=&lt;ufs|nfs|gpfs|panfs|lustre&gt;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/06/openmp%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/06/openmp%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">OpenMP基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-06 21:45:00" itemprop="dateCreated datePublished" datetime="2021-12-06T21:45:00+08:00">2021-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 16:52:01" itemprop="dateModified" datetime="2022-12-26T16:52:01+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-OpenMP基本介绍"><a href="#1-OpenMP基本介绍" class="headerlink" title="1. OpenMP基本介绍"></a>1. OpenMP基本介绍</h1><p>OpenMP是一个编译器指令和库函数的集合，主要是为共享式存储计算机上的并行程序设计使用的。目前支持OpenMP的语言主要有Fortran，C/C++。</p>
<h2 id="1-1-fork-join并行执行模式的概念"><a href="#1-1-fork-join并行执行模式的概念" class="headerlink" title="1.1 fork/join并行执行模式的概念"></a>1.1 fork/join并行执行模式的概念</h2><p>OpenMP在并行执行程序时，采用的是fork/join式并行模式，共享存储式并行程序就是使用fork/join式并行的。在开始时，只有一个叫做主线程的运行线程存在 。在运行过程中，当遇到需要进行并行计算的时候，派生出（Fork）线程来执行并行任务 。在并行代码结束执行，派生线程退出或挂起，控制流程回到单独的主线程中（Join）。</p>
<p>如图，标准并行模式执行代码的基本思想是，程序开始时只有一个主线程，程序中的串行部分都由主线程执行，并行的部分是通过派生其他线程来执行，但是如果并行部分没有结束时是不会执行串行部分的，先看一个简单例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">     <span class="type">clock_t</span> t1 = <span class="built_in">clock</span>();</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         a = i<span class="number">+1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">clock_t</span> t2 = <span class="built_in">clock</span>();</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Time = %d\n&quot;</span>, t2-t1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">clock_t</span> t1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">     <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ )&#123;</span><br><span class="line">         <span class="built_in">test</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">clock_t</span> t2 = <span class="built_in">clock</span>();</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Total time = %d\n&quot;</span>, t2-t1);</span><br><span class="line">     <span class="built_in">test</span>();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>main()</code>函数中，没有执行完for循环中的代码之前，后面的<code>clock_t t2 = clock();</code>这行代码是不会执行的，如果和调用线程创建函数相比，它相当于先创建线程，并等待线程执行完，所以这种并行模式中在主线程里创建的线程并没有和主线程并行运行。</p>
<h2 id="OpenMP编程模型"><a href="#OpenMP编程模型" class="headerlink" title="OpenMP编程模型"></a>OpenMP编程模型</h2><h3 id="共享内存模型"><a href="#共享内存模型" class="headerlink" title="共享内存模型"></a>共享内存模型</h3><p>OpenMP是为多处理器或多核共享内存机器设计的。底层架构可以是共享内存 UMA 或 NUMA。</p>
<p>Uniform Memory Access 一致内存访问<br><img src="/img/22782486-39c6a9a1da904c10.gif" alt=""></p>
<p>Ununiform Memory Access 非一致内存访问<br><img src="/img/22782486-6e84877ae3d67aae.gif" alt=""></p>
<p>因为OpenMP是为共享内存并行编程而设计的，所以它在很大程度上局限于单节点并行性。通常，节点上处理元素(核心)的数量决定了可以实现多少并行性。</p>
<h3 id="在-HPC-中使用-OpenMP-的动机"><a href="#在-HPC-中使用-OpenMP-的动机" class="headerlink" title="在 HPC 中使用 OpenMP 的动机"></a>在 HPC 中使用 OpenMP 的动机</h3><ul>
<li>OpenMP本身的并行性仅限于单个节点。</li>
<li>对于高性能计算(HPC - High Performance Computing)应用程序，OpenMP 与 MPI 相结合以实现分布式内存并行。这通常被称为混合并行编程。<ul>
<li>OpenMP 用于每个节点上的计算密集型工作。</li>
<li>MPI 用于实现节点之间的通信和数据共享。</li>
</ul>
</li>
</ul>
<p>这使得并行性可以在集群的整个范围内实现Hybrid OpenMP-MPI Parallelism。</p>
<h3 id="基于线程的并行性"><a href="#基于线程的并行性" class="headerlink" title="基于线程的并行性"></a>基于线程的并行性</h3><p>OpenMP 程序仅通过使用线程来实现并行性。执行线程是操作系统可以调度的最小处理单元。一种可以自动运行的子程序，这个概念可能有助于解释什么是线程。线程存在于单个进程的资源中。没有这个进程，它们就不复存在。通常，线程的数量与机器处理器/核心的数量相匹配。但是，线程的实际使用取决于应用程序。</p>
<h3 id="显式并行性"><a href="#显式并行性" class="headerlink" title="显式并行性"></a>显式并行性</h3><p>OpenMP 是一个显式的(而不是自动的)编程模型，为程序员提供了对并行化的完全控制。并行化可以像获取串行程序和插入编译器指令一样简单…或者像插入子程序来设置多个并行级别、锁甚至嵌套锁一样复杂</p>
<h3 id="Fork-Join-模型"><a href="#Fork-Join-模型" class="headerlink" title="Fork - Join 模型"></a>Fork - Join 模型</h3><p>OpenMP 使用并行执行的 fork-join 模型：<br><img src="/img/22782486-dbd6ee9610fb13a5.gif" alt=""></p>
<ul>
<li>所有 OpenMP 程序都开始于一个主线程。主线程按顺序执行，直到遇到第一个并行区域结构。</li>
<li>FORK：主线程然后创建一组并行线程。</li>
<li>之后程序中由并行区域结构封装的语句在各个团队线程中并行执行。</li>
<li>JOIN：当团队线程完成并行区域结构中的语句时，它们将进行同步并终止，只留下主线程。</li>
</ul>
<p>并行区域的数量和组成它们的线程是任意的。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li>因为 OpenMP 是共享内存编程模型，所以在默认情况下，并行区域中的大多数数据都是共享的。</li>
<li>一个并行区域中的所有线程都可以同时访问共享数据。</li>
<li>OpenMP 为程序员提供了一种方法，可以在不需要默认共享范围的情况下显式地指定数据的“作用域”。</li>
</ul>
<h3 id="动态线程"><a href="#动态线程" class="headerlink" title="动态线程"></a>动态线程</h3><p>该 API 为运行时环境提供了动态更改线程数量的功能，这些线程用于执行并行区域。如有可能，旨在促进更有效地利用资源。实现可能支持这个特性，也可能不支持。</p>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><p>OpenMP 没有指定任何关于并行 I/O 的内容。如果多个线程试图从同一个文件进行写/读操作，这一点尤其重要。如果每个线程都对不同的文件执行 I/O，那么问题就不那么重要了。完全由程序员来确保在多线程程序的上下文中正确地执行 I/O。</p>
<h3 id="内存模型：经常刷新？"><a href="#内存模型：经常刷新？" class="headerlink" title="内存模型：经常刷新？"></a>内存模型：经常刷新？</h3><p>OpenMP 提供了线程内存的“宽松一致性”和“临时”视图(用他们的话说)。换句话说，线程可以“缓存”它们的数据，并且不需要始终与实际内存保持精确的一致性。当所有线程以相同的方式查看共享变量非常重要时，程序员负责确保所有线程根据需要刷新该变量。</p>
<h1 id="2-OpenMP编程"><a href="#2-OpenMP编程" class="headerlink" title="2. OpenMP编程"></a>2. OpenMP编程</h1><h2 id="2-1-OpenMP指令和库函数介绍"><a href="#2-1-OpenMP指令和库函数介绍" class="headerlink" title="2.1 OpenMP指令和库函数介绍"></a>2.1 OpenMP指令和库函数介绍</h2><p>下面来介绍OpenMP的基本指令和常用指令的用法，在C/C++中，OpenMP指令使用的格式为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp 指令 [子句[子句]…]</span><br></pre></td></tr></table></figure><br>前面提到的<code>parallel for</code>就是一条指令，有些书中也将OpenMP的“指令”叫做“编译指导语句”，后面的子句是可选的。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp parallel private(i, j)</span><br></pre></td></tr></table></figure></p>
<p><code>parallel</code>就是指令，<code>private</code>是子句。为叙述方便把包含#pragma和OpenMP指令的一行叫做语句，如上面那行叫parallel语句。</p>
<h2 id="2-2-OpenMP指令列表"><a href="#2-2-OpenMP指令列表" class="headerlink" title="2.2 OpenMP指令列表"></a>2.2 OpenMP指令列表</h2><p>这里我们先列举出OpenMP常用的指令和函数，并附上一些简单的说明。如果你看不懂，没关系，后面我们会对每个指令有详细的例子介绍。</p>
<ul>
<li><code>parallel</code>：用在一个代码段之前，表示这段代码将被多个线程并行执行</li>
<li><code>for</code>：用于for循环之前，将循环分配到多个线程中并行执行，必须保证每次循环之间无相关性。</li>
<li><code>parallel for</code>，<code>parallel</code>和<code>for</code>语句的结合，也是用在一个for循环之前，表示for循环的代码将被多个线程并行执行。</li>
<li><code>sections</code>，用在可能会被并行执行的代码段之前</li>
<li><code>parallel sections</code>，<code>parallel</code>和<code>sections</code>两个语句的结合</li>
<li><code>critical</code>，用在一段代码临界区之前</li>
<li><code>single</code>，用在一段只被单个线程执行的代码段之前，表示后面的代码段将被单线程执行。</li>
<li><code>flush</code>，用来保证线程的内存临时视图和实际内存保持一致，即各个线程看到的共享变量是一致的</li>
<li><code>barrier</code>，用于并行区内代码的线程同步，所有线程执行到barrier时要停止，直到所有线程都执行到barrier时才继续往下执行。</li>
<li><code>atomic</code>，用于指定一块内存区域被制动更新</li>
<li><code>master</code>，用于指定一段代码块由主线程执行</li>
<li><code>ordered</code>， 用于指定并行区域的循环按顺序执行</li>
<li><code>threadprivate</code>，用于指定一个变量是线程私有的</li>
<li><code>copyprivate</code>，配合single指令，将指定线程的专有变量广播到并行域内其他线程的同名变量中；</li>
<li><code>copyin n</code>，用来指定一个threadprivate类型的变量需要用主线程同名变量进行初始化；</li>
<li><code>default</code>，用来指定并行域内的变量的使用方式，缺省是shared。</li>
</ul>
<h2 id="2-3-OpenMP库函数"><a href="#2-3-OpenMP库函数" class="headerlink" title="2.3 OpenMP库函数"></a>2.3 OpenMP库函数</h2><p>OpenMP除上述指令外，还有一些库函数，OpenMP运行时库函数原本用以设置和获取执行环境相关的信息.其也包含一系列用以同步的API.要使用运行时函数库所包含的函数，应该在相应的源文件中包含OpenMP头文件omp.h.OpenMP的运行时库函数的使用类似于相应编程语言内部的函数调用.</p>
<p>由编译指导语句和运行时库函数可见，OpenMP同时结合了两种并行编程的方式，通过编译指导语句，可以将串行的程序逐步地改造成一个并行程序，达到增量更新程序的目的，从而减少程序编写人员的一定负担。同时，这样的方式也能将串行程序和并行程序保存在同一个源代码文件当中。OpenMP在运行的时候，需要运行函数库的支持，并会获取一些环境变量来控制运行的过程。环境变量是动态函数库中用来控制函数运行的一些参数.</p>
<p>OpenMP API 包括越来越多的运行时库函数。这些函数有多种用途，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>opm_set_num_threads</td>
<td>设置将在下一个并行区域中使用的线程数</td>
</tr>
<tr>
<td>opm_get_num_threads</td>
<td>返回当前在团队中执行并行区域的线程数，该区域是调用该线程的地方</td>
</tr>
<tr>
<td>opm_get_max_threads</td>
<td>返回可通过调用 opm_get_num_threads 函数返回的最大值</td>
</tr>
<tr>
<td>opm_get_thread_num</td>
<td>返回在团队中执行此调用的线程的线程号</td>
</tr>
<tr>
<td>opm_get_thread_limit</td>
<td>返回程序可用的 OpenMP 线程的最大数量</td>
</tr>
<tr>
<td>opm_get_num_procs</td>
<td>返回程序可用的处理器数量</td>
</tr>
<tr>
<td>opm_in_parallel</td>
<td>用于确定正在执行的代码段是否并行</td>
</tr>
<tr>
<td>opm_set_dynamic</td>
<td>启用或禁用(由运行时系统)可用于执行并行区域的线程数的动态调整</td>
</tr>
<tr>
<td>opm_get_dynamic</td>
<td>用于确定是否启用动态线程调整</td>
</tr>
<tr>
<td>opm_set_nested</td>
<td>用于启用或禁用嵌套并行性</td>
</tr>
<tr>
<td>opm_get_nested</td>
<td>用于确定是否启用嵌套并行性</td>
</tr>
<tr>
<td>opm_set_schedule</td>
<td>在 OpenMP 指令中将“runtime”用作调度类型时，设置循环调度策略</td>
</tr>
<tr>
<td>opm_get_schedule</td>
<td>当 OpenMP 指令中使用“runtime”作为调度类型时，返回循环调度策略</td>
</tr>
<tr>
<td>opm_set_max-active_levels</td>
<td>设置嵌套并行区域的最大数目</td>
</tr>
<tr>
<td>opm_get_max-active_levels</td>
<td>返回嵌套并行区域的最大数目</td>
</tr>
<tr>
<td>opm_get_level</td>
<td>返回嵌套并行区域的当前级别</td>
</tr>
<tr>
<td>opm_get_ancestor_thread_num</td>
<td>对于当前线程的给定嵌套级别，返回祖先线程的线程数</td>
</tr>
<tr>
<td>opm_get_team_size</td>
<td>对于当前线程的给定嵌套级别，返回线程团队的大小</td>
</tr>
<tr>
<td>opm_get_active_level</td>
<td>返回包含调用的任务的嵌套活动并行区域的数目</td>
</tr>
<tr>
<td>opm_in_final</td>
<td>如果程序在最后一个任务区域执行，则返回true；否则返回false</td>
</tr>
<tr>
<td>opm_init_lock</td>
<td>初始化与锁变量关联的锁</td>
</tr>
<tr>
<td>opm_destory_lock</td>
<td>将给定的锁变量与任何锁分离</td>
</tr>
<tr>
<td>opm_set_lock</td>
<td>获得锁的所有权</td>
</tr>
<tr>
<td>opm_unset_lock</td>
<td>释放锁</td>
</tr>
<tr>
<td>opm_test_lock</td>
<td>尝试设置锁，但如果锁不可用，则不会阻塞</td>
</tr>
<tr>
<td>opm_init_nest_lock</td>
<td>初始化与锁变量关联的嵌套锁</td>
</tr>
<tr>
<td>opm_destory_nest_lock</td>
<td>将给定的嵌套锁变量与任何锁分离</td>
</tr>
<tr>
<td>opm_set_nest_lock</td>
<td>获取嵌套锁的所有权</td>
</tr>
<tr>
<td>opm_unset_nest_lock</td>
<td>释放嵌套锁</td>
</tr>
<tr>
<td>opm_test_nest_lock</td>
<td>尝试设置嵌套锁，但如果锁不可用，则不会阻塞</td>
</tr>
<tr>
<td>opm_get_wtime</td>
<td>提供便携式挂钟定时程序</td>
</tr>
<tr>
<td>opm_get_wtick</td>
<td>返回一个双精度浮点值，该值等于连续时钟滴答之间的秒数</td>
</tr>
</tbody>
</table>
</div>
<p>对于C/C++，所有运行时库函数都是实际的子程序。对于Fortran来说，有些是函数，有些是子程序。例如:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">omp_get_num_threads</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure><br>注意，对于C/C++，通常需要包含<code>&lt;omp.h&gt;</code>头文件。</p>
<p>对于锁程序/函数：</p>
<ul>
<li>锁变量只能通过锁程序访问</li>
<li>对于Fortran，锁变量的类型应该是integer，并且要足够大，以便容纳一个地址。</li>
<li>对于C/C++，lock 变量的类型必须是<code>omp_lock_t</code>或<code>omp_nest_lock_t</code>，这取决于所使用的函数。</li>
</ul>
<p>实现注意事项：</p>
<ul>
<li>实现可能支持也可能不支持所有 OpenMP API 特性。例如，如果支持嵌套并行，那么它可能只是名义上的，因为嵌套并行区域可能只有一个线程。</li>
<li>有关详细信息，请参阅您的实现文档—或者亲自试验一下，如果您在文档中找不到它，请自己查找。</li>
</ul>
<h2 id="2-3-OpenMP子句"><a href="#2-3-OpenMP子句" class="headerlink" title="2.3 OpenMP子句"></a>2.3 OpenMP子句</h2><ul>
<li><code>private</code>：指定每个线程都有它自己的变量私有副本。</li>
<li><code>firstprivate</code>：指定每个线程都有它自己的变量私有副本，并且变量要被继承主线程中的初值。</li>
<li><code>lastprivate</code>：主要是用来指定将线程中的私有变量的值在并行处理结束后复制回主线程中的对应变量。</li>
<li><code>reduce</code>：用来指定一个或多个变量是私有的，并且在并行处理结束后这些变量要执行指定的运算。</li>
<li><code>nowait</code>：忽略指定中暗含的等待</li>
<li><code>num_threads</code>：指定线程的个数</li>
<li><code>schedule</code>：指定如何调度for循环迭代</li>
<li><code>shared</code>：指定一个或多个变量为多个线程间的共享变量</li>
<li><code>ordered</code>：用来指定for循环的执行要按顺序执行</li>
<li><code>copyprivate</code>：用于single指令中的指定变量为多个线程的共享变量</li>
<li><code>copyin</code>：用来指定一个threadprivate的变量的值要用主线程的值进行初始化。</li>
<li><code>default</code>：用来指定并行处理区域内的变量的使用方式，缺省是shared</li>
</ul>
<h2 id="2-4-环境变量"><a href="#2-4-环境变量" class="headerlink" title="2.4 环境变量"></a>2.4 环境变量</h2><p>OpenMP 提供了几个环境变量，用于在运行时控制并行代码的执行。这些环境变量可以用来控制这些事情：</p>
<ul>
<li>设置线程数</li>
<li>指定如何划分循环交互</li>
<li>将线程绑定到处理器</li>
<li>启用/禁用嵌套的并行性；设置嵌套并行度的最大级别</li>
<li>启用/禁用动态线程</li>
<li>设置线程堆栈大小</li>
<li>设置线程等待策略</li>
</ul>
<p>设置 OpenMP 环境变量的方法与设置任何其他环境变量的方法相同，并且取决于您使用的是哪种 shell。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">csh/tcsh: setenv OMP_NUM_THREADS 8</span><br><span class="line">sh/bash:  <span class="built_in">export</span> OMP_NUM_THREADS=8</span><br></pre></td></tr></table></figure></p>
<p>OpenMP 提供了以下环境变量来控制并行代码的执行。所有环境变量名都是大写的。分配给它们的值不区分大小写。</p>
<p><code>OMP_SCHEDULE</code>只适用于DO， PARALLEL DO (Fortran)和 for， parallel for (C/C++)指令，它们的 schedule 子句设置为运行时。此变量的值决定如何在处理器上调度循环的迭代。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_SCHEDULE <span class="string">&quot;guided, 4&quot;</span> </span><br><span class="line">setenv OMP_SCHEDULE <span class="string">&quot;dynamic&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><code>OMP_NUM_THREADS</code>设置执行期间使用的最大线程数。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_NUM_THREADS 8</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_DYNAMIC</code>启用或禁用可用于并行区域执行的线程数量的动态调整。有效值为 TRUE 或 FALSE。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_DYNAMIC TRUE</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_PROC_BIND</code>启用或禁用线程绑定到处理器。有效值为 TRUE 或 FALSE。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_PROC_BIND TRUE</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_NESTED</code>启用或禁用嵌套并行性。有效值为 TRUE 或 FALSE。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_NESTED TRUE</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_STACKSIZE</code>控制已创建(非主)线程的堆栈大小。例子:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_STACKSIZE 2000500B </span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot;3000 k &quot;</span> </span><br><span class="line">setenv OMP_STACKSIZE 10M </span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot; 10 M &quot;</span> </span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot;20 m &quot;</span> </span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot; 1G&quot;</span> </span><br><span class="line">setenv OMP_STACKSIZE 20000</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_WAIT_POLICY</code>为 OpenMP 实现提供有关等待线程的所需行为的提示。一个兼容的 OpenMP 实现可能遵守也可能不遵守环境变量的设置。有效值分为 ACTIVE 和 PASSIVE。ACTIVE 指定等待的线程大部分应该是活动的，即，在等待时消耗处理器周期。PASSIVE 指定等待的线程大部分应该是被动的，即，而不是在等待时消耗处理器周期。ACTIVE 和 PASSIVE 行为的细节是由实现定义的。例子:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_WAIT_POLICY ACTIVE </span><br><span class="line">setenv OMP_WAIT_POLICY active </span><br><span class="line">setenv OMP_WAIT_POLICY PASSIVE </span><br><span class="line">setenv OMP_WAIT_POLICY passive</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_MAX_ACTIVE_LEVELS</code>控制嵌套的活动并行区域的最大数目。该环境变量的值必须是非负整数。如果 OMP_MAX_ACTIVE_LEVELS 的请求值大于实现所能支持的嵌套活动并行级别的最大数量，或者该值不是一个非负整数，则该程序的行为是由实现定义的。例子:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_MAX_ACTIVE_LEVELS 2</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_THREAD_LIMIT</code>设置用于整个 OpenMP 程序的 OpenMP 线程的数量。这个环境变量的值必须是正整数。如果 OMP_THREAD_LIMIT 的请求值大于实现所能支持的线程数，或者该值不是正整数，则程序的行为是由实现定义的。例子：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_THREAD_LIMIT 8</span><br></pre></td></tr></table></figure></p>
<h2 id="2-5-编译-OpenMP-程序"><a href="#2-5-编译-OpenMP-程序" class="headerlink" title="2.5 编译 OpenMP 程序"></a>2.5 编译 OpenMP 程序</h2><p>OpenMP 版本依赖的 GCC 版本</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>OpenMP 版本</th>
<th>GCC版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>OpenMP 5.0</td>
<td>&gt;= GCC 9.1</td>
</tr>
<tr>
<td>OpenMP 4.5</td>
<td>&gt;= GCC 6.1</td>
</tr>
<tr>
<td>OpenMP 4.0</td>
<td>&gt;= GCC 4.9.0</td>
</tr>
<tr>
<td>OpenMP 3.1</td>
<td>&gt;= GCC 4.7.0</td>
</tr>
<tr>
<td>OpenMP 3.0</td>
<td>&gt;= GCC 4.4.0</td>
</tr>
<tr>
<td>OpenMP 2.5</td>
<td>&gt;= GCC 4.2.0</td>
</tr>
</tbody>
</table>
</div>
<p>linux 下编译命令示例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ Test.cpp -o omptest -fopenmp</span><br></pre></td></tr></table></figure></p>
<h2 id="2-6-OpenMP-API-概述"><a href="#2-6-OpenMP-API-概述" class="headerlink" title="2.6 OpenMP API 概述"></a>2.6 OpenMP API 概述</h2><h3 id="三大构成"><a href="#三大构成" class="headerlink" title="三大构成"></a>三大构成</h3><p>OpenMP 3.1 API 由三个不同的组件组成：</p>
<ul>
<li>编译器指令</li>
<li>运行时库函数</li>
<li>环境变量</li>
</ul>
<p>后来的一些 API 包含了这三个相同的组件，但是增加了指令、运行时库函数和环境变量的数量。应用程序开发人员决定如何使用这些组件。在最简单的情况下，只需要其中的几个。实现对所有 API 组件的支持各不相同。例如，一个实现可能声明它支持嵌套并行，但是 API 清楚地表明它可能被限制在一个线程上——主线程。不完全符合开发人员的期望？</p>
<h3 id="编译器指令"><a href="#编译器指令" class="headerlink" title="编译器指令"></a>编译器指令</h3><p>编译器指令在源代码中以注释的形式出现，编译器会忽略它们，除非您另外告诉它们 — 通常通过指定适当的编译标志，如后面的编译部分所述。OpenMP 编译器指令用于各种目的：</p>
<ul>
<li>生成一个并行区域</li>
<li>在线程之间划分代码块</li>
<li>在线程之间分配循环迭代</li>
<li>序列化代码段</li>
<li>线程之间的工作同步</li>
</ul>
<p>编译器指令有以下语法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel directive-name [clause, ...] </span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel default(shared) private(beta, pi)</span></span><br></pre></td></tr></table></figure><br>后面将详细讨论编译器指令。</p>
<h3 id="运行时库函数-Run-time-Library-Routines"><a href="#运行时库函数-Run-time-Library-Routines" class="headerlink" title="运行时库函数 Run-time Library Routines:"></a>运行时库函数 Run-time Library Routines:</h3><p>OpenMP API 包括越来越多的运行时库函数。这些程序用于各种目的：</p>
<ul>
<li>设置和查询线程的数量</li>
<li>查询线程的唯一标识符(线程ID)、父线程的标识符、线程团队大小</li>
<li>设置和查询动态线程特性</li>
<li>查询是否在一个并行区域，以及在什么级别</li>
<li>设置和查询嵌套并行性</li>
<li>设置、初始化和终止锁以及嵌套锁</li>
<li>查询 wall clock time 和分辨率</li>
</ul>
<p>对于 C/C++，所有运行时库函数都是实际的子程序。对于Fortran来说，有些是函数，有些是子程序。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">omp_get_num_threads</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>注意，对于C/C++，通常需要包含<code>&lt;omp.h &gt;</code>头文件。</p>
<p>运行时库函数将在运行时库函数一节中作为概述进行简要讨论，更多细节将在附录A中讨论。</p>
<h2 id="2-7-OpenMP-指令"><a href="#2-7-OpenMP-指令" class="headerlink" title="2.7 OpenMP 指令"></a>2.7 OpenMP 指令</h2><h3 id="C-C-指令格式"><a href="#C-C-指令格式" class="headerlink" title="C/C++ 指令格式"></a>C/C++ 指令格式</h3><p>格式<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp	directive-name	[clause, ...]	newline</span><br></pre></td></tr></table></figure></p>
<p>所有 OpenMP C/C++ 指令都需要。    一个有效的 OpenMP 指令。必须出现在 pragma 之后和任何子句之前。    可选的。除非另有限制，子句可以按任何顺序重复。    必需的。在此指令所包含的结构化块之前。</p>
<p>一般规则</p>
<ul>
<li>区分大小写。</li>
<li>指令遵循 C/C++ 编译器指令标准的约定。</li>
<li>每个指令只能指定一个指令名。</li>
<li>每个指令最多应用于一个后续语句，该语句必须是一个结构化块。</li>
<li>长指令行可以通过在指令行的末尾使用反斜杠(“\”)来转义换行符，从而在后续的行中“继续”。</li>
</ul>
<h3 id="指令范围"><a href="#指令范围" class="headerlink" title="指令范围"></a>指令范围</h3><h4 id="静态-词法-范围"><a href="#静态-词法-范围" class="headerlink" title="静态(词法)范围"></a>静态(词法)范围</h4><ul>
<li>在指令后面的结构化块的开始和结束之间以文本形式封装的代码。</li>
<li>指令的静态范围不跨越多个程序或代码文件。</li>
</ul>
<h4 id="孤立的指令"><a href="#孤立的指令" class="headerlink" title="孤立的指令"></a>孤立的指令</h4><p>一个 OpenMP 指令，独立于另一个封闭指令，称为孤立型指令。它存在于另一个指令的静态(词法)范围之外。将跨越程序和可能的代码文件。</p>
<h4 id="动态范围"><a href="#动态范围" class="headerlink" title="动态范围"></a>动态范围</h4><p>指令的动态范围包括静态(词法)范围和孤立指令的范围。</p>
<h4 id="为什么这很重要？"><a href="#为什么这很重要？" class="headerlink" title="为什么这很重要？"></a>为什么这很重要？</h4><p>OpenMP 为指令如何相互关联(绑定)和嵌套指定了许多范围规则。如果忽略 OpenMP 绑定和嵌套规则，可能会导致非法或不正确的程序。有关详细信息，请参阅指令绑定和嵌套规则。</p>
<h3 id="并行区域结构"><a href="#并行区域结构" class="headerlink" title="并行区域结构"></a>并行区域结构</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>并行区域是由多个线程执行的代码块。这是基本的 OpenMP 并行结构。</p>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel [clause ...]  newline </span></span><br><span class="line">                     <span class="keyword">if</span> (scalar_expression) </span><br><span class="line">                     private (<span class="built_in">list</span>) </span><br><span class="line">                     shared (<span class="built_in">list</span>) </span><br><span class="line">                     <span class="keyword">default</span> (shared | none) </span><br><span class="line">                     firstprivate (<span class="built_in">list</span>) </span><br><span class="line">                     reduction (operator: <span class="built_in">list</span>) </span><br><span class="line">                     copyin (<span class="built_in">list</span>) </span><br><span class="line">                     num_threads (integer-expression)</span><br><span class="line"></span><br><span class="line">   structured_block</span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>当一个线程执行到一个并行指令时，它创建一个线程组并成为该线程组的主线程。主线程是该团队的成员，在该团队中线程号为0。</li>
<li>从这个并行区域开始，代码被复制，所有线程都将执行该代码。</li>
<li>在并行区域的末端有一个隐含的屏障。只有主线程在此之后继续执行。</li>
<li>如果任何线程在一个并行区域内终止，则团队中的所有线程都将终止，并且在此之前所做的工作都是未定义的。</li>
</ul>
<h4 id="有多少线程"><a href="#有多少线程" class="headerlink" title="有多少线程"></a>有多少线程</h4><p>并行区域内的线程数由以下因素决定，按优先级排序：</p>
<ul>
<li><code>IF</code>子句的计算</li>
<li><code>NUM_THREADS</code>子句的设置</li>
<li>使用<code>omp_set_num_threads()</code>库函数</li>
<li>设置<code>OMP_NUM_THREADS</code>环境变量</li>
<li>实现缺省值 — 通常是一个节点上的 cpu 数量，尽管它可以是动态的(参见下一小节)</li>
<li>线程的编号从0(主线程)到N-1。</li>
</ul>
<h4 id="动态线程-1"><a href="#动态线程-1" class="headerlink" title="动态线程"></a>动态线程</h4><p>使用<code>omp_get_dynamic()</code>库函数来确定是否启用了动态线程。如果支持的话，启用动态线程的两种方法是：</p>
<ul>
<li><code>omp_set_dynamic()</code>库函数</li>
<li>将<code>OMP_NESTED</code>环境变量设置为 TRUE</li>
</ul>
<p>如果不支持，则在另一个并行区域内嵌套一个并行区域，从而在默认情况下创建一个由单个线程组成的新团队。</p>
<h4 id="子句"><a href="#子句" class="headerlink" title="子句"></a>子句</h4><p>IF 子句：如果存在，它的值必须为非零，以便创建一个线程组。否则，该区域将由主线程串行执行。</p>
<h4 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h4><ul>
<li>并行区域必须是不跨越多个程序或代码文件的结构化块。</li>
<li>从一个并行区域转入或转出是非法的。</li>
<li>只允许一个 IF 子句。</li>
<li>只允许一个 NUM_THREADS 子句。</li>
<li>程序不能依赖于子句的顺序。</li>
</ul>
<h4 id="并行区域例子"><a href="#并行区域例子" class="headerlink" title="并行区域例子"></a>并行区域例子</h4><p>简单的“Hello World”程序。每个线程执行包含在并行区域中的所有代码。OpenMP 库函数用于获取线程标识符和线程总数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> nthreads, tid;</span><br><span class="line">    <span class="comment">/* Fork a team of threads with each thread having a private tid variable */</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(tid)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Obtain and print thread id */</span></span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World from thread = %d\n&quot;</span>, tid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Only master thread does this */</span></span><br><span class="line">        <span class="keyword">if</span> (tid == <span class="number">0</span>) &#123;</span><br><span class="line">            nthreads = omp_get_num_threads();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Number of threads = %d\n&quot;</span>, nthreads);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/* All threads join master thread and terminate */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="工作共享结构"><a href="#工作共享结构" class="headerlink" title="工作共享结构"></a>工作共享结构</h4><p>工作共享结构将封闭代码区域的执行划分给遇到它的团队成员。工作共享结构不会启动新线程。在进入工作共享结构时没有隐含的屏障，但是在工作共享结构的末尾有一个隐含的屏障。</p>
<p>工作共享结构的类型：</p>
<ul>
<li>DO / for - 整个团队的循环迭代。表示一种“数据并行性”。</li>
<li>SECTIONS - 把工作分成单独的、不连续的部分。每个部分由一个线程执行。可以用来实现一种“函数并行性”。</li>
<li>SINGLE - 序列化一段代码。</li>
</ul>
<p><img src="/img/20211202115649.png" alt="">    </p>
<h4 id="限制条件-1"><a href="#限制条件-1" class="headerlink" title="限制条件"></a>限制条件</h4><p>为了使指令能够并行执行，必须将工作共享结构动态地封装在一个并行区域中。团队的所有成员都必须遇到工作共享结构，或者根本不遇到。团队的所有成员必须以相同的顺序遇到连续的工作共享结构。</p>
<h4 id="DO-for-指令"><a href="#DO-for-指令" class="headerlink" title="DO / for 指令"></a>DO / for 指令</h4><p>DO / for 指令指定紧随其后的循环迭代必须由团队并行执行。这假定已经启动了并行区域，否则它将在单个处理器上串行执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for [clause ...]  newline </span></span><br><span class="line">                schedule (type [,chunk]) </span><br><span class="line">                ordered</span><br><span class="line">                <span class="title function_">private</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line">                <span class="title function_">firstprivate</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line">                <span class="title function_">lastprivate</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line">                <span class="title function_">shared</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line">                <span class="title function_">reduction</span> <span class="params">(operator: <span class="built_in">list</span>)</span> </span><br><span class="line">                <span class="title function_">collapse</span> <span class="params">(n)</span> </span><br><span class="line">                nowait </span><br><span class="line"></span><br><span class="line">   for_loop</span><br></pre></td></tr></table></figure>
<ul>
<li><code>schedule</code>：描述循环迭代如何在团队中的线程之间进行分配。默认的调度是依赖于实现的。有关如何使一种调度比其他调度更优的讨论，请参见<a href="http://openmp.org/forum/viewtopic.php?f=3&amp;t=83">http://openmp.org/forum/viewtopic.php?f=3&amp;t=83</a> 。<ul>
<li>静态(STATIC) - 循环迭代被分成小块，然后静态地分配给线程。如果没有指定 chunk，则迭代是均匀地(如果可能)在线程之间连续地划分。</li>
<li>动态(DYNAMIC) - 循环迭代分成小块，并在线程之间动态调度；当一个线程完成一个块时，它被动态地分配给另一个块。默认块大小为1。</li>
<li>引导(GUIDED) - 当线程请求迭代时，迭代被动态地分配给块中的线程，直到没有剩余的块需要分配为止。与 DYNAMIC 类似，只是每次将一个工作包分配给一个线程时，块的大小就会减小。<ul>
<li>初始块的大小与 number_of_iteration / number_of_threads 成比例</li>
<li>后续块与number_of_iterations_remaining / number_of_threads 成比例</li>
<li>chunk 参数定义最小块大小。默认块大小为1。</li>
</ul>
</li>
<li>运行时(RUNTIME) - 环境变量 OMP_SCHEDULE 将调度决策延迟到运行时。为这个子句指定块大小是非法的。</li>
<li>自动(AUTO) - 调度决策被委托给编译器或运行时系统。</li>
</ul>
</li>
<li><code>nowait</code>： 如果指定，那么线程在并行循环结束时不会同步。</li>
<li><code>ordered</code>：指定循环的迭代必须像在串行程序中一样执行。</li>
<li><code>collapse</code>：指定在一个嵌套循环中有多少个循环应该折叠成一个大的迭代空间，并根据 schedule 子句进行划分。折叠迭代空间中的迭代的顺序是确定的，就好像它们是按顺序执行的一样。可能会提高性能。</li>
<li>其他子句稍后将在数据范围属性子句一节中详细描述。</li>
</ul>
<h5 id="限制条件-2"><a href="#限制条件-2" class="headerlink" title="限制条件"></a>限制条件</h5><ul>
<li>DO 循环不能是 DO WHILE 循环，也不能是没有循环控制的循环。此外，循环迭代变量必须是整数，并且对于所有线程，循环控制参数必须相同。</li>
<li>程序的正确性不能依赖于哪个线程执行特定的迭代。</li>
<li>在与 DO / for 指令关联的循环中跳转（转到）是非法的。</li>
<li>块大小必须指定为循环不变的整数表达式，因为在不同线程求值期间不存在同步。</li>
<li>ORDERED、COLLAPSE、SCHEDULE 子句可以出现一次。</li>
<li>有关其他限制，请参阅 OpenMP 规范文档。</li>
</ul>
<h5 id="DO-for-指令示例"><a href="#DO-for-指令示例" class="headerlink" title="DO / for 指令示例"></a>DO / for 指令示例</h5><p>简单的 vector 相加程序，数组 A、B、C 和变量 N 将由所有线程共享。变量 i 对每个线程都是私有的；每个线程都有自己唯一的副本。循环迭代将在 CHUNK 大小的块中动态分布。线程在完成各自的工作后将不会同步 (NOWAIT)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, chunk;</span><br><span class="line">    <span class="type">float</span> a[N], b[N], c[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some initializations */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        a[i] = b[i] = i * <span class="number">1.0</span>;</span><br><span class="line">    chunk = CHUNKSIZE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(a,b,c,chunk) private(i)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for schedule(dynamic,chunk) nowait</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            c[i] = a[i] + b[i];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">/* end of parallel region */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="sections-指令"><a href="#sections-指令" class="headerlink" title="sections 指令"></a>sections 指令</h4><h5 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h5><p>sections 指令是一个非迭代的工作共享结构。它指定所包含的代码段将被分配给团队中的各个线程。</p>
<p>独立的 section 指令嵌套在 sections 指令中。每个部分由团队中的一个线程执行一次。不同的部分可以由不同的线程执行。如果一个线程执行多个部分的速度足够快，并且实现允许这样做，那么它就可以执行多个部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp sections [clause ...]  newline </span></span><br><span class="line">                     private (<span class="built_in">list</span>) </span><br><span class="line">                     firstprivate (<span class="built_in">list</span>) </span><br><span class="line">                     lastprivate (<span class="built_in">list</span>) </span><br><span class="line">                     reduction (operator: <span class="built_in">list</span>) </span><br><span class="line">                     nowait</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> omp section   newline </span></span><br><span class="line">     structured_block</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> omp section   newline </span></span><br><span class="line">     structured_block</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="子句-1"><a href="#子句-1" class="headerlink" title="子句"></a>子句</h5><p>除非使用了 NOWAIT/nowait 子句，否则在 sections 指令的末尾有一个隐含的屏障（译者注：an implied barrier 意思应该是线程会相互等待）。稍后将在数据范围属性子句一节中详细描述子句。</p>
<h5 id="限制条件-3"><a href="#限制条件-3" class="headerlink" title="限制条件"></a>限制条件</h5><p>跳转（转到）或跳出 section 代码块是非法的。section 指令必须出现在一个封闭的 sections 指令的词法范围内(没有独立部分)。</p>
<h5 id="sections-指令示例"><a href="#sections-指令示例" class="headerlink" title="sections 指令示例"></a>sections 指令示例</h5><p>下面一个简单的程序演示不同的工作块将由不同的线程完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> a[N], b[N], c[N], d[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some initializations */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        a[i] = i * <span class="number">1.5</span>;</span><br><span class="line">        b[i] = i + <span class="number">22.35</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(a,b,c,d) private(i)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp sections nowait</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">                c[i] = a[i] + b[i];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">                d[i] = a[i] * b[i];</span><br><span class="line">        &#125; <span class="comment">/* end of sections */</span></span><br><span class="line">    &#125; <span class="comment">/* end of parallel region */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="single-指令"><a href="#single-指令" class="headerlink" title="single 指令"></a>single 指令</h4><h5 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h5><p>single 指令指定所包含的代码仅由团队中的一个线程执行。在处理非线程安全的代码段(如 I/O )时可能很有用</p>
<h5 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single [clause ...]  newline </span></span><br><span class="line">                   private (<span class="built_in">list</span>) </span><br><span class="line">                   firstprivate (<span class="built_in">list</span>) </span><br><span class="line">                   nowait</span><br><span class="line"></span><br><span class="line">     structured_block</span><br></pre></td></tr></table></figure>
<h5 id="子句-2"><a href="#子句-2" class="headerlink" title="子句"></a>子句</h5><p>除非指定了 nowait 子句，否则团队中不执行 single 指令的线程将在代码块的末尾等待。稍后将在数据范围属性子句一节中详细描述子句。</p>
<h5 id="限制条件-4"><a href="#限制条件-4" class="headerlink" title="限制条件"></a>限制条件</h5><p>进入或跳出一个 single 代码块是非法的。</p>
<h3 id="合并并行工作共享结构"><a href="#合并并行工作共享结构" class="headerlink" title="合并并行工作共享结构"></a>合并并行工作共享结构</h3><p>OpenMP 提供了三个简单的指令：</p>
<ul>
<li>parallel for</li>
<li>parallel sections</li>
<li>PARALLEL WORKSHARE (fortran only)</li>
</ul>
<p>在大多数情况下，这些指令的行为与单独的并行指令完全相同，并行指令后面紧跟着一个单独的工作共享指令。大多数适用于这两个指令的规则、条款和限制都是有效的。有关详细信息，请参阅 OpenMP API。</p>
<p>下面显示了一个使用 parallel for 组合指令的示例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N       1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE   100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, chunk;</span><br><span class="line">    <span class="type">float</span> a[N], b[N], c[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some initializations */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        a[i] = b[i] = i * <span class="number">1.0</span>;</span><br><span class="line">    chunk = CHUNKSIZE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for shared(a,b,c,chunk) private(i) schedule(static,chunk)</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        c[i] = a[i] + b[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="任务结构"><a href="#任务结构" class="headerlink" title="任务结构"></a>任务结构</h3><h4 id="目的-3"><a href="#目的-3" class="headerlink" title="目的"></a>目的</h4><p>任务结构定义了一个显式任务，该任务可以由遇到的线程执行，也可以由团队中的任何其他线程延迟执行。任务的数据环境由数据共享属性子句确定。任务执行取决于任务调度 — 详细信息请参阅 OpenMP 3.1 规范文档</p>
<h4 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp task [clause ...]  newline </span></span><br><span class="line">                 <span class="keyword">if</span> (scalar expression) </span><br><span class="line">                 final (scalar expression) </span><br><span class="line">                 untied</span><br><span class="line">                 <span class="title function_">default</span> <span class="params">(shared | none)</span></span><br><span class="line">                 mergeable</span><br><span class="line">                 <span class="title function_">private</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line">                 <span class="title function_">firstprivate</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line">                 <span class="title function_">shared</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line"></span><br><span class="line">    structured_block</span><br></pre></td></tr></table></figure>
<h3 id="同步结构"><a href="#同步结构" class="headerlink" title="同步结构"></a>同步结构</h3><p>考虑一个简单的例子，两个线程都试图同时更新变量x：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">THREAD1	</span><br><span class="line"><span class="title function_">update</span><span class="params">(x)</span></span><br><span class="line">&#123;</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">update(x)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">THREAD2</span><br><span class="line"><span class="title function_">update</span><span class="params">(x)</span></span><br><span class="line">&#123;</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">update(x)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>一种可能的执行顺序：</p>
<ul>
<li>线程1初始化 x 为0并调用</li>
<li>线程1将 x 加1，x 现在等于1</li>
<li>线程2初始化 x 为0并调用 update(x)，x现在等于0</li>
<li>线程1输出 x，它等于0而不是1</li>
<li>线程2将 x 加1，x 现在等于1</li>
<li>线程2打印 x 为1</li>
</ul>
<p>为了避免这种情况，必须在两个线程之间同步 x 的更新，以确保产生正确的结果。OpenMP 提供了各种同步结构，这些构造控制每个线程相对于其他团队线程的执行方式。</p>
<h4 id="master-指令"><a href="#master-指令" class="headerlink" title="master 指令"></a>master 指令</h4><h5 id="目的-4"><a href="#目的-4" class="headerlink" title="目的"></a>目的</h5><p>master 指令指定了一个区域，该区域只由团队的主线程执行。团队中的所有其他线程都将跳过这部分代码。这个指令没有隐含的障碍( implied barrier )。</p>
<h5 id="格式-3"><a href="#格式-3" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp master  newline</span></span><br><span class="line">    structured_block</span><br></pre></td></tr></table></figure>
<h5 id="限制条件-5"><a href="#限制条件-5" class="headerlink" title="限制条件"></a>限制条件</h5><p>进入或跳出一个 master 代码块是非法的。</p>
<h4 id="critical-指令"><a href="#critical-指令" class="headerlink" title="critical 指令"></a>critical 指令</h4><h5 id="目的-5"><a href="#目的-5" class="headerlink" title="目的"></a>目的</h5><p>critical 指令指定了一个只能由一个线程执行的代码区域。</p>
<h5 id="格式-4"><a href="#格式-4" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical [ name ]  newline</span></span><br><span class="line">    structured_block</span><br></pre></td></tr></table></figure>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>如果一个线程当前在一个 critical 区域内执行，而另一个线程到达该 critical 区域并试图执行它，那么它将阻塞，直到第一个线程退出该 critical 区域。</li>
<li>可选的名称使多个不同的临界区域存在：<ul>
<li>名称充当全局标识符。具有相同名称的不同临界区被视为相同的区域。</li>
<li>所有未命名的临界段均视为同一段。</li>
</ul>
</li>
</ul>
<h5 id="限制条件-6"><a href="#限制条件-6" class="headerlink" title="限制条件"></a>限制条件</h5><p>进入或跳出一个 critical 代码块是非法的。</p>
<p>Fortran only: The names of critical constructs are global entities of the program. If a name conflicts with any other entity, the behavior of the program is unspecified.</p>
<h5 id="critical-结构示例"><a href="#critical-结构示例" class="headerlink" title="critical 结构示例"></a>critical 结构示例</h5><p>团队中的所有线程都将尝试并行执行，但是由于 x 的增加由 critical 结构包围，在任何时候只有一个线程能够读/增量/写 x。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(x)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">        x = x + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="comment">/* end of parallel region */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="barrier-指令"><a href="#barrier-指令" class="headerlink" title="barrier 指令"></a>barrier 指令</h4><h5 id="目的-6"><a href="#目的-6" class="headerlink" title="目的"></a>目的</h5><p>barrier 指令同步团队中的所有线程。当到达 barrier 指令时，一个线程将在该点等待，直到所有其他线程都到达了 barrier 指令。然后，所有线程继续并行执行 barrier 之后的代码。</p>
<h5 id="格式-5"><a href="#格式-5" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp barrier  newline</span></span><br></pre></td></tr></table></figure>
<p>f</p>
<h5 id="限制条件-7"><a href="#限制条件-7" class="headerlink" title="限制条件"></a>限制条件</h5><p>团队中的所有线程(或没有线程)都必须执行 barrier 区域。对于团队中的每个线程，遇到的 work-sharing 区域和 barrier 区域的顺序必须是相同的。</p>
<h4 id="taskwait-指令"><a href="#taskwait-指令" class="headerlink" title="taskwait 指令"></a>taskwait 指令</h4><h5 id="目的-7"><a href="#目的-7" class="headerlink" title="目的"></a>目的</h5><p>taskwait 结构指定自当前任务开始以来生成的子任务完成时的等待时间。</p>
<h5 id="格式-6"><a href="#格式-6" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp taskwait  newline</span></span><br></pre></td></tr></table></figure>
<h5 id="限制条件-8"><a href="#限制条件-8" class="headerlink" title="限制条件"></a>限制条件</h5><p>因为 taskwait 结构是一个独立的指令，所以它在程序中的位置有一些限制。taskwait 指令只能放置在允许使用基本语言语句的地方。taskwait 指令不能代替 if、while、do、switch 或 label 后面的语句。有关详细信息，请参阅 OpenMP 3.1 规范文档。</p>
<h4 id="atomic-指令"><a href="#atomic-指令" class="headerlink" title="atomic 指令"></a>atomic 指令</h4><h5 id="目的-8"><a href="#目的-8" class="headerlink" title="目的"></a>目的</h5><p>atomic 结构确保以原子方式访问特定的存储位置，而不是将其暴露给多个线程同时读写，这些线程可能会导致不确定的值。本质上，这个指令提供了一个最小临界( mini-CRITICAL )区域。</p>
<h5 id="格式-7"><a href="#格式-7" class="headerlink" title="格式"></a>格式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp atomic  [ read | write | update | capture ] newline</span><br><span class="line">   statement_expression</span><br></pre></td></tr></table></figure>
<h5 id="限制条件-9"><a href="#限制条件-9" class="headerlink" title="限制条件"></a>限制条件</h5><p>该指令仅适用于紧接其后的单个语句。原子语句必须遵循特定的语法。查看最新的OpenMP规范。</p>
<h4 id="flush-指令"><a href="#flush-指令" class="headerlink" title="flush 指令"></a>flush 指令</h4><h5 id="目的-9"><a href="#目的-9" class="headerlink" title="目的"></a>目的</h5><p>flush 指令标识了一个同步点，在这个点上，内存数据必须一致。这时，线程可见的变量被写回内存。请参阅最新的 OpenMP 规范以获取详细信息。</p>
<h5 id="格式-8"><a href="#格式-8" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp flush (list)  newline</span></span><br></pre></td></tr></table></figure>
<h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><p>可选 list 参数包含一个将被刷新的已命名变量列表，以避免刷新所有变量。对于列表中的指针，请注意指针本身被刷新，而不是它指向的对象。实现必须确保线程可见变量的任何修改在此之后对所有线程都是可见的，例如编译器必须将值从寄存器恢复到内存，硬件可能需要刷新写缓冲区，等等。对于下面的指令，将使用 flush 指令。如果存在 nowait 子句，则该指令无效。</p>
<ul>
<li>barrier</li>
<li>parallel - 进入和退出</li>
<li>critical - 进入和退出</li>
<li>ordered - 进入和退出</li>
<li>for - 退出</li>
<li>sections - 退出</li>
<li>single - 退出</li>
</ul>
<h4 id="ordered-指令"><a href="#ordered-指令" class="headerlink" title="ordered 指令"></a>ordered 指令</h4><h5 id="目的-10"><a href="#目的-10" class="headerlink" title="目的"></a>目的</h5><p>ordered 指令指定封闭的循环迭代将以串行处理器上执行顺序执行。如果之前的迭代还没有完成，线程在执行它们的迭代块之前需要等待。在带有 ordered 子句的 for 循环中使用。ordered 指令提供了一种“微调”的方法，其中在循环中应用了排序。否则，它不是必需的。</p>
<h5 id="格式-9"><a href="#格式-9" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for ordered [clauses...]</span></span><br><span class="line">   (loop region)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp ordered  newline</span></span><br><span class="line">   structured_block</span><br><span class="line">   (endo of loop region)</span><br></pre></td></tr></table></figure>
<h5 id="限制条件-10"><a href="#限制条件-10" class="headerlink" title="限制条件"></a>限制条件</h5><ul>
<li>一个 ordered 指令只能在以下指令的动态范围内出现：<ul>
<li>for 或者 parallel for (C/C++)。</li>
</ul>
</li>
<li>在一个有序的区段中，任何时候都只允许一个线程。</li>
<li>进入或跳出一个 ordered 代码块是非法的。</li>
<li>一个循环的迭代不能多次执行同一个有序指令，也不能一次执行多个有序指令。</li>
<li>包含有序指令的循环必须是带有 ordered 子句的循环。</li>
</ul>
<h3 id="threadprivate-指令"><a href="#threadprivate-指令" class="headerlink" title="threadprivate 指令"></a>threadprivate 指令</h3><h4 id="目的-11"><a href="#目的-11" class="headerlink" title="目的"></a>目的</h4><p>threadprivate 指令指定复制变量，每个线程都有自己的副本。</p>
<p>可用于通过执行多个并行区域将全局文件作用域变量(C/C++/Fortran)或公共块(Fortran)局部化并持久化到一个线程。</p>
<h4 id="格式-10"><a href="#格式-10" class="headerlink" title="格式"></a>格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate (list)</span></span><br></pre></td></tr></table></figure>
<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>指令必须出现在列出的变量/公共块的声明之后。每个线程都有自己的变量/公共块的副本，所以一个线程写的数据对其他线程是不可见的。</li>
<li>在第一次进入一个并行区域时，应该假设 threadprivate 变量和公共块中的数据是未定义的，除非在并行指令中指定了 copyin 子句。</li>
<li>threadprivate 变量不同于 private 变量(稍后讨论)，因为它们能够在代码的不同并行区域之间持久存在。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a, b, i, tid;</span><br><span class="line"><span class="type">float</span> x;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(a, x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* 显式关闭动态线程 Explicitly turn off dynamic threads */</span></span><br><span class="line">    omp_set_dynamic(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1st Parallel Region:\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(b,tid)</span></span><br><span class="line">    &#123;</span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        a = tid;</span><br><span class="line">        b = tid;</span><br><span class="line">        x = <span class="number">1.1</span> * tid + <span class="number">1.0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d:   a,b,x= %d %d %f\n&quot;</span>, tid, a, b, x);</span><br><span class="line">    &#125; <span class="comment">/* end of parallel region */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Master thread doing serial work here\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;************************************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2nd Parallel Region:\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(tid)</span></span><br><span class="line">    &#123;</span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d:   a,b,x= %d %d %f\n&quot;</span>, tid, a, b, x);</span><br><span class="line">    &#125; <span class="comment">/* end of parallel region */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1st Parallel Region:</span><br><span class="line">Thread 4:   a,b,x= 4 4 5.400000</span><br><span class="line">Thread 7:   a,b,x= 7 7 8.700000</span><br><span class="line">Thread 2:   a,b,x= 2 2 3.200000</span><br><span class="line">Thread 3:   a,b,x= 3 3 4.300000</span><br><span class="line">Thread 6:   a,b,x= 6 6 7.600000</span><br><span class="line">Thread 1:   a,b,x= 1 1 2.100000</span><br><span class="line">Thread 5:   a,b,x= 5 5 6.500000</span><br><span class="line">Thread 0:   a,b,x= 0 0 1.000000</span><br><span class="line">************************************</span><br><span class="line">Master thread doing serial work here</span><br><span class="line">************************************</span><br><span class="line">2nd Parallel Region:</span><br><span class="line">Thread 1:   a,b,x= 1 0 2.100000</span><br><span class="line">Thread 6:   a,b,x= 6 0 7.600000</span><br><span class="line">Thread 4:   a,b,x= 4 0 5.400000</span><br><span class="line">Thread 5:   a,b,x= 5 0 6.500000</span><br><span class="line">Thread 2:   a,b,x= 2 0 3.200000</span><br><span class="line">Thread 7:   a,b,x= 7 0 8.700000</span><br><span class="line">Thread 0:   a,b,x= 0 0 1.000000</span><br><span class="line">Thread 3:   a,b,x= 3 0 4.300000</span><br></pre></td></tr></table></figure></p>
<h4 id="限制条件-11"><a href="#限制条件-11" class="headerlink" title="限制条件"></a>限制条件</h4><p>只有在动态线程机制“关闭”并且不同并行区域中的线程数量保持不变的情况下，threadprivate 对象中的数据才能保证持久。动态线程的默认设置是未定义的。</p>
<h3 id="数据范围属性子句"><a href="#数据范围属性子句" class="headerlink" title="数据范围属性子句"></a>数据范围属性子句</h3><p>也称为数据共享属性子句。</p>
<p>OpenMP 编程的一个重要考虑是理解和使用数据作用域。因为 OpenMP 是基于共享内存编程模型的，所以大多数变量在默认情况下是共享的。</p>
<p>全局变量包括：</p>
<ul>
<li>Fortran: COMMON blocks, SAVE variables, MODULE variables</li>
<li>文件作用域变量，static</li>
</ul>
<p>私有变量包括：</p>
<ul>
<li>循环索引变量</li>
<li>从并行区域调用的子程序中的堆栈变量</li>
<li>Fortran: Automatic variables within a statement block</li>
</ul>
<p>OpenMP 数据范围属性子句用于显式定义变量的范围。它们包括：</p>
<ul>
<li>private</li>
<li>firstprivate</li>
<li>lastprivate</li>
<li>shared</li>
<li>default</li>
<li>reduction</li>
<li>copyin</li>
</ul>
<p>数据范围属性子句与几个指令（parallel、DO/for 和 sections）一起使用，以控制所包含变量的范围。这些结构提供了在并行结构执行期间控制数据环境的能力。它们定义了如何将程序的串行部分中的哪些数据变量传输到程序的并行区域(以及向后传输)。它们定义哪些变量将对并行区域中的所有线程可见，哪些变量以私有形式分配给所有线程。数据范围属性子句仅在其词法/静态范围内有效。</p>
<h4 id="private-子句"><a href="#private-子句" class="headerlink" title="private 子句"></a>private 子句</h4><h5 id="目的-12"><a href="#目的-12" class="headerlink" title="目的"></a>目的</h5><p>private 子句将在其列表中的变量声明为每个线程的私有变量。</p>
<h5 id="格式-11"><a href="#格式-11" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h5><p>私有变量的行为如下：</p>
<ul>
<li>为团队中的每个线程声明一个相同类型的新对象</li>
<li>所有对原始对象的引用都被替换为对新对象的引用</li>
<li>应该假定每个线程都没有初始化</li>
</ul>
<h4 id="shared-子句"><a href="#shared-子句" class="headerlink" title="shared 子句"></a>shared 子句</h4><h5 id="目的-13"><a href="#目的-13" class="headerlink" title="目的"></a>目的</h5><p>shared 子句声明其列表中的变量在团队中的所有线程之间共享。</p>
<h5 id="格式-12"><a href="#格式-12" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h5><p>共享变量只存在于一个内存位置，所有线程都可以读写该地址，程序员有责任确保多个线程正确地访问共享变量(例如通过临界区)</p>
<h4 id="default-子句"><a href="#default-子句" class="headerlink" title="default 子句"></a>default 子句</h4><h5 id="目的-14"><a href="#目的-14" class="headerlink" title="目的"></a>目的</h5><p>default 子句允许用户为任何并行区域的词法范围内的所有变量指定默认作用域。</p>
<h5 id="格式-13"><a href="#格式-13" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (shared | none)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h5><p>使用 private、shared、firstprivate、lastprivate 和 reduction 子句可以避免使用特定变量。C/C++ OpenMP 规范不包括将 private 或 firstprivate 作为可能的默认值。但是，实际的实现可能会提供这个选项。使用 none 作为默认值要求程序员显式地限定所有变量的作用域。</p>
<h4 id="firstprivate-子句"><a href="#firstprivate-子句" class="headerlink" title="firstprivate 子句"></a>firstprivate 子句</h4><h5 id="目的-15"><a href="#目的-15" class="headerlink" title="目的"></a>目的</h5><p>firstprivate 子句将 private 子句的行为与它的列表中变量的自动初始化相结合。</p>
<h5 id="格式-14"><a href="#格式-14" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firstprivate (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h5><p>在进入并行或工作共享结构之前，将根据其原始对象的值初始化列出的变量。</p>
<h4 id="lastprivate-子句"><a href="#lastprivate-子句" class="headerlink" title="lastprivate 子句"></a>lastprivate 子句</h4><h5 id="目的-16"><a href="#目的-16" class="headerlink" title="目的"></a>目的</h5><p>lastprivate 子句将 private 子句的行为与从最后一个循环迭代或部分到原始变量对象的复制相结合。</p>
<h5 id="格式-15"><a href="#格式-15" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lastprivate (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h5><p>复制回原始变量对象的值是从封闭结构的最后一次(顺序)迭代或部分获得的。例如，为 DO 部分执行最后一次迭代的团队成员，或者执行 sections 上下文的最后一部分的团队成员，使用其自身的值执行副本。</p>
<h4 id="copyin-子句"><a href="#copyin-子句" class="headerlink" title="copyin 子句"></a>copyin 子句</h4><h5 id="目的-17"><a href="#目的-17" class="headerlink" title="目的"></a>目的</h5><p>copyin 子句提供了为团队中的所有线程分配相同值的 threadprivate 变量的方法。</p>
<h5 id="格式-16"><a href="#格式-16" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copyin  (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h5><p>列表包含要复制的变量的名称。在Fortran中，列表既可以包含公共块的名称，也可以包含已命名变量的名称。主线程变量用作复制源。在进入并行结构时，将使用其值初始化团队线程。</p>
<h4 id="copyprivate-子句"><a href="#copyprivate-子句" class="headerlink" title="copyprivate 子句"></a>copyprivate 子句</h4><h5 id="目的-18"><a href="#目的-18" class="headerlink" title="目的"></a>目的</h5><p>copyprivate 子句可用于将单个线程获得的值直接传播到其他线程中私有变量的所有实例。与 single 指令相关联</p>
<h5 id="格式-17"><a href="#格式-17" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copyprivate  (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h4 id="reduction-子句"><a href="#reduction-子句" class="headerlink" title="reduction 子句"></a>reduction 子句</h4><h5 id="目的-19"><a href="#目的-19" class="headerlink" title="目的"></a>目的</h5><p>reduction 子句对出现在其列表中的变量执行约简操作。为每个线程创建并初始化每个列表变量的私有副本。在约简结束时，将约简变量应用于共享变量的所有私有副本，并将最终结果写入全局共享变量。</p>
<h5 id="格式-18"><a href="#格式-18" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduction (operator: <span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h5 id="Example-REDUCTION-Vector-Dot-Product"><a href="#Example-REDUCTION-Vector-Dot-Product" class="headerlink" title="Example: REDUCTION - Vector Dot Product:"></a>Example: REDUCTION - Vector Dot Product:</h5><p>并行循环的迭代将以相同大小的块分配给团队中的每个线程(调度静态)，在并行循环构造的末尾，所有线程将添加它们的“result”值来更新主线程的全局副本。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, n, chunk;</span><br><span class="line">    <span class="type">float</span> a[<span class="number">100</span>], b[<span class="number">100</span>], result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some initializations */</span></span><br><span class="line">    n = <span class="number">100</span>;</span><br><span class="line">    chunk = <span class="number">10</span>;</span><br><span class="line">    result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = i * <span class="number">1.0</span>;</span><br><span class="line">        b[i] = i * <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for default(shared) private(i) \</span></span><br><span class="line"><span class="meta">    schedule(static,chunk) reduction(+:result)</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        result = result + (a[i] * b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final result= %f\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="限制条件-12"><a href="#限制条件-12" class="headerlink" title="限制条件"></a>限制条件</h5><ul>
<li>列表项的类型必须对约简操作符有效。</li>
<li>列表项/变量不能声明为共享或私有。</li>
<li>约简操作可能与实数无关。</li>
<li>有关其他限制，请参见 OpenMP 标准 API。</li>
</ul>
<h3 id="指令绑定和嵌套规则"><a href="#指令绑定和嵌套规则" class="headerlink" title="指令绑定和嵌套规则"></a>指令绑定和嵌套规则</h3><p>本节主要是作为管理 OpenMP 指令和绑定的规则的快速参考。用户应该参考他们的实现文档和 OpenMP 标准以了解其他规则和限制。除非另有说明，规则适用于 Fortran 和 C/C++ OpenMP 实现。</p>
<p>注意：Fortran API 还定义了许多数据环境规则。这些没有在这里复制。</p>
<h4 id="指令绑定"><a href="#指令绑定" class="headerlink" title="指令绑定"></a>指令绑定</h4><ul>
<li>DO/for、sections、single、master 和 barrier 指令绑定到动态封闭的 parallel (如果存在的话)。如果当前没有并行区域被执行，指令就没有效果。</li>
<li>有序指令绑定到动态封闭的 DO/for 。</li>
<li>atomic 指令强制对所有线程中的 atomic 指令进行独占访问，而不仅仅是当前的团队。</li>
<li>critical 指令强制对所有线程中的 critical 指令进行独占访问，而不仅仅是当前的团队。</li>
<li>指令永远不能绑定到最接近的封闭并行之外的任何指令。</li>
</ul>
<h4 id="指令嵌套"><a href="#指令嵌套" class="headerlink" title="指令嵌套"></a>指令嵌套</h4><ul>
<li>工作共享区域不能紧密嵌套在工作共享、显式任务、关键区域、有序区域、原子区域或主区域内。</li>
<li>屏障区域不能紧密嵌套在工作共享、显式任务、关键区域、有序区域、原子区域或主区域中。</li>
<li>主区域不能紧密嵌套在工作共享、原子或显式任务区域内。</li>
<li>有序区域可能不会紧密嵌套在临界、原子或显式任务区域内。</li>
<li>一个有序区域必须与一个有序子句紧密嵌套在一个循环区域(或并行循环区域)内。</li>
<li>临界区不能嵌套(紧密嵌套或以其他方式嵌套)在具有相同名称的临界区内。注意，此限制不足以防止死锁。</li>
<li>并行、刷新、临界、原子、taskyield 和显式任务区域可能不会紧密嵌套在原子区域内。</li>
</ul>
<h2 id="2-8-线程堆栈大小和线程绑定"><a href="#2-8-线程堆栈大小和线程绑定" class="headerlink" title="2.8 线程堆栈大小和线程绑定"></a>2.8 线程堆栈大小和线程绑定</h2><h3 id="线程堆栈大小"><a href="#线程堆栈大小" class="headerlink" title="线程堆栈大小"></a>线程堆栈大小</h3><p>OpenMP 标准没有指定一个线程应该有多少堆栈空间。因此，默认线程堆栈大小的实现将有所不同。<br>默认的线程堆栈大小很容易耗尽。它也可以在编译器之间不可移植。以过去版本的LC编译器为例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Compiler</th>
<th>Approx. Stack Limit</th>
<th>Approx. Array Size (doubles)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux icc, ifort</td>
<td>4 MB</td>
<td>700 x 700</td>
</tr>
<tr>
<td>Linux pgcc, pgf90</td>
<td>8 MB</td>
<td>1000 x 1000</td>
</tr>
<tr>
<td>Linux gcc, gfortran</td>
<td>2 MB</td>
<td>500 x 500</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>超出其堆栈分配的线程可能存在或不存在段错误。当数据被破坏时，应用程序可以继续运行。</li>
<li>静态链接代码可能受到进一步的堆栈限制。</li>
<li>用户的登录shell还可以限制堆栈大小</li>
</ul>
<p>如果您的 OpenMP 环境支持 OpenMP 3.0  OMP_STACKSIZE 环境变量(在前一节中介绍过)，那么您可以使用它在程序执行之前设置线程堆栈大小。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_STACKSIZE 2000500B</span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot;3000 k &quot;</span></span><br><span class="line">setenv OMP_STACKSIZE 10M</span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot; 10 M &quot;</span></span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot;20 m &quot;</span></span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot; 1G&quot;</span></span><br><span class="line">setenv OMP_STACKSIZE 20000</span><br></pre></td></tr></table></figure></p>
<p>否则，在LC上，您应该能够对Linux集群使用下面的方法。该示例显示将线程堆栈大小设置为12 MB，作为预防措施，将shell堆栈大小设置为无限制。</p>
<p>csh/tcsh:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv KMP_STACKSIZE 12000000</span><br><span class="line"><span class="built_in">limit</span> stacksize unlimited</span><br></pre></td></tr></table></figure></p>
<p>ksh/sh/bash:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KMP_STACKSIZE=12000000</span><br><span class="line"><span class="built_in">ulimit</span> -s unlimited</span><br></pre></td></tr></table></figure></p>
<h3 id="线程绑定"><a href="#线程绑定" class="headerlink" title="线程绑定"></a>线程绑定</h3><ul>
<li>在某些情况下，如果一个程序的线程被绑定到处理器/核心，那么它的性能会更好。</li>
<li>“绑定”一个线程到一个处理器意味着操作系统将调度一个线程始终在同一个处理器上运行。否则，可以将线程调度为在任何处理器上执行，并在每个时间片的处理器之间来回“弹回”。也称为“线程关联性”或“处理器关联性”。</li>
<li>将线程绑定到处理器可以更好地利用缓存，从而减少昂贵的内存访问。这是将线程绑定到处理器的主要动机。</li>
</ul>
<p>根据平台、操作系统、编译器和 OpenMP 实现的不同，可以通过几种不同的方式将线程绑定到处理器。OpenMP 3.1 版 API 提供了一个环境变量来“打开”或“关闭”处理器绑定。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_PROC_BIND  TRUE</span><br><span class="line">setenv OMP_PROC_BIND  FALSE</span><br></pre></td></tr></table></figure></p>
<p>在更高的级别上，进程也可以绑定到处理器。</p>
<h1 id="3-OpenMP详细代码示例"><a href="#3-OpenMP详细代码示例" class="headerlink" title="3. OpenMP详细代码示例"></a>3. OpenMP详细代码示例</h1><h2 id="3-1-hello-openmp-cpp"><a href="#3-1-hello-openmp-cpp" class="headerlink" title="3.1 hello_openmp.cpp"></a>3.1 hello_openmp.cpp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 尝试着在编译选项里使用和不使用-openmp 这个编译选项分别编译并执行代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _OPENMP  <span class="comment">// 如果定义了这个宏</span></span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, OpenMP!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OpenMP is not enabled.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-header-and-env-cpp"><a href="#3-2-header-and-env-cpp" class="headerlink" title="3.2 header_and_env.cpp"></a>3.2 header_and_env.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  引入&lt;omp.h&gt;头文件，OpenMP的几乎所有函数定义都在这个头文件中。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span>  <span class="comment">// 包含OpenMP头文件 </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// omp_get_max_threads() 等其它函数都定义在omp.h头文件中</span></span><br><span class="line">	<span class="comment">// omp_get_max_threads() 获取本机的CPU线程数</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;OpenMP will use &quot;</span> &lt;&lt; <span class="built_in">omp_get_max_threads</span>() &lt;&lt;</span><br><span class="line">	    <span class="string">&quot; threads maximum.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-parallel-cpp"><a href="#3-3-parallel-cpp" class="headerlink" title="3.3 parallel.cpp"></a>3.3 parallel.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. 尝试将环境变量改为 OMP_NUM_THREADS=2 和 OMP_NUM_THREADS=3 再编译运行程序试试</span></span><br><span class="line"><span class="comment">  2. 尝试在 #pragma omp parallel 后添加num_threads(5) 试试</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel   <span class="comment">// OpenMP 并行区域</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 花括号里的内容会被N个线程同时执行，N定义在环境变量OMP_NUM_THREADS中 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d of %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), <span class="built_in">omp_get_num_threads</span>());</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-parallel-cout-cpp"><a href="#3-4-parallel-cout-cpp" class="headerlink" title="3.4 parallel_cout.cpp"></a>3.4 parallel_cout.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   程序说明： 我们会发现打印在控制台的内容是乱的，这是因为在一个线程还没输出完成时，另一个线程就抢着要输出了！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello from thread &quot;</span> &lt;&lt; <span class="built_in">omp_get_thread_num</span>() &lt;&lt; <span class="string">&quot; of &quot;</span> &lt;&lt;  <span class="built_in">omp_get_num_threads</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-nested-cpp"><a href="#3-5-nested-cpp" class="headerlink" title="3.5 nested.cpp"></a>3.5 nested.cpp</h2><p>如果嵌套并行可用，则在并行区里还会继续创建线程，level 2会输出4次。否则的话level 2输出2次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 看看打印输出是否跟您想的一样，如果不一样，为什么？</span></span><br><span class="line"><span class="comment">    2. 试着禁止嵌套并行;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">omp_set_nested</span>(<span class="number">1</span>);   <span class="comment">// 允许嵌套并行可用 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Level 1, thread %d of %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(),<span class="built_in">omp_get_num_threads</span>());</span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Level 2, thread %d of %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(),<span class="built_in">omp_get_num_threads</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-6-parallel-for-cpp"><a href="#3-6-parallel-for-cpp" class="headerlink" title="3.6 parallel-for.cpp"></a>3.6 parallel-for.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    for循环的并行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> size = <span class="number">50</span>;</span><br><span class="line">	<span class="type">int</span> a[size];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		a[i] = i;                     <span class="comment">// 这里的代码是并行执行的</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)    <span class="comment">// 这里是串行执行的，#pragma omp parallel for作用范围只有紧接着的for循环，当然这个for循环是可以嵌套的.</span></span><br><span class="line">		std::cout &lt;&lt; a[i] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-7-scoping-cpp"><a href="#3-7-scoping-cpp" class="headerlink" title="3.7 scoping.cpp"></a>3.7 scoping.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   1. 变量的作用范围在并行程序设计中非常重要</span></span><br><span class="line"><span class="comment">   2. 如果在并行区域再加一个私有的a变量，想想会发生什么？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// a在并行块内部是共享(默认)的，所有线程都有权操作它(操作的都是同一个变量，没有备份)，而且并行快结束后，块内代码对其的修改有效</span></span><br><span class="line">	<span class="type">int</span> b;     <span class="comment">// 在并行区域外不可见，每个线程有一个备份拷贝</span></span><br><span class="line">	a = <span class="built_in">omp_get_thread_num</span>() + <span class="number">100</span>;</span><br><span class="line">	b = <span class="built_in">omp_get_thread_num</span>() + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;   <span class="comment">// 理论上这里的输出是[100+0,100+threads)之间随机的, 得看哪个线程最后执行完</span></span><br><span class="line">    <span class="comment">//	b = 0;   // 对外不可见，这里会发生错误，所以注释</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-8-firstprivate-cpp"><a href="#3-8-firstprivate-cpp" class="headerlink" title="3.8 firstprivate.cpp"></a>3.8 firstprivate.cpp</h2><p>firstprivate的作用是，让i默认使用并行区域外i的值来初始化并行区域内的私有i，但是初始化后并行去内部的i就跟外面的没有关系了，各个线程仍然持有一个i的私有备份，运行结束时，原有的i值保持i=10不变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 私有变量i是覆盖了并行区域外的共享变量i，所以这里并没有初始化，值应该为0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread %d, i = %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), i);</span><br><span class="line">	i = <span class="number">200</span> + <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-9-lastprivate-cpp"><a href="#3-9-lastprivate-cpp" class="headerlink" title="3.9 lastprivate.cpp"></a>3.9 lastprivate.cpp</h2><p>跟firstprivate相反，lastprivate主要是用来指定将线程中的私有变量的值在并行处理结束后复制回主线程中的对应变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> size = <span class="number">1000</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">-1</span>, a[size];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for lastprivate(i)</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		a[i] = i;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-10-single-master-critical-cpp"><a href="#3-10-single-master-critical-cpp" class="headerlink" title="3.10 single-master-critical.cpp"></a>3.10 single-master-critical.cpp</h2><ol>
<li>omp critical -&gt; execute by one thread at a time</li>
<li>omp single   -&gt; execute by any one thread</li>
<li>omp master   -&gt; execute by the master thread (id == 0)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(8)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello from thread &quot;</span> &lt;&lt; <span class="built_in">omp_get_thread_num</span>() &lt;&lt; <span class="string">&quot; of &quot;</span> &lt;&lt;</span><br><span class="line">	    <span class="built_in">omp_get_num_threads</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-11-mutex-cpp"><a href="#3-11-mutex-cpp" class="headerlink" title="3.11 mutex.cpp"></a>3.11 mutex.cpp</h2><p>锁是多线程计算里非常重要的概念，他是保证数据一致性的基础，没有锁的并行计算会导致非常奇怪的结果。</p>
<p>举个栗子：当多个线程操作一个数据时，一个线程在读取一个数的时候另两个线程在对这个数作写操作，那这个读线程到底应该拿哪一个数值去做计算呢？回答当然是，拿最后更改这个值的线程的值去计算，但是这个值就是对的么？</p>
<p>很多时候即使是并行的，但是对于一个简单操作来讲，它也是需要有先后循序的，比如这个线程在操作这个变量的时候要求别的线程要等待这个线程操作完成，这时候就使用锁将该变量锁住。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">omp_lock_t</span> lock;</span><br><span class="line">	<span class="built_in">omp_init_lock</span>(&amp;lock);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(4)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">omp_set_lock</span>(&amp;lock); <span class="comment">// mutual exclusion (mutex)</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; <span class="built_in">omp_get_thread_num</span>() &lt;&lt;  <span class="string">&quot; has acquired the lock. Sleeping 2 seconds...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; <span class="built_in">omp_get_thread_num</span>() &lt;&lt;<span class="string">&quot; is releasing the lock...&quot;</span> &lt;&lt; std:: endl; <span class="built_in">omp_unset_lock</span>(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="built_in">omp_destroy_lock</span>(&amp;lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-12-barrier-cpp"><a href="#3-12-barrier-cpp" class="headerlink" title="3.12 barrier.cpp"></a>3.12 barrier.cpp</h2><ol>
<li>同步也是并行计算中特别重要的概念，跟上面讲的锁一样;</li>
<li>特别是在时间相关的计算领域里，如含时的有限差分等等;</li>
<li>因为在具体程序中，每个线程执行的任务不一样，即使执行的任务一样，也不能保证每个线程执行任务消费的时间都完全一致。有的线程已经执行了5行代码，有的线程才执行到第0行。而含时的迭代需要所有线程都执行完t步骤后，才能继续执行t+1时间步，不然会导致错误的结果。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d of %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(),</span><br><span class="line">	    <span class="built_in">omp_get_num_threads</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp barrier <span class="comment">//  所有的线程都执行到这里时才能继续往后执行 </span></span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Thread %d of %d have passed the barrier\n&quot;</span>,</span><br><span class="line">	    <span class="built_in">omp_get_thread_num</span>(), <span class="built_in">omp_get_num_threads</span>());</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-13-atomic-cpp"><a href="#3-13-atomic-cpp" class="headerlink" title="3.13 atomic.cpp"></a>3.13 atomic.cpp</h2><p>原子变量跟锁有相近似的作用，都是保证变量或者事务的一致性；举个栗子：银行转账，A给B转账过程中突然停电，A账户前丢失了B却没有收到，这是谁的责任？当然是银行的责任。当然，银行的程序员们可不是吃白米饭的，转账的操作就是一个原子操作，只有成功或失败，没有成功了一半这个说法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">two_body_energy</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">2.0</span> * i + <span class="number">3.0</span> * j) / <span class="number">10.0</span>; <span class="comment">// some dummy return value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> nbodies = <span class="number">1000</span>;</span><br><span class="line">	<span class="type">double</span> energy = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nbodies; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; nbodies; j++) &#123;</span><br><span class="line">			<span class="type">double</span> eij = <span class="built_in">two_body_energy</span>(i, j);</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> omp atomic</span></span><br><span class="line">			energy += eij;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;energy = &quot;</span> &lt;&lt; energy &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-14-reduction-cpp"><a href="#3-14-reduction-cpp" class="headerlink" title="3.14 reduction.cpp"></a>3.14 reduction.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span></span></span><br><span class="line"><span class="function"><span class="title">two_body_energy</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">2.0</span> * i + <span class="number">3.0</span> * j) / <span class="number">10.0</span>; <span class="comment">// some dummy return value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> nbodies = <span class="number">1000</span>;</span><br><span class="line">	<span class="type">double</span> energy = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// + 是进行加运算</span></span><br><span class="line"><span class="comment">// energy 是要进行归约的变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+:energy)   </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nbodies; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; nbodies; j++) &#123;</span><br><span class="line">			<span class="type">double</span> eij = <span class="built_in">two_body_energy</span>(i, j);</span><br><span class="line">			energy += eij;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;energy = &quot;</span> &lt;&lt; energy &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-15-scheduling-cpp"><a href="#3-15-scheduling-cpp" class="headerlink" title="3.15 scheduling.cpp"></a>3.15 scheduling.cpp</h2><p>schedule只能用于循环并行构造中，其作用是用于控制循环并行结构的任务调度。一个简单的理解，一个for循环假设有10次迭代，使用4个线程去执行，那么哪些线程去执行哪些迭代呢？可以通过schedule去控制迭代的调度和分配，从而适应不同的使用情况，提高性能。</p>
<ul>
<li>static -&gt; 大部分的编译器实现，在没有使用schedule子句的时候，系统就是采用static方式调度的。<ul>
<li>对于<code>schedule(static,size)</code>的含义，OpenMP会给每个线程分配size次迭代计算。这个分配是静态的，“静态”体现在这个分配过程跟实际的运行是无关的，可以从逻辑上推断出哪几次迭代会在哪几个线程上运行。具体而言，对于一个N次迭代，使用M个线程，那么，<code>[0,size-1]</code>的size次的迭代是在第一个线程上运行，<code>[size, size + size -1]</code>是在第二个线程上运行，依次类推。那么，如果M太大，size也很大，就可能出现很多个迭代在一个线程上运行，而某些线程不执行任何迭代。需要说明的是，这个分配过程就是这样确定的，不会因为运行的情况改变，比如，我们知道，进入OpenMP后，假设有M个线程，这M个线程开始执行的时间不一定是一样的，这是由OpenMP去调度的，并不会因为某一个线程先被启动，而去改变for的迭代的分配，这就是静态的含义。</li>
</ul>
</li>
<li>dynamic -&gt; 每个线程运行结束时获得新的计算任务<ul>
<li>动态调度迭代的分配是依赖于运行状态进行动态确定的，所以哪个线程上将会运行哪些迭代是无法像静态一样事先预料的。对于dynamic，没有size参数的情况下，每个线程按先执行完先分配的方式执行1次循环，比如，刚开始，线程1先启动，那么会为线程1分配一次循环开始去执行（i=0的迭代），然后，可能线程2启动了，那么为线程2分配一次循环去执行（i=1的迭代），假设这时候线程0和线程3没有启动，而线程1的迭代已经执行完，可能会继续为线程1分配一次迭代，如果线程0或3先启动了，可能会为之分配一次迭代，直到把所有的迭代分配完。所以，动态分配的结果是无法事先知道的，因为我们无法知道哪一个线程会先启动，哪一个线程执行某一个迭代需要多久等等，这些都是取决于系统的资源、线程的调度等等。</li>
</ul>
</li>
<li>guided -&gt; 类似动态钓鱼，但是 chunk size是自适应的。<ul>
<li>类似于动态调度，但每次分配的循环次数不同，开始比较大，以后逐渐减小。size表示每次分配的迭代次数的最小值，由于每次分配的迭代次数会逐渐减少，较少到size时，将不再减少。如果不知道size的大小，那么默认size为1，即一直减少到1。具体是如何减少的，以及开始比较大（具体是多少？），参考相关手册的信息。</li>
</ul>
</li>
<li>auto -&gt; 编译器动态决定采用那种策略<ul>
<li>runtime表示根据环境变量确定上述调度策略中的某一种，默认也是静态的（static）。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_SIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scheduling:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> niter = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for schedule(static, CHUNK_SIZE)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; niter; i++) &#123;</span><br><span class="line">		<span class="type">int</span> thr = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;iter %d of %d on thread %d\n&quot;</span>, i, niter, thr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-16-ordered-cpp"><a href="#3-16-ordered-cpp" class="headerlink" title="3.16 ordered.cpp"></a>3.16 ordered.cpp</h2><p>在循环代码中某些代码的执行需要按规定的顺序执行，比如在一个循环中，一部分的工作可以并行执行，而特定的部分需要按照串行的工作流程依次执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> niter = <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for ordered       <span class="comment">// 这里必须这么写</span></span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; niter; i++) &#123;</span><br><span class="line">		<span class="type">int</span> thr = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unordered iter %d of %d on thread %d\n&quot;</span>, i, niter, thr);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp ordered                    <span class="comment">// 这里是需要顺序执行的部分</span></span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ordered iter %d of %d on thread %d\n&quot;</span>, i, niter, thr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-17-loop-dependencies-cpp"><a href="#3-17-loop-dependencies-cpp" class="headerlink" title="3.17 loop-dependencies.cpp"></a>3.17 loop-dependencies.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">( <span class="type">int</span> N, <span class="type">int</span> M, <span class="type">double</span> **A, <span class="type">double</span> **B, <span class="type">double</span> **C )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">double</span> alpha = <span class="number">1.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for collapse(2) ordered(2)</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; M<span class="number">-1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">        A[i][j] = <span class="built_in">foo</span>(i, j);</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp ordered depend(source)</span></span><br><span class="line"></span><br><span class="line">        B[i][j] = alpha * A[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp ordered depend(sink: i-1,j) depend(sink: i,j-1)</span></span><br><span class="line">        C[i][j] = <span class="number">0.2</span> * (A[i<span class="number">-1</span>][j] + A[i<span class="number">+1</span>][j] + A[i][j<span class="number">-1</span>] + A[i][j<span class="number">+1</span>] + A[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-18-sections-cpp"><a href="#3-18-sections-cpp" class="headerlink" title="3.18 sections.cpp"></a>3.18 sections.cpp</h2><ol>
<li>有些需要并行的任务并不是一个for循环之类的，而是一个个代码块，这种情况下就可以使用sections的情形；</li>
<li>sections下包含多个section，section相互之间只并行执行的，但是section内部是串行执行的；</li>
<li>多个sections之间也是串行执行的</li>
<li>如果<code>#pragma omp parallel sections</code> 写成<code>#pragma omp sections</code>，则各个section之间是串行执行的 </li>
<li>如果变成两个线程的话，会有一个线程执行两个section</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel sections num_threads(4)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section <span class="comment">// 独立线程</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> thr = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;section 1, thread %d - sleeping 1 second\n&quot;</span>, thr);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;section 1 done\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section <span class="comment">// 独立线程</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> thr = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;section 2, thread %d - sleeping 2 second\n&quot;</span>, thr);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;section 2 done\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section <span class="comment">// 独立线程</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> thr = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;section 3, thread %d - sleeping 3 second\n&quot;</span>, thr);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;section 3 done\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// printf(&quot;not in omp section&quot;); // error - code must be in section</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-19-threadprivate-cpp"><a href="#3-19-threadprivate-cpp" class="headerlink" title="3.19 threadprivate.cpp"></a>3.19 threadprivate.cpp</h2><p>threadprivate指令用来指定全局的对象被各个线程各自复制了一个私有的拷贝，即各个线程具有各自私有的全局对象。threadprivate和private的区别在于threadprivate声明的变量通常是全局范围内有效的，而private声明的变量只在它所属的并行构造中有效。用作threadprivate的变量的地址不能是常数。对于C++的类（class）类型变量，用作threadprivate的参数时有些限制，当定义时带有外部初始化时，必须具有明确的拷贝构造函数。程序示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(g)       <span class="comment">//一定要先声明</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Explicitly turn off dynamic threads */</span></span><br><span class="line">    <span class="built_in">omp_set_dynamic</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">       g = <span class="built_in">omp_get_thread_num</span>();   </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;tid: %d\n&quot;</span>,g);         <span class="comment">//随机依次输出0~3</span></span><br><span class="line">    &#125; <span class="comment">// End of parallel region</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = g*g;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tid : %d, tid*tid: %d\n&quot;</span>,g, temp);  <span class="comment">//不同线程中全局变量值不同</span></span><br><span class="line">    &#125; <span class="comment">// End of parallel region</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：在使用threadprivate的时候，要用omp_set_dynamic(0)关闭动态线程的属性，才能保证结果正确。</p>
<h2 id="3-20-Copyin-cpp"><a href="#3-20-Copyin-cpp" class="headerlink" title="3.20 Copyin.cpp"></a>3.20 Copyin.cpp</h2><p>copyin子句用于将主线程中threadprivate变量的值拷贝到执行并行区域的各个线程的threadprivate变量中，从而使得team内的子线程都拥有和主线程同样的初始值。程序示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> A = <span class="number">100</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(A) </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        A++; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,<span class="built_in">omp_get_thread_num</span>(), i, A);   <span class="comment">// #1 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A); <span class="comment">// 并行区域外的打印的“Globa A”的值总是和前面的thread 0的结果相等，因为退出并行区域后，只有master线程即0号线程运行。</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for copyin(A)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        A++; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,<span class="built_in">omp_get_thread_num</span>(), i, A);   <span class="comment">// #1 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A); <span class="comment">// #2 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-21-Copyprivate-cpp"><a href="#3-21-Copyprivate-cpp" class="headerlink" title="3.21 Copyprivate.cpp"></a>3.21 Copyprivate.cpp</h2><p>copyprivate子句用于将线程私有副本变量的值从一个线程广播到执行同一并行区域的其他线程的同一变量。copyprivate只能用于single指令（single指令:用在一段只被单个线程执行的代码段之前,表示后面的代码段将被单线程执行）的子句中，在一个single块的结尾处完成广播操作。copyprivate只能用于private/firstprivate或threadprivate修饰的变量。程序示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(counter)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">increment_counter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">return</span>(counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>    count;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single copyprivate(counter)</span></span><br><span class="line">        &#123;</span><br><span class="line">            counter = <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count = <span class="built_in">increment_counter</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ThreadId: %ld, count = %ld/n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// count 都是51</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-22-nowait-cpp"><a href="#3-22-nowait-cpp" class="headerlink" title="3.22 nowait.cpp"></a>3.22 nowait.cpp</h2><p>栅障（Barrier）是OpenMP用于线程同步的一种方法。线程遇到栅障是必须等待，直到并行区中的所有线程都到达同一点。注意：在任务分配for循环和任务分配section结构中，我们已经隐含了栅障，在parallel,for,sections,single结构的最后，也会有一个隐式的栅障。</p>
<p>隐式的栅障会使线程等到所有的线程继续完成当前的循环、结构化块或并行区，再继续执行后面的工作。可以使用nowait去掉这个隐式的栅障.去掉隐式栅障，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel <span class="comment">//并行区内</span></span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="meta">#<span class="keyword">pragma</span> omp for nowait <span class="comment">// 任务分配for循环</span></span></span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;m;k++)&#123;</span><br><span class="line">             <span class="built_in">fun1</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="meta">#<span class="keyword">pragma</span> omp sections private(y,z)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#pragme omp section<span class="comment">//任务分配section</span></span></span><br><span class="line">            &#123;y=<span class="built_in">sectionA</span>(x);&#125;</span><br><span class="line">        <span class="meta">#pragme omp section</span></span><br><span class="line">            &#123;z=<span class="built_in">sectionB</span>(x);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为第一个 任务分配for循环和第二个任务分配section代码块之间不存在数据相关。加上显示栅障，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(x,y,z) num_threads(2)<span class="comment">//使用的线程数为2</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tid=<span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    <span class="keyword">if</span>(tid==<span class="number">0</span>)</span><br><span class="line">        y=<span class="built_in">fun1</span>();<span class="comment">//第一个线程得到y</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        z=<span class="built_in">fun2</span>();<span class="comment">//第二个线程得到z</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp barrier <span class="comment">//显示加上栅障，保证y和z在使用前已有值</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)</span><br><span class="line">        x[k]=y+z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单线程和多线程交错执行： 当开发人员为了减少开销而把并行区设置的很大时，有些代码很可能只执行一次，并且由一个线程执行，这样单线程和多线程需要交错执行</p>
<p>举例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel <span class="comment">//并行区</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tid=<span class="built_in">omp_get_thread_num</span>();<span class="comment">//每个线程都调用这个函数，得到线程号</span></span><br><span class="line">    <span class="comment">//这个循环被划分到多个线程上进行</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp for nowait</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)</span><br><span class="line">        x[k]=<span class="built_in">fun1</span>(tid);<span class="comment">//这个循环的结束处不存在使所有线程进行同步的隐式栅障</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp master</span></span><br><span class="line">    y=<span class="built_in">fn_input_only</span>(); <span class="comment">//只有主线程会调用这个函数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp barrier   <span class="comment">//添加一个显示的栅障对所有的线程同步，从而确保x[0-99]和y处于就绪状态</span></span></span><br><span class="line">    <span class="comment">//这个循环也被划分到多个线程上进行</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp for nowait</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)</span><br><span class="line">        x[k]=y+<span class="built_in">fn2</span>(x[k]); <span class="comment">//这个线程没有栅障，所以不会相互等待</span></span><br><span class="line">    <span class="comment">//一旦某个线程执行完上面的代码，不需要等待就可以马上执行下面的代码</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp single <span class="comment">//注意：single后面意味着有隐式barrier</span></span></span><br><span class="line">    <span class="built_in">fn_single_print</span>(y);</span><br><span class="line">    <span class="comment">//所有的线程在执行下面的函数前会进行同步</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp master</span></span><br><span class="line">    <span class="built_in">fn_print_array</span>(x);<span class="comment">//只有主线程会调用这个函数</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h2 id="3-23-task"><a href="#3-23-task" class="headerlink" title="3.23 task"></a>3.23 task</h2><p>从功能上说：</p>
<ol>
<li>The TASK construct defines an explicit task, which may be executed by the encountering thread, or deferred for execution by any other thread in the team.</li>
<li>The data environment of the task is determined by the data sharing attribute clauses.</li>
<li>Task execution is subject to task scheduling - see the OpenMP 3.0 specification document for details.</li>
</ol>
<p>任务构造定义一个显式的任务，可能会被遇到的线程马上执行，也可能被延迟给线程组内其他线程来执行。任务的执行，依赖于OpenMP的任务调度。</p>
<p>语法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp task [clause ...]  newline </span><br><span class="line">                   if (scalar expression) </span><br><span class="line">                   final (scalar expression) </span><br><span class="line">                   untied</span><br><span class="line">                   default (shared | none)</span><br><span class="line">                   mergeable</span><br><span class="line">                   private (list) </span><br><span class="line">                   firstprivate (list) </span><br><span class="line">                   shared (list) </span><br><span class="line">     structured_block</span><br></pre></td></tr></table></figure></p>
<p>task，简单的理解，就是定义一个任务，线程组内的某一个线程来执行此任务。和工作共享结构很类似，我们都知道，for也是某一个线程执行某一个迭代，如果把每一个迭代看成一个task，那么就是task的工作方式了，在for只能用于循环迭代的基础上，OpenMP提供了sections构造，用于构造一个sections，然后里面定义一堆的section，每一个section被一个线程去执行，这样，每一个section也类似于for的每一次迭代，只是使用sections会更灵活，更简单，但是其实，for和sections在某种程度上是可以转换的，用下面的例子来看一个使用sections和for指令分别执行“三个”任务的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_COUNT	3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task1</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task1, Thread ID: %d, task: %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task2</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task2, Thread ID: %d, task: %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task3</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task3, Thread ID: %d, task: %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp sections</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">			<span class="built_in">task1</span>(<span class="number">10</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">			<span class="built_in">task2</span>(<span class="number">20</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">			<span class="built_in">task3</span>(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; TASK_COUNT; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">task1</span>(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">task2</span>(<span class="number">20</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) </span><br><span class="line">				<span class="built_in">task3</span>(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，这个程序不是这里要讨论的重点，只是为了说明for和sections的一些类似之处，或者其实可以理解为sections其实是for的展开形式，适合于少量的“任务”，并且适合于没有迭代关系的“任务”。很显然，上面的例子适合用sections去解决，因为本身是三个任务，不存在迭代的关系，三个任务和循环迭代变量没有什么关联。</p>
<p>接下来，分析下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task, Thread ID: %d, task: %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N		3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span>*a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">		a[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[N];</span><br><span class="line">	<span class="built_in">init</span>(a);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp sections</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">			<span class="built_in">task</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">			<span class="built_in">task</span>(a[<span class="number">1</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">			<span class="built_in">task</span>(a[<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">task</span>(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子，很容易理解了，把一个数组内的每一个元素“并行”的传递给<code>task()</code>函数，执行一个“任务”。同样，for和sections都能解决，但是如果N太大了，比如N是100，那sections就为难了，这里要说明的是：sections不能使用嵌套的形式，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">	<span class="built_in">task</span>(a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样是不行的，section只能显式的，直接的在sections里面书写，可以理解为”静态“的。继续研究这个例子，假设现在的需求是对如下的代码进行并行化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i=i+a[i])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">task</span>(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于这样的需求，OpenMP的for指令也是无法完成的，因为for指令在进行并行执行之前，就需要”静态“的知道任务该如何划分，而上面的i=i+a[i]，在运行之前，是无法知道有那些迭代，需要如何进行划分，因为其迭代的循环依赖于数组a里面保存的值。那么对于这样的循环，该如何并行？最关键的是，从语义上，这个循环是明显可以进行并行的。这就是之所以OpenMP3.0提供task的原因了。</p>
<p>在此，先总结一下for和sections指令的”缺陷“：无法根据运行时的环境动态的进行任务划分，必须是预先能知道的任务划分的情况。</p>
<p>使用task解决上面遗留的问题的方法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task, Thread ID: %d, task: %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N		50</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span>*a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">		a[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[N];</span><br><span class="line">	<span class="built_in">init</span>(a);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i=i+a[i])</span><br><span class="line">			&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp task</span></span><br><span class="line">				<span class="built_in">task</span>(a[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里之所以用single表示只有一个线程会执行下面的代码，否则会执行两次（这里用的线程数量为2），这是single的子句的理解，就不在此分析了。看其中task的代码，其实很简单，OpenMP遇到了task之后，就会使用当前的线程或者延迟一会后接下来的线程来执行task定义的任务。task的作用，就是定义了一个显式的任务。</p>
<p>那么，task和前面的for和sections的区别在于：task是“动态”定义任务的，在运行过程中，只需要使用task就会定义一个任务，任务就会在一个线程上去执行，那么其它的任务就可以并行的执行。可能某一个任务执行了一半的时候，或者甚至要执行完的时候，程序可以去创建第二个任务，任务在一个线程上去执行，一个动态的过程，不像sections和for那样，在运行之前，已经可以判断出可以如何去分配任务。而且，task是可以进行嵌套定义的，可以用于递归的情况等等。</p>
<p>总结task的使用：task主要适用于不规则的循环迭代（如上面的循环）和递归的函数调用。都是无法使用for来完成的情况。</p>
<p>显示任务和隐式任务（implicit&amp;explicit）</p>
<p>task的作用就是创建一个显式的任务，那么什么是隐式的任务呢？OpenMP的任务分为显式和隐式两种，根据我的个人理解，分析下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i=i+a[i])</span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp task</span></span><br><span class="line">			<span class="built_in">task</span>(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	    <span class="built_in">task</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中task(1000);就属于一个隐式的任务。因为执行完for后，会执行这一个任务，而上面的任务可能也会同时执行。</p>
<p>task的嵌套</p>
<p>任务构造结构可以嵌套在另一个task结构中，但是内部的task结构并不属于外部的task区域的一部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp task</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">task</span>(a[i]);</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp task</span></span><br><span class="line">    <span class="built_in">task</span>(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的理解，OpenMP遇到task指令就会定义一个显式的任务，就会在当前的线程或者延迟等待其它线程去执行，而不是将嵌套task的部分当作外部task的一部分。</p>
<p>task指令的子句</p>
<p>如果给一个task使用了if子句，如果if子句的表达式是false，会生成一个不延迟的任务，这样，遇到这个task的当前线程必须挂起当前的task区域，直到当前的任务完成之后才会恢复。个人理解，当前线程挂起，那么这个task是不是由其它的线程去执行呢，还是就是当前的这个线程执行这个任务？</p>
<p>如果给task使用了final子句，如果final表达式的值为true，生成的任务是一个终结任务。所有任务遇到终结任务执行的时候会生成终结和包含的任务。PS：不太理解！</p>
<h2 id="3-25-flush-cpp"><a href="#3-25-flush-cpp" class="headerlink" title="3.25 flush.cpp"></a>3.25 flush.cpp</h2><p>当并行区域里存在一共享变量，并且对其进行修改时，需要用flush更新变量，确保并行的多线程对共享变量的读操作是最新值.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">done=<span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp flush(done)</span></span><br><span class="line"> <span class="keyword">if</span>(!done)</span><br><span class="line"> &#123;</span><br><span class="line">    ...</span><br><span class="line">    done=<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="OpenMP中数据属性相关子句详解"><a href="#OpenMP中数据属性相关子句详解" class="headerlink" title="OpenMP中数据属性相关子句详解"></a>OpenMP中数据属性相关子句详解</h1><h2 id="private-firstprivate-lastprivate-threadprivate之间的比较"><a href="#private-firstprivate-lastprivate-threadprivate之间的比较" class="headerlink" title="private/firstprivate/lastprivate/threadprivate之间的比较"></a>private/firstprivate/lastprivate/threadprivate之间的比较</h2><p>private/firstprivate/lastprivate/threadprivate，首先要知道的是，它们分为两大类，一类是private/firstprivate/lastprivate子句，另一类是threadprivate，为指令。</p>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>private子句将一个或多个变量声明为线程的私有变量。每个线程都有它自己的变量私有副本，其他线程无法访问。即使在并行区域外有同名的共享变量，共享变量在并行区域内不起任何作用，并且并行区域内不会操作到外面的共享变量。<br>注意：</p>
<ol>
<li>private variables are undefined on entry and exit of the parallel region.即private变量在进入和退出并行区域是“未定义“的。</li>
<li>The value of the original variable (before the parallel region) is undefined after the parallel region!在并行区域之前定义的原来的变量，在并行区域后也是”未定义“的。</li>
<li>A private variable within the parallel region has no storage association with the same variable outside of the region. 并行区域内的private变量和并行区域外同名的变量没有存储关联。</li>
</ol>
<p>说明：private的很容易理解错误。下面用例子来说明上面的注意事项，</p>
<p>A. private变量在进入和退出并行区域是”未定义“的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for private(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初学OpenMP很容易认为这段代码是没有问题的。其实，这里的A在进入并行区域的时候是未定义的，所以在并行区域直接对其进行读操作，会导致运行时错误。<br>其实，在VS中编译这段代码，就会有编译警告：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning C4700: uninitialized local variable &#x27;A&#x27; used</span><br></pre></td></tr></table></figure></p>
<p>很清楚的指向”printf”这句，A是没有初始化的变量。所以，运行时候会出现运行时崩溃的错误。</p>
<p>这段代码能说明，private在进入并行区域是未定义的，至于退出并行区域就不容易举例说明了，本身，这里的三个注意事项是交叉理解的，说明的是一个含义，所以，看下面的例子来理解。</p>
<p>B. 在并行区域之前定义的原来的变量，在并行区域后也是”未定义“的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> B;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for private(B)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		B = <span class="number">100</span>; </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,B);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的B在并行区域内进行了赋值等操作，但是在退出并行区域后，是未定义的。理解”在并行区域之 前定义的 原来的变量，在并行区域 后也是” 未定义“的“这句话的时候，要注意，不是说所有的在并行区域内定义的原来的变量，使用了private子句后，退出并行区域后就一定是未定义的，如果原来的变量，本身已经初始化，那么，退出后，不会处于未定义的状态，就是下面的第三个注意事项要说明的问题。</p>
<p>C. 并行区域内的private变量和并行区域外同名的变量没有存储关联<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> C = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for private(C)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		C = <span class="number">200</span>; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,C);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,C);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，在退出并行区域后，printf的C的结果是100，和并行区域内对其的操作无关。</p>
<p>总结来说，上面的三点是交叉的，第三点包含了所有的情况。所以，private的关键理解是：A private variable within the parallel region has no storage association with the same variable outside of the region. 简单点理解，可以认为，并行区域内的private变量和并行区域外的变量没有任何关联。如果非要说点关联就是，在使用private的时候，在之前要先定义一下这个变量，但是，到了并行区域后，并行区域的每个线程会产生此变量的副本，而且是没有初始化的。</p>
<p>下面是综合上面的例子，参考注释的解释：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A=<span class="number">100</span>,B,C=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for private(A) private(B)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		B = A + i;		<span class="comment">// A is undefined! Runtime error!</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*--End of OpemMP paralle region. --*/</span></span><br><span class="line"> </span><br><span class="line">	C = B;			<span class="comment">// B is undefined outside of the parallel region!</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;A:%d\n&quot;</span>, A);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;B:%d\n&quot;</span>, B);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="firstprivate"><a href="#firstprivate" class="headerlink" title="firstprivate"></a>firstprivate</h3><p>private子句的私有变量不能继承同名变量的值，firstprivate则用于实现这一功能-继承并行区域额之外的变量的值，用于在进入并行区域之前进行一次初始化。</p>
<p>Firstprivate(list): All variables in the list areinitialized with the value the original object had before entering the parallelconstruct.</p>
<p>分析下面的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for firstprivate(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>,i, A);	<span class="comment">// #1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用VS编译发现，也会报一个“warning C4700: uninitialized local variable ‘A’ used”的警告，但是这里其实两个地方用到了A。实际上，这个警告是针对第二处的，可以看出，VS并没有给第一处OpenMP并行区域内的A有警告，这是由于使用firstprivate的时候，会对并行区域内的A使用其外的同名共享变量就行初始化，当然，如果严格分析，外面的变量其实也是没有初始化的，理论上也是可以认为应该报警告，但是，具体而言，这是跟VS的实现有关的，另外，在debug下，上面的程序会崩溃，release下，其实是可以输出值的，总之，上面的输出是无法预料的。<br>再看下面的例子，和前面private的例子很类似：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for firstprivate(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>,i, A);	<span class="comment">// #1</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，如果使用private，那么并行区域内是有问题的，因为并行区域内的A是没有初始化的，导致无法预料的输出或崩溃。但是，使用了firstprivate后，这样，进入并行区域的时候，每一个线程的A的副本都会利用并行区域外的同名共享变量A的值进行一次初始化，所以，输出的A都是100.<br>继续探讨这里的“进行一次初始化”，为了理解“一次”的含义，看下面的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for firstprivate(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,omp_get_thread_num(), i, A);	<span class="comment">// #1</span></span><br><span class="line">		A = i;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，每次输出后，改变A的值，需要注意的是，这里的“进行一次初始化”是针对team内的每一个线程进行一次初始化，对于上面的程序，在4核的CPU上运行，并行区域内有四个线程，所以每一个线程都会有A的一个副本，因而，上面的程序输出结果可能如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread ID: 0, 0: 100</span><br><span class="line">Thread ID: 0, 1: 0</span><br><span class="line">Thread ID: 0, 2: 1</span><br><span class="line">Thread ID: 2, 6: 100</span><br><span class="line">Thread ID: 2, 7: 6</span><br><span class="line">Thread ID: 1, 3: 100</span><br><span class="line">Thread ID: 2, 4: 3</span><br><span class="line">Thread ID: 1, 5: 4</span><br><span class="line">Thread ID: 3, 8: 100</span><br><span class="line">Thread ID: 3, 9: 8</span><br><span class="line">100</span><br></pre></td></tr></table></figure></p>
<p>其实，这个结果是很容易理解的，不可能是每一个for都有一个变量的副本，而是每一个线程，所以这个结果在预料之中。</p>
<p>仍然借助上面这个例子，帮助理解private和firstprivate，从而引出lastprivate，private对于并行区域的每一个线程都有一个副本，并且和并行区域外的变量没有关联；firstprivate解决了进入并行区的问题，即在进入并行区域的每个线程的副本变量使用并行区域外的共享变量进行一个初始化的工作，那么下面有一个问题就是，如果希望并行区域的副本变量，在退出并行区的时候，能反过来赋值给并行区域外的共享变量，那么就需要依靠lastprivate了。</p>
<h3 id="lastprivate"><a href="#lastprivate" class="headerlink" title="lastprivate"></a>lastprivate</h3><p>如果需要在并行区域内的私有变量经过计算后，在退出并行区域时，需要将其值赋给同名的共享变量，就可以使用lastprivate完成。</p>
<p>Lastprivate(list):The thread that executes the sequentially last iteration or section updates thevalue of the objects in the list.</p>
<p>从上面的firstprivate的最后一个例子可以看出，并行区域对A进行了赋值，但是退出并行区域后，其值仍然为原来的值。</p>
<p>这里首先有一个问题是：退出并行区域后，需要将并行区域内的副本的值赋值为同名的共享变量，那么，并行区域内有多个线程，是哪一个线程的副本用于赋值呢？</p>
<p>是否是最后一个运行完毕的线程？否！OpenMP规范中指出，如果是循环迭代，那么是将最后一次循环迭代中的值赋给对应的共享变量；如果是section构造，那么是最后一个section语句中的值赋给对应的共享变量。注意这里说的最后一个section是指程序语法上的最后一个，而不是实际运行时的最后一个运行完的。</p>
<p>在理解这句话之前，先利用一个简单的例子来理解一下lastprivate的作用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for lastprivate(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		A = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，很容易知道结果为10，而不是100.这就是lastprivate带来的效果，退出后会有一个赋值的过程。<br>理解了lastprivate的基本含义，就可以继续来理解上面的红色文字部分的描述了，即到底是哪一个线程的副本用于对并行区域外的变量赋值的问题，下面的例子和前面firstprivate的例子很类似：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for lastprivate(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d\n&quot;</span>,omp_get_thread_num(), i);	<span class="comment">// #1</span></span><br><span class="line">		A = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread ID: 0, 0</span><br><span class="line">Thread ID: 0, 1</span><br><span class="line">Thread ID: 0, 2</span><br><span class="line">Thread ID: 3, 8</span><br><span class="line">Thread ID: 3, 9</span><br><span class="line">Thread ID: 2, 6</span><br><span class="line">Thread ID: 1, 3</span><br><span class="line">Thread ID: 1, 4</span><br><span class="line">Thread ID: 1, 5</span><br><span class="line">Thread ID: 2, 7</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>从结果可以看出，最后并行区域外的共享变量的值并不是最后一个线程退出的值，多次运行发现，并行区域的输出结果可能发生变化，但是最终的输出都是9，这就是上面的OpenMP规范说明的问题，退出并行区域的时候，是根据“逻辑上”的最后一个线程用于对共享变量赋值，而不是实际运行的最后一个线程，对于for而言，就是最后一个循环迭代所在线程的副本值，用于对共享变量赋值。</p>
<p>另外，firstprivate和lastprivate分别是利用共享变量对线程副本初始化（进入）以及利用线程副本对共享变量赋值（退出），private是线程副本和共享变量无任何关联，那么如果希望进入的时候初始化并且退出的时候赋值呢？事实上，可以对同一个变量使用firstprivate和lastprivate的，下面的例子即可看出：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for firstprivate(A) lastprivate(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,omp_get_thread_num(), i, A);	<span class="comment">// #1</span></span><br><span class="line">		A = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：不能对一个变量同时使用两次private，或者同时使用private和firstprivate/lastprivate，只能firstprivate和lastprivate一起使用。<br>关于lastprivate，还需要说明的一点是，如果是类（class）类型的变量使用在lastprivate参数中，那么使用时有些限制，需要一个可访问的，明确的缺省构造函数，除非变量也被使用作为firstprivate子句的参数；还需要一个拷贝赋值操作符，并且这个拷贝赋值操作符对于不同对象的操作顺序是未指定的，依赖于编译器的定义。</p>
<p>另外，firstprivate和private可以用于所有的并行构造块，但是lastprivate只能用于for和section组成的并行块之中。</p>
<h3 id="threadprivate"><a href="#threadprivate" class="headerlink" title="threadprivate"></a>threadprivate</h3><p>首先，threadprivate和上面几个子句的区别在于，threadprivate是指令，不是子句。threadprivate指定全局变量被OpenMP所有的线程各自产生一个私有的拷贝，即各个线程都有自己私有的全局变量。一个很明显的区别在于，threadprivate并不是针对某一个并行区域，而是整个于整个程序，所以，其拷贝的副本变量也是全局的，即在不同的并行区域之间的同一个线程也是共享的。</p>
<p>threadprivate只能用于全局变量或静态变量，这是很容易理解的，根据其功能。</p>
<p>根据下面的例子，来进一步理解threadprivate的使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(A)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		A++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,omp_get_thread_num(), i, A);	<span class="comment">// #1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		A++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,omp_get_thread_num(), i, A);	<span class="comment">// #1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Thread ID: 0, 0: 101</span><br><span class="line">Thread ID: 0, 1: 102</span><br><span class="line">Thread ID: 0, 2: 103</span><br><span class="line">Thread ID: 3, 8: 101</span><br><span class="line">Thread ID: 3, 9: 102</span><br><span class="line">Thread ID: 1, 3: 101</span><br><span class="line">Thread ID: 1, 4: 102</span><br><span class="line">Thread ID: 1, 5: 103</span><br><span class="line">Thread ID: 2, 6: 101</span><br><span class="line">Thread ID: 2, 7: 102</span><br><span class="line">Global A: 103</span><br><span class="line">Thread ID: 2, 6: 103</span><br><span class="line">Thread ID: 2, 7: 104</span><br><span class="line">Thread ID: 0, 0: 104</span><br><span class="line">Thread ID: 0, 1: 105</span><br><span class="line">Thread ID: 0, 2: 106</span><br><span class="line">Thread ID: 1, 3: 104</span><br><span class="line">Thread ID: 1, 4: 105</span><br><span class="line">Thread ID: 1, 5: 106</span><br><span class="line">Thread ID: 3, 8: 103</span><br><span class="line">Thread ID: 3, 9: 104</span><br><span class="line">Global A: 106</span><br></pre></td></tr></table></figure>
<p>分析结果，发现，第二个并行区域是在第一个并行区域的基础上继续递增的；每一个线程都有自己的全局私有变量。另外，观察在并行区域外的打印的“Globa A”的值可以看出，这个值总是前面的thread 0的结果，这也是预料之中的，因为退出并行区域后，只有master线程运行。</p>
<p>threadprivate指令也有自己的一些子句，就不在此分析了。另外，如果使用的是C++的类，对于类的构造函数也会有类似于lastprivate的一些限制。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>private/firstprivate/lastprivate都是子句，用于表示并行区域内的变量的数据范围属性。其中，private表示并行区域team内的每一个线程都会产生一个并行区域外同名变量的共享变量，且和共享变量没有任何关联；firstprivaet在private的基础上，在进入并行区域时（或说每个线程创建时，或副本变量构造时），会使用并行区域外的共享变量进行一次初始化工作；lastprivate在private的基础上，在退出并行区域时，会使用并行区域内的副本的变量，对共享变量进行赋值，由于有多个副本，OpenMP规定了如何确定使用哪个副本进行赋值。另外，private不能和firstprivate/lastprivate混用于同一个变量，firstprivate和lastprivate可以对同一变量使用，效果为两者的结合。</p>
<p>threadprivate是指令，和private的区别在于，private是针对并行区域内的变量的，而threadprivate是针对全局的变量的。</p>
<h2 id="shared-default-copyin-copyprivate子句的使用"><a href="#shared-default-copyin-copyprivate子句的使用" class="headerlink" title="shared/default/copyin/copyprivate子句的使用"></a>shared/default/copyin/copyprivate子句的使用</h2><h3 id="shared"><a href="#shared" class="headerlink" title="shared"></a>shared</h3><p>shared子句可以用于声明一个或多个变量为共享变量。所谓的共享变量，是在一个并行区域的team内的所有线程只拥有变量的一个内存地址，所有线程访问同一地址。所以，对于并行区域内的共享变量，需要考虑数据竞争条件，要防止竞争，需要增加对应的保护，这是程序员需要自行考虑的。</p>
<p>下面的例子是一个求和的并行实现，使用共享变量，由于没有采取保护，会有数据竞争：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT	10000</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for shared(sum)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; COUNT;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum = sum + i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多次运行，结果可能不一样。</p>
<p>另外，需要注意，循环迭代变量在循环构造区域里是私有的，声明在循环构造区域内的自动变量都是私有的。这一点其实也是比较容易理解的，很难想象，如果循环迭代变量也是共有的，OpenMP该如何去执行，所以也只能是私有的了。即使使用shared来修饰循环迭代变量，也不会改变循环迭代变量在循环构造区域中是私有的这一特点:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT	10</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for shared(sum, i)</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; COUNT;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum = sum + i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子能侧面能说明问题，这里的最后输出i是0，并不是0到COUNT之内的一个可能的值，尽管这里使用shared修饰变量i。注意，这里的规则只是针对循环并行区域，对于其他的并行区域没有这样的要求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT	10</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(sum) private(i)</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; COUNT;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum = sum + i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里输出的i为0，如果改为shared，那么就是10了。当然，这段代码和上面的求和的代码含义上就是不一样的。</p>
<p>另外，这里顺便一个问题是，在循环并行区域内，循环迭代变量是不可修改的。这也是上面的例子，为何不采用下面的写法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for shared(sum) shared(i)</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; COUNT;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		sum = sum + i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，i++会报错，原因是在循环并行区域内，迭代变量i是可读不可写的。</p>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>default指定并行区域内变量的属性，C++的OpenMP中default的参数只能为shared或none，对于Fortran，可以为private等参数，具体参考手册。</p>
<p><code>default(shared)</code>：表示并行区域内的共享变量在不指定的情况下都是shared属性</p>
<p><code>default(none)</code>：表示必须显式指定所有共享变量的数据属性，否则会报错，除非变量有明确的属性定义（比如循环并行区域的循环迭代变量只能是私有的）</p>
<p>另外，如果一个并行区域，没有使用default子句，会是什么情况？实际测试，个人认为，没有使用default，那么其默认行为为default(shared)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT	10</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; COUNT;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum = sum + i;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，sum为shared属性，而i的属性不会改变，仍然只能为私有。这里的效果和加上default(shared)是一样的。如果使用default(none)，那么编译会报错“没有给sum指定数据共享属性”，不会为变量i报错，因为i是有明确的含义的，只能为私有。</p>
<h3 id="copyin"><a href="#copyin" class="headerlink" title="copyin"></a>copyin</h3><p>copyin子句用于将主线程中threadprivate变量的值拷贝到执行并行区域的各个线程的threadprivate变量中，从而使得team内的子线程都拥有和主线程同样的初始值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> A = <span class="number">100</span>;  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(A)  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        A++;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,omp_get_thread_num(), i, A);   <span class="comment">// #1  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A); <span class="comment">// #2  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for copyin(A)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        A++;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,omp_get_thread_num(), i, A);   <span class="comment">// #1  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A); <span class="comment">// #2  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>输出如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Thread ID: 0, 0: 101</span><br><span class="line">Thread ID: 0, 1: 102</span><br><span class="line">Thread ID: 0, 2: 103</span><br><span class="line">Thread ID: 3, 8: 101</span><br><span class="line">Thread ID: 3, 9: 102</span><br><span class="line">Thread ID: 1, 3: 101</span><br><span class="line">Thread ID: 1, 4: 102</span><br><span class="line">Thread ID: 1, 5: 103</span><br><span class="line">Thread ID: 2, 6: 101</span><br><span class="line">Thread ID: 2, 7: 102</span><br><span class="line">Global A: 103</span><br><span class="line"></span><br><span class="line">Thread ID: 2, 6: 104</span><br><span class="line">Thread ID: 2, 7: 105</span><br><span class="line">Thread ID: 1, 3: 104</span><br><span class="line">Thread ID: 1, 4: 105</span><br><span class="line">Thread ID: 1, 5: 106</span><br><span class="line">Thread ID: 3, 8: 104</span><br><span class="line">Thread ID: 3, 9: 105</span><br><span class="line">Thread ID: 0, 0: 104</span><br><span class="line">Thread ID: 0, 1: 105</span><br><span class="line">Thread ID: 0, 2: 106</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>运行此程序，得到的结果和不使用copyin的结果是不一样的。不使用copyin的情况下，进入第二个并行区域的时候，不同线程的私有副本A的初始值是不一样的，这里使用了copyin之后，发现所有的线程的初始值都使用主线程的值初始化，然后继续运算。</p>
<p>为了更好的理解copyin，分析下面的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> A = <span class="number">100</span>;  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(A)  </span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Initial A = %d\n&quot;</span>, A);</span><br><span class="line">		A = omp_get_thread_num();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel copyin(A)			<span class="comment">// copyin</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Initial A = %d\n&quot;</span>, A);</span><br><span class="line">		A = omp_get_thread_num();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel				<span class="comment">// Will not copy, to check the result.</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Initial A = %d\n&quot;</span>, A);</span><br><span class="line">		A = omp_get_thread_num();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br></pre></td></tr></table></figure></p>
<p>得到输出如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Initial A = 100</span><br><span class="line">Initial A = 100</span><br><span class="line">Initial A = 100</span><br><span class="line">Initial A = 100</span><br><span class="line">Global A: 0</span><br><span class="line">Initial A = 0</span><br><span class="line">Initial A = 0</span><br><span class="line">Initial A = 0</span><br><span class="line">Initial A = 0</span><br><span class="line">Global A: 0</span><br><span class="line">Initial A = 0</span><br><span class="line">Initial A = 3</span><br><span class="line">Initial A = 2</span><br><span class="line">Initial A = 1</span><br><span class="line">Global A: 1</span><br></pre></td></tr></table></figure></p>
<p>简单理解，在使用了copyin后，所有的线程的threadprivate类型的副本变量都会与主线程的副本变量进行一次“同步”。</p>
<p>另外，copyin中的参数必须被声明成threadprivate的，对于类类型的变量，必须带有明确的拷贝赋值操作符。而且，对于第一个并行区域，是默认含有copyin的功能的（比如上面的例子的前面的四个A的输出都是100）。copyin的一个可能需要用到的情况是，比如程序中有多个并行区域，每个线程希望保存一个私有的全局变量，但是其中某一个并行区域执行前，希望与主线程的值相同，就可以利用copyin进行赋值。</p>
<h3 id="copyprivate"><a href="#copyprivate" class="headerlink" title="copyprivate"></a>copyprivate</h3><p>copyprivate子句用于将线程私有副本变量的值从一个线程广播到执行同一并行区域的其他线程的同一变量。</p>
<p>说明：copyprivate只能用于single指令的子句中，在一个single块的结尾处完成广播操作。copyprivate只能用于private/firstprivate或threadprivate修饰的变量。</p>
<p>根据下面的程序，可以理解copyprivate的使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;omp.h&gt;  </span><br><span class="line">int A = 100;  </span><br><span class="line">#pragma omp threadprivate(A)  </span><br><span class="line"> </span><br><span class="line">int main(int argc, _TCHAR* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">	int B = 100;</span><br><span class="line">	int C = 1000;</span><br><span class="line">#pragma omp parallel firstprivate(B) copyin(A)	// copyin(A) can be ignored!</span><br><span class="line">	&#123;</span><br><span class="line">#pragma omp single copyprivate(A) copyprivate(B)// copyprivate(C)	// C is shared, cannot use copyprivate!</span><br><span class="line">		&#123;</span><br><span class="line">			A = 10;</span><br><span class="line">			B = 20;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Initial A = %d\n&quot;, A);		// 10 for all threads</span><br><span class="line">		printf(&quot;Initial B = %d\n&quot;, B);		// 20 for all threads</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	printf(&quot;Global A: %d\n&quot;,A);		// 10</span><br><span class="line">	printf(&quot;Global A: %d\n&quot;,B);		// 100. B is still 100! Will not be affected here!</span><br><span class="line"> </span><br><span class="line">	return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="reduction子句"><a href="#reduction子句" class="headerlink" title="reduction子句"></a>reduction子句</h2><p>reduction的作用： A private copy for each list variable is created for each thread. At the end of the reduction, the reduction variable is applied to all private copies of the shared variable, and the final result is written to the global shared variable.</p>
<p>reduction子句为变量指定一个操作符，每个线程都会创建reduction变量的私有拷贝，在OpenMP区域结束处，将使用各个线程的私有拷贝的值通过制定的操作符进行迭代运算，并赋值给原来的变量。</p>
<p>reduction的语法为recutioin(operator:list)和其他的数据属性子句不一样的是多了一个operator参数。由于最后会进行迭代运算，所以不是所有的运算符都能作为reduction的参数，而且，迭代运算需要一个初始值，不是所有的操作符需要有相同的初始值，一般而言，常见的reduction操作符的初始值为：+(0),*(1),-(0),&amp;~(0),|(0),^(0),&amp;&amp;(1),||(0)，当然，这不是必须的，比如叠加运算的初始值，可以是任意值，只是表达的含义不一样而已，但是对于某些操作符，有些初始值是没有什么意义的，比如乘法迭代如果初始值为0没有什么意义，结果肯定是0了！</p>
<p>典型的使用reduction的例子，就是迭加（求和）操作了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT 10</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">100</span>;		<span class="comment">// Assign an initial value.</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+:sum)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; COUNT; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>,sum);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子就是对0到COUNT进行求和，由于初始值为100，所以还会加一个100，如果只是为了求和，只需要初始值为0即可。使用reduction可以避免数据竞争的发生，将上面例子的COUNT修改为一个比较大的值，如果不使用reduction，会发现有数据竞争导致结果不一致，使用reduction后，每次都能得到正确的结果。</p>
<p>reduction的使用是比较简单的，主要还是需要理解上面说到的“初始值”，第一个理解是这里的100这样的初始值，这是并行区域外的初始值，会在最后计算到迭代结果中，那么还有一个隐含的初始值，就是我们知道，使用了reduction，那么每个线程都会构造一个reduction变量的线程副本，那么其值为多少呢？从上面的例子可以看出，其初始值就是0，如果初始值都是100，那么结果应该是100会被加线程数目的次数。初始值的确定方法就是上面提到的：+(0),*(1),-(0),&amp;~(0),|(0),^(0),&amp;&amp;(1),||(0)。</p>
<p>所以，理解reduction的工作过程：</p>
<ol>
<li>进入并行区域后，team内的每个新的线程都会对reduction变量构造一个副本，比如上面的例子，假设有四个线程，那么，进入并行区域的初始化值分别为：sum0=100，sum1 = sum2 = sum3 = 0。为何sum0为100呢？因为主线程不是一个新的线程，所以不需要再为主线程构造一个副本（没有找到官方这样的说法，但是从理解上，应该就是这样工作的，只会有一个线程使用到并行区域外的初始值，其余的都是0）。</li>
<li>每个线程使用自己的副本变量完成计算。</li>
<li>在退出并行区域时，对所有的线程的副本变量使用指定的操作符进行迭代操作，对于上面的例子，即sum’ = sum0’+sum1’+sum2’+sum3’.</li>
<li>将迭代的结果赋值给原来的变量（sum），sum=sum’.</li>
</ol>
<p>注意：</p>
<ul>
<li>reduction只能用于标量类型（int、float等等）；</li>
<li>reduction只用于一个区域构造或者工作共享构造的结构中，并且，在这个区域中，reduction的变量只能被用于类似如下的语句：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = x op expr </span><br><span class="line">x = expr op x (except subtraction) </span><br><span class="line">x binop = expr </span><br><span class="line">x++ </span><br><span class="line">++x </span><br><span class="line">x-- </span><br><span class="line">--x</span><br></pre></td></tr></table></figure>
<p>说明：经过测试，其实不符合这一规则的时候，编译运行都不会有问题，有些甚至也是可以解释清楚为什么结果是这样的，但是无论如何，一般使用reduction的时候，都是一些迭代的情况，语义应该是很清楚的情况。看下面的一个“错误”的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT 10</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">100</span>;		<span class="comment">// Assign an initial value.</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+:sum)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; COUNT; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		sum += i;</span><br><span class="line">		sum = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>,sum);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为104（4核机器）。这个例子，<code>sum=1;</code>这个表达式是不应该出现的，但是如果就这么写，编译运行都没问题，而且，这个结果甚至也算是预料中的。每一个线程计算结束后，其sum的值都是1，四个线程，然后初始值是100，所以最后结果是104。:) 无论如何，即使可以解释得通，相信也没有这样使用的场合，至少，不要依赖于这样的实现的结果。从这个错误的例子，反过来，我发现上面的关于”理解reduction的工作过程“似乎不太完全正确，其中第一步，进入并行区域后，初始值为”sum0=100,sum1 = sum2 = sum3 = 0“，如果这样，只是一个初始值，那么计算后，在这个例子里，所有线程的sum都是1，结果应该为4才对。所以看来，实际的理解应该是，主线程也会创建一个副本变量，其初始值也为0，在最后迭代的时候，是用sum原来的值和每个线程的副本进行计算。过程大概如下：</p>
<ol>
<li>sum=100</li>
<li>进入并行区域，创建4个线程的4个副本：sum0=sum1=sum2=sum3=0;</li>
<li>计算完成后，得到sum0’,sum1’,sum2’,sum3’</li>
<li>计算sum，sum=sum op sum 0‘ op sum1’ op sum2‘ op sum3’。</li>
</ol>
<p>总之，具体编译器是如何实现的并不重要，关键是理解reduction是如何工作的。</p>
<h1 id="OpenMP参考文档"><a href="#OpenMP参考文档" class="headerlink" title="OpenMP参考文档"></a>OpenMP参考文档</h1><p><img src="/img/OpenMPRef-5.0-111802-web_Page1.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page2.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page3.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page4.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page5.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page6.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page7.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page8.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page9.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page10.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page11.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page12.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/06/%E6%9C%89%E8%B6%A3%E7%9A%84cache%E6%B5%8B%E9%87%8F%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/06/%E6%9C%89%E8%B6%A3%E7%9A%84cache%E6%B5%8B%E9%87%8F%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">有趣的cache测量数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-06 13:13:00" itemprop="dateCreated datePublished" datetime="2021-12-06T13:13:00+08:00">2021-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-17 17:09:01" itemprop="dateModified" datetime="2021-12-17T17:09:01+08:00">2021-12-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>首先，我们都知道现在的 CPU 多核技术，都会有几级缓存，老的 CPU 会有两级内存（L1 和 L2），新的CPU会有三级内存（L1，L2，L3 ），如下图所示：<br><img src="/img/20211206131357.jpg" alt=""></p>
<p>其中：</p>
<ul>
<li>L1 缓存分成两种，一种是指令缓存，一种是数据缓存。L2 缓存和 L3 缓存不分指令和数据。</li>
<li>L1 和 L2 缓存在每一个 CPU 核中，L3 则是所有 CPU 核心共享的内存。</li>
<li>L1、L2、L3 的越离CPU近就越小，速度也越快，越离 CPU 远，速度也越慢。</li>
</ul>
<p>再往后面就是内存，内存的后面就是硬盘。我们来看一些他们的速度：</p>
<ul>
<li>L1 的存取速度：4 个CPU时钟周期</li>
<li>L2 的存取速度：11 个CPU时钟周期</li>
<li>L3 的存取速度：39 个CPU时钟周期</li>
<li>RAM内存的存取速度 ：107 个CPU时钟周期</li>
</ul>
<p>我们可以看到，L1 的速度是 RAM 的 27 倍，但是 L1/L2 的大小基本上也就是 KB 级别的，L3 会是 MB 级别的。例如：Intel Core i7-8700K ，是一个 6 核的 CPU，每核上的 L1 是 64KB（数据和指令各 32KB），L2 是 256K，L3 有 2MB（我的苹果电脑是 Intel Core i9-8950HK，和Core i7-8700K 的Cache大小一样）。</p>
<p>我们的数据就从内存向上，先到 L3，再到 L2，再到 L1，最后到寄存器进行 CPU 计算。为什么会设计成三层？这里有下面几个方面的考虑：</p>
<ul>
<li>一个方面是物理速度，如果要更大的容量就需要更多的晶体管，除了芯片的体积会变大，更重要的是大量的晶体管会导致速度下降，因为访问速度和要访问的晶体管所在的位置成反比，也就是当信号路径变长时，通信速度会变慢。这部分是物理问题。</li>
<li>另外一个问题是，多核技术中，数据的状态需要在多个CPU中进行同步，并且，我们可以看到，cache 和RAM 的速度差距太大，所以，多级不同尺寸的缓存有利于提高整体的性能。</li>
</ul>
<p>这个世界永远是平衡的，一面变得有多光鲜，另一面也会变得有多黑暗。建立这么多级的缓存，一定就会引入其它的问题，这里有两个比较重要的问题，一个是比较简单的缓存的命中率的问题。另一个是比较复杂的缓存更新的一致性问题。尤其是第二个问题，在多核技术下，这就很像分布式的系统了，要对多个地方进行更新。</p>
<h1 id="缓存的命中"><a href="#缓存的命中" class="headerlink" title="缓存的命中"></a>缓存的命中</h1><p>在说明这两个问题之前。我们需要要解一个术语 Cache Line。缓存基本上来说就是把后面的数据加载到离自己近的地方，对于 CPU 来说，它是不会一个字节一个字节的加载的，因为这非常没有效率，一般来说都是要一块一块的加载的，对于这样的一块一块的数据单位，术语叫 Cache Line，</p>
<p>一般来说，一个主流的 CPU 的 Cache Line 是 64 Bytes（也有的CPU用32Bytes和128Bytes），64 Bytes也就是 16 个 32 位的整型，这就是 CPU 从内存中捞数据上来的最小数据单位。</p>
<p>比如：Cache Line是最小单位（64Bytes），所以先把 Cache 分布多个 Cache Line，比如：L1 有 32KB，那么，32KB/64B = 512 个 Cache Line。</p>
<p>一方面，缓存需要把内存里的数据放到放进来，英文叫 CPU Associativity。Cache 的数据放置的策略决定了内存中的数据块会拷贝到 CPU Cache 中的哪个位置上，因为 Cache 的大小远远小于内存，所以，需要有一种地址关联的算法，能够让内存中的数据可以被映射到 Cache 中来。这个有点像内存地址从逻辑地址向物理地址映射的方法，但不完全一样。</p>
<p>基本上来说，我们会有如下的一些方法。</p>
<ul>
<li>一种方法是，任何一个内存地址的数据可以被缓存在任何一个 Cache Line 里，这种方法是最灵活的，但是，如果我们要知道一个内存是否存在于 Cache 中，我们就需要进行 O(n) 复杂度的 Cache 遍历，这是很没有效率的。</li>
<li>另一种方法，为了降低缓存搜索算法，我们需要使用像Hash Table这样的数据结构，最简单的hash table就是做求模运算，比如：我们的 L1 Cache 有 512 个 Cache Line，那么，公式：（内存地址 mod 512）* 64 就可以直接找到所在的Cache地址的偏移了。但是，这样的方式需要我们的程序对内存地址的访问要非常地平均，不然冲突就会非常严重。这成了一种非常理想的情况了。</li>
</ul>
<p>为了避免上述的两种方案的问题，于是就要容忍一定的hash冲突，也就出现了 N-Way 关联。也就是把连续的N 个 Cache Line 绑成一组，然后，先把找到相关的组，然后再在这个组内找到相关的 Cache Line。这叫 Set Associativity。如下图所示。<br><img src="/img/20211206131502.jpg" alt=""></p>
<p>对于 N-Way 组关联，可能有点不好理解，这里个例子，并多说一些细节（不然后面的代码你会不能理解），Intel 大多数处理器的 L1 Cache 都是 32KB，8-Way 组相联，Cache Line 是 64 Bytes。这意味着，</p>
<ul>
<li>32KB的可以分成，32KB / 64 = 512 条 Cache Line。</li>
<li>因为有8 Way，于是会每一Way 有 512 / 8 = 64 条 Cache Line。</li>
<li>于是每一路就有 64 x 64 = 4096 Byts 的内存。</li>
</ul>
<p>为了方便索引内存地址，</p>
<ul>
<li>Tag：每条 Cache Line 前都会有一个独立分配的 24 bits来存的 tag，其就是内存地址的前24bits</li>
<li>Index：内存地址后续的 6 个 bits 则是在这一 Way 的是Cache Line 索引，2^6 = 64 刚好可以索引64条Cache Line</li>
<li>Offset：再往后的 6bits 用于表示在 Cache Line 里的偏移量</li>
</ul>
<p>如下图所示：（图片来自《Cache: a place for concealment and safekeeping》）</p>
<p>当拿到一个内存地址的时候，先拿出中间的 6bits 来，找到是哪组。<br><img src="/img/20211206131553.jpg" alt=""></p>
<p>然后，在这一个 8 组的 cache line 中，再进行 O(n) n=8 的遍历，主是要匹配前 24bits 的 tag。如果匹配中了，就算命中，如果没有匹配到，那就是 cache miss，如果是读操作，就需要进向后面的缓存进行访问了。</p>
<p>L2/L3 同样是这样的算法。而淘汰算法有两种，一种是随机一种是 LRU。现在一般都是以 LRU 的算法（通过增加一个访问计数器来实现）</p>
<p><img src="/img/20211206131605.jpg" alt=""></p>
<p>这也意味着：</p>
<ul>
<li>L1 Cache 可映射 36bits 的内存地址，一共 2^36 = 64GB 的内存</li>
<li>当 CPU 要访问一个内存的时候，通过这个内存中间的 6bits 定位是哪个 set，通过前 24bits 定位相应的Cache Line。</li>
<li>就像一个 hash Table 的数据结构一样，先是 O(1)的索引，然后进入冲突搜索。</li>
<li>因为中间的 6bits 决定了一个同一个 set，所以，对于一段连续的内存来说，每隔 4096 的内存会被放在同一个组内，导致缓存冲突。</li>
</ul>
<p>此外，当有数据没有命中缓存的时候，CPU 就会以最小为 Cache Line 的单元向内存更新数据。当然，CPU 并不一定只是更新 64Bytes，因为访问主存实在是太慢了，所以，一般都会多更新一些。好的 CPU 会有一些预测的技术，如果找到一种 pattern 的话，就会预先加载更多的内存，包括指令也可以预加载。</p>
<p>这叫 Prefetching 技术 （参看，Wikipedia 的 Cache Prefetching 和 纽约州立大学的 Memory Prefetching）。比如，你在for-loop访问一个连续的数组，你的步长是一个固定的数，内存就可以做到prefetching。（注：指令也是以预加载的方式执行）</p>
<p>了解这些细节，会有利于我们知道在什么情况下有可以导致缓存的失效。</p>
<h1 id="缓存的一致性"><a href="#缓存的一致性" class="headerlink" title="缓存的一致性"></a>缓存的一致性</h1><p>对于主流的 CPU 来说，缓存的写操作基本上是两种策略，</p>
<ul>
<li>一种是 Write Back，写操作只要在 cache 上，然后再 flush 到内存上。</li>
<li>一种是 Write Through，写操作同时写到 cache 和内存上。</li>
</ul>
<p>为了提高写的性能，一般来说，主流的 CPU（如：Intel Core i7/i9）采用的是 Write Back 的策略，因为直接写内存实在是太慢了。</p>
<p>好了，现在问题来了，如果有一个数据 x 在 CPU 第 0 核的缓存上被更新了，那么其它 CPU 核上对于这个数据 x 的值也要被更新，这就是缓存一致性的问题。（当然，对于我们上层的程序我们不用关心 CPU 多个核的缓存是怎么同步的，这对上层的代码来说都是透明的）</p>
<p>一般来说，在 CPU 硬件上，会有两种方法来解决这个问题。</p>
<ul>
<li>Directory 协议。这种方法的典型实现是要设计一个集中式控制器，它是主存储器控制器的一部分。其中有一个目录存储在主存储器中，其中包含有关各种本地缓存内容的全局状态信息。当单个 CPU Cache 发出读写请求时，这个集中式控制器会检查并发出必要的命令，以在主存和 CPU Cache之间或在 CPU Cache自身之间进行数据同步和传输。</li>
<li>Snoopy 协议。这种协议更像是一种数据通知的总线型的技术。CPU Cache 通过这个协议可以识别其它Cache上的数据状态。如果有数据共享的话，可以通过广播机制将共享数据的状态通知给其它 CPU Cache。这个协议要求每个 CPU Cache 都可以窥探数据事件的通知并做出相应的反应。如下图所示，有一个 Snoopy Bus 的总线。</li>
</ul>
<p><img src="/img/20211206131703.jpg" alt=""></p>
<p>因为 Directory 协议是一个中心式的，会有性能瓶颈，而且会增加整体设计的复杂度。而 Snoopy 协议更像是微服务+消息通讯，所以，现在基本都是使用 Snoopy 的总线的设计。</p>
<p>这里，我想多写一些细节，因为这种微观的东西，让人不自然地就会跟分布式系统关联起来，在分布式系统中我们一般用 Paxos/Raft 这样的分布式一致性的算法。</p>
<p>而在 CPU 的微观世界里，则不必使用这样的算法，原因是因为 CPU 的多个核的硬件不必考虑网络会断会延迟的问题。所以，CPU 的多核心缓存间的同步的核心就是要管理好数据的状态就好了。</p>
<p>这里介绍几个状态协议，先从最简单的开始，MESI 协议，这个协议跟那个著名的足球运动员梅西没什么关系，其主要表示缓存数据有四个状态：Modified（已修改）, Exclusive（独占的）,Shared（共享的），Invalid（无效的）。</p>
<p>这些状态的状态机如下所示（有点复杂，你可以先不看，这个图就是想告诉你状态控制有多复杂）：</p>
<p><img src="/img/20211206131802.jpg" alt=""></p>
<p>下面是个示例</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>当前操作</th>
<th>CPU0</th>
<th>CPU1</th>
<th>Memory</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1) CPU0 read(x)</td>
<td>x=1 (E)</td>
<td></td>
<td>x=1</td>
<td>只有一个CPU有 x 变量， 所以，状态是 Exclusive</td>
</tr>
<tr>
<td>2) CPU1 read(x)</td>
<td>x=1 (S)</td>
<td>x=1(S)</td>
<td>x=1</td>
<td>有两个CPU都读取 x 变量， 所以状态变成 Shared</td>
</tr>
<tr>
<td>3) CPU0 write(x,9)</td>
<td>x=9 (M)</td>
<td>x=1(I)</td>
<td>x=1</td>
<td>变量改变，在CPU0中状态 变成 Modified，在CPU1中 状态变成 Invalid</td>
</tr>
<tr>
<td>4) 变量 x 写回内存</td>
<td>x=9 (M)</td>
<td>X=1(I)</td>
<td>x=9</td>
<td>目前的状态不变</td>
</tr>
<tr>
<td>5) CPU1 read(x)</td>
<td>x=9 (S)</td>
<td>x=9(S)</td>
<td>x=9</td>
<td>变量同步到所有的Cache中， 状态回到Shared</td>
</tr>
</tbody>
</table>
</div>
<p>MESI 这种协议在数据更新后，会标记其它共享的 CPU 缓存的数据拷贝为 Invalid 状态，然后当其它 CPU 再次read 的时候，就会出现 cache miss 的问题，此时再从内存中更新数据。从内存中更新数据意味着 20 倍速度的降低。</p>
<p>我们能不能直接从我隔壁的 CPU 缓存中更新？是的，这就可以增加很多速度了，但是状态控制也就变麻烦了。还需要多来一个状态：Owner(宿主)，用于标记，我是更新数据的源。于是，出现了 MOESI 协议</p>
<p>MOESI 协议的状态机和演示示例我就不贴了（有兴趣可以上Berkeley上看看相关的课件），我们只需要理解MOESI协议允许 CPU Cache 间同步数据，于是也降低了对内存的操作，性能是非常大的提升，但是控制逻辑也非常复杂。</p>
<p>顺便说一下，与 MOESI 协议类似的一个协议是 MESIF，其中的 F 是 Forward，同样是把更新过的数据转发给别的 CPU Cache 但是，MOESI 中的 Owner 状态 和MESIF 中的 Forward 状态有一个非常大的不一样—— Owner 状态下的数据是 dirty 的，还没有写回内存，Forward 状态下的数据是 clean的，可以丢弃而不用另行通知。</p>
<p>需要说明的是，AMD 用 MOESI，Intel 用 MESIF。所以，F 状态主要是针对 CPU L3 Cache 设计的（前面我们说过，L3 是所有 CPU 核心共享的）。（相关的比较可以参看StackOverlow上这个问题的答案）</p>
<h1 id="程序性能"><a href="#程序性能" class="headerlink" title="程序性能"></a>程序性能</h1><p>了解了我们上面的这些东西后，我们来看一下对于程序的影响。</p>
<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><p>首先，假设我们有一个64M长的数组，设想一下下面的两个循环：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *arr = new <span class="type">int</span>[LEN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN; i += <span class="number">2</span>) arr[i] *= i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN; i += <span class="number">8</span>) arr[i] *= i;</span><br></pre></td></tr></table></figure><br>按我们的想法来看，第二个循环要比第一个循环少4倍的计算量，其应该也是要快4倍的。但实际跑下来并不是，在我的机器上，第一个循环需要 127 毫秒，第二个循环则需要 121 毫秒，相差无几。</p>
<p>这里最主要的原因就是 Cache Line，因为 CPU 会以一个 Cache Line 64Bytes 最小时单位加载，也就是 16 个 32bits 的整型，所以，无论你步长是 2 还是 8，都差不多。而后面的乘法其实是不耗 CPU 时间的。</p>
<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><p>我们再来看一个与缓存命中率有关的代码，我们以一定的步长increment 来访问一个连续的数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j += increment) &#123;</span><br><span class="line">        memory[j] += j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们测试一下，在下表中， 表头是步长，也就是每次跳多少个整数，而纵向是这个数组可以跳几次（你可以理解为要几条 Cache Line），于是表中的任何一项代表了这个数组有多少，而且步长是多少。</p>
<p>比如：横轴是 512，纵轴是4，意思是，这个数组有 4*512 = 2048 个长度，访问时按512步长访问，也就是访问其中的这几项：[0, 512, 1024, 1536] 这四项。</p>
<p>表中同的项是，是循环 1000 万次的时间，单位是“微秒”（除以1000后是毫秒）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">| count |   1    |   16  |  512  | 1024  |</span><br><span class="line">------------------------------------------</span><br><span class="line">|     1 |  17539 | 16726 | 15143 | 14477 |</span><br><span class="line">|     2 |  15420 | 14648 | 13552 | 13343 |</span><br><span class="line">|     3 |  14716 | 14463 | 15086 | 17509 |</span><br><span class="line">|     4 |  18976 | 18829 | 18961 | 21645 |</span><br><span class="line">|     5 |  23693 | 23436 | 74349 | 29796 |</span><br><span class="line">|     6 |  23264 | 23707 | 27005 | 44103 |</span><br><span class="line">|     7 |  28574 | 28979 | 33169 | 58759 |</span><br><span class="line">|     8 |  33155 | 34405 | 39339 | 65182 |</span><br><span class="line">|     9 |  37088 | 37788 | 49863 |156745 |</span><br><span class="line">|    10 |  41543 | 42103 | 58533 |215278 |</span><br><span class="line">|    11 |  47638 | 50329 | 66620 |335603 |</span><br><span class="line">|    12 |  49759 | 51228 | 75087 |305075 |</span><br><span class="line">|    13 |  53938 | 53924 | 77790 |366879 |</span><br><span class="line">|    14 |  58422 | 59565 | 90501 |466368 |</span><br><span class="line">|    15 |  62161 | 64129 | 90814 |525780 |</span><br><span class="line">|    16 |  67061 | 66663 | 98734 |440558 |</span><br><span class="line">|    17 |  71132 | 69753 |171203 |506631 |</span><br><span class="line">|    18 |  74102 | 73130 |293947 |550920 |</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，从 [9，1024] 以后，时间显著上升。包括 [17，512] 和 [18,512] 也显著上升。这是因为，我机器的 L1 Cache 是 32KB, 8 Way 的，前面说过，8 Way 的有 64 组，每组 8 个 Cache Line，当 for-loop步长超过 1024 个整型，也就是正好 4096 Bytes 时，也就是导致内存地址的变化是变化在高位的 24bits 上，</p>
<p>而低位的1 2bits 变化不大，尤其是中间6bits没有变化，导致全部命中同一组 set，导致大量的 cache 冲突，导致性能下降，时间上升。而 [16, 512]也是一样的，其中的几步开始导致L1 Cache开始冲突失效。</p>
<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><p>接下来，我们再来看个示例。下面是一个二维数组的两种遍历方式，一个逐行遍历，一个是逐列遍历，这两种方式在理论上来说，寻址和计算量都是一样的，执行时间应该也是一样的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> row = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> col = <span class="number">512</span></span><br><span class="line"><span class="type">int</span> matrix[row][col];</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐行遍历</span></span><br><span class="line"><span class="type">int</span> sum_row=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> _r=<span class="number">0</span>; _r&lt;row; _r++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> _c=<span class="number">0</span>; _c&lt;col; _c++)&#123;</span><br><span class="line">        sum_row += matrix[_r][_c];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐列遍历</span></span><br><span class="line"><span class="type">int</span> sum_col=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> _c=<span class="number">0</span>; _c&lt;col; _c++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> _r=<span class="number">0</span>; _r&lt;row; _r++)&#123;</span><br><span class="line">        sum_col += matrix[_r][_c];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，并不是，在我的机器上，得到下面的结果。</p>
<ul>
<li>逐行遍历：0.081ms</li>
<li>逐列遍历：1.069ms</li>
</ul>
<p>执行时间有十几倍的差距。其中的原因，就是逐列遍历对于 CPU Cache 的运作方式并不友好，所以，付出巨大的代价。</p>
<h2 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h2><p>接下来，我们来看一下多核下的性能问题，参看如下的代码。两个线程在操作一个数组的两个不同的元素（无需加锁），线程循环1000万次，做加法操作。在下面的代码中，我高亮了一行，就是p2指针，要么是p[1]，或是 p[30]，理论上来说，无论访问哪两个数组元素，都应该是一样的执行时间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fn</span> <span class="params">(<span class="type">int</span>* data)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>; ++i)</span><br><span class="line">        *data += rand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p1 = &amp;p[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> *p2 = &amp;p[<span class="number">1</span>]; <span class="comment">// int *p2 = &amp;p[30];</span></span><br><span class="line"></span><br><span class="line">thread <span class="title function_">t1</span><span class="params">(fn, p1)</span>;</span><br><span class="line">thread <span class="title function_">t2</span><span class="params">(fn, p2)</span>;</span><br></pre></td></tr></table></figure></p>
<p>然而，并不是，在我的机器上执行下来的结果是：</p>
<ul>
<li>对于 p[0] 和 p[1] ：560ms</li>
<li>对于 p[0] 和 p[30]：104ms</li>
</ul>
<p>这是因为 p[0] 和 p[1] 在同一条 Cache Line 上，而 p[0] 和 p[30] 则不可能在同一条Cache Line 上 ，CPU 的缓存最小的更新单位是 Cache Line，所以，这导致虽然两个线程在写不同的数据，但是因为这两个数据在同一条 Cache Line 上，就会导致缓存需要不断进在两个 CPU 的 L1/L2 中进行同步，从而导致了 5 倍的时间差异。</p>
<h2 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h2><p>接下来，我们再来看一下另外一段代码：我们想统计一下一个数组中的奇数个数，但是这个数组太大了，我们希望可以用多线程来完成这个统计。下面的代码中，我们为每一个线程传入一个 id ，然后通过这个 id 来完成对应数组段的统计任务。这样可以加快整个处理速度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> total_size = <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">//数组长度</span></span><br><span class="line"><span class="type">int</span>* test_data = new test_data[total_size]; <span class="comment">//数组</span></span><br><span class="line"><span class="type">int</span> nthread = <span class="number">6</span>; <span class="comment">//线程数（因为我的机器是6核的）</span></span><br><span class="line"><span class="type">int</span> result[nthread]; <span class="comment">//收集结果的数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_func</span> <span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    result[id] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chunk_size = total_size / nthread + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> start = id * chunk_size;</span><br><span class="line">    <span class="type">int</span> end = min(start + chunk_size, total_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = start; i &lt; end; ++i ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (test_data[i] % <span class="number">2</span> != <span class="number">0</span> ) ++result[id];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，在执行过程中，你会发现，6 个线程居然跑不过 1 个线程。因为根据上面的例子你知道 result[] 这个数组中的数据在一个 Cache Line 中，所以，所有的线程都会对这个 Cache Line 进行写操作，导致所有的线程都在不断地重新同步 result[] 所在的 Cache Line，所以，导致 6 个线程还跑不过一个线程的结果。这叫 False Sharing。</p>
<p>优化也很简单，使用一个线程内的变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread_func</span> <span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    result[id] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chunk_size = total_size / nthread + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> start = id * chunk_size;</span><br><span class="line">    <span class="type">int</span> end = min(start + chunk_size, total_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>; <span class="comment">//使用临时变量，没有cache line的同步了</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = start; i &lt; end; ++i ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (test_data[i] % <span class="number">2</span> != <span class="number">0</span> ) ++c;</span><br><span class="line">   &#125;</span><br><span class="line">    result[id] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们把两个程序分别在 1 到 32 个线程上跑一下，得出的结果画一张图如下所示（横轴是线程数，纵轴是完成统的时间，单位是微秒）：<br><img src="/img/20211206132118.jpg" alt=""></p>
<p>上图中，我们可以看到，灰色的曲线就是第一种方法，橙色的就是第二种（用局部变量的）方法。当只有一个线程的时候，两个方法相当，基本没有什么差别，但是在线程数增加的时候的时候，你会发现，第二种方法的性能提高的非常快。直到到达 6 个线程的时候，开始变得稳定（前面说过，我的 CPU 是6核的）。</p>
<p>而第一种方法无论加多少线程也没有办法超过第二种方法。因为第一种方法不是 CPU Cache 友好的。也就是说，第二种方法，只要我的 CPU 核数足够多，就可以做到线性的性能扩展，让每一个 CPU 核都跑起来，而第一种则不能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/04/%E8%A7%A3%E8%AF%BBraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/04/%E8%A7%A3%E8%AF%BBraft/" class="post-title-link" itemprop="url">解读Raft</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-04 00:33:00" itemprop="dateCreated datePublished" datetime="2021-12-04T00:33:00+08:00">2021-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-06 17:01:45" itemprop="dateModified" datetime="2022-01-06T17:01:45+08:00">2022-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Raft-是什么？"><a href="#Raft-是什么？" class="headerlink" title="Raft 是什么？"></a>Raft 是什么？</h2><p>Raft is a consensus algorithm for managing a replicated log. It produces a result equivalent to (multi-)Paxos, and it is as efficient as Paxos, but its structure is different from Paxos; this makes Raft more understandable than Paxos and also provides a better foundation for building practical systems.</p>
<p>—《In Search of an Understandable Consensus Algorithm》</p>
<p>在分布式系统中，为了消除单点提高系统可用性，通常会使用副本来进行容错，但这会带来另一个问题，即如何保证多个副本之间的一致性？</p>
<p>这里我们只讨论强一致性，即线性一致性。弱一致性涵盖的范围较广，涉及根据实际场景进行诸多取舍，不在 Raft 系列的讨论目标范围内。</p>
<p>所谓的强一致性（线性一致性）并不是指集群中所有节点在任一时刻的状态必须完全一致，而是指一个目标，即让一个分布式系统看起来只有一个数据副本，并且读写操作都是原子的，这样应用层就可以忽略系统底层多个数据副本间的同步问题。也就是说，我们可以将一个强一致性分布式系统当成一个整体，一旦某个客户端成功的执行了写操作，那么所有客户端都一定能读出刚刚写入的值。即使发生网络分区故障，或者少部分节点发生异常，整个集群依然能够像单机一样提供服务。</p>
<p>共识算法（Consensus Algorithm）就是用来做这个事情的，它保证即使在小部分（≤ (N-1)/2）节点故障的情况下，系统仍然能正常对外提供服务。共识算法通常基于状态复制机（Replicated State Machine）模型，也就是所有节点从同一个 state 出发，经过同样的操作 log，最终达到一致的 state。<br><img src="/img/715f38a55fae4ef6bed7bb7cfd134825_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>共识算法是构建强一致性分布式系统的基石，Paxos 是共识算法的代表，而 Raft 则是其作者在博士期间研究 Paxos 时提出的一个变种，主要优点是容易理解、易于实现，甚至关键的部分都在论文中给出了伪代码实现。</p>
<h2 id="谁在使用-Raft"><a href="#谁在使用-Raft" class="headerlink" title="谁在使用 Raft"></a>谁在使用 Raft</h2><p>采用 Raft 的系统最著名的当属 etcd 了，可以认为 etcd 的核心就是 Raft 算法的实现。作为一个分布式 kv 系统，etcd 使用 Raft 在多节点间进行数据同步，每个节点都拥有全量的状态机数据。我们在学习了 Raft 以后将会深刻理解为什么 etcd 不适合大数据量的存储（for the most critical data）、为什么集群节点数不是越多越好、为什么集群适合部署奇数个节点等问题。</p>
<p>作为一个微服务基础设施，consul 底层使用 Raft 来保证 consul server 之间的数据一致性。在阅读完第六章后，我们会理解为什么 consul 提供了 default、consistent、stale 三种一致性模式（Consistency Modes）、它们各自适用的场景，以及 consul 底层是如何通过改变 Raft 读模型来支撑这些不同的一致性模式的。</p>
<p>TiKV 同样在底层使用了 Raft 算法。虽然都自称是“分布式 kv 存储”，但 TiKV 的使用场景与 etcd 存在区别。其目标是支持 100TB+ 的数据，类似 etcd 的单 Raft 集群肯定无法支撑这个数据量。因此 TiKV 底层使用 Multi Raft，将数据划分为多个 region，每个 region 其实还是一个标准的 Raft 集群，对每个分区的数据实现了多副本高可用。</p>
<p>目前 Raft 在工业界已经开始大放异彩，对于其各类应用场景这里不再赘述，感兴趣的读者可以参考 这里，下方有列出各种语言的大量 Raft 实现。</p>
<h2 id="Raft-基本概念"><a href="#Raft-基本概念" class="headerlink" title="Raft 基本概念"></a>Raft 基本概念</h2><p>Raft 使用 Quorum 机制来实现共识和容错，我们将对 Raft 集群的操作称为提案，每当发起一个提案，必须得到大多数（&gt; N/2）节点的同意才能提交。</p>
<p>这里的“提案”我们可以先狭义地理解为对集群的读写操作，“提交”理解为操作成功。</p>
<p>那么当我们向 Raft 集群发起一系列读写操作时，集群内部究竟发生了什么呢？我们先来概览式地做一个整体了解，接下来再分章节详细介绍每个部分。</p>
<p>首先，Raft 集群必须存在一个主节点（leader），我们作为客户端向集群发起的所有操作都必须经由主节点处理。所以 Raft 核心算法中的第一部分就是选主（Leader election）——没有主节点集群就无法工作，先票选出一个主节点，再考虑其它事情。</p>
<p>其次，主节点需要承载什么工作呢？它会负责接收客户端发过来的操作请求，将操作包装为日志同步给其它节点，在保证大部分节点都同步了本次操作后，就可以安全地给客户端回应响应了。这一部分工作在 Raft 核心算法中叫日志复制（Log replication）。</p>
<p>然后，因为主节点的责任是如此之大，所以节点们在选主的时候一定要谨慎，只有符合条件的节点才可以当选主节点。此外主节点在处理操作日志的时候也一定要谨慎，为了保证集群对外展现的一致性，不可以覆盖或删除前任主节点已经处理成功的操作日志。所谓的“谨慎处理”，其实就是在选主和提交日志的时候进行一些限制，这一部分在 Raft 核心算法中叫安全性（Safety）。</p>
<p>Raft 核心算法其实就是由这三个子问题组成的：选主（Leader election）、日志复制（Log replication）、安全性（Safety）。这三部分共同实现了 Raft 核心的共识和容错机制。</p>
<p>除了核心算法外，Raft 也提供了几个工程实践中必须面对问题的解决方案。</p>
<ul>
<li>第一个是关于日志无限增长的问题。Raft 将操作包装成为了日志，集群每个节点都维护了一个不断增长的日志序列，状态机只有通过重放日志序列来得到。但由于这个日志序列可能会随着时间流逝不断增长，因此我们必须有一些办法来避免无休止的磁盘占用和过久的日志重放。这一部分叫日志压缩（Log compaction）。</li>
<li>第二个是关于集群成员变更的问题。一个 Raft 集群不太可能永远是固定几个节点，总有扩缩容的需求，或是节点宕机需要替换的时候。直接更换集群成员可能会导致严重的脑裂问题。Raft 给出了一种安全变更集群成员的方式。这一部分叫集群成员变更（Cluster membership change）。</li>
</ul>
<p>此外，我们还会额外讨论线性一致性的定义、为什么 Raft 不能与线性一致划等号、如何基于 Raft 实现线性一致，以及在如何保证线性一致的前提下进行读性能优化。</p>
<p>以上便是理论篇内将会讨论到的大部分内容的概要介绍，这里我们对 Raft 已经有了一个宏观上的认识，知道了各个部分大概是什么内容，以及它们之间的关系。接下来我们将会详细讨论 Raft 算法的每个部分。让我们先从第一部分选主开始。</p>
<h1 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h1><h2 id="什么是选主"><a href="#什么是选主" class="headerlink" title="什么是选主"></a>什么是选主</h2><p>选主（Leader election）就是在分布式系统内抉择出一个主节点来负责一些特定的工作。在执行了选主过程后，集群中每个节点都会识别出一个特定的、唯一的节点作为 leader。</p>
<p>我们开发的系统如果遇到选主的需求，通常会直接基于 zookeeper 或 etcd 来做，把这部分的复杂性收敛到第三方系统。然而作为 etcd 基础的 Raft 自身也存在“选主”的概念，这是两个层面的事情：基于 etcd 的选主指的是利用第三方 etcd 让集群对谁做主节点的决策达成一致，技术上来说利用的是 etcd 的一致性状态机、lease 以及 watch 机制，这个事情也可以改用单节点的 MySQL/Redis 来做，只是无法获得高可用性；而 Raft 本身的选主则指的是在 Raft 集群自身内部通过票选、心跳等机制来协调出一个大多数节点认可的主节点作为集群的 leader 去协调所有决策。</p>
<p>当你的系统利用 etcd 来写入谁是主节点的时候，这个决策也在 etcd 内部被它自己集群选出的主节点处理并同步给其它节点。</p>
<h2 id="Raft-为什么要进行选主？"><a href="#Raft-为什么要进行选主？" class="headerlink" title="Raft 为什么要进行选主？"></a>Raft 为什么要进行选主？</h2><p>按照论文所述，原生的 Paxos 算法使用了一种点对点（peer-to-peer）的方式，所有节点地位是平等的。在理想情况下，算法的目的是制定一个决策，这对于简化的模型比较有意义。但在工业界很少会有系统会使用这种方式，当有一系列的决策需要被制定的时候，先选出一个 leader 节点然后让它去协调所有的决策，这样算法会更加简单快速。</p>
<p>此外，和其它一致性算法相比，Raft 赋予了 leader 节点更强的领导力，称之为 Strong Leader。比如说日志条目只能从 leader 节点发送给其它节点而不能反着来，这种方式简化了日志复制的逻辑，使 Raft 变得更加简单易懂。</p>
<h2 id="Raft-选主过程"><a href="#Raft-选主过程" class="headerlink" title="Raft 选主过程"></a>Raft 选主过程</h2><h3 id="节点角色"><a href="#节点角色" class="headerlink" title="节点角色"></a>节点角色</h3><p>Raft 集群中每个节点都处于以下三种角色之一：</p>
<ul>
<li>Leader: 所有请求的处理者，接收客户端发起的操作请求，写入本地日志后同步至集群其它节点。</li>
<li>Follower: 请求的被动更新者，从 leader 接收更新请求，写入本地文件。如果客户端的操作请求发送给了 follower，会首先由 follower 重定向给 leader。</li>
<li>Candidate: 如果 follower 在一定时间内没有收到 leader 的心跳，则判断 leader 可能已经故障，此时启动 leader election 过程，本节点切换为 candidate 直到选主结束。</li>
</ul>
<h3 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h3><p>每开始一次新的选举，称为一个任期（term），每个 term 都有一个严格递增的整数与之关联。每当 candidate 触发 leader election 时都会增加 term，如果一个 candidate 赢得选举，他将在本 term 中担任 leader 的角色。但并不是每个 term 都一定对应一个 leader，有时候某个 term 内会由于选举超时导致选不出 leader，这时 candicate 会递增 term 号并开始新一轮选举。<br><img src="/img/f3e463285d0e4d6299fca19c7ef7e334_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>Term 更像是一个逻辑时钟（logic clock）的作用，有了它，就可以发现哪些节点的状态已经过期。每一个节点都保存一个 current term，在通信时带上这个 term 号。节点间通过 RPC 来通信，主要有两类 RPC 请求：</p>
<ul>
<li>RequestVote RPCs: 用于 candidate 拉票选举。</li>
<li>AppendEntries RPCs: 用于 leader 向其它节点复制日志以及同步心跳。</li>
</ul>
<h3 id="节点状态转换"><a href="#节点状态转换" class="headerlink" title="节点状态转换"></a>节点状态转换</h3><p>我们知道集群每个节点的状态都只能是 leader、follower 或 candidate，那么节点什么时候会处于哪种状态呢？下图展示了一个节点可能发生的状态转换：<br><img src="/img/d9f2d1f2d3674a50900eda504ecaa326_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>接下来我们详细讨论下每个转换所发生的场景。</p>
<h4 id="Follower-状态转换过程"><a href="#Follower-状态转换过程" class="headerlink" title="Follower 状态转换过程"></a>Follower 状态转换过程</h4><p>Raft 的选主基于一种心跳机制，集群中每个节点刚启动时都是 follower 身份（Step: starts up），leader 会周期性的向所有节点发送心跳包来维持自己的权威，那么首个 leader 是如何被选举出来的呢？方法是如果一个 follower 在一段时间内没有收到任何心跳，也就是选举超时，那么它就会主观认为系统中没有可用的 leader，并发起新的选举（Step: times out, starts election）。</p>
<p>这里有一个问题，即这个“选举超时时间”该如何制定？如果所有节点在同一时刻启动，经过同样的超时时间后同时发起选举，整个集群会变得低效不堪，极端情况下甚至会一直选不出一个主节点。Raft 巧妙的使用了一个随机化的定时器，让每个节点的“超时时间”在一定范围内随机生成，这样就大大的降低了多个节点同时发起选举的可能性。</p>
<p><img src="/img/fc2b320077124da39bade7adeaf7ef08_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：一个五节点 Raft 集群的初始状态，所有节点都是 follower 身份，term 为 1，且每个节点的选举超时定时器不同</p>
<p>若 follower 想发起一次选举，follower 需要先增加自己的当前 term，并将身份切换为 candidate。然后它会向集群其它节点发送“请给自己投票”的消息（RequestVote RPC）。</p>
<p><img src="/img/316b81a42ea843a192cc2f3578fbdb81_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S1 率先超时，变为 candidate，term + 1，并向其它节点发出拉票请求</p>
<h4 id="Candicate-状态转换过程"><a href="#Candicate-状态转换过程" class="headerlink" title="Candicate 状态转换过程"></a>Candicate 状态转换过程</h4><p>Follower 切换为 candidate 并向集群其他节点发送“请给自己投票”的消息后，接下来会有三种可能的结果，也即上面节点状态图中 candidate 状态向外伸出的三条线。</p>
<p>选举成功（Step: receives votes from majority of servers）。当candicate从整个集群的大多数（N/2+1）节点获得了针对同一 term 的选票时，它就赢得了这次选举，立刻将自己的身份转变为 leader 并开始向其它节点发送心跳来维持自己的权威。<br><img src="/img/a851f56a384b4a0f9da76644d645ae1f_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：“大部分”节点都给了 S1 选票</p>
<p><img src="/img/a6e0e622b7384ac78f733e471b280c27_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S1 变为 leader，开始发送心跳维持权威</p>
<p>每个节点针对每个 term 只能投出一张票，并且按照先到先得的原则。这个规则确保只有一个 candidate 会成为 leader。</p>
<p>选举失败（Step: discovers current leader or new term）。Candidate 在等待投票回复的时候，可能会突然收到其它自称是 leader 的节点发送的心跳包，如果这个心跳包里携带的 term 不小于 candidate 当前的 term，那么 candidate 会承认这个 leader，并将身份切回 follower。这说明其它节点已经成功赢得了选举，我们只需立刻跟随即可。但如果心跳包中的 term 比自己小，candidate 会拒绝这次请求并保持选举状态。</p>
<p><img src="/img/d4ce0c7fdf3b4039a0e4b0b200af731a_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S4、S2 依次开始选举</p>
<p><img src="/img/2535cfeb9cfb44d4a0a04506f09f7485_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S4 成为 leader，S2 在收到 S4 的心跳包后，由于 term 不小于自己当前的 term，因此会立刻切为 follower 跟随 S4</p>
<p>选举超时（Step: times out, new election）。第三种可能的结果是 candidate 既没有赢也没有输。如果有多个 follower 同时成为 candidate，选票是可能被瓜分的，如果没有任何一个 candidate 能得到大多数节点的支持，那么每一个 candidate 都会超时。此时 candidate 需要增加自己的 term，然后发起新一轮选举。如果这里不做一些特殊处理，选票可能会一直被瓜分，导致选不出 leader 来。这里的“特殊处理”指的就是前文所述的随机化选举超时时间。</p>
<p><img src="/img/04163db3b7ca4b4c8fbfdf4e7253a98f_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S1 ~ S5 都在参与选举</p>
<p><img src="/img/517e2f7939394b3ca35936702a107f07_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：没有任何节点愿意给他人投票</p>
<p><img src="/img/b52e004bd4654cb1b51cdb409182156f_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：如果没有随机化超时时间，所有节点将会继续同时发起选举……</p>
<p>以上便是 candidate 三种可能的选举结果。</p>
<h4 id="Leader-状态转换过程"><a href="#Leader-状态转换过程" class="headerlink" title="Leader 状态转换过程"></a>Leader 状态转换过程</h4><p>节点状态图中的最后一条线是：discovers server with higher term。想象一个场景：当 leader 节点发生了宕机或网络断连，此时其它 follower 会收不到 leader 心跳，首个触发超时的节点会变为 candidate 并开始拉票（由于随机化各个 follower 超时时间不同），由于该 candidate 的 term 大于原 leader 的 term，因此所有 follower 都会投票给它，这名 candidate 会变为新的 leader。一段时间后原 leader 恢复了，收到了来自新leader 的心跳包，发现心跳中的 term 大于自己的 term，此时该节点会立刻切换为 follower 并跟随的新 leader。</p>
<p>上述流程的动画模拟如下：<br><img src="/img/33f858652afc4be6bb1d7b1f1dc33eaa_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S4 作为 term2 的 leader</p>
<p><img src="/img/7d45e677f6c2428d9b9db7022416fe26_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S4 宕机，S5 即将率先超时</p>
<p><img src="/img/1418b09699fe4614a594a565c55055d5_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S5 当选 term3 的 leader</p>
<p><img src="/img/f0d9d314c75c4bd989dadf044ecd6307_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S4 宕机恢复后收到了来自 S5 的 term3 心跳</p>
<p><img src="/img/31b9745a2fa94fb693a7ea1257aa5f7f_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S4 立刻变为 S5 的 follower</p>
<p>以上就是 Raft 的选主逻辑，但还有一些细节（譬如是否给该 candidate 投票还有一些其它条件）依赖算法的其它部分基础，我们会在后续“安全性”一章描述。</p>
<p>当票选出 leader 后，leader 也该承担起相应的责任了，这个责任是什么？就是下一章将介绍的“日志复制”。</p>
<h1 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h1><h2 id="什么是日志复制"><a href="#什么是日志复制" class="headerlink" title="什么是日志复制"></a>什么是日志复制</h2><p>在前文中我们讲过：共识算法通常基于状态复制机（Replicated State Machine）模型，所有节点从同一个 state 出发，经过一系列同样操作 log 的步骤，最终也必将达到一致的 state。也就是说，只要我们保证集群中所有节点的 log 一致，那么经过一系列应用（apply）后最终得到的状态机也就是一致的。</p>
<p>Raft 负责保证集群中所有节点 log 的一致性。</p>
<p>此外我们还提到过：Raft 赋予了 leader 节点更强的领导力（Strong Leader）。那么 Raft 保证 log 一致的方式就很容易理解了，即所有 log 都必须交给 leader 节点处理，并由 leader 节点复制给其它节点。这个过程，就叫做日志复制（Log replication）。</p>
<h2 id="Raft-日志复制机制解析"><a href="#Raft-日志复制机制解析" class="headerlink" title="Raft 日志复制机制解析"></a>Raft 日志复制机制解析</h2><h3 id="整体流程解析"><a href="#整体流程解析" class="headerlink" title="整体流程解析"></a>整体流程解析</h3><p>一旦 leader 被票选出来，它就承担起领导整个集群的责任了，开始接收客户端请求，并将操作包装成日志，并复制到其它节点上去。整体流程如下：</p>
<ul>
<li>Leader 为客户端提供服务，客户端的每个请求都包含一条即将被状态复制机执行的指令。</li>
<li>Leader 把该指令作为一条新的日志附加到自身的日志集合，然后向其它节点发起附加条目请求（AppendEntries RPC），来要求它们将这条日志附加到各自本地的日志集合。</li>
<li>当这条日志已经确保被安全的复制，即大多数（N/2+1）节点都已经复制后，leader 会将该日志 apply 到它本地的状态机中，然后把操作成功的结果返回给客户端。</li>
</ul>
<p>整个集群的日志模型可以宏观表示为下图（x ← 3 代表 x 赋值为 3）：<br><img src="/img/60d6b91f49ac4d11bee43f86f33566d6_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>每条日志除了存储状态机的操作指令外，还会拥有一个唯一的整数索引值（log index）来表明它在日志集合中的位置。此外，每条日志还会存储一个 term 号（日志条目方块最上方的数字，相同颜色 term 号相同），该 term 表示 leader 收到这条指令时的当前任期，term 相同的 log 是由同一个 leader 在其任期内发送的。</p>
<p>当一条日志被 leader 节点认为可以安全的 apply 到状态机时，称这条日志是 committed（上图中的 committed entries）。那么什么样的日志可以被 commit 呢？答案是：当 leader 得知这条日志被集群过半的节点复制成功时。因此在上图中我们可以看到 (term3, index7) 这条日志以及之前的日志都是 committed，尽管有两个节点拥有的日志并不完整。</p>
<p>Raft 保证所有 committed 日志都已经被持久化，且“最终”一定会被状态机apply。</p>
<p>注：这里的“最终”用词很微妙，它表明了一个特点：Raft 保证的只是集群内日志的一致性，而我们真正期望的集群对外的状态机一致性需要我们做一些额外工作，这一点在《线性一致性与读性能优化》一章会着重介绍。</p>
<h3 id="日志复制流程图解"><a href="#日志复制流程图解" class="headerlink" title="日志复制流程图解"></a>日志复制流程图解</h3><p>我们通过 Raft 动画 来模拟常规日志复制这一过程：<br><img src="/img/11bd5a3d291b43d2b31fea3a75fb3655_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>如上图，S1 当选 leader，此时还没有任何日志。我们模拟客户端向 S1 发起一个请求。</p>
<p><img src="/img/7a17a0e447534541a520ec97a9942cdd_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>S1 收到客户端请求后新增了一条日志 (term2, index1)，然后并行地向其它节点发起 AppendEntries RPC。</p>
<p><img src="/img/2b0c350086014a52a4989f02f5262153_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>S2、S4 率先收到了请求，各自附加了该日志，并向 S1 回应响应。</p>
<p><img src="/img/6f062cd961a24c5a951f2c025f065bd4_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>所有节点都附加了该日志，但由于 leader 尚未收到任何响应，因此暂时还不清楚该日志到底是否被成功复制。</p>
<p><img src="/img/97dbbaaf72cc4a2ba148cb252bce95ec_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>当 S1 收到2个节点的响应时，该日志条目的边框就已经变为实线，表示该日志已经安全的复制，因为在5节点集群中，2个 follower 节点加上 leader 节点自身，副本数已经确保过半，此时 S1 将响应客户端的请求。<br><img src="/img/a127762b466a48719967d52ab9f0636c_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>leader 后续会持续发送心跳包给 followers，心跳包中会携带当前已经安全复制（我们称之为 committed）的日志索引，此处为 (term2, index1)。<br><img src="/img/f7ebe584867b4c0b98b1e46f595a5007_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>所有 follower 都通过心跳包得知 (term2, index1) 的 log 已经成功复制 （committed），因此所有节点中该日志条目的边框均变为实线。</p>
<h3 id="对日志一致性的保证"><a href="#对日志一致性的保证" class="headerlink" title="对日志一致性的保证"></a>对日志一致性的保证</h3><p>前边我们使用了 (term2, index1) 这种方式来表示一条日志条目，这里为什么要带上 term，而不仅仅是使用 index？原因是 term 可以用来检查不同节点间日志是否存在不一致的情况，阅读下一节后会更容易理解这句话。</p>
<p>Raft 保证：如果不同的节点日志集合中的两个日志条目拥有相同的 term 和 index，那么它们一定存储了相同的指令。为什么可以作出这种保证？因为 Raft 要求 leader 在一个 term 内针对同一个 index 只能创建一条日志，并且永远不会修改它。同时 Raft 也保证：如果不同的节点日志集合中的两个日志条目拥有相同的 term 和 index，那么它们之前的所有日志条目也全部相同。这是因为 leader 发出的 AppendEntries RPC 中会额外携带上一条日志的 (term, index)，如果 follower 在本地找不到相同的 (term, index) 日志，则拒绝接收这次新的日志。所以，只要 follower 持续正常地接收来自 leader 的日志，那么就可以通过归纳法验证上述结论。</p>
<h3 id="可能出现的日志不一致场景"><a href="#可能出现的日志不一致场景" class="headerlink" title="可能出现的日志不一致场景"></a>可能出现的日志不一致场景</h3><p>在所有节点正常工作的时候，leader 和 follower的日志总是保持一致，AppendEntries RPC 也永远不会失败。然而我们总要面对任意节点随时可能宕机的风险，如何在这种情况下继续保持集群日志的一致性才是我们真正要解决的问题。</p>
<p><img src="/img/012758dde1ba4305b417d860236a2ecc_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>上图展示了一个 term8 的 leader 刚上任时，集群中日志可能存在的混乱情况。例如 follower 可能缺少一些日志（a ~ b），可能多了一些未提交的日志（c ~ d），也可能既缺少日志又多了一些未提交日志（e ~ f）。</p>
<p>注：Follower 不可能比 leader 多出一些已提交（committed）日志，这一点是通过选举上的限制来达成的，会在下一章《安全性》介绍。</p>
<p>我们先来尝试复现上述 a ~ f 场景，最后再讲 Raft 如何解决这种不一致问题。</p>
<ul>
<li>场景a~b. Follower 日志落后于 leader<ul>
<li>这种场景其实很简单，即 follower 宕机了一段时间，follower-a 从收到 (term6, index9) 后开始宕机，follower-b 从收到 (term4, index4) 后开始宕机。这里不再赘述。</li>
</ul>
</li>
<li>场景c. Follower 日志比 leader 多 term6<ul>
<li>当 term6 的 leader 正在将 (term6, index11) 向 follower 同步时，该 leader 发生了宕机，且此时只有 follower-c 收到了这条日志的 AppendEntries RPC。然后经过一系列的选举，term7 可能是选举超时，也可能是 leader 刚上任就宕机了，最终 term8 的 leader 上任了，成就了我们看到的场景 c。</li>
</ul>
</li>
<li>场景d. Follower 日志比 leader 多 term7<ul>
<li>当 term6 的 leader 将 (term6, index10) 成功 commit 后，发生了宕机。此时 term7 的 leader 走马上任，连续同步了两条日志给 follower，然而还没来得及 commit 就宕机了，随后集群选出了 term8 的 leader。</li>
</ul>
</li>
<li>场景e. Follower 日志比 leader 少 term5 ~ 6，多 term4<ul>
<li>当 term4 的 leader 将 (term4, index7) 同步给 follower，且将 (term4, index5) 及之前的日志成功 commit 后，发生了宕机，紧接着 follower-e 也发生了宕机。这样在 term5~7 内发生的日志同步全都被 follower-e 错过了。当 follower-e 恢复后，term8 的 leader 也刚好上任了。</li>
</ul>
</li>
<li>场景f. Follower 日志比 leader 少 term4 ~ 6，多 term2 ~ 3<ul>
<li>当 term2 的 leader 同步了一些日志（index4 ~ 6）给 follower 后，尚未来得及 commit 时发生了宕机，但它很快恢复过来了，又被选为了 term3 的 leader，它继续同步了一些日志（index7~11）给 follower，但同样未来得及 commit 就又发生了宕机，紧接着 follower-f 也发生了宕机，当 follower-f 醒来时，集群已经前进到 term8 了。</li>
</ul>
</li>
</ul>
<h3 id="如何处理日志不一致"><a href="#如何处理日志不一致" class="headerlink" title="如何处理日志不一致"></a>如何处理日志不一致</h3><p>通过上述场景我们可以看到，真实世界的集群情况很复杂，那么 Raft 是如何应对这么多不一致场景的呢？其实方式很简单暴力，想想 Strong Leader 这个词。</p>
<p>Raft 强制要求 follower 必须复制 leader 的日志集合来解决不一致问题。也就是说，follower 节点上任何与 leader 不一致的日志，都会被 leader 节点上的日志所覆盖。这并不会产生什么问题，因为某些选举上的限制，如果 follower 上的日志与 leader 不一致，那么该日志在 follower 上一定是未提交的。未提交的日志并不会应用到状态机，也不会被外部的客户端感知到。</p>
<p>要使得 follower 的日志集合跟自己保持完全一致，leader 必须先找到二者间最后一次达成一致的地方。因为一旦这条日志达成一致，在这之前的日志一定也都一致（回忆下前文）。这个确认操作是在 AppendEntries RPC 的一致性检查步骤完成的。</p>
<p>Leader 针对每个 follower 都维护一个 next index，表示下一条需要发送给该follower 的日志索引。当一个 leader 刚刚上任时，它初始化所有 next index 值为自己最后一条日志的 index+1。但凡某个 follower 的日志跟 leader 不一致，那么下次 AppendEntries RPC 的一致性检查就会失败。在被 follower 拒绝这次 Append Entries RPC 后，leader 会减少 next index 的值并进行重试。</p>
<p>最终一定会存在一个 next index 使得 leader 和 follower 在这之前的日志都保持一致。极端情况下 next index 为1，表示 follower 没有任何日志与 leader 一致，leader 必须从第一条日志开始同步。</p>
<p>针对每个 follower，一旦确定了 next index 的值，leader 便开始从该 index 同步日志，follower 会删除掉现存的不一致的日志，保留 leader 最新同步过来的。</p>
<p>整个集群的日志会在这个简单的机制下自动趋于一致。此外要注意，leader 从来不会覆盖或者删除自己的日志，而是强制 follower 与它保持一致。这就要求集群票选出的 leader 一定要具备“日志的正确性”，这也就关联到了前文提到的：选举上的限制。下一章我们将对此详细讨论。</p>
<h1 id="安全性及正确性"><a href="#安全性及正确性" class="headerlink" title="安全性及正确性"></a>安全性及正确性</h1><p>前面的章节我们讲述了 Raft 算法是如何选主和复制日志的，然而到目前为止我们描述的这套机制还不能保证每个节点的状态机会严格按照相同的顺序 apply 日志。想象以下场景：</p>
<ul>
<li>Leader 将一些日志复制到了大多数节点上，进行 commit 后发生了宕机。</li>
<li>某个 follower 并没有被复制到这些日志，但它参与选举并当选了下一任 leader。</li>
<li>新的 leader 又同步并 commit 了一些日志，这些日志覆盖掉了其它节点上的上一任 committed 日志。</li>
<li>各个节点的状态机可能 apply 了不同的日志序列，出现了不一致的情况。</li>
</ul>
<p>因此我们需要对“选主+日志复制”这套机制加上一些额外的限制，来保证状态机的安全性，也就是 Raft 算法的正确性。</p>
<h2 id="对选举的限制"><a href="#对选举的限制" class="headerlink" title="对选举的限制"></a>对选举的限制</h2><p>我们再来分析下前文所述的 committed 日志被覆盖的场景，根本问题其实发生在第2步。Candidate 必须有足够的资格才能当选集群 leader，否则它就会给集群带来不可预料的错误。Candidate 是否具备这个资格可以在选举时添加一个小小的条件来判断，即：</p>
<p>每个 candidate 必须在 RequestVote RPC 中携带自己本地日志的最新 (term, index)，如果 follower 发现这个 candidate 的日志还没有自己的新，则拒绝投票给该 candidate。</p>
<p>Candidate 想要赢得选举成为 leader，必须得到集群大多数节点的投票，那么它的日志就一定至少不落后于大多数节点。又因为一条日志只有复制到了大多数节点才能被 commit，因此能赢得选举的 candidate 一定拥有所有 committed 日志。因此前一篇文章我们才会断定地说：Follower 不可能比 leader 多出一些 committed 日志。比较两个 (term, index) 的逻辑非常简单：如果 term 不同 term 更大的日志更新，否则 index 大的日志更新。</p>
<h2 id="对提交的限制"><a href="#对提交的限制" class="headerlink" title="对提交的限制"></a>对提交的限制</h2><p>除了对选举增加一点限制外，我们还需对 commit 行为增加一点限制，来完成我们 Raft 算法核心部分的最后一块拼图。</p>
<p>回忆下什么是 commit：当 leader 得知某条日志被集群过半的节点复制成功时，就可以进行 commit，committed 日志一定最终会被状态机 apply。所谓 commit 其实就是对日志简单进行一个标记，表明其可以被 apply 到状态机，并针对相应的客户端请求进行响应。然而 leader 并不能在任何时候都随意 commit 旧任期留下的日志，即使它已经被复制到了大多数节点。Raft 论文给出了一个经典场景：<br><img src="/img/b1b4e211fca44ca9bf5a67639e92d4d4_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>上图从左到右按时间顺序模拟了问题场景。</p>
<ul>
<li>阶段a：S1 是 leader，收到请求后将 (term2, index2) 只复制给了 S2，尚未复制给 S3 ~ S5。</li>
<li>阶段b：S1 宕机，S5 当选 term3 的 leader（S3、S4、S5 三票），收到请求后保存了 (term3, index2)，尚未复制给任何节点。</li>
<li>阶段c：S5 宕机，S1 恢复，S1 重新当选 term4 的 leader，继续将 (term2, index2) 复制给了 S3，已经满足大多数节点，我们将其 commit。</li>
<li>阶段d：S1 又宕机，S5 恢复，S5 重新当选 leader（S2、S3、S4 三票），将 (term3, inde2) 复制给了所有节点并 commit。注意，此时发生了致命错误，已经 committed 的 (term2, index2) 被 (term3, index2) 覆盖了。</li>
</ul>
<p>为了避免这种错误，我们需要添加一个额外的限制：Leader 只允许 commit 包含当前 term 的日志。</p>
<p>针对上述场景，问题发生在阶段c，即使作为 term4 leader 的 S1 将 (term2, index2) 复制给了大多数节点，它也不能直接将其 commit，而是必须等待 term4 的日志到来并成功复制后，一并进行 commit。</p>
<ul>
<li>阶段e：在添加了这个限制后，要么 (term2, index2) 始终没有被 commit，这样 S5 在阶段d将其覆盖就是安全的；要么 (term2, index2) 同 (term4, index3) 一起被 commit，这样 S5 根本就无法当选 leader，因为大多数节点的日志都比它新，也就不存在前边的问题了。</li>
</ul>
<p>以上便是对算法增加的两个小限制，它们对确保状态机的安全性起到了至关重要的作用。</p>
<p>至此我们对 Raft 算法的核心部分，已经介绍完毕。下一章我们会介绍两个同样描述于论文内的辅助技术：集群成员变更和日志压缩，它们都是在 Raft 工程实践中必不可少的部分。</p>
<h1 id="集群成员变更与日志压缩"><a href="#集群成员变更与日志压缩" class="headerlink" title="集群成员变更与日志压缩"></a>集群成员变更与日志压缩</h1><p>尽管我们已经通过前几章了解了 Raft 算法的核心部分，但相较于算法理论来说，在工程实践中仍有一些现实问题需要我们去面对。Raft 非常贴心的在论文中给出了两个常见问题的解决方案，它们分别是：</p>
<ul>
<li>集群成员变更：如何安全地改变集群的节点成员。</li>
<li>日志压缩：如何解决日志集合无限制增长带来的问题。</li>
</ul>
<p>本文我们将分别讲解这两种技术。</p>
<h2 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h2><p>在前文的理论描述中我们都假设了集群成员是不变的，然而在实践中有时会需要替换宕机机器或者改变复制级别（即增减节点）。一种最简单暴力达成目的的方式就是：停止集群、改变成员、启动集群。这种方式在执行时会导致集群整体不可用，此外还存在手工操作带来的风险。</p>
<p>为了避免这样的问题，Raft 论文中给出了一种无需停机的、自动化的改变集群成员的方式，其实本质上还是利用了 Raft 的核心算法，将集群成员配置作为一个特殊日志从 leader 节点同步到其它节点去。</p>
<h3 id="直接切换集群成员配置"><a href="#直接切换集群成员配置" class="headerlink" title="直接切换集群成员配置"></a>直接切换集群成员配置</h3><p>先说结论：所有将集群从旧配置直接完全切换到新配置的方案都是不安全的。</p>
<p>因此我们不能想当然的将新配置直接作为日志同步给集群并 apply。因为我们不可能让集群中的全部节点在“同一时刻”原子地切换其集群成员配置，所以在切换期间不同的节点看到的集群视图可能存在不同，最终可能导致集群存在多个 leader。为了理解上述结论，我们来看一个实际出现问题的场景，下图对其进行了展现。<br><img src="/img/00cd4fb677dc4a8987c015b6f074a3b8_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<ul>
<li>阶段a. 集群存在 S1 ~ S3 三个节点，我们将该成员配置表示为 C-old，绿色表示该节点当前视图（成员配置）为 C-old，其中红边的 S3 为 leader。</li>
<li>阶段b. 集群新增了 S4、S5 两个节点，该变更从 leader 写入，我们将 S1 ~ S5 的五节点新成员配置表示为 C-new，蓝色表示该节点当前视图为 C-new。</li>
<li>阶段c. 假设 S3 短暂宕机触发了 S1 与 S5 的超时选主。</li>
<li>阶段d. S1 向 S2、S3 拉票，S5 向其它全部四个节点拉票。由于 S2 的日志并没有比 S1 更新，因此 S2 可能会将选票投给 S1，S1 两票当选（因为 S1 认为集群只有三个节点）。而 S5 肯定会得到 S3、S4 的选票，因为 S1 感知不到 S4，没有向它发送 RequestVote RPC，并且 S1 的日志落后于 S3，S3 也一定不会投给 S1，结果 S5 三票当选。最终集群出现了多个主节点的致命错误，也就是所谓的脑裂。</li>
</ul>
<p><img src="/img/1c063b8c7e824bb88ffe572439c90975_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>上图来自论文，用不同的形式展现了和图5-1相同的问题。颜色代表的含义与图5-1是一致的，在 problem: two disjoint majorities 所指的时间点，集群可能会出现两个 leader。但是，多主问题并不是在任何新老节点同时选举时都一定可能出现的</p>
<p><img src="/img/85436861e4484446afac9192d02bc292_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图5-3</p>
<p>该假想场景类似图5-1的阶段d，模拟过程如下：</p>
<ul>
<li>S1 为集群原 leader，集群新增 S4、S5，该配置被推给了 S3，S2 尚未收到。</li>
<li>此时 S1 发生短暂宕机，S2、S3 分别触发选主。</li>
<li>最终 S2 获得了 S1 和自己的选票，S3 获得了 S4、S5 和自己的选票，集群出现两个 leader。</li>
</ul>
<p>图5-3过程看起来好像和图5-1没有什么大的不同，只是参与选主的节点存在区别，然而事实是图5-3的情况是不可能出现的。</p>
<p>注意：Raft 论文中传递集群变更信息也是通过日志追加实现的，所以也受到选主的限制。很多读者对选主限制中比较的日志是否必须是 committed 产生疑惑，回看下在《安全性》一文中的描述：</p>
<p>每个 candidate 必须在 RequestVote RPC 中携带自己本地日志的最新 (term, index)，如果 follower 发现这个 candidate 的日志还没有自己的新，则拒绝投票给该 candidate。</p>
<p>这里再帮大家明确下，论文里确实间接表明了，选主时比较的日志是不要求 committed 的，只需比较本地的最新日志就行！</p>
<p>回到图5-3，不可能出现的原因在于，S1 作为原 leader 已经第一个保存了新配置的日志，而 S2 尚未被同步这条日志，根据上一章《安全性》我们讲到的选主限制，S1 不可能将选票投给 S2，因此 S2 不可能成为 leader。</p>
<h3 id="两阶段切换集群成员配置"><a href="#两阶段切换集群成员配置" class="headerlink" title="两阶段切换集群成员配置"></a>两阶段切换集群成员配置</h3><p>Raft 使用一种两阶段方法平滑切换集群成员配置来避免遇到前一节描述的问题，具体流程如下：</p>
<ul>
<li>阶段一<ul>
<li>客户端将 C-new 发送给 leader，leader 将 C-old 与 C-new 取并集并立即apply，我们表示为 C-old,new。</li>
<li>Leader 将 C-old,new 包装为日志同步给其它节点。</li>
<li>Follower 收到 C-old,new 后立即 apply，当 <strong>C-old,new 的大多数节点（即 C-old 的大多数节点和 C-new 的大多数节点）</strong>都切换后，leader 将该日志 commit。</li>
</ul>
</li>
<li>阶段二<ul>
<li>Leader 接着将 C-new 包装为日志同步给其它节点。</li>
<li>Follower 收到 C-new 后立即 apply，如果此时发现自己不在 C-new 列表，则主动退出集群。</li>
<li>Leader 确认 C-new 的大多数节点都切换成功后，给客户端发送执行成功的响应。</li>
</ul>
</li>
</ul>
<p><img src="/img/3af62adcab904fbc8d606b1ad29d9a34_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>上图展示了该流程的时间线。虚线表示已经创建但尚未 commit 的成员配置日志，实线表示 committed 的成员配置日志。</p>
<p>为什么该方案可以保证不会出现多个 leader？我们来按流程逐阶段分析。</p>
<ul>
<li>阶段1. C-old,new 尚未 commit<ul>
<li>该阶段所有节点的配置要么是 C-old，要么是 C-old,new，但无论是二者哪种，只要原 leader 发生宕机，新 leader 都必须得到大多数 C-old 集合内节点的投票。</li>
<li>以图5-1场景为例，S5 在阶段d根本没有机会成为 leader，因为 C-old 中只有 S3 给它投票了，不满足大多数。</li>
</ul>
</li>
<li>阶段2. C-old,new 已经 commit，C-new 尚未下发<ul>
<li>该阶段 C-old,new 已经 commit，可以确保已经被 C-old,new 的大多数节点（再次强调：C-old 的大多数节点和 C-new 的大多数节点）复制。</li>
<li>因此当 leader 宕机时，新选出的 leader 一定是已经拥有 C-old,new 的节点，不可能出现两个 leader。</li>
</ul>
</li>
<li>阶段3. C-new 已经下发但尚未 commit<ul>
<li>该阶段集群中可能有三种节点 C-old、C-old,new、C-new，但由于已经经历了阶段2，因此 C-old 节点不可能再成为 leader。而无论是 C-old,new 还是 C-new 节点发起选举，都需要经过大多数 C-new 节点的同意，因此也不可能出现两个 leader。</li>
</ul>
</li>
<li>阶段4. C-new 已经 commit<ul>
<li>该阶段 C-new 已经被 commit，因此只有 C-new 节点可以得到大多数选票成为 leader。此时集群已经安全地完成了这轮变更，可以继续开启下一轮变更了。</li>
</ul>
</li>
</ul>
<p>以上便是对该两阶段方法可行性的分步验证，Raft 论文将该方法称之为共同一致（Joint Consensus）。关于集群成员变更另一篇更详细的论文还给出了其它方法，简单来说就是论证一次只变更一个节点的的正确性，并给出解决可用性问题的优化方案。感兴趣的同学可以参考：《Consensus: Bridging Theory and Practice》。</p>
<h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>我们知道 Raft 核心算法维护了日志的一致性，通过 apply 日志我们也就得到了一致的状态机，客户端的操作命令会被包装成日志交给 Raft 处理。然而在实际系统中，客户端操作是连绵不断的，但日志却不能无限增长，首先它会占用很高的存储空间，其次每次系统重启时都需要完整回放一遍所有日志才能得到最新的状态机。</p>
<p>因此 Raft 提供了一种机制去清除日志里积累的陈旧信息，叫做日志压缩。</p>
<p>快照（Snapshot）是一种常用的、简单的日志压缩方式，ZooKeeper、Chubby 等系统都在用。简单来说，就是将某一时刻系统的状态 dump 下来并落地存储，这样该时刻之前的所有日志就都可以丢弃了。所以大家对“压缩”一词不要产生错误理解，我们并没有办法将状态机快照“解压缩”回日志序列。<br>注意，在 Raft 中我们只能为 committed 日志做 snapshot，因为只有 committed 日志才是确保最终会应用到状态机的。</p>
<p><img src="/img/00ef776fc5b64e56bd2abbfae3371329_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>上图展示了一个节点用快照替换了 (term1, index1) ~ (term3, index5) 的日志。快照一般包含以下内容：</p>
<ul>
<li>日志的元数据：最后一条被该快照 apply 的日志 term 及 index</li>
<li>状态机：前边全部日志 apply 后最终得到的状态机</li>
</ul>
<p>当 leader 需要给某个 follower 同步一些旧日志，但这些日志已经被 leader 做了快照并删除掉了时，leader 就需要把该快照发送给 follower。</p>
<p>同样，当集群中有新节点加入，或者某个节点宕机太久落后了太多日志时，leader 也可以直接发送快照，大量节约日志传输和回放时间。</p>
<p>同步快照使用一个新的 RPC 方法，叫做 InstallSnapshot RPC。</p>
<h1 id="线性一致性与读性能优化"><a href="#线性一致性与读性能优化" class="headerlink" title="线性一致性与读性能优化"></a>线性一致性与读性能优化</h1><h2 id="什么是线性一致性？"><a href="#什么是线性一致性？" class="headerlink" title="什么是线性一致性？"></a>什么是线性一致性？</h2><p>在该系列首篇《基本概念》中我们提到过：在分布式系统中，为了消除单点提高系统可用性，通常会使用副本来进行容错，但这会带来另一个问题，即如何保证多个副本之间的一致性。</p>
<p>什么是一致性？所谓一致性有很多种模型，不同的模型都是用来评判一个并发系统正确与否的不同程度的标准。而我们今天要讨论的是强一致性（Strong Consistency）模型，也就是线性一致性（Linearizability），我们经常听到的 CAP 理论中的 C 指的就是它。</p>
<p>其实我们在第一篇就已经简要描述过何为线性一致性：</p>
<blockquote>
<p>所谓的强一致性（线性一致性）并不是指集群中所有节点在任一时刻的状态必须完全一致，而是指一个目标，即让一个分布式系统看起来只有一个数据副本，并且读写操作都是原子的，这样应用层就可以忽略系统底层多个数据副本间的同步问题。也就是说，我们可以将一个强一致性分布式系统当成一个整体，一旦某个客户端成功的执行了写操作，那么所有客户端都一定能读出刚刚写入的值。即使发生网络分区故障，或者少部分节点发生异常，整个集群依然能够像单机一样提供服务。</p>
</blockquote>
<p>“像单机一样提供服务”从感官上描述了一个线性一致性系统应该具备的特性，那么我们该如何判断一个系统是否具备线性一致性呢？通俗来说就是不能读到旧（stale）数据，但具体分为两种情况：</p>
<ul>
<li>对于调用时间存在重叠（并发）的请求，生效顺序可以任意确定。</li>
<li>对于调用时间存在先后关系（偏序）的请求，后一个请求不能违背前一个请求确定的结果。</li>
</ul>
<p>只要根据上述两条规则即可判断一个系统是否具备线性一致性。下面我们来看一个非线性一致性系统的例子。</p>
<p><img src="/img/286a2248256b4b9f84ff613318432103_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>如上图所示，裁判将世界杯的比赛结果写入了主库，Alice 和 Bob 所浏览的页面分别从两个不同的从库读取，但由于存在主从同步延迟，Follower 2 的本次同步延迟高于 Follower 1，最终导致 Bob 听到了 Alice 的惊呼后刷新页面看到的仍然是比赛进行中。</p>
<p>虽然线性一致性的基本思想很简单，只是要求分布式系统看起来只有一个数据副本，但在实际中还是有很多需要关注的点，我们继续看几个例子。</p>
<p><img src="/img/d22cb375fc664ac2a5585417a50028de_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>上图从客户端的外部视角展示了多个用户同时请求读写一个系统的场景，每条柱形都是用户发起的一个请求，左端是请求发起的时刻，右端是收到响应的时刻。由于网络延迟和系统处理时间并不固定，所以柱形长度并不相同。</p>
<ul>
<li>x 最初的值为 0，Client C 在某个时间段将 x 写为 1。</li>
<li>Client A 第一个读操作位于 Client C 的写操作之前，因此必须读到原始值 0。</li>
<li>Client A 最后一个读操作位于 Client C 的写操作之后，如果系统是线性一致的，那么必须读到新值 1。</li>
<li>其它与写操作重叠的所有读操作，既可能返回 0，也可能返回 1，因为我们并不清楚写操作在哪个时间段内哪个精确的点生效，这种情况下读写是并发的。</li>
</ul>
<p>仅仅是这样的话，仍然不能说这个系统满足线性一致。假设 Client B 的第一次读取返回了 1，如果 Client A 的第二次读取返回了 0，那么这种场景并不破坏上述规则，但这个系统仍不满足线性一致，因为客户端在写操作执行期间看到 x 的值在新旧之间来回翻转，这并不符合我们期望的“看起来只有一个数据副本”的要求。所以我们需要额外添加一个约束，如下图所示。</p>
<p><img src="/img/0d9c3635c4d245188997538e36cb972d_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>在任何一个客户端的读取返回新值后，所有客户端的后续读取也必须返回新值，这样系统便满足线性一致了。</p>
<p>我们最后来看一个更复杂的例子，继续细化这个时序图。</p>
<p><img src="/img/5d2ab2d829fe4fa086298245edc24dea_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>如上图所示，每个读写操作在某个特定的时间点都是原子性的生效，我们在柱形中用竖线标记出生效的时间点，将这些标记按时间顺序连接起来。那么线性一致的要求就是：连线总是按照时间顺序向右移动，而不会向左回退。所以这个连线结果必定是一个有效的寄存器读写序列：任何客户端的每次读取都必须返回该条目最近一次写入的值。</p>
<p>线性一致性并非限定在分布式环境下，在单机单核系统中可以简单理解为“寄存器”的特性。</p>
<p>Client B 的最后一次读操作并不满足线性一致，因为在连线向右移动的前提下，它读到的值是错误的（因为Client A 已经读到了由 Client C 写入的 4）。此外这张图里还有一些值得指出的细节点，可以解开很多我们在使用线性一致系统时容易产生的误解：</p>
<ul>
<li>Client B 的首个读请求在 Client D 的首个写请求和 Client A 的首个写请求之前发起，但最终读到的却是最后由 Client A 写成功之后的结果。</li>
<li>Client A 尚未收到首个写请求成功的响应时，Client B 就读到了 Client A 写入的值。</li>
</ul>
<p>上述现象在线性一致的语义下都是合理的。</p>
<p>所以线性一致性（Linearizability）除了叫强一致性（Strong Consistency）外，还叫做原子一致性（Atomic Consistency）、立即一致性（Immediate Consistency）或外部一致性（External Consistency），这些名字看起来都是比较贴切的。</p>
<h2 id="Raft-线性一致性读"><a href="#Raft-线性一致性读" class="headerlink" title="Raft 线性一致性读"></a>Raft 线性一致性读</h2><p>在了解了什么是线性一致性之后，我们将其与 Raft 结合来探讨。首先需要明确一个问题，使用了 Raft 的系统都是线性一致的吗？不是的，Raft 只是提供了一个基础，要实现整个系统的线性一致还需要做一些额外的工作。</p>
<p>假设我们期望基于 Raft 实现一个线性一致的分布式 kv 系统，让我们从最朴素的方案开始，指出每种方案存在的问题，最终使整个系统满足线性一致性。</p>
<h3 id="写主读从缺陷分析"><a href="#写主读从缺陷分析" class="headerlink" title="写主读从缺陷分析"></a>写主读从缺陷分析</h3><p>写操作并不是我们关注的重点，如果你稍微看了一些理论部分就应该知道，所有写操作都要作为提案从 leader 节点发起，当然所有的写命令都应该简单交给 leader 处理。真正关键的点在于读操作的处理方式，这涉及到整个系统关于一致性方面的取舍。</p>
<p>在该方案中我们假设读操作直接简单地向 follower 发起，那么由于 Raft 的 Quorum 机制（大部分节点成功即可），针对某个提案在某一时间段内，集群可能会有以下两种状态：</p>
<ul>
<li>某次写操作的日志尚未被复制到一少部分 follower，但 leader 已经将其 commit。</li>
<li>某次写操作的日志已经被同步到所有 follower，但 leader 将其 commit 后，心跳包尚未通知到一部分 follower。</li>
</ul>
<p>以上每个场景客户端都可能读到过时的数据，整个系统显然是不满足线性一致的。</p>
<h3 id="写主读主缺陷分析"><a href="#写主读主缺陷分析" class="headerlink" title="写主读主缺陷分析"></a>写主读主缺陷分析</h3><p>在该方案中我们限定，所有的读操作也必须经由 leader 节点处理，读写都经过 leader 难道还不能满足线性一致？是的！！ 并且该方案存在不止一个问题！！</p>
<h4 id="问题一：状态机落后于-committed-log-导致脏读"><a href="#问题一：状态机落后于-committed-log-导致脏读" class="headerlink" title="问题一：状态机落后于 committed log 导致脏读"></a>问题一：状态机落后于 committed log 导致脏读</h4><p>回想一下前文讲过的，我们在解释什么是 commit 时提到了写操作什么时候可以响应客户端：</p>
<p>所谓 commit 其实就是对日志简单进行一个标记，表明其可以被 apply 到状态机，并针对相应的客户端请求进行响应。</p>
<p>也就是说一个提案只要被 leader commit 就可以响应客户端了，Raft 并没有限定提案结果在返回给客户端前必须先应用到状态机。所以从客户端视角当我们的某个写操作执行成功后，下一次读操作可能还是会读到旧值。</p>
<p>这个问题的解决方式很简单，在 leader 收到读命令时我们只需记录下当前的 commit index，当 apply index 追上该 commit index 时，即可将状态机中的内容响应给客户端。</p>
<h4 id="问题二：网络分区导致脏读"><a href="#问题二：网络分区导致脏读" class="headerlink" title="问题二：网络分区导致脏读"></a>问题二：网络分区导致脏读</h4><p>假设集群发生网络分区，旧 leader 位于少数派分区中，而且此刻旧 leader 刚好还未发现自己已经失去了领导权，当多数派分区选出了新的 leader 并开始进行后续写操作时，连接到旧 leader 的客户端可能就会读到旧值了。</p>
<p>因此，仅仅是直接读 leader 状态机的话，系统仍然不满足线性一致性。</p>
<h3 id="Raft-Log-Read"><a href="#Raft-Log-Read" class="headerlink" title="Raft Log Read"></a>Raft Log Read</h3><p>为了确保 leader 处理读操作时仍拥有领导权，我们可以将读请求同样作为一个提案走一遍 Raft 流程，当这次读请求对应的日志可以被应用到状态机时，leader 就可以读状态机并返回给用户了。这种读方案称为 Raft Log Read，也可以直观叫做 Read as Proposal。</p>
<p>为什么这种方案满足线性一致？因为该方案根据 commit index 对所有读写请求都一起做了线性化，这样每个读请求都能感知到状态机在执行完前一写请求后的最新状态，将读写日志一条一条的应用到状态机，整个系统当然满足线性一致。但该方案的缺点也非常明显，那就是性能差，读操作的开销与写操作几乎完全一致。而且由于所有操作都线性化了，我们无法并发读状态机。</p>
<h2 id="Raft-读性能优化"><a href="#Raft-读性能优化" class="headerlink" title="Raft 读性能优化"></a>Raft 读性能优化</h2><p>接下来我们将介绍几种优化方案，它们在不违背系统线性一致性的前提下，大幅提升了读性能。</p>
<h3 id="Read-Index"><a href="#Read-Index" class="headerlink" title="Read Index"></a>Read Index</h3><p>与 Raft Log Read 相比，Read Index 省掉了同步 log 的开销，能够大幅提升读的吞吐，一定程度上降低读的时延。其大致流程为：</p>
<ul>
<li>Leader 在收到客户端读请求时，记录下当前的 commit index，称之为 read index。</li>
<li>Leader 向 followers 发起一次心跳包，这一步是为了确保领导权，避免网络分区时少数派 leader 仍处理请求。</li>
<li>等待状态机至少应用到 read index（即 apply index 大于等于 read index）。</li>
<li>执行读请求，将状态机中的结果返回给客户端。</li>
</ul>
<p>这里第三步的 apply index 大于等于 read index 是一个关键点。因为在该读请求发起时，我们将当时的 commit index 记录了下来，只要使客户端读到的内容在该 commit index 之后，那么结果一定都满足线性一致（如不理解可以再次回顾下前文线性一致性的例子以及2.2中的问题一）。</p>
<h3 id="Lease-Read"><a href="#Lease-Read" class="headerlink" title="Lease Read"></a>Lease Read</h3><p>与 Read Index 相比，Lease Read 进一步省去了网络交互开销，因此更能显著降低读的时延。基本思路是 leader 设置一个比选举超时（Election Timeout）更短的时间作为租期，在租期内我们可以相信其它节点一定没有发起选举，集群也就一定不会存在脑裂，所以在这个时间段内我们直接读主即可，而非该时间段内可以继续走 Read Index 流程，Read Index 的心跳包也可以为租期带来更新。</p>
<p>Lease Read 可以认为是 Read Index 的时间戳版本，额外依赖时间戳会为算法带来一些不确定性，如果时钟发生漂移会引发一系列问题，因此需要谨慎的进行配置。</p>
<h3 id="Follower-Read"><a href="#Follower-Read" class="headerlink" title="Follower Read"></a>Follower Read</h3><p>在前边两种优化方案中，无论我们怎么折腾，核心思想其实只有两点：</p>
<ul>
<li>保证在读取时的最新 commit index 已经被 apply。</li>
<li>保证在读取时 leader 仍拥有领导权。</li>
</ul>
<p>这两个保证分别对应2.2节所描述的两个问题。</p>
<p>其实无论是 Read Index 还是 Lease Read，最终目的都是为了解决第二个问题。换句话说，读请求最终一定都是由 leader 来承载的。</p>
<p>那么读 follower 真的就不能满足线性一致吗？其实不然，这里我们给出一个可行的读 follower 方案：Follower 在收到客户端的读请求时，向 leader 询问当前最新的 commit index，反正所有日志条目最终一定会被同步到自己身上，follower 只需等待该日志被自己 commit 并 apply 到状态机后，返回给客户端本地状态机的结果即可。这个方案叫做 Follower Read。</p>
<p>注意：Follower Read 并不意味着我们在读过程中完全不依赖 leader 了，在保证线性一致性的前提下完全不依赖 leader 理论上是不可能做到的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/16/6.828-lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/16/6.828-lab/" class="post-title-link" itemprop="url">6.828 lab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-16 14:08:00" itemprop="dateCreated datePublished" datetime="2021-11-16T14:08:00+08:00">2021-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 15:33:06" itemprop="dateModified" datetime="2022-12-26T15:33:06+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<a href="https://www.dingmos.com/index.php/archives/4/">https://www.dingmos.com/index.php/archives/4/</a></p>
<h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><p>实验分为三个部分：</p>
<ul>
<li>熟悉汇编语言、QEMU x86模拟器、PC上电启动过程</li>
<li>检查我们的6.828内核的boot loader程序，它位于lab的boot目录下。</li>
<li>深入研究6.828内核本身的初始模板，位于kernel目录下。</li>
</ul>
<h2 id="MIT6-828-实验环境配置"><a href="#MIT6-828-实验环境配置" class="headerlink" title="MIT6.828 实验环境配置"></a>MIT6.828 实验环境配置</h2><p>使用命令行创建了一个目录<code>~/6.828</code>，在该目录下初始化一个git仓库<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/6.828$ git init</span><br></pre></td></tr></table></figure></p>
<p>把JOS系统源码clone到本地<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/6.828$ git clone https://pdos.csail.mit.edu/6.828/2017/jos.git lab</span><br></pre></td></tr></table></figure></p>
<p>安装QEMU这个仿真器需要先安装包。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsdl1.2-dev</span><br><span class="line">sudo apt-get install libglib2.0-dev</span><br><span class="line">sudo apt-get install libz-dev</span><br><span class="line">sudo apt-get install libpixman-1-dev</span><br><span class="line">sudo apt-get install libtool*</span><br></pre></td></tr></table></figure></p>
<p>打开qemu所在目录，进行configuration<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --disable-kvm --disable-werror --prefix=$HMOE --target-list=&quot;i386-softmmu x86_64-softmmu&quot;</span><br></pre></td></tr></table></figure></p>
<p>最后进行安装。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>安装包时频繁出现依赖问题，把apt-get换成了aptitude无用；最后是换了源解决的，可能是因为在安装中断后更换了源，换回去就好了。</p>
<p>之后又报了Werror。在配置的时候处理werror解决。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --disable-werror --prefix==/usr/local --target-list=&quot;i386-softmmu x86_64-softmmu&quot;</span><br></pre></td></tr></table></figure></p>
<p>QUMU安装好之后，make lab下的代码报错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lib/printfmt.c:41: undefined reference to `__udivdi3&#x27;</span><br><span class="line">lib/printfmt.c:49: undefined reference to `__umoddi3&#x27;</span><br></pre></td></tr></table></figure></p>
<p>ARM是精简指令集，对求余和除法操作基本上不支持。linux内核源码<code>linux/arch/arm/lib/lib1funcs.S</code>实现支持除法、求模操作等操作的库函数。本来应该多研究下，但是发现有现成的解决方案，我开发环境是64gcc，但需要的是32位，所以安装32位gcc解决问题。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib</span><br></pre></td></tr></table></figure></p>
<p>再次进行make，成功！<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~/6.828/lab$ sudo make</span><br><span class="line">+ ld obj/kern/kernel</span><br><span class="line">+ as boot/boot.S</span><br><span class="line">+ cc -Os boot/main.c</span><br><span class="line">+ ld boot/boot</span><br><span class="line">boot block is 390 bytes (max 510)</span><br><span class="line">+ mk obj/kern/kernel.img</span><br></pre></td></tr></table></figure></p>
<p>之后需要<code>make qemu</code>，又报错了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: 1: /home/yuhao/qemu/: Permission denied</span><br><span class="line">/home/yuhao/qemu/ -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000</span><br><span class="line">make: execvp: /home/yuhao/qemu/: Permission denied</span><br><span class="line">GNUmakefile:156: recipe for target &#x27;qemu&#x27; failed</span><br><span class="line">make: *** [qemu] Error 127</span><br></pre></td></tr></table></figure></p>
<p>应该是qemu的可执行文件配置错误，改一下<code>env.mk</code>。在执行启动简单映像的命令后，又有错误：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLib-WARNING **：21：58：30.131：gmem.c：489：不支持自定义内存分配vtable</span><br><span class="line">(qemu-system-x86_64：23983)：Gtk-WARNING **：21：58：30.175：无法打开显示：</span><br></pre></td></tr></table></figure></p>
<p>出现此问题是因为glib2错误（<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1594304）。">https://bugzilla.redhat.com/show_bug.cgi?id=1594304）。</a></p>
<p>此问题的另一方面是Red Hat和CentOS存储库包含过时的QEMU版本（最近是4）。</p>
<ol>
<li>用qemu-kvm而不是qemu-system-x86_64：<a href="https://www.tecmint.com/install-manage-virtual-machines-in-centos/">https://www.tecmint.com/install-manage-virtual-machines-in-centos/</a></li>
<li>从fedora仓库重新安装/更新所有QEMU软件包（<a href="https://copr-be.cloud.fedoraproject.org/results/fcomida/qemu-4/fedora-30-x86_64/00910942-qemu/）`rpm">https://copr-be.cloud.fedoraproject.org/results/fcomida/qemu-4/fedora-30-x86_64/00910942-qemu/）`rpm</a> -i /path/to/file/file_name.rpm`</li>
<li>自己编译QEMU（<a href="https://www.qemu.org/download/#source）。">https://www.qemu.org/download/#source）。</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-4.1.0-rc2.tar.xz</span><br><span class="line">tar xvJf qemu-4.1.0-rc2.tar.xz</span><br><span class="line">cd qemu-4.1.0-rc2</span><br><span class="line">sudo ./configure --disable-kvm --disable-werror --prefix=$HMOE --target-list=&quot;i386-softmmu x86_64-softmmu&quot;</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">OR</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>运行成功的话终端就会打印出以下字符：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/home/yuhao/6.828/qemu/i386-softmmu/qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log</span><br><span class="line">VNC server running on 127.0.0.1:5900</span><br><span class="line">6828 decimal is XXX octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br></pre></td></tr></table></figure></p>
<p>键入kerninfo，值得注意的是，此内核监视器“直接”在模拟PC的“原始（虚拟）硬件”上运行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">K&gt; kerninfo</span><br><span class="line">Special kernel symbols:</span><br><span class="line">  _start                  0010000c (phys)</span><br><span class="line">  entry  f010000c (virt)  0010000c (phys)</span><br><span class="line">  etext  f0101acd (virt)  00101acd (phys)</span><br><span class="line">  edata  f0113060 (virt)  00113060 (phys)</span><br><span class="line">  end    f01136a0 (virt)  001136a0 (phys)</span><br><span class="line">Kernel executable memory footprint: 78KB</span><br></pre></td></tr></table></figure></p>
<p>细节记录</p>
<ul>
<li>PC中BIOS大小为64k, 物理地址范围0x000f0000-0x000fffff</li>
<li>PC 开机首先0xfffff0处执行 jmp [0xf000,0xe05b] 指令。在gdb中使用si(Step Instruction)进行跟踪。</li>
</ul>
<p>使用gdb进行调试<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ make gdb</span><br><span class="line">GNU gdb (GDB) 6.8-debian</span><br><span class="line">Copyright (C) 2008 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;i486-linux-gnu&quot;.</span><br><span class="line">+ target remote localhost:26000</span><br><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0] 0xffff0:	ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e05b]    0xfe05b:    cmpw   $0xffc8,%cs:(%esi)   # 比较大小，改变PSW</span><br><span class="line">0x0000e05b in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e062]    0xfe062:    jne    0xd241d416           # 不相等则跳转</span><br><span class="line">0x0000e062 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e066]    0xfe066:    xor    %edx,%edx            # 清零edx</span><br><span class="line">0x0000e066 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e068]    0xfe068:    mov    %edx,%ss</span><br><span class="line">0x0000e068 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e06a]    0xfe06a:    mov    $0x7000,%sp</span><br><span class="line">0x0000e06a in ?? ()</span><br></pre></td></tr></table></figure></p>
<p>BIOS运行过程中，它设定了中断描述符表，对VGA显示器等设备进行了初始化。在初始化完PCI总线和所有BIOS负责的重要设备后，它就开始搜索软盘、硬盘、或是CD-ROM等可启动的设备。最终，当它找到可引导磁盘时，BIOS从磁盘读取引导加载程序并将控制权转移给它。</p>
<h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><p>机器的物理地址空间有如下布局：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure></p>
<p>对于6.828，我们将使用传统的硬盘启动机制，这意味着我们的boot loader必须满足于512字节。</p>
<p>boot loader由一个汇编语言源文件<code>boot/boot.S</code>和一个C源文件<code>boot/main.c</code>组成。</p>
<h3 id="boot-S"><a href="#boot-S" class="headerlink" title="boot.S"></a>boot.S</h3><p>BIOS将<code>boot.S</code>这段代码从硬盘的第一个扇区load到物理地址为0x7c00的位置，同时CPU工作在real mode。</p>
<p><code>boot.S</code>需要将CPU的工作模式从实模式转换到32位的保护模式， 并且 jump 到 C 语言程序。</p>
<p>源码阅读，知识点：</p>
<ul>
<li>cli (clear interrupt)</li>
<li>cld (clear direction flag)</li>
</ul>
<blockquote>
<p>df: 方向标志位。在串处理指令中，控制每次操作后si，di的增减。（df=0，每次操作后si、di递增；df=1，每次操作后si、di递减）。</p>
</blockquote>
<p>为了向前兼容早期的PC机，A20地址线接地，所以当地址大于1M范围时，会默认回滚到0处。所以在转向32位模式之前，需要使能A20。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">  outb    %al,$0x60</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>test 逻辑运算指令，对两个操作数进行AND操作，并且修改PSW, test 与 AND 指令唯一不同的地方是，TEST 指令不修改目标操作数。</p>
<ul>
<li><code>test al, 00001001b ;</code>测试位 0 和位 3</li>
</ul>
</li>
<li><p><code>lgdt gdtdesc</code>, 加载全局描述符表，暂时不管全局描述表是如何生成的。</p>
</li>
<li><code>cr0</code>, control register,控制寄存器。<ul>
<li>CR0中包含了6个预定义标志，0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line"># and segment translation that makes virtual addresses</span><br><span class="line"># identical to their physical addresses, so that the</span><br><span class="line"># effective memory map does not change during the switch.</span><br><span class="line">lgdt    gdtdesc</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">movl    %eax, %cr0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="调试boot-S"><a href="#调试boot-S" class="headerlink" title="调试boot.S"></a>调试boot.S</h3><p>设置一个断点在地址0x7c00处，这是boot sector被加载的位置。然后让程序继续运行直到这个断点。跟踪/boot/boot.S文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件obj/boot/boot.asm。你也可以使用GDB的x/i指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。</p>
<p>追踪到bootmain函数中，而且还要具体追踪到<code>readsect()</code>子函数里面。找出和<code>readsect()</code>c语言程序的每一条语句所对应的汇编指令，回到<code>bootmain()</code>，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p>
<p>下面我们将分别分析一下这道练习中所涉及到的两个重要文件，它们一起组成了boot loader。分别是<code>/boot/boot.S</code>和<code>/boot/main.c</code>文件。其中前者是一个汇编文件，后者是一个C语言文件。当BIOS运行完成之后，CPU的控制权就会转移到<code>boot.S</code>文件上。所以我们首先看一下<code>boot.S</code>文件。</p>
<p>　　/boot/boot.S：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  .code16                # Assemble for 16-bit mode</span><br><span class="line">  cli                    # Disable interrupts</span><br></pre></td></tr></table></figure></p>
<p>这几条指令就是boot.S最开始的几句，其中cli是boot.S，也是boot loader的第一条指令。这条指令用于把所有的中断都关闭。因为在BIOS运行期间有可能打开了中断。此时CPU工作在实模式下。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cld                         # String operations increment</span><br></pre></td></tr></table></figure><br>这条指令用于指定之后发生的串处理操作的指针移动方向。在这里现在对它大致了解就够了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">xorw    %ax,%ax             # Segment number zero</span><br><span class="line">movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">movw    %ax,%ss             # -&gt; Stack Segment</span><br></pre></td></tr></table></figure>
<p>这几条命令主要是在把三个段寄存器，ds，es，ss全部清零，因为经历了BIOS，操作系统不能保证这三个寄存器中存放的是什么数。所以这也是为后面进入保护模式做准备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> # Enable A20:</span><br><span class="line"> #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line"> #   address line 20 is tied low, so that addresses higher than</span><br><span class="line"> #   1MB wrap around to zero by default.  This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line"> inb     $0x64,%al               # Wait for not busy</span><br><span class="line"> testb   $0x2,%al</span><br><span class="line"> jnz     seta20.1</span><br><span class="line"></span><br><span class="line"> movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line"> outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line"> inb     $0x64,%al               # Wait for not busy</span><br><span class="line"> testb   $0x2,%al</span><br><span class="line"> jnz     seta20.2</span><br><span class="line"></span><br><span class="line"> movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line"> outb    %al,$0x60</span><br></pre></td></tr></table></figure>
<p>这部分指令就是在准备把CPU的工作模式从实模式转换为保护模式。我们可以看到其中的指令包括inb，outb这样的IO端口命令。所以这些指令都是在对外部设备进行操作。0x64端口属于键盘控制器804x，名称是控制器读取状态寄存器。</p>
<p>不断的检测bit1。bit1的值代表输入缓冲区是否满了，也就是说CPU传送给控制器的数据，控制器是否已经取走了，如果CPU想向控制器传送新的数据的话，必须先保证这一位为0。所以这三条指令会一直等待这一位变为0，才能继续向后运行。</p>
<p>当0x64端口准备好读入数据后，现在就可以写入数据了，所以19~20这两条指令是把0xd1这条数据写入到0x64端口中。当向0x64端口写入数据时，则代表向键盘控制器804x发送指令。这个指令将会被送给0x60端口。</p>
<p>D1指令代表下一次写入0x60端口的数据将被写入给804x控制器的输出端口。可以理解为下一个写入0x60端口的数据是一个控制指令。</p>
<p>然后21~24号指令又开始再次等待，等待刚刚写入的指令D1，是否已经被读取了。</p>
<p>如果指令被读取了，25~26号指令会向控制器输入新的指令，0xdf。这个指令的含义是，使能A20线，代表可以进入保护模式了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">27   # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">28   # and segment translation that makes virtual addresses </span><br><span class="line">29   # identical to their physical addresses, so that the </span><br><span class="line">30   # effective memory map does not change during the switch.</span><br><span class="line">31   lgdt    gdtdesc</span><br><span class="line">32   movl    %cr0, %eax</span><br><span class="line">33   orl     $CR0_PE_ON, %eax</span><br><span class="line">34   movl    %eax, %cr0</span><br></pre></td></tr></table></figure>
<p>首先31号指令<code>lgdt gdtdesc</code>，是把gdtdesc这个标识符的值送入全局映射描述符表寄存器GDTR中。这个GDT表是处理器工作于保护模式下一个非常重要的表。这条指令的功能就是把关于GDT表的一些重要信息存放到CPU的GDTR寄存器中，其中包括GDT表的内存起始地址，以及GDT表的长度。这个寄存器由48位组成，其中低16位表示该表长度，高32位表该表在内存中的起始地址。所以gdtdesc是一个标识符，标识着一个内存地址。从这个内存地址开始之后的6个字节中存放着GDT表的长度和起始地址。我们可以在这个文件的末尾看到gdtdesc，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 # Bootstrap GDT</span><br><span class="line"> 2 .p2align 2                               # force 4 byte alignment</span><br><span class="line"> 3 gdt:</span><br><span class="line"> 4   SEG_NULL                               # null seg</span><br><span class="line"> 5   SEG(STA_X|STA_R, 0x0, 0xffffffff)      # code seg</span><br><span class="line"> 6   SEG(STA_W, 0x0, 0xffffffff)            # data seg</span><br><span class="line"> 7 </span><br><span class="line"> 8 gdtdesc:</span><br><span class="line"> 9   .word   0x17                           # sizeof(gdt) - 1</span><br><span class="line">10   .long   gdt                            # address gdt</span><br></pre></td></tr></table></figure>
<p>其中第3行的gdt是一个标识符，标识从这里开始就是GDT表了。可见这个GDT表中包括三个表项(4,5,6行)，分别代表三个段，null seg，code seg，data seg。由于xv6其实并没有使用分段机制，也就是说数据和代码都是写在一起的，所以数据段和代码段的起始地址都是0x0，大小都是0xffffffff=4GB。</p>
<p>在第4~6行是调用SEG()子程序来构造GDT表项的。这个子函数定义在mmu.h中，形式如下：　　<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　<span class="meta">#<span class="keyword">define</span> SEG(type,base,lim)                    \</span></span><br><span class="line"><span class="meta">.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);    \</span></span><br><span class="line"><span class="meta">.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),        \</span></span><br><span class="line"><span class="meta">(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span></span><br></pre></td></tr></table></figure></p>
<p>可见函数需要3个参数，一是type即这个段的访问权限，二是base，这个段的起始地址，三是lim，即这个段的大小界限。gdt表中的每一个表项的结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_entry_struct</span> &#123;</span></span><br><span class="line">    limit_low:    resb <span class="number">2</span></span><br><span class="line">    base_low:     resb <span class="number">2</span></span><br><span class="line">    base_middle : resb <span class="number">1</span></span><br><span class="line">    access:       resb <span class="number">1</span></span><br><span class="line">    granularity:  resb <span class="number">1</span></span><br><span class="line">    base_high:    resb <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个表项一共8字节，其中<code>limit_low</code>就是limit的低16位。<code>base_low</code>就是base的低16位，依次类推。</p>
<p>然后在<code>gdtdesc</code>处就要存放这个GDT表的信息了，其中0x17是这个表的大小-1 = 0x17 = 23，至于为什么不直接存表的大小24，根据查询是官方规定的。紧接着就是这个表的起始地址gdt。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">27   # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">28   # and segment translation that makes virtual addresses </span><br><span class="line">29   # identical to their physical addresses, so that the </span><br><span class="line">30   # effective memory map does not change during the switch.</span><br><span class="line">31   lgdt    gdtdesc</span><br><span class="line">32   movl    %cr0, %eax</span><br><span class="line">33   orl     $CR0_PE_ON, %eax</span><br><span class="line">34   movl    %eax, %cr0</span><br></pre></td></tr></table></figure>
<p>再回到刚才那里，当加载完GDT表的信息到GDTR寄存器之后。紧跟着3个操作，32~34指令。 这几步操作明显是在修改CR0寄存器的内容。CR0寄存器还有CR1~CR3寄存器都是80x86的控制寄存器。其中$CR0_PE的值定义于”mmu.h”文件中，为0x00000001。可见上面的操作是把CR0寄存器的bit0置1，CR0寄存器的bit0是保护模式启动位，把这一位值1代表保护模式启动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35  ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>
<p>这只是一个简单的跳转指令，这条指令的目的在于把当前的运行模式切换成32位地址模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protcseg:</span><br><span class="line">  # Set up the protected-mode data segment registers</span><br><span class="line">36  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</span><br><span class="line">37  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">38  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">39  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">40  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">41  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br></pre></td></tr></table></figure>
<p>修改这些寄存器的值。这些寄存器都是段寄存器，如果刚刚加载完GDTR寄存器我们必须要重新加载所有的段寄存器的值，而其中CS段寄存器必须通过长跳转指令，即23号指令来进行加载。这样才能是GDTR的值生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Set up the stack pointer and call into C.</span><br><span class="line">42  movl    $start, %esp</span><br><span class="line">43  call bootmain</span><br></pre></td></tr></table></figure>
<p>接下来的指令就是要设置当前的esp寄存器的值，然后准备正式跳转到main.c文件中的bootmain函数处。我们接下来分析一下这个函数的每一条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// read 1st page off disk</span><br><span class="line">1 readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);</span><br></pre></td></tr></table></figure>
<p>这里面调用了一个函数<code>readseg</code>，这个函数在<code>bootmain</code>之后被定义了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void readseg(uchar *pa, uint count, uint offset);</span><br></pre></td></tr></table></figure><br>它的功能从注释上来理解应该是，把距离内核起始地址offset个偏移量存储单元作为起始，将它和它之后的count字节的数据读出送入以pa为起始地址的内存物理地址处。</p>
<p>所以这条指令是把内核的第一个页(4MB = 4096 = SECTSIZE<em>8 = 512</em>8)的内容读取的内存地址ELFHDR(0x10000)处。其实完成这些后相当于把操作系统映像文件的elf头部读取出来放入内存中。</p>
<p>读取完这个内核的elf头部信息后，需要对这个elf头部信息进行验证，并且也需要通过它获取一些重要信息。</p>
<blockquote>
<p>elf文件：elf是一种文件格式，主要被用来把程序存放到磁盘上。是在程序被编译和链接后被创建出来的。一个elf文件包括多个段。对于一个可执行程序，通常包含存放代码的文本段(text section)，存放全局变量的data段，存放字符串常量的rodata段。elf文件的头部就是用来描述这个elf文件如何在存储器中存储。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line"><span class="number">3</span>        <span class="keyword">goto</span> bad;</span><br></pre></td></tr></table></figure>
<p>elf头部信息的magic字段是整个头部信息的开端。并且如果这个文件是格式是ELF格式的话，文件的elf-&gt;magic域应该是=ELF_MAGIC的，所以这条语句就是判断这个输入文件是否是合法的elf可执行文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br></pre></td></tr></table></figure>
<p>我们知道头部中一定包含Program Header Table。这个表格存放着程序中所有段的信息。通过这个表我们才能找到要执行的代码段，数据段等等。所以我们要先获得这个表。</p>
<p>这条指令就可以完成这一点，首先elf是表头起址，而phoff字段代表Program Header Table距离表头的偏移量。所以ph可以被指定为Program Header Table表头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> eph = ph + ELFHDR-&gt;e_phnum;</span><br></pre></td></tr></table></figure>
<p>由于phnum中存放的是Program Header Table表中表项的个数，即段的个数。所以这步操作是吧eph指向该表末尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">    <span class="comment">// as the physical address)</span></span><br><span class="line"><span class="number">7</span>    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure>
<p>这个for循环就是在加载所有的段到内存中。ph-&gt;paddr根据参考文献中的说法指的是这个段在内存中的物理地址。ph-&gt;off字段指的是这一段的开头相对于这个elf文件的开头的偏移量。ph-&gt;filesz字段指的是这个段在elf文件中的大小。ph-&gt;memsz则指的是这个段被实际装入内存后的大小。通常来说memsz一定大于等于filesz，因为段在文件中时许多未定义的变量并没有分配空间给它们。</p>
<p>所以这个循环就是在把操作系统内核的各个段从外存读入内存中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 ((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure>
<p>e_entry字段指向的是这个文件的执行入口地址。所以这里相当于开始运行这个文件。也就是内核文件。 自此就把控制权从boot loader转交给了操作系统的内核。</p>
<p>分析完了程序后，来完成Exercise要求我们做的事情：</p>
<p>在一个terminal中cd到lab目录下，执行<code>make qemu-gdb</code>。再开一个 terminal执行<code>make gdb</code>。</p>
<p>因为BIOS会把boot loader加载到0x7c00的位置，因此设置断点b *0x7c00。再执行c，会看到QUMU终端上显示Booting from hard disk。</p>
<p>执行x/30i 0x7c00就能看到与boot.S中类似的汇编代码了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7c00</span><br><span class="line">Breakpoint 1 at 0x7c00</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[   0:7c00] =&gt; 0x7c00:  cli</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">(gdb) x/30i 0x7c00</span><br><span class="line">=&gt; 0x7c00:      cli</span><br><span class="line">   0x7c01:      cld</span><br><span class="line">   0x7c02:      xor    %eax,%eax</span><br><span class="line">   0x7c04:      mov    %eax,%ds</span><br><span class="line">   0x7c06:      mov    %eax,%es</span><br><span class="line">   0x7c08:      mov    %eax,%ss</span><br><span class="line">   0x7c0a:      in     $0x64,%al</span><br><span class="line">   0x7c0c:      test   $0x2,%al</span><br><span class="line">   0x7c0e:      jne    0x7c0a</span><br><span class="line">   0x7c10:      mov    $0xd1,%al</span><br><span class="line">   0x7c12:      out    %al,$0x64</span><br><span class="line">   0x7c14:      in     $0x64,%al</span><br><span class="line">   0x7c16:      test   $0x2,%al</span><br><span class="line">   0x7c18:      jne    0x7c14</span><br><span class="line">   0x7c1a:      mov    $0xdf,%al</span><br><span class="line">   0x7c1c:      out    %al,$0x60</span><br><span class="line">   0x7c1e:      lgdtl  (%esi)</span><br><span class="line">   0x7c21:      fs jl  0x7c33</span><br><span class="line">   0x7c24:      and    %al,%al</span><br><span class="line">   0x7c26:      or     $0x1,%ax</span><br><span class="line">   0x7c2a:      mov    %eax,%cr0</span><br><span class="line">   0x7c2d:      ljmp   $0xb866,$0x87c32</span><br><span class="line">   0x7c34:      adc    %al,(%eax)</span><br></pre></td></tr></table></figure></p>
<p>这条gdb指令是把存放在0x7c00以及之后30字节的内存里面的指令反汇编出来，我们可以拿它直接和<code>boot.S</code>以及在<code>obj/boot/boot.asm</code>进行比较，这三者在指令上没有区别，只不过在源代码中，我们指定了很多标识符比如set20.1，.start，这些标识符在被汇编成机器代码后都会被转换成真实物理地址。比如set20.1就被转换为0x7c0a，那么在<code>obj/boot/boot.asm</code>中还把这种对应关系列出来了，但是在真实执行时，即第一种情况中，就看不到set20.1标识符了，完全是真实物理地址。</p>
<h2 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h2><p>接下来我们分析boot loader的C语言部分。</p>
<p>首先熟悉以下C指针。 编译运行pointer.c结果。 可以发现 a[],b的地址相差很多，因为两者所存放的段不同。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: a = <span class="number">0xbfa8bdbc</span>, b = <span class="number">0x9e3a160</span>, c = (nil)</span><br><span class="line"><span class="number">2</span>: a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">101</span>, a[<span class="number">2</span>] = <span class="number">102</span>, a[<span class="number">3</span>] = <span class="number">103</span></span><br><span class="line"><span class="number">3</span>: a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">300</span>, a[<span class="number">2</span>] = <span class="number">301</span>, a[<span class="number">3</span>] = <span class="number">302</span></span><br><span class="line"><span class="number">4</span>: a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">400</span>, a[<span class="number">2</span>] = <span class="number">301</span>, a[<span class="number">3</span>] = <span class="number">302</span></span><br><span class="line"><span class="number">5</span>: a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">128144</span>, a[<span class="number">2</span>] = <span class="number">256</span>, a[<span class="number">3</span>] = <span class="number">302</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b = a + 4</span></span><br><span class="line"><span class="number">6</span>: a = <span class="number">0xbfa8bdbc</span>, b = <span class="number">0xbfa8bdc0</span>, c = <span class="number">0xbfa8bdbd</span></span><br></pre></td></tr></table></figure></p>
<p>ELF格式非常强大和复杂，但大多数复杂的部分都是为了支持共享库的动态加载，在6.828课程中并不会用到。在本课程中，我们可以把ELF可执行文件简单地看为带有加载信息的标头，后跟几个程序部分，每个程序部分都是一个连续的代码块或数据，其将被加载到指定内存中。</p>
<p>我们所需要关心的Program Section是：</p>
<ul>
<li>.text : 可执行指令</li>
<li>.rodata: 只读数据段,例如字符串常量。（但是，我们不会费心设置硬件来禁止写入。）</li>
<li>.data : 存放已经初始化的数据</li>
<li>.bss ： 存放未初始化的变量， 但是在ELF中只需要记录.bss的起始地址和长度。Loader and program必须自己将.bss段清零。</li>
</ul>
<p>每个程序头的<code>ph-&gt; p_pa</code>字段包含段的目标物理地址（在这种情况下，它实际上是一个物理地址，尽管ELF规范对该字段的实际含义含糊不清）</p>
<p>BIOS会将引导扇区的内容加载到 0x7c00 的位置，引导程序也就从0x7C00的位置开始执行。我们通过-Ttext 0x7C00将链接地址传递给<code>boot / Makefrag</code>中的链接器，因此链接器将在生成的代码中生成正确的内存地址。</p>
<p>除了部分信息之外，ELF头中还有一个对我们很重要的字段，名为<code>e_entry</code>。该字段保存程序中入口点的链接地址：程序应该开始执行的代码段的存储地址。 在反汇编代码中，可以看到最后call 了 0x10018地址。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br><span class="line">    7d6b:    ff 15 18 00 01 00        call   *0x10018</span><br></pre></td></tr></table></figure></p>
<p>在0x7d6b 打断点后，c 再si一次，发现实际跳转地址位0x10000c<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7d6b</span><br><span class="line">Breakpoint 3 at 0x7d6b</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0x7d6b:    call   *0x10018</span><br><span class="line"></span><br><span class="line">Breakpoint 3, 0x00007d6b in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10000c:    movw   $0x1234,0x472</span><br></pre></td></tr></table></figure></p>
<p>与实际执行objdump -f kernel的 结果一致。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">../kern/kernel:     file format elf32-i386</span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0x0010000c</span><br></pre></td></tr></table></figure></p>
<h2 id="Part3：The-Kernel"><a href="#Part3：The-Kernel" class="headerlink" title="Part3：The Kernel"></a>Part3：The Kernel</h2><p>我们现在将开始更详细地研究JOS内核。（最后你会写一些代码！）。与引导加载程序一样，内核从一些汇编语言代码开始，这些代码设置可以使C语言代码正确执行。</p>
<h3 id="使用虚拟内存来解决位置依赖问题"><a href="#使用虚拟内存来解决位置依赖问题" class="headerlink" title="使用虚拟内存来解决位置依赖问题"></a>使用虚拟内存来解决位置依赖问题</h3><p>操作系统内核通常被链接到非常高的虚拟地址（例如0xf0100000）下运行，以便留下处理器虚拟地址空间的低地址部分供用户程序使用。 在下一个lab中，这种安排的原因将变得更加清晰。</p>
<p>许多机器在地址范围无法达到0xf0100000，因此我们无法指望能够在那里存储内核。相反，我们将使用处理器的内存管理硬件将虚拟地址0xf0100000（内核代码期望运行的链接地址）映射到物理地址0x00100000（引导加载程序将内核加载到物理内存中）。尽管内核的虚拟地址足够高，可以为用户进程留下大量的内存空间，在物理地址中内核将会被加载到1MB的位置，仅次于BIOS。</p>
<p>现在，我们只需映射前4MB的物理内存，这足以让我们启动并运行。 我们使用kern/entrypgdir.c中手写的，静态初始化的页面目录和页表来完成此操作。 现在，你不必了解其工作原理的细节，只需注意其实现的效果。</p>
<p>实现虚拟地址，有一个很重要的寄存器CR0-PG：</p>
<blockquote>
<p>PG：CR0的位31是分页（Paging）标志。当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于物理地址。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位。</p>
</blockquote>
<h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><ol>
<li>使用QEMU和GDB跟踪到JOS内核并停在<code>movl %eax，%cr0</code>。 检查内存为0x00100000和0xf0100000。 现在，使用stepi GDB命令单步执行该指令。 再次检查内存为0x00100000和0xf0100000。 确保你了解刚刚发生的事情。</li>
</ol>
<p>注意实验文档上所说的，硬件实现的页表转换机制将0xf0000000等那些f打头的16进制地址转到0x00100000。GDB调试设置断点时，设置的是物理地址，不是逻辑地址，所以断点设置为kernel的入口地址。</p>
<p>b *0x10000c<br>1<br>不知为何，断点设置到0x100000不行，可能是因为代码段中那一段标号和段标识我不认识。</p>
<p>0x100000处的反汇编代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.globl entry</span><br><span class="line">entry:</span><br><span class="line">	movw	$0x1234,0x472			# warm boot</span><br><span class="line">f0100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh</span><br><span class="line">f0100006:	00 00                	add    %al,(%eax)</span><br><span class="line">f0100008:	fe 4f 52             	decb   0x52(%edi)</span><br><span class="line">f010000b:	e4                   	.byte 0xe4</span><br><span class="line"></span><br><span class="line">f010000c &lt;entry&gt;:</span><br><span class="line">f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472</span><br></pre></td></tr></table></figure></p>
<p>执行过程如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x10000c:    movw   $0x1234,0x472</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0010000c in ?? ()</span><br><span class="line">(gdb) s</span><br><span class="line">Cannot find bounds of current function</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100015:    mov    $0x112000,%eax</span><br><span class="line">0x00100015 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10001a:    mov    %eax,%cr3</span><br><span class="line">0x0010001a in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10001d:    mov    %cr0,%eax</span><br><span class="line">0x0010001d in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100020:    or     $0x80010001,%eax</span><br><span class="line">0x00100020 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100025:    mov    %eax,%cr0</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100028:    mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>当执行到<code>movl %eax,%cr0</code>时，停下，此时查看两处内存结果如下。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100025:    mov    %eax,%cr0</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) x/1x 0x00100000</span><br><span class="line">0x100000:       0x1badb002</span><br><span class="line">(gdb) x/1x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x00000000</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure></p>
<p>因为0xf0100000处不是我们真正装载内核的地方，逻辑地址0xf0100000被映射成了0x00100000，所以低地址处有内容，高地址处无内容。</p>
<p>当单步执行完<code>movl %eax,%cr0</code> 时，停下，此时查看两处内存结果如下。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100028:    mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb) x/1x 0x00100000</span><br><span class="line">0x100000:       0x1badb002</span><br><span class="line">(gdb) x/1x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x1badb002</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure></p>
<p>可以看到高地址处和低地址处值相同了。</p>
<p>原因其实在实验指导书里写着。</p>
<blockquote>
<p>Once CR0_PG is set, memory references are virtual addresses that get translated by the virtual memory hardware to physical addresses. entry_pgdir translates virtual addresses in the range 0xf0000000 through 0xf0400000 to physical addresses 0x00000000 through 0x00400000, as well as virtual addresses 0x00000000 through 0x00400000 to physical addresses 0x00000000 through 0x00400000.</p>
</blockquote>
<p>首先明确cr0是什么。cr0全称是control register 0.下面是wiki中的解释。</p>
<p>The CR0 register is 32 bits long on the 386 and higher processors. On x86-64 processors in long mode, it (and the other control registers) is 64 bits long. CR0 has various control flags that modify the basic operation of the processor.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Bit</th>
<th>Name</th>
<th>Full Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>PE</td>
<td>Protected Mode Enable</td>
<td>If 1, system is in protected mode, else system is in real mode</td>
</tr>
<tr>
<td>1</td>
<td>MP</td>
<td>Monitor co-processor</td>
<td>Controls interaction of WAIT/FWAIT instructions with TS flag in CR0</td>
</tr>
<tr>
<td>2</td>
<td>EM</td>
<td>Emulation</td>
<td>If set, no x87 floating-point unit present, if clear, x87 FPU present</td>
</tr>
<tr>
<td>3</td>
<td>TS</td>
<td>Task switched</td>
<td>Allows saving x87 task context upon a task switch only after x87 instruction used</td>
</tr>
<tr>
<td>4</td>
<td>ET</td>
<td>Extension type</td>
<td>On the 386, it allowed to specify whether the external math coprocessor was an 80287 or 80387</td>
</tr>
<tr>
<td>5</td>
<td>NE</td>
<td>Numeric error</td>
<td>Enable internal x87 floating point error reporting when set, else enables PC style x87 error detection</td>
</tr>
<tr>
<td>16</td>
<td>WP</td>
<td>Write protect</td>
<td>When set, the CPU can’t write to read-only pages when privilege level is 0</td>
</tr>
<tr>
<td>18</td>
<td>AM</td>
<td>Alignment mask</td>
<td>Alignment check enabled if AM set, AC flag (in EFLAGS register) set, and privilege level is 3</td>
</tr>
<tr>
<td>29</td>
<td>NW</td>
<td>Not-write through</td>
<td>Globally enables/disable write-through caching</td>
</tr>
<tr>
<td>30</td>
<td>CD</td>
<td>Cache disable</td>
<td>Globally enables/disable the memory cache</td>
</tr>
<tr>
<td>31</td>
<td>PG</td>
<td>Paging</td>
<td>If 1, enable paging and use the § CR3 register, else disable paging.</td>
</tr>
</tbody>
</table>
</div>
<p>把eax赋给cr0时，eax=0x80110001，对应上面的标志位就能知道发出了什么控制信息。最关键的是PG，这个信号打开了页表机制，以后都会自动将 0xf0000000 到 0xf0400000 的虚拟（逻辑）地址转成 0x00000000 到 0x00400000 的物理地址。</p>
<p>所以此处会自动把0xf0100000转换成0x00100000，所以两者的值相等。</p>
<p>如果映射机制失败，我觉得<code>jmp *%eax</code>之后会失败。因为此时eax的值是0xf010002f，如果没有地址映射，那会指向这个物理高地址，而不是本应指向的0x100000附近的低地址，就会出错。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100025:    mov    $0xf010002c,%eax</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) </span><br><span class="line">=&gt; 0x10002a:    jmp    *%eax</span><br><span class="line">0x0010002a in ?? ()</span><br><span class="line">(gdb) </span><br><span class="line">=&gt; 0xf010002c &lt;relocated&gt;:      add    %al,(%eax)</span><br><span class="line">relocated () at kern/entry.S:74</span><br><span class="line">74              movl    $0x0,%ebp                       # nuke frame pointer</span><br><span class="line">(gdb) </span><br><span class="line">Remote connection closed</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure></p>
<p>上面是注释掉<code>movl %eax,%cr0</code>之后的调试结果。果然，跳转之后的第一条指令就报错了。</p>
<p>在entry.S中说：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The kernel (this code) is linked at address ~(KERNBASE + 1 Meg),</span><br></pre></td></tr></table></figure><br>在程序编译后，被链接到高地址处。在kernel.ld链接脚本文件里指定了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Link the kernel at this address: &quot;.&quot; means the current address */</span><br><span class="line">    . = 0xF0100000;</span><br></pre></td></tr></table></figure></p>
<p>但是bootloader 实际把kernel加载到了0x100000的位置</p>
<h3 id="格式化输出到控制台"><a href="#格式化输出到控制台" class="headerlink" title="格式化输出到控制台"></a>格式化输出到控制台</h3><p>激动人心的时刻到了，我们终于到了能对设备进行操作的阶段了。能打印出信息，是实现交互的开始，也是我们之后调试的一个重要途径。</p>
<p>大多数人都把<code>printf()</code>这样的函数认为是理所当然的，有时甚至认为它们是C语言的“原语“。但在OS内核中，我们必须自己实现所有I/O.</p>
<p>阅读<code>kern/printf.c</code>，<code>lib/printfmt.c</code>，<code>kern/console.c</code>三个源代码，理清三者之间的关系。</p>
<p><code>printf.c</code>基于<code>printfmt()</code>和 kernel console’s cputchar()；</p>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><p>我们省略了一小段代码 - 使用“％o”形式的模式打印八进制数所需的代码。 查找并填写此代码片段。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case &#x27;o&#x27;:</span><br><span class="line">            // Replace this with your code.</span><br><span class="line">            putch(&#x27;0&#x27;, putdat);</span><br><span class="line">            num = getuint(&amp;ap, lflag);</span><br><span class="line">            base = 8;</span><br><span class="line">            goto number;</span><br></pre></td></tr></table></figure><br>就是把%u的代码复制一遍，base 改为 8 就差不多了，并不复杂。</p>
<blockquote>
<p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p>
</blockquote>
<p><code>printf.c</code>中使用了<code>console.c</code>中的<code>cputchar</code>函数，并封装为<code>putch</code>函数。并以函数形参传递到<code>printfmt.c</code>中的<code>vprintfmt</code>函数，用于向屏幕上输出一个字符。</p>
<blockquote>
<p>解释console.c中的一段代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What is the purpose of this?</span></span><br><span class="line">    <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">    <span class="comment">// 显示字符数超过CRT一屏可显示的字符数</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">// 清除buf中&quot;第一行&quot;的字符</span></span><br><span class="line">        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">        <span class="comment">// CRT显示器需要对其用空格擦写才能去掉本来以及显示了的字符。</span></span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">            crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="comment">// 显示起点退回到最后一行起始</span></span><br><span class="line">        crt_pos -= CRT_COLS;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>首先理解几个宏定义和函数</p>
<ul>
<li><code>CRT_ROWS</code>，<code>CRT_COLS</code>：CRT显示器行列最大值， 此处是25x80</li>
<li><code>ctr_buf</code>在初始化时指向了显示器I/O地址</li>
</ul>
<p><code>memmove</code>从<code>ctr_buf+CTR_COLS</code>复制到<code>ctr_buf</code>中，就是清除掉第一行的数据，把最后一行给空出来，2~n行的数据（<code>CRT_SIZE - CRT_COLS</code>）个，移动到1~n-1行的位置。</p>
<blockquote>
<p>跟踪执行以下代码，在调用<code>cprintf()</code>时，<code>fmt</code>，<code>ap</code>指向什么？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">&quot;x %d, y %x, z %d\n&quot;</span>, x, y, z);</span><br></pre></td></tr></table></figure>
<p>在<code>kern/init.c</code>的<code>i386_init()</code>下加入代码，就可以直接测试；加<code>Lab1_exercise8_3</code>标号的目的是为了在<code>kern/kernel.asm</code>反汇编代码中容易找到添加的代码的位置。可以看到地址在<code>0xf0100080</code>处<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lab1 Exercise_8</span></span><br><span class="line">&#123;</span><br><span class="line">    cprintf(<span class="string">&quot;Lab1_Exercise_8:\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Lab1_exercise8_3:</span><br><span class="line">    cprintf(<span class="string">&quot;x %d, y %x, z %d\n&quot;</span>, x, y, z);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">    cprintf(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调试过程fmt=0xf010478d ， ap=0xf0118fc4； fmt指向字符串，ap指向栈顶<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf (fmt=0xf010478d &quot;x %d, y %x, z %d\n&quot;) at kern/printf.c:27</span><br></pre></td></tr></table></figure><br>可以看到以上地址处就存了字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0xf010478d</span><br><span class="line">0xf010478d:    &quot;x %d, y %x, z %d\n&quot;</span><br><span class="line"></span><br><span class="line">gdb) si</span><br><span class="line">=&gt; 0xf0102f85 &lt;vcprintf&gt;:    push   %ebp</span><br><span class="line">vcprintf (fmt=0xf010478d &quot;x %d, y %x, z %d\n&quot;, ap=0xf0118fc4 &quot;\001&quot;)</span><br><span class="line">    at kern/printf.c:18</span><br><span class="line">18    &#123;</span><br><span class="line"></span><br><span class="line">(gdb) x/16b 0xf0118fc4</span><br><span class="line">0xf0118fc4:    0x01    0x00    0x00    0x00    0x03    0x00    0x00    0x00</span><br><span class="line">0xf0118fcc:    0x04    0x00    0x00    0x00    0x7b    0x47    0x10    0xf0</span><br></pre></td></tr></table></figure>
<p>引用一段Github上大神做的labclpsz/mit-jos-2014的execise8中的一段话。</p>
<blockquote>
<p>从这个练习可以看出来，正是因为C函数调用实参的入栈顺序是从右到左的，才使得调用参数个数可变的函数成为可能(且不用显式地指出参数的个数)。但是必须有一个方式来告诉实际调用时传入的参数到底是几个，这个是在格式化字符串中指出的。如果这个格式化字符串指出的参数个数和实际传入的个数不一致，比如说传入的参数比格式化字符串指出的要少，就可能会使用到栈上错误的内存作为传入的参数，编译器必须检查出这样的错误。</p>
</blockquote>
<p>4.运行以下代码，输出结果是什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br></pre></td></tr></table></figure>
<p>调试输出了<code>He110 World</code>。<code>57616</code>的十六进制形式为<code>E110</code>，因为是小端机，<code>i</code>的在内存中为<code>0x72</code>，<code>0x6c</code>，<code>0x64</code>，<code>0x00</code>，对应ASCII为<code>rld\0</code>。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>打开文件<code>kern/entry.S</code>，按ctrl+f查找关键字，找找stack这个词出现在哪里，看看每次出现的含义。</p>
<p>77行处将一个宏变量<code>bootstacktop</code>的值赋值给了寄存器<code>esp</code>。而<code>bootstacktop</code>出现在<code>bootstack</code>下，<code>bootstack</code>出现在<code>.data</code>段下，这是数据段。可以肯定，这就是栈了。通过93行<code>.space</code>指令，在<code>bootstack</code>位置处初始化了<code>KSTKSIZE</code>这么多的空间。<code>KSTKSIZE</code>在<code>inc/memlayout.h</code>里面定义，是<code>8*PGSIZE</code>，而<code>PGSIZE</code>在<code>inc/mmu.h</code>中定义，值为4096。</p>
<p>栈在内核入口的汇编代码中初始化，是通过一个汇编指令<code>.space</code>，大小是<code>8 * 4096</code>。接下来看看栈的位置。</p>
<p>查看反汇编代码<code>obj/kern/kernel.asm</code>，<code>bootstacktop</code>的值为<code>0xf010f000</code>。这就是栈的位置，准确来说，是栈顶，栈将向地址值更小的方向生长。</p>
<h3 id="栈的行为"><a href="#栈的行为" class="headerlink" title="栈的行为"></a>栈的行为</h3><p>在正式运行一段代码之前，esp寄存器需要先初始化，正如前文所说。这个初始化可以是手动完成的，如<code>kern/entry.S</code>，也可以是自动完成的，如<code>call</code>指令。程序运行时，esp保存的地址以下的内存，都是栈可以生长，但尚未生长到的。esp表示的是“栈顶地址”stack top。</p>
<p>x86栈指针<code>esp</code>寄存器纸箱栈的最低地址。这个地址之下的都是空闲的。将一个值压入栈需要减小栈指针，同时把值写到栈指针之前指向的地方。在32位机器上，栈只能存储32位的值，<code>esp</code>只能被4整除。</p>
<p>程序“压栈”，就是减小esp，并在刚刚esp指向的位置上写入数据。</p>
<p>还有一个寄存器ebp，意思是base pointer，记录的是当前函数栈的开头。没有指令会自动更新ebp的值，但是任何C编译器都要遵守这个规定，写汇编的程序员也是，调用函数时必须写指令更新ebp寄存器。</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>在执行新的函数<code>callee</code>代码之前，先保存旧函数<code>caller</code>的栈的位置。这样一来，<code>callee</code>才可以返回到正确的指令上。通过ebp寄存器的值，Debugger可以迅速找到调用这个函数的函数，一路找到最开始执行这个函数的函数，这种操作称为<code>backtrace</code>。</p>
<p>看到反汇编代码<code>obj/kern/kernel.asm</code>中，所有C函数的第一个指令都是<code>push %ebp</code>，保存了旧的栈地址。第二个指令都是<code>mov %esp, %ebp</code>，将当前栈地址，也就是函数的栈的开头，保存到<code>ebp</code>。</p>
<h3 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h3><p>函数返回时，寄存器<code>eip</code>，也就是Instruction Pointer，跳转到调用本函数的<code>call</code>指令的下一个指令，且esp增加。栈是向下增长的，所以这其实是在“弹出”。调用函数时，函数接受的参数都被压栈，故返回时相应弹出。</p>
<h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><p>在<code>obj/kern/kernel.asm</code>找到<code>test_backtrace</code>函数，并设置断点。进行调试。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test_backtrace</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	cprintf(<span class="string">&quot;entering test_backtrace %d\n&quot;</span>, x);</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">		test_backtrace(x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		mon_backtrace(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cprintf(<span class="string">&quot;leaving test_backtrace %d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test_backtrace函数对应的汇编代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">f0100040:	55                   	push   %ebp</span><br><span class="line">f0100041:	89 e5                	mov    %esp,%ebp</span><br><span class="line">f0100043:	56                   	push   %esi</span><br><span class="line">f0100044:	53                   	push   %ebx</span><br><span class="line">f0100045:	e8 5b 01 00 00       	call   f01001a5 &lt;\_\_x86.get_pc_thunk.bx&gt;</span><br><span class="line">f010004a:	81 c3 be 12 01 00    	add    $0x112be,%ebx</span><br><span class="line">f0100050:	8b 75 08             	mov    0x8(%ebp),%esi</span><br><span class="line">f0100053:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">f0100056:	56                   	push   %esi</span><br><span class="line">f0100057:	8d 83 18 07 ff ff    	lea    -0xf8e8(%ebx),%eax</span><br><span class="line">f010005d:	50                   	push   %eax</span><br><span class="line">f010005e:	e8 cf 09 00 00       	call   f0100a32 &lt;cprintf&gt;</span><br><span class="line">f0100063:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f0100066:	85 f6                	test   %esi,%esi</span><br><span class="line">f0100068:	7f 2b                	jg     f0100095 &lt;test\_backtrace+0x55&gt;</span><br><span class="line">f010006a:	83 ec 04             	sub    $0x4,%esp</span><br><span class="line">f010006d:	6a 00                	push   $0x0</span><br><span class="line">f010006f:	6a 00                	push   $0x0</span><br><span class="line">f0100071:	6a 00                	push   $0x0</span><br><span class="line">f0100073:	e8 f4 07 00 00       	call   f010086c &lt;mon\_backtrace&gt;</span><br><span class="line">f0100078:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f010007b:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">f010007e:	56                   	push   %esi</span><br><span class="line">f010007f:	8d 83 34 07 ff ff    	lea    -0xf8cc(%ebx),%eax</span><br><span class="line">f0100085:	50                   	push   %eax</span><br><span class="line">f0100086:	e8 a7 09 00 00       	call   f0100a32 &lt;cprintf&gt;</span><br><span class="line">&#125;</span><br><span class="line">f010008b:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f010008e:	8d 65 f8             	lea    -0x8(%ebp),%esp</span><br><span class="line">f0100091:	5b                   	pop    %ebx</span><br><span class="line">f0100092:	5e                   	pop    %esi</span><br><span class="line">f0100093:	5d                   	pop    %ebp</span><br><span class="line">f0100094:	c3                   	ret    </span><br><span class="line">f0100095:	83 ec 0c             	sub    $0xc,%esp</span><br><span class="line">f0100098:	8d 46 ff             	lea    -0x1(%esi),%eax</span><br><span class="line">f010009b:	50                   	push   %eax</span><br><span class="line">f010009c:	e8 9f ff ff ff       	call   f0100040 &lt;test\_backtrace&gt;</span><br><span class="line">f01000a1:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f01000a4:	eb d5                	jmp    f010007b &lt;test\_backtrace+0x3b&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="观察test-backtrace函数调用栈"><a href="#观察test-backtrace函数调用栈" class="headerlink" title="观察test_backtrace函数调用栈"></a>观察test_backtrace函数调用栈</h3><p>下面开始观察test_backtrace函数的调用栈。%esp存储栈顶的位置，%ebp存储调用者栈顶的位置，%eax存储x的值，这几个寄存器需要重点关注，因此我使用gdb的display命令设置每次运行完成后自动打印它们的值，此外我也设置了自动打印栈内被用到的那段内存的数据，以便清楚观察栈的变化情况。Let’s go.</p>
<p>进入test_backtrace(5)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f01000d1:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)</span><br><span class="line">f01000d8:	e8 63 ff ff ff       	call   f0100040 &lt;test\_backtrace&gt;</span><br><span class="line">f01000dd:	83 c4 10             	add    $0x10,%esp</span><br></pre></td></tr></table></figure></p>
<p>test_backtrace函数的调用发生在i386_init函数中，传入的参数x=5.我们将从这里开始跟踪栈内数据的变化情况。各寄存器及栈内的数据如下所示。可见，共有两个4字节的整数被压入栈：</p>
<p>输入参数的值（也就是5）。<br>call指令的下一条指令的地址（也就是f01000dd）。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%esp = 0xf010ffdc</span><br><span class="line">%ebp = 0xf010fff8</span><br><span class="line">// stack info</span><br><span class="line">0xf010ffe0: 0x00000005  // 第1次调用时的输入参数：5</span><br><span class="line">0xf010ffdc: 0xf01000dd  // 第1次调用时的返回地址</span><br></pre></td></tr></table></figure></p>
<p>进入test_backtrace函数后，涉及栈内数据修改的指令可以分为三部分：</p>
<ul>
<li>函数开头，将部分寄存器的值压栈，以便函数结束前可以恢复。</li>
<li>调用cprintf前，将输入参数压入栈。</li>
<li>在第2次调用test_backtrace前，将输入参数压入栈。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// function start</span><br><span class="line">f0100040:	55                   	push   %ebp</span><br><span class="line">f0100041:	89 e5                	mov    %esp,%ebp</span><br><span class="line">f0100043:	56                   	push   %esi</span><br><span class="line">f0100044:	53                   	push   %ebx</span><br><span class="line">// call cprintf</span><br><span class="line">f0100053:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">f0100056:	56                   	push   %esi</span><br><span class="line">f0100057:	8d 83 18 07 ff ff    	lea    -0xf8e8(%ebx),%eax</span><br><span class="line">f010005d:	50                   	push   %eax</span><br><span class="line">f010005e:	e8 cf 09 00 00       	call   f0100a32 &lt;cprintf&gt;</span><br><span class="line">f0100063:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">// call test_backtrace(x-1)</span><br><span class="line">f0100095:	83 ec 0c             	sub    $0xc,%esp</span><br><span class="line">f0100098:	8d 46 ff             	lea    -0x1(%esi),%eax</span><br><span class="line">f010009b:	50                   	push   %eax</span><br><span class="line">f010009c:	e8 9f ff ff ff       	call   f0100040 &lt;test_backtrace&gt;</span><br></pre></td></tr></table></figure>
<p>进入test_backtrace(4)</p>
<p>在即将进入test_backtrace(4)前，栈内数据如下所示。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%esp = 0xf010ffc0</span><br><span class="line">%ebp = 0xf010ffd8</span><br><span class="line">// stack info</span><br><span class="line">0xf010ffe0: 0x00000005  // 第1次调用时的输入参数：5</span><br><span class="line">0xf010ffdc: 0xf01000dd  // 第1次调用时的返回地址</span><br><span class="line">0xf010ffd8: 0xf010fff8  // 第1次调用时寄存器%ebp的值</span><br><span class="line">0xf010ffd4: 0x10094     // 第1次调用时寄存器%esi的值</span><br><span class="line">0xf010ffd0: 0xf0111308  // 第1次调用时寄存器%ebx的值</span><br><span class="line">0xf010ffcc: 0xf010004a  // 残留数据，不需关注</span><br><span class="line">0xf010ffc8: 0x00000000  // 残留数据，不需关注</span><br><span class="line">0xf010ffc4: 0x00000005  // 残留数据，不需关注</span><br><span class="line">0xf010ffc0: 0x00000004  // 第2次调用时的输入参数</span><br></pre></td></tr></table></figure></p>
<p>进入mon_backtrace(0, 0, 0)</p>
<p>在即将进入mon_backtrace(0, 0, 0)前，栈内数据如下所示。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">%esp = 0xf010ff20</span><br><span class="line">%ebp = 0xf010ff38</span><br><span class="line">// stack info</span><br><span class="line">0xf010ffe0: 0x00000005  // 第1次调用时的输入参数：5</span><br><span class="line">0xf010ffdc: 0xf01000dd  // 第1次调用时的返回地址</span><br><span class="line">0xf010ffd8: 0xf010fff8  // 第1次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ffd4: 0x10094     // 第1次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ffd0: 0xf0111308  // 第1次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ffcc: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ffc8: 0x00000000  // 预留空间，不需关注</span><br><span class="line">0xf010ffc4: 0x00000005  // 预留空间，不需关注</span><br><span class="line">0xf010ffc0: 0x00000004  // 第2次调用时的输入参数：4</span><br><span class="line">0xf010ffbc: 0xf01000a1  // 第2次调用时的返回地址</span><br><span class="line">0xf010ffb8: 0xf010ffd8  // 第2次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ffb4: 0x00000005  // 第2次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ffb0: 0xf0111308  // 第2次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ffac: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ffa8: 0x00000000  // 预留空间，不需关注</span><br><span class="line">0xf010ffa4: 0x00000004  // 预留空间，不需关注</span><br><span class="line">0xf010ffa0: 0x00000003  // 第3次调用时的输入参数：3</span><br><span class="line">0xf010ff9c: 0xf01000a1  // 第3次调用时的返回地址</span><br><span class="line">0xf010ff98: 0xf010ffb8  // 第3次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ff94: 0x00000004  // 第3次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ff90: 0xf0111308  // 第3次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ff8c: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ff88: 0xf010ffb8  // 预留空间，不需关注</span><br><span class="line">0xf010ff84: 0x00000003  // 预留空间，不需关注</span><br><span class="line">0xf010ff80: 0x00000002  // 第4次调用时的输入参数：2</span><br><span class="line">0xf010ff7c: 0xf01000a1  // 第4次调用时的返回地址</span><br><span class="line">0xf010ff78: 0xf010ff98  // 第4次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ff74: 0x00000003  // 第4次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ff70: 0xf0111308  // 第4次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ff6c: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ff68: 0xf010ff98  // 预留空间，不需关注</span><br><span class="line">0xf010ff64: 0x00000002  // 预留空间，不需关注</span><br><span class="line">0xf010ff60: 0x00000001  // 第5次调用时的输入参数：1</span><br><span class="line">0xf010ff5c: 0xf01000a1  // 第5次调用时的返回地址</span><br><span class="line">0xf010ff58: 0xf010ff78  // 第5次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ff54: 0x00000002  // 第5次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ff50: 0xf0111308  // 第5次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ff4c: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ff48: 0xf010ff78  // 预留空间，不需关注</span><br><span class="line">0xf010ff44: 0x00000001  // 预留空间，不需关注</span><br><span class="line">0xf010ff40: 0x00000000  // 第6次调用时的输入参数：0</span><br><span class="line">0xf010ff3c: 0xf01000a1  // 第6次调用时的返回地址</span><br><span class="line">0xf010ff38: 0xf010ff58  // 第6次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ff34: 0x00000001  // 第6次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ff30: 0xf0111308  // 第6次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ff2c: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ff28: 0x00000000  // 第7次调用时的第1个输入参数：0</span><br><span class="line">0xf010ff24: 0x00000000  // 第7次调用时的第2个输入参数：0</span><br><span class="line">0xf010ff20: 0x00000000  // 第7次调用时的第3个输入参数：0</span><br></pre></td></tr></table></figure></p>
<p>mon_backtrace函数目前内部为空，不需关注。</p>
<p>退出mon_backtrace(0, 0, 0)：通过add $0x10, %esp语句，将输入参数及预留的4字节从栈中清除。此时%esp = 0xf010ff30，%ebp = 0xf010ff38.</p>
<p>退出test_backtrace(0)：连续3个pop语句将ebx, esi和ebp寄存器依次出栈，然后通过ret语句返回。其他1~5的退出过程类似，不再赘述。</p>
<h3 id="实现backtrace"><a href="#实现backtrace" class="headerlink" title="实现backtrace"></a>实现backtrace</h3><p>Lab中的练习要求我们实现一个backtrace函数，能够打印函数调用的地址和传给函数的参数值。其实CLion的Debugger就有这个功能：</p>
<p>我们要实现的函数，就是可以获得函数此时的ebp寄存器的值、返回的地址、和获得参数的值。</p>
<p>查找<code>mon_backtrace</code>，来到已经准备好的一个函数。函数中写了Your code here注释，让我们在这里实现backtrace功能。我的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> ebp = read_ebp();                <span class="comment">// 拿到ebp的值，类型和函数read_ebp的返回类型一致</span></span><br><span class="line"><span class="type">int</span> *ebp_base_ptr = (<span class="type">int</span> *)ebp;           <span class="comment">// 转化为指针</span></span><br><span class="line"><span class="type">uint32_t</span> eip = ebp_base_ptr[<span class="number">1</span>];   		  <span class="comment">// 拿到返回地址</span></span><br><span class="line">cprintf(<span class="string">&quot;ebp %x, eip %x, args &quot;</span>, ebp, eip);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *args = ebp_base_ptr + <span class="number">2</span>;             <span class="comment">// 拿到进入函数之前的栈地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;             <span class="comment">// 输出参数</span></span><br><span class="line">    cprintf(<span class="string">&quot;%x &quot;</span>, *(args+i));</span><br><span class="line">&#125;</span><br><span class="line">cprintf(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们把读取到的ebp的值转化为了int*类型，这样转化使得对指针的加减法步长和栈中元素长度一致。在x86机器中，地址和int类型同质，长度都是4字节。这样转换之后，无论是加法，还是中括号[]索引，改变的地址都是4字节，而不是1字节，可以恰好改变一个元素的长度。</p>
<p>来看打印得到结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ebp f010ef58, eip f01000a1, args 0 0 0 f010004a f0110308 </span><br></pre></td></tr></table></figure></p>
<p>给函数传的3个参数的值均为0，和打印结果一致！</p>
<p>eip的值正是调用完函数mon_backtrace后一个指令的地址，可以查看反汇编代码obj/kern/kernel.asm，调用函数指令如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">		mon_backtrace(0, 0, 0);</span><br><span class="line">f0100093:	83 ec 04             	sub    $0x4,%esp</span><br><span class="line">f0100096:	6a 00                	push   $0x0</span><br><span class="line">f0100098:	6a 00                	push   $0x0</span><br><span class="line">f010009a:	6a 00                	push   $0x0</span><br><span class="line">f010009c:	e8 e1 07 00 00       	call   f0100882 &lt;mon_backtrace&gt;</span><br><span class="line">f01000a1:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f01000a4:	eb d3                	jmp    f0100079 &lt;test_backtrace+0x39&gt;</span><br></pre></td></tr></table></figure></p>
<p>倒数第二行指令地址正是0xf01000a1！</p>
<h3 id="读取Symbol-Table"><a href="#读取Symbol-Table" class="headerlink" title="读取Symbol Table"></a>读取Symbol Table</h3><p>这个练习要求我们研究函数<code>debuginfo_eip</code>的实现，弄清楚命名为<code>__STAB_*</code>的几个宏的来历和作用，以及将<code>backtrace</code>功能作为命令加入console功能中。</p>
<p>命名为<code>__STAB_*</code>的宏最早在文件<code>kern/kernel.ld</code>中26行出现，<code>__STABSTR_*</code>则在下面一点的34行出现。这个连接器的配置文件，要求连接器生成elf文件时，分配两个segment给到.stab和.stabstr，正如连接器也分配了<code>.data</code>等segment一样。</p>
<p>运行<code>objdump -h obj/kern/kernel</code>查看分配的segment的信息，有关部分如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00001bad  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       000006f4  f0101bc0  00101bc0  00002bc0  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         000043b1  f01022b4  001022b4  000032b4  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .stabstr      00001987  f0106665  00106665  00007665  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .data         00009300  f0108000  00108000  00009000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .got          00000008  f0111300  00111300  00012300  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  6 .got.plt      0000000c  f0111308  00111308  00012308  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  7 .data.rel.local 00001000  f0112000  00112000  00013000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  8 .data.rel.ro.local 00000044  f0113000  00113000  00014000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  9 .bss          00000648  f0113060  00113060  00014060  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 10 .comment      0000002a  00000000  00000000  000146a8  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure></p>
<p>运行<code>objdump -G obj/kern/kernel</code>，查看符号列表Symbol Table，得到有关函数和文件的信息，以下粘贴了部分<code>kern/monitor.c</code>文件有关的信息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of .stab section:</span><br><span class="line"></span><br><span class="line">Symnum n_type n_othr n_desc n_value  n_strx String</span><br><span class="line">...  </span><br><span class="line">375    FUN    0      0      f0100882 1790   mon_backtrace:F(0,1)</span><br><span class="line">376    PSYM   0      0      00000008 1603   argc:p(0,1)</span><br><span class="line">377    PSYM   0      0      0000000c 1768   argv:p(0,2)</span><br><span class="line">378    PSYM   0      0      00000010 1780   tf:p(0,5)</span><br><span class="line">379    SLINE  0      59     00000000 0      </span><br><span class="line">380    SOL    0      0      f0100896 601    ./inc/x86.h</span><br><span class="line">381    SLINE  0      214    00000014 0      </span><br><span class="line">382    SOL    0      0      f0100898 1541   kern/monitor.c</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>知道了<code>__STAB_*</code>的来历，看看它们的作用。文件<code>kern/kdebug.c</code>中函数<code>debuginfo_eip</code>142行调用了这几个宏，整个函数和同一个文件里面的另一个函数<code>stab_binsearch</code>的目的是从<code>.stab</code>和<code>.stabstr</code>两个<code>segment</code>中读取出想要的debug信息，装进一个Eipdebuginfo结构体中。</p>
<p>按照提示，我们首先可以调用<code>read_ebp</code>函数来获取当前ebp寄存器的值。ebp寄存器的值实际上是一个指针，指向当前函数的栈帧的底部（而esp寄存器指向当前函数的栈顶）。我们可以把整个调用栈看做一个数组，其中每个元素均为4字节的整数，并以ebp指针的值为数组起始地址，那么<code>ebp[1]</code>存储的就是函数返回地址，也就是题目中要求的eip的值，<code>ebp[2]</code>以后存储的是输入参数的值。由于题目要求打印5个输入参数，因此需要获取<code>ebp[2]</code>～<code>ebp[6]</code>的值。这样第一条栈信息便可打印出来。</p>
<p>那么怎么打印下一条栈信息呢？还得从ebp入手。当前ebp指针存储的恰好是调用者的ebp寄存器的值，因此当前ebp指针又可以看做是一个链表头，我们通过链表头就可以遍历整个链表。举个例子：假设有A、B、C三个函数，A调用B，B调用C，每个函数都对应有一个栈帧，栈帧的底部地址均存储在当时的ebp寄存器中，不妨记为a_ebp, b_ebp和c_ebp，那么将有c_ebp -&gt; b_ebp -&gt; a_ebp，用程序语言表示就是：<code>a_ebp = (uint32_t *)*b_ebp</code>和<code>b_ebp = (uint32_t *)*c_ebp</code>。</p>
<p>还有一个问题：怎么知道遍历何时结束呢？题目中提示可以参考kern/entry.S，于是我打开此文件，果然找打答案：内核初始化时会将ebp设置为0，因此当我们检查到ebp为0后就应该结束了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Clear the frame pointer register (EBP)</span><br><span class="line"># so that once we get into debugging C code,</span><br><span class="line"># stack backtraces will be terminated properly.</span><br><span class="line">movl	$0x0,%ebp			# nuke frame pointer</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> *ebp;</span><br><span class="line"></span><br><span class="line">    ebp = (<span class="type">uint32_t</span> *)read_ebp();</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ebp)</span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\r\n&quot;</span>, </span><br><span class="line">                ebp, ebp[<span class="number">1</span>], ebp[<span class="number">2</span>], ebp[<span class="number">3</span>], ebp[<span class="number">4</span>], ebp[<span class="number">5</span>], ebp[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">        ebp = (<span class="type">uint32_t</span> *)*ebp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">6828 decimal is 15254 octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff18  eip f0100078  args 00000000 00000000 00000000 f010004a f0111308</span><br><span class="line">  ebp f010ff38  eip f01000a1  args 00000000 00000001 f010ff78 f010004a f0111308</span><br><span class="line">  ebp f010ff58  eip f01000a1  args 00000001 00000002 f010ff98 f010004a f0111308</span><br><span class="line">  ebp f010ff78  eip f01000a1  args 00000002 00000003 f010ffb8 f010004a f0111308</span><br><span class="line">  ebp f010ff98  eip f01000a1  args 00000003 00000004 00000000 f010004a f0111308</span><br><span class="line">  ebp f010ffb8  eip f01000a1  args 00000004 00000005 00000000 f010004a f0111308</span><br><span class="line">  ebp f010ffd8  eip f01000dd  args 00000005 00001aac f010fff8 f01000bd 00000000</span><br><span class="line">  ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br></pre></td></tr></table></figure></p>
<h3 id="debuginfo-eip函数实现根据地址寻找行号的功能"><a href="#debuginfo-eip函数实现根据地址寻找行号的功能" class="headerlink" title="debuginfo_eip函数实现根据地址寻找行号的功能"></a>debuginfo_eip函数实现根据地址寻找行号的功能</h3><p>解决这个问题的关键是熟悉stabs每行记录的含义，我折腾了一两小时才搞清楚。首先，使用<code>objdump -G obj/kern/kernel &gt; output.md</code>将内核的符号表信息输出到<code>output.md</code>文件，在<code>output.md</code>文件中可以看到以下片段：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symnum n_type n_othr n_desc n_value  n_strx String</span><br><span class="line">118    FUN    0      0      f01000a6 2987   i386_init:F(0,25)</span><br><span class="line">119    SLINE  0      24     00000000 0      </span><br><span class="line">120    SLINE  0      34     00000012 0      </span><br><span class="line">121    SLINE  0      36     00000017 0      </span><br><span class="line">122    SLINE  0      39     0000002b 0      </span><br><span class="line">123    SLINE  0      43     0000003a 0      </span><br></pre></td></tr></table></figure></p>
<p>这个片段是什么意思呢？首先要理解第一行给出的每列字段的含义：</p>
<ul>
<li><code>Symnum</code>是符号索引，换句话说，整个符号表看作一个数组，Symnum是当前符号在数组中的下标</li>
<li><code>n_type</code>是符号类型，FUN指函数名，SLINE指在text段中的行号</li>
<li><code>n_othr</code>目前没被使用，其值固定为0</li>
<li><code>n_desc</code>表示在文件中的行号</li>
<li><code>n_value</code>表示地址。特别要注意的是，这里只有FUN类型的符号的地址是绝对地址，SLINE符号的地址是偏移量，其实际地址为函数入口地址加上偏移量。比如第3行的含义是地址f01000b8(=0xf01000a6+0x00000012)对应文件第34行。</li>
</ul>
<p>理解stabs每行记录的含义后，调用<code>stab_binsearch</code>便能找到某个地址对应的行号了。由于前面的代码已经找到地址在哪个函数里面以及函数入口地址，将原地址减去函数入口地址即可得到偏移量，再根据偏移量在符号表中的指定区间查找对应的记录即可。代码如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_SLINE, addr - info-&gt;eip_fn_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lfun &lt;= rfun)</span><br><span class="line">&#123;</span><br><span class="line">    info-&gt;eip_line = stabs[lfun].n_desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="给内核模拟器增加backtrace命令，并在mon-backtrace中增加打印文件名、函数名和行号"><a href="#给内核模拟器增加backtrace命令，并在mon-backtrace中增加打印文件名、函数名和行号" class="headerlink" title="给内核模拟器增加backtrace命令，并在mon_backtrace中增加打印文件名、函数名和行号"></a>给内核模拟器增加backtrace命令，并在mon_backtrace中增加打印文件名、函数名和行号</h3><p>给内核模拟器增加backtrace命令。很简单，在<code>kern/monitor.c</code>文件中模仿已有命令添加即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display this list of commands&quot;</span>, mon_help &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;kerninfo&quot;</span>, <span class="string">&quot;Display information about the kernel&quot;</span>, mon_kerninfo &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;backtrace&quot;</span>, <span class="string">&quot;Display a backtrace of the function stack&quot;</span>, mon_backtrace &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="在mon-backtrace中增加打印文件名、函数名和行号"><a href="#在mon-backtrace中增加打印文件名、函数名和行号" class="headerlink" title="在mon_backtrace中增加打印文件名、函数名和行号"></a>在mon_backtrace中增加打印文件名、函数名和行号</h3><p>经过上面的探索，这个问题就很容易解决了。在<code>mon_backtrace</code>中调用<code>debuginfo_eip</code>来获取文件名、函数名和行号即可。注意，返回的<code>Eipdebuginfo</code>结构体的<code>eip_fn_name</code>字段除了函数名外还有一段尾巴，比如<code>test_backtrace:F(0,25)</code>，需要将”:F(0,25)”去掉，可以使用<code>printf(&quot;%.*s&quot;, length, string)</code>来实现。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> *ebp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    ebp = (<span class="type">uint32_t</span> *)read_ebp();</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (ebp)</span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\r\n&quot;</span>, ebp, ebp[<span class="number">1</span>], ebp[<span class="number">2</span>], ebp[<span class="number">3</span>], ebp[<span class="number">4</span>], ebp[<span class="number">5</span>], ebp[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Eipdebuginfo));</span><br><span class="line"></span><br><span class="line">        result = debuginfo_eip(ebp[<span class="number">1</span>], &amp;info);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != result)</span><br><span class="line">            cprintf(<span class="string">&quot;failed to get debuginfo for eip %x.\r\n&quot;</span>, ebp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cprintf(<span class="string">&quot;\t%s:%d: %.*s+%u\r\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, ebp[<span class="number">1</span>] - info.eip_fn_addr);</span><br><span class="line">        ebp = (<span class="type">uint32_t</span> *)*ebp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff18  eip f0100078  args 00000000 00000000 00000000 f010004a f0111308</span><br><span class="line">        kern/init.c:16: test_backtrace+56</span><br><span class="line">  ebp f010ff38  eip f01000a1  args 00000000 00000001 f010ff78 f010004a f0111308</span><br><span class="line">        kern/init.c:16: test_backtrace+97</span><br><span class="line">  ebp f010ff58  eip f01000a1  args 00000001 00000002 f010ff98 f010004a f0111308</span><br><span class="line">	    kern/init.c:16: test_backtrace+97</span><br><span class="line">  ebp f010ff78  eip f01000a1  args 00000002 00000003 f010ffb8 f010004a f0111308</span><br><span class="line">	    kern/init.c:16: test_backtrace+97</span><br><span class="line">  ebp f010ff98  eip f01000a1  args 00000003 00000004 00000000 f010004a f0111308</span><br><span class="line">	    kern/init.c:16: test_backtrace+97</span><br><span class="line">  ebp f010ffb8  eip f01000a1  args 00000004 00000005 00000000 f010004a f0111308</span><br><span class="line">	    kern/init.c:16: test_backtrace+97</span><br><span class="line">  ebp f010ffd8  eip f01000dd  args 00000005 00001aac f010fff8 f01000bd 00000000</span><br><span class="line">	    kern/init.c:43: i386_init+55</span><br><span class="line">  ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003</span><br><span class="line">	    &#123;standard input&#125;:0: &lt;unknown&gt;+0</span><br><span class="line">```:q</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在本实验中，我们将编写操作系统的内存管理代码。 内存管理有两个组成部分。</p>
<p>第一个部分是内核的物理内存分配器，以致于内核可以分配和释放内存。 分配器将以4096字节为操作单位，称为一个页面。 我们的任务是维护一个数据结构，去记录哪些物理页面是空闲的，哪些是已分配的，以及共享每个已分配页面的进程数。 我们还要编写例程来分配和释放内存页面。</p>
<p>内存管理的第二个组件是虚拟内存，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。 当指令使用内存时，x86硬件的内存管理单元（MMU）执行映射，查询一组页表。 我们根据任务提供的规范修改JOS以设置MMU的页面表。</p>
<p>lab2包含的新源文件：</p>
<ul>
<li>inc/memlayout.h</li>
<li>kern/pmap.c</li>
<li>kern/pmap.h</li>
<li>kern/kclock.h</li>
<li>kern/kclock.c</li>
</ul>
<p><code>memlayout.h</code>描述了虚拟地址空间的布局，这是我们需要通过修改<code>pmap.c</code>实现的。<code>memlayout.h</code>和<code>pmap.h</code>定义了<code>PageInfo</code>结构，可以通过这个结构来跟踪那个物理地址是空闲的。<code>kclock.c</code>和<code>kclock.h</code>操作系统的时钟。</p>
<p><code>memlayout.h</code>给贴心的画了个图，很形象的表述了虚拟地址的分布。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Virtual memory <span class="built_in">map</span>:                                Permissions</span><br><span class="line">                                                   kernel/user</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span> Gig --------&gt;  +------------------------------+</span><br><span class="line">                    |                              | RW/--</span><br><span class="line">                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">                    :              .               :</span><br><span class="line">                    :              .               :</span><br><span class="line">                    :              .               :</span><br><span class="line">                    |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span><br><span class="line">                    |                              | RW/--</span><br><span class="line">                    |   Remapped Physical Memory   | RW/--</span><br><span class="line">                    |                              | RW/--</span><br><span class="line">   KERNBASE, ----&gt;  +------------------------------+ <span class="number">0xf0000000</span>      --+</span><br><span class="line">   KSTACKTOP        |     CPU0<span class="string">&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="string">                    | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="string">                    |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="string">                    +------------------------------+                   |</span></span><br><span class="line"><span class="string">                    |     CPU1&#x27;</span>s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="line">                    | - - - - - - - - - - - - - - -|                 PTSIZE</span><br><span class="line">                    |      Invalid <span class="title function_">Memory</span> <span class="params">(*)</span>      | --/--  KSTKGAP    |</span><br><span class="line">                    +------------------------------+                   |</span><br><span class="line">                    :              .               :                   |</span><br><span class="line">                    :              .               :                   |</span><br><span class="line">   MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span><br><span class="line">                    |       Memory-mapped I/O      | RW/--  PTSIZE</span><br><span class="line">ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span><br><span class="line">                    |  Cur. Page <span class="title function_">Table</span> <span class="params">(User R-)</span>   | R-/R-  PTSIZE</span><br><span class="line">   UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="line">                    |          RO PAGES            | R-/R-  PTSIZE</span><br><span class="line">   UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br><span class="line">                    |           RO ENVS            | R-/R-  PTSIZE</span><br><span class="line">UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span><br><span class="line">UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span><br><span class="line">                    +------------------------------+ 0xeebff000</span><br><span class="line">                    |       Empty <span class="title function_">Memory</span> <span class="params">(*)</span>       | --/--  PGSIZE</span><br><span class="line">   USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span><br><span class="line">                    |      Normal User Stack       | RW/RW  PGSIZE</span><br><span class="line">                    +------------------------------+ 0xeebfd000</span><br><span class="line">                    |                              |</span><br><span class="line">                    |                              |</span><br><span class="line">                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">                    .                              .</span><br><span class="line">                    .                              .</span><br><span class="line">                    .                              .</span><br><span class="line">                    |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span><br><span class="line">                    |     Program Data &amp; Heap      |</span><br><span class="line">   UTEXT --------&gt;  +------------------------------+ 0x00800000</span><br><span class="line">   PFTEMP -------&gt;  |       Empty <span class="title function_">Memory</span> <span class="params">(*)</span>       |        PTSIZE</span><br><span class="line">                    |                              |</span><br><span class="line">   UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span><br><span class="line">                    |       Empty <span class="title function_">Memory</span> <span class="params">(*)</span>       |                   |</span><br><span class="line">                    | - - - - - - - - - - - - - - -|                   |</span><br><span class="line">                    |  User STAB <span class="title function_">Data</span> <span class="params">(optional)</span>   |                 PTSIZE</span><br><span class="line">   USTABDATA ----&gt;  +------------------------------+ 0x00200000        |</span><br><span class="line">                    |       Empty <span class="title function_">Memory</span> <span class="params">(*)</span>       |                   |</span><br><span class="line">   0 ------------&gt;  +------------------------------+                 --+</span><br><span class="line"></span><br><span class="line"><span class="params">(*)</span> Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="line">    &quot;Empty Memory&quot; is normally unmapped, but user programs may <span class="built_in">map</span> pages</span><br><span class="line">    there <span class="keyword">if</span> desired.  JOS user programs <span class="built_in">map</span> pages temporarily at UTEMP.</span><br></pre></td></tr></table></figure></p>
<h3 id="回顾：未初始化完成的内存映射"><a href="#回顾：未初始化完成的内存映射" class="headerlink" title="回顾：未初始化完成的内存映射"></a>回顾：未初始化完成的内存映射</h3><p>在Lab 1中，我们做了一个虚拟内存映射，将0xf0000000-0xf0400000映射到物理地址0x00000000-00400000，总共大小为4MB。如果访问任何超出这个范围的虚拟地址，CPU都会出错。</p>
<p>在之后写代码时，代码中的地址都是虚拟地址，翻译成物理地址的过程是硬件实现的，我们不应该想着如何直接操作物理地址。但是，有时将地址转化物理地址可以方便一些操作，在文件<code>inc/memlayout.h</code>和<code>kern/pmap.h</code>中提供了一些宏和函数，方便我们做这样的地址换算。</p>
<p>首先提供了宏<code>KERNBASE</code>，注释说所有物理地址都被映射到这里，值为0xf0000000，正是我们映射的地址。所谓所有，就是已经映射过的地址，不包括还没映射的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All physical memory mapped at this address</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE        0xF0000000</span></span><br></pre></td></tr></table></figure></p>
<p>宏函数<code>KADDR</code>调用了函数<code>_kaddr</code>，将物理地址转化成内核地址，或称虚拟地址，也就是在物理地址的数值上加上了<code>KERNBAE</code>。此时的“所有”物理地址，范围还很小，因为其它的内存映射还没有建立，故可以这样简单地操作。其它内存映射建立之后，物理地址转化为虚拟地址的过程将很复杂。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This macro takes a physical address and returns the corresponding kernel</span></span><br><span class="line"><span class="comment"> * virtual address.  It panics if you pass an invalid physical address. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KADDR(pa) _kaddr(__FILE__, __LINE__, pa)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>*</span><br><span class="line">_kaddr(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">physaddr_t</span> pa)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (PGNUM(pa) &gt;= npages)</span><br><span class="line">                _panic(file, line, <span class="string">&quot;KADDR called with invalid pa %08lx&quot;</span>, pa);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)(pa + KERNBASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相应的反向过程将虚拟地址转化为物理地址，宏函数<code>PADDR</code>做了这样的事情。也就是在输入的虚拟地址上减去<code>KERNBASE</code>，非常简单。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This macro takes a kernel virtual address -- an address that points above</span></span><br><span class="line"><span class="comment"> * KERNBASE, where the machine&#x27;s maximum 256MB of physical memory is mapped --</span></span><br><span class="line"><span class="comment"> * and returns the corresponding physical address.  It panics if you pass it a</span></span><br><span class="line"><span class="comment"> * non-kernel virtual address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PADDR(kva) _paddr(__FILE__, __LINE__, kva)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">physaddr_t</span></span><br><span class="line">_paddr(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">void</span> *kva)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">uint32_t</span>)kva &lt; KERNBASE)</span><br><span class="line">                _panic(file, line, <span class="string">&quot;PADDR called with invalid kva %08lx&quot;</span>, kva);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">physaddr_t</span>)kva - KERNBASE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下为把页转换为物理地址和把物理地址转成页，或者把页转成虚拟地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">physaddr_t</span></span><br><span class="line"><span class="title function_">page2pa</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> (pp - pages) &lt;&lt; PGSHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> PageInfo*</span><br><span class="line"><span class="title function_">pa2page</span><span class="params">(<span class="type">physaddr_t</span> pa)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (PGNUM(pa) &gt;= npages)</span><br><span class="line">                panic(<span class="string">&quot;pa2page called with invalid pa&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> &amp;pages[PGNUM(pa)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>*</span><br><span class="line"><span class="title function_">page2kva</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> KADDR(page2pa(pp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Part-1任务总览"><a href="#Part-1任务总览" class="headerlink" title="Part 1任务总览"></a>Part 1任务总览</h3><p>Lab 2 Part 1让我们完成内核内存初始化，而用户区User Level内存初始化在后面的part中完成。</p>
<p>初始化操作集中在文件<code>kern/pmap.c</code>的函数<code>mem_init</code>中，在内核初始化函数<code>i386_init</code>中调用。在这个part中，我们开始写这个函数以及它将调用的函数，只需要写到<code>check_page_alloc</code>函数的调用之前即可。<code>check_page_alloc</code>这一行之上进行的操作汇总如下。</p>
<ul>
<li>直接调用硬件查看可以使用的内存大小，也就是函数i386_detect_memory。</li>
<li>创建一个内核初始化时的page目录，并设置权限。</li>
<li>创建用于管理page的数组，初始化page分配器组件。</li>
<li>测试page分配器组件。</li>
</ul>
<p>需要我们写的函数有：</p>
<ul>
<li>boot_alloc，page未初始化时的分配器。</li>
<li>page_init, page_alloc, page_free，page分配器组件。</li>
<li>mem_init，总的内存初始化函数。</li>
</ul>
<p>完成分配器之后，我们的目标是让虚拟地址有基础。进程需要更多内存，向内核发出请求，内核利用分配器，将一个由分配器决定的物理地址和由进程决定的虚拟地址关联到一起，称为映射。这是后面的Lab的内容，本文只关心分配，不关心任何形式的映射。</p>
<h3 id="va-list-va-start等等"><a href="#va-list-va-start等等" class="headerlink" title="va_list va_start等等"></a>va_list va_start等等</h3><p>VA函数（variable argument function），参数可变函数。理解这个操作，头脑中需要有栈的概念，参数按序（从右到左）压栈，第一个参数在低地址位置。函数原型为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* va_list;</span><br><span class="line"><span class="comment">// 以4字节为单位对齐</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTSIZEOF(n) (sizeof(n)+sizeof(int)-1)&amp; ~(sizeof(int)-1)</span></span><br><span class="line"><span class="comment">// 求得参数栈的第一个参数地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap, v) (ap = (va_list)&amp;v + _INTSIZEOF(v)) </span></span><br><span class="line"><span class="comment">// 这里很巧妙，ap+SIZE指向下一个参数地址，再返回总体减去size（即又指回了当前变量） </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap, t)   (*(t *) ((ap+=_INTSIZEOF(t)) - _INTSIZEOF(t)) )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap)  (ap = (va_list) 0)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>va_list ap</code>    定义一个变差变量ap</li>
<li><code>va_start(ap, last)</code>    初始化ap,得到可变参数列表的第一个参数的确切地址。实际就是指向参数堆栈的栈顶</li>
<li><code>va_arg(ap, type)</code>    已知变量类型为type的情况下，获得下一个变参变量</li>
<li><code>va_end(ap)</code>    结束操作</li>
</ul>
<p><code>entry_pgdir</code>的写法也是内存映射的一个重要部分。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="type">pde_t</span> entry_pgdir[NPDENTRIES] = &#123;</span><br><span class="line">    <span class="comment">// Map VA&#x27;s [0, 4MB) to PA&#x27;s [0, 4MB)</span></span><br><span class="line">    <span class="comment">// 在数组定义中，这是什么写法？</span></span><br><span class="line">    [<span class="number">0</span>]</span><br><span class="line">        = ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P,</span><br><span class="line">    <span class="comment">// Map VA&#x27;s [KERNBASE, KERNBASE+4MB) to PA&#x27;s [0, 4MB)</span></span><br><span class="line">    [KERNBASE&gt;&gt;PDXSHIFT]</span><br><span class="line">        = ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P + PTE_W</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="两个内存分配器"><a href="#两个内存分配器" class="headerlink" title="两个内存分配器"></a>两个内存分配器</h3><p>有两个分配器，一个是正式的Page分配器，在之后的所有情况下我们都使用这个。另一个是在Page分配器初始化完成之前使用的，更加原始、简单。</p>
<p>在page分配器初始化完成之前，内核在初始化的过程中使用<code>boot_alloc</code>函数分配内存，也可称为boot分配器。这个分配器非常原始，在page分配器初始化完成后，务必不可调用<code>boot_alloc</code>分配内存，以免出现莫名其妙的错误。</p>
<h3 id="page分配器"><a href="#page分配器" class="headerlink" title="page分配器"></a>page分配器</h3><p>Page分配器操作内存是以page为单位的，之后几乎所有管理内存的机制都是以page为单位。page就是将所有的内存地址分成长度相同的一个个区块，每个的长度都是4096Bytes。所有可以分配的内存都注册到一个链表中，通过分配器，可以方便地拿到一个未分配的page。</p>
<p>内存管理组件维护一个链表，称为<code>free list</code>，这个链表将所有未分配的page连起来。需要分配内存时，将链表头部对应的page返回，并将链表头部更新为链表中的下一个元素。</p>
<p>在<code>inc/memlayout.h</code>中定义了这样的结构体，<code>pp_ref</code>是指向这个页面的指针数量，指针<code>pp_link</code>就是链表中常用的next指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> &#123;</span></span><br><span class="line">    <span class="comment">// Next page on the free list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp_link</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pp_ref is the count of pointers (usually in page table entries)</span></span><br><span class="line">    <span class="comment">// to this page, for pages allocated using page_alloc.</span></span><br><span class="line">    <span class="comment">// Pages allocated at boot time using pmap.c&#x27;s</span></span><br><span class="line">    <span class="comment">// boot_alloc do not have valid reference count fields.</span></span><br><span class="line">    <span class="type">uint16_t</span> pp_ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>创建了一个<code>struct PageInfo</code>的数组，数组中第i个成员代表内存中第i个<code>page</code>。故物理地址和数组索引很方便相换算。初始化时，形成一个链表，所有可分配的<code>page</code>都以<code>struct PageInfo</code>的形式存在于链表上。要通过分配器拿到一个<code>page</code>，也就是读取链表开头的节点，这个节点就对应一个<code>page</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pages</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> npages;</span><br></pre></td></tr></table></figure></p>
<p>初始化函数<code>page_init</code>将所有的<code>pp_link</code>初始化指向与自己相邻的<code>PageInfo</code>，如下，这是初步实现，后续还有更新：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initialize page structure and memory free list.</span></span><br><span class="line"><span class="comment">// After this is done, NEVER use boot_alloc again.  ONLY use the page</span></span><br><span class="line"><span class="comment">// allocator functions below to allocate and deallocate physical</span></span><br><span class="line"><span class="comment">// memory via the page_free_list.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line">        <span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line">        <span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line">        <span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line">        <span class="comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span></span><br><span class="line">        <span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line">        <span class="comment">//     is free.</span></span><br><span class="line">        <span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line">        <span class="comment">//     never be allocated.</span></span><br><span class="line">        <span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">        <span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line">        <span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line">        <span class="comment">//     page tables and other data structures?</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Change the code to reflect this.</span></span><br><span class="line">        <span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line">        <span class="comment">// free pages!</span></span><br><span class="line">        <span class="type">size_t</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;</span><br><span class="line">                pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">                pages[i].pp_link = page_free_list;</span><br><span class="line">                page_free_list = &amp;pages[i];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样初始化的操作是在<code>kern/pmap.c</code>中完成的。大概来说，初始化就是拉了这样一个链表，并且将指针<code>page_free_list</code>指向链表的开头。分配内存时，若读取<code>page_free_list</code>指针得到NULL，则说明分配器已经给完了它能够管理的内存，再也给不出来了。</p>
<p>分配器组件的函数都是在操作<code>PageInfo</code>指针，也就是pages数组中的元素，而不是直接操作每个<code>page</code>的地址。如分配函数<code>page_alloc</code>返回的是一个<code>PageInfo</code>，释放<code>page</code>的函数<code>page_free</code>接受的也是一个<code>PageInfo</code>指针。将这个指针和<code>pages</code>数组开头地址做差，可以得到这个<code>PageInfo</code>在数组中的索引，也就可以换算出相应物理地址。</p>
<p>在文件<code>kern/pmap.h</code>中，已经写好了一个函数<code>page2kva</code>，接受一个<code>PageInfo</code>指针，返回得到相应page的虚拟地址。我们可以直接使用这个函数进行换算，这样得到的是虚拟地址，要得到物理地址，还需要在此基础上将地址的数值减去<code>0xf0000000</code>，宏<code>PADDR</code>做了这件事情。</p>
<p>内核的其他代码通过函数<code>page_alloc</code>从<code>free list</code>取出一个<code>page</code>，返回当前<code>page_free_list</code>指针，并令<code>page_free_list</code>指针指向原链表中的下一个元素。</p>
<p>讲义中要求我们实现文件<code>kern/pmap.c</code>中的函数<code>page_alloc</code>，注释中写的比较清楚，分配一个物理页首先需要判断是否还有free的page，如果没有的话就返回NULL。之后从<code>page_free_list</code>中拿出一个page，因为page的指针还指向下一个<code>free_page</code>，所以<code>free_page_list</code>需要指向<code>target-&gt;pp_link</code>，同时<code>target-&gt;pp_link</code>置空。如果需要把页置为0的话，需要转成物理地址然后调用memset。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire</span></span><br><span class="line"><span class="comment">// returned physical page with &#x27;\0&#x27; bytes.  Does NOT increment the reference</span></span><br><span class="line"><span class="comment">// count of the page - the caller must do these if necessary (either explicitly</span></span><br><span class="line"><span class="comment">// or via page_insert).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Be sure to set the pp_link field of the allocated page to NULL so</span></span><br><span class="line"><span class="comment">// page_free can check for double-free bugs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns NULL if out of free memory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: use page2kva and memset</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_alloc</span><span class="params">(<span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// out of memory</span></span><br><span class="line">	<span class="keyword">if</span> (page_free_list == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="comment">// no changes made so far of course</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">target</span> =</span> page_free_list;</span><br><span class="line">	page_free_list = page_free_list-&gt;pp_link;     <span class="comment">// update free list pointer</span></span><br><span class="line">    target-&gt;pp_link = <span class="literal">NULL</span>;                       <span class="comment">// set to NULL according to notes</span></span><br><span class="line">	<span class="type">char</span> *space_head = page2kva(target);          <span class="comment">// extract kernel virtual memory</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;</span><br><span class="line">        <span class="comment">// zero the page according to flags</span></span><br><span class="line">        <span class="built_in">memset</span>(space_head, <span class="number">0</span>, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要释放一个<code>page</code>，也就是将这个<code>page</code>放回链表。将<code>page_free_list</code>指针指向这个<code>PageInfo</code>结构体，并设置这个结构体的<code>pp_link</code>为之前的<code>page_free_list</code>指针。放回链表的这个<code>page</code>也就变成了<code>free list</code>的开头。</p>
<p>讲义中要求我们实现文件<code>kern/pmap.c</code>中的函数<code>page_free</code>，给的提示足够多了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a page to the free list.</span></span><br><span class="line"><span class="comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Fill this function in</span></span><br><span class="line">        <span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">        <span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line">        <span class="keyword">if</span> (pp-&gt;pp_ref != <span class="number">0</span> || pp-&gt;pp_link != <span class="literal">NULL</span>)</span><br><span class="line">                panic(<span class="string">&quot;Page double free or freeing a referenced page...\n&quot;</span>);</span><br><span class="line">        pp-&gt;pp_link = page_free_list;</span><br><span class="line">        page_free_list = pp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="page分配器boot-alloc"><a href="#page分配器boot-alloc" class="headerlink" title="page分配器boot_alloc"></a>page分配器boot_alloc</h3><p><code>page</code>分配组件完成初始化之前，使用<code>boot_alloc</code>函数分配内存，<code>pages</code>数组就是这个函数分配的。</p>
<p>函数接受一个参数，代表要多少字节内存。函数将这个字节数上调到<code>page</code>大小的边界，也就是调整为离这个字节数最近的4096的整数倍，以求每次分配都是以<code>page</code>为单位的。这个分配器只能在<code>page</code>分配器初始化完成之前使用，之后一律使用<code>page</code>分配器。</p>
<p>实现非常简单，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">boot_alloc</span><span class="params">(<span class="type">uint32_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *nextfree;	<span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line">	<span class="type">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">		<span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">		nextfree = ROUNDUP((<span class="type">char</span> *) end, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// special case according to notes</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> nextfree;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// note before update</span></span><br><span class="line">	result = nextfree;</span><br><span class="line">	nextfree = ROUNDUP(n, PGSIZE) + nextfree;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// out of memory panic</span></span><br><span class="line">	<span class="keyword">if</span> (nextfree &gt; (<span class="type">char</span> *)<span class="number">0xf0400000</span>) &#123;</span><br><span class="line">	    panic(<span class="string">&quot;boot_alloc: out of memory, nothing changed, returning NULL...\n&quot;</span>);</span><br><span class="line">	    nextfree = result;    <span class="comment">// reset static data</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一次调用这个函数时，必须初始化nextfree指针。这个初始化也很简单，确定了内核本身在内存中的位置后，让<code>boot_alloc</code>函数在内核所占空间的内存之后的第一个<code>page</code>开始分配。表现为代码，就是从连接器中拿到内核的最后一个字节的地址<code>end</code>，将这个指针的数值上调到4096的整数倍。</p>
<p>其中，需要注意的一个是<code>end</code>到底是什么，另一个是<code>ROUNDUP</code>这个宏。其中，<code>end</code>指向内核的<code>bss</code>段的末尾。利用<code>objdump -h kernel</code>可以看出，<code>bss</code>段已经是内核的最后一段。因此，end 指向的是第一个未使用的虚拟内存地址。而<code>ROUNDUP</code>定义在<code>inc/types.h</code>中。</p>
<p>这个end指针是连接器产生的，可以看连接配置文件<code>kern/kernel.ld</code>的53行左右，end指向内核的最后一个字节的下一个字节。</p>
<h3 id="内核内存布局和分配器初始化"><a href="#内核内存布局和分配器初始化" class="headerlink" title="内核内存布局和分配器初始化"></a>内核内存布局和分配器初始化</h3><p>这里正式讲解page分配器的初始化，也就是<code>page_init</code>函数的实现，正确初始化之后的分配器才可以正确使用<code>page_alloc</code>, <code>page_free</code>等函数。要知道分配器如何初始化，就要理解内核内存的布局Layout。</p>
<h4 id="获得物理内存信息"><a href="#获得物理内存信息" class="headerlink" title="获得物理内存信息"></a>获得物理内存信息</h4><p>在初始化内存组件的函数<code>mem_init</code>中，首先调用了函数<code>i386_detect_memory</code>获得了内存硬件信息。追踪一下这个函数的调用，底层实现在<code>kern/kclock.c</code>中，通过一系列汇编指令向硬件要信息。汇编指令如何执行的，我们暂且不关心。</p>
<p>最终得到的内存信息是两个整数<code>npages</code>, <code>npages_basemem</code>，分别代表现有内存的<code>page</code>个数，以及在拓展内存之前的<code>page</code>个数。这些属于原始硬件信息，获得这个信息是为了确定一段IO映射区的位置。</p>
<p>接着研究现有内存布局。</p>
<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>在文件<code>kern/memlayout.h</code>中，有一个虚拟内存的布局示意图，这个示意图主要描绘用户区内存分配，而不是指出物理内存分布，故我们暂时不细看它。地址0xf0000000以上的区域，也就是我们现在已经映射的区域，是我们关心的区域。宏<code>KERNBASE</code>就是<code>0xf0000000</code>，同时这个地址也是内核栈的开端。以下为了讲述方便，所有地址都是物理内存。</p>
<p>初始化的重要一步是弄清楚哪些物理地址可以分配，哪些不可以。这也就是弄清楚内存布局的意义所在。</p>
<p>我们从KERNBASE开始想起。回顾Lab 1我们知道，内存0xf0000-0x100000是BIOS映射区，在这之前又是ROM映射区，这段空间不能使用，不能被分配器分配出去。查看讲义，我们知道，地址0xa0000-0x100000是ROM, BIOS等IO使用的内存，不可以被分配，初始化时应排除这部分空间。在文件inc/memlayout.h中，宏IOPHYSMEM定义了这段IO段内存的开头。</p>
<p>在<code>IOPHYSMEM</code>之前还有一些内存没有分配，这部分内存是可以使用的。函数<code>i386_detect_memory</code>得到的<code>npages_basemem</code>就是这一段的长度，初始化<code>page</code>分配器时应该包含这一段。可以验证一下，<code>npages_basemem</code>的值为160，这么多个<code>page</code>总的大小为160 * 4096 = 655360 = 0xa0000，确实是<code>IOPHYSMEM</code></p>
<p>从0x100000开始以上的内存就是内核，可以回顾Lab 1中探索内核结构的结果，内核的<code>.text</code>区的虚拟地址为0xf0100000，物理地址正是0x100000。文件<code>inc/memlayout.h</code>中定义的宏<code>EXTPHYSMEM</code>就是0x100000，意思是BIOS以上的内存，称为拓展区，其上限由RAM硬件大小决定。</p>
<p>如果你不记得内核的装载方式，可以使用指令<code>objdump -h obj/kern/kernel</code>查看。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">% obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00002a4d  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       00000bd0  f0102a60  00102a60  00003a60  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         000050d1  f0103630  00103630  00004630  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .stabstr      00001bc3  f0108701  00108701  00009701  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .data         00009300  f010b000  0010b000  0000c000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .got          00000008  f0114300  00114300  00015300  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  6 .got.plt      0000000c  f0114308  00114308  00015308  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  7 .data.rel.local 00001000  f0115000  00115000  00016000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  8 .data.rel.ro.local 00000060  f0116000  00116000  00017000  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  9 .bss          00000681  f0116060  00116060  00017060  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 10 .comment      00000012  00000000  00000000  000176e1  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure></p>
<p>内核占用了拓展区的开头，这些空间不应该被分配器管辖，不应该初始化到链表上。在初始化<code>page</code>分配器之前，调用了几次<code>boot_alloc</code>，这是内核运行时重要数据，他们占用的空间也不应该被分配器管辖。</p>
<p>分配器应该管辖最后一次调用<code>boot_alloc</code>分配的空间之后的空间，这个空间开头的地址可以直接通过<code>boot_alloc(0)</code>得到。</p>
<p>剩余的内存可以自由使用，分配器初始化是应该把链表拉到剩余的空间去。</p>
<h4 id="分配器初始化"><a href="#分配器初始化" class="headerlink" title="分配器初始化"></a>分配器初始化</h4><p><code>mem_init</code>函数中需要添加以下两行，为所有页分配空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span></span><br><span class="line"><span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line"><span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line"><span class="comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span></span><br><span class="line"><span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">pages = (<span class="keyword">struct</span> PageInfo *) boot_alloc(npages * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo));</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo));</span><br></pre></td></tr></table></figure>
<p>初始化就是拉链表，并注意排除不应该纳入分配器管辖的空间。总结上面对内存布局的研究，纳入分配器管辖的总共有两部分，分别是<code>basemem</code>部分，也就是0x0-0xa0000，和<code>boot_alloc</code>最后分配的空间的后面的部分，排除了内核，和一些<code>boot_alloc</code>取得的空间。</p>
<p><code>boot_alloc</code>即将分配的空间可以给函数传0直接得到，这是函数的特殊处理。由于<code>boot_alloc</code>以<code>page</code>为单位分配，这样得到的地址是一个<code>page</code>的首地址，这个<code>page</code>的索引可以轻易获得：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = PADDR(boot_alloc(<span class="number">0</span>)) / PGSIZE;</span><br></pre></td></tr></table></figure></p>
<p>最后分配得到的应该如下图所示，其中basemem部分省略了指针指向。<br><img src="/img/v2-f322c1238767ca4ae172b69548bd4b08_720w.png" alt=""></p>
<p>完整实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.mark page 0 as in use</span></span><br><span class="line"><span class="comment">// 这样我们就可以保留实模式IDT和BIOS结构，以备不时之需。</span></span><br><span class="line">pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// pages[0].pp_link = NULL;</span></span><br><span class="line"><span class="comment">// page_free_lis = &amp;pages[0];</span></span><br><span class="line"><span class="comment">// 被注释掉的这两句不对，因为这个开头的页不能放到free_list中被分配。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)is free.</span></span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">    pages[i].pp_link = page_free_list;</span><br><span class="line">    page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Then comes the IO hole[IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line"><span class="comment">//     never be allocated.</span></span><br><span class="line"><span class="keyword">for</span> (; i &lt; EXTPHYSMEM/PGSIZE; i ++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line"><span class="comment">// 还要注意哪些内存已经被内核、页表使用了！</span></span><br><span class="line"><span class="comment">// first需要向上取整对齐。同时此时已经工作在虚拟地址模式（entry.S对内存进行了映射）下，</span></span><br><span class="line"><span class="comment">// 需要求得first的物理地址</span></span><br><span class="line"><span class="type">physaddr_t</span> first_free_addr = PADDR(boot_alloc(<span class="number">0</span>));</span><br><span class="line"><span class="type">size_t</span> first_free_page = first_free_addr/PGSIZE;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; first_free_page; i ++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark other pages as free</span></span><br><span class="line"><span class="keyword">for</span>(; i &lt; npages; i ++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">    pages[i].pp_link = page_free_list;</span><br><span class="line">    page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以在<code>inc/memlayout.h</code>中找到 IO hole 的定义，可回顾lab 1：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// At IOPHYSMEM (640K) there is a 384K hole for I/O.  From the kernel,</span></span><br><span class="line"><span class="comment">// IOPHYSMEM can be addressed at KERNBASE + IOPHYSMEM.  The hole ends</span></span><br><span class="line"><span class="comment">// at physical address EXTPHYSMEM.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOPHYSMEM   0x0A0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTPHYSMEM  0x100000</span></span><br></pre></td></tr></table></figure></p>
<p>第四种情况略有难度，实际需要利用<code>boot_alloc</code>函数来找到第一个能分配的页面。相同的思想在已经写好的<code>check_free_page_list</code>函数中也可以找到。关键代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> first_free_address = PADDR(boot_alloc(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><br>尤其需要注意的是，由于<code>boot_alloc</code>返回的是内核虚拟地址 (kernel virtual address)，一定要利用 PADDR 转为物理地址。在 kern/pmap.h 中可以找到 PADDR 的定义，实际就是减了一个 F0000000。</p>
<p>完成以上步骤，编译运行，看到<code>check_page_alloc() succeeded!</code>则成功。</p>
<h2 id="Lab-2-Part-2：内核内存映射"><a href="#Lab-2-Part-2：内核内存映射" class="headerlink" title="Lab 2 Part 2：内核内存映射"></a>Lab 2 Part 2：内核内存映射</h2><p>上一篇Part 1实现了分配器，用的是非常简单的链表管理方式。分配器实现的是剩余空间管理Free Space Management，有了剩余空间管理，接下来就是实际使用这些空间了。</p>
<p>这个part帮助我们正式建立虚拟内存Virtual Memory和物理内存Physical Memory之间的关系，明确了概念，完成了实现。在很多操作系统教材中，内存映射放在Free Space Management之前讲。在真正实现内存管理的时候，必须先有分配器、后有其它的，和讲解知识相反。</p>
<h3 id="虚拟地址、线性地址和物理地址"><a href="#虚拟地址、线性地址和物理地址" class="headerlink" title="虚拟地址、线性地址和物理地址"></a>虚拟地址、线性地址和物理地址</h3><p>虚拟地址有段选择器和段内偏移组成，线性地址则是在段地址翻译之后、页地址翻译之前的地址，物理地址则是在段地址翻译、页地址翻译之后的最终的地址，是你从硬件中取数据的地址。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">           Selector  +--------------+         +-----------+</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     | Segmentation |         |  Paging   |</span><br><span class="line">Software             |              |--------&gt;|           |----------&gt;  RAM</span><br><span class="line">            Offset   |  Mechanism   |         | Mechanism |</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     +--------------+         +-----------+</span><br><span class="line">            Virtual                   Linear                Physical</span><br></pre></td></tr></table></figure></p>
<p>C 指针是<strong>虚拟地址的“偏移量”</strong>组件。在<code>boot/boot.S</code>中，我们安装了一个全局描述符表 (GDT)，它通过将所有段基地址设置为 0 并将限制设置为 0xffffffff 来有效地禁用段转换。因此“选择器”不起作用，线性地址总是等于虚拟地址的偏移量。在实验 3 中，我们将不得不与分段进行更多交互以设置权限级别，但是对于记忆翻译，我们可以在整个 JOS 实验中忽略分段，而只关注页面翻译。</p>
<p>回想一下，在实验 1 的第 3 部分中，我们安装了一个简单的页表，以便内核可以在其链接地址 0xf0100000 处运行，即使它实际上加载到 ROM BIOS 上方的物理内存中 0x00100000。这个页表只映射了 4MB 的内存。在本实验中您要为 JOS 设置的虚拟地址空间布局中，我们将扩展它以映射从虚拟地址 0xf0000000 开始的前 256MB 物理内存，并映射虚拟地址空间的许多其他区域。</p>
<h3 id="x86内存管理机制"><a href="#x86内存管理机制" class="headerlink" title="x86内存管理机制"></a>x86内存管理机制</h3><h4 id="虚拟、线性和物理地址"><a href="#虚拟、线性和物理地址" class="headerlink" title="虚拟、线性和物理地址"></a>虚拟、线性和物理地址</h4><ul>
<li>虚拟地址<ul>
<li>最原始的地址，也是 C/C++ 指针使用的地址。由前 16bit 段 (segment) 选择器和后 32bit 段内的偏移 (offset) 组成，显然一个段大小为 4GB。通过虚拟地址可以获得线性地址。</li>
</ul>
</li>
<li>线性地址<ul>
<li>前 10bit 为页目录项(page directory entry, PDE)，即该地址在页目录中的索引。中间 10bit 为页表项(page table entry, PTE)，代表在页表中的索引，最后 12bit 为偏移，也就是每页 4kB。通过线性地址可以获得物理地址。</li>
</ul>
</li>
<li>物理地址<ul>
<li>经过段转换以及页面转换，最终在 RAM 的硬件总线上的地址。</li>
</ul>
</li>
</ul>
<h4 id="两步映射总览"><a href="#两步映射总览" class="headerlink" title="两步映射总览"></a>两步映射总览</h4><p>x86建立了两次映射，程序给出地址，经过这两次翻译之后，才输出从到总线交给内存芯片。这两次映射分别为Segment Translation和Page Translation。</p>
<p>Segment Translation将虚拟地址转化为线性地址Linear Address，Page Translation将线性地址转化为物理地址，也就是真正用来索引内存的地址。</p>
<p>在我们的项目中，还没有对Segment Translation做特殊处理。Lab讲义中说明了，Segment Translation没有映射虚拟地址，线性地址和虚拟地址相同。后文中统一使用“虚拟地址”同时代指虚拟地址和线性地址，因为它们就是一样的。</p>
<p>我们暂时没有使用复杂的Segment Translation，所以Page Translation就是我们的重点，以下简单介绍Segment Translation，着重理解Page Translation。</p>
<h4 id="Segment-Translation"><a href="#Segment-Translation" class="headerlink" title="Segment Translation"></a>Segment Translation</h4><p>Segment Translation的过程可以如下图表示：<br><img src="/img/v2-e856328378b79f84cedece695adee101_b.gif" alt=""></p>
<p>由一个事先指定的selector选择器，从一个描述符表descriptor table中读出一个描述符descriptor。由这个描述符读出一个基地址base address，虚拟地址作为一种偏置offset，加到基地址上，就得到了linear address。</p>
<h4 id="描述符表Descriptor-Table"><a href="#描述符表Descriptor-Table" class="headerlink" title="描述符表Descriptor Table"></a>描述符表Descriptor Table</h4><p>描述符表必须事先指定，虚拟地址中不包含关于描述符表的信息。</p>
<p>有两种描述符表，分别为全局描述符表Global Descriptor Table (GDT)和本地描述符表Local Descriptor Table (LDT)，分别使用寄存器<code>GDTR</code>，<code>LDTR</code>获得。x86有访问这些寄存器的指令，我们没有直接使用，也就不关心了。</p>
<h4 id="描述符Descriptor"><a href="#描述符Descriptor" class="headerlink" title="描述符Descriptor"></a>描述符Descriptor</h4><p>通过selector索引描述符表得到的描述符，除了基地址之外，也包含了其他信息，具体结构如下图：<br><img src="/img/v2-9a1b68fd5f1fbcf1e163f4811ed576ad_b.gif" alt=""></p>
<p>这是两种不同的结构，其中的区别只有DPL和TYPE之间的那个bit，以及TYPE的位置，我们暂时不关心它们的区别。这里需要注意的是P域，也就是Segment Present bit，表示这个segment是否在内存中，之后的Page Translation也有类似机制。</p>
<h4 id="选择符Selector"><a href="#选择符Selector" class="headerlink" title="选择符Selector"></a>选择符Selector</h4><p>选择符不但有描述符表的索引，还有选择描述符表GDT/LDT的bit，以及发出的请求所在的优先级，用于区分User Level Access和Kernel Level Access。我们也暂时不关心它们的区别。结构如下：<br><img src="/img/v2-480829b29d4400a2182dcb58f31603e7_b.gif" alt=""></p>
<h4 id="和segment有关的寄存器"><a href="#和segment有关的寄存器" class="headerlink" title="和segment有关的寄存器"></a>和segment有关的寄存器</h4><p>虚拟地址只是一个segment的偏置，本身不包含和segment有关的信息。当前使用的描述符表、描述符选择符，都要另外存储在一些寄存器里面。当使用和跳转有关的指令call, jmp时，这些寄存器被隐式地访问了，从而帮助计算新的地址。</p>
<p>segment寄存器有两个部分，可以直接操作和读取的是16bit的selector域，修改selector域之后，硬件自动将对应的描述符从描述符表中读取进不显示的descriptor域，这样就方便了后续操作。<br><img src="/img/v2-f00aab967b70bdb3afd7743d902dfbdf_b.gif" alt=""></p>
<h3 id="Page-Translation"><a href="#Page-Translation" class="headerlink" title="Page Translation"></a>Page Translation</h3><p><img src="/img/v2-23f6d73c9f99f646458aac3b79e50e91_b.jpg" alt=""></p>
<p>虚拟地址，也就是线性地址，被拆成了三部分，都是一种索引<code>index</code>，分别索引的是<code>Page Directory</code>, <code>Page Table</code>, <code>Page Frame</code>。从<code>page directory</code>中读出<code>page table</code>的地址，在从读到的<code>page table</code>地址中读到<code>page frame</code>的地址，索引<code>page frame</code>之后，就得到相应物理地址上的内容。</p>
<p>对于开发者来说，<code>page directory</code>, <code>page table</code>都是两个数组，拿到<code>page directory</code>的头部指针，和虚拟地址一起，就可以确定物理地址。</p>
<h4 id="每个域对应长度"><a href="#每个域对应长度" class="headerlink" title="每个域对应长度"></a>每个域对应长度</h4><p>线性地址，也就是虚拟地址，的格式如下：<br><img src="/img/v2-57da610073dc97659f6a52683438bdd7_b.webp" alt=""></p>
<p>每个域包含bit的个数，也就是长度，决定了每个域对应的数组的长度。我们可以很方便地得到每个域对应的长度：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page_len = <span class="number">2</span> ** <span class="number">12</span> = <span class="number">4096</span>            <span class="comment">// OFFSET</span></span><br><span class="line">page_table_len = <span class="number">2</span> ** <span class="number">10</span> = <span class="number">1024</span>      <span class="comment">// PAGE</span></span><br><span class="line">page_dir_len = <span class="number">2</span> ** <span class="number">10</span> = <span class="number">1024</span>        <span class="comment">// DIR</span></span><br></pre></td></tr></table></figure></p>
<p>如果你不太理解这种计算方法，可以回到最开始的排列组合。每个bit代表两种状态，有n个bit也就有<code>2^n</code>种状态，也就是这个域可以产生多少索引。</p>
<p>以上计算出了每个域的长度，单位不是字节，而是索引个数。</p>
<p>这些长度应该这样看。一个<code>page directory</code>指向1024个<code>page directory entry</code>，一个<code>page directory entry</code>指向了1024个<code>page table</code>，一个<code>page table entry</code>指向了1024个<code>page frame</code>，一个<code>page frame</code>中包含4096Bytes。</p>
<h4 id="Entry格式"><a href="#Entry格式" class="headerlink" title="Entry格式"></a>Entry格式</h4><p>page directory entry, page table entry具有相同格式，如下：<br><img src="/img/v2-7645f7dc2a45edeef40540938cc55d8c_b.webp" alt=""></p>
<p><code>DIR</code>, <code>PAGE</code>域长度相同，而<code>entry</code>的格式也相同，说明<code>page directory</code>和<code>page table</code>其实是相同结构的嵌套。可以把<code>page directory</code>理解为高一级的<code>page table</code>，整个内存管理形成两个层级。一个<code>page table</code>自身就是一个<code>page</code>，是<code>page directory</code>管理的，而<code>page table</code>又管理了<code>page frame</code>。</p>
<p>同理，我们可以把虚拟地址拆得更细，从而创造更多的层级，不过这是CPU设计的事情了。</p>
<p>对于<code>page directory</code>来说，<code>entry</code>中12-31位上的<code>PAGE FRAME ADDRESS</code>就是一个<code>page table</code>的基地址。对于<code>page table</code>来说，这个地址是一个<code>page frame</code>的基地址。通过一个虚拟地址，获得3个索引，一次访问这3个结构，就可以得到物理地址了。</p>
<p>这里还要注意一下，bit 0是Present Bit，表示当前entry中的信息是否可以用于映射。要是<code>Present Bit</code>设置为0，则这个entry不包含有效信息。索引各种<code>page directory/table</code>时，必须先检查这个bit。</p>
<p>entry中的其他部分暂时不使用。</p>
<h3 id="可以使用的工具代码"><a href="#可以使用的工具代码" class="headerlink" title="可以使用的工具代码"></a>可以使用的工具代码</h3><p>在开始写代码之前，需要看看项目中已经提供好了哪些可以使用的工具。</p>
<p>首先是上个part中写好的分配器，<code>boot_alloc</code>已经不使用了，主要是<code>page_alloc/page_free</code>在使用。然后就是三个头文件<code>mmu.h</code>, <code>memlayout.h</code>, <code>pmap.h</code>中的各种小函数了</p>
<p>在 JOS 中，由于只有一个段，所以虚拟地址数值上等于线性地址。</p>
<p>JOS 内核常常需要读取或更改仅知道物理地址的内存。例如，添加一个到页表的映射要求分配物理内存来存储页目录并初始化内存。然而，内核和其他任何程序一样，无法绕过虚拟内存转换这个步骤，因此不能直接使用物理地址。JOS 将从 0x00000000 开始的物理内存映射到 0xf0000000 的其中一个原因就是需要使内核能读写仅知道物理地址的内存。为了把物理地址转为虚拟地址，内核需要给物理地址加上 0xf0000000。这就是 KADDR 函数做的事。</p>
<p>同样，JOS 内核有时也需要从虚拟地址获得物理地址。内核的全局变量和由 boot_alloc 分配的内存都在内核被加载的区域，即从0xf0000000开始的地方。因此，若需要将虚拟地址转为物理地址，直接减去0xf0000000即可。这就是 PADDR 函数做的事。</p>
<h4 id="mmu-h"><a href="#mmu-h" class="headerlink" title="mmu.h"></a>mmu.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性地址 &#x27;la&#x27; 可以被分成三块:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +--------10------+-------10-------+---------12----------+</span></span><br><span class="line"><span class="comment">// | Page Directory |   Page Table   | Offset within Page  |</span></span><br><span class="line"><span class="comment">// |      Index     |      Index     |                     |</span></span><br><span class="line"><span class="comment">// +----------------+----------------+---------------------+</span></span><br><span class="line"><span class="comment">//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span></span><br><span class="line"><span class="comment">//  \---------- PGNUM(la) ----------/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PDX, PTX, PGOFF, 和 PGNUM 宏将线性地址进行切分</span></span><br><span class="line"><span class="comment">// 如果需要通过PDX(la), PTX(la), and PGOFF(la)组织一个线性地址la的话</span></span><br><span class="line"><span class="comment">// 使用 PGADDR(PDX(la), PTX(la), PGOFF(la)).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page number field of address</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGNUM(la)       (((uintptr_t) (la)) &gt;&gt; PTXSHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page directory index</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDX(la)         ((((uintptr_t) (la)) &gt;&gt; PDXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page table index</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTX(la)         ((((uintptr_t) (la)) &gt;&gt; PTXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// offset in page</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGOFF(la)       (((uintptr_t) (la)) &amp; 0xFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// construct linear address from indexes and offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGADDR(d, t, o) ((void*) ((d) &lt;&lt; PDXSHIFT | (t) &lt;&lt; PTXSHIFT | (o)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Page directory and page table constants.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPDENTRIES      1024            <span class="comment">// page directory entries per page directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPTENTRIES      1024            <span class="comment">// page table entries per page table</span></span></span><br></pre></td></tr></table></figure>
<p>还有一些页表以及页目录会用到的标识位，exercise 4 中用得到的用中文注释：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Page table/directory entry flags.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_P       0x001   <span class="comment">// 该项是否存在</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W       0x002   <span class="comment">// 可写入</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U       0x004   <span class="comment">// 用户有权限读取</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PWT     0x008   <span class="comment">// Write-Through</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PCD     0x010   <span class="comment">// Cache-Disable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A       0x020   <span class="comment">// Accessed</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_D       0x040   <span class="comment">// Dirty</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PS      0x080   <span class="comment">// Page Size</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_G       0x100   <span class="comment">// Global</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="根据虚拟地址取出Page-Table-Entry"><a href="#根据虚拟地址取出Page-Table-Entry" class="headerlink" title="根据虚拟地址取出Page Table Entry"></a>根据虚拟地址取出Page Table Entry</h3><p>这里开始实现Lab讲义中指定要实现的函数，先是<code>pgdir_walk</code>函数，在文件<code>kern/pmap.c</code>中。这个函数接受一个<code>page directory</code>和一个虚拟地址，要求得到虚拟地址在这个<code>page directory</code>下对应的<code>page table entry</code>。</p>
<p>先拆分虚拟地址，根据虚拟地址取出<code>page directory/table/frame</code>中的索引。用到的三个宏函数在文件<code>mmu.h</code>中，也就是通过移位&gt;&gt;和与&amp;从一串bit中取出一些bit。需要完成如图的转换，返回对应的页表地址，即红圈圈出的部分的虚拟地址：<br><img src="/img/4482847-1941fd6b845db3b5.webp" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">pgdir_walk</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数1: 页目录项指针</span></span><br><span class="line">    <span class="comment">// 参数2: 线性地址，JOS 中等于虚拟地址</span></span><br><span class="line">    <span class="comment">// 参数3: 若页目录项不存在是否创建</span></span><br><span class="line">    <span class="comment">// 返回: 页表项指针</span></span><br><span class="line">    <span class="type">uint32_t</span> page_dir_idx = PDX(va);</span><br><span class="line">    <span class="type">uint32_t</span> page_tab_idx = PTX(va);</span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (pgdir[page_dir_idx] &amp; PTE_P) &#123;</span><br><span class="line">        pgtab = KADDR(PTE_ADDR(pgdir[page_dir_idx]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (create) &#123;</span><br><span class="line">            <span class="keyword">struct</span> PageInfo *new_pageInfo = page_alloc(ALLOC_ZERO);</span><br><span class="line">            <span class="keyword">if</span> (new_pageInfo) &#123;</span><br><span class="line">                new_pageInfo-&gt;pp_ref += <span class="number">1</span>;</span><br><span class="line">                pgtab = (<span class="type">pte_t</span> *) page2kva(new_pageInfo);</span><br><span class="line">                <span class="comment">// 修改页目录的flag，根据 check_page 函数中用到的属性。</span></span><br><span class="line">                <span class="comment">// 因为分配以页为单位对齐，必然后 12bit 为0</span></span><br><span class="line">                pgdir[page_dir_idx] = PADDR(pgtab) | PTE_P | PTE_W | PTE_U;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;pgtab[page_tab_idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要将<code>PageInfo</code>结构体的指针转换为物理地址，而不是虚拟地址。这个操作的依据是80386 Programmer’s Reference Manual的规定，在<code>entry</code>中放置的一定是物理地址。更新完<code>page directory entry</code>之后，原函数<code>pgdir_walk</code>根据虚拟地址中的索引，从新的<code>page directory entry</code>中获得新的<code>page table</code>地址，并返回。</p>
<p>通过宏函数<code>KADDR</code>转化为虚拟地址，而不是直接从page directory entry中读取出来的物理地址。</p>
<h3 id="映射一段空间"><a href="#映射一段空间" class="headerlink" title="映射一段空间"></a>映射一段空间</h3><p>第二个要实现的函数是<code>boot_map_region</code>，这个函数将虚拟地址中的几个<code>page</code>映射到连续的物理地址上。代码很简单，利用刚刚写好的函数<code>pgdir_walk</code>，给参数<code>create</code>传1，就可以方便地建立<code>page table</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="type">size_t</span> end_addr = va + size;</span><br><span class="line">    <span class="keyword">for</span> (;va &lt; end_addr; va += PGSIZE, pa += PGSIZE) &#123;</span><br><span class="line">        pgtab = pgdir_walk(pgdir, (<span class="type">void</span> *)va, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *pgtab = pa | perm | PTE_P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>boot_map_region</code>中的 for 循环一开始就判断<code>va &gt; end_addr</code>。这是显然的，因为<code>end_addr = 0xf0000000 + 0x1000000 = 0x00000000</code>。因此，实际上<code>boot_map_region</code>的更佳实现是直接用页数，避免溢出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="type">size_t</span> pg_num = PGNUM(size);</span><br><span class="line">    cprintf(<span class="string">&quot;map region size = %d, %d pages\n&quot;</span>,size, pg_num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pg_num; i ++) &#123;</span><br><span class="line">        pgtab = pgdir_walk(pgdir, (<span class="type">void</span> *)va, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *pgtab = pa | perm | PTE_P;</span><br><span class="line">        va += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注释中提示我们，这是静态映射，不要增加每个<code>page</code>对应的<code>PageInfo</code>结构体的引用计数<code>pp_ref</code>。</p>
<p>根据各个函数的依赖关系，下一个编写<code>page_lookup</code>函数。作用是查找虚拟地址对应的物理页描述。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_lookup</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, <span class="type">pte_t</span> **pte_store)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数1: 页目录指针</span></span><br><span class="line">    <span class="comment">// 参数2: 线性地址，JOS 中等于虚拟地址</span></span><br><span class="line">    <span class="comment">// 参数3: 指向页表指针的指针</span></span><br><span class="line">    <span class="comment">// 返回: 页描述结构体指针</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab = pgdir_walk(pgdir, va, <span class="number">0</span>);  <span class="comment">// 不创建，只查找</span></span><br><span class="line">    <span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 未找到则返回 NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pte_store) &#123;</span><br><span class="line">        *pte_store = pgtab;  <span class="comment">// 附加保存一个指向找到的页表的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pa2page(PTE_ADDR(*pgtab));  <span class="comment">//  返回页面描述</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处再次用到了<code>PTE_ADDR</code>这个宏。其作用是将页表指针指向的内容转为物理地址。这里还是要注意，从<code>page table</code>中拿出<code>page frame</code>的为物理地址，不是虚拟地址。</p>
<p><code>page_remove</code>函数作用是移除一个虚拟地址与对应的物理页的映射。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_remove</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="type">pte_t</span> **pte_store = &amp;pgtab;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pInfo</span> =</span> page_lookup(pgdir, va, pte_store);</span><br><span class="line">    <span class="keyword">if</span> (!pInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    page_decref(pInfo);</span><br><span class="line">    *pgtab = <span class="number">0</span>;  <span class="comment">// 将内容清0，即无法再根据页表内容得到物理地址。</span></span><br><span class="line">    tlb_invalidate(pgdir, va);  <span class="comment">// 通知tlb失效。tlb是个高速缓存，用来缓存查找记录增加查找速度。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数还减小了<code>PageInfo</code>结构体的引用计数<code>pp_ref</code>，并让TLB缓存失效了。</p>
<p><code>page_insert</code>函数作用是建立一个虚拟地址与物理页的映射，与<code>page_remove</code>对应。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数1: 页目录指针</span></span><br><span class="line">    <span class="comment">// 参数2: 页描述结构体指针</span></span><br><span class="line">    <span class="comment">// 参数3: 线性地址，JOS 中等于虚拟地址</span></span><br><span class="line">    <span class="comment">// 参数4: 权限</span></span><br><span class="line">    <span class="comment">// 返回: 成功(0)，失败(-E_NO_MEM)</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab = pgdir_walk(pgdir, va, <span class="number">1</span>);  <span class="comment">// 查找该虚拟地址对应的页表项，不存在则建立。</span></span><br><span class="line">    <span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;  <span class="comment">// 空间不足</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*pgtab &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// 页表项已经存在，即该虚拟地址已经映射到物理页了</span></span><br><span class="line">        <span class="keyword">if</span> (page2pa(pp) == PTE_ADDR(*pgtab)) &#123;</span><br><span class="line">            <span class="comment">// 如果映射到与之前相同的页，仅更改权限，不增加引用</span></span><br><span class="line">            *pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是更新映射的物理页，则要删除之前的映射关系</span></span><br><span class="line">            page_remove(pgdir, va);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">    pp-&gt;pp_ref++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，如果同样的虚拟页映射到了同样的物理页，如果不做特殊处理仍然调用<code>page_remove</code>后再增加引用次数，可能会出现以下情况：</p>
<ul>
<li>当该物理页<code>ref = 1</code>，经过<code>page_remove</code>后会被加入空闲页链表。然而，在函数最后还需要增加其引用计数，导致<code>page_free_list</code>中出现了非空闲页。</li>
</ul>
<p>课程中希望尽量不要做特例处理，即避免使用if，于是可以这么改进：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pte_t</span> *pgtab = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里一定要提前增加引用 </span></span><br><span class="line">    pp-&gt;pp_ref++;</span><br><span class="line">    <span class="keyword">if</span> (*pgtab &amp; PTE_P) &#123;</span><br><span class="line">        page_remove(pgdir, va);</span><br><span class="line">    &#125;</span><br><span class="line">    *pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上只要区分开了entry中保存的都是物理地址就好弄了。</p>
<h3 id="Page-Table组织总结"><a href="#Page-Table组织总结" class="headerlink" title="Page Table组织总结"></a>Page Table组织总结</h3><p>在Lab 2中，我们让代码跑过了各种<code>check_*</code>函数，但是没有对其中的原理充分深究。这里总结一下。</p>
<p>内核的内存管理是以<code>page</code>为单位的，称为一个<code>Page Frame</code>，一个<code>page</code>的大小是4096Bytes，也就是4KB。内核使用<code>free list</code>链表的方式管理尚未分配的空间，实现非常简单。</p>
<p>要使用内存，必须建立虚拟地址映射。无论是C代码还是汇编代码，要访问内存，都是通过虚拟地址。C代码中，所有指针的值都必须为虚拟地址，代码才能正确执行，否则<code>*</code>访问不到想要的地址。</p>
<p>虚拟地址映射是通过一个<strong>二级table</strong>实现的，两个层级分别被称为<code>Page Directory</code>和<code>Page Table</code>。两者在结构上没有区别，只是相同结构的相互嵌套。虚拟地址不包含任何<code>table</code>的地址，只包含<code>table</code>的索引。必须事先指定好<code>Page Directory</code>的地址，利用这个地址得到<code>Page Directory Entry</code>，从而得到<code>Page Table</code>地址，从而得到<code>Page Frame</code>地址，需要且仅需要指定<code>Page Directory</code>地址。<code>Page Directory</code>地址是寄存器<code>cr3</code>，设置<code>cr3</code>的行为会导致硬件执行切换<code>Page Directory</code>配套的一系列操作。</p>
<p>在函数<code>mem_init</code>之前，内核加载时简单地初始化了一个<code>Page Directory</code>，将<code>0xf0000000</code>开始的一段地址映射到<code>0x0</code>开始的一段地址，以方便正式初始化虚拟地址映射之前的操作。在<code>mem_init</code>函数的最后，我们需要初始化一个真正的<code>kern_pgdir</code>，并将寄存器<code>cr3</code>设置为它的地址。</p>
<p>最终得到的虚拟地址布局为文件<code>memlayout.h</code>中的注释（再来一遍，这个图画的真的太好了）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Virtual memory map:                                Permissions</span><br><span class="line"> *                                                    kernel/user</span><br><span class="line"> *</span><br><span class="line"> *    4 Gig --------&gt;  +------------------------------+</span><br><span class="line"> *                     |                              | RW/--</span><br><span class="line"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> *                     :              .               :</span><br><span class="line"> *                     :              .               :</span><br><span class="line"> *                     :              .               :</span><br><span class="line"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span><br><span class="line"> *                     |                              | RW/--</span><br><span class="line"> *                     |   Remapped Physical Memory   | RW/--</span><br><span class="line"> *                     |                              | RW/--</span><br><span class="line"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</span><br><span class="line"> *    KSTACKTOP        |     CPU0&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="line"> *                     | - - - - - - - - - - - - - - -|                   |</span><br><span class="line"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span><br><span class="line"> *                     +------------------------------+                   |</span><br><span class="line"> *                     |     CPU1&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="line"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</span><br><span class="line"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span><br><span class="line"> *                     +------------------------------+                   |</span><br><span class="line"> *                     :              .               :                   |</span><br><span class="line"> *                     :              .               :                   |</span><br><span class="line"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span><br><span class="line"> *                     |       Memory-mapped I/O      | RW/--  PTSIZE</span><br><span class="line"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span><br><span class="line"> *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE</span><br><span class="line"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="line"> *                     |          RO PAGES            | R-/R-  PTSIZE</span><br><span class="line"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br><span class="line"> *                     |           RO ENVS            | R-/R-  PTSIZE</span><br><span class="line"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span><br><span class="line"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span><br><span class="line"> *                     +------------------------------+ 0xeebff000</span><br><span class="line"> *                     |       Empty Memory (*)       | --/--  PGSIZE</span><br><span class="line"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span><br><span class="line"> *                     |      Normal User Stack       | RW/RW  PGSIZE</span><br><span class="line"> *                     +------------------------------+ 0xeebfd000</span><br><span class="line"> *                     |                              |</span><br><span class="line"> *                     |                              |</span><br><span class="line"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> *                     .                              .</span><br><span class="line"> *                     .                              .</span><br><span class="line"> *                     .                              .</span><br><span class="line"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span><br><span class="line"> *                     |     Program Data &amp; Heap      |</span><br><span class="line"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000</span><br><span class="line"> *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE</span><br><span class="line"> *                     |                              |</span><br><span class="line"> *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span><br><span class="line"> *                     |       Empty Memory (*)       |                   |</span><br><span class="line"> *                     | - - - - - - - - - - - - - - -|                   |</span><br><span class="line"> *                     |  User STAB Data (optional)   |                 PTSIZE</span><br><span class="line"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |</span><br><span class="line"> *                     |       Empty Memory (*)       |                   |</span><br><span class="line"> *    0 ------------&gt;  +------------------------------+                 --+</span><br><span class="line"> *</span><br><span class="line"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="line"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="line"> *     there if desired.  JOS user programs map pages temporarily at UTEMP.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<h3 id="建立映射的函数们"><a href="#建立映射的函数们" class="headerlink" title="建立映射的函数们"></a>建立映射的函数们</h3><p>我们已经写好了很多函数，在把它们用起来之前，再浏览一遍它们的目的。</p>
<p>首先是分配器，对未分配的物理内存进行管理。在初始化函数<code>mem_init</code>中调用<code>page_init</code>初始化了这个分配器，之后通过<code>page_alloc</code>，<code>page_free</code>获取和释放<code>page</code>。</p>
<p>要正确建立映射，首先需要正确方便地索引<code>Page Directory</code>，<code>Page Table</code>。函数<code>pgdir_walk</code>，根据指定<code>Page Directory</code>索引出<code>Page Table Entry</code>。函数<code>page_lookup</code>基于<code>pgdir_walk</code>，进一步得到这个<code>Page Table Entry</code>对应的物理地址。</p>
<p>地址映射可以建立或移除，我们都写好了方便的函数。函数<code>boot_map_region</code>用于给内核做映射，只处理0xf0000000以上虚拟空间。函数<code>page_insert</code>，<code>page_remove</code>处理其他空间的映射，分别建立映射、移除映射。</p>
<p>其他函数对以上起辅助作用。</p>
<h3 id="为内核建立虚拟地址映射"><a href="#为内核建立虚拟地址映射" class="headerlink" title="为内核建立虚拟地址映射"></a>为内核建立虚拟地址映射</h3><p>Lab 2 Part 3要求我们补全函数<code>mem_init</code>后面的部分，也就是给内核配置好<code>kern_pgdir</code>，并设置寄存器<code>cr3</code>。在这里使用的函数都是<code>boot_map_region</code>。</p>
<p>JOS 将处理器的 32 位线性地址空间分为两部分。我们将在 lab3 中开始加载和运行的用户环境（进程）将控制下部的布局和内容，而内核始终保持对上部的完全控制。分隔线由<code>inc/memlayout.h</code>中的符号<code>ULIM</code>随意定义，为内核保留大约 256MB 的虚拟地址空间。这就解释了为什么我们需要在实验室 1 中给内核一个如此高的链接地址：否则内核的虚拟地址空间将没有足够的空间同时映射到它下面的用户环境。</p>
<h4 id="权限和故障隔离"><a href="#权限和故障隔离" class="headerlink" title="权限和故障隔离"></a>权限和故障隔离</h4><p>由于内核和用户内存都存在于每个环境的地址空间中，我们将不得不在 x86 页表中使用权限位来允许用户代码仅访问地址空间的用户部分。否则用户代码中的错误可能会覆盖内核数据，导致崩溃或更微妙的故障；用户代码也可能窃取其他环境的私人数据。请注意，可写权限位<code>PTE_W</code>会影响用户和内核代码！</p>
<p>用户环境将无权访问<code>ULIM</code>之上的任何内存，而内核将能够读写此内存。对于地址范围<code>[UTOP,ULIM)</code>，内核和用户环境都有相同的权限：可以读但不能写这个地址范围。该地址范围用于向用户环境公开某些只读的内核数据结构。最后，UTOP下面的地址空间是供用户环境使用的；用户环境将设置访问此内存的权限。</p>
<p>JOS 将处理器的 32 位线性地址分为用户环境（低位地址）以及内核环境（高位地址）。分界线在<code>inc/memlayout.h</code>中定义为<code>ULIM</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE    0xF0000000</span></span><br><span class="line"><span class="comment">// Kernel stack.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACKTOP   KERNBASE</span></span><br><span class="line"><span class="comment">// Memory-mapped IO.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMIOLIM     (KSTACKTOP - PTSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMIOBASE    (MMIOLIM - PTSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULIM        (MMIOBASE)</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>PTSIZE</code>被定义为一个页目录项映射的 Byte，一个页目录中有1024个页表项，每个页表项可映射一个物理页。故为 4MB。可算得 ULIM = 0xf0000000 - 0x00400000 - 0x00400000 = 0xef800000，可通过查看<code>inc/memlayout</code>确认。</p>
<p>我们还需要给物理页表设置权限以确保用户只能访问用户环境的地址空间。否则，用户的代码可能会覆盖内核数据，造成严重后果。用户环境应该在高于 ULIM 的内存中没有任何权限，而内核则可以读写着部分内存。在 UTOP( 0xeec00000) 到 ULIM 的 12MB 区间中，存储了一些内核数据结构。内核以及用户环境对这部分地址都只具有 read-only 权限。低于 UTOP 的内存则由用户环境自由设置权限使用。</p>
<p>首先是分配器的<code>pages</code>数组，Hints中告诉我们这应该是对用户只读，并映射到<code>UPAGES</code>地址去。<code>UPAGES (0xef000000 ~ 0xef400000)</code>最多4MB，这是 JOS 记录物理页面使用情况的数据结构，即 exercise 1 中完成的东西，只有 kernel 能够访问。由于用户空间同样需要访问这个数据结构，我们将用户空间的一块内存映射到存储该数据结构的物理内存上。很自然联想到了<code>boot_map_region</code>这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, ROUNDUP((<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo)*npages), PGSIZE),PADDR(pages),PTE_U );</span><br></pre></td></tr></table></figure>
<p>需要注意的是目前只建立了一个页目录，即<code>kernel_pgdir</code>，所以第一个参数显然为<code>kernel_pgdir</code>。第二个参数是虚拟地址，<code>UPAGES</code>本来就是以虚拟地址形式给出的。第三个参数是映射的内存块大小。第四个参数是映射到的物理地址，直接取 pages 的物理地址即可。权限<code>PTE_U</code>表示用户有权限读取。</p>
<p>然后是内核的栈，用户不可读写，映射到<code>bootstack</code>地址。内核栈<code>0xefff8000 ~ 0xf0000000</code>为32kB。<code>bootstack</code>表示的是栈地最低地址，由于栈向低地址生长，实际是栈顶。常数<code>KSTACKTOP = 0xf0000000</code>，<code>KSTKSIZE = 32kB</code>。在此之下是一块未映射到物理内存的地址，所以如果栈溢出时，只会报错而不会覆盖数据。因此我们只用映射<code>[KSTACKTOP-KSTKSIZE, KSTACKTOP)</code>区间内的虚拟地址即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE,PADDR(bootstack),PTE_W );</span><br></pre></td></tr></table></figure></p>
<p>这里设置了<code>PTE_W</code>开启了写权限，然而并没有开启<code>PTE_U</code>，于是仅有内核能够读写，用户没有任何权限。</p>
<p>其余的地址全部映射到<code>KERNBASE</code>上，无论物理内存是否有这么大。用户不可读写。内核<code>( 0xf0000000 ~ 0xffffffff )</code>256MB。这里需要映射全部 0xf0000000 至 0xffffffff 共 256MB 的内存地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0x100000000</span> - KERNBASE, <span class="number">0</span>, PTE_U);</span><br></pre></td></tr></table></figure>
<h3 id="为用户建立虚拟地址映射"><a href="#为用户建立虚拟地址映射" class="headerlink" title="为用户建立虚拟地址映射"></a>为用户建立虚拟地址映射</h3><p>这里才是Lab 3的内容。和page类似，内核通过一个<code>struct Env</code>数组<code>envs</code>管理用户环境。函数<code>env_init</code>初始化了这个数组，具体操作和<code>page_init</code>类似，就是拉链表。</p>
<p>函数<code>env_setup_vm</code>为指定的用户环境<code>struct Env</code>初始化虚拟地址映射，得到的是一个<code>pde_t *</code>类型的<code>Page Directory</code>。需要注意以下几点：</p>
<ul>
<li>为<code>Page Directory</code>分配的新<code>page</code>应该增加引用统计次数<code>pp_ref</code>。</li>
<li><code>UTOP</code>以下的地址对用户应该为可读可写的。</li>
<li>可以使用<code>kern_pgdir</code>作为模板，在其基础上更改。</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/176967610">https://zhuanlan.zhihu.com/p/176967610</a></p>
<p><a href="https://www.dingmos.com/index.php/archives/5/">https://www.dingmos.com/index.php/archives/5/</a></p>
<h1 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>lab3 将主要实现能运行被保护的用户模式环境（protected user-mode environment，即 process）的内核服务。我们将增加数据结构来记录进程、创建进程、为其装载一个程序镜像。我们还要让 JOS 内核能够处理进程产生的系统调用和异常。</p>
<p>Lab 3 有如下几个新文件</p>
<ul>
<li><code>inc/env.h</code>：一些用户模式下的环境定义</li>
<li><code>trap.h</code>：trap的定义</li>
<li><code>syscall.h</code>：系统调用的定义，用户空间到内核空间</li>
<li><code>lib.h</code>：用户模式下的定义</li>
<li><code>kern/env.h</code>：内核支持用户模式的一些数据结构定义</li>
<li><code>env.c</code>：内核实现了用户空间</li>
<li><code>trap.h</code>：内核内部实现的处理trap</li>
<li><code>trap.c</code>：trap处理的函数</li>
<li><code>trapentry.S</code>：用汇编实现的进入trap处理的入口</li>
<li><code>syscall.h</code>：内核实现的处理系统调用的函数</li>
<li><code>syscall.c</code>：实现了系统调用</li>
<li><code>lib/Makefrag</code>：生成用户库obj/lib/libjos.a的makefile</li>
<li><code>entry.S</code>：用户环境的入口函数，用汇编实现</li>
<li><code>libmain.c</code>：用户模式的入口</li>
<li><code>syscall.c</code>：用户模式的系统调用入口</li>
<li><code>console.c</code>：putchar和getchar的用户模式下实现，提供了终端的IO</li>
<li><code>exit.c</code>：用户模式下exit的实现</li>
<li><code>panic.c</code>：用户模式下panic的实现</li>
</ul>
<p>在<code>env.h</code>中，定义了<code>envid_t</code>，有三个部分，第一个部分<code>ENVX(eid)</code>环境index与<code>envs[]</code>数组中的环境index一样。<code>uniqueifier</code>用于区分不同情况下创建的环境。第三个部分是用于区分是否是真正的环境、是错误的环境。如果<code>envid_t == 0</code>就是当前的环境。</p>
<p>下边三个宏应该是为env编号以及取出env index用的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span> <span class="type">envid_t</span>;</span><br><span class="line"><span class="comment">// An environment ID &#x27;envid_t&#x27; has three parts:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +1+---------------21-----------------+--------10--------+</span></span><br><span class="line"><span class="comment">// |0|          Uniqueifier             |   Environment    |</span></span><br><span class="line"><span class="comment">// | |                                  |      Index       |</span></span><br><span class="line"><span class="comment">// +------------------------------------+------------------+</span></span><br><span class="line"><span class="comment">//                                       \--- ENVX(eid) --/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The environment index ENVX(eid) equals the environment&#x27;s index in the</span></span><br><span class="line"><span class="comment">// &#x27;envs[]&#x27; array.  The uniqueifier distinguishes environments that were</span></span><br><span class="line"><span class="comment">// created at different times, but share the same environment index.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All real environments are greater than 0 (so the sign bit is zero).</span></span><br><span class="line"><span class="comment">// envid_ts less than 0 signify errors.  The envid_t == 0 is special, and</span></span><br><span class="line"><span class="comment">// stands for the current environment.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG2NENV                10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NENV                    (1 &lt;&lt; LOG2NENV)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENVX(envid)             ((envid) &amp; (NENV - 1))</span></span><br></pre></td></tr></table></figure></p>
<p><code>Env</code>需要存下当前环境下的寄存器、<code>env_id</code>及生成这个env的父亲的id，并将env组织成一个链表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>        <span class="comment">// Saved registers</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>           <span class="comment">// Next free Env</span></span><br><span class="line">        <span class="type">envid_t</span> env_id;                 <span class="comment">// Unique environment identifier</span></span><br><span class="line">        <span class="type">envid_t</span> env_parent_id;          <span class="comment">// env_id of this env&#x27;s parent</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span>          <span class="comment">// Indicates special system environments</span></span><br><span class="line">        <span class="type">unsigned</span> env_status;            <span class="comment">// Status of the environment</span></span><br><span class="line">        <span class="type">uint32_t</span> env_runs;              <span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Address space</span></span><br><span class="line">        <span class="type">pde_t</span> *env_pgdir;               <span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>trap.h</code>中除了定义一些错误和异常的id，主要是定义了两个结构，一个是用于在发生中断时把当前寄存器入栈的结构，另一个是记录这个<code>trap</code>的信息，注意到都使用了<code>__attribute__ ((packed))</code>，它的作用就是告诉编译器取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐，应该是为了去掉无意义的<code>padding</code>避免出错。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> &#123;</span></span><br><span class="line">        <span class="comment">/* registers as pushed by pusha */</span></span><br><span class="line">        <span class="type">uint32_t</span> reg_edi;</span><br><span class="line">        <span class="type">uint32_t</span> reg_esi;</span><br><span class="line">        <span class="type">uint32_t</span> reg_ebp;</span><br><span class="line">        <span class="type">uint32_t</span> reg_oesp;              <span class="comment">/* Useless */</span></span><br><span class="line">        <span class="type">uint32_t</span> reg_ebx;</span><br><span class="line">        <span class="type">uint32_t</span> reg_edx;</span><br><span class="line">        <span class="type">uint32_t</span> reg_ecx;</span><br><span class="line">        <span class="type">uint32_t</span> reg_eax;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">        <span class="type">uint16_t</span> tf_es;</span><br><span class="line">        <span class="type">uint16_t</span> tf_padding1;</span><br><span class="line">        <span class="type">uint16_t</span> tf_ds;</span><br><span class="line">        <span class="type">uint16_t</span> tf_padding2;</span><br><span class="line">        <span class="type">uint32_t</span> tf_trapno;</span><br><span class="line">        <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">        <span class="type">uint32_t</span> tf_err;</span><br><span class="line">        <span class="type">uintptr_t</span> tf_eip;</span><br><span class="line">        <span class="type">uint16_t</span> tf_cs;</span><br><span class="line">        <span class="type">uint16_t</span> tf_padding3;</span><br><span class="line">        <span class="type">uint32_t</span> tf_eflags;</span><br><span class="line">        <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">        <span class="type">uintptr_t</span> tf_esp;</span><br><span class="line">        <span class="type">uint16_t</span> tf_ss;</span><br><span class="line">        <span class="type">uint16_t</span> tf_padding4;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></p>
<p><code>syscall.h</code>中主要是用<code>enum</code>列举现有的<code>syscall</code>的代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* system call numbers */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        SYS_cputs = <span class="number">0</span>,</span><br><span class="line">        SYS_cgetc,</span><br><span class="line">        SYS_getenvid,</span><br><span class="line">        SYS_env_destroy,</span><br><span class="line">        NSYSCALLS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>lib.h</code>主要定义了用户模式下使用的一些函数和变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main user program</span></span><br><span class="line"><span class="type">void</span>    <span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libmain.c or entry.S</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *binaryname;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">thisenv</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> <span class="title">envs</span>[<span class="title">NENV</span>];</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> <span class="title">pages</span>[];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// exit.c</span></span><br><span class="line"><span class="type">void</span>    <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readline.c</span></span><br><span class="line"><span class="type">char</span>*   <span class="title function_">readline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"><span class="type">void</span>    <span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">envid_t</span> <span class="title function_">sys_getenvid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">sys_env_destroy</span><span class="params">(<span class="type">envid_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* File open modes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDONLY        0x0000          <span class="comment">/* open for reading only */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_WRONLY        0x0001          <span class="comment">/* open for writing only */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDWR          0x0002          <span class="comment">/* open for reading and writing */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_ACCMODE       0x0003          <span class="comment">/* mask for above modes */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_CREAT         0x0100          <span class="comment">/* create if nonexistent */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_TRUNC         0x0200          <span class="comment">/* truncate to zero length */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_EXCL          0x0400          <span class="comment">/* error if already exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_MKDIR         0x0800          <span class="comment">/* create directory, not regular file */</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="Part-A-用户环境和异常处理"><a href="#Part-A-用户环境和异常处理" class="headerlink" title="Part A: 用户环境和异常处理"></a>Part A: 用户环境和异常处理</h2><p>新的头文件<code>inc/env.h</code>包含了一些基础的用户环境的定义。内核可以使用这些<code>Env</code>数据结构来管理每一个用户环境。</p>
<p>在<code>kern/env.c</code>，kenerl维护了一组<code>Env</code>结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> =</span> <span class="literal">NULL</span>;		<span class="comment">// All environments</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> =</span> <span class="literal">NULL</span>;		<span class="comment">// The current env</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>	<span class="comment">// Free environment list</span></span><br></pre></td></tr></table></figure></p>
<p>一旦 JOS 启动并运行，<code>envs</code>指针就会指向一个表示系统中所有环境的<code>Env</code>结构数组。 在我们的设计中，JOS 内核将支持最多<code>NENV</code>同时活动的环境，尽管在任何给定时间运行的环境通常要少得多。（<code>NENV</code>是<code>inc/env.h</code>中的常量）。一旦分配，<code>envs</code>数组将包含每个<code>NENV</code>可能环境的<code>Env</code>数据结构的单个实例。</p>
<p>JOS 内核在<code>env_free_list</code>中保留了所有不活动的<code>Env</code>结构。 这种设计允许轻松分配和释放环境，因为它们只需添加到空闲列表或从空闲列表中删除。内核使用<code>curenv</code>符号在任何给定时间跟踪当前正在执行的环境。 在启动期间，在运行第一个环境之前，<code>curenv</code>最初设置为 NULL。</p>
<h3 id="Environment-State"><a href="#Environment-State" class="headerlink" title="Environment State"></a>Environment State</h3><p><code>Env</code>在<code>inc/env.h</code>中定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></span><br><span class="line">	<span class="type">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></span><br><span class="line">	<span class="type">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env&#x27;s parent</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span>		<span class="comment">// Indicates special system environments</span></span><br><span class="line">	<span class="type">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></span><br><span class="line">	<span class="type">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Address space</span></span><br><span class="line">	<span class="type">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>env_tf</code>:<ul>
<li>在<code>inc/trap.h</code>中定义，在这个环境没有运行时保存了其运行时的寄存器状态。当内核从用户态切换到内核态的时候，会保存当前的环境信息，用于之后切换时的场景恢复。</li>
</ul>
</li>
<li><code>env_link</code>:<ul>
<li>这是<code>env</code>组织起来的链表<code>env_free_list</code>。<code>env_free_list</code>指向链表中的第一个空闲<code>env</code>。<br><code>env_id</code>:</li>
<li>这个值唯一的标识了一个<code>env</code>。一个用户环境结束后，内核可能重新分配这个<code>Env</code>结构给一个不同的环境，但是这个<code>Env</code>就会有不同的<code>env_id</code>，即便这个<code>env_id</code>是复用的。</li>
</ul>
</li>
<li><code>env_parent_id</code>:<ul>
<li>内核存储了创造这个环境的父环境的<code>env_id</code>。这样可以将所有的环境组织成一个环境树，这样就可以方便的决定哪个环境可以对某个结构做什么操作。</li>
</ul>
</li>
<li><code>env_type</code>:<ul>
<li>这用于区分特殊环境。 对于大多数环境，它将是<code>ENV_TYPE_USER</code>。在后面的实验中，我们将针对特殊的系统服务环境再介绍几种类型。</li>
</ul>
</li>
<li><code>env_status</code>: 有如下几种取值:<ul>
<li><code>ENV_FREE</code>: 表示<code>Env</code>结构处于非活动状态，因此在<code>env_free_list</code>上</li>
<li><code>ENV_RUNNABLE</code>: 表示<code>Env</code>结构代表一个正在等待在处理器上运行的环境。</li>
<li><code>ENV_RUNNING</code>: 表示<code>Env</code>结构代表当前运行的环境。</li>
<li><code>ENV_NOT_RUNNABLE</code>: 表示<code>Env</code>结构表示当前活动的环境，但它当前尚未准备好运行：例如，因为它正在等待来自另一个环境的进程间通信 (IPC)。</li>
<li><code>ENV_DYING</code>: 表示<code>Env</code>结构代表僵尸环境。僵尸环境将在下一次陷入内核时被释放。</li>
</ul>
</li>
<li><code>env_pgdir</code>: 这个变量保存了这个环境页面目录的内核虚拟地址。</li>
</ul>
<p>与 Unix 进程一样，JOS 环境将“线程”和“地址空间”的概念结合在一起。线程主要由保存的寄存器（<code>env_tf</code>字段）定义，地址空间由<code>env_pgdir</code>指向的页目录和页表定义。为了运行一个环境，内核必须用保存的寄存器和适当的地址空间设置 CPU。</p>
<p>我们的<code>struct Env</code>类似于 xv6 中的<code>struct proc</code>。两个结构都在<code>Trapframe</code>结构中保存环境（即进程的）用户模式寄存器状态。在 JOS 中，单个环境不像 xv6 中的进程那样拥有自己的内核堆栈。内核中一次只能有一个 JOS 环境处于活动状态，因此 JOS 只需要一个内核堆栈。</p>
<h2 id="分配环境数组"><a href="#分配环境数组" class="headerlink" title="分配环境数组"></a>分配环境数组</h2><p>我们需要将<code>envs</code>指针指向一个由<code>Env</code>结构体组成的数组，就像我们在 lab2 中对<code>pages</code>指针做的一样。同时，JOS 还需要将不活动的<code>Env</code>记录在<code>env_free_list</code>之中，类似于<code>page_free_list。curenv</code>指针记录着现在执行的进程。在第一个进程运行之前，为NULL。<br>在<code>kern/pmap.c</code>中添加以下两行代码，基本就是仿造之前对<code>pages</code>的处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">envs = (<span class="keyword">struct</span> Env*) boot_alloc(NENV * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env));</span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env) * NENV);</span><br></pre></td></tr></table></figure></p>
<p>之后进行<code>make;make qemu</code>，如果从Lab 2继承下来，会出现<code>kernel panic at kern/pmap.c:152: PADDR called with invalid kva 00000000</code>的错误！究其原因，链接器提供的<code>end</code>变量并没有指向数据区域的最后，而是指向数据区域内。</p>
<h3 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h3><p>使用<code>objdump -h obj/kern/kernel</code>，得到如下信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00005379  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       000016b0  f0105380  00105380  00006380  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         000088c9  f0106a30  00106a30  00007a30  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .stabstr      00002a60  f010f2f9  0010f2f9  000102f9  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .data         0007a014  f0112000  00112000  00013000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .got          0000000c  f018c014  0018c014  0008d014  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  6 .got.plt      0000000c  f018c020  0018c020  0008d020  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  7 .data.rel.local 0000100e  f018d000  0018d000  0008e000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  8 .data.rel.ro.local 000000cc  f018e020  0018e020  0008f020  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  9 .bss          00000f14  f018e100  0018e100  0008f100  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 10 .comment      0000002b  00000000  00000000  00090014  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure><br>可以看出<code>.bss</code>段的范围为：<code>0xf018e100-0xf018f014</code>，大小为<code>0xf14</code>。将<code>end</code>变量输出，得到：<code>end=0xf018f000</code>。可以看到<code>end</code>在数据段之间。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>修改链接脚本<code>kern/kernel.ld</code>:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.bss : &#123;</span><br><span class="line">	PROVIDE(edata = .);</span><br><span class="line">	*(.bss)</span><br><span class="line">	*(COMMON) </span><br><span class="line">	PROVIDE(end = .);</span><br><span class="line">	BYTE(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>将<code>COMMON</code>添加在end之前即可。</p>
<p>将虚拟内存的 UENVS 段映射到 envs 的物理地址<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map the &#x27;envs&#x27; array read-only by the user at linear address UENVS</span></span><br><span class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line">boot_map_region(kern_pgdir, (<span class="type">uintptr_t</span>)UENVS, ROUNDUP(NENV*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env), PGSIZE), PADDR(envs), PTE_U | PTE_P);</span><br></pre></td></tr></table></figure><br>修正这个错误之后，发现代码的顺序也会影响最后check判断，可能是因为如果不在它指定的地方添加代码的话，会影响page分配的顺序，从而影响检查。</p>
<h3 id="创建和运行环境"><a href="#创建和运行环境" class="headerlink" title="创建和运行环境"></a>创建和运行环境</h3><p>在这里，环境和进程是可以对等的，都指程序运行期间的抽象。不直接叫进程是因为jos中实现的系统调用和UNIX是有差别的。</p>
<p>我们需要编写运行用户环境所需的<code>kern/env.c</code>代码。因为我们还没有文件系统，所以我们将设置内核来加载嵌入在内核中的静态二进制映像。JOS将此二进制文件作为ELF可执行映像嵌入内核中。</p>
<p>在<code>kern/Makefrag</code>文件中，使用了一些方法将这些二进制文件直接“链接”到内核可执行文件中。 链接器命令行上的<code>-b binary</code>选项会将这些文件作为“原始”未解释的二进制文件链接，而不是作为编译器生成的常规.o文件链接。（就链接器而言，这些文件根本不必是ELF文件——它们可以是任何格式，例如文本文件或图片）如果在构建内核后查看<code>obj/kern/kernel.sym</code>，你会注意到链接器“神奇地”产生了许多有趣的符号，这些符号具有晦涩的名字，如<code>_binary_obj_user_hello_start，_binary_obj_user_hello_end</code>和<code>_binary_obj_user_hello_size</code>。链接器通过修改二进制文件的文件名来生成这些符号名称; 这些符号为常规内核代码提供了引用嵌入式二进制文件的方法。</p>
<p>在<code>kern/init.c</code>中的<code>i386_init()</code>中我们将会看到运行这些二进制镜像的方法。</p>
<p>一个函数一个函数的看，第一个是<code>env_init</code>，把所有的<code>env</code>组织成一个链表<code>envs_free_list</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将&#x27;envs&#x27;中的所有环境加入到env_free_list中</span></span><br><span class="line"><span class="comment">// 确保环境以相同的顺序加入到空闲列表中</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Set up envs array</span></span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = NENV<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">                envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">                envs[i].env_link = env_free_list;</span><br><span class="line">                env_free_list = &amp;envs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">        env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>env_setup_vm</code>为指定的用户环境<code>struct Env</code>初始化虚拟地址映射，得到的是一个<code>pde_t *</code>类型的<code>Page Directory</code>。需要注意以下几点：</p>
<ul>
<li>为<code>Page Directory</code>分配的新<code>page</code>应该增加引用统计次数<code>pp_ref</code>。</li>
<li><code>UTOP</code>以下的地址对用户应该为可读可写的。</li>
<li>可以使用<code>kern_pgdir</code>作为模板，在其基础上更改。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">        <span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Hint:</span></span><br><span class="line">        <span class="comment">//    - Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line">        <span class="comment">//      (Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line">        <span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line">        <span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line">        <span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line">        <span class="comment">//      physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line">        <span class="comment">//      is an exception -- you need to increment env_pgdir&#x27;s</span></span><br><span class="line">        <span class="comment">//      pp_ref for env_free to work correctly.</span></span><br><span class="line">        <span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">        e-&gt;env_pgdir = page2kva(p);</span><br><span class="line">        <span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line">        p-&gt;pp_ref ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">pde_t</span>* pde = page2kva(p); pde &lt; (<span class="type">pde_t</span>*)(page2kva(p)+PGSIZE); pde ++)</span><br><span class="line">            *pde = *pde | PTE_U | PTE_W;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// UVPT maps the env&#x27;s own page table read-only.</span></span><br><span class="line">        <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">        e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>env_alloc</code>用来分配一个<code>env</code>，并保存到<code>newenv_store</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配并初始化一个新的env，将其存在 *newenv_store.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on failure.  Errors include:</span></span><br><span class="line"><span class="comment">//      -E_NO_FREE_ENV if all NENV environments are allocated</span></span><br><span class="line"><span class="comment">//      -E_NO_MEM on memory exhaustion</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">env_alloc</span><span class="params">(<span class="keyword">struct</span> Env **newenv_store, <span class="type">envid_t</span> parent_id)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int32_t</span> generation;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果env_free_list为空了，说明分配光了</span></span><br><span class="line">        <span class="keyword">if</span> (!(e = env_free_list))</span><br><span class="line">                <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用这个函数如果返回小于0，则说明没有多余内存了</span></span><br><span class="line">        <span class="keyword">if</span> ((r = env_setup_vm(e)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新生成一个env_id，当前的id加上特定的偏移量，再取低位</span></span><br><span class="line">        generation = (e-&gt;env_id + (<span class="number">1</span> &lt;&lt; ENVGENSHIFT)) &amp; ~(NENV - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (generation &lt;= <span class="number">0</span>)    <span class="comment">// Don&#x27;t create a negative env_id.</span></span><br><span class="line">            generation = <span class="number">1</span> &lt;&lt; ENVGENSHIFT;</span><br><span class="line">        e-&gt;env_id = generation | (e - envs);</span><br><span class="line"></span><br><span class="line">        e-&gt;env_parent_id = parent_id;</span><br><span class="line">        e-&gt;env_type = ENV_TYPE_USER;</span><br><span class="line">        e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">        e-&gt;env_runs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除之前可能保存的寄存器信息</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;e-&gt;env_tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(e-&gt;env_tf));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为寄存器赋初值</span></span><br><span class="line">        <span class="comment">// GD_UD is the user data segment selector in the GDT</span></span><br><span class="line">        <span class="comment">// GD_UT is the user text segment selector </span></span><br><span class="line">        <span class="comment">// 每个寄存器的最低几位标志了特权级，3是用户态。</span></span><br><span class="line">        <span class="comment">// 当我们转换特权级时，硬件会检查特权级和描述符优先级等</span></span><br><span class="line">        e-&gt;env_tf.tf_ds = GD_UD | <span class="number">3</span>;</span><br><span class="line">        e-&gt;env_tf.tf_es = GD_UD | <span class="number">3</span>;</span><br><span class="line">        e-&gt;env_tf.tf_ss = GD_UD | <span class="number">3</span>;</span><br><span class="line">        e-&gt;env_tf.tf_esp = USTACKTOP;</span><br><span class="line">        e-&gt;env_tf.tf_cs = GD_UT | <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// You will set e-&gt;env_tf.tf_eip later.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// commit the allocation</span></span><br><span class="line">        env_free_list = e-&gt;env_link;</span><br><span class="line">        *newenv_store = e;</span><br><span class="line"></span><br><span class="line">        cprintf(<span class="string">&quot;[%08x] new env %08x\n&quot;</span>, curenv ? curenv-&gt;env_id : <span class="number">0</span>, e-&gt;env_id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>region_alloc()</code>为进程分配内存并完成映射。要利用 lab2 中的<code>page_alloc()</code>完成分配内存页，<code>page_insert()</code>完成虚拟地址到物理页的映射。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为环境env分配len个字节的物理内存，将它映射到物理地址va</span></span><br><span class="line"><span class="comment">// 页需要可被用户和内核写</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">region_alloc</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">void</span> *va, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uintptr_t</span> va_start = ROUNDDOWN((<span class="type">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">    <span class="type">uintptr_t</span> va_end = ROUNDUP((<span class="type">uintptr_t</span>)va + len, PGSIZE);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pginfo</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur_va=va_start; cur_va&lt;va_end; cur_va+=PGSIZE) &#123;</span><br><span class="line">        pginfo = page_alloc(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pginfo) &#123;</span><br><span class="line">            <span class="type">int</span> r = -E_NO_MEM;</span><br><span class="line">            panic(<span class="string">&quot;region_alloc: %e&quot;</span> , r);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;insert page at %08x\n&quot;</span>,cur_va);</span><br><span class="line">        page_insert(e-&gt;env_pgdir, pginfo, (<span class="type">void</span> *)cur_va, PTE_U | PTE_W | PTE_P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>load_icode()</code>作用是将 ELF 二进制文件读入内存，由于 JOS 暂时还没有自己的文件系统，实际就是从<code>*binary</code>这个内存地址读取。大概需要做的事：</p>
<ul>
<li>根据<code>ELF header</code>得出<code>Programm header</code>。</li>
<li>遍历所有<code>Programm header</code>，分配好内存，加载类型为<code>ELF_PROG_LOAD</code>的段。</li>
<li>分配用户栈。</li>
</ul>
<p><code>lcr3([页目录物理地址])</code>将页目录地址加载到<code>cr3</code>寄存器。</p>
<p>更改函数入口时，将<code>env-&gt;env_tf.tf_eip</code>设置为<code>elf-&gt;e_entry</code>，等待之后的<code>env_pop_tf()</code>调用。</p>
<p>这里相当于实现一个ELF可执行文件加载器。ELF文件以一个ELF文件头开始，通过<code>ELFHDR-&gt;e_magic</code>字段判断该文件是否是ELF格式的，然后通过<code>ELFHDR-&gt;e_phoff</code>获取程序头距离ELF文件的偏移，<code>ph</code>指向的就是程序头的起始位置，相当于一个数组，程序头记录了有哪些Segment需要加载，加载到线性地址的何处？<code>ph_num</code>保存了总共有多少Segment。遍历<code>ph</code>数组，分配线性地址<code>p_va</code>开始的<code>p_memsz</code>大小的空间。并将ELF文件中<code>binary + ph[i].p_offset</code>偏移处的Segment拷贝到线性地址<code>p_va</code>处。</p>
<p>有一点需要注意，在执行for循环前，需要加载<code>e-&gt;env_pgdir</code>，也就是这句<code>lcr3(PADDR(e-&gt;env_pgdir));</code>，因为我们要将Segment拷贝到用户的线性地址空间内，而不是内核的线性地址空间。<br>加载完Segment后需要设置<code>e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry;</code>也就是程序第一条指令的位置。</p>
<p>最后<code>region_alloc(e, (void *) (USTACKTOP - PGSIZE), PGSIZE);</code>为用户环境分配栈空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">uint8_t</span> *binary)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span> =</span> (<span class="keyword">struct</span> Elf *)binary;</span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        panic(<span class="string">&quot;load_icode: not an ELF file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过ELF header中保存的Programm header的偏移找到Programm header</span></span><br><span class="line">    ph = (<span class="keyword">struct</span> Proghdr *)(binary + elf-&gt;e_phoff);</span><br><span class="line">    eph = ph + elf-&gt;e_phnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载这个环境自己的页表</span></span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    <span class="keyword">for</span> (; ph&lt;eph; ph++) &#123;</span><br><span class="line">        <span class="comment">// 如果这个programm header是需要被加载的</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">                panic(<span class="string">&quot;load_icode: file size is greater than memory size&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 分配一个空间并将所需要的复制过来，将其后填充</span></span><br><span class="line">            region_alloc(e, (<span class="type">void</span> *)ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="type">void</span> *)ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">            <span class="built_in">memset</span>((<span class="type">void</span> *)ph-&gt;p_va + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;env_tf.tf_eip = elf-&gt;e_entry;</span><br><span class="line">    <span class="comment">// Now map one page for the program&#x27;s initial stack</span></span><br><span class="line">    <span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    region_alloc(e, (<span class="type">void</span> *) USTACKTOP-PGSIZE, PGSIZE);</span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>env_create()</code>作用是新建一个进程。调用已经写好的<code>env_alloc()</code>函数即可，之后更改类型并且利用<code>load_icode()</code>读取 ELF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_create</span><span class="params">(<span class="type">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="type">int</span> r = env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (r&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;env_create: %e&quot;</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;env_type = type;</span><br><span class="line">    load_icode(e, binary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>env_run()</code>启动某个进程。最后调用了<code>env_pop_tf()</code>这个函数。该函数的作用是将<code>struct Trapframe</code>中存储的寄存器状态 pop 到相应寄存器中。查看之前写的<code>load_icode()</code>函数中的<code>e-&gt;env_tf.tf_eip = elf-&gt;e_entry</code>这一句，经过<code>env_pop_tf()</code>之后，指令寄存器的值即设置到了可执行文件的入口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Step 1: If this is a context switch (a new environment is running):</span></span><br><span class="line">    <span class="comment">//     1. Set the current environment (if any) back to</span></span><br><span class="line">    <span class="comment">//        ENV_RUNNABLE if it is ENV_RUNNING (think about</span></span><br><span class="line">    <span class="comment">//        what other states it can be in),</span></span><br><span class="line">    <span class="comment">//     2. Set &#x27;curenv&#x27; to the new environment,</span></span><br><span class="line">    <span class="comment">//     3. Set its status to ENV_RUNNING,</span></span><br><span class="line">    <span class="comment">//     4. Update its &#x27;env_runs&#x27; counter,</span></span><br><span class="line">    <span class="comment">//     5. Use lcr3() to switch to its address space.</span></span><br><span class="line">    <span class="comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span></span><br><span class="line">    <span class="comment">//     registers and drop into user mode in the</span></span><br><span class="line">    <span class="comment">//     environment.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This function loads the new environment&#x27;s state from</span></span><br><span class="line">    <span class="comment">//  e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line">    <span class="comment">//  and make sure you have set the relevant parts of</span></span><br><span class="line">    <span class="comment">//  e-&gt;env_tf to sensible values.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;</span><br><span class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    curenv = e;</span><br><span class="line">    e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">    e-&gt;env_runs++;</span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    </span><br><span class="line">    env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Trapframe</code>结构和<code>env_pop_tf()</code>函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> &#123;</span></span><br><span class="line">	<span class="comment">/* registers as pushed by pusha */</span></span><br><span class="line">	<span class="type">uint32_t</span> reg_edi;</span><br><span class="line">	<span class="type">uint32_t</span> reg_esi;</span><br><span class="line">	<span class="type">uint32_t</span> reg_ebp;</span><br><span class="line">	<span class="type">uint32_t</span> reg_oesp;		<span class="comment">/* Useless */</span></span><br><span class="line">	<span class="type">uint32_t</span> reg_ebx;</span><br><span class="line">	<span class="type">uint32_t</span> reg_edx;</span><br><span class="line">	<span class="type">uint32_t</span> reg_ecx;</span><br><span class="line">	<span class="type">uint32_t</span> reg_eax;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">	<span class="type">uint16_t</span> tf_es;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding1;</span><br><span class="line">	<span class="type">uint16_t</span> tf_ds;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding2;</span><br><span class="line">	<span class="type">uint32_t</span> tf_trapno;</span><br><span class="line">	<span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">	<span class="type">uint32_t</span> tf_err;</span><br><span class="line">	<span class="type">uintptr_t</span> tf_eip;</span><br><span class="line">	<span class="type">uint16_t</span> tf_cs;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding3;</span><br><span class="line">	<span class="type">uint32_t</span> tf_eflags;</span><br><span class="line">	<span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">	<span class="type">uintptr_t</span> tf_esp;</span><br><span class="line">	<span class="type">uint16_t</span> tf_ss;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding4;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restores the register values in the Trapframe with the &#x27;iret&#x27; instruction.</span></span><br><span class="line"><span class="comment">// This exits the kernel and starts executing some environment&#x27;s code.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function does not return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_pop_tf</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tmovl %0,%%esp\n&quot;</span>				<span class="comment">//将%esp指向tf地址处</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tpopal\n&quot;</span>						<span class="comment">//弹出Trapframe结构中的tf_regs值到通用寄存器</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tpopl %%es\n&quot;</span>					<span class="comment">//弹出Trapframe结构中的tf_es值到%es寄存器</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tpopl %%ds\n&quot;</span>					<span class="comment">//弹出Trapframe结构中的tf_ds值到%ds寄存器</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\taddl $0x8,%%esp\n&quot;</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tiret\n&quot;</span>						<span class="comment">//中断返回指令，具体动作如下：从Trapframe结构中依次弹出tf_eip,tf_cs,tf_eflags,tf_esp,tf_ss到相应寄存器</span></span></span><br><span class="line"><span class="params">		: : <span class="string">&quot;g&quot;</span> (tf) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">	panic(<span class="string">&quot;iret failed&quot;</span>);  <span class="comment">/* mostly to placate the compiler */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>PushRegs</code>结构保存的正是通用寄存器的值，<code>env_pop_tf()</code>第一条指令，将<code>%esp</code>指向<code>tf</code>地址处，也就是将栈顶指向<code>Trapframe</code>结构开始处，<code>Trapframe</code>结构开始处正是一个<code>PushRegs</code>结构，<code>popal</code>将<code>PushRegs</code>结构中保存的通用寄存器值弹出到寄存器中，接着按顺序弹出寄存器<code>%es</code>, <code>%ds</code>。最后执行<code>iret</code>指令，该指令是中断返回指令，具体动作如下：从<code>Trapframe</code>结构中依次弹出<code>tf_eip</code>，<code>tf_cs</code>，<code>tf_eflags</code>，<code>tf_esp</code>，<code>tf_ss</code>到相应寄存器。</p>
<p>至此结束，本次 exercise 结束后运行并不会成功，会报错 Triple fault。然后 gdb 停止在：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x800a1c:    int    $0x30</span><br><span class="line">0x00800a1c in ?? ()</span><br></pre></td></tr></table></figure><br>原因是此时系统已经进入用户空间，执行了 hello 直到使用系统调用。然而由于 JOS 还没有允许从用户态到内核态的切换，CPU 会产生一个保护异常，然而这个异常也没有程序进行处理，于是生成了 double fault 异常，这个异常同样没有处理。所以报错 triple fault。也就是说，看到执行到了 int 这个中断，实际上就是本次 exercise 顺利结束，这个系统调用是为了在终端输出字符。</p>
<h2 id="处理中断和异常"><a href="#处理中断和异常" class="headerlink" title="处理中断和异常"></a>处理中断和异常</h2><p>上一节中，<code>int $0x30</code>这个系统调用指令是一条死路：一旦进程进入用户模式，内核将无法再次获得控制权。异常和中断都是“受保护的控制权转移” (protected control transfers)，使处理器从用户模式转到内核模式，用户模式代码无法干扰内核或者其他进程的运行。区别在于，中断是由处理器外部的异步事件产生；而异常是由目前处理的代码产生，例如除以0。</p>
<p>为保证切换是被保护的，处理器的中断、异常机制使得正在运行的代码无须选择在哪里以什么方式进入内核。相反，处理器将保证内核在严格的限制下才能被进入。在 x86 架构下，一共有两个机制提供这种保护：</p>
<p>中断描述符表(Interrupt Descriptor Table, IDT)：处理器将确保从一些内核预先定义的条目才能进入内核，而不是由中断或异常发生时运行的代码决定。</p>
<p>x86 支持最多 256 个不同中断和异常的条目。每个包含一个中断向量，是一个 0~255 之间的数，代表中断来源：不同的设备以及错误类型。CPU 利用这些向量作为中断描述符表的索引。而这个表是内核定义在私有内存上（用户没有权限），就像全局描述符表(Global Descripter Table, GDT)一样。从表中恰当的条目，处理器可以获得：</p>
<ul>
<li>需要加载到指令指针寄存器(EIP)的值，该值指向内核中处理这类异常的代码。</li>
<li>需要加载到代码段寄存器(CS)的值，其中最低两位表示优先级（这也是为什么说可以寻址 2^46 的空间而不是 2^48)。 在JOS 中，所有的异常都在内核模式处理，优先级为0 (用户模式为3)。</li>
</ul>
<p>任务状态段(Task State Segment, TSS)：处理器需要保存中断和异常出现时的自身状态，例如 EIP 和 CS，以便处理完后能返回原函数继续执行。但是存储区域必须禁止用户访问，避免恶意代码或 bug 的破坏。</p>
<p>因此，当 x86 处理器处理从用户到内核的模式转换时，也会切换到内核栈。而 TSS 指明段选择器和栈地址。处理器将 SS, ESP, EFLAGS, CS, EIP 压入新栈，然后从 IDT 读取 CS 和 EIP，根据新栈设置 ESP 和 SS。</p>
<p>JOS 仅利用 TSS 来定义需要切换的内核栈。由于内核模式在 JOS 优先级是 0，因此处理器用 TSS 的 ESP0 和 SS0 来定义内核栈，无需 TSS 结构体中的其他内容。其中， SS0 种存储的是 GD_KD(0x10)，ESP0 种存储的是 KSTACKTOP(0xf0000000)。相关定义在<code>inc/memlayout.h</code>中可以找到。</p>
<h3 id="中断和异常的类型"><a href="#中断和异常的类型" class="headerlink" title="中断和异常的类型"></a>中断和异常的类型</h3><p>x86 的所有异常可以用中断向量 0~31 表示，对应 IDT 的第 0~31 项。例如，页错误产生一个中断向量为 14 的异常。大于 32 的中断向量表示的都是中断，其中，软件中断用 int 指令产生，而硬件中断则由硬件在需要关注的时候产生。</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>通过一个例子来理解上面的知识。假设处理器正在执行用户环境的代码，遇到了”除0”异常。</p>
<p>处理器切换到内核栈，利用了上文<code>TSS</code>中的<code>ESP0</code>和<code>SS0</code>，在JOS中分别是<code>KSTACKTOP</code>和<code>GD_KD</code>。处理器将异常参数<code>push</code>到了内核栈。一般情况下，按顺序push SS, ESP, EFLAGS, CS, EIP<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ KSTACKTOP</span><br><span class="line">| 0x00000 | old SS | &quot; - 4</span><br><span class="line">| old ESP | &quot; - 8</span><br><span class="line">| old EFLAGS | &quot; - 12</span><br><span class="line">| 0x00000 | old CS | &quot; - 16</span><br><span class="line">| old EIP | &quot; - 20 &lt;---- ESP</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure></p>
<p>存储这些寄存器状态的意义是：SS(堆栈选择器) 的低 16 位与 ESP 共同确定当前栈状态；EFLAGS(标志寄存器)存储当前FLAG；CS(代码段寄存器) 和 EIP(指令指针寄存器) 确定了当前即将执行的代码地址，E 代表”扩展”至32位。根据这些信息，就能保证处理中断结束后能够恢复到中断前的状态。</p>
<p>因为我们将处理一个”除0”异常，其对应中断向量是0，因此，处理器读取 IDT 的条目0，设置 CS:EIP 指向该条目对应的处理函数。</p>
<p>处理函数获得程序控制权并且处理该异常。例如，终止进程的运行。</p>
<p>对于某些特殊的 x86 异常，除了以上 5 个参数以外，还需要存储一个 error code。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ KSTACKTOP             </span><br><span class="line">| 0x00000 | old SS   |     &quot; - 4</span><br><span class="line">|      old ESP       |     &quot; - 8</span><br><span class="line">|     old EFLAGS     |     &quot; - 12</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 16</span><br><span class="line">|      old EIP       |     &quot; - 20</span><br><span class="line">|     error code     |     &quot; - 24 &lt;---- ESP</span><br><span class="line">+--------------------+     </span><br></pre></td></tr></table></figure></p>
<p>例如，页错误异常（中断向量=14）就是一个重要的例子，它就需要额外存储一个 error code。</p>
<h3 id="嵌套的异常和中断"><a href="#嵌套的异常和中断" class="headerlink" title="嵌套的异常和中断"></a>嵌套的异常和中断</h3><p>内核和用户进程都会引起异常和中断。然而，仅在从用户环境进入内核时才会切换栈。如果中断发生时已经在内核态了(此时， CS 寄存器的低 2bit 为 00) ，那么 CPU 就直接将状态压入内核栈，不再需要切换栈。这样，内核就能处理内核自身引起的”嵌套异常”，这是实现保护的重要工具。</p>
<p>如果处理器已经处于内核态，然后发生了嵌套异常，由于它并不进行栈切换，所以无须存储 SS 和 ESP 寄存器状态。对于不包含 error code 的异常，在进入处理函数前内核栈状态如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ &lt;---- old ESP</span><br><span class="line">|     old EFLAGS     |     &quot; - 4</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 8</span><br><span class="line">|      old EIP       |     &quot; - 12</span><br><span class="line">+--------------------+             </span><br></pre></td></tr></table></figure></p>
<p>对于包含了 error code 的异常，则将 error code 继续 push 到 EIP之后。</p>
<p>警告：如果 CPU 处理嵌套异常的时候，无法将状态 push 到内核栈（由于栈空间不足等原因），则 CPU 无法恢复当前状态，只能重启。当然，这是内核设计中必须避免的。</p>
<h3 id="建立中断描述符表-IDT"><a href="#建立中断描述符表-IDT" class="headerlink" title="建立中断描述符表(IDT)"></a>建立中断描述符表(IDT)</h3><p>IDT可以驻留在物理内存中的任何位置。 处理器通过IDT寄存器（IDTR）定位IDT。</p>
<p><img src="/img/201906171933232.png" alt=""></p>
<p>IDT包含了三种描述子</p>
<ul>
<li>任务门</li>
<li>中断门</li>
<li>陷阱门</li>
</ul>
<p><img src="/img/20190617193346641.png" alt=""></p>
<p>每个entry为8bytes，有以下关键bit：</p>
<ul>
<li>16~31：code segment selector</li>
<li>0~15 &amp; 46-64：segment offset （根据以上两项可确定中断处理函数的地址）</li>
<li>Type （8-11）：区分中断门、陷阱门、任务门等</li>
<li>DPL：Descriptor Privilege Level， 访问特权级</li>
<li>P：该描述符是否在内存中</li>
</ul>
<p>通过上文，已经了解到了建立 IDT 以及处理异常所需要的基本信息。头文件<code>inc/trap.h</code>和<code>kern/trap.h</code>包含了与中断和异常相关的定义。</p>
<p>每个异常和中断都应该在<code>trapentry.S</code>和<code>trap_init()</code>有自己的处理函数，并在<code>IDT</code>中将这些处理函数的地址初始化，这也描述了Part A的整个过程。每个处理函数都需要在栈上新建一个<code>struct Trapframe</code>（见<code>inc/trap.h</code>)，以其地址为参数调用<code>trap()</code>函数，然后进行异常处理。</p>
<p>总体的异常处理应该如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">      IDT                   trapentry.S         trap.c</span><br><span class="line">   </span><br><span class="line">+----------------+                        </span><br><span class="line">|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)</span><br><span class="line">|                |             // do stuff      &#123;</span><br><span class="line">|                |             call trap          // handle the exception/interrupt</span><br><span class="line">|                |             // ...           &#125;</span><br><span class="line">+----------------+</span><br><span class="line">|   &amp;handler2    |--------&gt; handler2:</span><br><span class="line">|                |            // do stuff</span><br><span class="line">|                |            call trap</span><br><span class="line">|                |            // ...</span><br><span class="line">+----------------+</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">+----------------+</span><br><span class="line">|   &amp;handlerX    |--------&gt; handlerX:</span><br><span class="line">|                |             // do stuff</span><br><span class="line">|                |             call trap</span><br><span class="line">|                |             // ...</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure></p>
<p>首先第一步是搞明白<code>TRAPHANDLER</code>这段汇编代码的意义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPHANDLER(name, num)  </span></span><br><span class="line">    .globl name;        </span><br><span class="line">    .type name, @function;  </span><br><span class="line">    .align <span class="number">2</span>;</span><br><span class="line">    name:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  pushl $0;    // if no error code </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pushl $(num);                           </span><br><span class="line">    jmp _alltraps</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&#x27;t push an error code.</span></span><br><span class="line"><span class="comment"> * It pushes a 0 in place of the error code, so the trap frame has the same</span></span><br><span class="line"><span class="comment"> * format in either case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPHANDLER_NOEC(name, num)</span></span><br><span class="line">    .globl name;</span><br><span class="line">    .type name, @function;</span><br><span class="line">    .align <span class="number">2</span>;</span><br><span class="line">    name:</span><br><span class="line">    pushl $<span class="number">0</span>;</span><br><span class="line">    pushl $(num);</span><br><span class="line">    jmp _alltraps</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>.global/ .globl</code>：用来定义一个全局的符号，格式如下:<ul>
<li><code>.global symbol</code>或者<code>.globl symbol</code></li>
<li>汇编函数如果需要在其他文件调用，需要把函数声明为全局的，此时就会用到<code>.global</code>这个伪操作。</li>
</ul>
</li>
<li><code>.type</code>: 用来指定一个符号的类型是函数类型或者是对象类型,对象类型一般是数据, 格式如下:<ul>
<li><code>.type symbol, @object</code></li>
<li><code>.type symbol, @function</code></li>
</ul>
</li>
<li><code>.align</code>: 用来指定内存对齐方式，格式如下：<ul>
<li><code>.align size</code>表示按 size 字节对齐内存。</li>
</ul>
</li>
</ul>
<p><code>TRAPHANDLER</code>定义了一个全局可见的函数来处理陷阱。它将陷阱编号压入堆栈，然后跳转到<code>_alltraps</code>。将<code>TRAPHANDLER</code>用于 CPU 自动推送错误代码的陷阱。不应该从 C 调用<code>TRAPHANDLER</code>函数，但可能需要在 C 中声明一个（例如，在 IDT 设置期间获取函数指针）。可以使用<code>void NAME();</code>声明函数。<code>TRAPHANDLER_NOEC</code>是没有返回错误码的陷阱。<code>TRAPHANDLER</code>和<code>TRAPHANDLER_NOEC</code>创建的函数都会跳转到<code>_alltraps</code>处，这里参考<code>inc/trap.h</code>中的<code>Trapframe</code>结构，<code>tf_ss</code>，<code>tf_esp</code>，<code>tf_eflags</code>，<code>tf_cs</code>，<code>tf_eip</code>，<code>tf_err</code>在中断发生时由处理器压入，所以现在只需要压入剩下寄存器（%ds,%es,通用寄存器）。然后将<code>%esp</code>压入栈中（也就是压入trap()的参数tf）</p>
<p>之前在<code>inc/trap.h</code>中已经定义了<code>T_*</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trap numbers</span></span><br><span class="line"><span class="comment">// These are processor defined:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIVIDE     0          <span class="comment">// divide error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEBUG      1          <span class="comment">// debug exception</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_NMI        2          <span class="comment">// non-maskable interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_BRKPT      3          <span class="comment">// breakpoint</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_OFLOW      4          <span class="comment">// overflow</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_BOUND      5          <span class="comment">// bounds check</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_ILLOP      6          <span class="comment">// illegal opcode</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE     7          <span class="comment">// device not available</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DBLFLT     8          <span class="comment">// double fault</span></span></span><br><span class="line"><span class="comment">/* #define T_COPROC  9 */</span>       <span class="comment">// reserved (not generated by recent processors)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_TSS       10          <span class="comment">// invalid task switch segment</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SEGNP     11          <span class="comment">// segment not present</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_STACK     12          <span class="comment">// stack exception</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_GPFLT     13          <span class="comment">// general protection fault</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_PGFLT     14          <span class="comment">// page fault</span></span></span><br><span class="line"><span class="comment">/* #define T_RES    15 */</span>       <span class="comment">// reserved</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FPERR     16          <span class="comment">// floating point error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_ALIGN     17          <span class="comment">// aligment check</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_MCHK      18          <span class="comment">// machine check</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SIMDERR   19          <span class="comment">// SIMD floating point error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These are arbitrarily chosen, but with care not to overlap</span></span><br><span class="line"><span class="comment">// processor defined exceptions or interrupt vectors.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SYSCALL   48          <span class="comment">// system call</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEFAULT   500         <span class="comment">// catchall</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_OFFSET      32      <span class="comment">// IRQ 0 corresponds to int IRQ_OFFSET</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hardware IRQ numbers. We receive these as (IRQ_OFFSET+IRQ_WHATEVER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TIMER        0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_KBD          1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_SERIAL       4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_SPURIOUS     7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_IDE         14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_ERROR       19</span></span><br></pre></td></tr></table></figure></p>
<p>通过查询80386手册的9.10可以看到如下关于error code的总结，根据是否有error code进行区分<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Description                       Interrupt     Error Code</span><br><span class="line"></span><br><span class="line">Divide error                       0            No</span><br><span class="line">Debug exceptions                   1            No</span><br><span class="line">Breakpoint                         3            No</span><br><span class="line">Overflow                           4            No</span><br><span class="line">Bounds check                       5            No</span><br><span class="line">Invalid opcode                     6            No</span><br><span class="line">Coprocessor not available          7            No</span><br><span class="line">System error                       8            Yes (always 0)</span><br><span class="line">Coprocessor Segment Overrun        9            No</span><br><span class="line">Invalid TSS                       10            Yes</span><br><span class="line">Segment not present               11            Yes</span><br><span class="line">Stack exception                   12            Yes</span><br><span class="line">General protection fault          13            Yes</span><br><span class="line">Page fault                        14            Yes</span><br><span class="line">Coprocessor error                 16            No</span><br><span class="line">Two-byte SW interrupt             0-255         No</span><br></pre></td></tr></table></figure></p>
<p>所以现在在<code>trapentry.S</code>中需要定义handler：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(divide_handler, T_DIVIDE);</span><br><span class="line">TRAPHANDLER_NOEC(debug_handler, T_DEBUG);</span><br><span class="line">TRAPHANDLER_NOEC(nmi_handler, T_NMI);</span><br><span class="line">TRAPHANDLER_NOEC(brkpt_handler, T_BRKPT);</span><br><span class="line">TRAPHANDLER_NOEC(oflow_handler, T_OFLOW);</span><br><span class="line">TRAPHANDLER_NOEC(bound_handler, T_BOUND);</span><br><span class="line">TRAPHANDLER_NOEC(illop_handler, T_ILLOP);</span><br><span class="line">TRAPHANDLER_NOEC(device_handler, T_DEVICE);</span><br><span class="line">TRAPHANDLER(dblflt_handler, T_DBLFLT);</span><br><span class="line">TRAPHANDLER(tss_handler, T_TSS);</span><br><span class="line">TRAPHANDLER(segnp_handler, T_SEGNP);</span><br><span class="line">TRAPHANDLER(stack_handler, T_STACK);</span><br><span class="line">TRAPHANDLER(gpflt_handler, T_GPFLT);</span><br><span class="line">TRAPHANDLER(pgflt_handler, T_PGFLT);</span><br><span class="line">TRAPHANDLER_NOEC(fperr_handler, T_FPERR);</span><br><span class="line">TRAPHANDLER(align_handler, T_ALIGN);</span><br><span class="line">TRAPHANDLER_NOEC(mchk_handler, T_MCHK);</span><br><span class="line">TRAPHANDLER_NOEC(simderr_handler, T_SIMDERR);</span><br><span class="line">TRAPHANDLER_NOEC(syscall_handler, T_SYSCALL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IRQs</span></span><br><span class="line">TRAPHANDLER_NOEC(timer_handler, IRQ_OFFSET + IRQ_TIMER);</span><br><span class="line">TRAPHANDLER_NOEC(kbd_handler, IRQ_OFFSET + IRQ_KBD);</span><br><span class="line">TRAPHANDLER_NOEC(serial_handler, IRQ_OFFSET + IRQ_SERIAL);</span><br><span class="line">TRAPHANDLER_NOEC(spurious_handler, IRQ_OFFSET + IRQ_SPURIOUS);</span><br><span class="line">TRAPHANDLER_NOEC(ide_handler, IRQ_OFFSET + IRQ_IDE);</span><br><span class="line">TRAPHANDLER_NOEC(error_handler, IRQ_OFFSET + IRQ_ERROR);</span><br></pre></td></tr></table></figure><br>该部分主要作用是<strong>声明函数</strong>。该函数是全局的，但是在 C 文件中使用的时候需要使用<code>void name();</code>再声明一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Your _alltraps should:</span><br><span class="line">	1. push values to make the stack look like a struct Trapframe</span><br><span class="line">	2. load GD_KD into %ds and %es</span><br><span class="line">	3. pushl %esp to pass a pointer to the Trapframe as an argument to trap()</span><br><span class="line">	4. call trap (can trap ever return?)</span><br><span class="line">*/</span><br><span class="line">.globl _alltraps</span><br><span class="line">_alltraps:</span><br><span class="line">pushl %ds</span><br><span class="line">pushl %es</span><br><span class="line">pushal</span><br><span class="line"></span><br><span class="line">movw $GD_KD, %ax</span><br><span class="line">movw %ax, %ds</span><br><span class="line">movw %ax, %es</span><br><span class="line">pushl %esp</span><br><span class="line">call trap</span><br></pre></td></tr></table></figure>
<p>这部分较有难度，首先要搞明白，栈是从高地址向低地址生长，而结构体在内存中的存储是从低地址到高地址。而 cpu 以及TRAPHANDLER宏已经将压栈工作进行到了中断向量部分。</p>
<p>首先需要产生一个<code>struct trapframe</code>结构的栈， 而压参数是从右往左，对应这个结构体就是从下往上对应。注意到<code>tf_esp</code>以及<code>tf_ss</code>只用在发生特权级变化的时候才会有，再往上是由硬件自动产生的。在<code>TRAPHANDLER</code>函数中压入了<code>trapno</code>，同时为了保证没有错误代码的<code>trap</code>能符合这个结构体，使用<code>TRAPHANDLER_NOEC</code>压入0占位<code>err</code>。最后我们的程序只需要压入<code>trapno</code>以上的参数即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="type">uint16_t</span> tf_es;</span><br><span class="line">    <span class="type">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="type">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="type">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="type">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">    <span class="type">uint32_t</span> tf_err;</span><br><span class="line">    <span class="type">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="type">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="type">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="type">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">    <span class="type">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="type">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="type">uint16_t</span> tf_padding4;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></p>
<p>所以若要形成一个<code>Trapframe</code>，则还应该依次压入<code>ds</code>，<code>es</code>以及<code>struct PushRegs</code>中的各寄存器（倒序，可使用 <code>pusha</code>指令）。此后还需要更改数据段为内核的数据段。注意，不能用立即数直接给段寄存器赋值。因此不能直接写<code>movw $GD_KD, %ds</code>。</p>
<p>在<code>kern/trap.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You will also need to modify trap_init() to initialize the idt to </span></span><br><span class="line"><span class="comment">// point to each of these entry points defined in trapentry.S;</span></span><br><span class="line"><span class="comment">// the SETGATE macro will be helpful here</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">divide_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">debug_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">nmi_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">brkpt_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">oflow_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">bound_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">device_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">illop_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">tss_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">segnp_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">stack_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">gpflt_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">pgflt_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">fperr_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">align_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">mchk_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">simderr_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">syscall_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dblflt_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">timer_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">kbd_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">serial_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">spurious_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">ide_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">error_handler</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// GD_KT 全局描述符， kernel text</span></span><br><span class="line">    SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, divide_handler, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DEBUG],  <span class="number">0</span>, GD_KT, debug_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_NMI],    <span class="number">0</span>, GD_KT, nmi_handler,    <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_BRKPT],  <span class="number">0</span>, GD_KT, brkpt_handler,  <span class="number">3</span>);</span><br><span class="line">    SETGATE(idt[T_OFLOW],  <span class="number">0</span>, GD_KT, oflow_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_BOUND],  <span class="number">0</span>, GD_KT, bound_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, device_handler, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_ILLOP],  <span class="number">0</span>, GD_KT, illop_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, dblflt_handler, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_TSS],    <span class="number">0</span>, GD_KT, tss_handler,    <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SEGNP],  <span class="number">0</span>, GD_KT, segnp_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_STACK],  <span class="number">0</span>, GD_KT, stack_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_GPFLT],  <span class="number">0</span>, GD_KT, gpflt_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_PGFLT],  <span class="number">0</span>, GD_KT, pgflt_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_FPERR],  <span class="number">0</span>, GD_KT, fperr_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_ALIGN],  <span class="number">0</span>, GD_KT, align_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_MCHK],   <span class="number">0</span>, GD_KT, mchk_handler,   <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, simderr_handler, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, syscall_handler, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// IRQ</span></span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_TIMER],    <span class="number">0</span>, GD_KT, timer_handler, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD],      <span class="number">0</span>, GD_KT, kbd_handler,     <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL],   <span class="number">0</span>, GD_KT, serial_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="number">0</span>, GD_KT, spurious_handler, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE],      <span class="number">0</span>, GD_KT, ide_handler,     <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR],    <span class="number">0</span>, GD_KT, error_handler,   <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-CPU setup </span></span><br><span class="line">    trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>SETGATE</code>参见<code>inc/mmu.h</code>中的函数定义。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define SETGATE(gate, istrap, sel, off, dpl)</span><br><span class="line">&#123;</span><br><span class="line">    (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff;</span><br><span class="line">    (gate).gd_sel = (sel);</span><br><span class="line">    (gate).gd_args = 0;</span><br><span class="line">    (gate).gd_rsv1 = 0;</span><br><span class="line">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;</span><br><span class="line">    (gate).gd_s = 0;</span><br><span class="line">    (gate).gd_dpl = (dpl);</span><br><span class="line">    (gate).gd_p = 1;</span><br><span class="line">    (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>gate</code>：这是一个 struct Gatedesc。</li>
<li><code>istrap</code>：该中断是 trap(exception) 则为1，是 interrupt 则为0。</li>
<li><code>sel</code>：代码段选择器。进入内核的话是 GD_KT。</li>
<li><code>off</code>：相对于段的偏移，简单来说就是函数地址。</li>
<li><code>dpl</code>(Descriptor Privileged Level)：权限描述符。</li>
</ul>
<h2 id="Part-B-缺页错误，断点异常以及系统调用"><a href="#Part-B-缺页错误，断点异常以及系统调用" class="headerlink" title="Part B: 缺页错误，断点异常以及系统调用"></a>Part B: 缺页错误，断点异常以及系统调用</h2><h3 id="处理缺页错误"><a href="#处理缺页错误" class="headerlink" title="处理缺页错误"></a>处理缺页错误</h3><p>缺页错误异常，中断向量 14 (<code>T_PGFLT</code>)，是一个非常重要的异常类型。当程序遇到缺页异常时，它将引起异常的虚拟地址存入<code>CR2</code>控制寄存器( control register)。在<code>trap.c</code>中，我们已经提供了<code>page_fault_handler()</code>函数用来处理缺页异常。</p>
<p>修改<code>trap_dispatch()</code>函数比较简单，实际上就是在<code>trap_dispatch()</code>中根据 trap number 进行一个处理分配。目前只需要加入缺页异常即可完成该 exercise。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Handle processor exceptions.</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">            page_fault_handler(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">        print_trapframe(tf);</span><br><span class="line">        <span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">            panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            env_destroy(curenv);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="断点异常"><a href="#断点异常" class="headerlink" title="断点异常"></a>断点异常</h3><p>断点异常，中断向量 3 (<code>T_BRKPT</code>) 允许调试器给程序加上断点。原理是暂时把程序中的某个指令替换为一个 1 字节大小的<code>int3</code>软件中断指令。在 JOS 中，我们将它实现为一个伪系统调用。这样，任何程序（不限于调试器）都能使用断点功能。这个exercise同样也是修改<code>trap_dispatch()</code>函数。另外需要找到在<code>kern/monitor.c</code>中的<code>void monitor(struct TrapFrame *tf)</code>函数，加入断点处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Handle processor exceptions.</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">            page_fault_handler(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_BRKPT:</span><br><span class="line">            monitor(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">        print_trapframe(tf);</span><br><span class="line">        <span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">            panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            env_destroy(curenv);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>challenge部分要求，我们修改monitor的代码，使得程序能够继续执行，以及能够逐指令执行。首先，按照题目要求，我们肯定要给monitor增加2个函数，不妨叫做：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mon_continue</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mon_stepi</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span>;</span><br></pre></td></tr></table></figure></p>
<p>把这两行加在头文件中，再在命令序列中加入这两个命令。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] =</span> &#123;</span><br><span class="line">        &#123; <span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display this list of commands&quot;</span>, mon_help &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;kerninfo&quot;</span>, <span class="string">&quot;Display information about the kernel&quot;</span>, mon_kerninfo &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;backtrace&quot;</span>, <span class="string">&quot;Display a backtrace of the function stack&quot;</span>, mon_backtrace &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;stepi&quot;</span>, <span class="string">&quot;step instruction&quot;</span>, mon_stepi&#125;,</span><br><span class="line">        &#123; <span class="string">&quot;continue&quot;</span>, <span class="string">&quot;continue instruction&quot;</span>, mon_continue&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其次，根据提示，我们去阅读intel文档中关于EFLAGS寄存器的部分，发现了一个位：<code>Trap Bit</code>。如果这个位被设置位1，那么每次执行一条指令，都会自动触发一次Debug Exception.</p>
<p>那么我们要做的就很简单了：在两个函数中，修改eflags寄存器的值，并返回-1（然后从内核态返回用户态）；同时，我们也要给Debug Exception增加特殊的处理函数，使他能够进入monitor。</p>
<p>注意，因为这些中断都是用户态到内核态的，所以<code>trap_init</code>中要做一些修改。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mon_continue</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Continue exectuion of current env. </span></span><br><span class="line">	<span class="comment">// Because we need to exit the monitor, retrun -1 when we can do so</span></span><br><span class="line">	<span class="comment">// Corner Case: If no trapframe(env context) is given, do nothing</span></span><br><span class="line">	<span class="keyword">if</span>(tf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cprintf(<span class="string">&quot;No Env is Running! This is Not a Debug Monitor!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Because we want the program to continue running; clear the TF bit</span></span><br><span class="line">	tf-&gt;tf_eflags &amp;= ~(FL_TF);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mon_stepi</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Continue exectuion of current env. </span></span><br><span class="line">	<span class="comment">// Because we need to exit the monitor, retrun -1 when we can do so</span></span><br><span class="line">	<span class="comment">// Corner Case: If no trapframe(env context) is given, do nothing</span></span><br><span class="line">	<span class="keyword">if</span>(tf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cprintf(<span class="string">&quot;No Env is Running! This is Not a Debug Monitor!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Because we want the program to single step, set the TF bit</span></span><br><span class="line">	tf-&gt;tf_eflags |= (FL_TF);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Changes in trap_init</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">handlerx</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">// Debug Exception could be trap or Fault</span></span><br><span class="line">	SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, DEBUG, <span class="number">3</span>);</span><br><span class="line">	<span class="type">void</span> <span class="title function_">handlerx</span><span class="params">()</span>;</span><br><span class="line">	SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, NMI, <span class="number">0</span>);</span><br><span class="line">	<span class="type">void</span> <span class="title function_">handlerx</span><span class="params">()</span>;</span><br><span class="line">	SETGATE(idt[T_BRKPT], <span class="number">1</span>, GD_KT, BRKPT, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户进程通过系统调用来让内核为他们服务。当用户进程召起一次系统调用，处理器将进入内核态，处理器以及内核合作存储用户进程的状态，内核将执行适当的代码来完成系统调用，最后返回用户进程继续执行。实现细节各个系统有所不同。</p>
<p>JOS 内核使用<code>int</code>指令来触发一个处理器中断。特别的，我们使用<code>int $0x30</code>作为系统调用中断。它并不能由硬件产生，因此使用它不会产生歧义。</p>
<p>应用程序会把系统调用号 (与中断向量不是一个东西) 以及系统调用参数传递给寄存器。这样，内核就不用在用户栈或者指令流里查询这些信息。系统调用号将存放于<code>%eax</code>，参数（至多5个）会存放于<code>%edx</code>, <code>%ecx</code>, <code>%ebx</code>, <code>%edi</code>以及<code>%esi</code>，调用结束后，内核将返回值放回到<code>%eax</code>。之所以用<code>%eax</code>来传递返回值，是由于系统调用导致了栈的切换。</p>
<p><code>kern</code>中有一套<code>syscall.h</code>，<code>syscall.c</code>，<code>inc</code>和<code>lib</code>中又有一套<code>syscall.h</code>，<code>syscall.c</code>。需要理清这两者之间的关系。</p>
<p>inc/syscall.h<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_INC_SYSCALL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOS_INC_SYSCALL_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* system call numbers */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    SYS_cputs = <span class="number">0</span>,</span><br><span class="line">    SYS_cgetc,</span><br><span class="line">    SYS_getenvid,</span><br><span class="line">    SYS_env_destroy,</span><br><span class="line">    NSYSCALLS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !JOS_INC_SYSCALL_H */</span></span></span><br></pre></td></tr></table></figure><br>这个头文件主要定义了系统调用号，实际就是一个 enum 而已。</p>
<p>lib/syscall.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call stubs.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int32_t</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> check, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4, <span class="type">uint32_t</span> a5)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generic system call: pass system call number in AX,</span></span><br><span class="line">    <span class="comment">// up to five parameters in DX, CX, BX, DI, SI.</span></span><br><span class="line">    <span class="comment">// Interrupt kernel with T_SYSCALL.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The &quot;volatile&quot; tells the assembler not to optimize</span></span><br><span class="line">    <span class="comment">// this instruction away just because we don&#x27;t use the</span></span><br><span class="line">    <span class="comment">// return value.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The last clause tells the assembler that this can</span></span><br><span class="line">    <span class="comment">// potentially change the condition codes and arbitrary</span></span><br><span class="line">    <span class="comment">// memory locations.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;int %1\n&quot;</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;=a&quot;</span> (ret)</span></span><br><span class="line"><span class="params">             : <span class="string">&quot;i&quot;</span> (T_SYSCALL),</span></span><br><span class="line"><span class="params">               <span class="string">&quot;a&quot;</span> (num),</span></span><br><span class="line"><span class="params">               <span class="string">&quot;d&quot;</span> (a1),</span></span><br><span class="line"><span class="params">               <span class="string">&quot;c&quot;</span> (a2),</span></span><br><span class="line"><span class="params">               <span class="string">&quot;b&quot;</span> (a3),</span></span><br><span class="line"><span class="params">               <span class="string">&quot;D&quot;</span> (a4),</span></span><br><span class="line"><span class="params">               <span class="string">&quot;S&quot;</span> (a5)</span></span><br><span class="line"><span class="params">             : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(check &amp;&amp; ret &gt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;syscall %d returned %d (&gt; 0)&quot;</span>, num, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall(SYS_cputs, <span class="number">0</span>, (<span class="type">uint32_t</span>)s, len, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_cgetc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_destroy</span><span class="params">(<span class="type">envid_t</span> envid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_env_destroy, <span class="number">1</span>, envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">envid_t</span></span><br><span class="line"><span class="title function_">sys_getenvid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> syscall(SYS_getenvid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个里边先定义了一个通用的syscall接口，用于被其他系统调用这个通用的接口。</p>
<h4 id="补充知识：GCC内联汇编"><a href="#补充知识：GCC内联汇编" class="headerlink" title="补充知识：GCC内联汇编"></a>补充知识：GCC内联汇编</h4><p>其语法固定为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asm volatile (“asm code”：output：input：changed);</span><br><span class="line"></span><br><span class="line">    asm volatile(&quot;int %1\n&quot;</span><br><span class="line">             : &quot;=a&quot; (ret)</span><br><span class="line">             : &quot;i&quot; (T_SYSCALL),</span><br><span class="line">               &quot;a&quot; (num),</span><br><span class="line">               &quot;d&quot; (a1),</span><br><span class="line">               &quot;c&quot; (a2),</span><br><span class="line">               &quot;b&quot; (a3),</span><br><span class="line">               &quot;D&quot; (a4),</span><br><span class="line">               &quot;S&quot; (a5)</span><br><span class="line">             : &quot;cc&quot;, &quot;memory&quot;);</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>限定符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>“m”、”v”、”o”</td>
<td>内存单元</td>
</tr>
<tr>
<td>“r”</td>
<td>任何寄存器</td>
</tr>
<tr>
<td>“q”</td>
<td>寄存器eax、ebx、ecx、edx之一</td>
</tr>
<tr>
<td>“i”、”h”</td>
<td>直接操作数</td>
</tr>
<tr>
<td>“E”、”F”</td>
<td>浮点数</td>
</tr>
<tr>
<td>“g”</td>
<td>任意</td>
</tr>
<tr>
<td>“a”、”b”、”c”、”d”</td>
<td>分别表示寄存器eax、ebx、ecx和edx</td>
</tr>
<tr>
<td>“S”、”D”</td>
<td>寄存器esi、edi</td>
</tr>
<tr>
<td>“I”</td>
<td>常数 (0至31)</td>
</tr>
</tbody>
</table>
</div>
<p>除了这些约束之外，输出值还包含一个约束修饰符:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>可以读取和写入操作数</td>
</tr>
<tr>
<td>=</td>
<td>只能写入操作数</td>
</tr>
<tr>
<td>%</td>
<td>如果有必要操作数可以和下一个操作数切换</td>
</tr>
<tr>
<td>&amp;</td>
<td>在内联函数完成之前, 可以删除和重新使用操作数</td>
</tr>
</tbody>
</table>
</div>
<p>根据表格内容，可以看出该内联汇编作用就是引发一个int中断，中断向量为立即数<code>T_SYSCALL</code>，同时，对寄存器进行操作。</p>
<p>首先不要忘记在<code>kern/trap.c</code>中的<code>trap_init</code>中设置好入口，并且权限设为3，使得用户进程能够产生这个中断。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, handler48, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>另外就是<code>trap_dispatch</code>函数中加入相应的处理方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">    tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, </span><br><span class="line">                    tf-&gt;tf_regs.reg_edx,</span><br><span class="line">                    tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">                    tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">                    tf-&gt;tf_regs.reg_edi,</span><br><span class="line">                    tf-&gt;tf_regs.reg_esi);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br>由于已经通过<code>lib/syscall.c</code>处理，<code>tf</code>结构体中存储的寄存器状态已经记录了系统调用号，系统调用参数等等。现在我们就可以利用这些信息调用<code>kern/syscall.c</code>中的函数了。</p>
<p>在函数<code>trap_dispatch</code>中，被分发到函数<code>handle_syscall</code>。在<code>handle_syscall</code>中调用真正的<code>syscall</code>函数，进行二次分发和运行。内核调用的函数<code>syscall</code>和用户调用的不同，前者在<code>kern/syscall.c</code>中，根据<code>syscallno</code>选择处理函数执行，如下：</p>
<p>kern/syscall.h<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">uint32_t</span> num, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4, <span class="type">uint32_t</span> a5)</span>;</span><br></pre></td></tr></table></figure><br>用户调用的syscall函数接受6个参数。第一个是系统调用序号，告诉内核要使用那个处理函数，进入寄存器eax。后5个是传递给内核中的处理函数的参数，进入剩下的寄存器edx, ecx, ebx, edi, esi。这些寄存器都在中断产生时被压栈了，可以通过Trapframe访问到。</p>
<p>我们在<code>kern/trap.c</code>中调用的实际上就是这里的<code>syscall</code>函数，而不是<code>lib/syscall.c</code>中的那个。想明白这一点，设置参数也就很简单了，注意返回值的处理。</p>
<p>kern/syscall.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">uint32_t</span> syscallno, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4, <span class="type">uint32_t</span> a5)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line">    <span class="comment">// Return any appropriate return value.</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic(&quot;syscall not implemented&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">        sys_cputs((<span class="type">const</span> <span class="type">char</span> *)a1, a2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">        retVal = sys_cgetc();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">        retVal = sys_env_destroy(a1);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">        retVal = sys_getenvid() &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">        <span class="comment">// retVal = sys_getenvid() &gt;= 0; 错误，应该返回获取的id</span></span><br><span class="line">        <span class="comment">// 返回值不仅是用于判断执行成功与否，也可能携带信息</span></span><br><span class="line">        retVal = sys_getenvid();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        retVal = -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以<code>user/hello.c</code>为例，其中调用了<code>cprintf()</code>，注意这是<code>lib/print.c</code>中的<code>cprintf</code>，该<code>cprintf()</code>最终会调用<code>lib/syscall.c</code>中的<code>sys_cputs()</code>，<code>sys_cputs()</code>又会调用<code>lib/syscall.c</code>中的<code>syscall()</code>，该函数将系统调用号放入<code>%eax</code>寄存器，五个参数依次放入in DX, CX, BX, DI, SI，然后执行指令<code>int 0x30</code>，发生中断后，去IDT中查找中断处理函数，最终会走到<code>kern/trap.c</code>的<code>trap_dispatch()</code>中，我们根据中断号<code>0x30</code>，又会调用<code>kern/syscall.c</code>中的<code>syscall()</code>函数（注意这时候我们已经进入了内核模式CPL=0），在该函数中根据系统调用号调用<code>kern/print.c</code>中的<code>cprintf()</code>函数，该函数最终调用<code>kern/console.c</code>中的<code>cputchar()</code>将字符串打印到控制台。当<code>trap_dispatch()</code>返回后，<code>trap()</code>会调用<code>env_run(curenv);</code>，该函数前面讲过，会将<code>curenv-&gt;env_tf</code>结构中保存的寄存器快照重新恢复到寄存器中，这样又会回到用户程序系统调用之后的那条指令运行，只是这时候已经执行了系统调用并且寄存器eax中保存着系统调用的返回值。任务完成重新回到用户模式CPL=3。</p>
<p>通过 exercise 7，可以看出 JOS系 统调用的步骤为：</p>
<ul>
<li>用户进程使用<code>inc/</code>目录下暴露的接口</li>
<li><code>lib/syscall.c</code>中的函数将系统调用号及必要参数传给寄存器，并引起一次<code>int $0x30</code>中断</li>
<li><code>kern/trap.c</code>捕捉到这个中断，并将<code>TrapFrame</code>记录的寄存器状态作为参数，调用处理中断的函数</li>
<li><code>kern/syscall.c</code>处理中断</li>
</ul>
<p><strong>记住这两个execrise能成功执行的话，需要在SETGATE中把这个设置成用户进程能够调用！！！</strong></p>
<h3 id="用户进程启动"><a href="#用户进程启动" class="headerlink" title="用户进程启动"></a>用户进程启动</h3><p>用户进程从<code>lib/entry.S</code>开始运行。经过一些设置，调用了<code>lib/libmain.c</code>下的<code>libmain()</code>函数。在<code>libmain()</code>中，我们需要把全局指针<code>thisenv</code>指向该程序在<code>envs[]</code>数组中的位置。</p>
<p><code>libmain()</code>会调用<code>umain</code>，即用户进程的<code>main</code>函数。在<code>user/hello.c</code>中，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    cprintf(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    cprintf(<span class="string">&quot;i am environment %08x\n&quot;</span>, thisenv-&gt;env_id);  <span class="comment">// 之前就在这里报错，因为thisenv = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Exercise 8 中，我们将设置好<code>thisenv</code>，这样就能正常运行用户进程了。这也是我们第一次用到内存的 UENVS 区域。</p>
<p>在<code>lib/libmain.c</code>中把<code>thisenv = 0</code>改为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br></pre></td></tr></table></figure></p>
<h3 id="页错误-amp-内存保护"><a href="#页错误-amp-内存保护" class="headerlink" title="页错误 &amp; 内存保护"></a>页错误 &amp; 内存保护</h3><p>内存保护是操作系统的关键功能，它确保了一个程序中的错误不会导致其他程序或是操作系统自身的崩溃。</p>
<p>操作系统通常依赖硬件的支持来实现内存保护。操作系统会告诉硬件哪些虚拟地址可用哪些不可用。当某个程序想访问不可用的内存地址或不具备权限时，处理器将在出错指令处停止程序，然后陷入内核。如果错误可以处理，内核就处理并恢复程序运行，否则无法恢复。</p>
<p>作为可以修复的错误，设想某个自动生长的栈。在许多系统中内核首先分配一个页面给栈，如果某个程序访问了页面外的空间，内核会自动分配更多页面以让程序继续。这样，内核只用分配程序需要的栈内存给它，然而程序感觉仿佛可以拥有任意大的栈内存。</p>
<p>系统调用也为内存保护带来了有趣的问题。许多系统调用接口允许用户传递指针给内核，这些指针指向待读写的用户缓冲区。内核处理系统调用的时候会对这些指针解引用。这样就带来了两个问题：</p>
<ol>
<li>内核的页错误通常比用户进程的页错误严重得多，如果内核在操作自己的数据结构时发生页错误，这就是一个内核bug，会引起系统崩溃。因此，内核需要记住这个错误是来自用户进程。</li>
<li>内核比用户进程拥有更高的内存权限，用户进程给内核传递的指针可能指向一个只有内核能够读写的区域，内核必须谨慎避免解引用这类指针，因为这样可能导致内核的私有信息泄露或破坏内核完整性。</li>
</ol>
<p>我们将对用户进程传给内核的指针做一个检查来解决这两个问题。内核将检查指针指向的是内存中用户空间部分，页表也允许内存操作。</p>
<p>Exercise 9需要修改<code>kern/trap.c</code>，使得内核态下的缺页能够引起panic。这需要检查<code>tf_cs</code>的地位。在<code>kern/trap.c</code>中加入判断页错误来源。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_fault_handler</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">    fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// 在这里判断 cs 的低 2bit</span></span><br><span class="line">    <span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) panic(<span class="string">&quot;Page fault in kernel-mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">    <span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">    cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">        curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/pmap.c</code>中修改检查用户内存的部分。需要注意的是由于需要存储第一个访问出错的地址，<code>va</code>所在的页面需要单独处理一下，不能直接对齐。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Check that an environment is allowed to access the range of memory</span></span><br><span class="line"><span class="comment">// [va, va+len) with permissions &#x27;perm | PTE_P&#x27;.</span></span><br><span class="line"><span class="comment">// Normally &#x27;perm&#x27; will contain PTE_U at least, but this is not required.</span></span><br><span class="line"><span class="comment">// &#x27;va&#x27; and &#x27;len&#x27; need not be page-aligned; you must test every page that</span></span><br><span class="line"><span class="comment">// contains any of that range.  You will test either &#x27;len/PGSIZE&#x27;,</span></span><br><span class="line"><span class="comment">// &#x27;len/PGSIZE + 1&#x27;, or &#x27;len/PGSIZE + 2&#x27; pages.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A user program can access a virtual address if (1) the address is below</span></span><br><span class="line"><span class="comment">// ULIM, and (2) the page table gives it permission.  These are exactly</span></span><br><span class="line"><span class="comment">// the tests you should implement here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If there is an error, set the &#x27;user_mem_check_addr&#x27; variable to the first</span></span><br><span class="line"><span class="comment">// erroneous virtual address.</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">user_mem_check</span><span class="params">(<span class="keyword">struct</span> Env *env, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">size_t</span> len, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="type">uintptr_t</span> start_va = ROUNDDOWN((<span class="type">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">    <span class="type">uintptr_t</span> end_va = ROUNDUP((<span class="type">uintptr_t</span>)va + len, PGSIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uintptr_t</span> cur_va=start_va; cur_va&lt;end_va; cur_va+=PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *cur_pte = pgdir_walk(env-&gt;env_pgdir, (<span class="type">void</span> *)cur_va, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cur_pte == <span class="literal">NULL</span> || (*cur_pte &amp; (perm|PTE_P)) != (perm|PTE_P) || cur_va &gt;= ULIM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_va == start_va) &#123;</span><br><span class="line">                user_mem_check_addr = (<span class="type">uintptr_t</span>)va;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                user_mem_check_addr = cur_va;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/syscall.c</code>中的输出字符串部分加入内存检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">    <span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    user_mem_assert(curenv, s, len, PTE_U);</span><br><span class="line">    <span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">    cprintf(<span class="string">&quot;%.*s&quot;</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/kdebug.c</code>中的<code>debuginfo_eip</code>函数中加入内存检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Make sure this memory is valid.</span></span><br><span class="line">        <span class="comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span></span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">        <span class="keyword">if</span> (user_mem_check(curenv, (<span class="type">void</span> *)usd, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UserStabData), PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// Make sure the STABS and string table memory is valid.</span></span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">        <span class="keyword">if</span> (user_mem_check(curenv, (<span class="type">void</span> *)stabs, stab_end-stabs, PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (user_mem_check(curenv, (<span class="type">void</span> *)stabstr, stabstr_end-stabstr, PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="TA’s-Exercise"><a href="#TA’s-Exercise" class="headerlink" title="TA’s Exercise"></a>TA’s Exercise</h3><p>在 JOS 中添加一个展示进程信息的系统调用 ( 请在<code>inc/syscall.h</code>中定义<code>SYS_show_environments</code>)，该系统调用可打印出所有进程的信息 ( 即<code>struct Env</code>的 内容，只打印<code>env_id</code>，寄存器信息等重要内容即可 )。</p>
<h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p>在<code>inc/syscall.h</code>中的枚举中定义变量<code>SYS_show_environments</code>，后在<code>kern/syscall.c</code>中定义函数<code>static void sys_show_environments(void)</code>打印<code>envs</code>数组中正在进行的进程的<code>env_id</code>以及状态 ( 不包括<code>env_status == ENV_NOT_RUNNABLE</code>)，并且在文件末尾<code>syscall</code>函数中加入新加<code>system call</code>。到此为止，我们设置完了在 kernel model 下新系统调用的调用过程，之后转向 user model. 在<code>inc/lib</code>中声明刚定义的系统调用，并转到<code>lib/syscall.c</code>下的<code>syscall.c</code>中，利用<code>syscall</code>调用之前定义在<code>kernel</code>中的<code>sys_show_environments(void)</code>，最后在<code>user/hello.c</code>中加入了这个调用就可以看到结果了.</p>
<h4 id="调用过程及代码实现"><a href="#调用过程及代码实现" class="headerlink" title="调用过程及代码实现"></a>调用过程及代码实现</h4><p><code>user/hello.c</code>调用在<code>inc/lib.h</code>中声明的<code>sys_show_environments()</code>，也就是在<code>lib/syscall.c</code>中定义的 ( 面对 user model 的 )<code>sys_show_environments()</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// at inc/lib.h:42</span><br><span class="line">void sys_show_environments(void);</span><br></pre></td></tr></table></figure></p>
<p>应用程序调用<code>inc/lib.h</code>中的<code>sys_show_environments()</code>函数，在<code>lib/syscall.c</code>中函数调用<code>syscall()</code>并且传参<code>SYS_show_environments</code>给<code>syscall()</code>。之后<code>syscall()</code>利用内联汇编 trap into the kernel 并将<code>T_SYSCALL</code>，<code>SYS_show_environments</code>这两个参数传给给后续函数 ( 后面虽然还传递了好几个 0 但是这里没有用就当他们不存在，而这里<code>T_SYSCALL</code>( 作为立即数传入 “i” ) 是用来做为索引给<code>IDT</code>找到<code>SystemCall</code>这个<code>Interrupt</code>的<code>Gate</code>( 当然这也是之后<code>trap_dispatch()</code>要用到的参数 )，而之后的<code>SYS_show_environments</code>会被放入<code>%eax</code>中，之后将通过<code>Trapfram</code>进入<code>kernel model</code>下的<code>stack</code>被<code>kernel</code>中的<code>system call</code>识别并调用对应的系统调用。)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// at lib/syscall.c:64</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sys_show_environments</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall(SYS_show_environments, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>trap_dispatch()</code>中选择<code>syscall()</code>函数，并将<code>Trapfram</code>中的”寄存器” ( 其实是在 kernel stack 中 ) 保存的数据作为参数传入，之后在<code>kern/syscall.c</code>中<code>syscall()</code>选择<code>sys_show_environments()</code>函数打印进程相关信息.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sys_show_environments</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NENV; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (envs[i].env_status == ENV_FREE || \</span><br><span class="line">        envs[i].env_status == ENV_NOT_RUNNABLE)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cprintf(<span class="string">&quot;Environment env_id: %x\tstatus: &quot;</span>, envs[i].env_id);</span><br><span class="line">        <span class="keyword">switch</span>(envs[i].env_status)&#123;</span><br><span class="line">            <span class="keyword">case</span> ENV_DYING:</span><br><span class="line">                cprintf(<span class="string">&quot;ENV_DYING\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ENV_RUNNABLE:</span><br><span class="line">                cprintf(<span class="string">&quot;ENV_RUNNABLE\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ENV_RUNNING:</span><br><span class="line">                cprintf(<span class="string">&quot;ENV_RUNNING\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">uint32_t</span> syscallno, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4, <span class="type">uint32_t</span> a5)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line">    <span class="comment">// Return any appropriate return value.</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">        <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">            sys_cputs((<span class="type">char</span> *)a1, (<span class="type">size_t</span>)a2);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">            <span class="keyword">return</span> sys_cgetc();</span><br><span class="line">        <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">            <span class="keyword">return</span> sys_getenvid();</span><br><span class="line">        <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">            <span class="keyword">return</span> sys_env_destroy((<span class="type">envid_t</span>)a1);</span><br><span class="line">        <span class="keyword">case</span> SYS_show_environments:</span><br><span class="line">            sys_show_environments();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> NSYSCALLS:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">&quot;syscall not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回顾下，本实验大致做了三件事：</p>
<ul>
<li>进程建立，可以加载用户ELF文件并执行。<ul>
<li>内核维护一个名叫<code>envs</code>的<code>Env</code>数组，每个<code>Env</code>结构对应一个进程，<code>Env</code>结构最重要的字段有<code>Trapframe env_tf</code>（该字段中断发生时可以保持寄存器的状态），<code>pde_t *env_pgdir</code>（该进程的页目录地址）。进程对应的内核数据结构可以用下图总结：</li>
<li>定义了<code>env_init()</code>，<code>env_create()</code>等函数，初始化<code>Env</code>结构，将<code>Env</code>结构<code>Trapframe env_tf</code>中的寄存器值设置到寄存器中，从而执行该<code>Env</code>。</li>
</ul>
</li>
</ul>
<p><img src="/img/20211121113100.png" alt=""></p>
<ul>
<li>创建异常处理函数，建立并加载IDT，使JOS能支持中断处理。要能说出中断发生时的详细步骤。需要搞清楚内核态和用户态转换方式：通过中断机制可以从用户环境进入内核态。使用iret指令从内核态回到用户环境。<ul>
<li>新建一个中断的步骤主要有：创建一个define标号，SETGATE注册中断和处理函数、特权级；在trap_dispatch中注册。</li>
<li>中断发生过程以及中断返回过程和系统调用原理可以总结为下图：</li>
</ul>
</li>
</ul>
<p><img src="/img/20211121113101.png" alt=""></p>
<ul>
<li>利用中断机制，使JOS支持系统调用。要能说出遇到int 0x30这条系统调用指令时发生的详细步骤。</li>
</ul>
<h1 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>在 lab4 中我们将实现多个同时运行的用户进程之间的抢占式多任务处理。</p>
<ul>
<li>在 part A 中，我们需要给 JOS 增加多处理器支持。实现轮询( round-robin, RR )调度，并增加基本的用户程序管理系统调用( 创建和销毁进程，分配和映射内存 )。</li>
<li>在 part B 中，我们需要实现一个与 Unix 类似的<code>fork()</code>，允许一个用户进程创建自己的拷贝。</li>
<li>在 part C中，我们会添加对进程间通信 ( IPC ) 的支持，允许不同的用户进程相互通信和同步。还要增加对硬件时钟中断和抢占的支持。</li>
</ul>
<p>Lab 4 包含许多新的源文件：</p>
<ul>
<li><code>kern/cpu.h</code>：多处理器支持的内核私有定义</li>
<li><code>kern/mpconfig.c</code>：读取多处理器配置的代码</li>
<li><code>kern/lapic.c</code>：驱动每个处理器中的本地 APIC 单元的内核代码</li>
<li><code>kern/mpentry.S</code>：非引导 CPU 的汇编语言入口代码</li>
<li><code>kern/spinlock.h</code>：自旋锁的内核私有定义，包括大内核锁</li>
<li><code>kern/spinlock.c</code>：实现自旋锁的内核代码</li>
<li><code>kern/sched.c</code>：将要实现的调度程序的代码框架</li>
</ul>
<h2 id="Part-A-多处理器支持及协同多任务处理"><a href="#Part-A-多处理器支持及协同多任务处理" class="headerlink" title="Part A: 多处理器支持及协同多任务处理"></a>Part A: 多处理器支持及协同多任务处理</h2><p>我们首先需要把 JOS 扩展到在多处理器系统中运行。然后实现一些新的 JOS 系统调用来允许用户进程创建新的进程。我们还要实现协同轮询调度，在当前进程不使用 CPU 时允许内核切换到另一个进程。</p>
<h3 id="多处理器支持"><a href="#多处理器支持" class="headerlink" title="多处理器支持"></a>多处理器支持</h3><p>我们即将使 JOS 能够支持“对称多处理” (Symmetric MultiProcessing, SMP)。这种模式使所有 CPU 能对等地访问内存、I/O 总线等系统资源。虽然 CPU 在 SMP 下以同样的方式工作，在启动过程中他们可以被分为两个类型：</p>
<ul>
<li>引导处理器(BootStrap Processor, BSP) 负责初始化系统以及启动操作系统；</li>
<li>应用处理器( Application Processors, AP ) 在操作系统拉起并运行后由 BSP 激活。</li>
</ul>
<p>哪个 CPU 作为 BSP 由硬件和 BIOS 决定。也就是说目前我们所有的 JOS 代码都运行在 BSP 上。</p>
<p>在 SMP 系统中，每个 CPU 都有一个附属的 (local APIC) LAPIC 单元。LAPIC 单元用于传递中断，并给它所属的 CPU 一个唯一的 ID。在 lab4 中，我们将会用到 LAPIC 单元的以下基本功能 ( 见<code>kern/lapic.c1</code>)：</p>
<ul>
<li>读取 APIC ID 来判断我们的代码运行在哪个 CPU 之上。</li>
<li>从 BSP 发送 STARTUP 跨处理器中断 (InterProcessor Interrupt, IPI) 来启动 AP。</li>
<li>在 part C 中，我们为 LAPIC 的内置计时器编程来触发时钟中断以支持抢占式多任务处理。</li>
</ul>
<p>处理器通过映射在内存上的 I/O (Memory-Mapped I/O, MMIO) 来访问它的 LAPIC。在 MMIO 中，物理内存的一部分被硬连接到一些 I/O 设备的寄存器，因此，访问内存的 load/store 指令可以被用于访问设备的寄存器。实际上，我们在 lab1 中已经接触过这样的 IO hole，如0xA0000被用来写 VGA 显示缓冲。</p>
<p>LAPIC 开始于物理地址 0xFE000000 ( 4GB以下32MB处 )。如果用以前的映射算法（将0xF0000000 映射到 0x00000000，也就是说内核空间最高只能到物理地址0x0FFFFFFF）显然太高了。因此，JOS 在<code>MMIOBASE</code>(即 虚拟地址0xEF800000) 预留了 4MB 来映射这类设备。我们需要写一个函数来分配这个空间并在其中映射设备内存。</p>
<p>exercise1需要实现<code>kern/pmap.c</code>中的<code>mmio_map_region</code>。首先还得去看<code>kern/lapic.c</code>中<code>lapic_init</code>的实现。<code>lapic_init()</code>函数的一开始就调用了该函数，将从<code>lapicaddr</code>开始的 4kB 物理地址映射到虚拟地址，并返回其起始地址。注意到，它是以页为单位对齐的，每次都<code>map</code>一个页的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">lapic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (!lapicaddr)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lapicaddr is the physical address of the LAPIC&#x27;s 4K MMIO</span></span><br><span class="line">        <span class="comment">// region.  Map it in to virtual memory so we can access it.</span></span><br><span class="line">        lapic = mmio_map_region(lapicaddr, <span class="number">4096</span>);</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从基址开始保留大小字节的虚拟内存并将物理页 [pa,pa+size) 映射到虚拟地址 [base,base+size)。 由于这是设备内存而不是常规 DRAM，因此您必须告诉 CPU 缓存访问此内存是不安全的。幸运的是，分页表为此提供了位；除了<code>PTE_W</code>之外，只需使用<code>PTE_PCD|PTE_PWT</code>（缓存禁用和直写）创建映射。</p>
<p>实际就是调用<code>boot_map_region</code>来建立所需要的映射，需要注意的是，每次需要更改base的值，使得每次都是映射到一个新的页面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span></span><br><span class="line"><span class="comment">// location.  Return the base of the reserved region.  size does *not*</span></span><br><span class="line"><span class="comment">// have to be multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">mmio_map_region</span><span class="params">(<span class="type">physaddr_t</span> pa, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">physaddr_t</span> pa_begin = ROUNDDOWN(pa, PGSIZE);</span><br><span class="line">	<span class="type">physaddr_t</span> pa_end = ROUNDUP(pa + size, PGSIZE);</span><br><span class="line">	<span class="keyword">if</span> (pa_end - pa_begin &gt;= MMIOLIM - MMIOBASE) &#123;</span><br><span class="line">	    panic(<span class="string">&quot;mmio_map_region: requesting size too large.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	size = pa_end - pa_begin;</span><br><span class="line">	boot_map_region(kern_pgdir, base, size, pa_begin, PTE_W | PTE_PCD | PTE_PWT);</span><br><span class="line">	<span class="type">void</span> *ret = (<span class="type">void</span> *)base;</span><br><span class="line">	base += size;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="引导应用处理器"><a href="#引导应用处理器" class="headerlink" title="引导应用处理器"></a>引导应用处理器</h3><p>在启动 APs 之前，<code>BSP</code>需要先搜集多处理器系统的信息，例如 CPU 的总数，CPU 各自的 APIC ID，LAPIC 单元的 MMIO 地址。<code>kern/mpconfig.c</code>中的<code>mp_init()</code>函数通过阅读 BIOS 区域内存中的 MP 配置表来获取这些信息。</p>
<p><code>boot_aps()</code>函数驱动了 AP 的引导。APs 从实模式开始，如同<code>boot/boot.S</code>中<code>bootloader</code>的启动过程。因此<code>boot_aps()</code>将 AP 的入口代码 (<code>kern/mpentry.S</code>) 拷贝到实模式可以寻址的内存区域 (0x7000,<code>MPENTRY_PADDR</code>)。</p>
<p>此后，<code>boot_aps()</code>通过发送<code>STARTUP</code>这个跨处理器中断到各 LAPIC 单元的方式，逐个激活 APs。激活方式为：初始化 AP 的<code>CS:IP</code>值使其从入口代码执行（<code>MPENTRY_PADDR</code>）。<code>kern/mpentry.S</code>中的入口代码跟<code>boot/boot.S</code>中的代码相同。通过一些简单的设置，AP 开启分页进入保护模式，然后调用 C 语言编写的<code>mp_main()</code>。<code>boot_aps()</code>等待 AP 发送<code>CPU_STARTED</code>信号，然后再唤醒下一个。</p>
<p>先看<code>boot_aps()</code>，注释比较清楚，将入口代码复制到<code>MPENTRY_PADDR</code>中，遍历cpu，告诉<code>mpentry.S</code>栈的入口在哪，函数<code>lapic_startup</code>向指定处理器发送信号，触发了中断，让处理器从指定地址开始执行。APIC更具体的操作细节我们就不关心了。启动，等待完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the non-boot (AP) processors.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_aps</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> mpentry_start[], mpentry_end[];</span><br><span class="line">    <span class="type">void</span> *code;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> *<span class="title">c</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write entry code to unused memory at MPENTRY_PADDR</span></span><br><span class="line">    code = KADDR(MPENTRY_PADDR);</span><br><span class="line">    memmove(code, mpentry_start, mpentry_end - mpentry_start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boot each AP one at a time</span></span><br><span class="line">    <span class="keyword">for</span> (c = cpus; c &lt; cpus + ncpu; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == cpus + cpunum())  <span class="comment">// We&#x27;ve started already.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell mpentry.S what stack to use</span></span><br><span class="line">        mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;</span><br><span class="line">        <span class="comment">// Start the CPU at mpentry_start</span></span><br><span class="line">        lapic_startap(c-&gt;cpu_id, PADDR(code));</span><br><span class="line">        <span class="comment">// Wait for the CPU to finish some basic setup in mp_main()</span></span><br><span class="line">        <span class="keyword">while</span>(c-&gt;cpu_status != CPU_STARTED)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>mpentry.S</code>中，每一个没有启动的CPU(“AP”)都会因为一个<code>STARTUP</code>中断而启动。AP启动时，<code>CS:IP</code>会被设置成<code>XY00:0000</code>，<code>XY</code>是跟着<code>STARTUP</code>一起送过来的值。</p>
<p>代码中设置<code>DS</code>为0，必须从物理地址中的低2^16字节开始运行。</p>
<p>在系统加载的过程中，<code>boot_aps()</code>被调用，然后按照前文所述使用<code>memmove()</code>函数从<code>mpentry.S</code>中拷贝文件中<code>.global mpentry_start</code>标签处开始的入口代码直到<code>.global mpentry_end</code>结束，代码被拷贝到<code>MPENTRY_PADDR</code>（此处是0x7000的I/O hole）对应的内核虚拟地址（别忘了必须拷贝到内核虚拟地址才可以被内核所操作）。然后<code>boot_aps()</code>根据每一个CPU的栈配置<code>percpu_kstacks[]</code>来为每一个AP设置栈地址<code>mpentry_stack</code>。再之后调用<code>lapic_startup()</code>函数来启动AP，并等待AP的状态变为<code>CPU_STARTED</code>以切换到下一个AP的配置。AP启动后会开启分页机制和保护模式，切换运行栈，然后跳转到<code>mp_main()</code>函数。</p>
<p>在<code>mp_main()</code>函数中，使用<code>lcr3</code>指令切换页目录到<code>kern_pgdir</code>，初始化LAPIC、用户环境和陷阱处理机制。最后设置<code>struct CpuInfo</code>中的<code>cpu_status</code>为<code>CPU_STARTED</code>来告知BPS已经启动成功。</p>
<p>此代码类似于<code>boot/boot.S</code>，不同之处在于</p>
<ul>
<li>不需要启用A20</li>
<li>它使用<code>MPBOOTPHYS</code>计算其绝对地址符号，而不是依赖链接器来填充它们</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">.set PROT_MODE_CSEG, 0x8        ## kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10       ## kernel data segment selector</span><br><span class="line"></span><br><span class="line">.code16</span><br><span class="line">.globl mpentry_start</span><br><span class="line">mpentry_start:</span><br><span class="line">        cli</span><br><span class="line"></span><br><span class="line">        xorw    %ax, %ax</span><br><span class="line">        movw    %ax, %ds</span><br><span class="line">        movw    %ax, %es</span><br><span class="line">        movw    %ax, %ss</span><br><span class="line"></span><br><span class="line">        lgdt    MPBOOTPHYS(gdtdesc)</span><br><span class="line">        movl    %cr0, %eax</span><br><span class="line">        orl     $CR0_PE, %eax</span><br><span class="line">        movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line">        ljmpl   $(PROT_MODE_CSEG), $(MPBOOTPHYS(start32))</span><br><span class="line"></span><br><span class="line">.code32</span><br><span class="line">start32:</span><br><span class="line">        movw    $(PROT_MODE_DSEG), %ax</span><br><span class="line">        movw    %ax, %ds</span><br><span class="line">        movw    %ax, %es</span><br><span class="line">        movw    %ax, %ss</span><br><span class="line">        movw    $0, %ax</span><br><span class="line">        movw    %ax, %fs</span><br><span class="line">        movw    %ax, %gs</span><br><span class="line"></span><br><span class="line">        ## Set up initial page table. We cannot use kern_pgdir yet because</span><br><span class="line">        ## we are still running at a low EIP.</span><br><span class="line">        movl    $(RELOC(entry_pgdir)), %eax</span><br><span class="line">        movl    %eax, %cr3</span><br><span class="line">        ## Turn on paging.</span><br><span class="line">        movl    %cr0, %eax</span><br><span class="line">        orl     $(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">        movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line">        ## Switch to the per-cpu stack allocated in boot_aps()</span><br><span class="line">        movl    mpentry_kstack, %esp</span><br><span class="line">        movl    $0x0, %ebp       ## nuke frame pointer</span><br><span class="line"></span><br><span class="line">        ## Call mp_main().  (Exercise for the reader: why the indirect call?)</span><br><span class="line">        movl    $mp_main, %eax</span><br><span class="line">        call    *%eax</span><br><span class="line"></span><br><span class="line">        ## If mp_main returns (it shouldn&#x27;t), loop.</span><br><span class="line">spin:</span><br><span class="line">        jmp     spin</span><br><span class="line"></span><br><span class="line">## Bootstrap GDT</span><br><span class="line">.p2align 2                                      ## force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">        SEG_NULL                                ## null seg</span><br><span class="line">        SEG(STA_X|STA_R, 0x0, 0xffffffff)       ## code seg</span><br><span class="line">        SEG(STA_W, 0x0, 0xffffffff)             ## data seg</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">        .word   0x17                            ## sizeof(gdt) - 1</span><br><span class="line">        .long   MPBOOTPHYS(gdt)                 ## address gdt</span><br><span class="line"></span><br><span class="line">.globl mpentry_end</span><br><span class="line">mpentry_end:</span><br><span class="line">        nop</span><br></pre></td></tr></table></figure>
<p>我们修改文件<code>kern/pmap.c</code>中的函数<code>page_init</code>，在构建链表的时候避开AP使用的引导器的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4:</span></span><br><span class="line">    <span class="comment">// Change your code to mark the physical page at MPENTRY_PADDR as in use</span></span><br><span class="line"></span><br><span class="line">    pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> mp_page = MPENTRY_PADDR / PGSIZE;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == mp_page) &#123; <span class="comment">// lab 4</span></span><br><span class="line">            pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must never be allocated.</span></span><br><span class="line">    <span class="keyword">for</span> (i = IOPHYSMEM/PGSIZE; i &lt; EXTPHYSMEM/PGSIZE; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">    <span class="type">size_t</span> first_free_address = PADDR(boot_alloc(<span class="number">0</span>)) / PGSIZE;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; first_free_address; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; npages; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在执行<code>make qemu</code>，可以通过<code>check_kern_pgdir()</code>测试，但是不会通过<code>check_kern_pgdir()</code>检查。</p>
<p><code>kern/mpentry.S</code>是运行在<code>KERNBASE</code>之上的，与其他的内核代码一样。也就是说，类似于<code>mpentry_start</code>，<code>mpentry_end</code>，<code>start32</code>这类地址，都位于<code>0xf0000000</code>之上，显然，实模式是无法寻址的。再仔细看<code>MPBOOTPHYS</code>的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR)</span></span><br></pre></td></tr></table></figure></p>
<p>其意义可以表示为，从<code>mpentry_start</code>到<code>MPENTRY_PADDR</code>建立映射，将<code>mpentry_start + offset</code>地址转为<code>MPENTRY_PADDR + offset</code>地址。查看<code>kern/init.c</code>，发现已经完成了这部分地址的内容拷贝。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_aps</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> mpentry_start[], mpentry_end[];</span><br><span class="line">    <span class="type">void</span> *code;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> *<span class="title">c</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write entry code to unused memory at MPENTRY_PADDR</span></span><br><span class="line">    code = KADDR(MPENTRY_PADDR);</span><br><span class="line">    memmove(code, mpentry_start, mpentry_end - mpentry_start);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，实模式下就可以通过<code>MPBOOTPHYS</code>宏的转换，运行这部分代码。<code>boot.S</code>中不需要这个转换是因为代码的本来就被加载在实模式可以寻址的地方。</p>
<h3 id="CPU-状态和初始化"><a href="#CPU-状态和初始化" class="headerlink" title="CPU 状态和初始化"></a>CPU 状态和初始化</h3><p>当写一个多处理器操作系统时，分清 CPU 的私有状态 ( per-CPU state) 及全局状态 (global state) 非常关键。<code>kern/cpu.h</code>定义了大部分的 per-CPU 状态。我们需要注意的 per-CPU 状态有：</p>
<ul>
<li>Per-CPU 内核栈<ul>
<li>因为多 CPU 可能同时陷入内核态，我们需要给每个处理器一个独立的内核栈。<code>percpu_kstacks[NCPU][KSTKSIZE]</code></li>
<li>在 Lab2 中，我们将<code>BSP</code>的内核栈映射到了<code>KSTACKTOP</code>下方。相似地，在 Lab4 中，我们需要把每个 CPU 的内核栈都映射到这个区域，每个栈之间留下一个空页作为缓冲区避免<code>overflow</code>。CPU 0 ，即<code>BSP</code>的栈还是从<code>KSTACKTOP</code>开始，间隔<code>KSTACKGAP</code>的距离就是 CPU 1 的栈，以此类推。</li>
</ul>
</li>
<li>Per-CPU TSS 以及 TSS 描述符<ul>
<li>为了指明每个 CPU 的内核栈位置，需要任务状态段 (Task State Segment, TSS)，其功能在 Lab3 中已经详细讲过。</li>
</ul>
</li>
<li>Per-CPU 当前环境指针<ul>
<li>因为每个 CPU 能够同时运行各自的用户进程，我们重新定义了基于<code>cpus[cpunum()]</code>的<code>curenv</code>。</li>
</ul>
</li>
<li>Per-CPU 系统寄存器<ul>
<li>所有的寄存器，包括系统寄存器，都是 CPU 私有的。因此，初始化这些寄存器的指令，例如<code>lcr3()</code>,<code>ltr()</code>,<code>lgdt()</code>,<code>lidt()</code>等，必须在每个 CPU 都执行一次。</li>
</ul>
</li>
</ul>
<p>在<code>kern/cpu.h</code>中可以找到对<code>NCPU</code>、CPU状态、<code>CpuInfo</code>以及全局变量<code>percpu_kstacks</code>的声明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum number of CPUs</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NCPU  8</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CPU_UNUSED = <span class="number">0</span>,</span><br><span class="line">    CPU_STARTED,</span><br><span class="line">    CPU_HALTED,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Per-CPU state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> cpu_id;                 <span class="comment">// Local APIC ID; index into cpus[] below</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> cpu_status;   <span class="comment">// The status of the CPU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">cpu_env</span>;</span>            <span class="comment">// The currently-running environment.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span> <span class="title">cpu_ts</span>;</span>        <span class="comment">// Used by x86 to find stack for interrupt</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Per-CPU kernel stacks</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> percpu_kstacks[NCPU][KSTKSIZE];</span><br></pre></td></tr></table></figure></p>
<p><code>percpu_kstacks</code>的定义在<code>kern/mpconfig.c</code>中可以找到，以<code>PGSIZE</code>对齐：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU kernel stacks</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> percpu_kstacks[NCPU][KSTKSIZE]</span><br><span class="line">__attribute__ ((aligned(PGSIZE)));</span><br></pre></td></tr></table></figure></p>
<p><code>mp_init()</code>是进行初始化的函数，首先设置一个初始cpu，之后对每个CPU进行处理。先通过调用<code>mpconfig()</code>找到<code>struct mpconf</code>然后根据这个结构体内的<code>entries</code>信息对各个ＣＰＵ结构体进行配置．</p>
<p>如果<code>proc-&gt;flag</code>是<code>MPPROC_BOOT</code>，说明这个入口对应的处理器是用于启动的处理器，我们把结构体数组<code>cpus[ncpu]</code>地址赋值给<code>bootcpu</code>指针．注意这里ncpu是个全局变量，那么这里实质上就是把cpus数组的第一个元素的地址给了<code>bootcpu</code>. </p>
<p>那个<code>ismp</code>是个全局变量，默认的初始值为0, 但是我们进行<code>mp_init()</code>的时候，就把这个全局变量置为1了，如果出现任何entries匹配错误(switch找不到对应项，跳进default)，这个时候我们多可处理器的初始化就失败了，不能用多核处理器进行机器的运行，于是<code>ismp</code>置为0<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mp_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mp</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mpconf</span> *<span class="title">conf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mpproc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> *p;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    bootcpu = &amp;cpus[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> ((conf = mpconfig(&amp;mp)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ismp = <span class="number">1</span>;</span><br><span class="line">    lapicaddr = conf-&gt;lapicaddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = conf-&gt;entries, i = <span class="number">0</span>; i &lt; conf-&gt;entry; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (*p) &#123;</span><br><span class="line">        <span class="keyword">case</span> MPPROC:</span><br><span class="line">            proc = (<span class="keyword">struct</span> mpproc *)p;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;flags &amp; MPPROC_BOOT)</span><br><span class="line">                bootcpu = &amp;cpus[ncpu];</span><br><span class="line">            <span class="keyword">if</span> (ncpu &lt; NCPU) &#123;</span><br><span class="line">                cpus[ncpu].cpu_id = ncpu;</span><br><span class="line">                ncpu++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cprintf(<span class="string">&quot;SMP: too many CPUs, CPU %d disabled\n&quot;</span>,</span><br><span class="line">                       proc-&gt;apicid);</span><br><span class="line">            &#125;</span><br><span class="line">            p += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mpproc);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> MPBUS:</span><br><span class="line">        <span class="keyword">case</span> MPIOAPIC:</span><br><span class="line">        <span class="keyword">case</span> MPIOINTR:</span><br><span class="line">        <span class="keyword">case</span> MPLINTR:</span><br><span class="line">            p += <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cprintf(<span class="string">&quot;mpinit: unknown config type %x\n&quot;</span>, *p);</span><br><span class="line">            ismp = <span class="number">0</span>;</span><br><span class="line">            i = conf-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bootcpu-&gt;cpu_status = CPU_STARTED;</span><br><span class="line">    <span class="keyword">if</span> (!ismp) &#123;</span><br><span class="line">        <span class="comment">// Didn&#x27;t like what we found; fall back to no MP.</span></span><br><span class="line">        ncpu = <span class="number">1</span>;</span><br><span class="line">        lapicaddr = <span class="number">0</span>;</span><br><span class="line">        cprintf(<span class="string">&quot;SMP: configuration not found, SMP disabled\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;SMP: CPU %d found %d CPU(s)\n&quot;</span>, bootcpu-&gt;cpu_id,  ncpu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;imcrp) &#123;</span><br><span class="line">        <span class="comment">// [MP 3.2.6.1] If the hardware implements PIC mode,</span></span><br><span class="line">        <span class="comment">// switch to getting interrupts from the LAPIC.</span></span><br><span class="line">        cprintf(<span class="string">&quot;SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n&quot;</span>);</span><br><span class="line">        outb(<span class="number">0x22</span>, <span class="number">0x70</span>);   <span class="comment">// Select IMCR</span></span><br><span class="line">        outb(<span class="number">0x23</span>, inb(<span class="number">0x23</span>) | <span class="number">1</span>);  <span class="comment">// Mask external interrupts.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理器同时运行，不能共享一个栈，每个处理器都要有自己的栈。当然，这种区分是在虚拟地址层面上的，不是在物理地址层面上的，不同虚拟地址可以映射到相同物理地址，也可以映射到不同。在这里，我们当然希望能够映射到不同地址上。</p>
<p>主要工作在函数<code>mem_init_mp</code>，这个函数在<code>mem_init</code>初始化完成BSP使用的栈后调用，为各个AP映射栈地址。</p>
<p>讲义和代码注释要求我们给每个栈分配<code>KSTKSIZE</code>大小，中间留出<code>KSTKGAP</code>作为保护，使得一个栈溢出一定不会影响相邻的栈。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modify mappings in kern_pgdir to support SMP</span></span><br><span class="line"><span class="comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init_mp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Map per-CPU stacks starting at KSTACKTOP, for up to &#x27;NCPU&#x27; CPUs.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 对每个CPUi，使用percpu_kstacks[i]所代表的物理地址作为内核栈。</span></span><br><span class="line">        <span class="comment">// CPU i的内核栈从kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP)向下生长</span></span><br><span class="line">        <span class="comment">// 为了避免溢出，还会加上GAP</span></span><br><span class="line">        <span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; ++i) &#123;</span><br><span class="line">        boot_map_region(kern_pgdir,</span><br><span class="line">                        KSTACKTOP - i * (KSTKSIZE + KSTKGAP) - KSTKSIZE,</span><br><span class="line">                        KSTKSIZE,</span><br><span class="line">                        (<span class="type">physaddr_t</span>)PADDR(percpu_kstacks[i]),</span><br><span class="line">                        PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我看着比较好的一种写法</span></span><br><span class="line">    <span class="comment">//uintptr_t start_addr = KSTACKTOP - KSTKSIZE;</span></span><br><span class="line">    <span class="comment">//   for (size_t i=0; i&lt;NCPU; i++) &#123;</span></span><br><span class="line">    <span class="comment">//       boot_map_region(kern_pgdir, (uintptr_t) start_addr, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W | PTE_P);</span></span><br><span class="line">    <span class="comment">//       start_addr -= KSTKSIZE + KSTKGAP;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="各处理器中断初始化"><a href="#各处理器中断初始化" class="headerlink" title="各处理器中断初始化"></a>各处理器中断初始化</h3><p>在文件<code>kern/trap.c</code>中函数<code>trap_init_percpu</code>对每个AP的中断进行初始化。上一个Lab留下的版本，不能正确地在多处理器情况下运行。我们需要做一些小更改，让函数正确初始化每个AP的中断。</p>
<p>上一个Lab中，函数<code>trap_init_percpu</code>在函数<code>trap_init</code>中调用，<code>trap_init</code>在<code>i386_init</code>中调用。这是给BSP初始化中断。</p>
<p>AP内核入口函数<code>mp_main</code>调用了<code>trap_init_percpu</code>，这是给各个AP初始化中断。在BSP调用的<code>trap_init</code>函数中，中断描述符表已经初始化完成了，在各个AP中也就没比要再做，故没有调用<code>trap_init</code>。</p>
<p>只需要将<code>trap_init_percpu</code>的变量<code>ts</code>改为当前处理器的<code>Task State Segment</code>就可以，其它操作和上个Lab相同。需要注意计算出当前处理器的栈的正确地址，不再是<code>KSTACKTOP</code>了。</p>
<p>先注释掉<code>ts</code>，再根据单个cpu的代码做改动。在<code>inc/memlayout.h</code>中可以找到<code>GD_TSS0</code>的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GD_TSS0   0x28     <span class="comment">// Task segment selector for CPU 0</span></span></span><br></pre></td></tr></table></figure></p>
<p>但是并没有其他地方说明其他 CPU 的任务段选择器在哪。因此最大的难点就是找到这个值。实际上，偏移就是<code>cpu_id &lt;&lt; 3</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static struct Taskstate ts;</span></span><br><span class="line">...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span>* <span class="title">this_ts</span> =</span> &amp;thiscpu-&gt;cpu_ts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">    <span class="comment">// when we trap to the kernel.</span></span><br><span class="line">    this_ts-&gt;ts_esp0 = KSTACKTOP - thiscpu-&gt;cpu_id*(KSTKSIZE + KSTKGAP);</span><br><span class="line">    this_ts-&gt;ts_ss0 = GD_KD;</span><br><span class="line">    this_ts-&gt;ts_iomb = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + thiscpu-&gt;cpu_id] = SEG16(STS_T32A, (<span class="type">uint32_t</span>) (this_ts),</span><br><span class="line">                    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + thiscpu-&gt;cpu_id].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">    <span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">    ltr(GD_TSS0 + (thiscpu-&gt;cpu_id &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the IDT</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br></pre></td></tr></table></figure>
<p>运行<code>make qemu CPUS=4</code>成功，输出如下提示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6828 decimal is 15254 octal!</span><br><span class="line">Physical memory: 131072K available, base = 640K, extended = 130432K</span><br><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_alloc() succeeded!</span><br><span class="line">check_page() succeeded!</span><br><span class="line">check_kern_pgdir() succeeded!</span><br><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_installed_pgdir() succeeded!</span><br><span class="line">SMP: CPU 0 found 4 CPU(s)</span><br><span class="line">enabled interrupts: 1 2</span><br><span class="line">SMP: CPU 1 starting</span><br><span class="line">SMP: CPU 2 starting</span><br><span class="line">SMP: CPU 3 starting</span><br></pre></td></tr></table></figure></p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>我们现在的代码在初始化 AP 后就会开始自旋。在进一步操作 AP 之前，我们要先处理几个 CPU 同时运行内核代码的竞争情况。最简单的方法是用一个大内核锁 (big kernel lock)。它是一个全局锁，在某个进程进入内核态时锁定，返回用户态时释放。这种模式下，用户进程可以并发地在 CPU 上运行，但是同一时间仅有一个进程可以在内核态，其他需要进入内核态的进程只能等待。<br><code>kern/spinlock.h</code>声明了一个大内核锁<code>kernel_lock</code>。它提供了<code>lock_kernel()</code>和<code>unlock_kernel()</code>方法用于获得和释放锁。在以下 4 个地方需要使用到大内核锁：</p>
<ul>
<li>在<code>i386_init()</code>，BSP 唤醒其他 CPU 之前获得内核锁</li>
<li>在<code>mp_main()</code>，初始化 AP 之后获得内核锁，之后调用<code>sched_yield()</code>在 AP 上运行进程。</li>
<li>在<code>trap()</code>，当从用户态陷入内核态时获得内核锁，通过检查<code>tf_cs</code>的低 2bit 来确定该 trap 是由用户进程还是内核触发。</li>
<li>在<code>env_run()</code>，在切换回用户模式前释放内核锁。</li>
</ul>
<p>Exercise 5是在合适的地方调用<code>lock_kernel()</code>和<code>unlock_kernel()</code>。在这些函数中，我们需要添加<code>lock/unlock</code>：<code>i386_init</code>, <code>mp_main</code>, <code>trap</code>, <code>env_run</code>。</p>
<p><code>i386_init</code>,<code>mp_main</code>函数的lock都发生在初始化完成，准备通过<code>sched_yield</code>进入用户进程之前。这时候加锁，让处理器依次加载用户进程，保证同一时刻只有一个处理器在内核态运行。</p>
<p>其它操作内核锁发生在进入和退出内核态的时候。处理器进入内核态后处在函数<code>trap</code>，故在<code>trap</code>开头加锁，等待其它处理器退出内核态。处理器要进入用户态时放开锁，也就是在<code>env_run</code>的最后，允许其它处理器进入内核态。</p>
<p>其它加锁方式可能更有效率，但比Spin Lock复杂很多。不论如何，这些lock/unlock操作都是为了保证内核只运行在一个处理器上。</p>
<p>在<code>kern/init.c</code>的<code>i386_init</code>中加锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lab 4 multitasking initialization functions</span></span><br><span class="line">pic_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Starting non-boot CPUs</span></span><br><span class="line">boot_aps();</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/init.c</code>的<code>mp_main</code>中加锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line"><span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line"><span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line"></span><br><span class="line">sched_yield();</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/trap.c</code>的<code>trap</code>中加锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// Trapped from user mode.</span></span><br><span class="line">    <span class="comment">// Acquire the big kernel lock before doing any</span></span><br><span class="line">    <span class="comment">// serious kernel work.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    lock_kernel();</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/env.c</code>的<code>env_run</code>中解锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unlock_kernel();</span><br><span class="line">env_pop_tf(&amp;e-&gt;env_tf);</span><br></pre></td></tr></table></figure></p>
<p>关键要理解两点：</p>
<h4 id="大内核锁的实现"><a href="#大内核锁的实现" class="headerlink" title="大内核锁的实现"></a>大内核锁的实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">spin_lock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">    <span class="keyword">if</span> (holding(lk))</span><br><span class="line">        panic(<span class="string">&quot;CPU %d cannot acquire %s: already holding&quot;</span>, cpunum(), lk-&gt;name);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The xchg is atomic.</span></span><br><span class="line">    <span class="comment">// It also serializes, so that reads after acquire are not</span></span><br><span class="line">    <span class="comment">// reordered before it. </span></span><br><span class="line">    <span class="comment">// 关键代码，体现了循环等待的思想</span></span><br><span class="line">    <span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;pause&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record info about lock acquisition for debugging.</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">    lk-&gt;cpu = thiscpu;</span><br><span class="line">    get_caller_pcs(lk-&gt;pcs);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，在<code>inc/x86.h</code>中可以找到<code>xchg()</code>函数的实现，使用它而不是用简单的<code>if + 赋值</code>是因为它是一个原子性的操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint32_t</span> *addr, <span class="type">uint32_t</span> newval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The + in &quot;+m&quot; denotes a read-modify-write operand.</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lock; xchgl %0, %1&quot;</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;+m&quot;</span> (*addr), <span class="string">&quot;=a&quot;</span> (result)  <span class="comment">// 输出</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;1&quot;</span> (newval)             <span class="comment">//  输入</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>lock</code>确保了操作的原子性，其意义是将<code>addr</code>存储的值与<code>newval</code>交换，并返回<code>addr</code>中原本的值。于是，如果最初<code>locked = 0</code>，即未加锁，就能跳出这个<code>while</code>循环。否则就会利用<code>pause</code>命令自旋等待。这就确保了当一个 CPU 获得了 BKL，其他 CPU 如果也要获得就只能自旋等待。</p>
<h4 id="为什么要在这几处加大内核锁"><a href="#为什么要在这几处加大内核锁" class="headerlink" title="为什么要在这几处加大内核锁"></a>为什么要在这几处加大内核锁</h4><p>从根本上来讲，其设计的初衷就是保证独立性。由于分页机制的存在，内核以及每个用户进程都有自己的独立空间。而多进程并发的时候，如果两个进程同时陷入内核态，就无法保证独立性了。例如内核中有某个全局变量<code>A</code>，cpu1 让 A=1， 而后 cpu2 却让 A=2，显然会互相影响。最初 Linux 设计者为了使系统尽快支持 SMP，直接在内核入口放了一把大锁，保证其独立性。</p>
<p>其流程大致为：BPS 启动 AP 前，获取内核锁，所以 AP 会在<code>mp_main</code>执行调度之前阻塞，在启动完 AP 后，BPS 执行调度，运行第一个进程，<code>env_run()</code>函数中会释放内核锁，这样一来，其中一个 AP 就可以开始执行调度，运行其他进程。</p>
<p>Q：看起来大内核锁机制保证了同时只能有一个CPU在内核态运行。那为什么我们还需要将每个CPU的内核栈分开？请描述一个场景，我们不分开内核栈而导致错误。</p>
<blockquote>
<p>假设CPU0因中断陷入内核并在内核栈中保留了相关的信息，此时若CPU1也发生中断而陷入内核，在同一个内核栈的情况下，CPU0中的信息将会被覆盖从而导致出现错误。</p>
</blockquote>
<h4 id="为什么要用不同栈"><a href="#为什么要用不同栈" class="headerlink" title="为什么要用不同栈"></a>为什么要用不同栈</h4><p>本标题对应Question 2。如果一次只有一个处理器运行内核，为什么每个处理器都要一个单独的栈？</p>
<p>这是个挺简单的问题。因为并不是真的只有一个处理器运行内核，处理器进入内核态之后才调用lock_kernel，进而抢锁。在中断发生进入trap函数时，这个处理器就已经在使用内核的代码了，只是可能没有运行真正的内核，而是在跑一个while循环，这也还是内核。</p>
<p>要处理这样同时跑内核的情况，自然要多个栈。可以设想，如果只有一个栈，一个处理器正在运行内核，一个处理器发生中断。被中断的处理器压栈，然后等待另一个处理器退出内核。在另一个处理器看来，栈没有变化，接着正常操作，把刚刚压栈的数据覆盖了。</p>
<h3 id="轮询调度"><a href="#轮询调度" class="headerlink" title="轮询调度"></a>轮询调度</h3><p>下一个任务是让 JOS 内核能够以轮询方式在多个任务之间切换。其原理如下：</p>
<ul>
<li><code>kern/sched.c</code>中的<code>sched_yield()</code>函数用来选择一个新的进程运行。它将从上一个运行的进程开始，按顺序循环搜索<code>envs[]</code>数组，选取第一个状态为<code>ENV_RUNNABLE</code>的进程执行。</li>
<li><code>sched_yield()</code>不能同时在两个CPU上运行同一个进程。如果一个进程已经在某个CPU上运行，其状态会变为<code>ENV_RUNNING</code>。</li>
<li>程序中已经实现了一个新的系统调用<code>sys_yield()</code>，进程可以用它来唤起内核的<code>sched_yield()</code>函数，从而将 CPU 资源移交给一个其他的进程。</li>
</ul>
<p>如何找到目前正在运行的进程在<code>envs[]</code>中的序号？在<code>kern/env.h</code>中，可以找到指向<code>struct Env</code>的指针<code>curenv</code>，表示当前正在运行的进程。但是需要注意，不能直接由<code>curenv-&gt;env_id</code>得到其序号。在<code>inc/env.h</code>中有一个宏可以完成这个转换。</p>
<p><code>sched_yield()</code>将找到下一个<code>runable</code>的进程并切换到这个进程上。主要步骤如下:</p>
<ul>
<li>从当前在<code>running</code>的进程 ( 也就是<code>curenv</code>) 开始 ( 如果<code>curenv</code>不存在，则从数组首部开始查找 )，顺序查找在<code>envs</code>数组 ( in circular fashion，也就是要取模做个环状查找 )，取出首个<code>status</code>为<code>ENV_RUNNABLE</code>的进程，并调用<code>env_run()</code>唤醒取出的进程。</li>
<li>如果上述查询中没有找到任何一个<code>ENV_RUNNABLE</code>的进程，则将观测<code>curenv-&gt;env_status</code>若其为<code>ENV_RUNNING</code>则继续运行这个进程。</li>
<li>若以上两种情况都没发生. 则自然的停止调度.</li>
</ul>
<p>这个函数必须阻止同一个进程在两个不同 CPU 上运行的情况 ( 由于正在运行 env 的状态必定是<code>ENV_RUNNING</code>，在前述中不会发生这种事情 )</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The environment index ENVX(eid) equals the environment&#x27;s offset in the &#x27;envs[]&#x27; array.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENVX(envid)     ((envid) &amp; (NENV - 1))</span></span><br></pre></td></tr></table></figure>
<p>查看<code>kern/env.c</code>可以发现<code>curenv</code>可能为NULL。因此要注意特例。</p>
<p>在<code>kern/sched.c</code>中实现轮询调度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched_yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line">    </span><br><span class="line">    idle = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (curenv) &#123;</span><br><span class="line">        <span class="type">size_t</span> eidx = ENVX(curenv-&gt;env_id);</span><br><span class="line">        <span class="type">uint32_t</span> mask = NENV - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = (eidx + <span class="number">1</span>) &amp; mask; i != eidx; i = (i + <span class="number">1</span>) &amp; mask) &#123;</span><br><span class="line">            <span class="keyword">if</span> (envs[i].env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">                idle = &amp;envs[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!idle &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">            idle = curenv;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; NENV; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (envs[i].env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">                idle = &amp;envs[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idle)</span><br><span class="line">        env_run(idle);</span><br><span class="line">    <span class="comment">// sched_halt never returns</span></span><br><span class="line">    sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/syscall.c</code>中添加新的系统调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall()</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> SYS_yield:</span><br><span class="line">        sys_yield();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>将<code>kern/init.c</code>中运行的用户进程改为以下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i386_init()</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(TEST)</span></span><br><span class="line">    <span class="comment">// Don&#x27;t touch -- used by grading script!</span></span><br><span class="line">    ENV_CREATE(TEST, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// Touch all you want.</span></span><br><span class="line">    ENV_CREATE(user_primes, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// TEST*</span></span></span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>运行<code>make qemu CPUS=2</code>可以看到三个进程通过调用<code>sys_yield</code>切换了5次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Hello, I am environment 00001000.</span><br><span class="line">Hello, I am environment 00001001.</span><br><span class="line">Back in environment 00001000, iteration 0.</span><br><span class="line">Hello, I am environment 00001002.</span><br><span class="line">Back in environment 00001001, iteration 0.</span><br><span class="line">Back in environment 00001000, iteration 1.</span><br><span class="line">Back in environment 00001002, iteration 0.</span><br><span class="line">Back in environment 00001001, iteration 1.</span><br><span class="line">Back in environment 00001000, iteration 2.</span><br><span class="line">Back in environment 00001002, iteration 1.</span><br><span class="line">Back in environment 00001001, iteration 2.</span><br><span class="line">Back in environment 00001000, iteration 3.</span><br><span class="line">Back in environment 00001002, iteration 2.</span><br><span class="line">Back in environment 00001001, iteration 3.</span><br><span class="line">Back in environment 00001000, iteration 4.</span><br><span class="line">Back in environment 00001002, iteration 3.</span><br><span class="line">All done in environment 00001000.</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Back in environment 00001001, iteration 4.</span><br><span class="line">Back in environment 00001002, iteration 4.</span><br><span class="line">All done in environment 00001001.</span><br><span class="line">All done in environment 00001002.</span><br><span class="line">[00001001] exiting gracefully</span><br><span class="line">[00001001] free env 00001001</span><br><span class="line">[00001002] exiting gracefully</span><br><span class="line">[00001002] free env 00001002</span><br><span class="line">No runnable environments in the system!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line">K&gt; </span><br></pre></td></tr></table></figure>
<p>Q：我们在<code>env_run()</code>的实现中调用了<code>lcr3()</code>。在这个函数的调用之前以及调用之后，你的代码对<code>env_run()</code>的参数<code>e</code>进行了引用。在加载<code>%cr3</code>寄存器之后，MMU的寻址上下文就改变了（页目录切换了）。为什么我们在页目录改变前后都可以对<code>e</code>进行解引用？</p>
<blockquote>
<p>A：在我们lab3实现的过程中，任务的<code>env_pgdir</code>是基于<code>kern_pgdir</code>产生的，也就是说对于<code>UTOP</code>上的地址映射关系在两个页表中是一样的。而<code>e</code>所对应的<code>Env</code>结构由操作系统管理，在虚拟空间地址都是<code>UENVS-UPAGES</code>的范围，因此在所有用户环境的映射也是一样的。</p>
</blockquote>
<p>Q：当内核进行用户环境切换的时候，必须要保证旧的环境的寄存器值被保存起来以便之后恢复。这个过程是在哪里发生的？</p>
<blockquote>
<p>A：用户环境进行环境切换是通过系统调用<code>syscall()</code>，最终通过<code>kern/trap.c</code>中的<code>trap()</code>产生异常然后陷入内核。因而中断触发会进入<code>trapentry.S</code>的代码入口然后调用<code>trap()</code>，系统会在栈上创建一个<code>Trapframe</code>然后赋给用户环境的<code>env_tf</code>从而保护用户环境寄存器。如下所示代码片段：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_alltraps:</span><br><span class="line">	;ds es</span><br><span class="line">	push %ds</span><br><span class="line">	push %es</span><br><span class="line">	pushal   #;其余寄存器</span><br><span class="line"></span><br><span class="line">	#;load DS and ES with GD_KD (不能用立即数设置段寄存器)</span><br><span class="line">	mov $GD_KD, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	pushl %esp</span><br><span class="line">	call trap</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这里我们将环境的现场全部保护起来压栈使得其结构与<code>Trapframe</code>一样，然后调用<code>trap()</code>就可以使得其作为<code>tf</code>被保存。</p>
<p>恢复：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_pop_tf</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Record the CPU we are running on for user-space debugging</span></span><br><span class="line">    curenv-&gt;env_cpunum = cpunum();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;\tmovl %0,%%esp\n&quot;</span>  <span class="comment">// 恢复栈顶指针</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;\tpopal\n&quot;</span>          <span class="comment">// 恢复其他寄存器</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;\tpopl %%es\n&quot;</span>      <span class="comment">// 恢复段寄存器</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;\tpopl %%ds\n&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;\taddl $0x8,%%esp\n&quot;</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;\tiret\n&quot;</span></span></span><br><span class="line"><span class="params">        : : <span class="string">&quot;g&quot;</span> (tf) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    panic(<span class="string">&quot;iret failed&quot;</span>);  <span class="comment">/* mostly to placate the compiler */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="系统调用：创建进程"><a href="#系统调用：创建进程" class="headerlink" title="系统调用：创建进程"></a>系统调用：创建进程</h3><p>现在我们的内核已经可以运行多个进程，并在其中切换了。不过，现在它仍然只能运行内核最初设定好的程序<code>kern/init.c</code>。现在我们即将实现一个新的系统调用，它允许进程创建并开始新的进程。</p>
<p>Unix 提供了<code>fork()</code>这个原始的系统调用来创建进程。<code>fork()</code>将会拷贝父进程的整个地址空间来创建子进程。在用户空间里，父子进程之间的唯一区别就是它们的进程ID分别为<code>pid</code>和<code>ppid</code>。<code>fork()</code>在父进程中返回其子进程的进程 ID，而在子进程中返回 0。父子进程之间是完全独立的，任意一方修改内存，另一方都不会受到影响。</p>
<p>默认情况下，每一个进程都有其私有的地址空间，而且任意一个进程对于内核的修改都是对于其他进程而言不可见的。</p>
<p>我们将为 JOS 实现一个更原始的系统调用来创建新的进程。涉及到的系统调用如下：</p>
<ul>
<li><code>sys_exofork</code>：这个系统调用将会创建一个空白进程：在其用户空间中没有映射任何物理内存，并且它是不可运行的。刚开始时，它拥有和父进程相同的寄存器状态。<code>sys_exofork</code>将会在父进程返回其子进程的<code>envid_t</code>，子进程返回 0（当然，由于子进程还无法运行，也无法返回值，直到运行）。由于子环境最初被标记为不可执行，故在子环境中<code>sys_exofork()</code>直到父环境显式标记子环境为可执行，其才会在子环境中返回。</li>
<li><code>sys_env_set_status</code>：设置指定进程的状态为<code>ENV_RUNNABLE</code>或者<code>RUN_NOT_RUNNABLE</code>。这个系统调用通常用于在新进程的地址空间和寄存器初始化完成后，将其标记为可运行。</li>
<li><code>sys_page_alloc</code>：分配一个物理页并将其映射到指定进程的指定虚拟地址上。</li>
<li><code>sys_page_map</code>：从一个进程中拷贝一个页面映射（而非物理页的内容）到另一个。即共享内存。</li>
<li><code>sys_page_unmap</code>：删除到指定进程的指定虚拟地址的映射。</li>
</ul>
<p>上述所有系统调用集都需要接受一个环境ID，jos的内核支持了环境号0代表当前环境。在<code>kern/env.c</code>中的<code>envid2env()</code>实现了这种映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">envid2env</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">struct</span> Env **env_store, <span class="type">bool</span> checkperm)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果envid为零，则返回当前环境.</span></span><br><span class="line">        <span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">                *env_store = curenv;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过envid的索引部分查找Env结构，然后检查该结构Env中的env_id字段以确保envid不是陈旧的</span></span><br><span class="line">        e = &amp;envs[ENVX(envid)];</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;</span><br><span class="line">                *env_store = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查调用环境是否具有操作指定环境的合法权限。</span></span><br><span class="line">        <span class="comment">// 如果设置了 checkperm，则指定的环境必须是当前环境或当前环境的直接子环境。</span></span><br><span class="line">        <span class="keyword">if</span> (checkperm &amp;&amp; e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id) &#123;</span><br><span class="line">                *env_store = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *env_store = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现上述在<code>kern/syscall.c</code>中的系统调用集，确保<code>syscall()</code>可以调用它们。你可能需要用到<code>kern/pmap.c</code>和<code>kern/env.c</code>中的一些函数，尤其是<code>envid2env()</code>。</p>
<p>现在你使用<code>envid2env()</code>的时候，将<code>checkperm</code>参数设置为1，确保当你的一些系统调用参数无效的时候会返回<code>-E_INVAL</code>。使用<code>user/dumpfork.c</code>测试你实现的这些系统调用。</p>
<p><code>sys_exofork()</code>的关键点在于如何让子环境对该系统调用返回0。这个用户态的触发系统调用的函数定义实际上在<code>inc/lib.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This must be inlined. </span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">envid_t</span> __attribute__((always_inline))</span><br><span class="line">sys_exofork(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">envid_t</span> ret;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;int %2&quot;</span></span></span><br><span class="line"><span class="params">		     : <span class="string">&quot;=a&quot;</span> (ret)</span></span><br><span class="line"><span class="params">		     : <span class="string">&quot;a&quot;</span> (SYS_exofork), <span class="string">&quot;i&quot;</span> (T_SYSCALL))</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个过程的控制流如下：父环境显式调用该系统调用，通过内联汇编<code>int %2</code>触发中断，然后硬件控制流通过<code>trapentry.S</code>中的入口地址进行保护现场并将控制流转到<code>trap.c</code>最终进入<code>trap_dispatch()</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_trapno == T_SYSCALL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int32_t</span> retval = syscall(tf-&gt;tf_regs.reg_eax,</span><br><span class="line">								 tf-&gt;tf_regs.reg_edx,</span><br><span class="line">								 tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">								 tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">								 tf-&gt;tf_regs.reg_edi,</span><br><span class="line">								 tf-&gt;tf_regs.reg_esi);</span><br><span class="line">		<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">			panic(<span class="string">&quot;[trap_dispatch] syscall : %e\n&quot;</span>, retval);</span><br><span class="line">		tf-&gt;tf_regs.reg_eax = retval;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见这里系统调用获取返回值的方式是：<code>env_tf</code>中的<code>reg_eax</code>寄存器设置为将系统调用的返回值。然后回到<code>trap</code>中直接通过调用<code>env_run()</code>来返回用户态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatch based on what type of trap occurred</span></span><br><span class="line">	trap_dispatch(tf);         <span class="comment">// &lt;-  这里是上面的返回，返回值存在了其tf的reg_eax中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we made it to this point, then no other environment was</span></span><br><span class="line">	<span class="comment">// scheduled, so we should return to the current environment</span></span><br><span class="line">	<span class="comment">// if doing so makes sense.</span></span><br><span class="line">	<span class="keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">		env_run(curenv);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sched_yield();</span><br></pre></td></tr></table></figure></p>
<p>而在我们的<code>sys_exofork()</code>执行过程中，只有父环境发生了系统调用，在陷入内核之前保护了用户环境的下一条指令<code>eip</code>，子环境是没有产生中断以及系统调用的，子环境会从其地址空间的<code>eip</code>指定的代码处继续执行（别忘了子环境的寄存器实际上就是拷贝父环境的）。因此整个<code>kern/trap.c</code>以及<code>kern/syscall.c</code>并没有影响子环境，子环境只会等待内核调用<code>sched_yield()</code>开始执行，因此返回值就是我们伪造的<code>eax=0</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">envid_t</span></span><br><span class="line"><span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_exofork not implemented&quot;);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="type">int</span> r = env_alloc(&amp;e, curenv-&gt;env_id);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_tf = curenv-&gt;env_tf;</span><br><span class="line">    e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该函数中，子进程复制了父进程的<code>trapframe</code>，此后把<code>trapframe</code>中的<code>eax</code>的值设为了0。最后，返回了子进程的<code>id</code>。注意，根据<code>kern/trap.c</code>中的<code>trap_dispatch()</code>函数，这个返回值仅仅是存放在了父进程的<code>trapframe</code>中，还没有返回。而是在返回用户态的时候，即在<code>env_run()</code>中调用<code>env_pop_tf()</code>时，才把<code>trapframe</code>中的值赋值给各个寄存器。这时候<code>lib/syscall.c</code>中的函数<code>syscall()</code>才获得真正的返回值。因此，在这里对子进程<code>trapframe</code>的修改，可以使得子进程返回0。</p>
<p><code>sys_page_alloc()</code>函数在进程<code>envid</code>的目标地址<code>va</code>分配一个权限为<code>perm</code>的页面。</p>
<p>在做这个之前需要看一下<code>duppage()</code>函数，这是对这个系统调用的测试函数，里边列举了一些可能会出现的Corner case。<code>duppage()</code>函数利用<code>sys_page_alloc()</code>为子进程分配空闲物理页，再使用<code>sys_page_map()</code>将该新物理页映射到内核 (内核的<code>env_id = 0</code>) 的交换区<code>UTEMP</code>，方便在内核态进行<code>memmove</code>拷贝操作。在拷贝结束后，利用<code>sys_page_unmap()</code>将交换区的映射删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">duppage</span><span class="params">(<span class="type">envid_t</span> dstenv, <span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is NOT what you should do in your fork.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_map(dstenv, addr, <span class="number">0</span>, UTEMP, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;sys_page_map: %e&quot;</span>, r);</span><br><span class="line">    memmove(UTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, UTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;sys_page_unmap: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在写之前也要看一下注释里的提示，注意检查权限位，这个看一下位操作就能搞定。分配了<code>page</code>之后要检查是否没有分配成功，检查能否获得正确的<code>env</code>，检查插入<code>page</code>是否成功，完成这些检查并根据返回值返回相应的错误码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a page of memory and map it at &#x27;va&#x27; with permission</span></span><br><span class="line"><span class="comment">// &#x27;perm&#x27; in the address space of &#x27;envid&#x27;.</span></span><br><span class="line"><span class="comment">// The page&#x27;s contents are set to 0.</span></span><br><span class="line"><span class="comment">// If a page is already mapped at &#x27;va&#x27;, that page is unmapped as a</span></span><br><span class="line"><span class="comment">// side effect.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span></span><br><span class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//      -E_BAD_ENV if environment envid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//              or the caller doesn&#x27;t have permission to change envid.</span></span><br><span class="line"><span class="comment">//      -E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="comment">//      -E_INVAL if perm is inappropriate (see above).</span></span><br><span class="line"><span class="comment">//      -E_NO_MEM if there&#x27;s no memory to allocate the new page,</span></span><br><span class="line"><span class="comment">//              or to allocate any necessary page tables.</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_alloc</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line">        <span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">        <span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line">        <span class="comment">//   parameters for correctness.</span></span><br><span class="line">        <span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line">        <span class="comment">//   allocated!</span></span><br><span class="line">        <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">        <span class="comment">// panic(&quot;sys_page_alloc not implemented&quot;);</span></span><br><span class="line">        <span class="keyword">if</span> ((~perm &amp; (PTE_U|PTE_P)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; (~(PTE_U|PTE_P|PTE_AVAIL|PTE_W))) != <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span> =</span> page_alloc(ALLOC_ZERO);</span><br><span class="line">        <span class="keyword">if</span> (!page)</span><br><span class="line">            <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">        <span class="type">int</span> err = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">        err = page_insert(e-&gt;env_pgdir, page, va, perm);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            page_free(page);</span><br><span class="line">            <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_page_map()</code>函数简单来说，就是建立跨进程的映射。注释中给出了一些需要做的检查，取得src中的页，使用<code>page_insert</code>把这页添加到<code>dst_env-&gt;env_pgdir</code>中即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map the page of memory at &#x27;srcva&#x27; in srcenvid&#x27;s address space</span></span><br><span class="line"><span class="comment">// at &#x27;dstva&#x27; in dstenvid&#x27;s address space with permission &#x27;perm&#x27;.</span></span><br><span class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></span><br><span class="line"><span class="comment">// that it also must not grant write access to a read-only</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//      -E_BAD_ENV if srcenvid and/or dstenvid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//              or the caller doesn&#x27;t have permission to change one of them.</span></span><br><span class="line"><span class="comment">//      -E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></span><br><span class="line"><span class="comment">//              or dstva &gt;= UTOP or dstva is not page-aligned.</span></span><br><span class="line"><span class="comment">//      -E_INVAL is srcva is not mapped in srcenvid&#x27;s address space.</span></span><br><span class="line"><span class="comment">//      -E_INVAL if perm is inappropriate (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//      -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid&#x27;s</span></span><br><span class="line"><span class="comment">//              address space.</span></span><br><span class="line"><span class="comment">//      -E_NO_MEM if there&#x27;s no memory to allocate any necessary page tables.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_map</span><span class="params">(<span class="type">envid_t</span> srcenvid, <span class="type">void</span> *srcva,</span></span><br><span class="line"><span class="params">             <span class="type">envid_t</span> dstenvid, <span class="type">void</span> *dstva, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></span><br><span class="line">        <span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">        <span class="comment">//   Again, most of the new code you write should be to check the</span></span><br><span class="line">        <span class="comment">//   parameters for correctness.</span></span><br><span class="line">        <span class="comment">//   Use the third argument to page_lookup() to</span></span><br><span class="line">        <span class="comment">//   check the current permissions on the page.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">        <span class="comment">//      -E_BAD_ENV if srcenvid and/or dstenvid doesn&#x27;t currently exist,</span></span><br><span class="line">        <span class="comment">//              or the caller doesn&#x27;t have permission to change one of them.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">uintptr_t</span>)srcva &gt;= UTOP || PGOFF(srcva) != <span class="number">0</span> || (<span class="type">uintptr_t</span>)dstva &gt;= UTOP || PGOFF(dstva) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; PTE_U) == <span class="number">0</span> || (perm &amp; PTE_P) == <span class="number">0</span> || (perm &amp; ~PTE_SYSCALL) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">src_env</span>, *<span class="title">dst_env</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (envid2env(srcenvid, &amp;src_env, <span class="number">1</span>) &lt; <span class="number">0</span> || envid2env(dstenvid, &amp;dst_env, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">        <span class="type">pte_t</span> *src_pte;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span> =</span> page_lookup(src_env-&gt;env_pgdir, srcva, &amp;src_pte);</span><br><span class="line">        <span class="keyword">if</span> ( (*src_pte &amp; PTE_W == <span class="number">0</span>) &amp;&amp; (perm &amp; PTE_W == <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="keyword">if</span> (page_insert(dst_env-&gt;env_pgdir, page, dstva, perm) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_page_unmap()</code>函数取消映射。是对<code>page_remove</code>的封装。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_unmap</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;e, <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    page_remove(e-&gt;env_pgdir, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_env_set_status()</code>函数设置<code>env</code>的状态，在子进程内存<code>map</code>结束后再使用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_status</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_env_set_status not implemented&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) </span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;e, <span class="number">1</span>) &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    e-&gt;env_status = status;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Part-B-写时拷贝的-Fork"><a href="#Part-B-写时拷贝的-Fork" class="headerlink" title="Part B: 写时拷贝的 Fork"></a>Part B: 写时拷贝的 Fork</h2><p>在 Part A 中，我们通过把父进程的所有内存数据拷贝到子进程实现了<code>fork()</code>，这也是 Unix 系统早期的实现。这个拷贝到过程是<code>fork()</code>时最昂贵的操作。</p>
<p>然而，调用了<code>fork()</code>之后往往立即就会在子进程中调用<code>exec()</code>，将子进程的内存更换为新的程序。这样，复制父进程的内存这个操作就完全浪费了。</p>
<p>因此，后来的 Unix 系统让父、子进程共享同一片物理内存，直到某个进程修改了内存。这被称作 copy-on-write。为了实现它，<code>fork()</code>时内核只拷贝页面的映射关系，而不拷贝其内容，同时将共享的页面标记为只读 (read-only)。当父子进程中任一方向内存中写入数据时，就会触发 page fault。此时，Unix 就知道应该分配一个私有的可写内存给这个进程。</p>
<p>也就是说，这样只有在实际进行修改页面的时候，这个页面的内容才会真正被复制。那么这种机制使得<code>exec()</code>降低了开销：实际上子进程可能只需要在调用<code>exec()</code>之前复制当前栈上的一页。</p>
<p>下面，我们就需要实现一个Unix-like的具有写时复制的<code>fork()</code>，作为用户空间库函数例程。（之所以作为用户库函数而不是内核函数，是为了让内核保持简单，同时能让用户定制自身<code>fork()</code>的实现）</p>
<h3 id="用户级别的页错误处理"><a href="#用户级别的页错误处理" class="headerlink" title="用户级别的页错误处理"></a>用户级别的页错误处理</h3><p>内核必须要记录进程不同区域出现页面错误时的处理方法。例如，一个栈区域的<code>page fault</code>会分配并映射一个新的页。一个<code>BSS</code>区域（用于存放程序中未初始化的全局变量、静态变量）的页错误会分配一个新的页面，初始化为0，再映射。<br>用户级别的页错误处理流程为：</p>
<ul>
<li>页错误异常，陷入内核</li>
<li>内核修改<code>%esp</code>切换到进程的异常栈，修改<code>%eip</code>让进程运行<code>_pgfault_upcall</code></li>
<li><code>_pgfault_upcall</code>将运行 page fault handler，此后不通过内核切换回正常栈</li>
</ul>
<p>用户级的写时复制<code>fork()</code>的第一个关键点，在于能够使得用户发现由写权限问题引发的page fault的能力。</p>
<p>通常来说，是设置一个地址空间用以让page fault来指示发生错误时应该采取哪种行为。比如说，大多数的Unix内核通常会为新的进程的栈区域分配一个页的大小，随着进程栈逐渐增长一直到了未映射分配的区域，就会引发page fault，然后内核再按需分配。这时典型的Unix内核需要追踪进程空间不同区域在发生page fault时应该采取何种措施</p>
<ul>
<li>栈区发生page fault，则表示需要新的页面的分配和映射；</li>
<li>BSS区的page faule，则表示应该分配一个新页面并且填充0再映射；</li>
<li>对于具有可执行文件的系统，text段的page fault则表示从磁盘上的二进制文件中读取页面并映射。</li>
</ul>
<p>和传统的内存追踪大量信息的方法不同，这个实验中我们需要让用户自己决定如何处理用户空间的每个页面错误（这些bug的损害通常不大）。这种设计方式为用户定义储存区域带来了较强的灵活性，我们之后将会使用用户级别的错误处理程序来进行映射以及访问磁盘系统的文件。</p>
<p>为了能够处理页错误，用户环境必须向jos的内核注册一个页错误处理程序入口（page fault handler entrypoint）。用户环境通过系统调用<code>sys_env_set_pgfault_upcall()</code>来注册错误处理程序入口。实验中已经对于<code>Env</code>结构增加了新的成员<code>env_pgfault_upcall</code>来记录该信息。</p>
<p>实现<code>sys_env_set_pgfault_upcall()</code>系统调用，相当简单。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the page fault upcall for &#x27;envid&#x27; by modifying the corresponding struct</span></span><br><span class="line"><span class="comment">// Env&#x27;s &#x27;env_pgfault_upcall&#x27; field.  When &#x27;envid&#x27; causes a page fault, the</span></span><br><span class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></span><br><span class="line"><span class="comment">// &#x27;func&#x27;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn&#x27;t have permission to change envid.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_pgfault_upcall</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *func)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid, &amp;env, <span class="number">1</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	env-&gt;env_pgfault_upcall = func;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="进程的正常栈和异常栈"><a href="#进程的正常栈和异常栈" class="headerlink" title="进程的正常栈和异常栈"></a>进程的正常栈和异常栈</h4><p>正常运行时，JOS 的进程会运行在正常栈上，<code>ESP</code>从<code>USTACKTOP</code>开始往下生长，栈上的数据存放在<code>[USTACKTOP-PGSIZE, USTACKTOP-1]</code>上。当出现页错误时，内核会把进程在一个新的栈（异常栈）上面重启，运行指定的用户级别页错误处理函数。也就是说完成了一次进程内的栈切换。这个过程与<code>trap</code>的过程很相似。</p>
<p>JOS 的异常栈也只有一个物理页大小，并且它的栈顶定义在虚拟内存<code>UXSTACKTOP</code>处。当用户环境在异常处理栈上运行时，用户级别页错误处理程序可以使用jos系统调用来映射新的页面以解决page fault，最终通过一些汇编代码回到正常栈。</p>
<p>每个需要支持用户级页错误处理的函数都需要分配自己的异常栈。可以使用<code>sys_page_alloc()</code>这个系统调用来实现。</p>
<h4 id="用户页错误处理函数"><a href="#用户页错误处理函数" class="headerlink" title="用户页错误处理函数"></a>用户页错误处理函数</h4><p>现在我们需要修改<code>kern/trap.c</code>中的缺页异常处理函数，使其能够按照特定的方式处理用户模式页错误。我们将用户环境发生错误时的状态称为异常状态（trap-time state）。</p>
<p>如果没有注册<code>page fault handler</code>，JOS内核就直接销毁进程。否则，内核就会初始化一个<code>trap frame</code>记录寄存器状态，在异常栈上处理页错误，恢复进程的执行，<code>fault_va</code>是导致页错误发生的虚拟地址。<code>UTrapframe</code>在异常栈栈上如下所示。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time eflags</span><br><span class="line">trap-time eip</span><br><span class="line">trap-time eax       start of struct PushRegs</span><br><span class="line">trap-time ecx</span><br><span class="line">trap-time edx</span><br><span class="line">trap-time ebx</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time ebp</span><br><span class="line">trap-time esi</span><br><span class="line">trap-time edi       end of struct PushRegs</span><br><span class="line">tf_err (error code)</span><br><span class="line">fault_va            &lt;-- %esp when handler is run</span><br></pre></td></tr></table></figure></p>
<p>相比<code>trap</code>时使用的<code>Trapframe</code>，多了记录错误位置的<code>fault_va</code>，少了段选择器<code>%cs</code>，<code>%ds</code>，<code>%ss</code>。这反映了两者最大的不同：是否发生了进程的切换。</p>
<p>如果异常发生时，进程已经在异常栈上运行了，这就说明 page fault handler 本身出现了问题。这时，我们就应该在<code>tf-&gt;tf_esp</code>处分配新的栈，而不是在<code>UXSTACKTOP</code>。首先需要 push 一个空的 32bit word (4 bytes，所以要减4)作为占位符，然后是一个<code>UTrapframe</code>结构体。</p>
<p>实现<code>kern/trap.c</code>中的<code>page_fault_handler()</code>。注意上述提及的异常处理栈的机制。</p>
<p>为检查<code>tf-&gt;tf_esp</code>是否已经在异常栈上了，只要检查它是否在区间<code>[UXSTACKTOP-PGSIZE, UXSTACKTOP-1]</code>上即可。</p>
<p>再次分析控制流，当用户环境陷入中断时将<code>tf</code>保护起来，这里传递的参数<code>tf</code>实际上就是用户环境的现场。我们在这个系统调用之后需要将控制权还给用户环境，但是需要让用户环境进入页异常处理函数（如果有）并且将栈切换为异常处理栈。也就是说我们需要改变<code>curenv</code>的<code>ip</code>以及<code>esp</code>。同时我们只需要将<code>tf</code>中保护的现场原样传递给<code>utf</code>即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_fault_handler</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">	fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">		panic(<span class="string">&quot;[page_fault_handler] Page fault in kernel.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">	<span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call the environment&#x27;s page fault upcall, if one exists.  Set up a</span></span><br><span class="line">	<span class="comment">// page fault stack frame on the user exception stack (below</span></span><br><span class="line">	<span class="comment">// UXSTACKTOP), then branch to curenv-&gt;env_pgfault_upcall.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The page fault upcall might cause another page fault, in which case</span></span><br><span class="line">	<span class="comment">// we branch to the page fault upcall recursively, pushing another</span></span><br><span class="line">	<span class="comment">// page fault stack frame on top of the user exception stack.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It is convenient for our code which returns from a page fault</span></span><br><span class="line">	<span class="comment">// (lib/pfentry.S) to have one word of scratch space at the top of the</span></span><br><span class="line">	<span class="comment">// trap-time stack; it allows us to more easily restore the eip/esp. In</span></span><br><span class="line">	<span class="comment">// the non-recursive case, we don&#x27;t have to worry about this because</span></span><br><span class="line">	<span class="comment">// the top of the regular user stack is free.  In the recursive case,</span></span><br><span class="line">	<span class="comment">// this means we have to leave an extra word between the current top of</span></span><br><span class="line">	<span class="comment">// the exception stack and the new stack frame because the exception</span></span><br><span class="line">	<span class="comment">// stack _is_ the trap-time stack.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If there&#x27;s no page fault upcall, the environment didn&#x27;t allocate a</span></span><br><span class="line">	<span class="comment">// page for its exception stack or can&#x27;t write to it, or the exception</span></span><br><span class="line">	<span class="comment">// stack overflows, then destroy the environment that caused the fault.</span></span><br><span class="line">	<span class="comment">// Note that the grade script assumes you will first check for the page</span></span><br><span class="line">	<span class="comment">// fault upcall and print the &quot;user fault va&quot; message below if there is</span></span><br><span class="line">	<span class="comment">// none.  The remaining three checks can be combined into a single test.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//   user_mem_assert() and env_run() are useful here.</span></span><br><span class="line">	<span class="comment">//   To change what the user environment runs, modify &#x27;curenv-&gt;env_tf&#x27;</span></span><br><span class="line">	<span class="comment">//   (the &#x27;tf&#x27; variable points at &#x27;curenv-&gt;env_tf&#x27;).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> * <span class="title">utf</span>;</span></span><br><span class="line">	<span class="type">uintptr_t</span> utf_top;</span><br><span class="line">	<span class="comment">//curenv has pg fault handler</span></span><br><span class="line">	<span class="keyword">if</span>(curenv -&gt; env_pgfault_upcall)&#123;</span><br><span class="line">		<span class="comment">//esp already in handler (recursive)</span></span><br><span class="line">		<span class="keyword">if</span> ((tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE) &amp;&amp; (tf-&gt;tf_esp &lt; UXSTACKTOP))&#123;</span><br><span class="line">			<span class="comment">// recursive exception stack</span></span><br><span class="line">			utf_top = tf-&gt;tf_esp - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe) - <span class="number">4</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			utf_top = UXSTACKTOP - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//check permission on exception stack</span></span><br><span class="line">		user_mem_assert(curenv, utf_top, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe), PTE_W | PTE_U);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//push UTrapframe</span></span><br><span class="line">		utf = (<span class="keyword">struct</span> UTrapframe *)utf_top;</span><br><span class="line">		utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">		utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">		utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">		utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">		utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">		utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//modify stack and ip</span></span><br><span class="line">		(&amp;(curenv-&gt;env_tf))-&gt;tf_eip = (<span class="type">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">		(&amp;(curenv-&gt;env_tf))-&gt;tf_esp = utf_top;</span><br><span class="line">		env_run(curenv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">	cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用户模式页错误入口"><a href="#用户模式页错误入口" class="headerlink" title="用户模式页错误入口"></a>用户模式页错误入口</h3><p>在处理完页错误之后，现在我们需要编写汇编语句实现从异常栈到正常栈的切换，该例程将会调用C页面错误处理程序（<code>sys_env_set_pgfault_upcall()</code>）。</p>
<p>实现<code>lib/pfentry.S</code>中的<code>_pgfault_upcall</code>例程。这部分最有趣的在于如何返回用户触发page fault的代码。我们在这里将要直接返回而无需再陷入内核。难点在于如何同时切换栈以及重新加载<code>eip</code>。</p>
<ul>
<li><code>_pgfault_upcall()</code>：分析其汇编代码逻辑，我们知道它将<code>_pgfault_handler()</code>这个全局函数指针放入<code>eax</code>中并执行，这个全局函数<code>_pgfault_handler()</code>实际上就是我们的C处理页异常的例程（在<code>pgfault.c</code>中定义并且通过用户环境程序显式调用<code>set_pgfault_handler()</code>去定制该处理函数）。</li>
</ul>
<p>仔细阅读注释，这里有一些坑点：</p>
<p>首先我们要跳转回发生异常的<code>eip</code>时，已经恢复了所有现场（包括<code>esp</code>），这里不能使用<code>jmp</code>进行跳转（因为需要一个目的地址，我们不能用寄存器存了）。而且我们不能直接<code>ret</code>（因为<code>ret</code>会改变<code>esp</code>）。所以我们应该在切换栈之前将异常时的<code>eip</code>装载到异常处理栈的栈顶，切换栈的时候设置<code>esp = esp-4</code>，然后这样使用<code>ret</code>返回时就会取出<code>eip</code>并且返回同时使<code>esp=esp+4</code>。这样做是完全合理的，非嵌套情况下的异常处理栈栈顶之上（更低的地址）是空的，而嵌套情况两个异常处理栈之间会存在32bits的空白空间，因此完全没问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    // 调用用户定义的页错误处理函数</span><br><span class="line">    // Call the C page fault handler.</span><br><span class="line">    pushl %esp          // function argument: pointer to UTF</span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $4, %esp           // pop function argument</span><br><span class="line"></span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    movl 48(%esp), %ebp</span><br><span class="line">    subl $4, %ebp</span><br><span class="line">    movl %ebp, 48(%esp)</span><br><span class="line">    movl 40(%esp), %eax</span><br><span class="line">    movl %eax, (%ebp)</span><br><span class="line"></span><br><span class="line">    // Restore the trap-time registers.  After you do this, you</span><br><span class="line">    // can no longer modify any general-purpose registers.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // 跳过 utf_err 以及 utf_fault_va</span><br><span class="line">    addl $8, %esp</span><br><span class="line">    // popal 同时 esp 会增加，执行结束后 %esp 指向 utf_eip</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    // Restore eflags from the stack.  After you do this, you can</span><br><span class="line">    // no longer use arithmetic operations or anything else that</span><br><span class="line">    // modifies eflags.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // 跳过 utf_eip</span><br><span class="line">    addl $4, %esp</span><br><span class="line">    // 恢复 eflags</span><br><span class="line">    popfl</span><br><span class="line"></span><br><span class="line">    // Switch back to the adjusted trap-time stack.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // 恢复 trap-time 的栈顶</span><br><span class="line">    popl %esp</span><br><span class="line">    // Return to re-execute the instruction that faulted.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // ret 指令相当于 popl %eip</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>首先必须要理解异常栈的结构，下图所示的是嵌套异常时的情况。其中左边表示内容，右边表示地址。需要注意的是，上一次异常的栈顶之下间隔 4byte，就是一个新的异常。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                 utf_esp</span><br><span class="line">reserved 32 bit  </span><br><span class="line">utf_esp          48(%esp)</span><br><span class="line">utf_eflags       44(%esp)</span><br><span class="line">utf_eip          40(%esp)</span><br><span class="line">utf_regs(end)    36(%esp)</span><br><span class="line">...</span><br><span class="line">utf_regs(start)   8(%esp)</span><br><span class="line">utf_err           4(%esp)</span><br><span class="line">utf_fault_va       (%esp)</span><br></pre></td></tr></table></figure></p>
<p>最难理解的是这一部分：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl 48(%esp), %ebp  // 使 %ebp 指向 utf_esp</span><br><span class="line">subl $4, %ebp        // %ebp-4</span><br><span class="line">movl %ebp, 48(%esp)  // 更新 utf_esp 值为 utf_esp-4</span><br><span class="line">movl 40(%esp), %eax</span><br><span class="line">movl %eax, (%ebp)  // 将 utf_esp-4 地址的内容改为 utf_eip</span><br></pre></td></tr></table></figure></p>
<p>经过这一部分的修改，异常栈更新为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                 utf_esp</span><br><span class="line">utf_eip</span><br><span class="line">utf_esp-4        48(%esp)</span><br><span class="line">utf_eflags       44(%esp)</span><br><span class="line">utf_eip          40(%esp)</span><br><span class="line">utf_regs(end)    36(%esp)</span><br><span class="line">...</span><br><span class="line">utf_regs(start)   8(%esp)</span><br><span class="line">utf_err           4(%esp)</span><br><span class="line">utf_fault_va       (%esp)</span><br></pre></td></tr></table></figure></p>
<p>此后就是恢复各寄存器，最后的<code>ret</code>指令相当于<code>popl %eip</code>，指令寄存器的值修改为<code>utf_eip</code>，达到了返回的效果。</p>
<p>实现<code>set_pgfault_handler()</code>练习是用户用来指定缺页异常处理方式的函数。代码比较简单，但是需要区分清楚<code>handler</code>，<code>_pgfault_handler</code>，<code>_pgfault_upcall</code>三个变量。</p>
<p><code>handler</code>是传入的用户自定义页错误处理函数指针。</p>
<p><code>_pgfault_upcall</code>是一个全局变量，在<code>lib/pfentry.S</code>中完成的初始化。它是页错误处理的总入口，页错误除了运行 page fault handler，还需要切换回正常栈。</p>
<p><code>_pgfault_handler</code>被赋值为<code>handler</code>，会在<code>_pgfault_upcall</code>中被调用，是页错误处理的一部分。具体代码是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    // Call the C page fault handler.</span><br><span class="line">    pushl %esp          // function argument: pointer to UTF</span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $4, %esp</span><br></pre></td></tr></table></figure></p>
<p>若是第一次调用，需要首先在这个<code>env</code>分配一个页面作为异常栈，并且将该进程的<code>upcall</code>设置为 Exercise 10 中的程序。此后如果需要改变<code>handler</code>，不需要再重复这个工作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">set_pgfault_handler</span><span class="params">(<span class="type">void</span> (*handler)(<span class="keyword">struct</span> UTrapframe *utf))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// First time through!</span></span><br><span class="line">        <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">        <span class="type">envid_t</span> e_id = sys_getenvid();</span><br><span class="line">        r = sys_page_alloc(e_id, (<span class="type">void</span> *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;pgfault_handler: %e&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// r = sys_env_set_pgfault_upcall(e_id, handler);</span></span><br><span class="line">        r = sys_env_set_pgfault_upcall(e_id, _pgfault_upcall);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;pgfault_handler: %e&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">    _pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>user/faultalloc</code>的部分输出如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">envs: f0292000, e: f0292000, e-&gt;env_id: 1000</span><br><span class="line">env_id, 1000</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">envs[0].env_status: 2</span><br><span class="line">PAGE FAULT</span><br><span class="line">fault deadbeef</span><br><span class="line">this string was faulted in at deadbeef</span><br><span class="line">PAGE FAULT</span><br><span class="line">fault cafebffe</span><br><span class="line">PAGE FAULT</span><br><span class="line">fault cafec000</span><br><span class="line">this string was faulted in at cafebffe</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">envs[0].env_status: 0</span><br><span class="line">envs[1].env_status: 0</span><br><span class="line">envs[0].env_status: 0</span><br><span class="line">envs[1].env_status: 0</span><br><span class="line">No runnable environments in the system!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br></pre></td></tr></table></figure></p>
<p><code>user/faultallocbad</code>的部分输出如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">envs: f0292000, e: f0292000, e-&gt;env_id: 1000</span><br><span class="line">env_id, 1000</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">envs[0].env_status: 2</span><br><span class="line">[00001000] user_mem_check assertion failure for va deadbeef</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">envs[0].env_status: 0</span><br><span class="line">envs[1].env_status: 0</span><br><span class="line">envs[0].env_status: 0</span><br><span class="line">envs[1].env_status: 0</span><br><span class="line">No runnable environments in the system!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br></pre></td></tr></table></figure></p>
<p>可以发现两个程序的输出有所不同，但是两者的page fault handler相同，因为一个使用<code>cprintf()</code>输出，一个使用<code>sys_cput()</code>输出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test user-level fault handler -- alloc pages to fix faults</span></span><br><span class="line"><span class="comment">// faultalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">handler</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">void</span> *addr = (<span class="type">void</span>*)utf-&gt;utf_fault_va;</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;fault %x\n&quot;</span>, addr);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, ROUNDDOWN(addr, PGSIZE),</span><br><span class="line">				PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;allocating at %x in page fault handler: %e&quot;</span>, addr, r);</span><br><span class="line">	<span class="built_in">snprintf</span>((<span class="type">char</span>*) addr, <span class="number">100</span>, <span class="string">&quot;this string was faulted in at %x&quot;</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	set_pgfault_handler(handler);</span><br><span class="line">	cprintf(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span>*)<span class="number">0xDeadBeef</span>);</span><br><span class="line">	cprintf(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span>*)<span class="number">0xCafeBffe</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test user-level fault handler -- alloc pages to fix faults</span></span><br><span class="line"><span class="comment">// doesn&#x27;t work because we sys_cputs instead of cprintf (exercise: why?)</span></span><br><span class="line"><span class="comment">// faultallocbad.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">handler</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">void</span> *addr = (<span class="type">void</span>*)utf-&gt;utf_fault_va;</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;fault %x\n&quot;</span>, addr);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, ROUNDDOWN(addr, PGSIZE),</span><br><span class="line">				PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;allocating at %x in page fault handler: %e&quot;</span>, addr, r);</span><br><span class="line">	<span class="built_in">snprintf</span>((<span class="type">char</span>*) addr, <span class="number">100</span>, <span class="string">&quot;this string was faulted in at %x&quot;</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	set_pgfault_handler(handler);</span><br><span class="line">	sys_cputs((<span class="type">char</span>*)<span class="number">0xDEADBEEF</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>sys_cput()</code>的时候会直接通过<code>lib/syscall.c</code>发起系统调用，其在<code>kern/syscall.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">    <span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    user_mem_assert(curenv, s, len, PTE_U);</span><br><span class="line">    <span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">    cprintf(<span class="string">&quot;%.*s&quot;</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它检查了内存，因此在这里 panic 了。中途没有触发过页错误。</p>
<p>而<code>cprintf()</code>的实现可以在<code>lib/printf.c</code>中找到：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vcprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">printbuf</span> <span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    b.idx = <span class="number">0</span>;</span><br><span class="line">    b.cnt = <span class="number">0</span>;</span><br><span class="line">    vprintfmt((<span class="type">void</span>*)putch, &amp;b, fmt, ap);</span><br><span class="line">    sys_cputs(b.buf, b.idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b.cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    cnt = vcprintf(fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它在调用<code>sys_cputs()</code>之前，首先在用户态执行了<code>vprintfmt()</code>将要输出的字符串存入结构体<code>b</code>中。在此过程中试图访问<code>0xdeadbeef</code>地址，触发并处理了页错误（其处理方式是在错误位置处分配一个字符串，内容是 “this string was faulted in at …”），因此在继续调用<code>sys_cputs()</code>时不会出现 panic。</p>
<h4 id="实现-Copy-on-Write-Fork"><a href="#实现-Copy-on-Write-Fork" class="headerlink" title="实现 Copy-on-Write Fork"></a>实现 Copy-on-Write Fork</h4><p>现在我们已经具备了在用户空间实现<code>copy-on-write fork()</code>的条件。</p>
<p>现在同样在<code>lib/fork.c</code>中给出了<code>fork()</code>的框架。如同<code>dumbfork()</code>一样，<code>fork()</code>也要创建一个新进程，并且在新进程中建立与父进程同样的内存映射。关键的不同点是，<code>dumbfork()</code>拷贝了物理页的内容，而<code>fork()</code>仅拷贝了映射关系，仅在某个进程需要改写某一页的内容时，才拷贝这一页的内容。其基本流程如下：</p>
<ul>
<li>父进程使用<code>set_pgfault_handler</code>将<code>pgfault()</code>设为<code>page fault handler</code></li>
<li>父进程使用<code>sys_exofork()</code>建立一个子进程</li>
<li>对每个在<code>UTOP</code>之下可写页面以及 COW 页面（用<code>PTE_COW</code>标识），父进程调用<code>duppage()</code>将其“映射”到子进程，同时将其权限改为只读，并用<code>PTE_COW</code>位来与一般只读页面区别。<ul>
<li>这个函数的作用是把一个页面以写时复制权限<code>PTE_COW</code>映射到子环境，然后再以写时复制权限映射到父进程（这个顺序很重要）。</li>
<li>以写时复制映射：先取消写权限（如果有），然后再加上写时复制权限用以区分普通只读页面。</li>
<li>异常栈的分配方式与此不同，需要在子进程中分配一个新页面。因为<code>page fault handler</code>会实实在在地向异常栈写入内容，并在异常栈上运行。如果异常栈页面都用<code>COW</code>机制，那就没有能够执行拷贝这个过程的载体了</li>
<li><code>fork()</code>同样需要处理<code>PTE_P</code>权限的页面（非可写或写时复制的）</li>
</ul>
</li>
<li>父进程会为子进程设置用户页错误处理入口。</li>
<li>子进程已经就绪，父进程将其设为<code>runnable</code></li>
</ul>
<p>进程第一次往一个 COW page 写入内容时，会发生 page fault，其流程为：</p>
<ul>
<li>内核将 page fault 传递至<code>_pgfault_upcall</code>，它会调用<code>pgfault() handler</code></li>
<li><code>pgfault()</code>检查错误号（error code）是否为<code>FEC_WR</code>（写操作），即是由于写操作触发了异常。然后检查触发异常的页面是否为写时复制的，如果不是则直接panic内核。</li>
<li><code>pgfault()</code>分配一个新的页面并将 fault page 的内容拷贝进去，然后将旧的映射覆盖，使其以可读可写权限映射到该新页面，并且取代原来的映射。</li>
</ul>
<p>用户级别的<code>lib/fork.c</code>代码需要查看环境的页表（查询某个页面是否为写时复制），这也是内核将环境的页表映射到<code>UVPT</code>位置的原因（因为用户环境不能访问内核，不具备访问<code>kern_pgdir</code>以及使用<code>pgdir_walk</code>的权限）。所以为了能够让用户环境访问到<code>PTE</code>和<code>PDE</code>，jos采取了这种clever mapping trick：UVPT</p>
<h4 id="UVPT"><a href="#UVPT" class="headerlink" title="UVPT"></a>UVPT</h4><p>页表的一个很好的概念模型是一个 2^20 条目的数组，它可以通过物理页号进行索引。x86 2 级分页方案通过将巨型页表分成许多页表和一个页目录来打破这个简单的模型。在内核中，我们使用<code>pgdir_walk()</code>通过遍历两级页表来查找条目。以某种方式恢复巨大的简单页表会很好——JOS 中的进程将查看它以弄清楚它们的地址空间中发生了什么。</p>
<p>这个页面描述了 JOS 通过利用分页硬件使用的一个巧妙的技巧——分页硬件非常适合将一组碎片页面放在一个连续的地址空间中。事实证明，我们已经有一个表，其中包含指向所有碎片页表的指针：它是页目录！</p>
<p>因此，我们可以使用页目录作为页表，在虚拟地址空间中某个连续的 2^22 字节范围内映射我们概念上的巨大 2^22 字节页表（由 1024 个页面表示）。我们可以通过将 PDE 条目标记为只读来确保用户进程不能修改他们的页表。</p>
<p>解释一下，每个4GB虚拟地址空间对应一个页目录，一个页目录包含2^10（10bits）个页表，每个页表有 2^10(10bits)页，每页的大小是 2^12B(12bits)，最终形成4GB地址空间。</p>
<p><img src="/img/20211124224000.png" alt=""></p>
<p>CR3指向页目录，解析一个线性地址，MMU会跟据其PDX，PTX和OFFSET三个部分依次去在页目录（通过目录项找到页表）和页表（通过表项找到页）中进行索引。</p>
<p>但是处理器分不清楚页表、页目录，它只是根据以下过程来进行查找：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd = lcr3(); </span><br><span class="line">pt = *(pd+4*PDX); </span><br><span class="line">page = *(pt+4*PTX);</span><br></pre></td></tr></table></figure></p>
<p>UVPT是页目录中的一个特殊的entry，它指向的是页目录自身。若UVPT的索引值是V，如果我们用一个PDX和PTX都是V的线性地址去进行解析，就会发现由于在页目录中对第V个entry的索引仍然是页目录本身的地址，这个地址最终解析出的就是页目录的物理地址（你可以理解为页目录本身就是一个页表，这种方式下我们连续两次解析到页目录本身的地址）。在JOS中，V=0x3BD，所以UVPD的虚拟地址是<code>(0x3BD &lt;&lt; 22)|(0x3BD &lt;&lt; 12)</code>。</p>
<p>同理，如果PDX为V而PTX不为V，则会解析出各个页表的地址。在JOS中，V=0x3BD，所以UVPT的虚拟地址是<code>(0x3BD &lt;&lt; 22)</code>。通过这种方式，用户可以在UVPT内存区中访问到页目录和各个页表。<br><img src="/img/20211124224001.png" alt=""></p>
<h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><p>首先从主函数<code>fork()</code>入手，其大体结构可以仿造<code>user/dumbfork.c</code>写，但是有关键几处不同：</p>
<ul>
<li>设置<code>page fault handler</code>，即<code>page fault upcall</code>调用的函数</li>
<li><code>duppage</code>的范围不同，<code>fork()</code>不需要复制内核区域的映射</li>
<li>为子进程设置<code>page fault upcall</code>，之所以这么做，是因为<code>sys_exofork()</code>并不会复制父进程的<code>e-&gt;env_pgfault_upcall</code>给子进程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">envid_t</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;fork not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    set_pgfault_handler(pgfault);</span><br><span class="line">    <span class="type">envid_t</span> e_id = sys_exofork();</span><br><span class="line">    <span class="keyword">if</span> (e_id &lt; <span class="number">0</span>) panic(<span class="string">&quot;fork: %e&quot;</span>, e_id);</span><br><span class="line">    <span class="keyword">if</span> (e_id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parent</span></span><br><span class="line">    <span class="comment">// extern unsigned char end[];</span></span><br><span class="line">    <span class="comment">// for ((uint8_t *) addr = UTEXT; addr &lt; end; addr += PGSIZE)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uintptr_t</span> addr = UTEXT; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) ) &#123;</span><br><span class="line">            <span class="comment">// dup page to child</span></span><br><span class="line">            duppage(e_id, PGNUM(addr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// alloc page for exception stack</span></span><br><span class="line">    <span class="type">int</span> r = sys_page_alloc(e_id, (<span class="type">void</span> *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) panic(<span class="string">&quot;fork: %e&quot;</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DO NOT FORGET</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> _pgfault_upcall();</span><br><span class="line">    r = sys_env_set_pgfault_upcall(e_id, _pgfault_upcall);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) panic(<span class="string">&quot;fork: set upcall for child fail, %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark the child environment runnable</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_status(e_id, ENV_RUNNABLE)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;sys_env_set_status: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="duppage-函数"><a href="#duppage-函数" class="headerlink" title="duppage()函数"></a>duppage()函数</h4><p>该函数的作用是复制父、子进程的页面映射。尤其注意一个权限问题。由于<code>sys_page_map()</code>页面的权限有硬性要求，因此必须要修正一下权限。之前没有修正导致一直报错，后来发现页面权限为<code>0x865</code>，不符合<code>sys_page_map()</code>要求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">duppage</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">unsigned</span> pn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;duppage not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">envid_t</span> this_env_id = sys_getenvid();</span><br><span class="line">    <span class="type">void</span> * va = (<span class="type">void</span> *)(pn * PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> perm = uvpt[pn] &amp; <span class="number">0xFFF</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (perm &amp; PTE_W) || (perm &amp; PTE_COW) ) &#123;</span><br><span class="line">        <span class="comment">// marked as COW and read-only</span></span><br><span class="line">        perm |= PTE_COW;</span><br><span class="line">        perm &amp;= ~PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// IMPORTANT: adjust permission to the syscall</span></span><br><span class="line">    perm &amp;= PTE_SYSCALL;</span><br><span class="line">    <span class="comment">// cprintf(&quot;fromenvid = %x, toenvid = %x, dup page %d, addr = %08p, perm = %03x\n&quot;,this_env_id, envid, pn, va, perm);</span></span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_map(this_env_id, va, envid, va, perm)) &lt; <span class="number">0</span>) </span><br><span class="line">        panic(<span class="string">&quot;duppage: %e&quot;</span>,r);</span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_map(this_env_id, va, this_env_id, va, perm)) &lt; <span class="number">0</span>) </span><br><span class="line">        panic(<span class="string">&quot;duppage: %e&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pgfault-函数"><a href="#pgfault-函数" class="headerlink" title="pgfault() 函数"></a>pgfault() 函数</h4><p>这是<code>_pgfault_upcall</code>中调用的页错误处理函数。在调用之前，父子进程的页错误地址都引用同一页物理内存，该函数作用是分配一个物理页面使得两者独立。</p>
<p>首先，它分配一个页面，映射到了交换区<code>PFTEMP</code>这个虚拟地址，然后通过<code>memmove()</code>函数将<code>addr</code>所在页面拷贝至<code>PFTEMP</code>，此时有两个物理页保存了同样的内容。再将<code>addr</code>也映射到<code>PFTEMP</code>对应的物理页，最后解除了<code>PFTEMP</code>的映射，此时就只有<code>addr</code>指向新分配的物理页了，如此就完成了错误处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *addr = (<span class="type">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">    <span class="type">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line">    <span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line">    <span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((err &amp; FEC_WR)==<span class="number">0</span> || (uvpt[PGNUM(addr)] &amp; PTE_COW)==<span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;pgfault: invalid user trap frame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line">    <span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line">    <span class="comment">// page to the old page&#x27;s address.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;pgfault not implemented&quot;);</span></span><br><span class="line">    <span class="type">envid_t</span> envid = sys_getenvid();</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(envid, (<span class="type">void</span> *)PFTEMP, PTE_P | PTE_W | PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;pgfault: page allocation failed %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    memmove(PFTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(envid, addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;pgfault: page unmap failed (%e)&quot;</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_W |PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;pgfault: page map failed (%e)&quot;</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(envid, PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;pgfault: page unmap failed (%e)&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-C-抢占式多进程处理-amp-进程间通信"><a href="#Part-C-抢占式多进程处理-amp-进程间通信" class="headerlink" title="Part C: 抢占式多进程处理 &amp; 进程间通信"></a>Part C: 抢占式多进程处理 &amp; 进程间通信</h2><p>作为 lab4 的最后一步，我们要修改内核使之能抢占一些不配合的进程占用的资源，以及允许进程之间的通信。</p>
<h3 id="Part-I-时钟中断以及抢占"><a href="#Part-I-时钟中断以及抢占" class="headerlink" title="Part I: 时钟中断以及抢占"></a>Part I: 时钟中断以及抢占</h3><p>尝试运行一下 user/spin 测试，该测试建立一个子进程，该子进程获得 CPU 资源后就进入死循环，这样内核以及父进程都无法再次获得 CPU。这显然是操作系统需要避免的。为了允许内核从一个正在运行的进程抢夺 CPU 资源，我们需要支持来自硬件时钟的外部硬件中断。</p>
<h4 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h4><p>外部中断用 IRQ(Interrupt Request) 表示。一共有 16 种 IRQ，IRQ的编号到IDT表项的映射并不是固定的。<code>picirq.c</code>的<code>pic_init()</code>将会把0-15号IRQ映射到<code>IDT</code>表项中对应的<code>IRQ_OFFSET</code>-<code>IRQ_OFFSET+15</code>。</p>
<p><code>IRQ_OFFSET</code>被定义为32（在<code>inc/trap.h</code>中），那么<code>IDT</code>表项的32-47就对应了15种<code>IRQ</code>，时钟中断是<code>IRQ 0</code>。这样设置不会让处理器异常和IRQ重叠。</p>
<p>Lab3中介绍 x86 的所有异常可以用中断向量 0~31 表示，对应 IDT 的第 0~31 项。例如，页错误产生一个中断向量为 14 的异常。大于 32 的中断向量表示的都是中断</p>
<p>相对 xv6，在 JOS 中我们中了一个关键的简化：在内核态时禁用外部设备中断。外部中断使用<code>%eflag</code>寄存器的<code>FL_IF</code>位控制。当该位置 1 时，开启中断。由于我们的简化，我们只在进入以及离开内核时需要修改这个位。</p>
<p>我们需要确保在用户态时<code>FL_IF</code>置 1，使得当有中断发生时，可以被处理。我们在<code>bootloader</code>的第一条指令<code>cli</code>就关闭了中断，然后再也没有开启过。</p>
<p>exercise13要求我们修改<code>kern/trap.c</code>和<code>kern/trapentry.S</code>，来初始化IDT中的入口，为IRQ 0到15提供处理函数。然后修改<code>env_alloc</code>，确保用户环境能够在使能中断时运行。</p>
<p>比较简单，跟 Lab3 中的 Exercise 4 大同小异。相关的常数定义在<code>inc/trap.h</code>中可以找到。</p>
<p>在<code>kern/trapentry.S</code>中加入：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRQs</span></span><br><span class="line">TRAPHANDLER(handler32, IRQ_OFFSET + IRQ_TIMER)</span><br><span class="line">TRAPHANDLER(handler33, IRQ_OFFSET + IRQ_KBD)</span><br><span class="line">TRAPHANDLER(handler36, IRQ_OFFSET + IRQ_SERIAL)</span><br><span class="line">TRAPHANDLER(handler39, IRQ_OFFSET + IRQ_SPURIOUS)</span><br><span class="line">TRAPHANDLER(handler46, IRQ_OFFSET + IRQ_IDE)</span><br><span class="line">TRAPHANDLER(handler51, IRQ_OFFSET + IRQ_ERROR)</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/trap.c</code>的<code>trap_init()</code>中加入：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// IRQs</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">handler32</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">handler33</span><span class="params">()</span>;   </span><br><span class="line">    <span class="type">void</span> <span class="title function_">handler36</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">handler39</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">handler46</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">handler51</span><span class="params">()</span>;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// IRQs</span></span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], <span class="number">0</span>, GD_KT, handler32, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD], <span class="number">0</span>, GD_KT, handler33, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], <span class="number">0</span>, GD_KT, handler36, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="number">0</span>, GD_KT, handler39, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE], <span class="number">0</span>, GD_KT, handler46, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], <span class="number">0</span>, GD_KT, handler51, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意，<code>SETGATE</code>中<code>istrap</code>参数需要设置为0。根据<code>SETGATE</code>的注释，两个值的区别在于，设为<code>1</code>就会在开始处理中断时将<code>FL_IF</code>位重新置1，而设为<code>0</code>则保持<code>FL_IF</code>位不变。根据这里的需求，显然应该置0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up a normal interrupt/trap gate descriptor.</span></span><br><span class="line"><span class="comment">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class="line">    <span class="comment">//   see section 9.6.1.3 of the i386 reference: &quot;The difference between</span></span><br><span class="line">    <span class="comment">//   an interrupt gate and a trap gate is in the effect on IF (the</span></span><br><span class="line">    <span class="comment">//   interrupt-enable flag). An interrupt that vectors through an</span></span><br><span class="line">    <span class="comment">//   interrupt gate resets IF, thereby preventing other interrupts from</span></span><br><span class="line">    <span class="comment">//   interfering with the current interrupt handler. A subsequent IRET</span></span><br><span class="line">    <span class="comment">//   instruction restores IF to the value in the EFLAGS image on the</span></span><br><span class="line">    <span class="comment">//   stack. An interrupt through a trap gate does not change IF.&quot;</span></span><br><span class="line"><span class="comment">// - sel: Code segment selector for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - off: Offset in code segment for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - dpl: Descriptor Privilege Level -</span></span><br><span class="line"><span class="comment">//    the privilege level required for software to invoke</span></span><br><span class="line"><span class="comment">//    this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)            \</span></span><br><span class="line"><span class="meta">&#123;                               \</span></span><br><span class="line"><span class="meta">    (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff;     \</span></span><br><span class="line"><span class="meta">    (gate).gd_sel = (sel);                  \</span></span><br><span class="line"><span class="meta">    (gate).gd_args = 0;                 \</span></span><br><span class="line"><span class="meta">    (gate).gd_rsv1 = 0;                 \</span></span><br><span class="line"><span class="meta">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span></span><br><span class="line"><span class="meta">    (gate).gd_s = 0;                    \</span></span><br><span class="line"><span class="meta">    (gate).gd_dpl = (dpl);                  \</span></span><br><span class="line"><span class="meta">    (gate).gd_p = 1;                    \</span></span><br><span class="line"><span class="meta">    (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16;       \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在<code>kern/env.c</code>的<code>env_alloc()</code>中加入：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable interrupts while in user mode.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure></p>
<h4 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h4><p>在<code>user/spin</code>程序中，子进程开启后就陷入死循环，此后 kernel 无法再获得控制权。我们需要让硬件周期性地产生时钟中断，强制将控制权交给 kernel，使得我们能够切换到其他进程。</p>
<p>Exercise 14需要修改<code>trap_dispatch()</code>函数，当时钟中断到达时，执行新的环境。</p>
<p>直接在<code>trap_dispatch()</code>中添加时钟中断的分支即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle clock interrupts. Don&#x27;t forget to acknowledge the</span></span><br><span class="line"><span class="comment">// interrupt using lapic_eoi() before calling the scheduler!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">    lapic_eoi();</span><br><span class="line">    sched_yield();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Part-II-进程间通信-IPC"><a href="#Part-II-进程间通信-IPC" class="headerlink" title="Part II: 进程间通信(IPC)"></a>Part II: 进程间通信(IPC)</h3><p>在之前的 Lab 中，我们一直在讲操作系统是如何隔离各个进程的，怎么让程序感觉独占一台机器的。操作系统的另一个重要功能就是允许进程之间相互通信。</p>
<h4 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h4><p>我们将实现两个系统调用：<code>sys_ipc_recv</code>以及<code>sys_ipc_try_send</code>，再将他们封装为两个库函数，<code>ipc_recv</code>和<code>ipc_send</code>以支持通信。</p>
<p>用户环境可以通过jos系统的IPC机制向其他用户环境发送“消息”（message）。这个消息分为两部分：一个32-bit的值，以及一个可选的单页映射。允许用户环境传递页映射是一种比发送32-bit更有效的数据传递方式（很容易实现共享内存）。</p>
<h4 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a>发送和接收消息</h4><p>进程使用<code>sys_ipc_recv</code>来接收消息。该系统调用会将程序挂起，让出 CPU 资源，直到收到消息。在这个时期，任一进程都能给他发送信息，不限于父子进程。<br>为了发送信息，进程会调用<code>sys_ipc_try_send</code>，以接收者的进程<code>id</code>以及要发送的值为参数。如果接收者已经调用了<code>sys_ipc_recv</code>，则成功发送消息并返回0。否则返回<code>E_IPC_NOT_RECV</code>表明目标进程并没有接收消息。</p>
<p>用户空间的库函数<code>ipc_recv()</code>将会负责调用<code>sys_ipc_recv()</code>，然后在当前环境的<code>struct Env</code>中查找接收值的信息。相似地，库函数<code>ipc_send()</code>负责重复调用<code>sys_ipc_try_send()</code>直到发送成功。</p>
<h4 id="传递页面"><a href="#传递页面" class="headerlink" title="传递页面"></a>传递页面</h4><p>当进程调用<code>sys_ipc_recv</code>并提供一个<code>UTOP</code>以下的合法虚拟地址<code>dstva</code>(必须位于用户空间)时，进程表示它希望能接收一个页面映射。如果发送者发送一个页面，该页面就会被映射到接收者的<code>dstva</code>。同时，之前位于<code>dstva</code>的页面映射会被覆盖。</p>
<p>当进程调用<code>sys_ipc_try_send</code>并提供一个<code>UTOP</code>以下的合法虚拟地址<code>srcva</code>(必须位于用户空间)，表明发送者希望发送位于<code>srcva</code>的页面给接收者，权限设置为<code>perm</code>。当IPC成功进行之后，发送方会保持<code>srcva</code>处的映射关系，但是接受方同样也会在其地址<code>dstva</code>处映射这个页面。那此时这个页面就成了发送方到接受方的共享页面。</p>
<p>在一个成功的 IPC 之后，发送者和接受者将共享一个物理页。</p>
<p>注意，如果发送方和接收方之间的任意一方没有声明需要传输的是一个页面，那就不会有页面进行传输。</p>
<p>在任何IPC结束之后，内核将会设置接受方的<code>struct Env</code>的<code>env_ipc_perm</code>成员。如果没有接受页面则设置为0，如果接受页面则设置为接收到的页面权限<code>perm</code>。</p>
<h4 id="Implementing-IPC"><a href="#Implementing-IPC" class="headerlink" title="Implementing IPC"></a>Implementing IPC</h4><p>exercise 15实现<code>kern/syscall.c</code>中的<code>sys_ipc_recv()</code>和<code>sys_ipc_try_send()</code>。</p>
<p>当我们需要在这些有关IPC的例程中调用<code>envid2env()</code>时，需要将参数<code>checkperm</code>设置为0，这意味着任何环境都被允许与其他环境进行IPC。</p>
<p>然后实现<code>lib/ipc.c</code>中的<code>ipc_recv()</code>和<code>ipc_send()</code>的封装。</p>
<p>首先需要仔细阅读<code>inc/env.h</code>了解用于传递消息的数据结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lab 4 IPC</span></span><br><span class="line"><span class="type">bool</span> env_ipc_recving;       <span class="comment">// Env is blocked receiving</span></span><br><span class="line"><span class="type">void</span> *env_ipc_dstva;        <span class="comment">// VA at which to map received page</span></span><br><span class="line"><span class="type">uint32_t</span> env_ipc_value;     <span class="comment">// Data value sent to us</span></span><br><span class="line"><span class="type">envid_t</span> env_ipc_from;       <span class="comment">// envid of the sender</span></span><br><span class="line"><span class="type">int</span> env_ipc_perm;       <span class="comment">// Perm of page mapping received</span></span><br></pre></td></tr></table></figure></p>
<p>然后需要注意的是通信流程。</p>
<ol>
<li>调用<code>ipc_recv</code>，设置好<code>Env</code>结构体中的相关<code>field</code></li>
<li>调用<code>ipc_send</code>，它会通过<code>envid</code>找到接收进程，并读取<code>Env</code>中刚才设置好的<code>field</code>，进行通信。</li>
<li>最后返回实际上是在<code>ipc_send</code>中设置好<code>reg_eax</code>，在调用结束，退出内核态时返回。</li>
</ol>
<p>首先从调用过程入手，这部分比较简单。</p>
<h4 id="lib-部分"><a href="#lib-部分" class="headerlink" title="lib 部分"></a>lib 部分</h4><p><code>ipc_recv</code>中，如果<code>pg</code>不为空，则收到的页会被映射到这里。如果<code>from_env_store</code>不为空，则把sender的<code>envid</code>存到这里。如果系统调用失败了，<code>*fromenv</code>和<code>*perm</code>这两个都会被赋值为0。</p>
<p>如果不需要共享页面，则把作为参数的虚拟地址设为<code>UTOP</code>，这个地址在下面的系统调用实现中，会被忽略掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">ipc_recv</span><span class="params">(<span class="type">envid_t</span> *from_env_store, <span class="type">void</span> *pg, <span class="type">int</span> *perm_store)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;ipc_recv not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (pg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        r = sys_ipc_recv(pg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = sys_ipc_recv((<span class="type">void</span> *) UTOP);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// failed</span></span><br><span class="line">        <span class="keyword">if</span> (from_env_store != <span class="literal">NULL</span>) *from_env_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (perm_store != <span class="literal">NULL</span>) *perm_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from_env_store != <span class="literal">NULL</span>) </span><br><span class="line">            *from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">        <span class="keyword">if</span> (perm_store != <span class="literal">NULL</span>) </span><br><span class="line">            *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">        <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就是会不停地尝试，在这个while里也要调用<code>sys_yield</code>防止一直占用CPU。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_send</span><span class="params">(<span class="type">envid_t</span> to_env, <span class="type">uint32_t</span> val, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;ipc_send not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (pg == <span class="literal">NULL</span>) pg = (<span class="type">void</span> *)UTOP;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        r = sys_ipc_try_send(to_env, val, pg, perm);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> &amp;&amp; r != -E_IPC_NOT_RECV) </span><br><span class="line">            panic(<span class="string">&quot;ipc send failed: %e&quot;</span>, r);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125; <span class="keyword">while</span> (r != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_ipc_recv()</code>首先检查<code>dstva</code>是否合法，这里如果<code>dstva</code>等于<code>UTOP</code>的其实也是合法的，只是不需要去映射地址。然后获取到相应的<code>env</code>对象，设置其ipc数据域，并把当前的<code>env</code>设置成不能运行，直至接收完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 接收</span><br><span class="line">static int</span><br><span class="line">sys_ipc_recv(void *dstva)</span><br><span class="line">&#123;</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // panic(&quot;sys_ipc_recv not implemented&quot;);</span><br><span class="line">    </span><br><span class="line">    // wrong, because when we don&#x27;t want to share page, we set dstva=UTOP</span><br><span class="line">    // but we can still pass value</span><br><span class="line">    // if ( (uintptr_t) dstva &gt;= UTOP) return -E_INVAL;</span><br><span class="line">    if ((uintptr_t) dstva &lt; UTOP &amp;&amp; PGOFF(dstva) != 0) return -E_INVAL;</span><br><span class="line"></span><br><span class="line">    envid_t envid = sys_getenvid();</span><br><span class="line">    struct Env *e;</span><br><span class="line">    // do not check permission</span><br><span class="line">    if (envid2env(envid, &amp;e, 0) &lt; 0) return -E_BAD_ENV;</span><br><span class="line">    </span><br><span class="line">    e-&gt;env_ipc_recving = true;</span><br><span class="line">    e-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    sys_yield();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_ipc_try_send()</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to send &#x27;value&#x27; to the target env &#x27;envid&#x27;.</span></span><br><span class="line"><span class="comment">// If srcva &lt; UTOP, then also send page currently mapped at &#x27;srcva&#x27;,</span></span><br><span class="line"><span class="comment">// so that receiver gets a duplicate mapping of the same page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The send fails with a return value of -E_IPC_NOT_RECV if the</span></span><br><span class="line"><span class="comment">// target is not blocked, waiting for an IPC.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The send also can fail for the other reasons listed below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Otherwise, the send succeeds, and the target&#x27;s ipc fields are</span></span><br><span class="line"><span class="comment">// updated as follows:</span></span><br><span class="line"><span class="comment">//    env_ipc_recving is set to 0 to block future sends;</span></span><br><span class="line"><span class="comment">//    env_ipc_from is set to the sending envid;</span></span><br><span class="line"><span class="comment">//    env_ipc_value is set to the &#x27;value&#x27; parameter;</span></span><br><span class="line"><span class="comment">//    env_ipc_perm is set to &#x27;perm&#x27; if a page was transferred, 0 otherwise.</span></span><br><span class="line"><span class="comment">// The target environment is marked runnable again, returning 0</span></span><br><span class="line"><span class="comment">// from the paused sys_ipc_recv system call.  (Hint: does the</span></span><br><span class="line"><span class="comment">// sys_ipc_recv function ever actually return?)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the sender wants to send a page but the receiver isn&#x27;t asking for one,</span></span><br><span class="line"><span class="comment">// then no page mapping is transferred, but no error occurs.</span></span><br><span class="line"><span class="comment">// The ipc only happens when no errors occur.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn&#x27;t currently exist.</span></span><br><span class="line"><span class="comment">//		(No need to check permissions.)</span></span><br><span class="line"><span class="comment">//	-E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,</span></span><br><span class="line"><span class="comment">//		or another environment managed to send first.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP but srcva is not page-aligned.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP and perm is inappropriate</span></span><br><span class="line"><span class="comment">//		(see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP but srcva is not mapped in the caller&#x27;s</span></span><br><span class="line"><span class="comment">//		address space.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in the</span></span><br><span class="line"><span class="comment">//		current environment&#x27;s address space.</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there&#x27;s not enough memory to map srcva in envid&#x27;s</span></span><br><span class="line"><span class="comment">//		address space.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_try_send</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">uint32_t</span> value, <span class="type">void</span> *srcva, <span class="type">unsigned</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">tar_env</span>;</span></span><br><span class="line">	<span class="comment">// check target env</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid, &amp;tar_env, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// check recver status</span></span><br><span class="line">	<span class="keyword">if</span>(!tar_env-&gt;env_ipc_recving)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// page send</span></span><br><span class="line">	<span class="keyword">if</span>((<span class="type">uintptr_t</span>)srcva &lt; UTOP)&#123;</span><br><span class="line">		<span class="comment">//page valid check</span></span><br><span class="line">		<span class="keyword">if</span>(PGOFF(srcva))&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// perm valid check</span></span><br><span class="line">		<span class="keyword">if</span>(perm &amp; (~PTE_SYSCALL) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P))&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// page find</span></span><br><span class="line">		<span class="type">pte_t</span> * pte;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">pginfo</span>;</span></span><br><span class="line">		pginfo = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pte);</span><br><span class="line">		<span class="keyword">if</span>(!pginfo)&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// sender &amp; receiver PTE_W</span></span><br><span class="line">		<span class="keyword">if</span>((perm &amp; PTE_W) &amp;&amp; !((*pte) &amp; PTE_W))&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// dst check</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="type">uintptr_t</span>)(tar_env-&gt;env_ipc_dstva) &lt; UTOP)&#123;</span><br><span class="line">			<span class="comment">// insert page map</span></span><br><span class="line">			<span class="keyword">if</span>(page_insert(tar_env-&gt;env_pgdir, pginfo, tar_env-&gt;env_ipc_dstva, perm) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// insert success</span></span><br><span class="line">			tar_env-&gt;env_ipc_perm = perm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tar_env-&gt;env_ipc_perm = <span class="number">0</span>;</span><br><span class="line">	tar_env-&gt;env_ipc_value = value;</span><br><span class="line">	<span class="comment">// tar status</span></span><br><span class="line">	tar_env-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">	tar_env-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">	tar_env-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	tar_env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在这次lab中，您将实现spawn，这是一个加载和运行磁盘可执行文件的库调用。然后，您将充实kernel和库操作系统，以在控制台上运行Shell。</p>
<h2 id="文件系统初步"><a href="#文件系统初步" class="headerlink" title="文件系统初步"></a>文件系统初步</h2><p>JOS文件系统设计相比Linux等系统的文件系统如ext2，ext3等，要简化不少。它不支持用户和权限特性，也不支持硬链接，符号链接，时间戳以及特殊设备文件等。</p>
<h3 id="磁盘文件系统结构"><a href="#磁盘文件系统结构" class="headerlink" title="磁盘文件系统结构"></a>磁盘文件系统结构</h3><p>大部分Unix文件系统会将磁盘空间分为inode和data两个部分，如linux就是这样的，其中inode用于存储文件的元数据，比如文件类型(常规、目录、符号链接等），权限，文件大小，创建/修改/访问时间，文件数据块信息等，我们运行的<code>ls -l</code>看到的内容，都是存储在inode而不是数据块中的。数据部分通常分为很多数据块，数据块用于存储文件的数据信息以及目录的元数据(目录元数据包括目录下文件的inode，文件名，文件类型等)。</p>
<p>文件和目录在逻辑上都由一系列数据块组成，这些数据块可能分散在整个磁盘中，就像虚拟地址空间的页面可以分散在整个物理内存中一样。文件系统环境隐藏了块布局的细节，提供了用于读取和写入文件内任意偏移量的字节序列的接口。文件系统环境在内部处理对目录的所有修改，作为执行文件创建和删除等操作的一部分。我们的文件系统允许用户环境直接读取目录元数据（例如，使用 read），这意味着用户环境可以自己执行目录扫描操作（例如，实现 ls 程序），而不必依赖到文件系统的特殊系统调用。这种目录扫描方法的缺点，也是大多数现代 UNIX 变体不鼓励它的原因，是它使应用程序依赖于目录元数据的格式，从而很难在不改变或至少改变文件系统的内部布局的情况下重新编译应用程序。</p>
<h3 id="磁盘扇区、数据块"><a href="#磁盘扇区、数据块" class="headerlink" title="磁盘扇区、数据块"></a>磁盘扇区、数据块</h3><p>扇区是磁盘的物理属性，通常一个扇区大小为512字节，而数据块则是操作系统使用磁盘的一个逻辑属性，一个块大小通常是扇区的整数倍，在JOS中一个扇区是512Bytes，一个块大小为4KB，跟我们物理内存的页大小一致。UNIX xv6 文件系统使用 512 字节的块大小，与底层磁盘的扇区大小相同。然而，大多数现代文件系统使用更大的块大小，因为存储空间变得更便宜，并且以更大的粒度管理存储更有效。我们的文件系统将使用 4096 字节的块大小，方便地匹配处理器的页面大小。</p>
<p>文件系统实际上以块为单位分配和使用磁盘存储。注意这两个术语之间的区别：扇区大小是磁盘硬件的属性，而块大小是使用磁盘的操作系统的一个方面。文件系统的块大小必须是底层磁盘扇区大小的倍数。</p>
<h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><p>文件系统通常在磁盘上“易于查找”的位置（例如开头或结尾）保留某些磁盘块，以保存描述整个文件系统属性的元数据，例如块大小、磁盘大小、查找根目录所需的任何元数据、文件系统上次挂载的时间、文件系统上次检查错误的时间等。这些特殊块被称为超级块。</p>
<p>我们的文件系统将只有一个超级块，它始终位于磁盘上的块 1。它的布局由<code>inc/fs.h</code>中的<code>struct Super</code>定义。块 0 通常保留用于保存引导加载程序和分区表，因此文件系统通常不使用第一个磁盘块。许多“真正的”文件系统维护多个超级块，在磁盘的多个间隔很宽的区域中复制，因此如果其中一个被损坏或磁盘在该区域出现介质错误，则仍然可以找到其他超级块并用于访问文件系统。</p>
<h3 id="文件元数据"><a href="#文件元数据" class="headerlink" title="文件元数据"></a>文件元数据</h3><p>在我们的文件系统中描述文件的元数据的布局由<code>inc/fs.h</code>中的<code>struct File</code>描述。此元数据包括文件的名称、大小、类型（常规文件或目录）以及指向组成文件的块的指针。如上所述，我们没有<code>inode</code>，因此此元数据存储在磁盘上的目录条目中。与大多数“真实”文件系统不同，为简单起见，我们将使用这种文件结构来表示文件元数据，因为它同时出现在磁盘和内存中。</p>
<p><img src="/img/20211128114300.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> s_magic;               <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">        <span class="type">uint32_t</span> s_nblocks;             <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>             <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct File</code>中的<code>f_direct</code>数组包含空间来存储文件的前 10 个（NDIRECT）块的块号，我们称之为文件的直接块。对于大小不超过<code>10*4096 = 40KB</code>的小文件，这意味着所有文件块的块号将直接适合文件结构本身。然而，对于较大的文件，我们需要一个地方来保存文件的其余块编号。因此，对于任何大于 40KB 的文件，我们分配一个额外的磁盘块，称为文件的间接块，以容纳多达<code>4096/4 = 1024</code>个额外的块号。因此，我们的文件系统允许文件最大为 1034 个块，或略高于 4 兆字节。为了支持更大的文件，“真正的”文件系统通常也支持双重和三重间接块。</p>
<p><img src="/img/20211128114301.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> f_name[MAXNAMELEN];    <span class="comment">// filename</span></span><br><span class="line">    <span class="type">off_t</span> f_size;           <span class="comment">// file size in bytes</span></span><br><span class="line">    <span class="type">uint32_t</span> f_type;        <span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block pointers.</span></span><br><span class="line">    <span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">    <span class="type">uint32_t</span> f_direct[NDIRECT]; <span class="comment">// direct blocks</span></span><br><span class="line">    <span class="type">uint32_t</span> f_indirect;        <span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad out to 256 bytes; must do arithmetic in case we&#x27;re compiling</span></span><br><span class="line">    <span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line">    <span class="type">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));  <span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure>
<h3 id="目录与常规文件"><a href="#目录与常规文件" class="headerlink" title="目录与常规文件"></a>目录与常规文件</h3><p>我们文件系统中的 File 结构可以表示一个普通文件或一个目录； 这两种类型的“文件”通过文件结构中的类型字段来区分。文件系统以完全相同的方式管理常规文件和目录文件，除了它根本不解释与常规文件关联的数据块的内容，而文件系统将目录文件的内容解释为一系列 描述目录中的文件和子目录的文件结构。</p>
<p>我们文件系统中的超级块包含一个文件结构（结构 Super 中的根字段），它保存文件系统根目录的元数据。该目录文件的内容是描述位于文件系统根目录中的文件和目录的文件结构序列。根目录中的任何子目录又可能包含更多表示子子目录的文件结构，依此类推。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h3><p>操作系统中的文件系统环境需要能够访问磁盘，但是我们还没有在内核中实现任何磁盘访问功能。我们没有采用传统的“单片”操作系统策略，即在内核中添加IDE磁盘驱动程序以及允许文件系统访问它的必要的系统调用，而是将IDE磁盘驱动程序实现为用户级文件系统环境的一部分。我们仍然需要稍微修改内核，以便进行设置，使文件系统环境具有实现磁盘访问本身所需的特权。</p>
<p>只要我们依赖于polling(轮询)、基于“programmed I/O”(PIO)的磁盘访问，并且不使用磁盘中断，就很容易在用户空间中实现磁盘访问。也可以在用户模式下实现中断驱动的设备驱动程序(例如，L3和L4内核是这样做的)，但是难度更大，因为内核必须实现设备中断并将它们分派到正确的用户模式环境中。</p>
<p>x86处理器使用EFLAGS寄存器中的IOPL位来确定是否允许保护模式代码执行特殊的设备I/O指令，比如IN和OUT指令。由于我们需要访问的所有IDE磁盘寄存器都位于x86的I/O空间中，而不是内存映射，所以为了允许文件系统访问这些寄存器，我们只需要给文件系统环境提供“I/O privilege”。实际上，EFLAGS寄存器中的IOPL位为内核提供了一个简单的“all-or-nothing”(全有或全无)方法来控制用户模式代码是否可以访问I/O空间。在我们的示例中，我们希望文件系统environment能够访问I/O空间，但是我们根本不希望任何其他environment能够访问I/O空间。</p>
<p>Exercise 1. <code>i386_init</code>通过将类型<code>ENV_TYPE_FS</code>传递给环境创建函数<code>env_create</code>来标识文件系统环境。在<code>env.c</code>中修改<code>env_create</code>，以便它赋予文件系统environment I/O特权，但永远不要将该特权授予任何其他环境。</p>
<p>这个地方代码还是比较简单的，毕竟之前为用户环境开中断也是设置的<code>eflags</code>的<code>FL_IF</code>位，这里就是设置<code>eflags</code>的<code>IOPL</code>位<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_create</span><span class="params">(<span class="type">uint8_t</span> *binary, <span class="type">size_t</span> size, <span class="keyword">enum</span> EnvType type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">        <span class="type">int</span> result = env_alloc(&amp;env, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(result &lt; <span class="number">0</span>)</span><br><span class="line">                panic(<span class="string">&quot;env_create: env_alloc error&quot;</span>);</span><br><span class="line">        load_icode(env, binary, size);</span><br><span class="line">        env-&gt;env_type = type;</span><br><span class="line">        <span class="comment">// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.</span></span><br><span class="line">        <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">        <span class="keyword">if</span> (type == ENV_TYPE_FS)</span><br><span class="line">                env-&gt;env_tf.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Question1.当您随后从一种environment切换到另一种environment时，是否还需要执行其他操作以确保正确保存和恢复此I/O特权设置？ 为什么？</p>
<p>answer：这肯定是不用的，每次切换进程都会保存上下文，切回来的时候恢复上下文。</p>
<h3 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h3><p>在我们的文件系统中，我们将借助处理器的虚拟内存系统实现一个简单的“buffer cache”（实际上只是一个block cache）。 block cache的代码在<code>fs/bc.c</code>中。（这里其实就暗示了文件系统读写的单位是一个block而不是扇区）。</p>
<p>我们的文件系统将仅限于处理3GB或更小的磁盘。我们保留文件系统environment的地址空间的一个大的、固定的3GB区域，从<code>0x10000000</code> (<code>DISKMAP</code>)到<code>0xD0000000</code>(<code>DISKMAP+DISKMAX</code>)，作为磁盘的“内存映射”版本。例如，disk block 0映射到虚拟地址<code>0x10000000</code>，disk block 1映射到虚拟地址<code>0x10001000</code>(一个块4KB)，以此类推。<code>fs/bc.c</code>中的<code>diskaddr</code>函数实现了从 disk block numbers到虚拟地址的转换(以及一些完整性(sanity)检查)。</p>
<p>由于我们的文件系统environment具有自己的虚拟地址空间，而与系统中其他environment的虚拟地址空间无关，并且文件系统environment唯一需要做的就是实现文件访问，因此我们以这种方式保留大多数文件系统environment的地址空间。 由于现代磁盘大于3GB，因此在32位计算机上执行真实文件系统会很尴尬。 在具有64位地址空间的机器上，这种buffer cache管理方法仍然是合理的。</p>
<p>当然，将整个磁盘读取到内存中要花很长时间，所以我们以请求分页(demand paging)的形式实现，其中我们只在磁盘映射区域分配页和从磁盘读取相应的块来响应一个在这个地区发生的页面错误。</p>
<p><code>ide_read()</code>的单位是扇区，不是磁盘块，通过<code>outb</code>指令设置读取的扇区数，通过<code>insl</code>指令读取磁盘数据到对应的虚拟地址<code>addr</code>处。<code>bc_pgfault</code>中分配了一页物理页，然后从磁盘中读取出错的addr那一块数据(8个扇区）到分配的物理页中，然后清除分配页的dirty标记，最后调用<code>block_is_free</code>检查对应磁盘块确保磁盘块已经分配。注意这里检查磁盘块是否已经分配要在最后检查，是因为<code>bitmap</code>的值是在<code>fs_init</code>时指定的为<code>diskaddr(2)</code>，即<code>0x10002000</code>，在准备读取第二个磁盘块发生页错误进入<code>bgfault</code>时，此时<code>bitmap</code>对应块还没有从磁盘读取并映射好，所以要在最后检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ide_read</span><span class="params">(<span class="type">uint32_t</span> secno, <span class="type">void</span> *dst, <span class="type">size_t</span> nsecs)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">        assert(nsecs &lt;= <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">        ide_wait_ready(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        outb(<span class="number">0x1F2</span>, nsecs);</span><br><span class="line">        outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">        outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        outb(<span class="number">0x1F6</span>, <span class="number">0xE0</span> | ((diskno&amp;<span class="number">1</span>)&lt;&lt;<span class="number">4</span>) | ((secno&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0x0F</span>));</span><br><span class="line">        outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);      <span class="comment">// CMD 0x20 means read sector</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; nsecs &gt; <span class="number">0</span>; nsecs--, dst += SECTSIZE) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((r = ide_wait_ready(<span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>fs/fs.c</code>中的<code>fs_init</code>函数是如何使用<code>block cache</code>的一个主要示例。在初始化块缓存之后，它简单将指向块缓存的指针存储到<code>super</code>全局变量中的磁盘映射区域。在这之后，我们可以简单地从<code>super structure</code>中读取，就像它们在内存中一样，并且我们的页面错误处理程序将根据需要从磁盘中读取它们。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the file system</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> File) == <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find a JOS disk.  Use the second IDE disk (number 1) if available.</span></span><br><span class="line">        <span class="keyword">if</span> (ide_probe_disk1())</span><br><span class="line">                ide_set_disk(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                ide_set_disk(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bc_init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set &quot;super&quot; to point to the super block.</span></span><br><span class="line">        super = diskaddr(<span class="number">1</span>);</span><br><span class="line">        check_super();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Exercise 2. 在<code>fs/bc.c</code>中实现<code>bc_pgfault</code>和<code>flush_block</code>函数。<code>bc_pgfault</code>是一个页面错误处理程序，就像您在上一个lab中为copy-on-write fork的写的页面处理程序一样，不同之处在于<code>bc_pgfault</code>的工作是响应页面错误从磁盘加载页面。 编写此代码时，请记住，<code>addr</code>可能未与<code>block</code>对齐，并且<code>ide_read</code>在扇区而不是<code>block</code>中操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fault any disk block that is read in to memory by</span></span><br><span class="line"><span class="comment">// loading it from disk.只说从disk又不说disk哪个扇区</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bc_pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *addr = (<span class="type">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="type">uint32_t</span> blockno = ((<span class="type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the fault was within the block cache region</span></span><br><span class="line">	<span class="keyword">if</span> (addr &lt; (<span class="type">void</span>*)DISKMAP || addr &gt;= (<span class="type">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">		panic(<span class="string">&quot;page fault in FS: eip %08x, va %08x, err %04x&quot;</span>,</span><br><span class="line">		      utf-&gt;utf_eip, addr, utf-&gt;utf_err);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sanity check the block number.</span></span><br><span class="line">	<span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">		panic(<span class="string">&quot;reading non-existent block %08x\n&quot;</span>, blockno);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page in the disk map region, read the contents</span></span><br><span class="line">	<span class="comment">// of the block from the disk into that page.</span></span><br><span class="line">	<span class="comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span></span><br><span class="line">	<span class="comment">// the disk.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 5: you code here:</span></span><br><span class="line">	addr = (<span class="type">void</span> *)ROUNDDOWN(addr, BLKSIZE);</span><br><span class="line">	<span class="keyword">if</span>((r=sys_page_alloc(<span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;in bc_pgfault,out of memory: %e&quot;</span>, r);</span><br><span class="line">	<span class="keyword">if</span>((r=ide_read(blockno*<span class="number">8</span>, addr, BLKSECTS))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;in bc_pgfault, ide_read: %e&quot;</span>, r);</span><br><span class="line">	<span class="comment">// Clear the dirty bit for the disk block page since we just read the</span></span><br><span class="line">	<span class="comment">// block from disk</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the block we read was allocated. (exercise for</span></span><br><span class="line">	<span class="comment">// the reader: why do we do this *after* reading the block</span></span><br><span class="line">	<span class="comment">// in?)</span></span><br><span class="line">	<span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">		panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>flush_block()</code>函数用于在写入磁盘数据到块缓存后，调用<code>ide_write()</code>写入块缓存数据到磁盘中。写入完成后，也要通过<code>sys_page_map()</code>清除块缓存的<code>dirty</code>标记(每次写入物理页的时候，处理器会自动标记该页为<code>dirty</code>，即设置<code>PTE_D</code>标记)。注意，在<code>flush_block()</code>中，如果该地址并没有映射或者并没有<code>dirty</code>，则不需要做任何事情。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flush the contents of the block containing VA out to disk if</span></span><br><span class="line"><span class="comment">// necessary, then clear the PTE_D bit using sys_page_map.</span></span><br><span class="line"><span class="comment">// If the block is not in the block cache or is not dirty, does</span></span><br><span class="line"><span class="comment">// nothing.</span></span><br><span class="line"><span class="comment">// Hint: Use va_is_mapped, va_is_dirty, and ide_write.</span></span><br><span class="line"><span class="comment">// Hint: Use the PTE_SYSCALL constant when calling sys_page_map.</span></span><br><span class="line"><span class="comment">// Hint: Don&#x27;t forget to round addr down.</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">flush_block</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> blockno = ((<span class="type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &lt; (<span class="type">void</span>*)DISKMAP || addr &gt;= (<span class="type">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">        panic(<span class="string">&quot;flush_block of bad va %08x&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    addr = ROUNDDOWN(addr, BLKSIZE);</span><br><span class="line">    <span class="keyword">if</span> (va_is_mapped(addr) &amp;&amp; va_is_dirty(addr)) &#123;</span><br><span class="line">        ide_write(blockno*BLKSECTS, addr, BLKSECTS);</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)]&amp;PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;in flush_block, sys_page_map: %e&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bc.c</code>中的<code>bc_init</code>用于完成块缓存初始化，它完成下面几件事：</p>
<ol>
<li>设置页错误处理函数为<code>bc_pgfault</code>。</li>
<li>调用check_bc()。</li>
<li>读取磁盘块1的数据到函数局部变量super对应的地址中。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Super</span> <span class="title">super</span>;</span></span><br><span class="line">        set_pgfault_handler(bc_pgfault);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache the super block by reading it once</span></span><br><span class="line">        memmove(&amp;super, diskaddr(<span class="number">1</span>), <span class="keyword">sizeof</span> super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="块位图"><a href="#块位图" class="headerlink" title="块位图"></a>块位图</h3><p>在<code>fs_init</code>设置<code>bitmap</code>指针后，可以认为<code>bitmap</code>就是一个位数组，每个块占据一位。可以通过<code>block_is_free</code>检查块位图中的对应块是否空闲，如果为1表示空闲，为0已经使用。JOS中第0，1，2块分别给<code>bootloader</code>，<code>superblock</code>以及<code>bitmap</code>使用了。此外，因为在文件系统中加入了<code>user</code>目录和<code>fs</code>目录的文件，导致JOS文件系统一共用掉了0-110这111个文件块，下一个空闲文件块从111开始。</p>
<p>使用<code>free_block</code>作为模型在<code>fs/fs.c</code>中实现<code>alloc_block</code>。它应该在位图中找到一个空闲磁盘块，标记它该磁盘块已被使用，并返回该磁盘块号。当您分配一个块时，您应该立即使用<code>flush_block</code>将更改后的位图块刷新到磁盘，以保持文件系统的一致性。</p>
<p>使用位图标记一个块是否被使用过。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark a block free in the bitmap</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">free_block</span><span class="params">(<span class="type">uint32_t</span> blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Blockno zero is the null pointer of block numbers.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0 块启动块</span></span><br><span class="line">	<span class="keyword">if</span> (blockno == <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;attempt to free zero block&quot;</span>);</span><br><span class="line">	bitmap[blockno/<span class="number">32</span>] |= <span class="number">1</span>&lt;&lt;(blockno%<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Search the bitmap for a free block and allocate it.  When you</span></span><br><span class="line"><span class="comment">// allocate a block, immediately flush the changed bitmap block</span></span><br><span class="line"><span class="comment">// to disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return block number allocated on success,</span></span><br><span class="line"><span class="comment">// -E_NO_DISK if we are out of blocks.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The bitmap consists of one or more blocks.  A single bitmap block</span></span><br><span class="line">	<span class="comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span></span><br><span class="line">	<span class="comment">// super-&gt;s_nblocks blocks in the disk altogether.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i &lt; super-&gt;s_nblocks; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (block_is_free(i)) &#123;</span><br><span class="line">			bitmap[i/<span class="number">32</span>] &amp;=  ~(<span class="number">1</span>&lt;&lt;(i%<span class="number">32</span>));</span><br><span class="line">            <span class="comment">// 或者</span></span><br><span class="line">            <span class="comment">// bitmap[blockno/32] ^= 1&lt;&lt;(blockno%32);</span></span><br><span class="line">			flush_block(&amp;bitmap[i/<span class="number">32</span>]);</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// panic(&quot;alloc_block not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>在<code>fs/fs.c</code>中有很多文件操作相关的函数，这里的主要几个结构体要说明下：</p>
<ul>
<li><code>struct File</code>用于存储文件元数据，前面提到过。</li>
<li><code>struct Fd</code>用于文件模拟层，类似文件描述符，如文件ID，文件打开模式，文件偏移都存储在Fd中。一个进程同时最多打开 MAXFD(32) 个文件。</li>
</ul>
<p>文件系统进程还维护了一个打开文件的描述符表，即<code>opentab</code>数组，数组元素为<code>struct OpenFile</code>。<code>OpenFile</code>结构体用于存储打开文件信息，包括文件<code>ID</code>，<code>struct File</code>以及<code>struct Fd</code>。JOS同时打开的文件数一共为 MAXOPEN(1024) 个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> &#123;</span>                                                              </span><br><span class="line">    <span class="type">uint32_t</span> o_fileid;  <span class="comment">// file id                                             </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>    <span class="comment">// mapped descriptor for open file                 </span></span><br><span class="line">    <span class="type">int</span> o_mode;     <span class="comment">// open mode                                               </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">o_fd</span>;</span>    <span class="comment">// Fd page                                             </span></span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd_dev_id;</span><br><span class="line">    <span class="type">off_t</span> fd_offset;</span><br><span class="line">    <span class="type">int</span> fd_omode;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">// File server files</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">FdFile</span> <span class="title">fd_file</span>;</span></span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>文件操作函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_block_walk(<span class="keyword">struct</span> File *f, <span class="type">uint32_t</span> filebno, <span class="type">uint32_t</span> **ppdiskbno, <span class="type">bool</span> alloc)</span><br></pre></td></tr></table></figure></p>
<p>这个函数是查找文件第<code>filebno</code>块的数据块的地址，查到的地址存储在<code>ppdiskbno</code>中。注意这里要检查间接块，如果alloc为1且寻址的块号<code>&gt;=NDIRECT</code>，而间接块没有分配的话需要分配一个间接块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_get_block(<span class="keyword">struct</span> File *f, <span class="type">uint32_t</span> filebno, <span class="type">char</span> **blk)</span><br></pre></td></tr></table></figure>
<p>查找文件第<code>filebno</code>块的块地址，并将块地址在虚拟内存中映射的地址存储在<code>blk</code>中(即将<code>diskaddr(blockno)</code>存到blk中)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir_lookup(<span class="keyword">struct</span> File *dir, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> File **file)</span><br></pre></td></tr></table></figure>
<p>在目录<code>dir</code>中查找名为<code>name</code>的文件，如果找到了设置<code>*file</code>为找到的文件。因为目录的数据块存储的是<code>struct File</code>列表，可以据此来查找文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_open(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> File **pf)</span><br></pre></td></tr></table></figure>
<p>打开文件，设置<code>*pf</code>为查找到的文件指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_create(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> File *pf)</span><br></pre></td></tr></table></figure>
<p>创建路径/文件，在pf存储创建好的文件指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_read(<span class="keyword">struct</span> File *f, <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span><br></pre></td></tr></table></figure>
<p>从文件的<code>offset</code>处开始读取<code>count</code>个字节到<code>buf</code>中，返回实际读取的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_write(<span class="keyword">struct</span> File *f, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span><br></pre></td></tr></table></figure>
<p>从文件<code>offset</code>处开始写入<code>buf</code>中的<code>count</code>字节，返回实际写入的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_truncate_blocks(<span class="keyword">struct</span> File *f, <span class="type">off_t</span> newsize);</span><br></pre></td></tr></table></figure>
<p>将文件设置为缩小后的新大小，清空那些被释放的物理块。</p>
<p>Exercise 4：实现<code>file_block_walk</code>函数和<code>file_get_block</code>函数。<br>　　<br>回答：<code>file_block_walk</code>函数寻找一个文件结构<code>f</code>中的第<code>fileno</code>个块指向的磁盘块编号放入<code>ppdiskbno</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File *f, <span class="type">uint32_t</span> filebno, <span class="type">uint32_t</span> **ppdiskbno, <span class="type">bool</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filebno &gt;= NDIRECT + NINDIRECT)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ppdiskbno)</span><br><span class="line">            *ppdiskbno = f-&gt;f_direct + filebno;</span><br><span class="line">         <span class="comment">//把f-&gt;f_direct第filebno个槽的地址给它</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!alloc &amp;&amp; !f-&gt;f_indirect)</span><br><span class="line">        <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">    <span class="keyword">if</span> (!f-&gt;f_indirect) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">        f-&gt;f_indirect = r;</span><br><span class="line">        <span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">        flush_block(diskaddr(r));</span><br><span class="line">        <span class="comment">//每次对磁盘映射区域的块修改后都应该刷新回磁盘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//捋一下，现在我们要的是存着f第filebno块块号的那个槽的地址</span></span><br><span class="line">	<span class="comment">//即f-&gt;f_indirect与f-&gt;f_direct都是存着块号，而*ppdiskbno要的是存着块号的那个槽的地址</span></span><br><span class="line">	   </span><br><span class="line">    <span class="keyword">if</span> (ppdiskbno)</span><br><span class="line">        *ppdiskbno = (<span class="type">uint32_t</span>*)diskaddr(f-&gt;f_indirect) + filebno - NDIRECT;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>file_get_block</code>函数先调用<code>file_walk_block</code>函数找到文件中的目标块，然后将其转换为地址空间中的地址赋值给<code>blk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File *f, <span class="type">uint32_t</span> filebno, <span class="type">char</span> **blk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">uint32_t</span> *ppdiskbno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ppdiskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="comment">//ppdiskbno是f的第filebno块的块号所在的槽的地址</span></span><br><span class="line">	<span class="comment">//blk要的是这个块映射到内存里的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*ppdiskbno == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//就算是直接块也是有可能还未分配</span></span><br><span class="line">        <span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">        *ppdiskbno = r;</span><br><span class="line">        <span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">        flush_block(diskaddr(r));</span><br><span class="line">        <span class="comment">//每次对磁盘映射区域的块修改后都应该刷新回磁盘</span></span><br><span class="line">    &#125;</span><br><span class="line">    *blk = diskaddr(*ppdiskbno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h3><p>既然我们已经在文件系统environment本身中拥有了必要的功能，那么我们必须让希望使用文件系统的其他environment也可以访问它。由于其他environment不能直接调用文件系统environment中的函数，所以我们将通过构建在JOS IPC机制之上的remote procedure call(远程过程调用)或者RPC、抽象来公开对文件系统环境的访问。从图形上看，下面是其他environment对 the file system server (比如read)的调用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	  Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib/fd.c)  |   |   (fs/fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +---------&gt;---------+</span><br></pre></td></tr></table></figure></p>
<p>在虚线下的部分是普通进程如何发送一个读请求到文件系统服务进程的机制。首先<code>read</code>操作文件描述符，分发给合适的设备读函数<code>devfile_read</code>。<code>devfile_read</code>函数实现读取磁盘文件，作为客户端文件操作函数。然后建立请求结构的参数，调用<code>fsipc</code>函数来发送IPC请求并解析返回的结果。</p>
<p>文件系统服务端的代码在<code>fs/serv.c</code>中，服务进程在serve函数中循环，循环等待直到收到1个IPC请求。然后分发给合适的处理函数，最后通过IPC发回结果。对于读请求，服务端会分发给<code>serve_read</code>函数</p>
<p>在JOS实现的IPC机制中，允许进程发送1个32位数和1个页。为了实现发送1个请求从客户端到服务端，我们使用32位数来表示请求类型，存储参数在联合<code>Fsipc</code>位于共享页中。在客户端我们一直共享<code>fsipcbuf</code>所在页，在服务端我们映射请求页到<code>fsreq</code>地址(0x0ffff000)。</p>
<p>服务端也会通过IPC发送结果。我们使用32位数作为函数的返回码。<code>FSREQ_READ</code>和<code>FSREQ_STAT</code>函数也会返回数据，它们将数据写入共享页返回给客户端。不需要在响应 IPC 中发送此页面，因为客户端首先与文件系统服务器共享它。 此外，在其响应中，<code>FSREQ_OPEN</code>与客户端共享一个新的“Fd页面”。 我们将很快返回到文件描述符页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Fsipc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">        <span class="type">int</span> req_omode;</span><br><span class="line">    &#125; open;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> req_fileid;</span><br><span class="line">        <span class="type">off_t</span> req_size;</span><br><span class="line">    &#125; set_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> req_fileid;</span><br><span class="line">        <span class="type">size_t</span> req_n;</span><br><span class="line">    &#125; read;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> ret_buf[PGSIZE];</span><br><span class="line">    &#125; readRet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_write</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> req_fileid;</span><br><span class="line">        <span class="type">size_t</span> req_n;</span><br><span class="line">        <span class="type">char</span> req_buf[PGSIZE - (<span class="keyword">sizeof</span>(<span class="type">int</span>) + <span class="keyword">sizeof</span>(<span class="type">size_t</span>))];</span><br><span class="line">    &#125; write;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_stat</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> req_fileid;</span><br><span class="line">    &#125; stat;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_stat</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> ret_name[MAXNAMELEN];</span><br><span class="line">        <span class="type">off_t</span> ret_size;</span><br><span class="line">        <span class="type">int</span> ret_isdir;</span><br><span class="line">    &#125; statRet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_flush</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> req_fileid;</span><br><span class="line">    &#125; flush;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">    &#125; remove;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure Fsipc is one page</span></span><br><span class="line">    <span class="type">char</span> _pad[PGSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里需要了解一下<code>union Fsipc</code>，文件系统中客户端和服务端通过IPC进行通信，通信的数据格式就是<code>union Fsipc</code>，它里面的每一个成员对应一种文件系统的操作请求。每次客户端发来请求，都会将参数放入一个<code>union Fsipc</code>映射的物理页到服务端。同时服务端还会将处理后的结果放入到<code>Fsipc</code>内，传递给客户端。文件服务端进行的地址空间布局如下：<br><img src="/img/20211128114305.png" alt=""></p>
<p><code>OpenFile</code>结构是服务端进程维护的一个映射，它将一个真实文件<code>struct File</code>和用户客户端打开的文件描述符<code>struct Fd</code>对应到一起。每个被打开文件对应的<code>struct Fd</code>都被映射到<code>FILEEVA(0xd0000000)</code>往上的1个物理页，服务端和打开这个文件的客户端进程共享这个物理页。客户端进程和文件系统服务端通信时使用<code>0_fileid</code>来指定要操作的文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> o_fileid;      <span class="comment">// file id</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>    <span class="comment">// mapped descriptor for open file</span></span><br><span class="line">        <span class="type">int</span> o_mode;             <span class="comment">// open mode</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">o_fd</span>;</span>        <span class="comment">// Fd page</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>文件系统默认最大同时可以打开的文件个数为1024，所以有1024个<code>strcut Openfile</code>，对应着服务端进程地址空间0xd0000000往上的1024个物理页，用于映射这些对应的<code>struct Fd</code>。</p>
<p><code>struct Fd</code>是1个抽象层，JOS和Linux一样，所有的IO都是文件，所以用户看到的都是<code>Fd</code>代表的文件。但是<code>Fd</code>会记录其对应的具体对象，比如真实文件、Socket和管道等等。现在只用文件，所以union中只有1个<code>FdFile</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd_dev_id;</span><br><span class="line">    <span class="type">off_t</span> fd_offset;</span><br><span class="line">    <span class="type">int</span> fd_omode;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">// File server files</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">FdFile</span> <span class="title">fd_file</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Exercise 5.在<code>fs/servlet.c</code>中实现<code>serve_read</code>。<code>serve_read</code>的繁重工作将由<code>fs/fs.c</code>中已经实现的<code>file_read</code>来完成(反过来，它只是对<code>file_get_block</code>的一系列调用)。<code>serve_read</code>只需要提供用于文件读取的RPC接口。查看<code>serve_set_size</code>中的注释和代码，了解应该如何构造<code>server</code>函数。</p>
<p>做这个得弄清楚这些概念:</p>
<ul>
<li><code>regular</code>进程访问文件的整个流程。</li>
<li>在IPC通信过程中，<code>fsipcbuf</code>(客户端)与<code>fsreq</code>(服务端)共享页面。</li>
<li>保存着open file基本信息的<code>Fd page</code>页面(在内存空间0xD0000000以上)</li>
<li>服务端的私有结构体<code>OpenFile</code></li>
<li>设备结构体<code>dev</code>，设备有三种，devfile、devpipe、devcons</li>
<li><code>OpenFile-&gt;o_fileid</code>跟<code>OpenFile-&gt;o_fd-&gt;fd_file.id</code>以及<code>Fsipc-&gt;read-&gt;req_fileid</code>的关系!</li>
</ul>
<p>在<code>devfile_read()</code>里，<code>fsipcbuf.read.req_fileid = fd-&gt;fd_file.id;</code>这是客户端根据在0xD0000000以上的第<code>fdnum</code>个<code>fd page</code>的<code>fd-&gt;fd_file.id</code>告诉服务器端要读的是id为这个的文件。</p>
<p>在<code>serve_open()</code>里，<code>o-&gt;o_fd-&gt;fd_file.id = o-&gt;o_fileid;</code>这是服务器端将open file与它的Fd page对应起来。</p>
<p>首先来看一下整个read的流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inc/fd.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd_dev_id;</span><br><span class="line">	<span class="type">off_t</span> fd_offset;</span><br><span class="line">	<span class="type">int</span> fd_omode;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">// File server files</span></span><br><span class="line">		<span class="comment">// 这应该就是目标文件id，在客户端赋值给了fsipcbuf.read.req_fileid</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">FdFile</span> <span class="title">fd_file</span>;</span> <span class="comment">//struct FdFile &#123;int id; &#125;;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fs/serv.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> &#123;</span> </span><br><span class="line">    <span class="comment">//This memory is kept private to the file server.</span></span><br><span class="line">	<span class="type">uint32_t</span> o_fileid;	<span class="comment">// file id。 The client uses file IDs to communicate with the server.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>	<span class="comment">// mapped descriptor for open file应该是打开的那个文件的file pointer</span></span><br><span class="line">	<span class="type">int</span> o_mode;		<span class="comment">// open mode</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">o_fd</span>;</span>	<span class="comment">// Fd page是一个专门记录着这个open file的基本信息的页面</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inc/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> f_name[MAXNAMELEN];	<span class="comment">// filename</span></span><br><span class="line">	<span class="type">off_t</span> f_size;			<span class="comment">// file size in bytes</span></span><br><span class="line">	<span class="type">uint32_t</span> f_type;		<span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block pointers.</span></span><br><span class="line">	<span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">	<span class="comment">// 这里存的是块号还是块的地址？</span></span><br><span class="line">	<span class="type">uint32_t</span> f_direct[NDIRECT];	<span class="comment">// direct blocks</span></span><br><span class="line">	<span class="type">uint32_t</span> f_indirect;		<span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pad out to 256 bytes; must do arithmetic in case we&#x27;re compiling</span></span><br><span class="line">	<span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line">	<span class="comment">// 扩展到256字节;必须做算术，以防我们在64位机器上编译fsformat。</span></span><br><span class="line">	<span class="type">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));	<span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure></p>
<p><code>lib/fd.c/read()</code>根据<code>fdnum</code>在内存空间0xD0000000以上找到一个<code>struct Fd</code>页面命名为<code>fd</code>，页面内保存着一个open file的基本信息。然后根据<code>fd</code>内的<code>fd_dev_id</code>找到对应设备<code>dev</code>，很明显这里是<code>devfile</code>，然后调用<code>(*devfile-&gt;dev_read)(fd, buf, n)</code>。该函数返回读到的字节总数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">	    || (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_WRONLY) &#123;</span><br><span class="line">		cprintf(<span class="string">&quot;[%08x] read %d -- bad mode\n&quot;</span>, thisenv-&gt;env_id, fdnum);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;dev_read)</span><br><span class="line">		<span class="keyword">return</span> -E_NOT_SUPP;</span><br><span class="line">	<span class="keyword">return</span> (*dev-&gt;dev_read)(fd, buf, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>lib/file.c/devfile_read()</code>通过IPC共享的页面上的<code>union Fsipc</code>中存储请求的参数。在客户端，我们总是在<code>fsipcbuf</code>共享页面。设置好<code>fsipcbuf</code>的参数，调用<code>fsipc</code>去向服务器端发送<code>read</code>请求。请求成功后结果也是保存在共享页面<code>fsipcbuf</code>中，然后读到指定的<code>buf</code>就行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">devfile_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Make an FSREQ_READ request to the file system server after</span></span><br><span class="line">	<span class="comment">// filling fsipcbuf.read with the request arguments.  The</span></span><br><span class="line">	<span class="comment">// bytes read will be written back to fsipcbuf by the file</span></span><br><span class="line">	<span class="comment">// system server.</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	fsipcbuf.read.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">    <span class="comment">//这个id就是指的当前位置？current position？</span></span><br><span class="line">	fsipcbuf.read.req_n = n;</span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc(FSREQ_READ, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	assert(r &lt;= n);</span><br><span class="line">	assert(r &lt;= PGSIZE);</span><br><span class="line">	memmove(buf, fsipcbuf.readRet.ret_buf, r);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>lib/file.c/fsipc()</code>这个函数就是负责跟文件系统<code>server</code>进程间通信的。发送请求并接受结果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fsipc</span><span class="params">(<span class="type">unsigned</span> type, <span class="type">void</span> *dstva)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">envid_t</span> fsenv;</span><br><span class="line">	<span class="keyword">if</span> (fsenv == <span class="number">0</span>)</span><br><span class="line">		fsenv = ipc_find_env(ENV_TYPE_FS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(fsipcbuf) == PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (debug)</span><br><span class="line">		cprintf(<span class="string">&quot;[%08x] fsipc %d %08x\n&quot;</span>, thisenv-&gt;env_id, type, *(<span class="type">uint32_t</span> *)&amp;fsipcbuf);</span><br><span class="line"></span><br><span class="line">	ipc_send(fsenv, type, &amp;fsipcbuf, PTE_P | PTE_W | PTE_U);</span><br><span class="line">	<span class="keyword">return</span> ipc_recv(<span class="literal">NULL</span>, dstva, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>fs/serv.c/serve()</code>中<code>ipc_recv</code>的返回值是32位字<code>env_ipc_value</code>，即<code>fsipc</code>里<code>ipc_send</code>过来的<code>type</code>，根据这个<code>type</code>判断进入哪个处理函数，这里很明显<code>type==FSREQ_READ</code>。</p>
<ol>
<li>从IPC接受1个请求类型<code>req</code>以及数据页<code>fsreq</code></li>
<li>然后根据<code>req</code>来执行相应的服务端处理函数</li>
<li>将相应服务端函数的执行结果(如果产生了数据也则有pg)通过IPC发送回调用进程</li>
<li>将映射好的物理页<code>fsreq</code>取消映射</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> req, whom;</span><br><span class="line">	<span class="type">int</span> perm, r;</span><br><span class="line">	<span class="type">void</span> *pg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		perm = <span class="number">0</span>;</span><br><span class="line">		req = ipc_recv((<span class="type">int32_t</span> *) &amp;whom, fsreq, &amp;perm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// All requests must contain an argument page</span></span><br><span class="line">		<span class="keyword">if</span> (!(perm &amp; PTE_P)) &#123;</span><br><span class="line">			cprintf(<span class="string">&quot;Invalid request from %08x: no argument page\n&quot;</span>,</span><br><span class="line">				whom);</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// just leave it hanging...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pg = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (req == FSREQ_OPEN) &#123;</span><br><span class="line">			r = serve_open(whom, (<span class="keyword">struct</span> Fsreq_open*)fsreq, &amp;pg, &amp;perm);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req &lt; ARRAY_SIZE(handlers) &amp;&amp; handlers[req]) &#123;</span><br><span class="line">			r = handlers[req](whom, fsreq);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cprintf(<span class="string">&quot;Invalid request code %d from %08x\n&quot;</span>, req, whom);</span><br><span class="line">			r = -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		ipc_send(whom, r, pg, perm);</span><br><span class="line">		sys_page_unmap(<span class="number">0</span>, fsreq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端函数定义在handler数组，通过请求号进行调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fshandler)</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">union</span> Fsipc *req)</span>;</span><br><span class="line"></span><br><span class="line">fshandler handlers[] = &#123;</span><br><span class="line">    <span class="comment">// Open is handled specially because it passes pages</span></span><br><span class="line">    <span class="comment">/* [FSREQ_OPEN] =       (fshandler)serve_open, */</span></span><br><span class="line">    [FSREQ_READ] =          serve_read,</span><br><span class="line">    [FSREQ_STAT] =          serve_stat,</span><br><span class="line">    [FSREQ_FLUSH] =         (fshandler)serve_flush,</span><br><span class="line">    [FSREQ_WRITE] =         (fshandler)serve_write,</span><br><span class="line">    [FSREQ_SET_SIZE] =      (fshandler)serve_set_size,</span><br><span class="line">    [FSREQ_SYNC] =          serve_sync</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NHANDLERS (sizeof(handlers)/sizeof(handlers[0]))</span></span><br></pre></td></tr></table></figure></p>
<p>这个结构体定义了一些函数指针，做题的时候需要注意。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">        .dev_id =       <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">        .dev_name =     <span class="string">&quot;file&quot;</span>,</span><br><span class="line">        .dev_read =     devfile_read,</span><br><span class="line">        .dev_close =    devfile_flush,</span><br><span class="line">        .dev_stat =     devfile_stat,</span><br><span class="line">        .dev_write =    devfile_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于读文件请求，调用<code>serve_read</code>函数来处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">serve_read</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> =</span> &amp;ipc-&gt;read;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> =</span> &amp;ipc-&gt;readRet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;serve_read %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">        <span class="type">int</span> r, req_n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        req_n = req-&gt;req_n &gt; PGSIZE ? PGSIZE : req-&gt;req_n;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_read(o-&gt;o_file, ret-&gt;ret_buf, req_n, o-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先从<code>Fsipc</code>中获取读请求的结构体，然后在<code>openfile</code>中查找<code>fileid</code>对应的<code>Openfile</code>结构体，紧接着从<code>openfile</code>长相的<code>o_file</code>中读取内容到保存返回结果的<code>ret_buf</code>中，并移动文件偏移指针。</p>
<p>然后我们可以看一下用户进程发送读取请求的函数<code>devfile_read</code>，主要操作是封装<code>Fsipc</code>设置请求类型为<code>FSREQ_READ</code>，在接受到返回后，将返回结果拷贝到自己的<code>buf</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">devfile_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">        fsipcbuf.read.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">        fsipcbuf.read.req_n = n;</span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc(FSREQ_READ, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        assert(r &lt;= n);</span><br><span class="line">        assert(r &lt;= PGSIZE);</span><br><span class="line">        memmove(buf, fsipcbuf.readRet.ret_buf, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Exercise 6.在<code>fs/server.c</code>中实现<code>serve_write</code>，在<code>lib/file.c</code>中实现<code>devfile_write</code>。实现与read请求类似。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/serv.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">serve_write</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">struct</span> Fsreq_write *req)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;serve_write %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">        <span class="type">int</span> r, req_n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        req_n = req-&gt;req_n &gt; PGSIZE ? PGSIZE : req-&gt;req_n;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_write(o-&gt;o_file, req-&gt;req_buf, req_n, o-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/file.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">devfile_write</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="keyword">sizeof</span>(fsipcbuf.write.req_buf))</span><br><span class="line">                n = <span class="keyword">sizeof</span>(fsipcbuf.write.req_buf);</span><br><span class="line">        fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">        fsipcbuf.write.req_n = n;</span><br><span class="line">        memmove(fsipcbuf.write.req_buf, buf, n);</span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc(FSREQ_WRITE, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spawning-Processes-衍生程序，派生程序"><a href="#Spawning-Processes-衍生程序，派生程序" class="headerlink" title="Spawning Processes(衍生程序，派生程序)"></a>Spawning Processes(衍生程序，派生程序)</h3><p>我们已经给出了<code>spawn</code>的代码(参见<code>lib/spawn.c</code>)，它创建一个新环境，从文件系统加载一个程序映像到其中，然后启动运行这个程序的子环境。然后父进程继续独立于子进程运行。<code>spawn</code>函数的作用类似于UNIX中的fork，然后在子进程中立即执行exec。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spawn a child process from a program image loaded from the file system.</span></span><br><span class="line"><span class="comment">// prog: the pathname of the program to run.</span></span><br><span class="line"><span class="comment">// argv: pointer to null-terminated array of pointers to strings,</span></span><br><span class="line"><span class="comment">//       which will be passed to the child as its command-line arguments.</span></span><br><span class="line"><span class="comment">// Returns child envid on success, &lt; 0 on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">spawn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *prog, <span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> elf_buf[<span class="number">512</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">child_tf</span>;</span></span><br><span class="line">    <span class="type">envid_t</span> child;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd, i, r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>;</span></span><br><span class="line">    <span class="type">int</span> perm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This code follows this procedure:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Open the program file.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Read the ELF header, as you have before, and sanity check its</span></span><br><span class="line">    <span class="comment">//     magic number.  (Check out your load_icode!)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Use sys_exofork() to create a new environment.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Set child_tf to an initial struct Trapframe for the child.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Call the init_stack() function above to set up</span></span><br><span class="line">    <span class="comment">//     the initial stack page for the child environment.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Map all of the program&#x27;s segments that are of p_type</span></span><br><span class="line">    <span class="comment">//     ELF_PROG_LOAD into the new environment&#x27;s address space.</span></span><br><span class="line">    <span class="comment">//     Use the p_flags field in the Proghdr for each segment</span></span><br><span class="line">    <span class="comment">//     to determine how to map the segment:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      * If the ELF flags do not include ELF_PROG_FLAG_WRITE,</span></span><br><span class="line">    <span class="comment">//    then the segment contains text and read-only data.</span></span><br><span class="line">    <span class="comment">//    Use read_map() to read the contents of this segment,</span></span><br><span class="line">    <span class="comment">//    and map the pages it returns directly into the child</span></span><br><span class="line">    <span class="comment">//    so that multiple instances of the same program</span></span><br><span class="line">    <span class="comment">//    will share the same copy of the program text.</span></span><br><span class="line">    <span class="comment">//    Be sure to map the program text read-only in the child.</span></span><br><span class="line">    <span class="comment">//    Read_map is like read but returns a pointer to the data in</span></span><br><span class="line">    <span class="comment">//    *blk rather than copying the data into another buffer.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      * If the ELF segment flags DO include ELF_PROG_FLAG_WRITE,</span></span><br><span class="line">    <span class="comment">//    then the segment contains read/write data and bss.</span></span><br><span class="line">    <span class="comment">//    As with load_icode() in Lab 3, such an ELF segment</span></span><br><span class="line">    <span class="comment">//    occupies p_memsz bytes in memory, but only the FIRST</span></span><br><span class="line">    <span class="comment">//    p_filesz bytes of the segment are actually loaded</span></span><br><span class="line">    <span class="comment">//    from the executable file - you must clear the rest to zero.</span></span><br><span class="line">    <span class="comment">//    For each page to be mapped for a read/write segment,</span></span><br><span class="line">    <span class="comment">//    allocate a page in the parent temporarily at UTEMP,</span></span><br><span class="line">    <span class="comment">//    read() the appropriate portion of the file into that page</span></span><br><span class="line">    <span class="comment">//    and/or use memset() to zero non-loaded portions.</span></span><br><span class="line">    <span class="comment">//    (You can avoid calling memset(), if you like, if</span></span><br><span class="line">    <span class="comment">//    page_alloc() returns zeroed pages already.)</span></span><br><span class="line">    <span class="comment">//    Then insert the page mapping into the child.</span></span><br><span class="line">    <span class="comment">//    Look at init_stack() for inspiration.</span></span><br><span class="line">    <span class="comment">//    Be sure you understand why you can&#x27;t use read_map() here.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//     Note: None of the segment addresses or lengths above</span></span><br><span class="line">    <span class="comment">//     are guaranteed to be page-aligned, so you must deal with</span></span><br><span class="line">    <span class="comment">//     these non-page-aligned values appropriately.</span></span><br><span class="line">    <span class="comment">//     The ELF linker does, however, guarantee that no two segments</span></span><br><span class="line">    <span class="comment">//     will overlap on the same page; and it guarantees that</span></span><br><span class="line">    <span class="comment">//     PGOFF(ph-&gt;p_offset) == PGOFF(ph-&gt;p_va).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Call sys_env_set_trapframe(child, &amp;child_tf) to set up the</span></span><br><span class="line">    <span class="comment">//     correct initial eip and esp values in the child.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Start the child process running with sys_env_set_status().</span></span><br><span class="line">    <span class="keyword">if</span> ((r = open(prog, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    fd = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read elf header</span></span><br><span class="line">    elf = (<span class="keyword">struct</span> Elf*) elf_buf;</span><br><span class="line">    <span class="keyword">if</span> (readn(fd, elf_buf, <span class="keyword">sizeof</span>(elf_buf)) != <span class="keyword">sizeof</span>(elf_buf) || elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        cprintf(<span class="string">&quot;elf magic %08x want %08x\n&quot;</span>, elf-&gt;e_magic, ELF_MAGIC);</span><br><span class="line">        <span class="keyword">return</span> -E_NOT_EXEC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create new child environment</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_exofork()) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    child = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up trap frame, including initial stack.</span></span><br><span class="line">    child_tf = envs[ENVX(child)].env_tf;</span><br><span class="line">    child_tf.tf_eip = elf-&gt;e_entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = init_stack(child, argv, &amp;(child_tf.tf_esp))) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up program segments as defined in ELF header.</span></span><br><span class="line">    ph = (<span class="keyword">struct</span> Proghdr*) (elf_buf + elf-&gt;e_phoff);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elf-&gt;e_phnum; i++, ph++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PROG_LOAD)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        perm = PTE_P | PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PROG_FLAG_WRITE)</span><br><span class="line">            perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((r = map_segment(child, ph-&gt;p_va, ph-&gt;p_memsz, fd, ph-&gt;p_filesz, ph-&gt;p_offset, perm)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy shared library state.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = copy_shared_pages(child)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;copy_shared_pages: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_trapframe(child, &amp;child_tf)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;sys_env_set_trapframe: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_status(child, ENV_RUNNABLE)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;sys_env_set_status: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    sys_env_destroy(child);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们实现了<code>spawn</code>而不是unix风格的exec，因为spawn更容易从用户空间以“exokernel fashion”(一种方式)实现，而不需要内核的特殊帮助。考虑一下要在用户空间中实现exec需要做些什么，并确保您理解为什么这么做更难些。</p>
<p>Exercise 7. 依赖于新的系统调用<code>sys_env_set_trapframe</code>来初始化新创建环境的状态的<code>spawn</code>。在<code>kern/syscall.c</code>中实现<code>sys_env_set_trapframe</code>(不要忘记在<code>syscall()</code>中添加新的系统调用的分派)。</p>
<p><code>sys_env_set_trapframe</code>函数实现简单，主要是用来拷贝父进程的寄存器。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_trapframe</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = envid2env(envid, &amp;e, <span class="literal">true</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    user_mem_assert(e, tf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe), PTE_U);</span><br><span class="line">    e-&gt;env_tf = *tf;</span><br><span class="line">    e-&gt;env_tf.tf_cs |= <span class="number">3</span>;</span><br><span class="line">    e-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h3><p>UNIX文件描述符是一个通用的概念，它还包括pipes, console I/O等。在JOS中，每种设备类型都有一个对应的<code>struct Dev</code>，带有指向为该类型实现的read/write等函数的指针。<code>lib/fd.c</code>在此基础上实现了通用的类unix文件描述符接口。每个<code>struct Fd</code>都指示其设备类型，<code>lib/fd.c</code>中的大多数函数只是简单地将操作分派给适当<code>struct Dev</code>中的函数。</p>
<p><code>lib/fd.c</code>还在每个应用程序环境的地址空间中维护从<code>FDTABLE(0xD0000000)</code>开始的 file descriptor table region。在这个区域每个<code>struct Fd</code>都保留着一个页。在任何给定时间，只有在使用相应的文件描述符时才映射特定的文件描述符表页。每个文件描述符在从FILEDATA开始的区域中都有一个可选的“data page”，设备可以使用这些“data page”。</p>
<p>我们希望跨<code>fork</code>和<code>spawn</code>共享文件描述符状态，但是文件描述符状态保存在用户空间内存中。而且在fork时，内存将被标记为copy-on-write，因此状态将被复制而不是共享。(这意味着环境无法在自己没有打开的文件中进行查找，而且管道也不能跨fork工作)。在<code>spawn</code>时，内存将被留在后面，根本不复制。(实际上，派生的环境一开始没有打开的文件描述符)</p>
<p>我们将更改<code>fork</code>，以确定“library operating system”使用的内存区域应该总是共享的。我们将在页表条目中设置一个未使用的位，而不是在某个地方hard-code(硬编码)一个区域列表(就像我们在<code>fork</code>中使用PTE_COW位一样)。</p>
<p>我们在<code>inc/lib.h</code>中定义了一个新的<code>PTE_SHARE</code>位。这个位是三个PTE位之一，在 Intel and AMD manuals中被标记为“available for software use”。我们将建立这样一个约定:如果页表条目设置了这个位，那么PTE应该在<code>fork</code>和<code>spawn</code>时从父环境直接复制到子环境。注意，这与标记为copy-on-write不同：如第一段所述，我们希望确保共享页面的更新。</p>
<p>Exercise 8：改变<code>duppage</code>函数实现上述变化，如果页表入口有设置<code>PTE_SHARE</code>位，那么直接拷贝映射。类似地，实现<code>copy_shared_pages</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">duppage</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">unsigned</span> pn)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *addr;</span><br><span class="line">    <span class="type">pte_t</span> pte;</span><br><span class="line">    <span class="type">int</span> perm;</span><br><span class="line"></span><br><span class="line">    addr = (<span class="type">void</span> *)((<span class="type">uint32_t</span>)pn * PGSIZE);</span><br><span class="line">    pte = uvpt[pn];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_SHARE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(sys_getenvid(), addr, envid, addr, pte &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            panic(<span class="string">&quot;duppage: page mapping failed %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        perm = PTE_P | PTE_U;</span><br><span class="line">        <span class="keyword">if</span> ((pte &amp; PTE_W) || (pte &amp; PTE_COW))</span><br><span class="line">            perm |= PTE_COW;</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(thisenv-&gt;env_id, addr, envid, addr, perm)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;duppage: page remapping failed %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (perm &amp; PTE_COW) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r = sys_page_map(thisenv-&gt;env_id, addr, thisenv-&gt;env_id, addr, perm)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                panic(<span class="string">&quot;duppage: page remapping failed %e&quot;</span>, r);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>copy_shared_pages</code>应该循环遍历当前进程中的所有页表条目(就像fork所做的那样)，将设置了<code>PTE_SHARE</code>位的任何页映射复制到子进程中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">copy_shared_pages</span><span class="params">(<span class="type">envid_t</span> child)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="type">int</span> r,i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PGNUM(USTACKTOP); i ++)&#123; </span><br><span class="line">	<span class="comment">// uvpd、uvpt应该是个全局数组变量，</span></span><br><span class="line">    <span class="comment">// 但是数组元素对应的pde、pte具体是什么应该取决于lcr3设置的是哪个环境的内存空间</span></span><br><span class="line">		<span class="keyword">if</span>((uvpd[i/<span class="number">1024</span>] &amp; PTE_P) &amp;&amp; (uvpt[i] &amp; PTE_P) &amp;&amp; (uvpt[i] &amp; PTE_SHARE))&#123; </span><br><span class="line">            <span class="comment">//i跟pte一一对应，而i/1024就是该pte所在的页表</span></span><br><span class="line">			<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, PGADDR(i/<span class="number">1024</span>, i%<span class="number">1024</span>, <span class="number">0</span>), child, PGADDR(i/<span class="number">1024</span>, i%<span class="number">1024</span>, <span class="number">0</span>), uvpt[i] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要让shell工作，我们需要一种方法来键入它。QEMU一直在显示我们写入到CGA显示器和串行端口的输出，但到目前为止，我们只在内核监视器中接受输入。在QEMU中，在图形化窗口中键入的输入显示为从键盘到JOS的输入，而在控制台中键入的输入显示为串行端口上的字符。<code>kern/console.c</code>已经包含了自lab 1以来内核监视器一直使用的键盘和串行驱动程序，但是现在您需要将它们附加到系统的其他部分。</p>
<p>Exercise 9. 在你的<code>kern/trap.c</code>，调用<code>kbd_intr</code>处理<code>trap IRQ_OFFSET+IRQ_KBD</code>，调用<code>serial_intr</code>处理<code>trap IRQ_OFFSET+IRQ_SERIAL</code>。</p>
<p>我们在<code>lib/console.c</code>中为您实现了控制台输入/输出文件类型。<code>kbd_intr</code>和<code>serial_intr</code>用最近读取的输入填充缓冲区，而控制台文件类型耗尽缓冲区(控制台文件类型默认用于<code>stdin/stdout</code>，除非用户重定向它们)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/trap.c/trap_dispatch()</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_KBD)&#123;</span><br><span class="line">	kbd_intr();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SERIAL)&#123;</span><br><span class="line">	serial_intr();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>稍微看一下这两个函数。<code>kbd_proc_data()</code>是从键盘读入character就返回，如果没输入就返回-1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kbd_intr</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    cons_intr(kbd_proc_data);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//serial_proc_data()很明显就是从串行端口读一个data</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serial_intr</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (serial_exists)</span><br><span class="line">		cons_intr(serial_proc_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个函数都调用下边这个<code>cons_intr</code>，这个函数就是从键盘读入的一行填充到<code>cons.buf</code>。而<code>cons</code>如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> buf[CONSBUFSIZE];</span><br><span class="line">        <span class="type">uint32_t</span> rpos;</span><br><span class="line">        <span class="type">uint32_t</span> wpos;</span><br><span class="line">&#125; cons;</span><br></pre></td></tr></table></figure></p>
<p>当函数指针所接收到的数据不为-1时，把收到的数据加入到buf中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cons_intr</span><span class="params">(<span class="type">int</span> (*proc)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((c = (*proc)()) != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		cons.buf[cons.wpos++] = c;</span><br><span class="line">		<span class="keyword">if</span> (cons.wpos == CONSBUFSIZE)</span><br><span class="line">			cons.wpos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与<code>kbd_intr</code>有关的是下边这个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get data from the keyboard.  If we finish a character, return it.  Else 0.</span></span><br><span class="line"><span class="comment"> * Return -1 if no data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">kbd_proc_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">uint8_t</span> data;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> shift;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((inb(KBSTATP) &amp; KBS_DIB) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    data = inb(KBDATAP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="number">0xE0</span>) &#123;</span><br><span class="line">        <span class="comment">// E0 escape character</span></span><br><span class="line">        shift |= E0ESC;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">        <span class="comment">// Key released</span></span><br><span class="line">        data = (shift &amp; E0ESC ? data : data &amp; <span class="number">0x7F</span>);</span><br><span class="line">        shift &amp;= ~(shiftcode[data] | E0ESC);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shift &amp; E0ESC) &#123;</span><br><span class="line">        <span class="comment">// Last character was an E0 escape; or with 0x80</span></span><br><span class="line">        data |= <span class="number">0x80</span>;</span><br><span class="line">        shift &amp;= ~E0ESC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shift |= shiftcode[data];</span><br><span class="line">    shift ^= togglecode[data];</span><br><span class="line"></span><br><span class="line">    c = charcode[shift &amp; (CTL | SHIFT)][data];</span><br><span class="line">    <span class="keyword">if</span> (shift &amp; CAPSLOCK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            c += <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            c += <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process special keys</span></span><br><span class="line">    <span class="comment">// Ctrl-Alt-Del: reboot</span></span><br><span class="line">    <span class="keyword">if</span> (!(~shift &amp; (CTL | ALT)) &amp;&amp; c == KEY_DEL) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;Rebooting!\n&quot;</span>);</span><br><span class="line">        outb(<span class="number">0x92</span>, <span class="number">0x3</span>); <span class="comment">// courtesy of Chris Frost</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h2><p>运行<code>make run-icode</code>或者<code>make run-icode-nox</code>。这将运行内核并启动<code>user/icode</code>。<code>icode</code>执行<code>init</code>，它将把控制台设置为文件描述符0和1(标准输入和标准输出)。然后它会<code>spawn sh</code>，也就是<code>shell</code>。你应该能够运行以下命令:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello world | <span class="built_in">cat</span></span><br><span class="line"><span class="built_in">cat</span> lorem |<span class="built_in">cat</span></span><br><span class="line"><span class="built_in">cat</span> lorem |num</span><br><span class="line"><span class="built_in">cat</span> lorem |num |num |num |num |num</span><br><span class="line">lsfd</span><br></pre></td></tr></table></figure></p>
<p>注意，用户库例程cprintf直接打印到控制台，而不使用文件描述符代码。这对于调试非常有用，但是对于piping into other programs却不是很有用。要将输出打印到特定的文件描述符(例如，1，标准输出)，请使用fprintf(1, “…”, …)。 printf(“…”, …)是打印到FD 1的捷径。有关示例，请参见user/lsfd.c。</p>
<p>Exercise 10. shell不支持I/O重定向。如果能运行<code>sh &lt;script</code>就更好，而不是像上面那样手工输入<code>script</code>中的所有命令。将<code>&lt;</code>的I/O重定向添加到<code>user/sh.c</code>。通过在shell中键入<code>sh &lt;script</code>测试您的实现</p>
<p>运行<code>make run-testshell</code>来测试您的<code>shell</code>。<code>testshell</code>只是将上面的命令(也可以在<code>fs/testshell.sh</code>中找到)提供给shell，然后检查输出是否匹配<code>fs/testshell.key</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:	<span class="comment">// Input redirection</span></span><br><span class="line">	<span class="comment">// Grab the filename from the argument list</span></span><br><span class="line">	<span class="keyword">if</span> (gettoken(<span class="number">0</span>, &amp;t) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">&quot;syntax error: &lt; not followed by word\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">&quot;open %s for read: %e&quot;</span>, t, fd);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fd != <span class="number">0</span>) &#123;</span><br><span class="line">		dup(fd, <span class="number">0</span>); <span class="comment">//应该是让文件描述符0也作为fd对应的那个open file的struct Fd页面</span></span><br><span class="line">		close(fd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//panic(&quot;&lt; redirection not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>为什么好多函数的<code>envid_t</code>参数总是设成0？在<code>envid2env()</code>函数中有这样如下定义。所以设成0就e就默认是<code>curenv</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If envid is zero, return the current environment.</span></span><br><span class="line">    <span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">        *env_store = curenv;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Challenge的要求即为清空掉所有的没有被访问的页面。那么对于单个页面，只需要调用<code>flush_block()</code>，之后通过系统调用<code>unmap</code>就可以了。<code>evict_policy()</code>即对于所有的block做一个便利，清除所有从未被访问过的页面。具体代码内容如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// challenge</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">evict_block</span><span class="params">(<span class="type">void</span> *addr)</span>&#123;</span><br><span class="line">	<span class="type">uint32_t</span> blockno = ((<span class="type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">	<span class="keyword">if</span>(addr &lt; (<span class="type">void</span>*)DISKMAP || addr &gt;= (<span class="type">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">		panic(<span class="string">&quot;evict_block of bad va %08x&quot;</span>, addr);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	addr = ROUNDDOWN(addr, BLKSIZE);</span><br><span class="line">	flush_block(addr);</span><br><span class="line">	<span class="keyword">if</span>((r = sys_page_unmap(<span class="number">0</span>, addr)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;in evict block, sys_page_unmap: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">evict_policy</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">uint32_t</span> blockno;</span><br><span class="line">	<span class="keyword">for</span>(blockno = <span class="number">3</span>; blockno &lt; DISKSIZE / BLKSIZE; ++blockno)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(uvpt[PGNUM(diskaddr(blockno))]&amp;PTE_A))&#123;</span><br><span class="line">			evict_block(diskaddr(blockno));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="lab6"><a href="#lab6" class="headerlink" title="lab6"></a>lab6</h1><h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>我们已经实现了1个文件系统，当然OS还需要1个网络栈，在本次实验中我们将实现1个网卡驱动，这个网卡基于Intel 82540EM芯片，也就是熟知的E1000网卡。</p>
<p>网卡驱动不足以使你的OS能连接上Internet。在LAB6新增加的代码中，我们提供了1个网络栈(network stack)和网络服务器(network server)在<code>net/</code>目录和<code>kern/</code>目录下。</p>
<p>本次新增加的文件如下：</p>
<ul>
<li><code>net/lwip</code>目录：开源轻量级TCP/IP协议组件包括1个网络栈</li>
<li><code>net/timer.c</code>：定时器功能测试程序</li>
<li><code>net/ns.h</code>：网卡驱动相关的参数宏定义和函数声明</li>
<li><code>net/testinput.c</code>：收包功能测试程序</li>
<li><code>net/input.c</code>：收包功能的用户态函数</li>
<li><code>net/testoutput.c</code>：发包功能测试程序</li>
<li><code>net/output.c</code>：发包功能的用户态函数</li>
<li><code>net/serv.c</code>：网络服务器的实现</li>
<li><code>kern/e1000.c</code>：网卡驱动的内核实现</li>
<li><code>kern/e1000.h</code>：网卡驱动实现相关的参数宏定义和函数声明</li>
</ul>
<p>除了实现网卡驱动，我们还要实现1个系统调用接口来访问驱动。我们需要实现网络服务器代码来传输网络数据包在网络栈和驱动之间。同时网络服务器也能使用文件系统中的文件。</p>
<p>大部分内核驱动代码必须从零开始编写，这次实验比前面的实验提供更少的指导：没有骨架文件、没有系统调用接口等。总之一句话，要实现这次实验需要阅读很多提供的指导说明手册，才能完成实验。</p>
<h2 id="QEMU’s-virtual-network"><a href="#QEMU’s-virtual-network" class="headerlink" title="QEMU’s virtual network"></a>QEMU’s virtual network</h2><p>我们将会使用QEMU用户态网络栈，因为它运行不需要管理员权限。</p>
<p>在默认情况下，QEMU会提供一个运行在IP为10.0.2.2的虚拟路由器并且分配给JOS一个10.0.2.15的IP地址。为了简单起见，我们把这些默认设置硬编码在了<code>net/ns.h</code>中。</p>
<p>尽管QEMU的虚拟网络允许JOS和互联网做任意的连接，但是JOS的10.0.2.15 IP地址在QEMU运行的虚拟网络之外没有任何意义(QEMU就像一个NAT)，所以我们不能直接和JOS中运行的se服务器连接，即使是运行QEMU的宿主机上也不行。为了解决这个问题，我们通过配置QEMU，让JOS的一些端口和宿主机的某些端口相连，让服务器运行在这些端口上，从而让数据在宿主机和虚拟网络之间进行交换。</p>
<p>我们将在端口7（echo）和80（http）运行端口。为了避免端口冲突，makefile里实现了端口转发。可以通过运行<code>make which-ports</code>来找出QEMU转发的端口，也可以通过<code>make nc-7</code>和<code>make nc-80</code>来和运行在这些端口上的服务器交互。</p>
<h3 id="Packet-Inspection"><a href="#Packet-Inspection" class="headerlink" title="Packet Inspection"></a>Packet Inspection</h3><p>makefile也配置了QEMU的网络栈来记录各种进入和出去的数据包到<code>qemu.pcap</code>文件中。为了获得hex/ASCII的转换，我们可以使用<code>tcpdump</code>命令(Linux下非常有用的网络抓包分析工具，具体的参数说明可以用man tcpdump)：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -XXnr qemu.pcap</span><br></pre></td></tr></table></figure></p>
<h3 id="Debugging-the-E1000"><a href="#Debugging-the-E1000" class="headerlink" title="Debugging the E1000　　"></a>Debugging the E1000　　</h3><p>很幸运我们使用的是模拟硬件，E1000网卡运行为软件，模拟的E1000网卡能以用户可读的形式，向我们汇报有用的信息，比如内部状态和问题。</p>
<p>模拟E1000网卡能产生一系列debug输出，通过打开特殊的日志通道，来捕获输出信息：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>tx</td>
<td>Log packet transmit operations</td>
</tr>
<tr>
<td>txerr</td>
<td>Log transmit ring errors</td>
</tr>
<tr>
<td>rx</td>
<td>Log changes to RCTL</td>
</tr>
<tr>
<td>rxfilter</td>
<td>Log filtering of incoming packets</td>
</tr>
<tr>
<td>rxerr</td>
<td>Log receive ring errors</td>
</tr>
<tr>
<td>unknown</td>
<td>Log reads and writes of unknown registers</td>
</tr>
<tr>
<td>eeprom</td>
<td>Log reads from the EEPROM</td>
</tr>
<tr>
<td>interrupt</td>
<td>Log interrupts and changes to interrupt registers.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="The-Network-Server"><a href="#The-Network-Server" class="headerlink" title="The Network Server"></a>The Network Server</h3><p>从零开始写1个网络栈是很难的。这里，我们使用lwIP开源TCP/IP协议组件来实现网络栈。在这个实验中，我们只需知道lwIP是一个黑盒，它实现了BSD的socket接口并且有一个数据包input port和数据包output port。</p>
<p>网络服务器其实是由以下四个environments组成的</p>
<ol>
<li>核心网络服务 environment(包括socket调用分发和lwIP</li>
<li>输入environment</li>
<li>输出environment</li>
<li>计时environment</li>
</ol>
<p>下图显示了各个environments以及它们之间的关系。图中展示了整个系统包括设备驱动。在本次实验中，我们将实现被标记为绿色的那些部分。<br><img src="/img/20211129222000.png" alt=""></p>
<p>其实整个网络服务器实现与文件系统的实现类似，也是通过IPC机制来在各个environment之间进行数据交互。</p>
<p>本次实验中QEMU因为不是MIT修改过的版本，所以改为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/yuhao/6.828/qemu/i386-softmmu/qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log -smp 1 -drive file=obj/fs/fs.img,index=1,media=disk,format=raw -netdev user,<span class="built_in">id</span>=u1 -device e1000,netdev=u1 -nic user,hostfwd=tcp::26001-:7 -nic user,hostfwd=tcp::26002-:80 -nic user,hostfwd=udp::26001-:7 -object filter-dump,<span class="built_in">id</span>=f1,netdev=u1,file=qemu.pcap</span><br></pre></td></tr></table></figure></p>
<h3 id="The-Core-Network-Server-Environment"><a href="#The-Core-Network-Server-Environment" class="headerlink" title="The Core Network Server Environment　　"></a>The Core Network Server Environment　　</h3><p>核心网络服务environment由<code>socket</code>调用分发器和lwIP组成。<code>socket</code>调用分发和文件服务器的工作方式类似。用户 environment通过<code>stubs</code>（定义在<code>lib/nsipc.c</code>）向核心网络environment发送IPC消息。查看<code>lib/nsipc.c</code>可以发现，核心网络服务器的工作方式和文件服务器是类似的：<code>i386_init</code>创建了NS environment，类型为<code>NS_TYPE_NS</code>，因此我们遍历<code>envs</code>，找到这个特殊的environment type。对于每一个用户environment的IPC，网络服务器中的IPC分发器会调用由lwIP提供的BSD socket接口来实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send an IP request to the network server, and wait for a reply.</span></span><br><span class="line"><span class="comment">// The request body should be in nsipcbuf, and parts of the response</span></span><br><span class="line"><span class="comment">// may be written back to nsipcbuf.</span></span><br><span class="line"><span class="comment">// type: request code, passed as the simple integer IPC value.</span></span><br><span class="line"><span class="comment">// Returns 0 if successful, &lt; 0 on failure.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">nsipc</span><span class="params">(<span class="type">unsigned</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">envid_t</span> nsenv;</span><br><span class="line">    <span class="keyword">if</span> (nsenv == <span class="number">0</span>)</span><br><span class="line">        nsenv = ipc_find_env(ENV_TYPE_NS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(nsipcbuf) == PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">&quot;[%08x] nsipc %d\n&quot;</span>, thisenv-&gt;env_id, type);</span><br><span class="line"></span><br><span class="line">    ipc_send(nsenv, type, &amp;nsipcbuf, PTE_P|PTE_W|PTE_U);</span><br><span class="line">    <span class="keyword">return</span> ipc_recv(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>普通的用户environment不直接使用<code>nsipc_*</code>调用。通常它们都使用<code>lib/sockets.c</code>中提供的基于文件描述符的sockets API。因此，用户environment通过文件描述符来引用<code>socket</code>，就像引用普通的磁盘文件一样。虽然<code>socket</code>有许多特殊的操作(比如<code>connect</code>、<code>accept</code>等等)，但是像<code>read</code>，<code>write</code>，<code>close</code>这样的操作也是通过<code>lib/fd.c</code>中正常的文件描述符device-dispatcher代码。就像文件服务器会为所有打开的文件维护一个内部独有的ID，lwIP也会为每个打开的socket维护一个独有的ID。在文件服务器或者网络服务器中，我们使用存储在<code>struct Fd</code>中的信息来映射每个environment的文件描述符到相应的ID空间中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fd2sockid</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">sfd</span>;</span></span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = fd_lookup(fd, &amp;sfd)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">if</span> (sfd-&gt;fd_dev_id != devsock.dev_id)</span><br><span class="line">                <span class="keyword">return</span> -E_NOT_SUPP;</span><br><span class="line">        <span class="keyword">return</span> sfd-&gt;fd_sock.sockid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">alloc_sockfd</span><span class="params">(<span class="type">int</span> sockid)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">sfd</span>;</span></span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = fd_alloc(&amp;sfd)) &lt; <span class="number">0</span></span><br><span class="line">            || (r = sys_page_alloc(<span class="number">0</span>, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                nsipc_close(sockid);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sfd-&gt;fd_dev_id = devsock.dev_id;</span><br><span class="line">        sfd-&gt;fd_omode = O_RDWR;</span><br><span class="line">        sfd-&gt;fd_sock.sockid = sockid;</span><br><span class="line">        <span class="keyword">return</span> fd2num(sfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">accept</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = fd2sockid(s)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = nsipc_accept(r, addr, addrlen)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> alloc_sockfd(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">bind</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *name, <span class="type">socklen_t</span> namelen)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = fd2sockid(s)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> nsipc_bind(r, name, namelen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> how)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = fd2sockid(s)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> nsipc_shutdown(r, how);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">devsock_close</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (pageref(fd) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> nsipc_close(fd-&gt;fd_sock.sockid);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">connect</span><span class="params">(<span class="type">int</span> s, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *name, <span class="type">socklen_t</span> namelen)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = fd2sockid(s)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> nsipc_connect(r, name, namelen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">listen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = fd2sockid(s)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> nsipc_listen(r, backlog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">devsock_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> nsipc_recv(fd-&gt;fd_sock.sockid, buf, n, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">devsock_write</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> nsipc_send(fd-&gt;fd_sock.sockid, buf, n, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">devsock_stat</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="keyword">struct</span> Stat *stat)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(stat-&gt;st_name, <span class="string">&quot;&lt;sock&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = nsipc_socket(domain, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> alloc_sockfd(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然看起来文件服务器和网络服务器的IPC分发器工作方式相同，但是事实上有一个非常重要的区别。有些BSD socket的操作，例如accept和recv可能会永远阻塞。如果分发器让lwIP运行其中一个堵塞调用，那么很可能分发器会阻塞，因此整个系统在某一时刻只能有一个网络调用，显然，这是不能让人接收的。因此网络服务器使用用户级线程去避免整个服务器environment的阻塞。对于每一个到来的IPC，分发器都会创建一个线程，然后由它对请求进行处理。即使这个线程阻塞了，那么也仅仅只是它进入休眠状态，而其他的线程照样能继续运行。</p>
<p>除了核心网络environment之外，还有其他三个辅助的environment。除了从用户程序中获取消息以外，核心网络 environment的分发器还从input environment和timer environment处获取信息。</p>
<h3 id="The-Output-Environment"><a href="#The-Output-Environment" class="headerlink" title="The Output Environment　"></a>The Output Environment　</h3><p>当处理用户environment的socket调用时，lwIP会产生packet用于网卡的传输。lwIP会将需要发送的packet通过<code>NSREQ_OUTPUT IPC</code>发送给output helper environment，packet的内容存放在IPC的共享页中。output environment负责接收这些信息并且通过系统调用接口将这些packet转发到相应的设备驱动(我们即将实现)。</p>
<h3 id="The-Input-Environment"><a href="#The-Input-Environment" class="headerlink" title="The Input Environment"></a>The Input Environment</h3><p>网卡得到的packet需要注入到lwIP中。对于设备驱动获得的每一个packet，input environment需要通过相应的系统调用将它们从内核中抽取出来，然后通过<code>NSREQ_INPUT IPC</code>发送给核心服务器environment。</p>
<p>packet input的功能从核心网络environment中剥离出来了，因为接收IPC并且同时接收或等待来自设备驱动的packet对于JOS是非常困难的。因为JOS中没有select这样能够允许environment监听多个输入源并且判断出哪个源已经准备好了。</p>
<p>当我们实现完网卡驱动和系统调用接口后<code>net/input.c</code>和<code>net/output.c</code>中就是我们要实现的2个用户态函数。</p>
<h3 id="The-Timer-Environment"><a href="#The-Timer-Environment" class="headerlink" title="The Timer Environment　　　　　　　"></a>The Timer Environment　　　　　　　</h3><p>timer environment会定期地向核心网络服务器发送<code>NSREQ_TIMER IPC</code>，通知它又过去了一个时间间隔，而lwIP会利用这些时间信息去实现各种的网络超时。</p>
<h2 id="Part-A-Initialization-and-transmitting-packets"><a href="#Part-A-Initialization-and-transmitting-packets" class="headerlink" title="Part A: Initialization and transmitting packets"></a>Part A: Initialization and transmitting packets</h2><p>我们的内核中还没有时间的概念，所以我们需要加上它。现在每隔10ms都有一个由硬件产生的时钟中断。每次出现一个时钟中断的时候，我们都对一个变量进行加操作，表示过去了10ms。这实现在kern/time.c中，但是并未归并到内核中。<br>　　<br>Exercise 1：在<code>kern/trap.c</code>中增加1个<code>time_tick</code>调用来处理每次时钟中断，实现<code>sys_time_msec</code>系统调用，使用户空间能读取时间。<br>　<br>首先在<code>kern/trap.c</code>的<code>trap_dispatch</code>函数中，对于<code>IRQ_OFFSET + IRQ_TIMER</code>中断添加<code>time_tick</code>调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/trap.c</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">        lapic_eoi();</span><br><span class="line">        time_tick();</span><br><span class="line">        sched_yield();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kern/time.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">time_tick</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    ticks++;</span><br><span class="line">    <span class="keyword">if</span> (ticks * <span class="number">10</span> &lt; ticks)</span><br><span class="line">        panic(<span class="string">&quot;time_tick: time overflowed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下去就是添加获取时间的系统调用，具体流程和之前的一样，主要是在<code>kern/syscall.c</code>的中实现<code>sys_time_msec</code>函数，在该函数中调用<code>time_msec</code>函数来获得系统时间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/syscall.c</span></span><br><span class="line"><span class="comment">// Return the current time.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_time_msec</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> time_msec();</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//kern/time.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">time_msec</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">return</span> ticks * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过运行<code>make INIT_CFLAGS=-DTEST_NO_NS run-testtime</code>来测试计时器共，将会看到从5到1的倒计时。其中<code>-DTEST_NO_NS</code>禁止启动网络服务器environment，因为我们暂时还没实现。</p>
<h3 id="The-Network-Interface-Card"><a href="#The-Network-Interface-Card" class="headerlink" title="The Network Interface Card"></a>The Network Interface Card</h3><p>　　要写1个驱动必须要深入硬件和软件接口，在本次实验中我们将给1个高层次综述关于如何与E1000网卡交互，但是你需要去使用Intel的帮助手册来实现驱动。</p>
<h3 id="PCI-Interface"><a href="#PCI-Interface" class="headerlink" title="PCI Interface"></a>PCI Interface</h3><p>E1000网卡是一个PCI设备，这说明它是插入主板的PCI总线。PCI总线有地址总线、数据总线和中断总线，从而允许CPU能访问PCI设备，PCI设备也能读写内存。一个PCI设备在使用之前需要被发现并且初始化。发现的过程是指遍历PCI总线找到已经连接的设备。初始化是指为设备分配IO和内存空间并且指定IRQ线的过程。</p>
<p>PCI是外围设备互连(Peripheral Component Interconnect)的简称，是在目前计算机系统中得到广泛应用的通用总线接口标准：　　</p>
<ul>
<li>在一个PCI系统中，最多可以有256根PCI总线，一般主机上只会用到其中很少的几条。</li>
<li>在一根PCI总线上可以连接多个物理设备，可以是一个网卡、显卡或者声卡等，最多不超过32个。</li>
<li>一个PCI物理设备可以有多个功能，比如同时提供视频解析和声音解析，最多可提供8个功能。</li>
<li>每个功能对应1个256字节的PCI配置空间。</li>
</ul>
<p>我们在<code>kern/pci.c</code>中已经提供了PCI相关的代码。为了在启动过程中实现PCI的初始化，相关的PCI代码遍历了PCI总线进行设备查找。当发现一个设备时，它会读取它的vendor ID和device ID，把这两个值作为<code>key</code>去查询<code>pci_attach_vendor</code>数组。该数组元素是<code>struct pci_driver</code>类型的，如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> &#123;</span></span><br><span class="line">　　<span class="type">uint32_t</span> key1, key2;</span><br><span class="line">　　<span class="type">int</span> (*attachfn) (<span class="keyword">struct</span> pci_func *pcif);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果被发现设备的vendor ID和device ID和数组中的某个表项是匹配的，那么接下来就会调用该表项的<code>attachfn</code>函数进行初始化工作。(设备也能被class识别，我们在<code>kern/pci.c</code>中也提供了其它驱动表)</p>
<p>当我们向查询1个特定PCI设备的配置空间时，需要向I/O地址<code>[0cf8，0cfb]</code>写入1个4字节的查询码指定总线号：设备号：功能号以及其配置地址空间中的查询位置。PCI Host Bridge将监听对于这个I/O端口的写入，并将查询结果写入到<code>[0cfc，0cff]</code>，我们可以从这个地址读出1个32位整数表示查询到的相应信息。</p>
<p><code>attach</code>函数通过一个 PCI 函数来初始化。 PCI 卡可以提供多种功能，而 E1000 只提供一种功能。以下是我们在 JOS 中表示 PCI 功能的方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_func</span> &#123;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">pci_bus</span> 　　*<span class="title">bus</span>;</span></span><br><span class="line">　　<span class="type">uint32_t</span>　　　　　dev;</span><br><span class="line">　　<span class="type">uint32_t</span>　　　　　func;</span><br><span class="line">　　<span class="type">uint32_t</span>　　　　　dev_id;</span><br><span class="line">　　<span class="type">uint32_t</span>　　　　　dev_clasee;</span><br><span class="line">　　<span class="type">uint32_t</span>　　　　　reg_base[<span class="number">6</span>];</span><br><span class="line">　　<span class="type">uint32_t</span>　　　　　reg_size[<span class="number">6</span>];</span><br><span class="line">　　<span class="type">uint8_t</span>　　　　　  irq_line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述结构的最后三个表项是最吸引我们的地方，其中记录了该设备的内存、IO和中断资源的信息。<code>reg_base</code>和<code>reg_size</code>数组包含了最多6个Base Address Register（BAR）的信息。<code>reg_base</code>记录了memory-mapped IO region的基内存地址或者基IO端口，<code>reg_size</code>则记录了<code>reg_base</code>对应的内存区域的大小或者IO端口的数目，<code>irq_line</code>则表示分配给设备中断用的IRQ线。</p>
<p>当设备的<code>attachfn</code>被调用时，设备已经被找到了，但是还不能用。这说明相关代码还没有确定分配给设备的资源，比如地址空间和IRQ线，其实就是<code>struct pci_fun</code>中的后三项还没被填充。<code>attachfn</code>函数需要调用<code>pci_func_enable</code>来分配相应的资源，填充<code>struct pci_func</code>，使设备运行起来。</p>
<p>每一个PCI设备都有它映射的内存地址空间和I/O区域，除此之外，PCI设备还有配置空间，一共有256字节，其中前64字节是标准化的，提供了厂商号、设备号、版本号等信息，唯一标示1个PCI设备，同时提供最多6个的IO地址区域。<br><img src="/img/1638326044.jpg" alt=""></p>
<p>Exercise 3：实现1个<code>attach</code>函数来初始化E1000网卡，在<code>pci_attach_vendor</code>数组中增加1个表项来触发，可以在参考手册的5.2章节来找到82450EM的vendor ID和device ID。目前暂时使用<code>pci_func_enable</code>来使能E1000网卡设备，初始化工作放到后面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pci_func_enable</span><span class="params">(<span class="keyword">struct</span> pci_func *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_conf_write(f, PCI_COMMAND_STATUS_REG,</span><br><span class="line">                   PCI_COMMAND_IO_ENABLE |</span><br><span class="line">                   PCI_COMMAND_MEM_ENABLE |</span><br><span class="line">                   PCI_COMMAND_MASTER_ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> bar_width;</span><br><span class="line">    <span class="type">uint32_t</span> bar;</span><br><span class="line">    <span class="keyword">for</span> (bar = PCI_MAPREG_START; bar &lt; PCI_MAPREG_END;</span><br><span class="line">        bar += bar_width)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> oldv = pci_conf_read(f, bar);</span><br><span class="line"></span><br><span class="line">        bar_width = <span class="number">4</span>;</span><br><span class="line">        pci_conf_write(f, bar, <span class="number">0xffffffff</span>);</span><br><span class="line">        <span class="type">uint32_t</span> rv = pci_conf_read(f, bar);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rv == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> regnum = PCI_MAPREG_NUM(bar);</span><br><span class="line">        <span class="type">uint32_t</span> base, size;</span><br><span class="line">        <span class="keyword">if</span> (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)</span><br><span class="line">                bar_width = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">            size = PCI_MAPREG_MEM_SIZE(rv);</span><br><span class="line">            base = PCI_MAPREG_MEM_ADDR(oldv);</span><br><span class="line">            <span class="keyword">if</span> (pci_show_addrs)</span><br><span class="line">                cprintf(<span class="string">&quot;  mem region %d: %d bytes at 0x%x\n&quot;</span>,</span><br><span class="line">                        regnum, size, base);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            size = PCI_MAPREG_IO_SIZE(rv);</span><br><span class="line">            base = PCI_MAPREG_IO_ADDR(oldv);</span><br><span class="line">            <span class="keyword">if</span> (pci_show_addrs)</span><br><span class="line">                cprintf(<span class="string">&quot;  io region %d: %d bytes at 0x%x\n&quot;</span>,</span><br><span class="line">                        regnum, size, base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pci_conf_write(f, bar, oldv);</span><br><span class="line">        f-&gt;reg_base[regnum] = base;</span><br><span class="line">        f-&gt;reg_size[regnum] = size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &amp;&amp; !base)</span><br><span class="line">            cprintf(<span class="string">&quot;PCI device %02x:%02x.%d (%04x:%04x) &quot;</span></span><br><span class="line">                    <span class="string">&quot;may be misconfigured: &quot;</span></span><br><span class="line">                    <span class="string">&quot;region %d: base 0x%x, size %d\n&quot;</span>,</span><br><span class="line">                    f-&gt;bus-&gt;busno, f-&gt;dev, f-&gt;func,</span><br><span class="line">                    PCI_VENDOR(f-&gt;dev_id), PCI_PRODUCT(f-&gt;dev_id),</span><br><span class="line">                    regnum, base, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;PCI function %02x:%02x.%d (%04x:%04x) enabled\n&quot;</span>,</span><br><span class="line">            f-&gt;bus-&gt;busno, f-&gt;dev, f-&gt;func,</span><br><span class="line">            PCI_VENDOR(f-&gt;dev_id), PCI_PRODUCT(f-&gt;dev_id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回答：在JOS中是如何对PCI设备进行初始化的，这部分模块主要定义在<code>pci.c</code>中，JOS会在系统初始化时调用<code>pci_init</code>函数来进行设备初始化(在<code>kern/init.c</code>的<code>i386_init</code>函数中)。</p>
<p>首先来看一些最基本的变量和函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pci_attach_class matches the class and subclass of a PCI device</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">pci_attach_class</span>[] =</span> &#123;</span><br><span class="line">    &#123; PCI_CLASS_BRIDGE, PCI_SUBCLASS_BRIDGE_PCI, &amp;pci_bridge_attach &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pci_attach_vendor matches the vendor ID and device ID of a PCI device. key1</span></span><br><span class="line"><span class="comment">// and key2 should be the vendor ID and device ID respectively</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">pci_attach_vendor</span>[] =</span> &#123;</span><br><span class="line">    &#123; PCI_E1000_VENDOR, PCI_E1000_DEVICE, &amp;pci_e1000_attach &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pci_conf1_set_addr</span><span class="params">(<span class="type">uint32_t</span> bus,</span></span><br><span class="line"><span class="params">           <span class="type">uint32_t</span> dev,</span></span><br><span class="line"><span class="params">           <span class="type">uint32_t</span> func,</span></span><br><span class="line"><span class="params">           <span class="type">uint32_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(bus &lt; <span class="number">256</span>);</span><br><span class="line">    assert(dev &lt; <span class="number">32</span>);</span><br><span class="line">    assert(func &lt; <span class="number">8</span>);</span><br><span class="line">    assert(offset &lt; <span class="number">256</span>);</span><br><span class="line">    assert((offset &amp; <span class="number">0x3</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> v = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) |        <span class="comment">// config-space</span></span><br><span class="line">        (bus &lt;&lt; <span class="number">16</span>) | (dev &lt;&lt; <span class="number">11</span>) | (func &lt;&lt; <span class="number">8</span>) | (offset);</span><br><span class="line">    outl(pci_conf1_addr_ioport, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">pci_conf_read</span><span class="params">(<span class="keyword">struct</span> pci_func *f, <span class="type">uint32_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_conf1_set_addr(f-&gt;bus-&gt;busno, f-&gt;dev, f-&gt;func, off);</span><br><span class="line">    <span class="keyword">return</span> inl(pci_conf1_data_ioport);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pci_conf_write</span><span class="params">(<span class="keyword">struct</span> pci_func *f, <span class="type">uint32_t</span> off, <span class="type">uint32_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_conf1_set_addr(f-&gt;bus-&gt;busno, f-&gt;dev, f-&gt;func, off);</span><br><span class="line">    outl(pci_conf1_data_ioport, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pci_attach_class</code>和<code>pci_attach_vendor</code>2个数组就是设备数组，3个函数是堆PCI设备最基本的读状态和写状态的函数：　　　</p>
<ul>
<li><code>pci_conf_read</code>函数是读取PCI配置空间中特定位置的配置值</li>
<li><code>pci_conf_write</code>函数是设置PCI配置空间中特定位置的配置值</li>
<li><code>pci_conf1_set_addr</code>函数是负责设置需要读写的具体设备</li>
</ul>
<p>这里涉及的2个I/O端口正是我们上面提到的操作PCI设备的IO端口。接下来我们看看如何初始化PCI设备，进入<code>pic_init</code>函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pci_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_bus</span> <span class="title">root_bus</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;root_bus, <span class="number">0</span>, <span class="keyword">sizeof</span>(root_bus));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pci_scan_bus(&amp;root_bus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">pci_scan_bus</span><span class="params">(<span class="keyword">struct</span> pci_bus *bus)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> totaldev = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_func</span> <span class="title">df</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;df, <span class="number">0</span>, <span class="keyword">sizeof</span>(df));</span><br><span class="line">    df.bus = bus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (df.dev = <span class="number">0</span>; df.dev &lt; <span class="number">32</span>; df.dev++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> bhlc = pci_conf_read(&amp;df, PCI_BHLC_REG);</span><br><span class="line">        <span class="keyword">if</span> (PCI_HDRTYPE_TYPE(bhlc) &gt; <span class="number">1</span>)     <span class="comment">// Unsupported or no device</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        totaldev++;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pci_func</span> <span class="title">f</span> =</span> df;</span><br><span class="line">        <span class="keyword">for</span> (f.func = <span class="number">0</span>; f.func &lt; (PCI_HDRTYPE_MULTIFN(bhlc) ? <span class="number">8</span> : <span class="number">1</span>);</span><br><span class="line">             f.func++) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pci_func</span> <span class="title">af</span> =</span> f;</span><br><span class="line"></span><br><span class="line">            af.dev_id = pci_conf_read(&amp;f, PCI_ID_REG);</span><br><span class="line">            <span class="keyword">if</span> (PCI_VENDOR(af.dev_id) == <span class="number">0xffff</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> intr = pci_conf_read(&amp;af, PCI_INTERRUPT_REG);</span><br><span class="line">            af.irq_line = PCI_INTERRUPT_LINE(intr);</span><br><span class="line"></span><br><span class="line">            af.dev_class = pci_conf_read(&amp;af, PCI_CLASS_REG);</span><br><span class="line">            <span class="keyword">if</span> (pci_show_devs)</span><br><span class="line">                pci_print_func(&amp;af);</span><br><span class="line">            pci_attach(&amp;af);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totaldev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>pci_init</code>函数中，<code>root_bus</code>被全部清0，然后交给<code>pci_scan_bus</code>函数来扫描这条总线上的所有设备，说明在JOS中E1000网卡是连接在0号总线上的。<code>pci_scan_bus</code>函数来顺次查找0号总线上的32个设备，如果发现其存在，那么顺次扫描它们每个功能对应的配置地址空间，将一些关键的控制参数读入到<code>pci_func</code>中进行保存。</p>
<p>得到<code>pci_func</code>函数后，被传入<code>pci_attach</code>函数去查找是否为已存在的设备，并用相应的初始化函数来初始化设备。</p>
<p>通过查阅手册，我们知道E1000网卡的Vendor ID为0x8086，Device ID为0x100E，所以我们先实现1个e1000网卡初始化函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/e1000.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_KERN_E1000_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOS_KERN_E1000_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kern/pci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pci_e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// SOL &gt;= 6</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/e1000.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pci_e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kern/pci.c</span></span><br><span class="line"><span class="comment">// pci_attach_vendor matches the vendor ID and device ID of a PCI device. key1</span></span><br><span class="line"><span class="comment">// and key2 should be the vendor ID and device ID respectively</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">pci_attach_vendor</span>[] =</span> &#123;</span><br><span class="line">        &#123; PCI_VENDOR_ID, PCI_DEVICE_ID, &amp;e1000_init &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kern/pcireg.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCI_VENDOR_ID                           0x8086</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCI_DEVICE_ID                           0x100E</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Memory-mapped-I-O"><a href="#Memory-mapped-I-O" class="headerlink" title="Memory-mapped I/O"></a>Memory-mapped I/O</h3><p>软件通过memory-mapped IO（MMIO）和E1000网卡进行通信。我们已经在JOS两次见到过它了：对于CGA和LAPIC都是通过直接读写“内存”来控制和访问的。但是这些读写操作都是不经过DRAM的，而是直接进入设备。</p>
<p><code>pci_func_enable</code>为E1000网卡分配了一个MMIO区域，并且将它的基地址和大小存储在了BAR0中，也就是<code>reg_base[0]</code>和<code>reg_size[0]</code>中。这是一段为设备分配的物理地址，意味着你需要通过虚拟内存访问它。因为MMIO区域通常都被放在非常高的物理地址上（通常高于3GB），因此我们不能直接使用<code>KADDR</code>去访问它，因为JOS 256MB的内存限制。所以我们需要建立一个新的内存映射。我们将会使用高于<code>MMIOBASE</code>的区域（lab4中的<code>mmio_map_region</code>将会保证我们不会复写LAPIC的映射）。因为PCI设备的初始化发生在JOS创建user environment之前，所以我们可以在<code>kern_pgdir</code>创建映射，从而保证它永远可用。</p>
<p>Exercise 4：在E1000网卡的初始化函数中，通过调用<code>mmio_map_region</code>函数来为E1000网卡的BAR0建立一个虚拟内存映射。你需要使用1个变量记录下该映射地址以便之后可以访问映射的寄存器。查看在<code>kern/lapic.c</code>中的<code>lapic</code>变量，效仿它的做法。假如你使用1个指针指向设备寄存器映射地址，那么你必须声明它为<code>volatile</code>，否则编译器会运行缓存该值和重新排序内存访问序列。</p>
<p>为了测试你的映射，可以尝试答应处设备状态寄出去，该寄存器为4个字节，值为0x80080783，表示全双工1000MB/S。</p>
<p>根据练习的提示，仿照lapic中的做法，在<code>kern/e1000.c</code>中声明1个全局变量<code>e1000</code>，该变量是1个指针，指向映射地址。然后调用<code>mmio_map_region</code>函数来申请内存建立映射，输出状态寄存器的值。关于寄存器位置和相关掩码，我们需要查看开发手册，设置宏定义，这一步可以借鉴QEMU的e1000_hw.h文件，拷贝相关定义到<code>kern/e1000.h</code>中。代码如下，具体的宏定义可以参考github。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pci_e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line"></span><br><span class="line">    e1000 = mmio_map_region(pcif-&gt;reg_base[<span class="number">0</span>], pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    cprintf(<span class="string">&quot;e1000: bar0  %x size0 %x\n&quot;</span>, pcif-&gt;reg_base[<span class="number">0</span>], pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    cprintf(<span class="string">&quot;e1000: status %x\n&quot;</span>, e1000[STATUS/<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>我们可以想象通过读写E1000网卡的寄存器来发送和接收<code>packet</code>，但这实在是太慢了，而且需要E1000暂存<code>packets</code>。因此E1000使用Direct Access Memory(DMA)来直接从内存中读写<code>packets</code>而不通过CPU。驱动的作用就是负责为发送和接收队列分配内存，建立DMA描述符，以及配置E1000网卡，让它知道这些队列的位置，不过之后的所有事情都是异步。在发送<code>packet</code>的时候，驱动会将它拷贝到<code>transmit</code>队列的下一个DMA描述符中，然后通知E1000网卡另外一个包到了。E1000网卡会在能够发送下一个<code>packet</code>的时候，将<code>packet</code>从描述符中拷贝出来。同样，当E1000网卡接收到一个<code>packet</code>的时候，就会将它拷贝到接收队列的下一个DMA描述符中，并且在合适的时机，驱动会将它从中读取出来。<br>　　<br>从高层次来看，接收和发送队列是非常相似的，都是由一系列的描述符组成。但是这些descriptor具体的结构是不同的，每个描述符都包含了一些flag以及存储packet数据的物理地址。<br>　　<br>队列由循环数组构成，这表示当网卡或者驱动到达了数组的末尾时，它又会转回数组的头部。每个循环数组都有一个<code>head</code>指针和<code>tail</code>指针，这两个指针之间的部分就是队列的内容。网卡总是从<code>head</code>消耗描述符并且移动<code>head</code>指针，同时，驱动总是向尾部添加描述符并且移动<code>tail</code>指针。发送队列的描述符代表等待被发送的<code>packet</code>。对于接收队列，队列中的描述符是一些闲置的描述符，网卡可以将收到的<code>packet</code>放进去。</p>
<p>这些指向数组的指针和描述符中packet buffer的地址都必须是物理地址，因为硬件直接和物理RAM发生DMA，并不经过MMU。</p>
<h3 id="Transmitting-Packets"><a href="#Transmitting-Packets" class="headerlink" title="Transmitting Packets"></a>Transmitting Packets</h3><p>E1000网卡的发送和接收函数是独立的，因此我们能一次处理其中一个。我们将首先实现发送<code>packet</code>的操作，因为没有发送就不能接收。<br>　　<br>首先，我们要做的是初始化网卡的发包。根据14.5章节描述的步骤，发送操作初始化的第一步就是建立发送队列，具体队列结构的描述在3.4章节，描述符的结构在3.3.3章节。我们不会使用E1000网卡的TCP offload特性，所以我们专注于”legacy transmit descriptor format”。</p>
<h4 id="C-Structures"><a href="#C-Structures" class="headerlink" title="C Structures"></a>C Structures</h4><p>我们会发现用C的结构描述E1000网卡的结构是相当容易的。就像我们之前遇到过的<code>struct Trapframe</code>，C结构能让你精确地控制数据在内存中的布局。C会在结构的各个元素间插入空白用于对齐，但是对于E1000里的结构这都不是问题。例如，传统的发送描述符如下图所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">63      48 47 40 39   32 31  24 23   16 15      0</span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">|               buffer address                  |</span><br><span class="line">+---------+-----+--------+-----+-------+--------+</span><br><span class="line">| special | CSS | status | cmd |  CSO  | length |</span><br><span class="line">+---------+-----+--------+-----+-------+--------+</span><br></pre></td></tr></table></figure></p>
<p>按照从上往下，从右往左的顺序读取，我们可以发现，<code>struct tx_desc</code>刚好是对齐的，因此不会有空白填充。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> addr;</span><br><span class="line">    <span class="type">uint16_t</span> length;</span><br><span class="line">    <span class="type">uint8_t</span> cso;</span><br><span class="line">    <span class="type">uint8_t</span> cmd;</span><br><span class="line">    <span class="type">uint8_t</span> status;</span><br><span class="line">    <span class="type">uint8_t</span> css;</span><br><span class="line">    <span class="type">uint16_t</span> special;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们的驱动需要为发送描述符数组和发送描述符指向的<code>packet buffers</code>预留内存。对于这一点，我们有很多实现方法，包括可以通过动态地分配页面并将它们存放在全局变量中。我们用哪种方法，需要记住的是E1000总是直接访问物理内存的，这意味着任何它访问的buffer都必须在物理空间上是连续的。<br>　　<br>同样，我们有很多方法处理<code>packet buffer</code>。最简单的就是像最开始我们说的那样，在驱动初始化的时候为每个描述符的<code>packet buffer</code>预留空间，之后就在这些预留的<code>buffer</code>中对<code>packet</code>进行进出拷贝。Ethernet packet最大有1518个byte，这就表明了这些buffer至少要多大。更加复杂的驱动可以动态地获取packet buffer（为了降低网络使用率比较低的时候带来的浪费）或者直接提供由用户空间提供的buffers，不过一开始简单点总是好的。<br>　　<br>Exercise 5：根据14.5章节的描述，实现发包初始化，同时借鉴13章节(寄存器初始化)、3.3.3章节((发送描述符)和3.4章节(发送描述符数组)。<br>　　<br>记住发送描述数组的对弈要求和数组长度的限制。TDLEN必须是128字节对齐的，每个发送描述符是16字节的，你的发送描述符数组大小需要是8的倍数。在JOS中不要超过64个描述符，以防不好测试发送环形队列溢出情况。</p>
<p>这里需要查看开发手册14.5章节关于发送初始化的描述，主要步骤如下：</p>
<ul>
<li>为发送描述符队列分配一块连续空间，设置<code>TDBAL</code>和<code>TDBAH</code>寄存器的值指向起始地址，其中<code>TDBAL</code>为32位地址，<code>TDBAL</code>和<code>TDBAH</code>表示64位地址。</li>
<li>设置<code>TDLEN</code>寄存器的值为描述符队列的大小，以字节计算。</li>
<li>设置发送队列的<code>Head</code>指针(TDH)和<code>Tail</code>指针(TDT)寄存器的值为0。</li>
<li>初始化发送控制<code>TCTL</code>寄存器的值，包括设置Enable位为1(<code>TCTL.EN</code>)、<code>TCTL.PSP</code>位为1、<code>TCTL.CT</code>位为10h、<code>TCTL.COLD</code>位为40h。</li>
<li>设置<code>TIPG</code>寄存器为期望值</li>
</ul>
<p>首先是发送队列的设置，这里采用最简单的方法，声明发送描述符结构体和<code>packet buffer</code>结构体，并定义1个64大小的全局发送描述符数组和1个64大小的<code>packet buffer</code>数组，即都使用静态分配的方法。由于packet最大为1518字节，根据后面接收描述符的配置，将<code>packet buffer</code>设置为2048字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/e1000.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> addr;</span><br><span class="line">    <span class="type">uint16_t</span> length;</span><br><span class="line">    <span class="type">uint8_t</span> cso;</span><br><span class="line">    <span class="type">uint8_t</span> cmd;</span><br><span class="line">    <span class="type">uint8_t</span> status;</span><br><span class="line">    <span class="type">uint8_t</span> css;</span><br><span class="line">    <span class="type">uint16_t</span> special;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span></span></span><br><span class="line"><span class="class">&#123;</span>       </span><br><span class="line">    <span class="type">char</span> body[<span class="number">2048</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kern/e1000.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> <span class="title">tx_d</span>[<span class="title">TXRING_LEN</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span> (<span class="title">PGSIZE</span>)))</span></span><br><span class="line"><span class="class">        =</span> &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span> <span class="title">pbuf</span>[<span class="title">TXRING_LEN</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span> (<span class="title">PGSIZE</span>)))</span></span><br><span class="line"><span class="class">        =</span> &#123;&#123;&#123;<span class="number">0</span>&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>pci_enable_attach</code>函数中初始化相关寄存器的设置和发送描述符初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">init_desc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; TXRING_LEN; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;tx_d[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(tx_d[i]));</span><br><span class="line">        tx_d[i].addr = PADDR(&amp;pbuf[i]);</span><br><span class="line">        tx_d[i].status = TXD_STAT_DD;</span><br><span class="line">        tx_d[i].cmd = TXD_CMD_RS | TXD_CMD_EOP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pci_e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line">    init_desc();</span><br><span class="line"></span><br><span class="line">    e1000 = mmio_map_region(pcif-&gt;reg_base[<span class="number">0</span>], pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    cprintf(<span class="string">&quot;e1000: bar0  %x size0 %x\n&quot;</span>, pcif-&gt;reg_base[<span class="number">0</span>], pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    e1000[TDBAL/<span class="number">4</span>] = PADDR(tx_d);</span><br><span class="line">    e1000[TDBAH/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    e1000[TDLEN/<span class="number">4</span>] = TXRING_LEN * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tx_desc);</span><br><span class="line">    e1000[TDH/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    e1000[TDT/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    e1000[TCTL/<span class="number">4</span>] = TCTL_EN | TCTL_PSP | (TCTL_CT &amp; (<span class="number">0x10</span> &lt;&lt; <span class="number">4</span>)) | (TCTL_COLD &amp; (<span class="number">0x40</span> &lt;&lt; <span class="number">12</span>));</span><br><span class="line">    e1000[TIPG/<span class="number">4</span>] = <span class="number">10</span> | (<span class="number">8</span> &lt;&lt; <span class="number">10</span>) | (<span class="number">12</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">    cprintf(<span class="string">&quot;e1000: status %x\n&quot;</span>, e1000[STATUS/<span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在完成了exercise 5之后，发送已经初始化完成。我们需要实现包的发送工作，然后让用户空间能够通过系统调用获取这些包。为了发送一个包，我们需要将它加入到发送队列的尾部，这意味着我们要将<code>packet</code>拷贝到下一个packet buffer，并且更新TDT寄存器，从而告诉网卡，已经有另一个<code>packet</code>进入发送队列了。(需要注意的是，TDT是一个指向transmit descriptor array的index，而不是一个byte offset)</p>
<p>但是，发送队列只有这么大。如果网卡迟迟没有发送<code>packet</code>，发送队列满了怎么办？为了检测这种情况，我们需要反馈给E1000网卡一些信息。不幸的是，我们并不能直接使用<code>TDH</code>寄存器，文档中明确声明，读取该寄存器的值是不可靠的。然而，如果我们在发送描述符的command filed设置了RS位，那么当网卡发送了这个描述符中的包之后，就会设置该描述符的status域的DD位。如果一个描述符的DD位被设置了，那么我们就可以知道循环利用这个描述符是安全的，可以利用它去发送下一个packet。</p>
<p>如果当用户调用了发包的系统调用，但是下一个描述符的DD位没有设置怎么办？这是否代表发送队列满了么？遇到这种情况我们应该如何处理？我们可以选择简单地直接丢弃这个packet。许多网络协议都对这种情况有弹性的设置，但是如果我们丢弃了很多packet的话，协议可能就无法恢复了。我们也许可以告诉user environment我们需要重新发送，就像<code>sys_ipc_try_send</code>中做的一样。我们可以让驱动一直处于自旋状态，直到有一个发送描述符被释放，但是这可能会造成比较大的性能问题，因为JOS内核不是设计成能阻塞的。最后，我们可以让transmitting environment睡眠并且要求网卡在有transmit descriptor被释放的时候发送一个中断。</p>
<p>Exercise 6：写一个函数通过检查下一个描述符是否可用来发送一个包，拷贝数据包内容到下一个描述符中，更新TDT，确保你能正确解决发送队列满了的情况。</p>
<p>回答：在初始化工作中我们已经设置发送描述符的状态位为DD，即表示可用，只要在发送函数里获取<code>Tail</code>指针寄存器的值，判断该指针指向的发送描述符是否可用，如果可用将数据包内容拷贝到描述符中，并更新描述符的状态位和<code>TDT</code>寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tail = e1000[TDT/<span class="number">4</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> *<span class="title">nxt</span> =</span> &amp;tx_d[tail];</span><br><span class="line">    <span class="comment">// find the last ex_desc with tail.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((nxt-&gt;status &amp; TXD_STAT_DD) != TXD_STAT_DD)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; TBUFFSIZE)</span><br><span class="line">        len = TBUFFSIZE;</span><br><span class="line"></span><br><span class="line">    memmove(&amp;pbuf[tail], addr, len);</span><br><span class="line">    nxt-&gt;length = (<span class="type">uint16_t</span>)len;</span><br><span class="line">    nxt-&gt;status &amp;= !TXD_STAT_DD;</span><br><span class="line">    e1000[TDT/<span class="number">4</span>] = (tail + <span class="number">1</span>) % TXRING_LEN;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你完成发包代码后，可以在内核中调用该函数来测试代码正确性。运行<code>make E1000_DEBUG=TXERR,TX qemu</code>测试，你会看到如下输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e1000: index 0: 0x271f00 : 9000002a 0</span><br></pre></td></tr></table></figure></p>
<p>其中每一行表示1个发送的数据包，<code>index</code>给出了在发送描述符数组中的索引，之后的为该描述符中<code>packet buffer</code>的地址，然后是cmd/CSO/length标志位，最后是special/CSS/status标志位。</p>
<p>Exercise 7：添加1个系统调用来让用户空间可以发送数据包。具体的接口实现取决于自己。</p>
<p>仿照<code>sys_ipc_try_send</code>调用，在系统调用涉及的文件中添加调用号和接口函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/syscall.c</span></span><br><span class="line"><span class="comment">// Send network packet</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_netpacket_try_send</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    user_mem_assert(curenv, addr, len, PTE_U);</span><br><span class="line">    <span class="keyword">return</span> e1000_transmit(addr, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Transmitting-Packets-Network-Server"><a href="#Transmitting-Packets-Network-Server" class="headerlink" title="Transmitting Packets: Network Server"></a>Transmitting Packets: Network Server</h3><p>现在我们已经有了访问设备驱动发送端的系统调用接口，那么该发送一些<code>packets</code>了。output helper environment的作用就是不断做如下的循环：从核心网络服务器中接收<code>NSREQ_OUTPUT</code>类型的IPC消息，然后用我们自己写的系统调用将含有这些IPC消息的<code>packet</code>发送到网卡驱动。</p>
<p><code>NSREQ_OUTPUT</code>的IPC消息是由<code>net/lwip/jos/jif/jif.c</code>中的<code>low_level_output</code>发送的，它将lwIP stack和JOS的网络系统连在了一起。每一个IPC都会包含一个由union Nsipc组成的页，其中<code>packet</code>存放在<code>struct jif_pkt</code>字段中（见<code>inc/ns.h</code>）。<code>struct jif_pkt</code>如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jif_pkt</span> &#123;</span></span><br><span class="line">　　<span class="type">int</span> 　　jp_len;</span><br><span class="line">　　<span class="type">char</span>　  jp_data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>jp_len</code>代表了<code>packet</code>的长度。IPC page之后的所有字节都代表了<code>packet</code>的内容。使用一个长度为0的数组，例如<code>jp_data</code>，在<code>struct jif_pkt</code>的结尾，是C中一种比较通用的方式，用于代表一个未提前指定长度的<code>buffer</code>。因为C中并没有做任何边界检测，只要你确定<code>struct</code>之后有足够的未被使用的内存，我们就可以认为<code>jp_data</code>是任意大小的数组。</p>
<p>我们需要搞清楚当设备驱动的发送队列中没有空间的时候，设备驱动，output environment和核心网络服务器三者之间的关系。核心网络服务器通过IPC将packet发送给output environment。如果output environment因为驱动中没有足够的缓存空间用于存放新的packet而阻塞，核心网络服务器会一直阻塞直到output environment接受了IPC为止。</p>
<p>Exercise 8：实现<code>net/output.c</code>。</p>
<p>回答：这里主要是实现output environment的工作。<code>net/testoutput.c</code>是测试发包的代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">envid_t</span> output_envid;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">jif_pkt</span> *<span class="title">pkt</span> =</span> (<span class="keyword">struct</span> jif_pkt*)REQVA;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">envid_t</span> ns_envid = sys_getenvid();</span><br><span class="line">    <span class="type">int</span> i, r;</span><br><span class="line"></span><br><span class="line">    binaryname = <span class="string">&quot;testoutput&quot;</span>;</span><br><span class="line"></span><br><span class="line">    output_envid = fork();</span><br><span class="line">    <span class="keyword">if</span> (output_envid &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;error forking&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (output_envid == <span class="number">0</span>) &#123;</span><br><span class="line">        output(ns_envid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;       </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TESTOUTPUT_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, pkt, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">        pkt-&gt;jp_len = <span class="built_in">snprintf</span>(pkt-&gt;jp_data,</span><br><span class="line">                       PGSIZE - <span class="keyword">sizeof</span>(pkt-&gt;jp_len),</span><br><span class="line">                       <span class="string">&quot;Packet %02d&quot;</span>, i);</span><br><span class="line">        cprintf(<span class="string">&quot;Transmitting packet %d\n&quot;</span>, i);</span><br><span class="line">        ipc_send(output_envid, NSREQ_OUTPUT, pkt, PTE_P|PTE_W|PTE_U);</span><br><span class="line">        sys_page_unmap(<span class="number">0</span>, pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spin for a while, just in case IPC&#x27;s or packets need to be flushed</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TESTOUTPUT_COUNT*<span class="number">2</span>; i++)</span><br><span class="line">        sys_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>testoutput.c</code>中，先<code>fork</code>1个environment，即output environment，然后运行需要实现的<code>output</code>函数，在原先environment中通过<code>ipc_send</code>发送数据包的内容。所以在output environment中，就需要实现通过<code>ipc_recv</code>接受到IPC信息时，如果为<code>NSREQ_OUTPUT</code>，那么调用发包系统调用来发送数据包到网卡驱动。</p>
<h2 id="Part-B-Receiving-packets-and-the-web-server"><a href="#Part-B-Receiving-packets-and-the-web-server" class="headerlink" title="Part B: Receiving packets and the web server"></a>Part B: Receiving packets and the web server</h2><h3 id="Receiving-Packets"><a href="#Receiving-Packets" class="headerlink" title="Receiving Packets"></a>Receiving Packets</h3><p>与发包类似，我们必须配置E1000网卡来接受包并提供接收描述符队列和接收描述符。</p>
<p>接收队列和发送队列非常相似，不同的是它由空的<code>packet buffer</code>组成，等待被即将到来的<code>packet</code>填充。因此，当网络暂停的时候，发送队列是空的，但是接收队列是满的。当E1000接收到一个<code>packet</code>时，它会首先检查这个<code>packet</code>是否满足该网卡的configured filters（比如，这个包的目的地址是不是该E1000的MAC地址）并且忽略那些不符合这些filter的<code>packet</code>。否则，E1000尝试获取从接收队列获取下一个空闲的描述符。如果<code>Head</code>指针（<code>RDH</code>）已经追赶上了<code>Tail</code>指针（<code>RDT</code>），那么说明接收队列已经用完了空闲的descriptor，因此网卡就会丢弃这个<code>packet</code>。如果还有空闲的接收描述符，它会将packet data拷贝到描述符包含的<code>buffer</code>中，并且设置描述符的<code>DD</code>（descriptor done）和<code>EOP</code>（End of Packet）状态位，然后增加<code>RDH</code>。</p>
<p>如果E1000网卡收到一个<code>packet</code>，它的数据大于一个接收描述符的packet buffer，它会继续从接收队列中获取尽可能多的描述符，用来存放<code>packet</code>的所有内容。为了表明这样的情况，它会在每个<code>descriptor</code>中都设置<code>DD</code>状态位，但只在最后一个<code>descriptor</code>中设置<code>EOP</code>状态位。我们可以让驱动对这种情况进行处理，或者只是简单地对对网卡进行配置，让它不接收这样的“long packet”，但是我们要确保我们的receive buffer能够接收最大的标志Ethernet packet（1518字节）。</p>
<p>Exercise 10：建立接收队列和配置E1000网卡，无须支持”long packets”和multicast。暂时不要配置使用中断，同时忽略CRC。</p>
<p>默认情况下，网卡会过滤所有的<code>packet</code>，我们必须配置接收地址寄存器(<code>RAL</code>和<code>RAH</code>)为网卡的MAC地址以使得能接受发送给该网卡的包。目前可以简单地硬编码QEMU的默认MAC地址52:54:00:12:34:56。注意字节顺序MAC地址从左到右是从低地址到高地址的，所以52:54:00:12为低32位，34:56为高16位</p>
<p>E1000网卡只支持一系列特殊的receive buffer大小。假如我们配置receive packet buffers足够大并关闭long packets，那么我们就无需担心跨越多个receive buffer的包。同时记住接收队列和packet buffer也必须是连续的物理内存。我们必需使用至少128个接收描述符。</p>
<p>整个流程跟发包初始化配置类似。主要相关工作如下：</p>
<ul>
<li>设置接受地址寄存器(RAL/RAH)为网卡的MAC地址。</li>
<li>初始化<code>multicast</code>表数组为0。</li>
<li>设置中断相关寄存器的值，这里我们关闭中断</li>
<li>为接收描述符队列分配一块连续空间，设置<code>RDBAL</code>和<code>RDBAH</code>寄存器的值指向起始地址，其中<code>RDBAL</code>为32位地址，<code>RDBAL</code>和<code>RDBAH</code>表示64位地址。</li>
<li>设置<code>RDLEN</code>寄存器的值为描述符队列的大小，以字节计算。</li>
<li>设置接收队列的<code>Head</code>指针(<code>RDH</code>)和<code>Tail</code>指针(<code>RDT</code>)寄存器的值为0。<code>Head</code>指针指向第1个可用的描述符，<code>Tail</code>指向最后1个可用描述符的下一个描述符。如果将<code>Head</code>指针和<code>Tail</code>指针初始化为0，那么将接收不到数据包，应该将<code>Tail</code>指针初始化为最后1个可用描述符即<code>RDLEN-1</code>，因为像上面描述的当<code>RDH</code>等于<code>RDT</code>的时候，网卡认为队列满了，会丢弃数据包。</li>
<li>设置接收控制寄存器<code>RCTL</code>的值，主要包括设置<code>RCTL.EN</code>标志位为1(激活)、<code>RCTL.LBM</code>标志位为00(关闭回环)、<code>RCTL.BSIZE</code>标志位为00和<code>RCTL.BSEX</code>位为0(<code>buffer</code>大小为2048字节)、<code>RCTL.SECRC</code>标志位为1(忽略校验)。</li>
</ul>
<p>下边的代码与上述描述一一对应。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 为描述符列表分配静态内存 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> <span class="title">tx_d</span>[<span class="title">TXRING_LEN</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(<span class="title">PGSIZE</span>)))</span></span><br><span class="line"><span class="class">        =</span> &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span> <span class="title">pbuf</span>[<span class="title">TXRING_LEN</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(<span class="title">PGSIZE</span>)))</span></span><br><span class="line"><span class="class">        =</span> &#123;&#123;&#123;<span class="number">0</span>&#125;&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> <span class="title">rx_d</span>[<span class="title">RXRING_LEN</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(<span class="title">PGSIZE</span>)))</span></span><br><span class="line"><span class="class">        =</span> &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span> <span class="title">prbuf</span>[<span class="title">RXRING_LEN</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(<span class="title">PGSIZE</span>)))</span></span><br><span class="line"><span class="class">        =</span> &#123;&#123;&#123;<span class="number">0</span>&#125;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">init_desc</span><span class="params">()</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; RXRING_LEN; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;rx_d[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(rx_d[i]));</span><br><span class="line">        rx_d[i].addr = PADDR(&amp;prbuf[i]);</span><br><span class="line">        rx_d[i].status = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pci_e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">   e1000[RA/<span class="number">4</span>] = mac[<span class="number">0</span>];</span><br><span class="line">    e1000[RA/<span class="number">4</span>+<span class="number">1</span>] = mac[<span class="number">1</span>];</span><br><span class="line">    e1000[RA/<span class="number">4</span>+<span class="number">1</span>] |= RAV;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;e1000: mac address %x:%x\n&quot;</span>, mac[<span class="number">1</span>], mac[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span>*)&amp;e1000[MTA/<span class="number">4</span>], <span class="number">0</span>, <span class="number">128</span> * <span class="number">4</span>);</span><br><span class="line">    e1000[ICS/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    e1000[IMS/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//e1000[IMC/4] = 0xFFFF;</span></span><br><span class="line">    e1000[RDBAL/<span class="number">4</span>] = PADDR(rx_d);</span><br><span class="line">    e1000[RDBAH/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    e1000[RDLEN/<span class="number">4</span>] = RXRING_LEN * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rx_desc);</span><br><span class="line">    e1000[RDH/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    e1000[RDT/<span class="number">4</span>] = RXRING_LEN - <span class="number">1</span>;</span><br><span class="line">    e1000[RCTL/<span class="number">4</span>] = RCTL_EN | RCTL_LBM_NO | RCTL_SECRC | RCTL_BSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成后，运行<code>make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-net_testinput</code>，<code>testinput</code>会发送ARP广播，QEMU会自动回应。</p>
<p>现在我们要实现接收包。为了接收<code>packet</code>，我们的驱动需要跟踪到底从哪个描述符中获取下一个received packet。和发送时相似，文档中说明从软件中读取RDH寄存器也是不可靠的。所以，为了确定一个<code>packet</code>是否被发送到描述符的packet buffer中，我们需要读取该描述符的<code>DD</code>状态位。如果<code>DD</code>已经被置位，那么我们可以将packet data从描述符的packet buffer中拷贝出来，然后通过更新队列的RDT告诉网卡该描述符已经被释放了。</p>
<p>如果<code>DD</code>没有被置位，那么说明没有接收到任何packet。这和发送端队列已满的情况是一样的，在这种情况下，我们可以做很多事情。我们可以简单地返回一个“try again”的error并且要求调用者继续尝试。这种方法对于发送队列已满的情况是有效的，因为那种情况是短暂的，但是对于空的接收队列就不合适了，因为接收队列可能很长时间处于空的状态。</p>
<p>第二种方法就是将calling environment挂起，直到接收队列中有packet可以处理。这种方法和<code>sys_ipc_recv</code>和相似。就像在IPC中所做的，每个CPU只有一个kernel stack，一旦我们离开kernel，那么栈上的state就会消失。我们需要设置一个<code>flag</code>来表明这个environment是因为接收队列被挂起的并且记录下系统调用参数。这种方法的缺点有点复杂：E1000网卡必须被配置成能产生接收中断并且驱动还需要能够对中断进行处理，为了让等待packet的environment能恢复过来。</p>
<p>Exercise 11：写1个函数来从E1000网卡接收1个包，并添加1个系统调用暴露给用户空间。确保你能处理接收队列为空的情况。</p>
<p>与发包类似，读取<code>RDT</code>寄存器的值，判断最后1个可用描述符的下一个描述符的标志位是否为<code>DD</code>，如果是则拷贝该描述符中的<code>buffer</code>，清除<code>DD</code>位，并增加<code>RDT</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_receive</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tail = (e1000[RDT/<span class="number">4</span>] + <span class="number">1</span>) % RXRING_LEN;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">nxt</span> =</span> &amp;rx_d[tail];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((nxt-&gt;status &amp; RXD_STAT_DD) != RXD_STAT_DD) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nxt-&gt;length &lt; buflen)</span><br><span class="line">        buflen = nxt-&gt;length;</span><br><span class="line"></span><br><span class="line">    memmove(addr, &amp;prbuf[tail], buflen);</span><br><span class="line">    nxt-&gt;status &amp;= !RXD_STAT_DD;</span><br><span class="line">    e1000[RDT/<span class="number">4</span>] = tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buflen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Receiving-Packets-Network-Server"><a href="#Receiving-Packets-Network-Server" class="headerlink" title="Receiving Packets: Network Server"></a>Receiving Packets: Network Server</h3><p>在网络服务器input environment中，我们将需要使用新添加的收包系统调用来接收数据包并通过<code>NSREQ_INPUT IPC</code>消息传递给核心网络服务器environment。</p>
<p>Exercise 12：实现<code>net/input.c</code></p>
<p>回答：这里主要是实现input environment的工作。<code>net/testinput.c</code>是测试收包的代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">envid_t</span> ns_envid = sys_getenvid();</span><br><span class="line">    <span class="type">int</span> i, r, first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    binaryname = <span class="string">&quot;testinput&quot;</span>;</span><br><span class="line"></span><br><span class="line">    output_envid = fork();</span><br><span class="line">    <span class="keyword">if</span> (output_envid &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;error forking&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (output_envid == <span class="number">0</span>) &#123;</span><br><span class="line">        output(ns_envid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input_envid = fork();</span><br><span class="line">    <span class="keyword">if</span> (input_envid &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;error forking&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (input_envid == <span class="number">0</span>) &#123;</span><br><span class="line">        input(ns_envid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;Sending ARP announcement...\n&quot;</span>);</span><br><span class="line">    announce();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">envid_t</span> whom;</span><br><span class="line">        <span class="type">int</span> perm;</span><br><span class="line"></span><br><span class="line">        <span class="type">int32_t</span> req = ipc_recv((<span class="type">int32_t</span> *)&amp;whom, pkt, &amp;perm);</span><br><span class="line">        <span class="keyword">if</span> (req &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;ipc_recv: %e&quot;</span>, req);</span><br><span class="line">        <span class="keyword">if</span> (whom != input_envid)</span><br><span class="line">            panic(<span class="string">&quot;IPC from unexpected environment %08x&quot;</span>, whom);</span><br><span class="line">        <span class="keyword">if</span> (req != NSREQ_INPUT)</span><br><span class="line">            panic(<span class="string">&quot;Unexpected IPC %d&quot;</span>, req);</span><br><span class="line"></span><br><span class="line">        hexdump(<span class="string">&quot;input: &quot;</span>, pkt-&gt;jp_data, pkt-&gt;jp_len);</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only indicate that we&#x27;re waiting for packets once</span></span><br><span class="line">        <span class="comment">// we&#x27;ve received the ARP reply</span></span><br><span class="line">        <span class="keyword">if</span> (first)</span><br><span class="line">            cprintf(<span class="string">&quot;Waiting for packets...\n&quot;</span>);</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>fork</code>了2个新的environment，其中1个执行output，发送ARP广播，另外1个执行input，接收QEMU的回应。通过<code>ipc_recv</code>来获得input environment收到的数据包。</p>
<p>在<code>net/input.c</code>的<code>input</code>函数中通过调用收包系统调用从网卡驱动处获得数据包，这里的注意点是根据注释有可能收包太快，发送给网络服务器，但是网络服务器可能读取过慢，导致相应的内容被冲刷，所以我们采用10页的缓冲来存放从网卡驱动获得的数据包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input</span><span class="params">(<span class="type">envid_t</span> ns_envid)</span></span><br><span class="line">&#123;   </span><br><span class="line">    binaryname = <span class="string">&quot;ns_input&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, r;</span><br><span class="line">    <span class="type">int32_t</span> length;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jif_pkt</span> *<span class="title">cpkt</span> =</span> pkt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, (<span class="type">void</span>*)((<span class="type">uintptr_t</span>)pkt + i * PGSIZE), PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>((length = sys_netpacket_recv((<span class="type">void</span>*)((<span class="type">uintptr_t</span>)cpkt + <span class="keyword">sizeof</span>(cpkt-&gt;jp_len)), PGSIZE - <span class="keyword">sizeof</span>(cpkt-&gt;jp_len))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// cprintf(&quot;len: %d\n&quot;, length);</span></span><br><span class="line">            sys_yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cpkt-&gt;jp_len = length;</span><br><span class="line">        ipc_send(ns_envid, NSREQ_INPUT, cpkt, PTE_P | PTE_U);</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">        cpkt = (<span class="keyword">struct</span> jif_pkt*)((<span class="type">uintptr_t</span>)pkt + i * PGSIZE);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Web-Server"><a href="#The-Web-Server" class="headerlink" title="The Web Server"></a>The Web Server</h3><p>1个简单的web服务器将发送1个文件内容给请求客户端。JOS已经在<code>user/httpd.c</code>文件中提供可骨架代码，处理socket连接和Http头转义。</p>
<p>Exercise 13：实现<code>user/httpd.c</code>文件中的<code>send_file</code>函数和<code>send_data</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">send_file</span><span class="params">(<span class="keyword">struct</span> http_request *req)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">off_t</span> file_size = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(req-&gt;url, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> send_error(req, <span class="number">404</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = fstat(fd, &amp;st)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> send_error(req, <span class="number">404</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st.st_isdir)</span><br><span class="line">        <span class="keyword">return</span> send_error(req, <span class="number">404</span>);</span><br><span class="line"></span><br><span class="line">    file_size = st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = send_header(req, <span class="number">200</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = send_size(req, file_size)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = send_content_type(req)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = send_header_fin(req)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">    r = send_data(req, fd);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">send_data</span><span class="params">(<span class="keyword">struct</span> http_request *req, <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        r = read(fd, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">if</span>(write(req-&gt;sock, buf, r) != r)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/14/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%94%B6%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/14/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%94%B6%E9%9B%86/" class="post-title-link" itemprop="url">常用算法收集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-14 00:50:00" itemprop="dateCreated datePublished" datetime="2021-11-14T00:50:00+08:00">2021-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 18:10:35" itemprop="dateModified" datetime="2022-12-26T18:10:35+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="求二进制数中1的个数"><a href="#求二进制数中1的个数" class="headerlink" title="求二进制数中1的个数"></a>求二进制数中1的个数</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>任意给定一个32位无符号整数n，求n的二进制表示中1的个数，比如n = 5（0101）时，返回2，n = 15（1111）时，返回4</p>
<p>这也是一道比较经典的题目了，相信不少人面试的时候可能遇到过这道题吧，下面介绍了几种方法来实现这道题。</p>
<h2 id="普通法"><a href="#普通法" class="headerlink" title="普通法"></a>普通法</h2><p>移位+计数，这种方法的运算次数与输入n最高位1的位置有关，最多循环32次。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int BitCount(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int c =0 ; // 计数器</span><br><span class="line">    while (n &gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        if((n &amp;1) ==1) // 当前位是1</span><br><span class="line">            ++c ; // 计数器加1</span><br><span class="line">        n &gt;&gt;=1 ; // 移位</span><br><span class="line">    &#125;</span><br><span class="line">    return c ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一个更精简的版本如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int BitCount1(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int c =0 ; // 计数器</span><br><span class="line">    for (c =0; n; n &gt;&gt;=1) // 循环移位</span><br><span class="line">        c += n &amp;1 ; // 如果当前位是1，则计数器加1</span><br><span class="line">    return c ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="快速法"><a href="#快速法" class="headerlink" title="快速法"></a>快速法</h2><p>这种方法速度比较快，其运算次数与输入n的大小无关，只与n中1的个数有关。如果n的二进制表示中有k个1，那么这个方法只需要循环k次即可。其原理是不断清除n的二进制表示中最右边的1，同时累加计数器，直至n为0，代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int BitCount2(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int c =0 ;</span><br><span class="line">    for (c =0; n; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        n &amp;= (n -1) ; // 清除最低位的1</span><br><span class="line">    &#125;</span><br><span class="line">    return c ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为什么n &amp;= (n – 1)能清除最右边的1呢？因为从二进制的角度讲，n相当于在n - 1的最低位加上1。举个例子，8（1000）= 7（0111）+ 1（0001），所以8 &amp; 7 = （1000）&amp;（0111）= 0（0000），清除了8最右边的1（其实就是最高位的1，因为8的二进制中只有一个1）。再比如7（0111）= 6（0110）+ 1（0001），所以7 &amp; 6 = （0111）&amp;（0110）= 6（0110），清除了7的二进制表示中最右边的1（也就是最低位的1）。</p>
<h2 id="查表法"><a href="#查表法" class="headerlink" title="查表法"></a>查表法</h2><h3 id="动态建表"><a href="#动态建表" class="headerlink" title="动态建表"></a>动态建表</h3><p>由于表示在程序运行时动态创建的，所以速度上肯定会慢一些，把这个版本放在这里，有两个原因</p>
<ol>
<li>介绍填表的方法，因为这个方法的确很巧妙。</li>
<li>类型转换，这里不能使用传统的强制转换，而是先取地址再转换成对应的指针类型。也是常用的类型转换方法。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int BitCount3(unsigned int n) </span><br><span class="line">&#123; </span><br><span class="line">    // 建表</span><br><span class="line">    unsigned char BitsSetTable256[256] = &#123;0&#125; ; </span><br><span class="line"></span><br><span class="line">    // 初始化表 </span><br><span class="line">    for (int i =0; i &lt;256; i++) </span><br><span class="line">    &#123; </span><br><span class="line">        BitsSetTable256[i] = (i &amp;1) + BitsSetTable256[i /2]; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    unsigned int c =0 ; </span><br><span class="line"></span><br><span class="line">    // 查表</span><br><span class="line">    unsigned char* p = (unsigned char*) &amp;n ; </span><br><span class="line"></span><br><span class="line">    c = BitsSetTable256[p[0]] + </span><br><span class="line">        BitsSetTable256[p[1]] + </span><br><span class="line">        BitsSetTable256[p[2]] + </span><br><span class="line">        BitsSetTable256[p[3]]; </span><br><span class="line"></span><br><span class="line">    return c ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先说一下填表的原理，根据奇偶性来分析，对于任意一个正整数n</p>
<ol>
<li>如果它是偶数，那么n的二进制中1的个数与n/2中1的个数是相同的，比如4和2的二进制中都有一个1，6和3的二进制中都有两个1。为啥？因为n是由n/2左移一位而来，而移位并不会增加1的个数。</li>
<li>如果n是奇数，那么n的二进制中1的个数是n/2中1的个数+1，比如7的二进制中有三个1，7/2 = 3的二进制中有两个1。为啥？因为当n是奇数时，n相当于n/2左移一位再加1。</li>
</ol>
<p>再说一下查表的原理</p>
<p>对于任意一个32位无符号整数，将其分割为4部分，每部分8bit，对于这四个部分分别求出1的个数，再累加起来即可。而8bit对应2^8 = 256种01组合方式，这也是为什么表的大小为256的原因。</p>
<p>注意类型转换的时候，先取到n的地址，然后转换为unsigned char*，这样一个unsigned int（4 bytes）对应四个unsigned char（1 bytes），分别取出来计算即可。举个例子吧，以87654321（十六进制）为例，先写成二进制形式-8bit一组，共四组，以不同颜色区分，这四组中1的个数分别为4，4，3，2，所以一共是13个1，如下面所示。</p>
<p>10000111 01100101 01000011 00100001 = 4 + 4 + 3 + 2 = 13</p>
<h3 id="静态表-4bit"><a href="#静态表-4bit" class="headerlink" title="静态表-4bit"></a>静态表-4bit</h3><p>原理和8-bit表相同，详见8-bit表的解释<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int BitCount4(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int table[16] = </span><br><span class="line">    &#123;</span><br><span class="line">        0, 1, 1, 2, </span><br><span class="line">        1, 2, 2, 3, </span><br><span class="line">        1, 2, 2, 3, </span><br><span class="line">        2, 3, 3, 4</span><br><span class="line">    &#125; ;</span><br><span class="line"></span><br><span class="line">    unsigned int count =0 ;</span><br><span class="line">    while (n)</span><br><span class="line">    &#123;</span><br><span class="line">        count += table[n &amp;0xf] ;</span><br><span class="line">        n &gt;&gt;=4 ;</span><br><span class="line">    &#125;</span><br><span class="line">    return count ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="静态表-8bit"><a href="#静态表-8bit" class="headerlink" title="静态表-8bit"></a>静态表-8bit</h3><p>首先构造一个包含256个元素的表table，table[i]即i中1的个数，这里的i是[0-255]之间任意一个值。然后对于任意一个32bit无符号整数n，我们将其拆分成四个8bit，然后分别求出每个8bit中1的个数，再累加求和即可，这里用移位的方法，每次右移8位，并与0xff相与，取得最低位的8bit，累加后继续移位，如此往复，直到n为0。所以对于任意一个32位整数，需要查表4次。以十进制数2882400018为例，其对应的二进制数为10101011110011011110111100010010，对应的四次查表过程如下：红色表示当前8bit，绿色表示右移后高位补零。</p>
<p>第一次（n &amp; 0xff）             10101011110011011110111100010010</p>
<p>第二次（(n &gt;&gt; 8) &amp; 0xff）  00000000101010111100110111101111</p>
<p>第三次（(n &gt;&gt; 16) &amp; 0xff）00000000000000001010101111001101</p>
<p>第四次（(n &gt;&gt; 24) &amp; 0xff）00000000000000000000000010101011</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int BitCount7(unsigned int n)</span><br><span class="line">&#123; </span><br><span class="line">    unsigned int table[256] = </span><br><span class="line">    &#123; </span><br><span class="line">        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, </span><br><span class="line">        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, </span><br><span class="line">        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, </span><br><span class="line">        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, </span><br><span class="line">        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, </span><br><span class="line">        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, </span><br><span class="line">        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, </span><br><span class="line">        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, </span><br><span class="line">        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, </span><br><span class="line">        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, </span><br><span class="line">        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, </span><br><span class="line">        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, </span><br><span class="line">        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, </span><br><span class="line">        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, </span><br><span class="line">        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, </span><br><span class="line">        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, </span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    return table[n &amp;0xff] +</span><br><span class="line">        table[(n &gt;&gt;8) &amp;0xff] +</span><br><span class="line">        table[(n &gt;&gt;16) &amp;0xff] +</span><br><span class="line">        table[(n &gt;&gt;24) &amp;0xff] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以搞一个16bit的表，或者更极端一点32bit的表，速度将会更快。</p>
<h2 id="平行算法"><a href="#平行算法" class="headerlink" title="平行算法"></a>平行算法</h2><p>网上都这么叫，我也这么叫吧，不过话说回来，的确有平行的意味在里面，先看代码，稍后解释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int BitCount4(unsigned int n) </span><br><span class="line">&#123; </span><br><span class="line">    n = (n &amp;0x55555555) + ((n &gt;&gt;1) &amp;0x55555555) ; </span><br><span class="line">    n = (n &amp;0x33333333) + ((n &gt;&gt;2) &amp;0x33333333) ; </span><br><span class="line">    n = (n &amp;0x0f0f0f0f) + ((n &gt;&gt;4) &amp;0x0f0f0f0f) ; </span><br><span class="line">    n = (n &amp;0x00ff00ff) + ((n &gt;&gt;8) &amp;0x00ff00ff) ; </span><br><span class="line">    n = (n &amp;0x0000ffff) + ((n &gt;&gt;16) &amp;0x0000ffff) ; </span><br><span class="line"></span><br><span class="line">    return n ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>速度不一定最快，但是想法绝对巧妙。 说一下其中奥妙，其实很简单，先将n写成二进制形式，然后相邻位相加，重复这个过程，直到只剩下一位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int BitCount5(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int tmp = n - ((n &gt;&gt;1) &amp;033333333333) - ((n &gt;&gt;2) &amp;011111111111);</span><br><span class="line">    return ((tmp + (tmp &gt;&gt;3)) &amp;030707070707) %63;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最喜欢这个，代码太简洁啦，只是有个取模运算，可能速度上慢一些。区区两行代码，就能计算出1的个数，到底有何奥妙呢？为了解释的清楚一点，我尽量多说几句。</p>
<p>第一行代码的作用：先说明一点，以0开头的是8进制数，以0x开头的是十六进制数，上面代码中使用了三个8进制数。</p>
<p>将n的二进制表示写出来，然后每3bit分成一组，求出每一组中1的个数，再表示成二进制的形式。比如n = 50，其二进制表示为110010，分组后是110和010，这两组中1的个数本别是2和3。2对应010，3对应011，所以第一行代码结束后，tmp = 010011，具体是怎么实现的呢？由于每组3bit，所以这3bit对应的十进制数都能表示为2^2 <em> a + 2^1 </em> b + c的形式，也就是4a + 2b + c的形式，这里a,b,c的值为0或1，如果为0表示对应的二进制位上是0，如果为1表示对应的二进制位上是1，所以a + b + c的值也就是4a + 2b + c的二进制数中1的个数了。举个例子，十进制数6（0110）= 4 <em> 1 + 2 </em> 1 + 0，这里a = 1, b = 1, c = 0, a + b + c = 2，所以6的二进制表示中有两个1。现在的问题是，如何得到a + b + c呢？注意位运算中，右移一位相当于除2，就利用这个性质！</p>
<p>4a + 2b + c 右移一位等于2a + b</p>
<p>4a + 2b + c 右移量位等于a</p>
<p>然后做减法</p>
<p>4a + 2b + c –(2a + b) – a = a + b + c，这就是第一行代码所作的事，明白了吧。</p>
<p>第二行代码的作用：在第一行的基础上，将tmp中相邻的两组中1的个数累加，由于累加到过程中有些组被重复加了一次，所以要舍弃这些多加的部分，这就是&amp;030707070707的作用，又由于最终结果可能大于63，所以要取模。</p>
<p>需要注意的是，经过第一行代码后，从右侧起，每相邻的3bit只有四种可能，即000, 001, 010, 011，为啥呢？因为每3bit中1的个数最多为3。所以下面的加法中不存在进位的问题，因为3 + 3 = 6，不足8，不会产生进位。</p>
<p>tmp + (tmp &gt;&gt; 3)-这句就是是相邻组相加，注意会产生重复相加的部分，比如tmp = 659 = 001 010 010 011时，tmp &gt;&gt; 3 = 000 001 010 010，相加得</p>
<p>001 010 010 011</p>
<p>000 001 010 010</p>
<hr>
<p>001 011 100 101</p>
<p>011 + 101 = 3 + 5 = 8。（感谢网友Di哈指正。）注意，659只是个中间变量，这个结果不代表659这个数的二进制形式中有8个1。</p>
<p>注意我们想要的只是第二组和最后一组（绿色部分），而第一组和第三组（红色部分）属于重复相加的部分，要消除掉，这就是&amp;030707070707所完成的任务（每隔三位删除三位），最后为什么还要%63呢？因为上面相当于每次计算相连的6bit中1的个数，最多是111111 = 77（八进制）= 63（十进制），所以最后要对63取模。</p>
<h2 id="位标志法"><a href="#位标志法" class="headerlink" title="位标志法"></a>位标志法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct _byte </span><br><span class="line">&#123; </span><br><span class="line">    unsigned a:1; </span><br><span class="line">    unsigned b:1; </span><br><span class="line">    unsigned c:1; </span><br><span class="line">    unsigned d:1; </span><br><span class="line">    unsigned e:1; </span><br><span class="line">    unsigned f:1; </span><br><span class="line">    unsigned g:1; </span><br><span class="line">    unsigned h:1; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">long get_bit_count( unsigned char b ) </span><br><span class="line">&#123;</span><br><span class="line">    struct _byte *by = (struct _byte*)&amp;b; </span><br><span class="line">    return (by-&gt;a+by-&gt;b+by-&gt;c+by-&gt;d+by-&gt;e+by-&gt;f+by-&gt;g+by-&gt;h); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指令法"><a href="#指令法" class="headerlink" title="指令法"></a>指令法</h2><p>使用微软提供的指令，首先要确保你的CPU支持SSE4指令，用Everest和CPU-Z可以查看是否支持。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int n =127 ;</span><br><span class="line">unsigned int bitCount = _mm_popcnt_u32(n) ;</span><br></pre></td></tr></table></figure></p>
<h1 id="快速幂、快速幂取模"><a href="#快速幂、快速幂取模" class="headerlink" title="快速幂、快速幂取模"></a>快速幂、快速幂取模</h1><h2 id="大数模幂运算的缺陷"><a href="#大数模幂运算的缺陷" class="headerlink" title="大数模幂运算的缺陷"></a>大数模幂运算的缺陷</h2><p>快速幂取模算法的引入是从大数的小数取模的朴素算法的局限性所提出的，在朴素的方法中我们计算一个数比如5^1003%31是非常消耗我们的计算资源的，在整个计算过程中最麻烦的就是我们的5^1003这个过程</p>
<ul>
<li>缺点1：在我们在之后计算指数的过程中，计算的数字不都拿得增大，非常的占用我们的计算资源（主要是时间，还有空间）</li>
<li>缺点2：我们计算的中间过程数字大的恐怖，我们现有的计算机是没有办法记录这么长的数据的，所以说我们必须要想一个更加高效的方法来解决这个问题</li>
</ul>
<h2 id="快速幂的引入"><a href="#快速幂的引入" class="headerlink" title="快速幂的引入"></a>快速幂的引入</h2><p>我们首先从优化的过程开始一步一步优化我们的模幂算法<br>1.朴素模幂运算过程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define ans=1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=b;i++)</span><br><span class="line">&#123;</span><br><span class="line">    ans*=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>根据我们上面说的，这种算法是非常的无法容忍的，我们在计算的过程中出现的两个缺点在这里都有体现<br>在这里我们如果要做优化的话，我肥就是每个过程中都加一次模运算，但是我们首先要记住模运算是非常的消耗内存资源的，在计算的次数非常的大的时候，我们是没有办法忍受这种时间耗费的<br>2.快速幂引入：<br>在讲解快速幂取模算法之前，我们先将几个必备的知识</p>
<p>1.对于取模运算：<code>(a*b)%c=(a%c)*(b%c)%c</code>，这个是成立的：也是我们实现快速幂的基础。之后我们来看看快速幂的核心本质。</p>
<p>在这里，我们对指数动了一些手脚，核心思想在于：将大数的幂运算拆解成了相对应的乘法运算，利用上面的式子，始终将我们的运算的数据量控制在c的范围以下，这样我们可以客服朴素的算法的缺点二，我们将计算的数据量压缩了很大一部分，当指数非常大的时候这个优化是更加显著的，我们用Python来做一个实验来看看就知道我们优化的效率有多高了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">orginal_algorithm</span>(<span class="params">a,b,c</span>):  <span class="comment">#a^b%c</span></span><br><span class="line">    ans=<span class="number">1</span></span><br><span class="line">    a=a%c  <span class="comment">#预处理，防止出现a比c大的情况</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b):</span><br><span class="line">        ans=(ans*a)%c</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_algorithm</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    a=a%c</span><br><span class="line">    ans=<span class="number">1</span></span><br><span class="line">    <span class="comment">#这里我们不需要考虑b&lt;0，因为分数没有取模运算</span></span><br><span class="line">    <span class="keyword">while</span> b!=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> b&amp;<span class="number">1</span>:</span><br><span class="line">            ans=(ans*a)%c</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span></span><br><span class="line">        a=(a*a)%c</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"> </span><br><span class="line">time=clock()</span><br><span class="line">a=<span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;底数:&quot;</span>))</span><br><span class="line">b=<span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;指数:&quot;</span>))</span><br><span class="line">c=<span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;模:&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;朴素算法结果%d&quot;</span>%(orginal_algorithm(a,b,c)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;朴素算法耗时:%f&quot;</span>%(clock()-time))</span><br><span class="line">time=clock()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;快速幂算法结果%d&quot;</span>%(quick_algorithm(a,b,c)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;快速幂算法耗时:%f&quot;</span>%(clock()-time))</span><br></pre></td></tr></table></figure>
<p>实验结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">底数:5</span><br><span class="line">指数:1003</span><br><span class="line">模:12</span><br><span class="line">朴素算法结果5</span><br><span class="line">朴素算法耗时:3.289952</span><br><span class="line">快速幂算法结果5</span><br><span class="line">快速幂算法耗时:0.006706</span><br></pre></td></tr></table></figure></p>
<p>我们现在知道了快速幂取模算法的强大了，我们现在来看核心原理：对于任何一个整数的模幂运算：<code>a^b%c</code>，对于b我们可以拆成二进制的形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b=b0+b1*2+b2*2^2+...+bn*2^n</span><br></pre></td></tr></table></figure><br>这里我们的b0对应的是b二进制的第一位，那么我们的a^b运算就可以拆解成<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a^b0*a^b1*2*...*a^(bn*2^n)</span><br></pre></td></tr></table></figure><br>对于b来说，二进制位不是0就是1，那么对于bx为0的项我们的计算结果是1就不用考虑了，我们真正想要的其实是b的非0二进制位。那么假设除去了b的0的二进制位之后我们得到的式子是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a^(bx*2^x)*...*a(bn*2^n)</span><br></pre></td></tr></table></figure><br>这里我们再应用我们一开始提到的公式，那么我们的a^b%c运算就可以转化为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a^(bx*2^x)%c）*...*(a^(bn*2^n)%c)</span><br></pre></td></tr></table></figure><br>这样的话，我们就很接近快速幂的本质了<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a^(bx*2^x)%c)*...*(a^(bn*2^n)%c)</span><br></pre></td></tr></table></figure><br>我们会发现令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A1=(a^(bx*2^x)%c)</span><br><span class="line">...</span><br><span class="line">An=(a^(bn*2^n)%c)</span><br></pre></td></tr></table></figure><br>这样的话，An始终是A(n-1)的平方倍（当然加进去了取模匀速那），依次递推。现在，我们基本的内容都已经了解到了，现在我们来考虑实现它：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int quick(int a,int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">	int ans=1;   //记录结果</span><br><span class="line">	a=a%c;   //预处理，使得a处于c的数据范围之下</span><br><span class="line">	while(b!=0)</span><br><span class="line">	&#123;</span><br><span class="line">		if(b&amp;1) ans=(ans*a)%c;   //如果b的二进制位不是0，那么我们的结果是要参与运算的</span><br><span class="line">		b&gt;&gt;=1;    //二进制的移位操作，相当于每次除以2，用二进制看，就是我们不断的遍历b的二进制位</span><br><span class="line">		a=(a*a)%c;   //不断的加倍</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在，我们的快速幂已经讲完了。我们来大致的推演一下快速幂取模算法的时间复杂度。首先，我们会观察到，我们每次都是将b的规模缩小了2倍，那么很显然，原本的朴素的时间复杂度是O(n)。快速幂的时间复杂度就是O(logn)无限接近常熟的时间复杂度无疑逼朴素的时间复杂度优秀很多，在数据量越大的时候，者中优化效果越明显。</p>
<h2 id="OJ例题"><a href="#OJ例题" class="headerlink" title="OJ例题"></a>OJ例题</h2><p>POJ1995题意：快速幂版题<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;iostream&quot;</span><br><span class="line">#include&quot;cstdio&quot;</span><br><span class="line">#include&quot;cstring&quot;</span><br><span class="line">#include&quot;cstdlib&quot;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int ans=0;</span><br><span class="line">int a,b;</span><br><span class="line">int c;</span><br><span class="line"> </span><br><span class="line">int quick(int a,int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">	int ans=1;</span><br><span class="line">	a=a%c;</span><br><span class="line">	while(b!=0)</span><br><span class="line">	&#123;</span><br><span class="line">		if(b&amp;1) ans=(ans*a)%c;</span><br><span class="line">		b&gt;&gt;=1;</span><br><span class="line">		a=(a*a)%c;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int for_;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=0;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;c,&amp;for_);</span><br><span class="line">		for(int i=1;i&lt;=for_;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">			ans=(ans+quick(a,b,c))%c;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ol>
<li>所有非叶子结点至多拥有两个儿子（Left和Right）；</li>
<li>所有结点存储一个关键字；</li>
<li>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</li>
</ol>
<p>二叉树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果二叉树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么二叉树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变二叉树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；</p>
<p><img src="/img/20211114005300.jpg" alt=""></p>
<p>但二叉树在经过多次插入与删除后，有可能导致不同的结构：<br><img src="/img/20211114005301.jpg" alt=""></p>
<p>右边也是一个二叉树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的树结构索引；所以，使用二叉树还要考虑尽可能让二叉树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；实际使用的二叉树都是在原二叉树的基础上加上平衡算法，即“平衡二叉树”；如何保持二叉树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在二叉树中插入和删除结点的策略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    //左孩子</span><br><span class="line">    TreeNode left;</span><br><span class="line">    //右孩子</span><br><span class="line">    TreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉树的题目普遍可以用递归和迭代的方式来解</p>
<ol>
<li>求二叉树的最大深度</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDeath</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==null)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">maxDeath</span>(node.left);</span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">maxDeath</span>(node.right);</span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">max</span>(left,right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>求二叉树的最小深度</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMinDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">getMin</span>(root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">          <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(root.left == null&amp;&amp;root.right == null)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Math.<span class="built_in">min</span>(<span class="built_in">getMin</span>(root.left),<span class="built_in">getMin</span>(root.right)) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>求二叉树中节点的个数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numOfTreeNode</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> left = <span class="built_in">numOfTreeNode</span>(root.left);</span><br><span class="line">      <span class="type">int</span> right = <span class="built_in">numOfTreeNode</span>(root.right);</span><br><span class="line">      <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>求二叉树中叶子节点的个数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">int</span> <span class="title">numsOfNoChildNode</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left==null&amp;&amp;root.right==null)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">numsOfNodeTreeNode</span>(root.left)+<span class="built_in">numsOfNodeTreeNode</span>(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>求二叉树中第k层节点的个数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numsOfkLevelTreeNode</span><span class="params">(TreeNode root,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == null||k&lt;<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> numsLeft = <span class="built_in">numsOfkLevelTreeNode</span>(root.left,k<span class="number">-1</span>);</span><br><span class="line">      <span class="type">int</span> numsRight = <span class="built_in">numsOfkLevelTreeNode</span>(root.right,k<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">return</span> numsLeft + numsRight;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断二叉树是否是平衡二叉树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">isBalanced</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">maxDeath2</span>(node)!=<span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">maxDeath2</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(node == null)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> left = <span class="built_in">maxDeath2</span>(node.left);</span><br><span class="line">       <span class="type">int</span> right = <span class="built_in">maxDeath2</span>(node.right);</span><br><span class="line">       <span class="keyword">if</span>(left==<span class="number">-1</span>||right==<span class="number">-1</span>||Math.<span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Math.<span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断二叉树是否是完全二叉树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">isCompleteTreeNode</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="built_in">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">     queue.<span class="built_in">add</span>(root);</span><br><span class="line">     boolean result = <span class="literal">true</span>;</span><br><span class="line">     boolean hasNoChild = <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">while</span>(!queue.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">         TreeNode current = queue.<span class="built_in">remove</span>();</span><br><span class="line">         <span class="keyword">if</span>(hasNoChild)&#123;</span><br><span class="line">             <span class="keyword">if</span>(current.left!=null||current.right!=null)&#123;</span><br><span class="line">                 result = <span class="literal">false</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(current.left!=null&amp;&amp;current.right!=null)&#123;</span><br><span class="line">                 queue.<span class="built_in">add</span>(current.left);</span><br><span class="line">                 queue.<span class="built_in">add</span>(current.right);</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current.left!=null&amp;&amp;current.right==null)&#123;</span><br><span class="line">                 queue.<span class="built_in">add</span>(current.left);</span><br><span class="line">                 hasNoChild = <span class="literal">true</span>;</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current.left==null&amp;&amp;current.right!=null)&#123;</span><br><span class="line">                 result = <span class="literal">false</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 hasNoChild = <span class="literal">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>两个二叉树是否完全相同</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">isSameTreeNode</span><span class="params">(TreeNode t1,TreeNode t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1==null&amp;&amp;t2==null)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t1==null||t2==null)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t<span class="number">1.</span>val != t<span class="number">2.</span>val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean left = <span class="built_in">isSameTreeNode</span>(t<span class="number">1.l</span>eft,t<span class="number">2.l</span>eft);</span><br><span class="line">    boolean right = <span class="built_in">isSameTreeNode</span>(t<span class="number">1.</span>right,t<span class="number">2.</span>right);</span><br><span class="line">    <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>两个二叉树是否互为镜像</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">boolean <span class="title">isMirror</span><span class="params">(TreeNode t1,TreeNode t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1==null&amp;&amp;t2==null)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t1==null||t2==null)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t<span class="number">1.</span>val != t<span class="number">2.</span>val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isMirror</span>(t<span class="number">1.l</span>eft,t<span class="number">2.</span>right)&amp;&amp;<span class="built_in">isMirror</span>(t<span class="number">1.</span>right,t<span class="number">2.l</span>eft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>翻转二叉树or镜像二叉树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">TreeNode <span class="title">mirrorTreeNode</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode left = <span class="built_in">mirrorTreeNode</span>(root.left);</span><br><span class="line">    TreeNode right = <span class="built_in">mirrorTreeNode</span>(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>求两个二叉树的最低公共祖先节点</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">getLastCommonParent</span><span class="params">(TreeNode root,TreeNode t1,TreeNode t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">findNode</span>(root.left,t1))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">findNode</span>(root.right,t2))&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getLastCommonParent</span>(root.left,t1,t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">findNode</span>(root.left,t2))&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getLastCommonParent</span>(root.right,t1,t2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找节点node是否在当前 二叉树中</span></span><br><span class="line">boolean <span class="built_in">findNode</span>(TreeNode root,TreeNode node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null || node == null)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root == node)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean found = <span class="built_in">findNode</span>(root.left,node);</span><br><span class="line">    <span class="keyword">if</span>(!found)&#123;</span><br><span class="line">        found = <span class="built_in">findNode</span>(root.right,node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>二叉树的前序遍历</li>
</ol>
<p>迭代解法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">ArrayList&lt;Integer&gt; <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="built_in">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode node = stack.<span class="built_in">pop</span>();</span><br><span class="line">            list.<span class="built_in">add</span>(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=null)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != null)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">```C++</span><br><span class="line"></span><br><span class="line">递归解法</span><br><span class="line">```C++</span><br><span class="line">  <span class="function">ArrayList&lt;Integer&gt; <span class="title">preOrderReverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="built_in">preOrder2</span>(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder2</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">add</span>(root.val);</span><br><span class="line">        <span class="built_in">preOrder2</span>(root.left,result);</span><br><span class="line">        <span class="built_in">preOrder2</span>(root.right,result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>二叉树的中序遍历</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ArrayList&lt;Integer&gt; <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&lt;Integer&gt;();</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="built_in">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">      TreeNode current = root;</span><br><span class="line">      <span class="keyword">while</span>(current != null|| !stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">          <span class="keyword">while</span>(current != null)&#123;</span><br><span class="line">              stack.<span class="built_in">add</span>(current);</span><br><span class="line">              current = current.left;</span><br><span class="line">          &#125;</span><br><span class="line">          current = stack.<span class="built_in">peek</span>();</span><br><span class="line">          stack.<span class="built_in">pop</span>();</span><br><span class="line">          list.<span class="built_in">add</span>(current.val);</span><br><span class="line">          current = current.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>二叉树的后序遍历</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ArrayList&lt;Integer&gt; <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">      <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">          <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">      list.<span class="built_in">addAll</span>(<span class="built_in">postOrder</span>(root.left));</span><br><span class="line">      list.<span class="built_in">addAll</span>(<span class="built_in">postOrder</span>(root.right));</span><br><span class="line">      list.<span class="built_in">add</span>(root.val);</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>前序遍历和后序遍历构造二叉树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">buildTreeNode</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(preorder.length!=inorder.length)&#123;</span><br><span class="line">          <span class="keyword">return</span> null;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">myBuildTree</span>(inorder,<span class="number">0</span>,inorder.length<span class="number">-1</span>,preorder,<span class="number">0</span>,preorder.length<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">TreeNode <span class="title">myBuildTree</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span> instart,<span class="type">int</span> inend,<span class="type">int</span>[] preorder,<span class="type">int</span> prestart,<span class="type">int</span> preend)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instart&gt;inend)&#123;</span><br><span class="line">          <span class="keyword">return</span> null;</span><br><span class="line">      &#125;</span><br><span class="line">      TreeNode root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[prestart]);</span><br><span class="line">      <span class="type">int</span> position = <span class="built_in">findPosition</span>(inorder,instart,inend,preorder[start]);</span><br><span class="line">      root.left = <span class="built_in">myBuildTree</span>(inorder,instart,position<span class="number">-1</span>,preorder,prestart<span class="number">+1</span>,prestart+position-instart);</span><br><span class="line">      root.right = <span class="built_in">myBuildTree</span>(inorder,position<span class="number">+1</span>,inend,preorder,position-inend+preend<span class="number">+1</span>,preend);</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findPosition</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">      <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">for</span>(i = start;i&lt;=end;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[i] == key)&#123;</span><br><span class="line">              <span class="keyword">return</span> i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在二叉树中插入节点</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">insertNode</span><span class="params">(TreeNode root,TreeNode node)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root == node)&#123;</span><br><span class="line">         <span class="keyword">return</span> node;</span><br><span class="line">     &#125;</span><br><span class="line">     TreeNode tmp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">     tmp = root;</span><br><span class="line">     TreeNode last = null;</span><br><span class="line">     <span class="keyword">while</span>(tmp!=null)&#123;</span><br><span class="line">         last = tmp;</span><br><span class="line">         <span class="keyword">if</span>(tmp.val&gt;node.val)&#123;</span><br><span class="line">             tmp = tmp.left;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             tmp = tmp.right;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(last!=null)&#123;</span><br><span class="line">         <span class="keyword">if</span>(last.val&gt;node.val)&#123;</span><br><span class="line">             last.left = node;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             last.right = node;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">findPath</span><span class="params">(TreeNode r,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="built_in">Stack</span>&lt;Integer&gt;();</span><br><span class="line">     <span class="type">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">findPath</span>(r, i, stack, currentSum);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">findPath</span><span class="params">(TreeNode r,<span class="type">int</span> i,Stack&lt;Integer&gt; stack,<span class="type">int</span> currentSum)</span></span>&#123;</span><br><span class="line">     currentSum+=r.val;</span><br><span class="line">     stack.<span class="built_in">push</span>(r.val);</span><br><span class="line">     <span class="keyword">if</span>(r.left==null&amp;&amp;r.right==null)&#123;</span><br><span class="line">         <span class="keyword">if</span>(currentSum==i)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> path:stack)&#123;</span><br><span class="line">                 System.out.<span class="built_in">println</span>(path);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(r.left!=null)&#123;</span><br><span class="line">         <span class="built_in">findPath</span>(r.left, i, stack, currentSum);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(r.right!=null)&#123;</span><br><span class="line">         <span class="built_in">findPath</span>(r.right, i, stack, currentSum);</span><br><span class="line">     &#125;</span><br><span class="line">     stack.<span class="built_in">pop</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>二叉树的搜索区间<br>给定两个值 k1 和 k2（k1 &lt; k2）和一个二叉查找树的根节点。找到树中所有值在 k1 到 k2 范围内的节点。即打印所有x (k1 &lt;= x &lt;= k2) 其中 x 是二叉查找树的中的节点值。返回所有升序的节点值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; result;</span><br><span class="line">  <span class="function">ArrayList&lt;Integer&gt; <span class="title">searchRange</span><span class="params">(TreeNode root,<span class="type">int</span> k1,<span class="type">int</span> k2)</span></span>&#123;</span><br><span class="line">      result = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">      <span class="built_in">searchHelper</span>(root,k1,k2);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">searchHelper</span><span class="params">(TreeNode root,<span class="type">int</span> k1,<span class="type">int</span> k2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(root.val&gt;k1)&#123;</span><br><span class="line">          <span class="built_in">searchHelper</span>(root.left,k1,k2);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(root.val&gt;=k1&amp;&amp;root.val&lt;=k2)&#123;</span><br><span class="line">          result.<span class="built_in">add</span>(root.val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(root.val&lt;k2)&#123;</span><br><span class="line">          <span class="built_in">searchHelper</span>(root.right,k1,k2);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>二叉树的层次遍历</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode root)&#123;</span><br><span class="line">      ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">      <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="built_in">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">      queue.<span class="built_in">offer</span>(root);</span><br><span class="line">      <span class="keyword">while</span>(!queue.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">          <span class="type">int</span> size = queue.<span class="built_in">size</span>();</span><br><span class="line">          ArrayList&lt;&lt;Integer&gt; level = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;Integer&gt;():</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size ;i++)&#123;</span><br><span class="line">              TreeNode node = queue.<span class="built_in">poll</span>();</span><br><span class="line">              level.<span class="built_in">add</span>(node.val);</span><br><span class="line">              <span class="keyword">if</span>(node.left != null)&#123;</span><br><span class="line">                  queue.<span class="built_in">offer</span>(node.left);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(node.right != null)&#123;</span><br><span class="line">                  queue.<span class="built_in">offer</span>(node.right);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; </span><br><span class="line">          result.<span class="built_in">add</span>(Level);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>二叉树内两个节点的最长距离<br>二叉树中两个节点的最长距离可能有三种情况：</li>
</ol>
<ul>
<li>左子树的最大深度+右子树的最大深度为二叉树的最长距离</li>
<li>左子树中的最长距离即为二叉树的最长距离</li>
<li>右子树种的最长距离即为二叉树的最长距离</li>
</ul>
<p>因此，递归求解即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">Result</span>&#123;  </span><br><span class="line">    <span class="type">int</span> maxDistance;  </span><br><span class="line">    <span class="type">int</span> maxDepth;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(<span class="type">int</span> maxDistance, <span class="type">int</span> maxDepth)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.maxDistance = maxDistance;  </span><br><span class="line">        <span class="keyword">this</span>.maxDepth = maxDepth;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxDistance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">getMaxDistanceResult</span>(root).maxDistance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Result <span class="title">getMaxDistanceResult</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            Result empty = <span class="keyword">new</span> <span class="built_in">Result</span>(<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> empty;</span><br><span class="line">        &#125;</span><br><span class="line">        Result lmd = <span class="built_in">getMaxDistanceResult</span>(root.left);</span><br><span class="line">        Result rmd = <span class="built_in">getMaxDistanceResult</span>(root.right);</span><br><span class="line">        Result result = <span class="keyword">new</span> <span class="built_in">Result</span>();</span><br><span class="line">        result.maxDepth = Math.<span class="built_in">max</span>(lmd.maxDepth,rmd.maxDepth) + <span class="number">1</span>;</span><br><span class="line">        result.maxDistance = Math.<span class="built_in">max</span>(lmd.maxDepth + rmd.maxDepth,Math.<span class="built_in">max</span>(lmd.maxDistance,rmd.maxDistance));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>不同的二叉树<br>给出 n，问由 1…n 为节点组成的不同的二叉查找树有多少种？</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;</span><br><span class="line">      <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="type">int</span>[n<span class="number">+2</span>];</span><br><span class="line">      counts[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      counts[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">              counts[i] += counts[j] * counts[i-j<span class="number">-1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> counts[n];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断二叉树是否是合法的二叉查找树(BST)<br>一棵BST定义为：</li>
</ol>
<ul>
<li>节点的左子树中的值要严格小于该节点的值。</li>
<li>节点的右子树中的值要严格大于该节点的值。</li>
<li>左右子树也必须是二叉查找树。</li>
</ul>
<p>一个节点的树也是二叉查找树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> lastVal = Integer.MAX_VALUE;</span><br><span class="line">   <span class="keyword">public</span> boolean firstNode = <span class="literal">true</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> boolean <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// write your code here</span></span><br><span class="line">       <span class="keyword">if</span>(root==null)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(!<span class="built_in">isValidBST</span>(root.left))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(!firstNode&amp;&amp;lastVal &gt;= root.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       firstNode = <span class="literal">false</span>;</span><br><span class="line">       lastVal = root.val;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="built_in">isValidBST</span>(root.right)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h2><ol>
<li>加线。在所有兄弟结点之间加一条连线。</li>
<li>去线。树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。</li>
<li>层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）</li>
</ol>
<p><img src="/img/2012110416594150.jpg" alt=""></p>
<h2 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h2><ol>
<li>把每棵树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。</li>
</ol>
<p><img src="/img/2012110417004247.jpg" alt=""></p>
<h2 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h2><p>是树转换为二叉树的逆过程。</p>
<ol>
<li>加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。</li>
<li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li>
<li>层次调整。</li>
</ol>
<p><img src="/img/2012110417011138.jpg" alt=""></p>
<h2 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h2><p>假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树。</p>
<ol>
<li>从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除…。直到所有这些根节点与右孩子的连线都删除为止。</li>
<li>将每棵分离后的二叉树转换为树。</li>
</ol>
<p><img src="/img/2012110417014911.jpg" alt=""></p>
<h1 id="2-3-树"><a href="#2-3-树" class="headerlink" title="2-3 树"></a>2-3 树</h1><p>2-3 树的定义如下：</p>
<ol>
<li>2-3 树要么为空要么具有以下性质：</li>
<li>对于 2- 节点，和普通的 BST 节点一样，有一个数据域和两个子节点指针，两个子节点要么为空，要么也是一个2-3树，当前节点的数据的值要大于左子树中所有节点的数据，要小于右子树中所有节点的数据。</li>
<li>对于 3- 节点，有两个数据域 a 和 b 和三个子节点指针，左子树中所有的节点数据要小于a，中子树中所有节点数据要大于 a 而小于 b ，右子树中所有节点数据要大于 b 。</li>
</ol>
<p>例如图 2.1 所示的树为一棵 2-3 树：<br><img src="/img/48e19c1215d19ce879969eaded83857a.png" alt=""></p>
<h2 id="2-3-树性质"><a href="#2-3-树性质" class="headerlink" title="2-3 树性质"></a>2-3 树性质</h2><p>性质：</p>
<ol>
<li>对于每一个结点有 1 或者 2 个关键码。</li>
<li>当节点有一个关键码的时，节点有 2 个子树。</li>
<li>当节点有 2 个关键码时，节点有 3 个子树。</li>
<li>所有叶子点都在树的同一层。</li>
</ol>
<h2 id="2-3树查找"><a href="#2-3树查找" class="headerlink" title="2-3树查找"></a>2-3树查找</h2><p>2-3 树的查找类似二叉搜索树的查找过程，根据键值的比较来决定查找的方向。</p>
<p>例如在图 2.1 所示的 2-3 树中查找键为H的节点：<br><img src="/img/8a27a65b20d282c20b086d7289a5c8bc.jpg" alt=""></p>
<p>例如在图 2.1 所示的 2-3 树中查找键为 B 的节点：<br><img src="/img/883755cf230779f56d5a0aecc6c4af8b.jpg" alt=""></p>
<h2 id="2-3树插入"><a href="#2-3树插入" class="headerlink" title="2-3树插入"></a>2-3树插入</h2><p>在树的插入之前需要对带插入的节点进行一次查找操作，若树中已经有此节点则不予插入，若没有查找到此节点则记录未命中查找结束时访问的最后一个节点。</p>
<p>空树的插入最简单，创建一个节点即可，这里不予赘述。</p>
<p>对于非空树插入主要分为 4 种情况：</p>
<ol>
<li>向 2- 节点中插入新节点</li>
<li>向一棵只含 3- 节点的树中插入新节点</li>
<li>向一个父节点为 2- 节点的 3- 节点中插入新节点</li>
<li>向一个父节点为 3- 节点的 3- 节点中插入新节点</li>
</ol>
<p>向2-节点中插入新节点的操作步骤：如果未命中查找结束于一个 2-节点，直接将 2- 节点替换为一个 3- 节点，并将要插入的键保存在其中。</p>
<p>图解：<br><img src="/img/eda14ebcb2f586f09385f18608fb7af1.png" alt=""></p>
<p><img src="/img/3c09f162bdd31bf42dbc3e0147813f3f.jpg" alt=""></p>
<p>向一棵只含 3- 节点的树中插入新节点的操作步骤：先临时将新键存入唯一的 3- 节点中，使其成为一个 4- 节点，再将它转化为一颗由 3 个 2- 节点组成的 2-3 树，分解后树高会增加 1。</p>
<p>图解：<br><img src="/img/b546a317a515e7af9f17750e8d39e7c3.png" alt=""></p>
<p>向一个父节点为 2- 节点的 3- 节点中插入新节点的操作步骤：先构造一个临时的 4- 节点并将其分解，分解时将中键移动到父节点中(中键移动后，其父节点中的位置由键的大小确定)</p>
<p>图解：<br><img src="/img/abccd8c302b9609b787495f0bf9bd364.png" alt=""><br><img src="/img/71c621876faa1e651fb3a4197a1d0c11.png" alt=""></p>
<p>向一个父节点为3-节点的3-节点中插入新节点的操作步骤：插入节点后一直向上分解构造的临时4-节点并将中键移动到更高层双亲节点，直到遇到一个-2节点并将其替换为一个不需要继续分解的3-节点，或是到达树根(3-节点)。</p>
<p>图解：<br><img src="/img/48a23e1dd9c8a341741d380033ad008f.png" alt=""></p>
<p><img src="/img/30150a1882bfb7cf3a549be1eddc84a6.jpg" alt=""></p>
<p><img src="/img/17f62ec19a5985fd20373f8f76ae1938.png" alt=""></p>
<p>分解根节点<br>操作步骤：如果从插入节点到根节点的路径上全是3-节点（包含根节点在内），根节点将最终被替换为一个临时的4-节点，将临时的4-节点分解为3个2-节点，分解后树高会增加1。</p>
<p>图解：<br><img src="/img/5d18899b2274d575830eb9608b8e0af5.jpg" alt=""></p>
<h2 id="2-3树删除"><a href="#2-3树删除" class="headerlink" title="2-3树删除"></a>2-3树删除</h2><p>删除之前，先要对2-3树进行一次命中的查找，查找成功才可以进行删除操作。删除节点大概分为3种情形</p>
<ol>
<li>删除非叶子节点。</li>
<li>删除不为2-节点的叶子节点。</li>
<li>删除为2-节点的叶子节点。</li>
</ol>
<h3 id="删除非叶子节点"><a href="#删除非叶子节点" class="headerlink" title="删除非叶子节点"></a>删除非叶子节点</h3><p>操作步骤：使用中序遍历下的直接后继节点key来覆盖当前待删除节点key，再删除用来覆盖的后继节点key。</p>
<p>图解：<br><img src="/img/a1bedcc86a524ba67d5c1856e231721f.png" alt=""></p>
<p>删除不为2-节点的叶子节点操作步骤：删除不为2-节点的叶子节点，直接删除节点即可。**</p>
<p>图解：<br><img src="/img/4615e62775c541bc9e75beb2fdb25f65.png" alt=""></p>
<p>删除为2-节点的叶子节点<br>删除为2-节点的叶子节点的步骤相对复杂，删除节点后需要做出相应判断，并根据判断结果调整树结构。主要分为四种情形：</p>
<p>删除节点为2-节点，父节点为2-节点，兄弟节点为3-节点的操作步骤：当前待删除节点的父节点是2-节点、兄弟节点是3-节点，将父节点移动到当前待删除节点位置，再将兄弟节点中最接近当前位置的key移动到父节点中。</p>
<p>图解：<br><img src="/img/4f2a0549924de35b50f72e4f212145a0.png" alt=""></p>
<p>删除节点为2-节点，父节点为2-节点，兄弟节点为2-节点的操作步骤：当前待删除节点的父节点是2-节点、兄弟节点也是2-节点，先通过移动兄弟节点的中序遍历直接后驱到兄弟节点，以使兄弟节点变为3-节点；再进行6.3.1的操作。</p>
<p>图解：<br><img src="/img/cb828f494ba4b69cecce89f8e5bceb20.png" alt=""><br><img src="/img/f5f3fd791411fbb6fb45d5d6a7612e9a.png" alt=""></p>
<p>删除节点为2-节点，父节点为3-节点的操作步骤：当前待删除节点的父节点是3-节点，拆分父节点使其成为2-节点，再将再将父节点中最接近的一个拆分key与中孩子合并，将合并后的节点作为当前节点。</p>
<p>图解：<br><img src="/img/62a98f17efedf822e68f2c1e38fc7779.png" alt=""></p>
<p>2-3树为满二叉树，删除叶子节点的操作步骤：若2-3树是一颗满二叉树，将2-3树层树减少，并将当前删除节点的兄弟节点合并到父节点中，同时将父节点的所有兄弟节点合并到父节点的父节点中，如果生成了4-节点，再分解4-节点。</p>
<p>图解：<br><img src="/img/413808e1b75212f1f23a6e122897d0c5.png" alt=""></p>
<h2 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h2><p>2-3-4树是对2-3树的概念扩展，包括了4节点的使用。一个4节点中包含小中大三个元素和四个孩子(要么有四个孩子要么没有，不存在其他情况)，如果某个4节点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>先找插入结点，若结点有空(即2-结点)，则直接插入。如结点没空(即3-结点)，则插入使其临时容纳这个元素，然后分裂此结点，把中间元素移到其父结点中。对父结点亦如此处理。（中键一直往上移，直到找到空位，在此过程中没有空位就先搞个临时的，再分裂。）</p>
<p>2-3树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。所有局部变换都不会影响整棵树的有序性和平衡性。</p>
<p>同时，通过上面树的深度增加的例子，可以看出2-3树和标准二叉树不同，标准的二叉树的的深度是由上到下的增加的，而2-3树的深度生长是由下至上的。</p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h1><p>定义：B-树是一类树，包括B-树、B+树、B*树等，是一棵自平衡的搜索树，它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。</p>
<p>一个 m 阶的B树满足以下条件：</p>
<ul>
<li>每个结点至多拥有m棵子树；</li>
<li>根结点至少拥有两颗子树（存在子树的情况下）；</li>
<li>除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；</li>
<li>所有的叶结点都在同一层上；</li>
<li>有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；</li>
<li>关键字数量需要满足ceil(m/2)-1 &lt;= n &lt;= m-1；</li>
</ul>
<p><img src="/img/5959612-b81be8294621eb26.webp" alt=""></p>
<p>B树上大部分的操作所需要的磁盘存取次数和B树的高度是成正比的，在B树中可以检查多个子结点，由于在一棵树中检查任意一个结点都需要一次磁盘访问，所以B树避免了大量的磁盘访问。</p>
<p>B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</p>
<p>定义只需要知道B-树允许每个节点有更多的子节点即可（多叉树）。子节点数量一般在上千，具体数量依赖外部存储器的特性。</p>
<p>先来看看为什么会出现B-树这类数据结构。</p>
<p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。原因当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。这说明程序大部分时间会阻塞在磁盘 IO 上。那么我们如何提高程序性能？减少磁盘 IO 次数，像 AVL 树，红黑树这类平衡二叉树从设计上无法“迎合”磁盘。</p>
<p>平衡二叉树是通过旋转来保持平衡的，而旋转是对整棵树的操作，若部分加载到内存中则无法完成旋转操作。其次平衡二叉树的高度相对较大为 log n（底数为2），这样逻辑上很近的节点实际可能非常远，无法很好的利用磁盘预读（局部性原理），所以这类平衡二叉树在数据库和文件系统上的选择就被 pass 了。</p>
<p>空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。</p>
<p>我们从“迎合”磁盘的角度来看看B-树的设计。</p>
<p>索引的效率依赖与磁盘 IO 的次数，快速索引需要有效的减少磁盘 IO 次数，如何快速索引呢？索引的原理其实是不断的缩小查找范围，就如我们平时用字典查单词一样，先找首字母缩小范围，再第二个字母等等。平衡二叉树是每次将范围分割为两个区间。为了更快，B-树每次将范围分割为多个区间，区间越多，定位数据越快越精确。那么如果节点为区间范围，每个节点就较大了。所以新建节点时，直接申请页大小的空间（磁盘存储单位是按 block 分的，一般为 512 Byte。磁盘 IO 一次读取若干个 block，我们称为一页，具体大小和操作系统有关，一般为 4 k，8 k或 16 k），计算机内存分配是按页对齐的，这样就实现了一个节点只需要一次 IO。</p>
<p>多叉的好处非常明显，有效的降低了B-树的高度，为底数很大的 log n，底数大小与节点的子节点数目有关，一般一棵B-树的高度在 3 层左右。层数低，每个节点区确定的范围更精确，范围缩小的速度越快（比二叉树深层次的搜索肯定快很多）。上面说了一个节点需要进行一次 IO，那么总 IO 的次数就缩减为了 log n 次。B-树的每个节点是 n 个有序的序列(a1,a2,a3…an)，并将该节点的子节点分割成 n+1 个区间来进行索引(X1&lt; a1, a2 &lt; X2 &lt; a3, … , an+1 &lt; Xn &lt; anXn+1 &gt; an)。</p>
<p>点评：B树的每个节点，都是存多个值的，不像二叉树那样，一个节点就一个值，B树把每个节点都给了一点的范围区间，区间更多的情况下，搜索也就更快了，比如：有1-100个数，二叉树一次只能分两个范围，0-50和51-100，而B树，分成4个范围 1-25， 25-50，51-75，76-100一次就能筛选走四分之三的数据。所以作为多叉树的B树是更快的。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>新结点一般插在第h层，通过搜索找到对应的结点进行插入，那么根据即将插入的结点的数量又分为下面几种情况。</p>
<p>如果该结点的关键字个数没有到达m-1个，那么直接插入即可；</p>
<p>如果该结点的关键字个数已经到达了m-1个，那么根据B树的性质显然无法满足，需要将其进行分裂。分裂的规则是该结点分成两半，将中间的关键字进行提升，加入到父亲结点中，但是这又可能存在父亲结点也满员的情况，则不得不向上进行回溯，甚至是要对根结点进行分裂，那么整棵树都加了一层。</p>
<p>其过程如下：<br><img src="/img/5959612-c11df32046f7c405.webp" alt=""></p>
<p><img src="/img/5959612-c347422b9a94f5bb.webp" alt=""></p>
<p><img src="/img/5959612-b979b0489ef0a576.webp" alt=""></p>
<p><img src="/img/5959612-d9cc5aa6b00fae0d.webp" alt=""></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>同样的，我们需要先通过搜索找到相应的值，存在则进行删除，需要考虑删除以后的情况，</p>
<ul>
<li>如果该结点拥有关键字数量仍然满足B树性质，则不做任何处理；</li>
<li>如果该结点在删除关键字以后不满足B树的性质（关键字没有到达ceil(m/2)-1的数量），则需要向兄弟结点借关键字，这有分为兄弟结点的关键字数量是否足够的情况。</li>
<li>如果兄弟结点的关键字足够借给该结点，则过程为将父亲结点的关键字下移，兄弟结点的关键字上移；</li>
<li>如果兄弟结点的关键字在借出去以后也无法满足情况，即之前兄弟结点的关键字的数量为ceil(m/2)-1，借的一方的关键字数量为ceil(m/2)-2的情况，那么我们可以将该结点合并到兄弟结点中，合并之后的子结点数量少了一个，则需要将父亲结点的关键字下放，如果父亲结点不满足性质，则向上回溯；</li>
<li>其余情况参照BST中的删除。</li>
</ul>
<p>其过程如下：<br><img src="/img/5959612-82ca66cb555eeaa6.webp" alt=""></p>
<p><img src="/img/5959612-3d9383c247d3112b.webp" alt=""></p>
<p><img src="/img/5959612-0ecb25e96e2f6210.webp" alt=""></p>
<p>B-树是一种多路搜索树（并不是二叉的）：</p>
<ol>
<li>定义任意非叶子结点最多只有M个儿子；且M&gt;2；</li>
<li>根结点的儿子数为[2, M]；</li>
<li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li>
<li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</li>
<li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li>
<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li>
<li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li>
<li>所有叶子结点位于同一层；</li>
</ol>
<p>如：（M=3）<br><img src="/img/20211114005302.jpg" alt=""></p>
<p>来模拟下查找文件29的过程：</p>
<ol>
<li>根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作1次】</li>
<li>此时内存中有两个文件名17，35和三个存储其他磁盘页面地址的数据。根据算法我们发现17&lt;29&lt;35，因此我们找到指针p2。</li>
<li>根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作2次】</li>
<li>此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现26&lt;29&lt;30，因此我们找到指针p2。</li>
<li>根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作3次】</li>
<li>此时内存中有两个文件名28，29。根据算法我们查找到文件29，并定位了该文件内存的磁盘地址。</li>
</ol>
<p>生成从空树开始，逐个插入关键字。但是由于B-树节点关键字必须大于等于<code>[ceil(m/2)-1]</code>，所以每次插入一个关键字不是在树中添加一个叶子结点，而是首先在最底层的某个非终端节点中添加一个“关键字”，该结点的关键字不超过m-1，则插入完成；否则要产生结点的“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中。</p>
<p>1、咱们通过一个实例来逐步讲解下。插入以下字符字母到一棵空的B 树中（非根结点关键字数小了（小于2个）就合并，大了（超过4个）就分裂）：C N G A H E K Q M F W L T Z D P R X Y S，首先，结点空间足够，4个字母插入相同的结点中，如下图：<br><img src="/img/20211114005306.jpg" alt=""></p>
<p>2、当咱们试着插入H时，结点发现空间不够，以致将其分裂成2个结点，移动中间元素G上移到新的根结点中，在实现过程中，咱们把A和C留在当前结点中，而H和N放置新的其右邻居结点中。如下图：<br><img src="/img/20211114005307.jpg" alt=""></p>
<p>3、当咱们插入E,K,Q时，不需要任何分裂操作<br><img src="/img/20211114005308.jpg" alt=""></p>
<p>4、插入M需要一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中<br><img src="/img/20211114005309.jpg" alt=""></p>
<p>5、插入F,W,L,T不需要任何分裂操作<br><img src="/img/20211114005310.jpg" alt=""></p>
<p>6、插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在2个关键字元素。<br><img src="/img/20211114005311.jpg" alt=""></p>
<p>7、插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y陆续插入不需要任何分裂操作（别忘了，树中至多5个孩子）。<br><img src="/img/20211114005312.jpg" alt=""></p>
<p>8、最后，当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中，注意以前在父节点中的第三个指针在修改后包括D和G节点中。这样具体插入操作的完成。<br><img src="/img/20211114005313.jpg" alt=""></p>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况。</p>
<p>删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于<code>ceil(m/2)-1</code>，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于<code>ceil(m/2)-1)</code>（还记得第一节中关于B树的第5个特性中的c点么?：c)除根结点之外的结点（包括叶子结点）的关键字的个数n必须满足：<code>(ceil(m / 2)-1) &lt;= n &lt;= m-1</code>。m表示最多含有m个孩子，n表示关键字数。在本小节中举的一颗B树的示例中，关键字数n满足：<code>2&lt;=n&lt;=4</code>），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于<code>ceil(m/2)-1</code>，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。那咱们通过下面实例来详细了解吧。</p>
<p>以上述插入操作构造的一棵5阶B树（树中最多含有m（m=5）个孩子，因此关键字数最小为ceil(m / 2)-1=2。还是这句话，关键字数小了（小于2个）就合并，大了（超过4个）就分裂）为例，依次删除H,T,R,E。</p>
<p><img src="/img/20211114005314.jpg" alt=""></p>
<p>1、首先删除元素H，当然首先查找H，H在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目ceil(m/2)-1=2，则操作很简单，咱们只需要移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）<br><img src="/img/20211114005315.jpg" alt=""></p>
<p>2、下一步，删除T,因为T没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者W(字母升序的下个元素)，将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该孩子结点中元素个数大于2，无需进行合并操作。<br><img src="/img/20211114005316.jpg" alt=""></p>
<p>3、下一步删除R，R在叶子结点中，但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目<code>ceil(5/2)-1=2</code>，而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于<code>ceil(5/2)-1=2</code>），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中（有没有看到红黑树中左旋操作的影子?），在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。<br><img src="/img/20211114005317.jpg" alt=""></p>
<p>4、最后一步删除E，删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2），而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。<br><img src="/img/20211114005318.jpg" alt=""></p>
<p>5、也许你认为这样删除操作已经结束了，其实不然，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素G，没达标（因为非根节点包括叶子结点的关键字数n必须满足于<code>2=&lt;n&lt;=4</code>，而此处的n=1），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）有一个以上的元素（Q右边还有元素），然后咱们将M下移到元素很少的子结点中，将Q上移到M的位置，这时，Q的左子树将变成M的右子树，也就是含有N，P结点被依附在M的右指针上。所以在这个实例中，咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。<br><img src="/img/20211114005319.jpg" alt=""></p>
<p>为了进一步详细讨论删除的情况，再举另外一个实例：这里是一棵不同的5序B树，那咱们试着删除C<br><img src="/img/20211114005320.jpg" alt=""></p>
<p>于是将删除元素C的右子结点中的D元素上移到C的位置，但是出现上移元素后，只有一个元素的结点的情况。</p>
<p>又因为含有E的结点，其相邻兄弟结点才刚脱贫（最少元素个数为2），不可能向父节点借元素，所以只能进行合并操作，于是这里将含有A,B的左兄弟结点和含有E的结点进行合并成一个结点。<br><img src="/img/20211114005321.jpg" alt=""></p>
<p>这样又出现只含有一个元素F结点的情况，这时，其相邻的兄弟结点是丰满的（元素个数为3&gt;最小元素个数2），这样就可以想父结点借元素了，把父结点中的J下移到该结点中，相应的如果结点中J后有元素则前移，然后相邻兄弟结点中的第一个元素（或者最后一个元素）上移到父节点中，后面的元素（或者前面的元素）前移（或者后移）；注意含有K，L的结点以前依附在M的左边，现在变为依附在J的右边。这样每个结点都满足B树结构性质。<br><img src="/img/20211114005322.jpg" alt=""></p>
<p>从以上操作可看出：除根结点之外的结点（包括叶子结点）的关键字的个数n满足：<code>(ceil(m / 2)-1) &lt;= n &lt;= m-1</code>，即2&lt;=n&lt;=4。这也佐证了咱们之前的观点。删除操作完。</p>
<p>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p>
<p>B-树的特性：</p>
<ol>
<li>关键字集合分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
<li>自动层次控制；</li>
</ol>
<p>由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：<br><img src="/img/20211114005303.jpg" alt=""></p>
<p>其中，M为设定的非叶子结点最多子树个数，N为关键字总数；所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；</p>
<h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h1><p>B+树是B-树的变体，也是一种多路搜索树：</p>
<ol>
<li>其定义基本与B-树同，除了：</li>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
</ol>
<p><img src="/img/20211114005323.jpg" alt=""></p>
<p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。B+树的主要优点：非终端结点仅仅起高层索引作用，而B树非终端结点的关键字除作子树分界外，本身还是实际记录的有效关键字（含记录指针），因此相同的结点空间，B+树可以设计的阶树比B树大，相同的索引，B+树的索引层数比B树少，因此检索速度比B树快。此外，B+树叶子结点包含完整的索引信息，可以较方便地表示文件的稀疏索引。最后，B+树的检索、插入和删除都在叶子结点进行，比B树相对简单。</p>
<p>B+的特性：</p>
<ol>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>更适合文件索引系统；</li>
</ol>
<p>B树和B+树的区别是由于B+树和B具有这不同的存储结构所造成的区别，以一个m阶树为例。</p>
<ul>
<li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。</li>
<li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li>
<li>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</li>
<li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li>
</ul>
<h1 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B*树"></a>B*树</h1><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；<br><img src="/img/20211114005305.jpg" alt=""></p>
<p><code>B*</code>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；</p>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p><code>B*</code>树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>根据B树的特点，我们首先可以写出B树的整体的结构。</p>
<h3 id="B树结构"><a href="#B树结构" class="headerlink" title="B树结构"></a>B树结构</h3><p>B树的结构我们定义需要参考规则，我们首先是需要给出保存键值的一个数组，这个数组的大小取决与我们定义的M，然后我们根据规则，可以得到一个保存M+1个子的一个数组，然后当然为了方便访问，parent指针，然后要有一个记录每个节点中键值个数的一个size。</p>
<p>所以定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="type">int</span> M&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    K _keys[M];                     <span class="comment">//用来保存键值。</span></span><br><span class="line">    BTreeNode&lt;K, M&gt;* _sub[M + <span class="number">1</span>];   <span class="comment">//用来保存子。</span></span><br><span class="line">    BTreeNode&lt;K, M&gt;* _parent;</span><br><span class="line">    <span class="type">size_t</span> _size;</span><br><span class="line">    <span class="built_in">BTreeNode</span>()</span><br><span class="line">        :_parent(<span class="literal">NULL</span>)</span><br><span class="line">        , _size(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _keys[i] = <span class="built_in">K</span>();</span><br><span class="line">            _sub[i] = <span class="built_in">K</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _sub[i] = <span class="built_in">K</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="B树的查找"><a href="#B树的查找" class="headerlink" title="B树的查找"></a>B树的查找</h3><p>对于AVL，BST，红黑树，B树这些高级的数据结构而言，查找算法是非常重要的。我们首先确定返回值，对于这种关于key和key-value的数据结构，参考map和set，我们让它返回一个pair的一个结构体。</p>
<p>pair结构体的定义在std中是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span></span><br><span class="line">&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们只需要让这个里面的value变为bool值，value返回以后说明的是存不存就可以了。</p>
<p>接下来的思路就是从根节点进行和这个节点当中的每一个key比较，如果=那么就返回找到了，如果小于，那么就到这个节点左面的子节点中找，如果大了，就继续向后面的键值进行查找。如果相等那么就返回。</p>
<p>示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;Node*, <span class="type">int</span>&gt; <span class="built_in">Find</span>(<span class="type">const</span> K &amp;key)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* cur = _root;</span><br><span class="line">        Node* parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; cur-&gt;_size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果小于当前，向后</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;_keys[i] &lt; key)</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果大于，</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_keys[i]&gt;key)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = cur-&gt;_sub[i];</span><br><span class="line">                    parent = cur;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//相等，返回这个节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">pair</span>&lt;Node *, <span class="type">int</span>&gt;(<span class="literal">NULL</span>, <span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; cur-&gt;_sub[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;_sub[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为了防止出现我返回空指针操作，如果是空指针，那么就返回父亲</span></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span> &amp;&amp; i == cur-&gt;_size)</span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_sub[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;Node *, <span class="type">int</span>&gt;(parent, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h3><p><img src="/img/20211114005324.jpg" alt=""></p>
<p>示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> K &amp;key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//首先来考虑空树的情况</span></span><br><span class="line">    <span class="keyword">if</span> (_root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//给这个节点中添加key，并且让size++。</span></span><br><span class="line">        _root = <span class="keyword">new</span> Node;</span><br><span class="line">        _root-&gt;_keys[<span class="number">0</span>] = key;</span><br><span class="line">        _root-&gt;_size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用通用的key-value结构体来保存找到的key所在的节点。</span></span><br><span class="line"></span><br><span class="line">    pair&lt;Node*,<span class="type">int</span> &gt; ret=<span class="built_in">Find</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里来看这个节点是否存在，存在就直接return false。</span></span><br><span class="line">    <span class="keyword">if</span> (ret.second == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* cur = ret.first;</span><br><span class="line">    K newKey = key;</span><br><span class="line">    Node *sub = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//此时表示考虑插入。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//向cur里面进行插入，如果没满插入，满了就进行分裂。</span></span><br><span class="line">        <span class="built_in">InsetKey</span>(cur, newKey, sub);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小于M，这样就可以直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;_size &lt; M)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果==M，那么就应该进行分裂</span></span><br><span class="line">        <span class="comment">//首先找到中间的节点</span></span><br><span class="line">        <span class="type">size_t</span> mid = cur-&gt;_size / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//创建一个节点，用来保存中间节点右边所有的节点和子节点。</span></span><br><span class="line">        Node * tmp = <span class="keyword">new</span> Node;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//进行移动sub以及所有的子接点。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = mid + <span class="number">1</span>; i &lt; cur-&gt;_size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;_keys[j] = cur-&gt;_keys[i];</span><br><span class="line">            cur-&gt;_keys[i] = <span class="built_in">K</span>();</span><br><span class="line">            cur-&gt;_size--;</span><br><span class="line">            tmp-&gt;_size++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移动子串</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tmp-&gt;_size + <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;_sub[j] = cur-&gt;_sub[mid + <span class="number">1</span> + j];</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;_sub[j])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;_sub[j]-&gt;_parent = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;_sub[mid + <span class="number">1</span> + j] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行其他的移动</span></span><br><span class="line">        <span class="comment">//分裂的条件就是要么分裂根，要么就是分裂子节点，要么就是所在节点的节点数小于M。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//考虑根分裂，分裂的时候创建节点，然后把中间节点上拉，记得要更改最后的parent</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;_parent == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            _root-&gt;_keys[<span class="number">0</span>] = cur-&gt;_keys[mid];</span><br><span class="line">            cur-&gt;_keys[mid] = <span class="built_in">K</span>();</span><br><span class="line">            cur-&gt;_size--;</span><br><span class="line">            _root-&gt;_size++;</span><br><span class="line"></span><br><span class="line">            _root-&gt;_sub[<span class="number">0</span>] = cur;</span><br><span class="line">            cur-&gt;_parent = _root;</span><br><span class="line"></span><br><span class="line">            _root-&gt;_sub[<span class="number">1</span>] = tmp;</span><br><span class="line">            tmp-&gt;_parent = _root;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分裂如果不是根节点，那么就把mid节点插入到上一层节点中，然后看上一层节点是否要分裂。注意修改cur和sub</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            newKey = cur-&gt;_keys[mid];</span><br><span class="line">            cur-&gt;_keys[mid] = <span class="built_in">K</span>();</span><br><span class="line">            cur-&gt;_size--;</span><br><span class="line">            cur = cur-&gt;_parent;</span><br><span class="line"></span><br><span class="line">            sub = tmp;</span><br><span class="line">            sub-&gt;_parent = cur;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsetKey</span><span class="params">(Node* cur, <span class="type">const</span> K &amp;key, Node* sub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = cur-&gt;_size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进行插入</span></span><br><span class="line">        <span class="keyword">if</span> (key &gt; cur-&gt;_keys[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行移动</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;_keys[i + <span class="number">1</span>] = cur-&gt;_keys[i];</span><br><span class="line">            cur-&gt;_sub[i + <span class="number">2</span>] = cur-&gt;_sub[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行插入</span></span><br><span class="line">    cur-&gt;_keys[i + <span class="number">1</span>] = key;</span><br><span class="line">    <span class="comment">//插入子</span></span><br><span class="line">    cur-&gt;_sub[i + <span class="number">2</span>] = sub;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没满，只需要对size++；</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;_size &lt; M)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;_size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="深入浅出分析LSM树"><a href="#深入浅出分析LSM树" class="headerlink" title="深入浅出分析LSM树"></a>深入浅出分析LSM树</h1><h2 id="LSM树数据结构定义"><a href="#LSM树数据结构定义" class="headerlink" title="LSM树数据结构定义"></a>LSM树数据结构定义</h2><p>LSM树并没有一种固定死的实现方式，更多的是一种将：</p>
<p>“磁盘顺序写” + “多个树(状数据结构)” + “冷热（新老）数据分级” + “定期归并” + “非原地更新”这几种特性统一在一起的思想。</p>
<p>为了方便后续的讲解分析，我们尝试先对LSM树做一个定义。</p>
<p>LSM树的定义：</p>
<ul>
<li>LSM树是一个横跨内存和磁盘的，包含多颗”子树”的一个森林。</li>
<li>LSM树分为Level 0，Level 1，Level 2 … Level n 多颗子树，其中只有Level 0在内存中，其余Level 1-n在磁盘中。</li>
<li>内存中的Level 0子树一般采用排序树（红黑树/AVL树）、跳表或者TreeMap等这类有序的数据结构，方便后续顺序写磁盘。</li>
<li>磁盘中的Level 1-n子树，本质是数据排好序后顺序写到磁盘上的文件，只是叫做树而已。</li>
<li>每一层的子树都有一个阈值大小，达到阈值后会进行合并，合并结果写入下一层。</li>
<li>只有内存中数据允许原地更新，磁盘上数据的变更只允许追加写，不做原地更新。</li>
</ul>
<p>以上6条定义组成了LSM树，如图1所示。<br><img src="/img/v2-9359003a0c88626b33979b784982e9ab_720w.jpg" alt=""></p>
<ul>
<li>图1中分成了左侧绿色的内存部分和右侧蓝色的磁盘部分（定义1）。</li>
<li>图1左侧绿色的内存部分只包含Level 0树，右侧蓝色的磁盘部分则包含Level 1-n等多棵”树”（定义2）</li>
<li>图1左侧绿色的内存部分中Level 0是一颗二叉排序树（定义3）。注意这里的有序性，该性质决定了LSM树优异的读写性能。</li>
<li>图1右侧蓝色的磁盘部分所包含的Level 1到Level n多颗树，虽然叫做“树”，但本质是按数据key排好序后，顺序写在磁盘上的一个个文件（定义4） ，注意这里再次出现了有序性。</li>
<li>内存中的Level 0树在达到阈值后，会在内存中遍历排好序的Level 0树并顺序写入磁盘的Level 1。同样的，在磁盘中的Level n（n&gt;0）达到阈值时，则会将Level n层的多个文件进行归并，写入Level n+1层。（定义5）</li>
<li>除了内存中的Level 0层做原地更新外，对已写入磁盘上的数据，都采用Append形式的磁盘顺序写，即更新和删除操作并不去修改老数据，只是简单的追加新数据。图1中右侧蓝色的磁盘部分，Level 1和Level 2均包含key为2的数据，同时图1左侧绿色内存中的Level 0树也包含key为2的数据节点。（定义6）</li>
</ul>
<p>下面我们遵循LSM树的6条定义，通过动图对LSM树的增、删、改、查和归并进行详细分析。</p>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>LSM树的插入较简单，数据无脑往内存中的Level 0排序树丢即可，并不关心该数据是否已经在内存或磁盘中存在。（已经存在该数据的话，则场景转换成更新操作，详见第四部分）</p>
<p>图2展示了，新数据直接插入Level 0树的过程。<br><img src="/img/b8494042-21d0-11ec-8331-6ad01c902347.mp4" alt=""></p>
<p>如上图2所示，我们依次插入了key=9、1、6的数据，这三个数据均按照key的大小，插入内存里的Level 0排序树中。该操作复杂度为树高log(n)，n是Level 0树的数据量，可见代价很低，能实现极高的写吞吐量。</p>
<h2 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h2><p>LSM树的删除操作并不是直接删除数据，而是通过一种叫“墓碑标记”的特殊数据来标识数据的删除。</p>
<p>删除操作分为：待删除数据在内存中、待删除数据在磁盘中 和 该数据根本不存在 三种情况。</p>
<h3 id="待删除数据在内存中："><a href="#待删除数据在内存中：" class="headerlink" title="待删除数据在内存中："></a>待删除数据在内存中：</h3><p>如图3所示，展示了待删除数据在内存中的删除过程。我们不能简单地将Level 0树中的黄色节点2删除，而是应该采用墓碑标记将其覆盖（思考题：为什么不能直接删除而是要用墓碑标记覆盖呢）<br><img src="/img/v2-7b764ddb2404b3b3e2d3f19b917a7bf3_b.gif" alt=""></p>
<h3 id="待删除数据在磁盘中"><a href="#待删除数据在磁盘中" class="headerlink" title="待删除数据在磁盘中"></a>待删除数据在磁盘中</h3><p>如图4所示，展示了待删除数据在磁盘上时的删除过程。我们并不去修改磁盘上的数据（理都不理它），而是直接向内存中的Level 0树中插入墓碑标记即可。<br><img src="/img/v2-6130424a556ba99a040bcd474371d347_b.gif" alt=""></p>
<h3 id="待删除数据根本不存在："><a href="#待删除数据根本不存在：" class="headerlink" title="待删除数据根本不存在："></a>待删除数据根本不存在：</h3><p>这种情况等价于在内存的Level 0树中新增一条墓碑标记，场景转换为情况3.2的内存中插入墓碑标记操作。</p>
<p>综合看待上述三种情况，发现不论数据有没有、在哪里，删除操作都是等价于向Level 0树中写入墓碑标记。该操作复杂度为树高log(n)，代价很低。</p>
<h2 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h2><p>LSM树的修改操作和删除操作很像，也是分为三种情况：待修改数据在内存中、在磁盘中和 该数据根本不存在。</p>
<h3 id="待修改数据在内存中："><a href="#待修改数据在内存中：" class="headerlink" title="待修改数据在内存中："></a>待修改数据在内存中：</h3><p><img src="/img/v2-238724222503b9be0316c3554c5ae29f_b.gif" alt=""></p>
<p>如图5所示，展示了待修改数据在内存中的操作过程。新的蓝色的key=7的数据，直接定位到内存中Level 0树上黄色的老的key=7的位置，将其覆盖即可。</p>
<h3 id="待修改数据在磁盘中："><a href="#待修改数据在磁盘中：" class="headerlink" title="待修改数据在磁盘中："></a>待修改数据在磁盘中：</h3><p><img src="/img/v2-482e280b9b27876ff5302b845c95353e_b.gif" alt=""></p>
<p>如图6所示，展示了待修改数据在磁盘中的操作过程。LSM树并不会去磁盘中的Level 1树上原地更新老的key=7的数据，而是直接将新的蓝色的节点7插入内存中的Level 0树中。</p>
<h3 id="该数据根本不存在："><a href="#该数据根本不存在：" class="headerlink" title="该数据根本不存在："></a>该数据根本不存在：</h3><p>此场景等价于情况b，直接向内存中的Level 0树插入新的数据即可。</p>
<p>综上4.1、4.2、4.3三种情况可以看出，修改操作都是对内存中Level 0进行覆盖/新增操作。该操作复杂度为树高log(n)，代价很低。</p>
<p>我们会发现，LSM树的增加、删除、修改（这三个都属于写操作）都是在内存中倒腾，完全没涉及到磁盘操作，所以速度飞快，写吞吐量高的离谱。。。</p>
<h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>LSM树的查询操作会按顺序查找Level 0、Level 1、Level 2 … Level n 每一颗树，一旦匹配便返回目标数据，不再继续查询。该策略保证了查到的一定是目标key最新版本的数据（有点MVCC的感觉）。</p>
<p>我们来分场景分析：依然分为 待查询数据在内存中 和 待查询数据在磁盘中 两种情况。</p>
<h3 id="待查询数据在内存中："><a href="#待查询数据在内存中：" class="headerlink" title="待查询数据在内存中："></a>待查询数据在内存中：</h3><p>如图7所示，展示了待查询数据在内存中时的查询过程。</p>
<p><img src="/img/v2-49a19f8261209dfda34b0901fa6c2e77_b.gif" alt=""></p>
<p>沿着内存中已排好序的Level 0树递归向下比较查询，返回目标节点即可。我们注意到磁盘上的Level 1树中同样包括一个key=6的较老的数据。但LSM树查询的时候会按照Level 0、1、2 … n的顺序查询，一旦查到第一个就返回，因此磁盘上老的key=6的数据没人理它，更不会作为结果被返回。</p>
<h3 id="待查询数据在磁盘中："><a href="#待查询数据在磁盘中：" class="headerlink" title="待查询数据在磁盘中："></a>待查询数据在磁盘中：</h3><p>如图8所示，展示了待查询数据在磁盘上时的查询过程。</p>
<p><img src="/img/7b5d5564-21d1-11ec-b7c1-3a28dfb2838d.mp4" alt=""></p>
<p>先查询内存中的Level 0树，没查到便查询磁盘中的Level 1树，还是没查到，于是查询磁盘中的Level 2树，匹配后返回key=6的数据。</p>
<p>综合上述两种情况，我们发现，LSM树的查询操作相对来说代价比较高，需要从Level 0到Level n一直顺序查下去。极端情况是LSM树中不存在该数据，则需要把整个库从Level 0到Level n给扫了一遍，然后返回查无此人（可以通过 布隆过滤器 + 建立稀疏索引 来优化查询操作）。代价大于以B/B+树为基本数据结构的传统RDB存储引擎。</p>
<h2 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h2><p>合并操作是LSM树的核心（毕竟LSM树的名字就叫: 日志结构合并树，直接点名了合并这一操作）</p>
<p>之所以在增、删、改、查这四个基本操作之外还需要合并操作：一是因为内存不是无限大，Level 0树达到阈值时，需要将数据从内存刷到磁盘中，这是合并操作的第一个场景；二是需要对磁盘上达到阈值的顺序文件进行归并，并将归并结果写入下一层，归并过程中会清理重复的数据和被删除的数据(墓碑标记)。我们分别对上述两个场景进行分析：</p>
<h3 id="内存数据写入磁盘的场景："><a href="#内存数据写入磁盘的场景：" class="headerlink" title="内存数据写入磁盘的场景："></a>内存数据写入磁盘的场景：</h3><p>如图9所示，展示了内存中Level 0树在达到阈值后，归并写入磁盘Level 1树的场景。</p>
<p><img src="/img/v2-52dc81ca11590af2c57a248b106f889f_b.gif" alt=""></p>
<p>对内存中的Level 0树进行中序遍历，将数据顺序写入磁盘的Level 1层即可，我们可以看到因为Level 0树是已经排好序的，所以写入的Level 1中的新块也是有序的（有序性保证了查询和归并操作的高效）。此时磁盘的Level 1层有两个Block块。</p>
<h3 id="磁盘中多个块的归并："><a href="#磁盘中多个块的归并：" class="headerlink" title="磁盘中多个块的归并："></a>磁盘中多个块的归并：</h3><p>如图10所示，该图展示了磁盘中Level 1层达到阈值时，对其包含的两个Block块进行归并，并将归并结果写入Level 2层的过程。</p>
<p><img src="/img/47cada78-21d6-11ec-bf49-362c95d6552e.mp4" alt=""></p>
<p>我们注意到key=5和key=7的数据同时存在于较老的Block 1和较新的Block 2中。而归并的过程是保留较新的数据，于是我们看到结果中，key=5和7的数据都是红色的（来自于较新的Block2）。</p>
<p>综上我们可以看到，不论是场景6.1还是场景6.2，由于原始数据都是有序的，因此归并的过程只需要对数据集进行一次扫描即可，复杂度为O(n)。</p>
<h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><p>以上便是对LSM树的增、删、改、查和归并五种核心操作的详细分析。</p>
<p>可以看到LSM树将增、删、改这三种操作都转化为内存insert + 磁盘顺序写(当Level 0满的时候)，通过这种方式得到了无与伦比的写吞吐量。</p>
<p>LSM树的查询能力则相对被弱化，相比于B+树的最多3~4次磁盘IO，LSM树则要从Level 0一路查询Level n，极端情况下等于做了全表扫描。（即便做了稀疏索引，也是lg(N0)+lg(N1)+…+lg(Nn)的复杂度，大于B+树的lg(N0+N1+…+Nn)的时间复杂度）。</p>
<p>同时，LSM树只append追加不原地修改的特性引入了归并操作，归并操作涉及到大量的磁盘IO，比较消耗性能，需要合理设置触发该操作的参数。</p>
<p>综上我们可以给出LSM树的优缺点：</p>
<p>优：增、删、改操作飞快，写吞吐量极大。</p>
<p>缺：读操作性能相对被弱化；不擅长区间范围的读操作； 归并操作较耗费资源。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>以上是对LSM树基本操作以及优缺点的分析，我们可以据此得出LSM树的设计原则：</p>
<ul>
<li>先内存再磁盘</li>
<li>内存原地更新</li>
<li>磁盘追加更新</li>
<li>归并保留新值</li>
</ul>
<p>如果说B/B+树的读写性能基本平衡的话，LSM树的设计原则通过舍弃部分读性能，换取了无与伦比的写性能。该数据结构适合用于写吞吐量远远大于读吞吐量的场景，得到了NoSQL届的喜爱和好评。</p>
<h1 id="平衡二叉树详解"><a href="#平衡二叉树详解" class="headerlink" title="平衡二叉树详解"></a>平衡二叉树详解</h1><h2 id="二叉搜索树（Binary-Sort-Tree）"><a href="#二叉搜索树（Binary-Sort-Tree）" class="headerlink" title="二叉搜索树（Binary Sort Tree）"></a>二叉搜索树（Binary Sort Tree）</h2><p>二叉搜索树，又称之为二叉排序树（二叉查找树），它或许是一棵空树，或许是具有以下性质的二叉树：</p>
<ul>
<li>若他的左子树不为空，则左子树上所有节点的值都小于根节点的值</li>
<li>若它的右子树不为空，则右子树上所有节点的值都大于根节点的值</li>
<li>它的左右子树也分别是二叉搜索树</li>
</ul>
<p><img src="/img/20180706083115153.png" alt=""></p>
<p>二叉搜索树的这种特性，使得我们在此二叉树上查找某个值就很方便了，从根节点开始，若要寻找的值小于根节点的值，则在左子树上去找，反之则去右子树查找，知道找到与值相同的节点。插入节点也是一样的道理，从根节点出发，所要插入的值，若小于根节点则去左子树寻找该节点所对应的位置，反之去右子树寻找，直到找到该节点合适的位置。<br><img src="/img/20180706083929233.png" alt=""></p>
<h2 id="二叉平衡搜索树（AVL）"><a href="#二叉平衡搜索树（AVL）" class="headerlink" title="二叉平衡搜索树（AVL）"></a>二叉平衡搜索树（AVL）</h2><p>前面提到了二叉搜索树，我们知道，二叉搜索树的特性便于我们进行查找插入删除等一系列操作，其时间复杂度为O（logn），但是，如果遇见最差的情况，比如以下这棵树：</p>
<p><img src="/img/20180706085004255.png" alt=""></p>
<p>这棵树，说是树，其实它已经退化成链表了，但从概念上来看，它仍是一棵二叉搜索树，只要我们按照逐次增大，如1、2、3、4、5、6的顺序构造一棵二叉搜索树，则形如上图。那么插入的时间复杂度就变成了O(n)，导致这种糟糕的情况原因是因为这棵树极其不平衡，右树的重量远大于左树，因此我们提出了叫平衡二叉搜索树的结构，又称之为AVL树，是因为平衡二叉搜索树的发明者为Adel’son-Vel’skii 和Landis二人。</p>
<p>平衡二叉搜索树，它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均查找长度。</p>
<p>AVL树的性质：</p>
<ul>
<li>左子树与右子树高度之差的绝对值不超过1</li>
<li>树的每个左子树和右子树都是AVL树</li>
<li>每一个节点都有一个平衡因子（balance factor），任一节点的平衡因子是-1、0、1（每一个节点的平衡因子 = 右子树高度 - 左子树高度）</li>
</ul>
<p>做到了这点，这棵树看起来就比较平衡了，那么如何生成一棵AVL树呢？算法相对来说复杂，随着新节点的加入，树自动调整自身结构，达到新的平衡状态，这就是我们想要的AVL树。我们先要分析，为什么树会失衡？是由于插入了一个新的元素。</p>
<ul>
<li>当子树的根结点的平衡因子为+1时，它是左倾斜的（left-heavy)。</li>
<li>当子树的根结点的平衡因子为 -1时，它是右倾斜的(right-heavy)。</li>
<li>一颗子树的根结点的平衡因子就代表该子树的平衡性。</li>
<li>保持所有子树几乎都处于平衡状态，AVL树在总体上就能够基本保持平衡。</li>
</ul>
<p>AVL树的基本查找、插入结点的操作和二叉树的操作一样。但是，当向AVL树中插入一个结点后，还有一些额外的工作要做。首先，必须计算因插入操作对平衡因子带来的改变。其次，如果任何平衡因子变成了+/-2，就必须从这个结点开始往下重新平衡这颗树，这个重新平衡的过程就称为旋转。</p>
<p>在AVL树中，插入一个节点是什么样的过程呢？总结如下：</p>
<ol>
<li>AVL树首先是二叉搜索树。我们要根据二叉搜索树的插入节点方式进行插入</li>
<li>AVL树有判断该树是否平衡的平衡因子，我们要根据平衡因子来对树进行选择调整</li>
</ol>
<p>具体步骤：</p>
<ol>
<li>判断该树是不是NULL，若为NULL，则直接插入<br>2· 若不为NULL，找到需要插入节点的位置（用pParent标记双亲，方便插入节点）pCur</li>
<li>插入节点pCur</li>
<li>更新pParent的平衡因子。然后判断该树是否要调整<ol>
<li>若更新后的pParent平衡因子为0的话，pParent在插入新节点之前只有左孩子或者只有右孩子，此时树的高度不变，该树仍然为AVL</li>
<li>若更新后的pParent平衡因子为1或者-1的话，pParent在插入节点前是叶子节点，此时的高度可能发生改变，我们要从pParent节点开始，向上判断调整其祖先节点</li>
<li>若平衡因子不满足上面的两种情况，说明该树已经不平衡，需要调整。具体情况见下面，局部调整完后，上面的树已经满足AVL。</li>
</ol>
</li>
</ol>
<p><img src="/img/20180710083908118.png" alt=""></p>
<p>插入节点代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="type">bool</span> AVLTree&lt;K, V&gt;::<span class="built_in">AVLInsert</span>(K key, V val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.根节点为空，直接插入</span></span><br><span class="line">    <span class="keyword">if</span> (_root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span>(key, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.根节点不为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node* cur = _root;</span><br><span class="line">        Node* parent =<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//a)找到要插入节点的位置</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//不允许出现重复元素的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//b)插入新节点</span></span><br><span class="line">        cur = <span class="keyword">new</span> <span class="built_in">Node</span>(key, val);</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;_key &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_left = cur;</span><br><span class="line">            cur-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_right = cur;</span><br><span class="line">            cur-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//c)插入完成后，调整平衡因子</span></span><br><span class="line">        <span class="keyword">while</span> (parent)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == parent-&gt;_left)<span class="comment">//插入节点在左子树父节点bf--，反之++</span></span><br><span class="line">                parent-&gt;_bf--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                parent-&gt;_bf++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1)插入新节点后，parent-&gt;bf==0；说明高度没变，平衡，返回</span></span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//2)插入节点后parent-&gt;_bf==-1||parent-&gt;_bf==1；说明子树高度改变，则继续向上调整</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-1</span> || parent-&gt;_bf == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = parent;</span><br><span class="line">                parent = parent-&gt;_parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3)插入节点后parent-&gt;_bf==-2||parent-&gt;_bf==2；说明已经不平衡，需要旋转</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;_bf == <span class="number">1</span>)</span><br><span class="line">                        <span class="built_in">RotateL</span>(parent);</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">// (cur-&gt;_bf == -1)</span></span><br><span class="line">                        <span class="built_in">RotateRL</span>(parent);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//parent-&gt;_bf == -2</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;_bf == <span class="number">-1</span>)</span><br><span class="line">                        <span class="built_in">RotateR</span>(parent);</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">// (cur-&gt;_bf == 1)</span></span><br><span class="line">                        <span class="built_in">RotateLR</span>(parent);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end while (parent)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当树不平衡时，我们需要做出旋转调整，有四种调整方法。以下是节点调平的四种情况。</p>
<h2 id="AVL树的自平衡操作——旋转"><a href="#AVL树的自平衡操作——旋转" class="headerlink" title="AVL树的自平衡操作——旋转"></a>AVL树的自平衡操作——旋转</h2><p>AVL树的旋转总体来说分为四种情况：</p>
<ul>
<li>左单旋</li>
<li>右单旋</li>
<li>左右双旋</li>
<li>右左双旋</li>
</ul>
<p>接下来，我们通过图解来认识这四种节点调平方式</p>
<h3 id="左单旋（逆时针旋转）"><a href="#左单旋（逆时针旋转）" class="headerlink" title="左单旋（逆时针旋转）"></a>左单旋（逆时针旋转）</h3><p><img src="/img/20180710084456779.png" alt=""></p>
<p>代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;K, V&gt;::<span class="built_in">RotateL</span>(Node* parent)</span><br><span class="line">&#123;</span><br><span class="line">    Node* subR = parent-&gt;_right;</span><br><span class="line">    Node* subRL = subR-&gt;_left;</span><br><span class="line">    Node* pParent = parent-&gt;_parent;</span><br><span class="line"></span><br><span class="line">    parent-&gt;_right = subRL;</span><br><span class="line">    <span class="keyword">if</span> (subRL)</span><br><span class="line">        subRL-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">    subR-&gt;_left = parent;</span><br><span class="line">    parent-&gt;_parent = subR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent == _root)</span><br><span class="line">    &#123;</span><br><span class="line">        _root = subR;</span><br><span class="line">        _root-&gt;_parent = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pParent-&gt;_left = parent)</span><br><span class="line">            pParent-&gt;_left = subR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pParent-&gt;_right = subR;</span><br><span class="line">        subR-&gt;_parent = pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    parent-&gt;_bf = subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="右单旋（顺时针旋转）"><a href="#右单旋（顺时针旋转）" class="headerlink" title="右单旋（顺时针旋转）"></a>右单旋（顺时针旋转）</h3><p><img src="/img/2018071008461365.png" alt=""></p>
<p>代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;K, V&gt;::<span class="built_in">RotateR</span>(Node* parent)</span><br><span class="line">&#123;</span><br><span class="line">    Node* subL = parent-&gt;_left;</span><br><span class="line">    Node* subLR = subL-&gt;_right;</span><br><span class="line">    Node* ppNode = parent-&gt;_parent;</span><br><span class="line"></span><br><span class="line">    parent-&gt;_left = subLR;</span><br><span class="line">    <span class="keyword">if</span> (subLR)</span><br><span class="line">        subLR-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">    subL-&gt;_right = parent;</span><br><span class="line">    parent-&gt;_parent = subL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_root == parent)</span><br><span class="line">    &#123;</span><br><span class="line">        _root = subL;</span><br><span class="line">        subL-&gt;_parent = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ppNode-&gt;_right == parent)</span><br><span class="line">        &#123;</span><br><span class="line">            ppNode-&gt;_right = subL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ppNode-&gt;_left = subL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subL-&gt;_parent = ppNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subL-&gt;_bf = parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="左右双旋"><a href="#左右双旋" class="headerlink" title="左右双旋"></a>左右双旋</h3><p><img src="/img/201807100847331.png" alt=""></p>
<p>代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;K, V&gt;::<span class="built_in">RotateLR</span>(Node* parent)</span><br><span class="line">&#123;</span><br><span class="line">    Node* subL = parent-&gt;_left;</span><br><span class="line">    Node* subLR = subL-&gt;_right;</span><br><span class="line">    <span class="type">int</span> bf = subLR-&gt;_bf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RotateL</span>(parent-&gt;_left);</span><br><span class="line">    <span class="built_in">RotateR</span>(parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bf == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        subLR-&gt;_bf = subL-&gt;_bf = parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">        subL-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">        subLR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        parent-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">        subL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">        subLR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="右左双旋"><a href="#右左双旋" class="headerlink" title="右左双旋"></a>右左双旋</h3><p><img src="/img/20180710084920195.png" alt=""></p>
<p>代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;K, V&gt;::<span class="built_in">RotateRL</span>(Node* parent)</span><br><span class="line">&#123;</span><br><span class="line">    Node* subR = parent-&gt;_right;</span><br><span class="line">    Node* subRL = subR-&gt;_left;</span><br><span class="line">    <span class="type">int</span> bf = subRL-&gt;_bf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RotateR</span>(parent-&gt;_right);</span><br><span class="line">    <span class="built_in">RotateL</span>(parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bf == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        subRL-&gt;_bf = subR-&gt;_bf = parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">        parent-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">        subRL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">        subR-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">        subRL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="平衡因子更新"><a href="#平衡因子更新" class="headerlink" title="平衡因子更新"></a>平衡因子更新</h2><p>我们知道AVL树的每一个节点都有一个平衡因子，那么在AVL树插入节点时，其自平衡操作保证了AVL树始终保持平衡状态，但是在每一次插入节点时，都可能会导致节点平衡因子的改变，因此，当插入节点时，我们应当注意平衡因子的更新，这直接关系到之后判断插入节点后的数是否仍为AVL树。</p>
<p>平衡因子更新原则：——平衡因子与节点本身无关，只与其左右子树相关</p>
<ul>
<li>新增节点bf恒为1</li>
<li>右子树结点增加，父亲bf ++</li>
</ul>
<p><img src="/img/2018070610583514.png" alt=""></p>
<ul>
<li>左子树结点增加，父亲bf —</li>
</ul>
<p><img src="/img/20180706110052907.png" alt=""></p>
<ul>
<li>若插入节点，更新平衡因子之后<ul>
<li>父亲节点bf==0：高度没变，结束更新，平衡，满足条件，返回</li>
</ul>
</li>
</ul>
<p><img src="/img/20180706111055499.png" alt=""></p>
<pre><code>- 父亲bf==1 （或者bf== -1），子树高度改变，继续往上更新
</code></pre><p><img src="/img/20180706112034630.png" alt=""></p>
<pre><code>- 父亲bf==2 （或者bf== -2），子树不再是平衡树，旋转，变成平衡
</code></pre><p><img src="/img/20180706113856841.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//AVLTree树节点定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    K _key;</span><br><span class="line">    V _val;</span><br><span class="line"></span><br><span class="line">    AVLTreeNode&lt;K,V&gt;* _left;</span><br><span class="line">    AVLTreeNode&lt;K, V&gt;* _right;</span><br><span class="line">    AVLTreeNode&lt;K, V&gt;* _parent;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _bf;    <span class="comment">//平衡因子</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVLTreeNode</span>(<span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; val)</span><br><span class="line">        :_key(key)</span><br><span class="line">        , _val(val)</span><br><span class="line">        , _left(<span class="literal">NULL</span>)</span><br><span class="line">        , _right(<span class="literal">NULL</span>)</span><br><span class="line">        , _parent(<span class="literal">NULL</span>)</span><br><span class="line">        , _bf(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AVLTree类的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> AVLTreeNode&lt;K, V&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AVLTree</span>()   <span class="comment">//构造函数</span></span><br><span class="line">        :_root(<span class="literal">NULL</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">AVLInsert</span><span class="params">(K key,V val)</span></span>;    <span class="comment">//插入节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* parent)</span></span>;     <span class="comment">//  左单旋</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* parent)</span></span>;     <span class="comment">//  右单旋</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RotateLR</span><span class="params">(Node* parent)</span></span>;    <span class="comment">//  左右双旋</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RotateRL</span><span class="params">(Node* parent)</span></span>;    <span class="comment">//  右左双旋</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> _IsBalance(Node* root, <span class="type">int</span>&amp; height)    <span class="comment">//判断是否平衡</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            height = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rightHeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (_IsBalance(root-&gt;_left, leftHeight)</span><br><span class="line">            &amp;&amp; _IsBalance(root-&gt;_right, rightHeight))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rightHeight - leftHeight != root-&gt;_bf)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;平衡因子异常&quot;</span> &lt;&lt; root-&gt;_key &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            height = leftHeight &gt; rightHeight ? leftHeight + <span class="number">1</span> : rightHeight + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &lt; <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsBalance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> _IsBalance(_root, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _InOrder(Node* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _InOrder(root-&gt;_left);</span><br><span class="line">        cout &lt;&lt; root-&gt;_key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        _InOrder(root-&gt;_right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _InOrder(_root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* _root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="type">bool</span> AVLTree&lt;K, V&gt;::<span class="built_in">AVLInsert</span>(K key, V val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.根节点为空，直接插入</span></span><br><span class="line">    <span class="keyword">if</span> (_root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span>(key, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.根节点不为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node* cur = _root;</span><br><span class="line">        Node* parent =<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//a)找到要插入节点的位置</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//不允许出现重复元素的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//b)插入新节点</span></span><br><span class="line">        cur = <span class="keyword">new</span> <span class="built_in">Node</span>(key, val);</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;_key&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_left = cur;</span><br><span class="line">            cur-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_right = cur;</span><br><span class="line">            cur-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//c)插入完成后，调整平衡因子</span></span><br><span class="line">        <span class="keyword">while</span> (parent)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == parent-&gt;_left)<span class="comment">//插入节点在左子树父节点bf--，反之++</span></span><br><span class="line">            parent-&gt;_bf--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent-&gt;_bf++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1)插入新节点后，parent-&gt;bf==0;说明高度没变，平衡，返回</span></span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//2)插入节点后parent-&gt;_bf==-1||parent-&gt;_bf==1;说明子树高度改变，则继续向上调整</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-1</span> || parent-&gt;_bf == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = parent;</span><br><span class="line">                parent = parent-&gt;_parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3)插入节点后parent-&gt;_bf==-2||parent-&gt;_bf==2；说明已经不平衡，需要旋转</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;_bf == <span class="number">1</span>)</span><br><span class="line">                        <span class="built_in">RotateL</span>(parent);</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">// (cur-&gt;_bf == -1)</span></span><br><span class="line">                        <span class="built_in">RotateRL</span>(parent);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//parent-&gt;_bf == -2</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;_bf == <span class="number">-1</span>)</span><br><span class="line">                        <span class="built_in">RotateR</span>(parent);</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">// (cur-&gt;_bf == 1)</span></span><br><span class="line">                        <span class="built_in">RotateLR</span>(parent);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">//end while (parent)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;K, V&gt;::<span class="built_in">RotateL</span>(Node* parent)</span><br><span class="line">&#123;</span><br><span class="line">    Node*subR = parent-&gt;_right;</span><br><span class="line">    Node*subRL = subR-&gt;_left;</span><br><span class="line">    Node*pParent = parent-&gt;_parent;</span><br><span class="line"></span><br><span class="line">    parent-&gt;_right = subRL;</span><br><span class="line">    <span class="keyword">if</span> (subRL)</span><br><span class="line">        subRL-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">    subR-&gt;_left = parent;</span><br><span class="line">    parent-&gt;_parent = subR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent == _root)</span><br><span class="line">    &#123;</span><br><span class="line">        _root = subR;</span><br><span class="line">        _root-&gt;_parent = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pParent-&gt;_left = parent)</span><br><span class="line">            pParent-&gt;_left = subR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pParent-&gt;_right = subR;</span><br><span class="line"></span><br><span class="line">        subR-&gt;_parent = pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    parent-&gt;_bf = subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;K, V&gt;::<span class="built_in">RotateR</span>(Node* parent)</span><br><span class="line">&#123;</span><br><span class="line">    Node* subL = parent-&gt;_left;</span><br><span class="line">    Node* subLR = subL-&gt;_right;</span><br><span class="line">    Node* ppNode = parent-&gt;_parent;</span><br><span class="line"></span><br><span class="line">    parent-&gt;_left = subLR;</span><br><span class="line">    <span class="keyword">if</span> (subLR)</span><br><span class="line">        subLR-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">    subL-&gt;_right = parent;</span><br><span class="line">    parent-&gt;_parent = subL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_root == parent)</span><br><span class="line">    &#123;</span><br><span class="line">        _root = subL;</span><br><span class="line">        subL-&gt;_parent = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ppNode-&gt;_right == parent)</span><br><span class="line">        &#123;</span><br><span class="line">            ppNode-&gt;_right = subL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ppNode-&gt;_left = subL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subL-&gt;_parent = ppNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subL-&gt;_bf = parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;K, V&gt;::<span class="built_in">RotateLR</span>(Node* parent)</span><br><span class="line">&#123;</span><br><span class="line">    Node* subL = parent-&gt;_left;</span><br><span class="line">    Node* subLR = subL-&gt;_right;</span><br><span class="line">    <span class="type">int</span> bf = subLR-&gt;_bf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RotateL</span>(parent-&gt;_left);</span><br><span class="line">    <span class="built_in">RotateR</span>(parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bf == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        subLR-&gt;_bf = subL-&gt;_bf = parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">        subL-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">        subLR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        parent-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">        subL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">        subLR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;K, V&gt;::<span class="built_in">RotateRL</span>(Node* parent)</span><br><span class="line">&#123;</span><br><span class="line">    Node* subR = parent-&gt;_right;</span><br><span class="line">    Node* subRL = subR-&gt;_left;</span><br><span class="line">    <span class="type">int</span> bf = subRL-&gt;_bf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RotateR</span>(parent-&gt;_right);</span><br><span class="line">    <span class="built_in">RotateL</span>(parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bf == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        subRL-&gt;_bf = subR-&gt;_bf = parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        subR-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">        parent-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">        subRL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">        subR-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">        subRL-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestAVLtree</span><span class="params">()</span> <span class="comment">//测试代码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">14</span> &#125;;</span><br><span class="line">    <span class="comment">//&#123;16, 3, 7, 11, 9, 26, 18, 14, 15&#125;;</span></span><br><span class="line">    AVLTree&lt;<span class="type">int</span>, <span class="type">int</span>&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">AVLInsert</span>(a[i], i);</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t.<span class="built_in">IsBalance</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">InOrder</span>();</span><br><span class="line">    cout &lt;&lt; t.<span class="built_in">IsBalance</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更清晰的一个图"><a href="#更清晰的一个图" class="headerlink" title="更清晰的一个图"></a>更清晰的一个图</h2><p>旋转操作用来重新平衡树的某个部分。通过重新安排结点 ，使结点之间的关系始终保持左子结点小于父结点，父结点小于右子结点。使得该树仍然是一颗二叉搜索树。旋转过后，旋转子树中的所有结点的平衡因子都为+1、-1或0。</p>
<p>AVL树的旋转类型有4种， 分别是LL(left-left)旋转、LR(left-right)旋转、RR(right-right)旋转和RL(right-left)旋转。</p>
<p>为方便理解在何时执行哪一种旋转，设x代表刚插入AVL树中的结点，设A为离x最近且平衡因子更改为2的绝对值的祖先。</p>
<h3 id="LL旋转"><a href="#LL旋转" class="headerlink" title="LL旋转"></a>LL旋转</h3><p>如下图所示，当x位于A的左子树的左子树上时，执行LL旋转。</p>
<p>设left为A的左子树，要执行LL旋转，将A的左指针指向left的右子结点，left的右指针指向A，将原来指向A的指针指向left。</p>
<p>旋转过后，将A和left的平衡因子都改为0。所有其他结点的平衡因子没有发生变化。</p>
<p><img src="/img/20211114001300.jpg" alt=""></p>
<h3 id="LR旋转"><a href="#LR旋转" class="headerlink" title="LR旋转"></a>LR旋转</h3><p>当x位于A的左子树的右子树上时，执行LR旋转。</p>
<p>设left是A的左子结点，并设A的子孙结点grandchild为left的右子结点。</p>
<p>要执行LR旋转，将left的右子结点指向grandchild的左子结点，grandchild的左子结点指向left，A的左子结点指向grandchild的右子结点，再将grandchild的右子结点指向A，最后将原来指向A的指针指向grandchild。</p>
<p>执行LR旋转之后，调整结点的平衡因子取决于旋转前grandchild结点的原平衡因子值。</p>
<ul>
<li>如果grandchild结点的原始平衡因子为+1，就将A的平衡因子设为-1，将left的平衡因子设为0。</li>
<li>如果grandchild结点的原始平衡因子为0，就将A和left的平衡因子都设置为0。</li>
<li>如果grandchild结点的原始平衡因子为-1，就将A的平衡因子设置为0，将left的平衡因子设置为+1。</li>
</ul>
<p>在所有的情况下，grandchild的新平衡因子都是0。所有其他结点的平衡因子都没有改变。</p>
<p><img src="/img/20211114001301.jpg" alt=""></p>
<h3 id="RR旋转"><a href="#RR旋转" class="headerlink" title="RR旋转"></a>RR旋转</h3><p>当x位于A的右子树的右子树上时，执行RR旋转。</p>
<p>RR旋转与LL旋转是对称的关系。</p>
<p>设A的右子结点为Right。要执行RR旋转，将A的右指针指向right的左子结点，right的左指针指向A，原来指向A的指针修改为指向right。</p>
<p>完成旋转以后，将A和left的平衡因子都修改为0。所有其他结点的平衡因子都没有改变。<br><img src="/img/20211114001302.jpg" alt=""></p>
<h3 id="RL旋转"><a href="#RL旋转" class="headerlink" title="RL旋转"></a>RL旋转</h3><p>当x位于A的右子树的左子树上时，执行RL旋转。</p>
<p>RL旋转与LR旋转是对称的关系。</p>
<p>设A的右子结点为right，right的左子结点为grandchild。要执行RL旋转，将right结点的左子结点指向grandchild的右子结点，将grandchild的右子结点指向right，将A的右子结点指向grandchild的左子结点，将grandchild的左子结点指向A，最后将原来指向A的指针指向grandchild。</p>
<p>执行RL旋转以后，调整结点的平衡因子取决于旋转前grandchild结点的原平衡因子。这里也有三种情况需要考虑：</p>
<ul>
<li>如果grandchild的原始平衡因子值为+1，将A的平衡因子更新为0，right的更新为-1；</li>
<li>如果grandchild的原始平衡因子值为 0，将A和right的平衡因子都更新为0；</li>
<li>如果grandchild的原始平衡因子值为-1，将A的平衡因子更新为+1，right的更新为0；</li>
</ul>
<p>在所有情况中，都将grandchild的新平衡因子设置为0。所有其他结点的平衡因子不发生改变。<br><img src="/img/20211114001303.jpg" alt=""></p>
<h2 id="AVL树的删除操作"><a href="#AVL树的删除操作" class="headerlink" title="AVL树的删除操作"></a>AVL树的删除操作</h2><p>同插入操作一样，删除结点时也有可能破坏平衡性，这就要求我们删除的时候要进行平衡性调整。</p>
<p>首先在整个二叉树中搜索要删除的结点，如果没搜索到直接返回不作处理，否则执行以下操作：</p>
<ul>
<li>要删除的节点是当前根节点T。<ul>
<li>如果左右子树都非空。在高度较大的子树中实施删除操作。分两种情况：<ul>
<li>左子树高度大于右子树高度，将左子树中最大的那个元素赋给当前根节点，然后删除左子树中元素值最大的那个节点。</li>
<li>左子树高度小于右子树高度，将右子树中最小的那个元素赋给当前根节点，然后删除右子树中元素值最小的那个节点。</li>
</ul>
</li>
<li>如果左右子树中有一个为空，那么直接用那个非空子树或者是NULL替换当前根节点即可。</li>
</ul>
</li>
<li>要删除的节点元素值小于当前根节点T值，在左子树中进行删除。<ul>
<li>递归调用，在左子树中实施删除。</li>
<li>这个是需要判断当前根节点是否仍然满足平衡条件，</li>
<li>如果满足平衡条件，只需要更新当前根节点T的高度信息。</li>
<li>否则，需要进行旋转调整：</li>
<li>如果T的左子节点的左子树的高度大于T的左子节点的右子树的高度，进行相应的单旋转。否则进行双旋转。</li>
</ul>
</li>
<li>要删除的节点元素值大于当前根节点T值，在右子树中进行删除。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line">下面给出详细代码实现：</span><br><span class="line"></span><br><span class="line">AvlTree.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">//平衡二叉树结点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AvlNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="type">int</span> height; <span class="comment">//结点所在高度</span></span><br><span class="line">    AvlNode&lt;T&gt; *left;</span><br><span class="line">    AvlNode&lt;T&gt; *right;</span><br><span class="line">    <span class="built_in">AvlNode</span>&lt;T&gt;(<span class="type">const</span> T theData) : <span class="built_in">data</span>(theData), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>), <span class="built_in">height</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//AvlTree</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AvlTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AvlTree</span>&lt;T&gt;()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">AvlTree</span>&lt;T&gt;()&#123;&#125;</span><br><span class="line">    AvlNode&lt;T&gt; *root;</span><br><span class="line">    <span class="comment">//插入结点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(AvlNode&lt;T&gt; *&amp;t, T x)</span></span>;</span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Delete</span><span class="params">(AvlNode&lt;T&gt; *&amp;t, T x)</span></span>;</span><br><span class="line">    <span class="comment">//查找是否存在给定值的结点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Contains</span><span class="params">(AvlNode&lt;T&gt; *t, <span class="type">const</span> T x)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InorderTraversal</span><span class="params">(AvlNode&lt;T&gt; *t)</span></span>;</span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreorderTraversal</span><span class="params">(AvlNode&lt;T&gt; *t)</span></span>;</span><br><span class="line">    <span class="comment">//最小值结点</span></span><br><span class="line">    <span class="function">AvlNode&lt;T&gt; *<span class="title">FindMin</span><span class="params">(AvlNode&lt;T&gt; *t)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//最大值结点</span></span><br><span class="line">    <span class="function">AvlNode&lt;T&gt; *<span class="title">FindMax</span><span class="params">(AvlNode&lt;T&gt; *t)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//求树的高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetHeight</span><span class="params">(AvlNode&lt;T&gt; *t)</span></span>;</span><br><span class="line">    <span class="comment">//单旋转 左</span></span><br><span class="line">    <span class="function">AvlNode&lt;T&gt; *<span class="title">LL</span><span class="params">(AvlNode&lt;T&gt; *t)</span></span>;</span><br><span class="line">    <span class="comment">//单旋转 右</span></span><br><span class="line">    <span class="function">AvlNode&lt;T&gt; *<span class="title">RR</span><span class="params">(AvlNode&lt;T&gt; *t)</span></span>;</span><br><span class="line">    <span class="comment">//双旋转 右左</span></span><br><span class="line">    <span class="function">AvlNode&lt;T&gt; *<span class="title">LR</span><span class="params">(AvlNode&lt;T&gt; *t)</span></span>;</span><br><span class="line">    <span class="comment">//双旋转 左右</span></span><br><span class="line">    <span class="function">AvlNode&lt;T&gt; *<span class="title">RL</span><span class="params">(AvlNode&lt;T&gt; *t)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">AvlNode&lt;T&gt; * AvlTree&lt;T&gt;::<span class="built_in">FindMax</span>(AvlNode&lt;T&gt; *t) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FindMax</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">AvlNode&lt;T&gt; * AvlTree&lt;T&gt;::<span class="built_in">FindMin</span>(AvlNode&lt;T&gt; *t) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FindMin</span>(t-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> AvlTree&lt;T&gt;::<span class="built_in">GetHeight</span>(AvlNode&lt;T&gt; *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单旋转</span></span><br><span class="line"><span class="comment">//左左插入导致的不平衡</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">AvlNode&lt;T&gt; * AvlTree&lt;T&gt;::<span class="built_in">LL</span>(AvlNode&lt;T&gt; *t)</span><br><span class="line">&#123;</span><br><span class="line">    AvlNode&lt;T&gt; *q = t-&gt;left;</span><br><span class="line">    t-&gt;left = q-&gt;right;</span><br><span class="line">    q-&gt;right = t;</span><br><span class="line">    t = q;</span><br><span class="line">    t-&gt;height = <span class="built_in">max</span>(<span class="built_in">GetHeight</span>(t-&gt;left), <span class="built_in">GetHeight</span>(t-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    q-&gt;height = <span class="built_in">max</span>(<span class="built_in">GetHeight</span>(q-&gt;left), <span class="built_in">GetHeight</span>(q-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单旋转</span></span><br><span class="line"><span class="comment">//右右插入导致的不平衡</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">AvlNode&lt;T&gt; * AvlTree&lt;T&gt;::<span class="built_in">RR</span>(AvlNode&lt;T&gt; *t)</span><br><span class="line">&#123;</span><br><span class="line">    AvlNode&lt;T&gt; *q = t-&gt;right;</span><br><span class="line">    t-&gt;right = q-&gt;left;</span><br><span class="line">    q-&gt;left = t;</span><br><span class="line">    t = q;</span><br><span class="line">    t-&gt;height = <span class="built_in">max</span>(<span class="built_in">GetHeight</span>(t-&gt;left), <span class="built_in">GetHeight</span>(t-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    q-&gt;height = <span class="built_in">max</span>(<span class="built_in">GetHeight</span>(q-&gt;left), <span class="built_in">GetHeight</span>(q-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双旋转</span></span><br><span class="line"><span class="comment">//插入点位于t的左儿子的右子树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">AvlNode&lt;T&gt; * AvlTree&lt;T&gt;::<span class="built_in">LR</span>(AvlNode&lt;T&gt; *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//双旋转可以通过两次单旋转实现</span></span><br><span class="line">    <span class="comment">//对t的左结点进行RR旋转，再对根节点进行LL旋转</span></span><br><span class="line">    <span class="built_in">RR</span>(t-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LL</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双旋转</span></span><br><span class="line"><span class="comment">//插入点位于t的右儿子的左子树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">AvlNode&lt;T&gt; * AvlTree&lt;T&gt;::<span class="built_in">RL</span>(AvlNode&lt;T&gt; *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">LL</span>(t-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RR</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> AvlTree&lt;T&gt;::<span class="built_in">Insert</span>(AvlNode&lt;T&gt; *&amp;t, T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        t = <span class="keyword">new</span> <span class="built_in">AvlNode</span>&lt;T&gt;(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; t-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Insert</span>(t-&gt;left, x);</span><br><span class="line">        <span class="comment">//判断平衡情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetHeight</span>(t-&gt;left) - <span class="built_in">GetHeight</span>(t-&gt;right) &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//分两种情况 左左或左右</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt; t-&gt;left-&gt;data)<span class="comment">//左左</span></span><br><span class="line">                t = <span class="built_in">LL</span>(t);</span><br><span class="line">            <span class="keyword">else</span>                  <span class="comment">//左右</span></span><br><span class="line">                t = <span class="built_in">LR</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; t-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Insert</span>(t-&gt;right, x);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetHeight</span>(t-&gt;right) - <span class="built_in">GetHeight</span>(t-&gt;left) &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; t-&gt;right-&gt;data)</span><br><span class="line">                t = <span class="built_in">RR</span>(t);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t = <span class="built_in">RL</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ;<span class="comment">//数据重复</span></span><br><span class="line">    t-&gt;height = <span class="built_in">max</span>(<span class="built_in">GetHeight</span>(t-&gt;left), <span class="built_in">GetHeight</span>(t-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> AvlTree&lt;T&gt;::<span class="built_in">Delete</span>(AvlNode&lt;T&gt; *&amp;t, T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//t为空 未找到要删除的结点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//找到了要删除的结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;data == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//左右子树都非空</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left != <span class="literal">NULL</span> &amp;&amp; t-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;<span class="comment">//在高度更大的那个子树上进行删除操作</span></span><br><span class="line">            <span class="comment">//左子树高度大，删除左子树中值最大的结点，将其赋给根结点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetHeight</span>(t-&gt;left) &gt; <span class="built_in">GetHeight</span>(t-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                t-&gt;data = <span class="built_in">FindMax</span>(t-&gt;left)-&gt;data;</span><br><span class="line">                <span class="built_in">Delete</span>(t-&gt;left, t-&gt;data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//右子树高度更大，删除右子树中值最小的结点，将其赋给根结点</span></span><br><span class="line">            &#123;</span><br><span class="line">                t-&gt;data = <span class="built_in">FindMin</span>(t-&gt;right)-&gt;data;</span><br><span class="line">                <span class="built_in">Delete</span>(t-&gt;right, t-&gt;data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;<span class="comment">//左右子树有一个不为空，直接用需要删除的结点的子结点替换即可</span></span><br><span class="line">            AvlNode&lt;T&gt; *old = t;</span><br><span class="line">            t = t-&gt;left ? t-&gt;left: t-&gt;right;<span class="comment">//t赋值为不空的子结点</span></span><br><span class="line">            <span class="keyword">delete</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; t-&gt;data)<span class="comment">//要删除的结点在左子树上</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//递归删除左子树上的结点</span></span><br><span class="line">        <span class="built_in">Delete</span>(t-&gt;left, x);</span><br><span class="line">        <span class="comment">//判断是否仍然满足平衡条件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetHeight</span>(t-&gt;right) - <span class="built_in">GetHeight</span>(t-&gt;left) &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetHeight</span>(t-&gt;right-&gt;left) &gt; <span class="built_in">GetHeight</span>(t-&gt;right-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//RL双旋转</span></span><br><span class="line">                t = <span class="built_in">RL</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="comment">//RR单旋转</span></span><br><span class="line">                t = <span class="built_in">RR</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//满足平衡条件 调整高度信息</span></span><br><span class="line">        &#123;</span><br><span class="line">            t-&gt;height = <span class="built_in">max</span>(<span class="built_in">GetHeight</span>(t-&gt;left), <span class="built_in">GetHeight</span>(t-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//要删除的结点在右子树上</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//递归删除右子树结点</span></span><br><span class="line">        <span class="built_in">Delete</span>(t-&gt;right, x);</span><br><span class="line">        <span class="comment">//判断平衡情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetHeight</span>(t-&gt;left) - <span class="built_in">GetHeight</span>(t-&gt;right) &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetHeight</span>(t-&gt;left-&gt;right) &gt; <span class="built_in">GetHeight</span>(t-&gt;left-&gt;left))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//LR双旋转</span></span><br><span class="line">                t = <span class="built_in">LR</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//LL单旋转</span></span><br><span class="line">                t = <span class="built_in">LL</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//满足平衡性 调整高度</span></span><br><span class="line">        &#123;</span><br><span class="line">            t-&gt;height = <span class="built_in">max</span>(<span class="built_in">GetHeight</span>(t-&gt;left), <span class="built_in">GetHeight</span>(t-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找结点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> AvlTree&lt;T&gt;::<span class="built_in">Contains</span>(AvlNode&lt;T&gt; *t, <span class="type">const</span> T x) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; t-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Contains</span>(t-&gt;left, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; t-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Contains</span>(t-&gt;right, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> AvlTree&lt;T&gt;::<span class="built_in">InorderTraversal</span>(AvlNode&lt;T&gt; *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InorderTraversal</span>(t-&gt;left);</span><br><span class="line">        cout &lt;&lt; t-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">InorderTraversal</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> AvlTree&lt;T&gt;::<span class="built_in">PreorderTraversal</span>(AvlNode&lt;T&gt; *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; t-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">PreorderTraversal</span>(t-&gt;left);</span><br><span class="line">        <span class="built_in">PreorderTraversal</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="红黑树详解"><a href="#红黑树详解" class="headerlink" title="红黑树详解"></a>红黑树详解</h1><p>转载请标明出处，原文地址：<a href="http://blog.csdn.net/hackbuteer1/article/details/7740956">http://blog.csdn.net/hackbuteer1/article/details/7740956</a> </p>
<h2 id="红黑树概述"><a href="#红黑树概述" class="headerlink" title="红黑树概述"></a>红黑树概述</h2><p>红黑树和我们以前学过的AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。不过自从红黑树出来后，AVL树就被放到了博物馆里，据说是红黑树有更好的效率，更高的统计性能。这一点在我们了解了红黑树的实现原理后，就会有更加深切的体会。</p>
<p>红黑树和AVL树的区别在于它使用颜色来标识结点的高度，它所追求的是局部平衡而不是AVL树中的非常严格的平衡。学过数据结构的人应该都已经领教过AVL树的复杂，但AVL树的复杂比起红黑树来说简直是小巫见大巫，红黑树才是真正的变态级数据结构。由于STL中的关联式容器默认的底层实现都是红黑树，因此红黑树对于后续学习STL源码还是很重要的，有必要掌握红黑树的实现原理和源码实现。红黑树是AVL树的变种，红黑树通过一些着色法则确保没有一条路径会比其它路径长出两倍，因而达到接近平衡的目的。所谓红黑树，不仅是一个二叉搜索树，而且必须满足以下规则：</p>
<ol>
<li>每个节点不是红色就是黑色。</li>
<li>根节点为黑色。</li>
<li>如果节点为红色，其子节点必须为黑色。</li>
<li>任意一个节点到到NULL（树尾端）的任何路径，所含之黑色节点数必须相同。</li>
</ol>
<p>上面的这些约束保证了这个树大致上是平衡的，这也决定了红黑树的插入、删除、查询等操作是比较快速的。 根据规则4，新增节点必须为红色；根据规则3，新增节点之父节点必须为黑色。当新增节点根据二叉搜索树的规则到达其插入点时，却未能符合上述条件时，就必须调整颜色并旋转树形，如下图：<br><img src="/img/1342081846_5019.png" alt=""></p>
<p>假设我们为上图分别插入节点3、8、35、75，根据二叉搜索树的规则，插入这四个节点后，我们会发现它们都破坏了红黑树的规则，因此我们必须调整树形，也就是旋转树形并改变节点的颜色。</p>
<h2 id="红黑树上结点的插入"><a href="#红黑树上结点的插入" class="headerlink" title="红黑树上结点的插入"></a>红黑树上结点的插入</h2><p>在讨论红黑树的插入操作之前必须要明白，任何一个即将插入的新结点的初始颜色都为红色。这一点很容易理解，因为插入黑点会增加某条路径上黑结点的数目，从而导致整棵树黑高度的不平衡。但如果新结点的父结点为红色时（如下图所示），将会违反红黑树的性质：一条路径上不能出现相邻的两个红色结点。这时就需要通过一系列操作来使红黑树保持平衡。<br><img src="/img/1342082295_4867.jpg" alt=""></p>
<p>为了清楚地表示插入操作以下在结点中使用“新”字表示一个新插入的结点；使用“父”字表示新插入点的父结点；使用“叔”字表示“父”结点的兄弟结点；使用“祖”字表示“父”结点的父结点。插入操作分为以下几种情况：</p>
<h3 id="黑父"><a href="#黑父" class="headerlink" title="黑父"></a>黑父</h3><p>如下图所示，如果新节点的父结点为黑色结点，那么插入一个红点将不会影响红黑树的平衡，此时插入操作完成。红黑树比AVL树优秀的地方之一在于黑父的情况比较常见，从而使红黑树需要旋转的几率相对AVL树来说会少一些。<br><img src="/img/1342082985_8252.jpg" alt=""></p>
<h3 id="红父"><a href="#红父" class="headerlink" title="红父"></a>红父</h3><p>如果新节点的父结点为红色，这时就需要进行一系列操作以保证整棵树红黑性质。如下图所示，由于父结点为红色，此时可以判定，祖父结点必定为黑色。这时需要根据叔父结点的颜色来决定做什么样的操作。青色结点表示颜色未知。由于有可能需要根结点到新点的路径上进行多次旋转操作，而每次进行不平衡判断的起始点（我们可将其视为新点）都不一样。所以我们在此使用一个蓝色箭头指向这个起始点，并称之为判定点。<br><img src="/img/1342083075_5573.jpg" alt=""></p>
<h3 id="红叔"><a href="#红叔" class="headerlink" title="红叔"></a>红叔</h3><p>当叔父结点为红色时，如下图所示，无需进行旋转操作，只要将父和叔结点变为黑色，将祖父结点变为红色即可。但由于祖父结点的父结点有可能为红色，从而违反红黑树性质。此时必须将祖父结点作为新的判定点继续向上（迭代）进行平衡操作。<br><img src="/img/1342083201_9333.jpg" alt=""></p>
<p>需要注意的是，无论“父节点”在“叔节点”的左边还是右边，无论“新节点”是“父节点”的左孩子还是右孩子，它们的操作都是完全一样的（其实这种情况包括4种，只需调整颜色，不需要旋转树形）。</p>
<h3 id="黑叔"><a href="#黑叔" class="headerlink" title="黑叔"></a>黑叔</h3><p>当叔父结点为黑色时，需要进行旋转，以下图示了所有的旋转可能：</p>
<p>Case 1:<br><img src="/img/1342083532_9981.jpg" alt=""></p>
<p>Case 2:<br><img src="/img/1342083571_7513.jpg" alt=""></p>
<p>Case 3:<br><img src="/img/1342083759_7035.jpg" alt=""></p>
<p>Case 4:<br><img src="/img/1342083770_6903.jpg" alt=""></p>
<p>可以观察到，当旋转完成后，新的旋转根全部为黑色，此时不需要再向上回溯进行平衡操作，插入操作完成。需要注意，上面四张图的“叔”、“1”、“2”、“3”结点有可能为黑哨兵结点。</p>
<p>其实红黑树的插入操作不是很难，甚至比AVL树的插入操作还更简单些。红黑树的插入操作源代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素插入操作  insert_unique()</span></span><br><span class="line"><span class="comment">// 插入新值：节点键值不允许重复，若重复则插入无效</span></span><br><span class="line"><span class="comment">// 注意，返回值是个pair，第一个元素是个红黑树迭代器，指向新增节点</span></span><br><span class="line"><span class="comment">// 第二个元素表示插入成功与否</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">pair&lt;<span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator, <span class="type">bool</span>&gt;</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_unique</span>(<span class="type">const</span> Value &amp;v)&#123;</span><br><span class="line">    rb_tree_node* y = header;    <span class="comment">// 根节点root的父节点</span></span><br><span class="line">    rb_tree_node* x = <span class="built_in">root</span>();    <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="type">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x));    <span class="comment">// v键值小于目前节点之键值？</span></span><br><span class="line">        x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);   <span class="comment">// 遇“大”则往左，遇“小于或等于”则往右    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 离开while循环之后，y所指即插入点之父节点（此时的它必为叶节点）</span></span><br><span class="line">    iterator j = <span class="built_in">iterator</span>(y);     <span class="comment">// 令迭代器j指向插入点之父节点y</span></span><br><span class="line">    <span class="keyword">if</span>(comp)     <span class="comment">// 如果离开while循环时comp为真（表示遇“大”，将插入于左侧）    </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="built_in">begin</span>())    <span class="comment">// 如果插入点之父节点为最左节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(_insert(x, y, z), <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span>     <span class="comment">// 否则（插入点之父节点不为最左节点）</span></span><br><span class="line">            --j;   <span class="comment">// 调整j，回头准备测试</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node), <span class="built_in">KeyOfValue</span>()(v) ))        <span class="comment">// 新键值不与既有节点之键值重复，于是以下执行安插操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(_insert(x, y, z), <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 以上，x为新值插入点，y为插入点之父节点，v为新值     </span></span><br><span class="line">    <span class="comment">// 进行至此，表示新值一定与树中键值重复，那么就不应该插入新值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正地插入执行程序 _insert()</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::_insert(base_ptr x_, base_ptr y_, <span class="type">const</span> Value &amp;v)</span><br><span class="line">&#123;    <span class="comment">// 参数x_ 为新值插入点，参数y_为插入点之父节点，参数v为新值</span></span><br><span class="line">    link_type x = (link_type) x_;</span><br><span class="line">    link_type y = (link_type) y_;</span><br><span class="line">    link_type z;     <span class="comment">// key_compare 是键值大小比较准则。应该会是个function object</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y == header || x != <span class="number">0</span> || <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(y) ))    &#123;</span><br><span class="line">        z = <span class="built_in">create_node</span>(v);    <span class="comment">// 产生一个新节点</span></span><br><span class="line">        <span class="built_in">left</span>(y) = z;           <span class="comment">// 这使得当y即为header时，leftmost() = z</span></span><br><span class="line">        <span class="keyword">if</span>(y == header)    &#123;</span><br><span class="line">            <span class="built_in">root</span>() = z;</span><br><span class="line">            <span class="built_in">rightmost</span>() = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y == <span class="built_in">leftmost</span>())     <span class="comment">// 如果y为最左节点    </span></span><br><span class="line">            <span class="built_in">leftmost</span>() = z;          <span class="comment">// 维护leftmost()，使它永远指向最左节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        z = <span class="built_in">create_node</span>(v);        <span class="comment">// 产生一个新节点</span></span><br><span class="line">        <span class="built_in">right</span>(y) = z;              <span class="comment">// 令新节点成为插入点之父节点y的右子节点</span></span><br><span class="line">        <span class="keyword">if</span>(y == <span class="built_in">rightmost</span>())</span><br><span class="line">            <span class="built_in">rightmost</span>() = z;       <span class="comment">// 维护rightmost()，使它永远指向最右节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">parent</span>(z) = y;      <span class="comment">// 设定新节点的父节点</span></span><br><span class="line">    <span class="built_in">left</span>(z) = <span class="number">0</span>;        <span class="comment">// 设定新节点的左子节点</span></span><br><span class="line">    <span class="built_in">right</span>(z) = <span class="number">0</span>;       <span class="comment">// 设定新节点的右子节点    </span></span><br><span class="line">    <span class="comment">// 新节点的颜色将在_rb_tree_rebalance()设定（并调整）</span></span><br><span class="line">    _rb_tree_rebalance(z, header-&gt;parent);      <span class="comment">// 参数一为新增节点，参数二为根节点root    </span></span><br><span class="line">    ++node_count;       <span class="comment">// 节点数累加</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(z);  <span class="comment">// 返回一个迭代器，指向新增节点</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="comment">// 重新令树形平衡（改变颜色及旋转树形）</span></span><br><span class="line"><span class="comment">// 参数一为新增节点，参数二为根节点root</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _rb_tree_rebalance(_rb_tree_node_base* x, _rb_tree_node_base*&amp; root) &#123;</span><br><span class="line">    x-&gt;color = _rb_tree_red;    <span class="comment">//新节点必为红    </span></span><br><span class="line">    <span class="keyword">while</span>(x != root &amp;&amp; x-&gt;parent-&gt;color == _rb_tree_red)    <span class="comment">// 父节点为红    </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left)      <span class="comment">// 父节点为祖父节点之左子节点</span></span><br><span class="line">        &#123;            </span><br><span class="line">            _rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;right;    <span class="comment">// 令y为伯父节点            </span></span><br><span class="line">            <span class="keyword">if</span>(y &amp;&amp; y-&gt;color == _rb_tree_red)    <span class="comment">// 伯父节点存在，且为红            </span></span><br><span class="line">            &#123;</span><br><span class="line">                x-&gt;parent-&gt;color = _rb_tree_black;           <span class="comment">// 更改父节点为黑色</span></span><br><span class="line">                y-&gt;color = _rb_tree_black;                   <span class="comment">// 更改伯父节点为黑色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = _rb_tree_red;     <span class="comment">// 更改祖父节点为红色</span></span><br><span class="line">                x = x-&gt;parent-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// 无伯父节点，或伯父节点为黑色</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x == x-&gt;parent-&gt;right)   <span class="comment">// 如果新节点为父节点之右子节点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    _rb_tree_rotate_left(x, root);    <span class="comment">// 第一个参数为左旋点</span></span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = _rb_tree_black;     <span class="comment">// 改变颜色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = _rb_tree_red;</span><br><span class="line">                _rb_tree_rotate_right(x-&gt;parent-&gt;parent, root);    <span class="comment">// 第一个参数为右旋点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>          <span class="comment">// 父节点为祖父节点之右子节点        </span></span><br><span class="line">        &#123;</span><br><span class="line">            _rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left;    <span class="comment">// 令y为伯父节点</span></span><br><span class="line">            <span class="keyword">if</span>(y &amp;&amp; y-&gt;color == _rb_tree_red)    <span class="comment">// 有伯父节点，且为红</span></span><br><span class="line">            &#123;</span><br><span class="line">                x-&gt;parent-&gt;color = _rb_tree_black;           <span class="comment">// 更改父节点为黑色</span></span><br><span class="line">                y-&gt;color = _rb_tree_black;                   <span class="comment">// 更改伯父节点为黑色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = _rb_tree_red;     <span class="comment">// 更改祖父节点为红色</span></span><br><span class="line">                x = x-&gt;parent-&gt;parent;          <span class="comment">// 准备继续往上层检查</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// 无伯父节点，或伯父节点为黑色    </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)        <span class="comment">// 如果新节点为父节点之左子节点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    _rb_tree_rotate_right(x, root);    <span class="comment">// 第一个参数为右旋点</span></span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = _rb_tree_black;     <span class="comment">// 改变颜色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = _rb_tree_red;</span><br><span class="line">                _rb_tree_rotate_left(x-&gt;parent-&gt;parent, root);    <span class="comment">// 第一个参数为左旋点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    root-&gt;color = _rb_tree_black;    <span class="comment">// 根节点永远为黑色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _rb_tree_rotate_left(_rb_tree_node_base* x, _rb_tree_node_base*&amp; root)</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// x 为旋转点</span></span><br><span class="line">    _rb_tree_node_base* y = x-&gt;right;          <span class="comment">// 令y为旋转点的右子节点    </span></span><br><span class="line">    x-&gt;right = y-&gt;left;    </span><br><span class="line">    <span class="keyword">if</span>(y-&gt;left != <span class="number">0</span>)    </span><br><span class="line">        y-&gt;left-&gt;parent = x;           <span class="comment">// 别忘了回马枪设定父节点</span></span><br><span class="line">    y-&gt;parent = x-&gt;parent;     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 令y完全顶替x的地位（必须将x对其父节点的关系完全接收过来）</span></span><br><span class="line">    <span class="keyword">if</span>(x == root)    <span class="comment">// x为根节点</span></span><br><span class="line">        root = y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)         <span class="comment">// x为其父节点的左子节点</span></span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">// x为其父节点的右子节点        </span></span><br><span class="line">        x-&gt;parent-&gt;right = y;    </span><br><span class="line">    </span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _rb_tree_rotate_right(_rb_tree_node_base* x, _rb_tree_node_base*&amp; root)</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// x 为旋转点</span></span><br><span class="line">    _rb_tree_node_base* y = x-&gt;left;          <span class="comment">// 令y为旋转点的左子节点    </span></span><br><span class="line">    x-&gt;left = y-&gt;right;    </span><br><span class="line">    <span class="keyword">if</span>(y-&gt;right != <span class="number">0</span>)</span><br><span class="line">        y-&gt;right-&gt;parent = x;           <span class="comment">// 别忘了回马枪设定父节点</span></span><br><span class="line">    y-&gt;parent = x-&gt;parent;     <span class="comment">// 令y完全顶替x的地位（必须将x对其父节点的关系完全接收过来）</span></span><br><span class="line">    <span class="keyword">if</span>(x == root)</span><br><span class="line">        root = y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;right)         <span class="comment">// x为其父节点的右子节点</span></span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">// x为其父节点的左子节点</span></span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line"></span><br><span class="line">    y-&gt;right = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>算法导论书上给出的红黑树的性质如下，跟STL源码剖析书上面的4条性质大同小异。</p>
<ol>
<li>每个结点或是红色的，或是黑色的</li>
<li>根节点是黑色的</li>
<li>每个叶结点（NIL）是黑色的</li>
<li>如果一个节点是红色的，则它的两个儿子都是黑色的。</li>
<li>对于每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑色结点。</li>
</ol>
<p>从红黑树上删除一个节点，可以先用普通二叉搜索树的方法，将节点从红黑树上删除掉，然后再将被破坏的红黑性质进行恢复。我们回忆一下普通二叉树的节点删除方法：Z指向需要删除的节点，Y指向实质结构上被删除的结点，如果Z节点只有一个子节点或没有子节点，那么Y就是指向Z指向的节点。如果Z节点有两个子节点，那么Y指向Z节点的后继节点（其实前趋也是一样的），而Z的后继节点绝对不可能有左子树。因此，仅从结构来看，二叉树上实质被删除的节点最多只可能有一个子树。</p>
<p>现在我们来看红黑性质的恢复过程：如果Y指向的节点是个红色节点，那么直接删除掉Y以后，红黑性质不会被破坏。操作结束。如果Y指向的节点是个黑色节点，那么就有几条红黑性质可能受到破坏了。首先是包含Y节点的所有路径，黑高度都减少了一（第５条被破坏）。其次，如果Y的有红色子节点，Y又有红色的父节点，那么Y被删除后，就出现了两个相邻的红色节点（第４条被破坏）。最后，如果Y指向的是根节点，而Y的子节点又是红色的，那么Y被删除后，根节点就变成红色的了（第2条被破坏）。其中，第5条被破坏是让我们比较难受的。因为这影响到了全局。这样动作就太大太复杂了。而且在这个条件下，进行其它红黑性质的恢复也很困难。</p>
<p>所以我们首先解决这个问题：如果不改变含Y路径的黑高度，那么树的其它部分的黑高度就必须做出相应的变化来适应它。所以，我们想办法恢复原来含Y节点的路径的黑高度。做法就是：无条件的把Y节点的黑色，推到它的子节点X上去。（X可能是NIL节点）。这样，X就可能具有双重黑色，或同时具有红黑两色，也就是第1条性质被破坏了。但第１条性质是比较容易恢复的：</p>
<ol>
<li>如果X是同时具有红黑两色，那么好办，直接把X涂成黑色，就行了。而且这样把所有问题都解决了。因为将X变为黑色，2、4两条如果有问题的话也会得到恢复，算法结束。</li>
<li>如果X是双黑色，那么我们希望把这种情况向上推一直推到根节点（调整树结构和颜色，X的指向新的双黑色节点，X不断向上移动），让根节点具双黑色，这时，直接把X的一层黑色去掉就行了（因为根节点被包含在所有的路径上，所以这样做所有路径同时黑高减少一，不会破坏红黑特征）。</li>
</ol>
<p>下面就具体地分析如何恢复1、2、4三个可能被破坏的红黑特性：我们知道，如果X指向的节点是有红黑两色，或是X是根节点时，只需要简单的对X进行一些改变就行了。要对除X节点外的其它节点进行操作时，必定是这样的情况：X节点是双层黑色，且X有父节点P。由知可知，X必然有兄弟节点W，而且这个W节点必定有两个子节点。（因为这是原树满足红黑条件要求而自然具备的。X为双黑色，那么P的另一个子节点以下一定要有至少两层的节点，否则黑色高度不可能和X路径一致）。所以我们就分析这些节点之间如何变形，把问题限制在比较小的范围内解决。另一个前提是：X在一开始，肯定是树底的叶节点或是NIL节点，所以在递归向上的过程中，每一步都保证下一步进行时，至少X的子树是满足红黑特性的。因此子树的情况就可以认为是已经正确的了，这样，分析就只限制在X节点，X的父节点P和X的兄弟节点W，以及W的两个子节点中。</p>
<p>下面仅仅考虑X原本是黑色的情况即可。在这种情况下，X此时应该具有双重黑色，算法的过程就是将这多出的一重黑色向上移动，直到遇到红节点或者根节点。接着往下分析，会遇到4种情况，实际上是8种，因为其中4种是相互对称的，这可以通过判断X是其父节点的右孩子还是左孩子来区分。下面我们以X是其父节点的左孩子的情况来分析这4种情况，实际上接下来的调整过程，就是要想方设法将经过X的所有路径上的黑色节点个数增加1。</p>
<p>具体分为以下四种情况：（下面针对x是左儿子的情况讨论，右儿子对称）</p>
<p>Case1：X的兄弟W是红色（想办法将其变为黑色）。由于W是红色的，因此其儿子节点和父节点必为黑色，只要将W和其父节点的颜色对换，在对父节点进行一次左旋转，便将W的左子节点放到了X的兄弟节点上，X的兄弟节点变成了黑色，且红黑性质不变。但还不算完，只是暂时将情况1转变成了下面的情况2或3或4。<br><img src="/img/1342667343_1242.png" alt=""></p>
<p>Case2：X的兄弟节点W是黑色的，而且W的两个子节点都是黑色的。此时可以将X的一重黑色和W的黑色同时去掉，而转加给他们的父节点上，这是X就指向它的父节点了，因此此时父节点具有双重颜色了。这一重黑色节点上移。<br><img src="/img/1342668925_6221.png" alt=""></p>
<p>如果父节点原来是红色的，现在又加一层黑色，那么X现在指向的这个节点就是红黑两色的，直接把X（也就是父节点）着为黑色。问题就已经完整解决了。如果父节点现在是双层黑色，那就以父节点为新的X进行向上的下一次的递归。</p>
<p>Case3：X的兄弟节点W是黑色的，而且W的左子节点是红色的，右子节点是黑色的。此时通过交换W和其左子节点的颜色并进行一次向右旋转就可转换成下面的第四种情况。注意，原来L是红色的，所以L的子节点一定是黑色的，所以旋转中L节点的一个子树挂到之后着为红色的W节点上不会破坏红黑性质。变形后黑色高度不变。<br><img src="/img/1342667853_4859.png" alt=""></p>
<p>Case4：X的兄弟节点W是黑色的，而且W的右子节点是红色的。这种情况下，做一次左旋，W就处于根的位置，将W保持为原来的根的位置的颜色，同时将W的两个新的儿子节点的颜色变为黑色，去掉X的一重黑色。这样整个问题也就得到了解决。递归结束。（在代码上，为了标识递归结束，我们把X指向根节点）<br><img src="/img/1342668194_2916.png" alt=""></p>
<p>因此，只要按上面四种情况一直递归处理下去，X最终总会指向根结点或一个红色结点，这时我们就可以结束递归并把问题解决了。</p>
<p>以上就是红黑树的节点删除全过程。</p>
<p>总结：如果我们通过上面的情况画出所有的分支图，我们可以得出如下结论</p>
<ul>
<li>插入操作：解决的是 红-红 问题</li>
<li>删除操作：解决的是 黑-黑 问题</li>
</ul>
<p>即你可以从分支图中看出，需要往上遍历的情况为红红(插入)，或者为黑黑黑（删除）的情况，如果你认真分析并总结所有的情况后，并坚持下来，红黑树也就没有想象中的那么恐怖了，并且很美妙；</p>
<p>详细的红黑树删除节点的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义节点颜色</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">COLOR</span> &#123;</span><br><span class="line">    BLACK = <span class="number">0</span>,</span><br><span class="line">    RED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树节点  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">RB_Tree_Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">RB_Tree_Node</span> *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">RB_Tree_Node</span> *right;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">RB_Tree_Node</span> *parent;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> RB_COLOR;  </span><br><span class="line">&#125; RB_Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树，包含一个指向根节点的指针  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">RBTree</span> &#123;</span><br><span class="line">    RB_Node* root;</span><br><span class="line">&#125; *RB_Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的NIL节点</span></span><br><span class="line"><span class="type">static</span> RB_Tree_Node NIL = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BLACK&#125;; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PNIL (&amp;NIL)   <span class="comment">// NIL节点地址 </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init_RBTree</span><span class="params">(RB_Tree pTree)</span> <span class="comment">// 初始化一棵红黑树  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pTree-&gt;root = PNIL;  </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最小键值节点  </span></span><br><span class="line"><span class="function">RB_Node* <span class="title">RBTREE_MIN</span><span class="params">(RB_Node* pRoot)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (PNIL != pRoot-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        pRoot = pRoot-&gt;left;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找指定节点的后继节点  </span></span><br><span class="line"><span class="function">RB_Node* <span class="title">RBTREE_SUCCESSOR</span><span class="params">(RB_Node*  pRoot)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PNIL != pRoot-&gt;right)</span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">RBTREE_MIN</span>(pRoot-&gt;right);      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点没有右子树的时候，进入下面的while循环</span></span><br><span class="line">    RB_Node* pParent = pRoot-&gt;parent;      </span><br><span class="line">    <span class="keyword">while</span>((PNIL != pParent) &amp;&amp; (pRoot == pParent-&gt;right))    </span><br><span class="line">    &#123;          </span><br><span class="line">        pRoot = pParent;        </span><br><span class="line">        pParent = pRoot-&gt;parent;          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pParent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的节点删除</span></span><br><span class="line"><span class="function">RB_Node* <span class="title">Delete</span><span class="params">(RB_Tree pTree , RB_Node* pDel)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RB_Node* rel_delete_point;    </span><br><span class="line">    <span class="keyword">if</span>(pDel-&gt;left == PNIL || pDel-&gt;right == PNIL)        </span><br><span class="line">        rel_delete_point = pDel;    </span><br><span class="line">    <span class="keyword">else</span>        </span><br><span class="line">        rel_delete_point = <span class="built_in">RBTREE_SUCCESSOR</span>(pDel);     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找后继节点    </span></span><br><span class="line">    RB_Node* delete_point_child;      </span><br><span class="line">    <span class="keyword">if</span>(rel_delete_point-&gt;right != PNIL)      </span><br><span class="line">    &#123;</span><br><span class="line">        delete_point_child = rel_delete_point-&gt;right;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rel_delete_point-&gt;left != PNIL)      </span><br><span class="line">    &#123;</span><br><span class="line">        delete_point_child = rel_delete_point-&gt;left;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>      </span><br><span class="line">    &#123;          </span><br><span class="line">        delete_point_child = PNIL;      </span><br><span class="line">    &#125;      </span><br><span class="line">    delete_point_child-&gt;parent = rel_delete_point-&gt;parent;      </span><br><span class="line">    <span class="keyword">if</span>(rel_delete_point-&gt;parent == PNIL)    <span class="comment">// 删除的节点是根节点    </span></span><br><span class="line">    &#123;          </span><br><span class="line">        pTree-&gt;root = delete_point_child;    </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rel_delete_point == rel_delete_point-&gt;parent-&gt;right)    </span><br><span class="line">    &#123;          </span><br><span class="line">        rel_delete_point-&gt;parent-&gt;right = delete_point_child;      </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">else</span>      </span><br><span class="line">    &#123;          </span><br><span class="line">        rel_delete_point-&gt;parent-&gt;left = delete_point_child;      </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pDel != rel_delete_point)    </span><br><span class="line">    &#123;        </span><br><span class="line">        pDel-&gt;key = rel_delete_point-&gt;key;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(rel_delete_point-&gt;RB_COLOR == BLACK)      </span><br><span class="line">    &#123;          </span><br><span class="line">        <span class="built_in">DeleteFixUp</span>(pTree , delete_point_child);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rel_delete_point;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*算法导论上的描述如下：</span></span><br><span class="line"><span class="comment">RB-DELETE-FIXUP(T, x) </span></span><br><span class="line"><span class="comment">1 while x ≠ root[T] and color[x] = BLACK </span></span><br><span class="line"><span class="comment">2     do if x = left[p[x]] </span></span><br><span class="line"><span class="comment">3           then w ← right[p[x]] </span></span><br><span class="line"><span class="comment">4                if color[w] = RED </span></span><br><span class="line"><span class="comment">5                   then color[w] ← BLACK                           Case 1 </span></span><br><span class="line"><span class="comment">6                        color[p[x]] ← RED                          Case 1 </span></span><br><span class="line"><span class="comment">7                        LEFT-ROTATE(T, p[x])                       Case 1 </span></span><br><span class="line"><span class="comment">8                        w ← right[p[x]]                            Case 1 </span></span><br><span class="line"><span class="comment">9                if color[left[w]] = BLACK and color[right[w]] = BLACK </span></span><br><span class="line"><span class="comment">10                   then color[w] ← RED                            Case 2 </span></span><br><span class="line"><span class="comment">11                        x p[x]                                    Case 2 </span></span><br><span class="line"><span class="comment">12                   else if color[right[w]] = BLACK </span></span><br><span class="line"><span class="comment">13                           then color[left[w]] ← BLACK            Case 3 </span></span><br><span class="line"><span class="comment">14                                color[w] ← RED                    Case 3 </span></span><br><span class="line"><span class="comment">15                                RIGHT-ROTATE(T, w)                Case 3 </span></span><br><span class="line"><span class="comment">16                                w ← right[p[x]]                   Case 3 </span></span><br><span class="line"><span class="comment">17                         color[w] ← color[p[x]]                   Case 4 </span></span><br><span class="line"><span class="comment">18                         color[p[x]] ← BLACK                      Case 4 </span></span><br><span class="line"><span class="comment">19                         color[right[w]] ← BLACK                  Case 4 </span></span><br><span class="line"><span class="comment">20                         LEFT-ROTATE(T, p[x])                     Case 4 </span></span><br><span class="line"><span class="comment">21                         x ← root[T]                              Case 4 </span></span><br><span class="line"><span class="comment">22        else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged) </span></span><br><span class="line"><span class="comment">23 color[x] ← BLACK  */</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来的工作，很简单，即把上述伪代码改写成c++代码即可  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteFixUp</span><span class="params">(RB_Tree pTree , RB_Node* node)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line">    <span class="keyword">while</span>(node != pTree-&gt;root &amp;&amp; node-&gt;RB_COLOR == BLACK)      </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == node-&gt;parent-&gt;left)          </span><br><span class="line">        &#123;</span><br><span class="line">            RB_Node* brother = node-&gt;parent-&gt;right;              </span><br><span class="line">            <span class="keyword">if</span>(brother-&gt;RB_COLOR==RED)   <span class="comment">//情况1：x的兄弟w是红色的。              </span></span><br><span class="line">            &#123;                  </span><br><span class="line">                brother-&gt;RB_COLOR = BLACK;                  </span><br><span class="line">                node-&gt;parent-&gt;RB_COLOR = RED;                  </span><br><span class="line">                <span class="built_in">RotateLeft</span>(node-&gt;parent);              </span><br><span class="line">            &#125;              </span><br><span class="line">            <span class="keyword">else</span>     <span class="comment">//情况2：x的兄弟w是黑色的，              </span></span><br><span class="line">            &#123;                  </span><br><span class="line">                <span class="keyword">if</span>(brother-&gt;left-&gt;RB_COLOR == BLACK &amp;&amp; brother-&gt;right-&gt;RB_COLOR == BLACK)  <span class="comment">//w的两个孩子都是黑色的                  </span></span><br><span class="line">                &#123;                     </span><br><span class="line">                    brother-&gt;RB_COLOR = RED;</span><br><span class="line">                    node = node-&gt;parent;                  </span><br><span class="line">                &#125;                  </span><br><span class="line">                <span class="keyword">else</span>                </span><br><span class="line">                &#123;                    </span><br><span class="line">                    <span class="keyword">if</span>(brother-&gt;right-&gt;RB_COLOR == BLACK)  <span class="comment">//情况3：x的兄弟w是黑色的，w的右孩子是黑色（w的左孩子是红色）</span></span><br><span class="line">                    &#123;  </span><br><span class="line">                        brother-&gt;RB_COLOR = RED;  </span><br><span class="line">                        brother-&gt;left-&gt;RB_COLOR = BLACK;  </span><br><span class="line">                        <span class="built_in">RotateRight</span>(brother);  </span><br><span class="line">                        brother = node-&gt;parent-&gt;right;      <span class="comment">//情况3转换为情况4                    </span></span><br><span class="line">                    &#125;                    <span class="comment">//情况4：x的兄弟w是黑色的，且w的右孩子时红色的                    </span></span><br><span class="line">                    brother-&gt;RB_COLOR = node-&gt;parent-&gt;RB_COLOR;</span><br><span class="line">                    node-&gt;parent-&gt;RB_COLOR = BLACK;</span><br><span class="line">                    brother-&gt;right-&gt;RB_COLOR = BLACK;</span><br><span class="line">                    <span class="built_in">RotateLeft</span>(node-&gt;parent);</span><br><span class="line">                    node = pTree-&gt;root;                </span><br><span class="line">                &#125;<span class="comment">//else            </span></span><br><span class="line">            &#125;<span class="comment">//else        </span></span><br><span class="line">        &#125;          </span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">//同上，原理一致，只是遇到左旋改为右旋，遇到右旋改为左旋即可。其它代码不变。          </span></span><br><span class="line">        &#123;              </span><br><span class="line">            RB_Node* brother = node-&gt;parent-&gt;left;              </span><br><span class="line">            <span class="keyword">if</span>(brother-&gt;RB_COLOR == RED)              </span><br><span class="line">            &#123;</span><br><span class="line">                brother-&gt;RB_COLOR = BLACK;                  </span><br><span class="line">                node-&gt;parent-&gt;RB_COLOR = RED;                  </span><br><span class="line">                <span class="built_in">RotateRight</span>(node-&gt;parent);              </span><br><span class="line">            &#125;              </span><br><span class="line">            <span class="keyword">else</span>              </span><br><span class="line">            &#123;                  </span><br><span class="line">                <span class="keyword">if</span>(brother-&gt;left-&gt;RB_COLOR==BLACK &amp;&amp; brother-&gt;right-&gt;RB_COLOR == BLACK)                  </span><br><span class="line">                &#123;</span><br><span class="line">                    brother-&gt;RB_COLOR = RED;</span><br><span class="line">                    node = node-&gt;parent;                  </span><br><span class="line">                &#125;                  </span><br><span class="line">                <span class="keyword">else</span>                   </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(brother-&gt;left-&gt;RB_COLOR==BLACK)</span><br><span class="line">                    &#123;    </span><br><span class="line">                        brother-&gt;RB_COLOR = RED;    </span><br><span class="line">                        brother-&gt;right-&gt;RB_COLOR = BLACK;    </span><br><span class="line">                        <span class="built_in">RotateLeft</span>(brother);  </span><br><span class="line">                        brother = node-&gt;parent-&gt;left;      <span class="comment">//情况3转换为情况4                    </span></span><br><span class="line">                    &#125;</span><br><span class="line">                    brother-&gt;RB_COLOR = node-&gt;parent-&gt;RB_COLOR;</span><br><span class="line">                    node-&gt;parent-&gt;RB_COLOR = BLACK;</span><br><span class="line">                    brother-&gt;left-&gt;RB_COLOR = BLACK;</span><br><span class="line">                    <span class="built_in">RotateRight</span>(node-&gt;parent);</span><br><span class="line">                    node = pTree-&gt;root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//while     </span></span><br><span class="line">    node-&gt;RB_COLOR = BLACK;    <span class="comment">//如果X节点原来为红色，那么直接改为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="斜堆之图文解析和C语言的实现"><a href="#斜堆之图文解析和C语言的实现" class="headerlink" title="斜堆之图文解析和C语言的实现"></a>斜堆之图文解析和C语言的实现</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本章介绍斜堆。和以往一样，本文会先对斜堆的理论知识进行简单介绍，然后给出C语言的实现。后续再分别给出C++和Java版本的实现；实现的语言虽不同，但是原理如出一辙，选择其中之一进行了解即可。若文章有错误或不足的地方，请不吝指出！</p>
<p>目录</p>
<ol>
<li>斜堆的介绍</li>
<li>斜堆的基本操作</li>
<li>斜堆的C实现(完整源码)</li>
<li>斜堆的C测试程序</li>
</ol>
<p>转载请注明出处：<a href="http://www.cnblogs.com/skywang12345/p/3638493.html">http://www.cnblogs.com/skywang12345/p/3638493.html</a></p>
<h2 id="斜堆的介绍"><a href="#斜堆的介绍" class="headerlink" title="斜堆的介绍"></a>斜堆的介绍</h2><p>斜堆(Skew heap)也叫自适应堆(self-adjusting heap)，它是左倾堆的一个变种。和左倾堆一样，它通常也用于实现优先队列。它的合并操作的时间复杂度也是O(lg n)。</p>
<p>相比于左倾堆，斜堆的节点没有”零距离”这个属性。除此之外，它们斜堆的合并操作也不同。斜堆的合并操作算法如下：<br>(01) 如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。<br>(02) 如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。<br>(03) 合并后，交换新堆根节点的左孩子和右孩子。</p>
<p>第(03)步是斜堆和左倾堆的合并操作差别的关键所在，如果是左倾堆，则合并后要比较左右孩子的零距离大小，若右孩子的零距离 &gt; 左孩子的零距离，则交换左右孩子；最后，在设置根的零距离。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SKEW_HEAP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SKEW_HEAP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SkewNode</span>&#123;</span></span><br><span class="line">    Type   key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SkewNode</span> *<span class="title">left</span>;</span>    <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SkewNode</span> *<span class="title">right</span>;</span>   <span class="comment">// 右孩子</span></span><br><span class="line">&#125;SkewNode, *SkewHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历&quot;斜堆&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preorder_skewheap</span><span class="params">(SkewHeap heap)</span>;</span><br><span class="line"><span class="comment">// 中序遍历&quot;斜堆&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder_skewheap</span><span class="params">(SkewHeap heap)</span>;</span><br><span class="line"><span class="comment">// 后序遍历&quot;斜堆&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postorder_skewheap</span><span class="params">(SkewHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小值(保存到pval中)，成功返回0，失败返回-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">skewheap_minimum</span><span class="params">(SkewHeap heap, <span class="type">int</span> *pval)</span>;</span><br><span class="line"><span class="comment">// 合并&quot;斜堆x&quot;和&quot;斜堆y&quot;，并返回合并后的新树</span></span><br><span class="line">SkewNode* <span class="title function_">merge_skewheap</span><span class="params">(SkewHeap x, SkewHeap y)</span>;</span><br><span class="line"><span class="comment">// 将结点插入到斜堆中，并返回根节点</span></span><br><span class="line">SkewNode* <span class="title function_">insert_skewheap</span><span class="params">(SkewHeap heap, Type key)</span>;</span><br><span class="line"><span class="comment">// 删除结点(key为节点的值)，并返回根节点</span></span><br><span class="line">SkewNode* <span class="title function_">delete_skewheap</span><span class="params">(SkewHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁斜堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy_skewheap</span><span class="params">(SkewHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印斜堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_skewheap</span><span class="params">(SkewHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>SkewNode是斜堆对应的节点类。</p>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 合并&quot;斜堆x&quot;和&quot;斜堆y&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     合并得到的树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SkewNode* <span class="title function_">merge_skewheap</span><span class="params">(SkewHeap x, SkewHeap y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并x和y时，将x作为合并后的树的根；</span></span><br><span class="line">    <span class="comment">// 这里的操作是保证: x的key &lt; y的key</span></span><br><span class="line">    <span class="keyword">if</span>(x-&gt;key &gt; y-&gt;key)</span><br><span class="line">        swap_skewheap_node(x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将x的右孩子和y合并，</span></span><br><span class="line">    <span class="comment">// 合并后直接交换x的左右孩子，而不需要像左倾堆一样考虑它们的npl。</span></span><br><span class="line">    SkewNode *tmp = merge_skewheap(x-&gt;right, y);</span><br><span class="line">    x-&gt;right = x-&gt;left;</span><br><span class="line">    x-&gt;left  = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>merge_skewheap(x, y)的作用是合并x和y这两个斜堆，并返回得到的新堆。merge_skewheap(x, y)是递归实现的。</p>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 新建结点(key)，并将其插入到斜堆中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     heap 斜堆的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SkewNode* <span class="title function_">insert_skewheap</span><span class="params">(SkewHeap heap, Type key)</span></span><br><span class="line">&#123;</span><br><span class="line">    SkewNode *node;    <span class="comment">// 新建结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((node = (SkewNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkewNode))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> heap;</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge_skewheap(heap, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insert_skewheap(heap, key)的作用是新建键值为key的结点，并将其插入到斜堆中，并返回堆的根节点。</p>
<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 取出根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     取出根节点后的新树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SkewNode* <span class="title function_">delete_skewheap</span><span class="params">(SkewHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    SkewNode *l = heap-&gt;left;</span><br><span class="line">    SkewNode *r = heap-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除根节点</span></span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge_skewheap(l, r); <span class="comment">// 返回左右子树合并后的新树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete_skewheap(heap)的作用是删除斜堆的最小节点，并返回删除节点后的斜堆根节点。</p>
<h2 id="斜堆的C实现-完整源码"><a href="#斜堆的C实现-完整源码" class="headerlink" title="斜堆的C实现(完整源码)"></a>斜堆的C实现(完整源码)</h2><p>斜堆的头文件(skewheap.h)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SKEW_HEAP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SKEW_HEAP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SkewNode</span>&#123;</span></span><br><span class="line">    Type   key;                    <span class="comment">// 关键字(键值)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SkewNode</span> *<span class="title">left</span>;</span>    <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SkewNode</span> *<span class="title">right</span>;</span>    <span class="comment">// 右孩子</span></span><br><span class="line">&#125;SkewNode, *SkewHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历&quot;斜堆&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preorder_skewheap</span><span class="params">(SkewHeap heap)</span>;</span><br><span class="line"><span class="comment">// 中序遍历&quot;斜堆&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder_skewheap</span><span class="params">(SkewHeap heap)</span>;</span><br><span class="line"><span class="comment">// 后序遍历&quot;斜堆&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postorder_skewheap</span><span class="params">(SkewHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小值(保存到pval中)，成功返回0，失败返回-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">skewheap_minimum</span><span class="params">(SkewHeap heap, <span class="type">int</span> *pval)</span>;</span><br><span class="line"><span class="comment">// 合并&quot;斜堆x&quot;和&quot;斜堆y&quot;，并返回合并后的新树</span></span><br><span class="line">SkewNode* <span class="title function_">merge_skewheap</span><span class="params">(SkewHeap x, SkewHeap y)</span>;</span><br><span class="line"><span class="comment">// 将结点插入到斜堆中，并返回根节点</span></span><br><span class="line">SkewNode* <span class="title function_">insert_skewheap</span><span class="params">(SkewHeap heap, Type key)</span>;</span><br><span class="line"><span class="comment">// 删除结点(key为节点的值)，并返回根节点</span></span><br><span class="line">SkewNode* <span class="title function_">delete_skewheap</span><span class="params">(SkewHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁斜堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy_skewheap</span><span class="params">(SkewHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印斜堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_skewheap</span><span class="params">(SkewHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><br>斜堆的实现文件(skewheap.c)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C语言实现的斜堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2014/03/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;skewheap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前序遍历&quot;斜堆&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preorder_skewheap</span><span class="params">(SkewHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;key);</span><br><span class="line">        preorder_skewheap(heap-&gt;left);</span><br><span class="line">        preorder_skewheap(heap-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 中序遍历&quot;斜堆&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder_skewheap</span><span class="params">(SkewHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inorder_skewheap(heap-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;key);</span><br><span class="line">        inorder_skewheap(heap-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 后序遍历&quot;斜堆&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postorder_skewheap</span><span class="params">(SkewHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postorder_skewheap(heap-&gt;left);</span><br><span class="line">        postorder_skewheap(heap-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 交换两个节点的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">swap_skewheap_node</span><span class="params">(SkewNode *x, SkewNode *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    SkewNode tmp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 获取最小值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *    成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">skewheap_minimum</span><span class="params">(SkewHeap heap, <span class="type">int</span> *pval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    *pval = heap-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 合并&quot;斜堆x&quot;和&quot;斜堆y&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     合并得到的树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SkewNode* <span class="title function_">merge_skewheap</span><span class="params">(SkewHeap x, SkewHeap y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并x和y时，将x作为合并后的树的根；</span></span><br><span class="line">    <span class="comment">// 这里的操作是保证: x的key &lt; y的key</span></span><br><span class="line">    <span class="keyword">if</span>(x-&gt;key &gt; y-&gt;key)</span><br><span class="line">        swap_skewheap_node(x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将x的右孩子和y合并，</span></span><br><span class="line">    <span class="comment">// 合并后直接交换x的左右孩子，而不需要像左倾堆一样考虑它们的npl。</span></span><br><span class="line">    SkewNode *tmp = merge_skewheap(x-&gt;right, y);</span><br><span class="line">    x-&gt;right = x-&gt;left;</span><br><span class="line">    x-&gt;left  = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 新建结点(key)，并将其插入到斜堆中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     heap 斜堆的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SkewNode* <span class="title function_">insert_skewheap</span><span class="params">(SkewHeap heap, Type key)</span></span><br><span class="line">&#123;</span><br><span class="line">    SkewNode *node;    <span class="comment">// 新建结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((node = (SkewNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkewNode))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> heap;</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge_skewheap(heap, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 取出根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     取出根节点后的新树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SkewNode* <span class="title function_">delete_skewheap</span><span class="params">(SkewHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    SkewNode *l = heap-&gt;left;</span><br><span class="line">    SkewNode *r = heap-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除根节点</span></span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge_skewheap(l, r); <span class="comment">// 返回左右子树合并后的新树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 销毁斜堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy_skewheap</span><span class="params">(SkewHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        destroy_skewheap(heap-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        destroy_skewheap(heap-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&quot;斜堆&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * heap       -- 斜堆的节点</span></span><br><span class="line"><span class="comment"> * key        -- 节点的键值 </span></span><br><span class="line"><span class="comment"> * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment"> *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment"> *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">skewheap_print</span><span class="params">(SkewHeap heap, Type key, <span class="type">int</span> direction)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// heap是根节点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2d is root\n&quot;</span>, heap-&gt;key);</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// heap是分支节点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2d is %2d&#x27;s %6s child\n&quot;</span>, heap-&gt;key, key, direction==<span class="number">1</span>?<span class="string">&quot;right&quot;</span> : <span class="string">&quot;left&quot;</span>);</span><br><span class="line"></span><br><span class="line">        skewheap_print(heap-&gt;left, heap-&gt;key, <span class="number">-1</span>);</span><br><span class="line">        skewheap_print(heap-&gt;right,heap-&gt;key,  <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_skewheap</span><span class="params">(SkewHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap != <span class="literal">NULL</span>)</span><br><span class="line">        skewheap_print(heap, heap-&gt;key,  <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>斜堆的测试程序(skewheap_test.c)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C语言实现的斜堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2014/03/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;skewheap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH(a) ( (sizeof(a)) / (sizeof(a[0])) )</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a[]= &#123;<span class="number">10</span>,<span class="number">40</span>,<span class="number">24</span>,<span class="number">30</span>,<span class="number">36</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[]= &#123;<span class="number">17</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">23</span>&#125;;</span><br><span class="line">    <span class="type">int</span> alen=LENGTH(a);</span><br><span class="line">    <span class="type">int</span> blen=LENGTH(b);</span><br><span class="line">    SkewHeap ha,hb;</span><br><span class="line"></span><br><span class="line">    ha=hb=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;== 斜堆(ha)中依次添加: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;alen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">        ha = insert_skewheap(ha, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n== 斜堆(ha)的详细信息: \n&quot;</span>);</span><br><span class="line">    print_skewheap(ha);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n== 斜堆(hb)中依次添加: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;blen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">        hb = insert_skewheap(hb, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n== 斜堆(hb)的详细信息: \n&quot;</span>);</span><br><span class="line">    print_skewheap(hb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将&quot;斜堆hb&quot;合并到&quot;斜堆ha&quot;中。</span></span><br><span class="line">    ha = merge_skewheap(ha, hb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n== 合并ha和hb后的详细信息: \n&quot;</span>);</span><br><span class="line">    print_skewheap(ha);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁斜堆</span></span><br><span class="line">    destroy_skewheap(ha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="左倾堆之图文解析和C语言的实现"><a href="#左倾堆之图文解析和C语言的实现" class="headerlink" title="左倾堆之图文解析和C语言的实现"></a>左倾堆之图文解析和C语言的实现</h1><h2 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h2><p>本章介绍左倾堆，它和二叉堆一样，都是堆结构中的一员。和以往一样，本文会先对左倾堆的理论知识进行简单介绍，然后给出C语言的实现。后续再分别给出C++和Java版本的实现；实现的语言虽不同，但是原理如出一辙，选择其中之一进行了解即可。若文章有错误或不足的地方，请不吝指出！</p>
<p>目录</p>
<ol>
<li>左倾堆的介绍</li>
<li>左倾堆的图文解析</li>
<li>左倾堆的C实现(完整源码)</li>
<li>左倾堆的C测试程序</li>
</ol>
<p>转载请注明出处：<a href="http://www.cnblogs.com/skywang12345/p/3638327.html">http://www.cnblogs.com/skywang12345/p/3638327.html</a></p>
<h2 id="左倾堆的介绍"><a href="#左倾堆的介绍" class="headerlink" title="左倾堆的介绍"></a>左倾堆的介绍</h2><p>左倾堆(leftist tree 或 leftist heap)，又被成为左偏树、左偏堆，最左堆等。<br>它和二叉堆一样，都是优先队列实现方式。当优先队列中涉及到”对两个优先队列进行合并”的问题时，二叉堆的效率就无法令人满意了，而本文介绍的左倾堆，则可以很好地解决这类问题。</p>
<h2 id="左倾堆的定义"><a href="#左倾堆的定义" class="headerlink" title="左倾堆的定义"></a>左倾堆的定义</h2><p>左倾堆是一棵二叉树，它的节点除了和二叉树的节点一样具有左右子树指针外，还有两个属性：键值和零距离。<br>(01) 键值的作用是来比较节点的大小，从而对节点进行排序。<br>(02) 零距离(英文名NPL，即Null Path Length)则是从一个节点到一个”最近的不满节点”的路径长度。不满节点是指该该节点的左右孩子至少有有一个为NULL。叶节点的NPL为0，NULL节点的NPL为-1。<br><img src="/img/011451438751063.jpg" alt=""></p>
<p>上图是一颗左倾堆，它满足左倾堆的基本性质：<br>[性质1] 节点的键值小于或等于它的左右子节点的键值。<br>[性质2] 节点的左孩子的NPL &gt;= 右孩子的NPL。<br>[性质3] 节点的NPL = 它的右孩子的NPL + 1。</p>
<p>左倾堆，顾名思义，是有点向左倾斜的意思了。它在统计问题、最值问题、模拟问题和贪心问题等问题中有着广泛的应用。此外，斜堆是比左倾堆更为一般的数据结构。当然，今天讨论的是左倾堆，关于斜堆，以后再撰文来表。<br>前面说过，它能和好的解决”两个优先队列合并”的问题。实际上，左倾堆的合并操作的平摊时间复杂度为O(lg n)，而完全二叉堆为O(n)。合并就是左倾树的重点，插入和删除操作都是以合并操作为基础的。插入操作，可以看作两颗左倾树合并；删除操作(移除优先队列中队首元素)，则是移除根节点之后再合并剩余的两个左倾树。闲话说到这里，下面开始介绍左倾树的基本方法。</p>
<h2 id="左倾堆的图文解析"><a href="#左倾堆的图文解析" class="headerlink" title="左倾堆的图文解析"></a>左倾堆的图文解析</h2><p>合并操作是左倾堆的重点。合并两个左倾堆的基本思想如下：</p>
<ol>
<li>如果一个空左倾堆与一个非空左倾堆合并，返回非空左倾堆。</li>
<li>如果两个左倾堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。</li>
<li>如果新堆的右孩子的NPL &gt; 左孩子的NPL，则交换左右孩子。</li>
<li>设置新堆的根节点的NPL = 右子堆NPL + 1</li>
</ol>
<p>下面通过图文演示合并以下两个堆的过程。<br><img src="/img/011452529377696.jpg" alt=""></p>
<p>提示：这两个堆的合并过程和测试程序相对应！</p>
<p>第1步：将”较小堆(根为10)的右孩子”和”较大堆(根为11)”进行合并。<br>合并的结果，相当于将”较大堆”设置”较小堆”的右孩子，如下图所示：<br><img src="/img/011453446095544.jpg" alt=""></p>
<p>第2步：将上一步得到的”根11的右子树”和”根为12的树”进行合并，得到的结果如下：<br><img src="/img/011454410629829.jpg" alt=""></p>
<p>第3步：将上一步得到的”根12的右子树”和”根为13的树”进行合并，得到的结果如下：<br><img src="/img/011455050785927.jpg" alt=""></p>
<p>第4步：将上一步得到的”根13的右子树”和”根为16的树”进行合并，得到的结果如下：<br><img src="/img/011456381256901.jpg" alt=""></p>
<p>第5步：将上一步得到的”根16的右子树”和”根为23的树”进行合并，得到的结果如下：<br><img src="/img/011457032506325.jpg" alt=""></p>
<p>至此，已经成功的将两棵树合并成为一棵树了。接下来，对新生成的树进行调节。<br>第6步：上一步得到的”树16的右孩子的NPL &gt; 左孩子的NPL”，因此交换左右孩子。得到的结果如下：<br><img src="/img/011457434061924.jpg" alt=""></p>
<p>第7步：上一步得到的”树12的右孩子的NPL &gt; 左孩子的NPL”，因此交换左右孩子。得到的结果如下：<br><img src="/img/011458120315745.jpg" alt=""></p>
<p>第8步：上一步得到的”树10的右孩子的NPL &gt; 左孩子的NPL”，因此交换左右孩子。得到的结果如下：<br><img src="/img/011458431561137.jpg" alt=""></p>
<p>至此，合并完毕。上面就是合并得到的左倾堆！</p>
<p>下面看看左倾堆的基本操作的代码</p>
<ol>
<li>头文件<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LEFTIST_TREE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LEFTIST_TREE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LeftistNode</span>&#123;</span></span><br><span class="line">    Type   key;                    <span class="comment">// 关键字(键值)</span></span><br><span class="line">    <span class="type">int</span> npl;                    <span class="comment">// 零路经长度(Null Path Length)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LeftistNode</span> *<span class="title">left</span>;</span>    <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LeftistNode</span> *<span class="title">right</span>;</span>    <span class="comment">// 右孩子</span></span><br><span class="line">&#125;LeftistNode, *LeftistHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历&quot;左倾堆&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preorder_leftist</span><span class="params">(LeftistHeap heap)</span>;</span><br><span class="line"><span class="comment">// 中序遍历&quot;左倾堆&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder_leftist</span><span class="params">(LeftistHeap heap)</span>;</span><br><span class="line"><span class="comment">// 后序遍历&quot;左倾堆&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postorder_leftist</span><span class="params">(LeftistHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小值(保存到pval中)，成功返回0，失败返回-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">leftist_minimum</span><span class="params">(LeftistHeap heap, <span class="type">int</span> *pval)</span>;</span><br><span class="line"><span class="comment">// 合并&quot;左倾堆x&quot;和&quot;左倾堆y&quot;，并返回合并后的新树</span></span><br><span class="line">LeftistNode* <span class="title function_">merge_leftist</span><span class="params">(LeftistHeap x, LeftistHeap y)</span>;</span><br><span class="line"><span class="comment">// 将结点插入到左倾堆中，并返回根节点</span></span><br><span class="line">LeftistNode* <span class="title function_">insert_leftist</span><span class="params">(LeftistHeap heap, Type key)</span>;</span><br><span class="line"><span class="comment">// 删除结点(key为节点的值)，并返回根节点</span></span><br><span class="line">LeftistNode* <span class="title function_">delete_leftist</span><span class="params">(LeftistHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁左倾堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy_leftist</span><span class="params">(LeftistHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印左倾堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_leftist</span><span class="params">(LeftistHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
LeftistNode是左倾堆对应的节点类。</li>
</ol>
<ol>
<li>合并<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 合并&quot;左倾堆x&quot;和&quot;左倾堆y&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     合并得到的树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LeftistNode* <span class="title function_">merge_leftist</span><span class="params">(LeftistHeap x, LeftistHeap y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并x和y时，将x作为合并后的树的根；</span></span><br><span class="line">    <span class="comment">// 这里的操作是保证: x的key &lt; y的key</span></span><br><span class="line">    <span class="keyword">if</span>(x-&gt;key &gt; y-&gt;key)</span><br><span class="line">        swap_leftist_node(x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将x的右孩子和y合并，&quot;合并后的树的根&quot;是x的右孩子。</span></span><br><span class="line">    x-&gt;right = merge_leftist(x-&gt;right, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果&quot;x的左孩子为空&quot; 或者 &quot;x的左孩子的npl&lt;右孩子的npl&quot;</span></span><br><span class="line">    <span class="comment">// 则，交换x和y</span></span><br><span class="line">    <span class="keyword">if</span>(x-&gt;left == <span class="literal">NULL</span> || x-&gt;left-&gt;npl &lt; x-&gt;right-&gt;npl)</span><br><span class="line">    &#123;</span><br><span class="line">        LeftistNode *tmp = x-&gt;left;</span><br><span class="line">        x-&gt;left = x-&gt;right;</span><br><span class="line">        x-&gt;right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置合并后的新树(x)的npl</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right == <span class="literal">NULL</span> || x-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">        x-&gt;npl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;npl = (x-&gt;left-&gt;npl &gt; x-&gt;right-&gt;npl) ? (x-&gt;right-&gt;npl + <span class="number">1</span>) : (x-&gt;left-&gt;npl + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>merge_leftist(x, y)的作用是合并x和y这两个左倾堆，并返回得到的新堆。merge_leftist(x, y)是递归实现的。</p>
<ol>
<li><p>添加</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 新建结点(key)，并将其插入到左倾堆中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     heap 左倾堆的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LeftistNode* <span class="title function_">insert_leftist</span><span class="params">(LeftistHeap heap, Type key)</span></span><br><span class="line">&#123;</span><br><span class="line">    LeftistNode *node;    <span class="comment">// 新建结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((node = (LeftistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LeftistNode))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> heap;</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;npl = <span class="number">0</span>;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge_leftist(heap, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insert_leftist(heap, key)的作用是新建键值为key的结点，并将其插入到左倾堆中，并返回堆的根节点。</p>
</li>
<li><p>删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 取出根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     取出根节点后的新树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LeftistNode* <span class="title function_">delete_leftist</span><span class="params">(LeftistHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    LeftistNode *l = heap-&gt;left;</span><br><span class="line">    LeftistNode *r = heap-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除根节点</span></span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge_leftist(l, r); <span class="comment">// 返回左右子树合并后的新树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete_leftist(heap)的作用是删除左倾堆的最小节点，并返回删除节点后的左倾堆根节点。</p>
</li>
</ol>
<h2 id="左倾堆的头文件-leftist-h"><a href="#左倾堆的头文件-leftist-h" class="headerlink" title="左倾堆的头文件(leftist.h)"></a>左倾堆的头文件(leftist.h)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LEFTIST_TREE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LEFTIST_TREE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LeftistNode</span>&#123;</span></span><br><span class="line">    Type   key;                    <span class="comment">// 关键字(键值)</span></span><br><span class="line">    <span class="type">int</span> npl;                    <span class="comment">// 零路经长度(Null Path Length)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LeftistNode</span> *<span class="title">left</span>;</span>    <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LeftistNode</span> *<span class="title">right</span>;</span>    <span class="comment">// 右孩子</span></span><br><span class="line">&#125;LeftistNode, *LeftistHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历&quot;左倾堆&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preorder_leftist</span><span class="params">(LeftistHeap heap)</span>;</span><br><span class="line"><span class="comment">// 中序遍历&quot;左倾堆&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder_leftist</span><span class="params">(LeftistHeap heap)</span>;</span><br><span class="line"><span class="comment">// 后序遍历&quot;左倾堆&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postorder_leftist</span><span class="params">(LeftistHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小值(保存到pval中)，成功返回0，失败返回-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">leftist_minimum</span><span class="params">(LeftistHeap heap, <span class="type">int</span> *pval)</span>;</span><br><span class="line"><span class="comment">// 合并&quot;左倾堆x&quot;和&quot;左倾堆y&quot;，并返回合并后的新树</span></span><br><span class="line">LeftistNode* <span class="title function_">merge_leftist</span><span class="params">(LeftistHeap x, LeftistHeap y)</span>;</span><br><span class="line"><span class="comment">// 将结点插入到左倾堆中，并返回根节点</span></span><br><span class="line">LeftistNode* <span class="title function_">insert_leftist</span><span class="params">(LeftistHeap heap, Type key)</span>;</span><br><span class="line"><span class="comment">// 删除结点(key为节点的值)，并返回根节点</span></span><br><span class="line">LeftistNode* <span class="title function_">delete_leftist</span><span class="params">(LeftistHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁左倾堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy_leftist</span><span class="params">(LeftistHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印左倾堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_leftist</span><span class="params">(LeftistHeap heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="左倾堆的实现文件-leftist-c"><a href="#左倾堆的实现文件-leftist-c" class="headerlink" title="左倾堆的实现文件(leftist.c)"></a>左倾堆的实现文件(leftist.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C语言实现的左倾堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2014/03/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leftist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前序遍历&quot;左倾堆&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preorder_leftist</span><span class="params">(LeftistHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;key);</span><br><span class="line">        preorder_leftist(heap-&gt;left);</span><br><span class="line">        preorder_leftist(heap-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 中序遍历&quot;左倾堆&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder_leftist</span><span class="params">(LeftistHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inorder_leftist(heap-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;key);</span><br><span class="line">        inorder_leftist(heap-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 后序遍历&quot;左倾堆&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postorder_leftist</span><span class="params">(LeftistHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postorder_leftist(heap-&gt;left);</span><br><span class="line">        postorder_leftist(heap-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 交换两个节点的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">swap_leftist_node</span><span class="params">(LeftistNode *x, LeftistNode *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    LeftistNode tmp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 获取最小值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *    成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">leftist_minimum</span><span class="params">(LeftistHeap heap, <span class="type">int</span> *pval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    *pval = heap-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 合并&quot;左倾堆x&quot;和&quot;左倾堆y&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     合并得到的树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LeftistNode* <span class="title function_">merge_leftist</span><span class="params">(LeftistHeap x, LeftistHeap y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并x和y时，将x作为合并后的树的根；</span></span><br><span class="line">    <span class="comment">// 这里的操作是保证: x的key &lt; y的key</span></span><br><span class="line">    <span class="keyword">if</span>(x-&gt;key &gt; y-&gt;key)</span><br><span class="line">        swap_leftist_node(x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将x的右孩子和y合并，&quot;合并后的树的根&quot;是x的右孩子。</span></span><br><span class="line">    x-&gt;right = merge_leftist(x-&gt;right, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果&quot;x的左孩子为空&quot; 或者 &quot;x的左孩子的npl&lt;右孩子的npl&quot;</span></span><br><span class="line">    <span class="comment">// 则，交换x和y</span></span><br><span class="line">    <span class="keyword">if</span>(x-&gt;left == <span class="literal">NULL</span> || x-&gt;left-&gt;npl &lt; x-&gt;right-&gt;npl)</span><br><span class="line">    &#123;</span><br><span class="line">        LeftistNode *tmp = x-&gt;left;</span><br><span class="line">        x-&gt;left = x-&gt;right;</span><br><span class="line">        x-&gt;right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置合并后的新树(x)的npl</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right == <span class="literal">NULL</span> || x-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">        x-&gt;npl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;npl = (x-&gt;left-&gt;npl &gt; x-&gt;right-&gt;npl) ? (x-&gt;right-&gt;npl + <span class="number">1</span>) : (x-&gt;left-&gt;npl + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 新建结点(key)，并将其插入到左倾堆中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     heap 左倾堆的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LeftistNode* <span class="title function_">insert_leftist</span><span class="params">(LeftistHeap heap, Type key)</span></span><br><span class="line">&#123;</span><br><span class="line">    LeftistNode *node;    <span class="comment">// 新建结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((node = (LeftistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LeftistNode))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> heap;</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;npl = <span class="number">0</span>;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge_leftist(heap, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 取出根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     取出根节点后的新树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LeftistNode* <span class="title function_">delete_leftist</span><span class="params">(LeftistHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    LeftistNode *l = heap-&gt;left;</span><br><span class="line">    LeftistNode *r = heap-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除根节点</span></span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge_leftist(l, r); <span class="comment">// 返回左右子树合并后的新树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 销毁左倾堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy_leftist</span><span class="params">(LeftistHeap heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        destroy_leftist(heap-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        destroy_leftist(heap-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&quot;左倾堆&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * heap       -- 左倾堆的节点</span></span><br><span class="line"><span class="comment"> * key        -- 节点的键值 </span></span><br><span class="line"><span class="comment"> * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment"> *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment"> *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">leftist_print</span><span class="params">(LeftistHeap heap, Type key, <span class="type">int</span> direction)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// heap是根节点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2d(%d) is root\n&quot;</span>, heap-&gt;key, heap-&gt;npl);</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// heap是分支节点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2d(%d) is %2d&#x27;s %6s child\n&quot;</span>, heap-&gt;key, heap-&gt;npl, key, direction==<span class="number">1</span>?<span class="string">&quot;right&quot;</span> : left<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        leftist_print(heap-&gt;left, heap-&gt;key, -1);</span></span><br><span class="line"><span class="string">        leftist_print(heap-&gt;right,heap-&gt;key,  1);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void print_leftist(LeftistHeap heap)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    if (heap != NULL)</span></span><br><span class="line"><span class="string">        leftist_print(heap, heap-&gt;key,  0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="左倾堆的测试程序-leftist-test-c"><a href="#左倾堆的测试程序-leftist-test-c" class="headerlink" title="左倾堆的测试程序(leftist_test.c)"></a>左倾堆的测试程序(leftist_test.c)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C语言实现的左倾堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2014/03/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leftist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH(a) ( (sizeof(a)) / (sizeof(a[0])) )</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a[]= &#123;<span class="number">10</span>,<span class="number">40</span>,<span class="number">24</span>,<span class="number">30</span>,<span class="number">36</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[]= &#123;<span class="number">17</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">23</span>&#125;;</span><br><span class="line">    <span class="type">int</span> alen=LENGTH(a);</span><br><span class="line">    <span class="type">int</span> blen=LENGTH(b);</span><br><span class="line">    LeftistHeap ha,hb;</span><br><span class="line"></span><br><span class="line">    ha=hb=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;== 左倾堆(ha)中依次添加: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;alen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">        ha = insert_leftist(ha, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n== 左倾堆(ha)的详细信息: \n&quot;</span>);</span><br><span class="line">    print_leftist(ha);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n== 左倾堆(hb)中依次添加: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;blen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">        hb = insert_leftist(hb, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n== 左倾堆(hb)的详细信息: \n&quot;</span>);</span><br><span class="line">    print_leftist(hb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将&quot;左倾堆hb&quot;合并到&quot;左倾堆ha&quot;中。</span></span><br><span class="line">    ha = merge_leftist(ha, hb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n== 合并ha和hb后的详细信息: \n&quot;</span>);</span><br><span class="line">    print_leftist(ha);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁左倾堆</span></span><br><span class="line">    destroy_leftist(ha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="左倾堆的C测试程序"><a href="#左倾堆的C测试程序" class="headerlink" title="左倾堆的C测试程序"></a>左倾堆的C测试程序</h2><p>左倾堆的测试程序已经包含在它的实现文件(leftist_test.c)中了，这里仅给出它的运行结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">== 左倾堆(ha)中依次添加: 10 40 24 30 36 20 12 16 </span><br><span class="line">== 左倾堆(ha)的详细信息: </span><br><span class="line">10(2) is root</span><br><span class="line">24(1) is 10&#x27;s   left child</span><br><span class="line">30(0) is 24&#x27;s   left child</span><br><span class="line">36(0) is 24&#x27;s  right child</span><br><span class="line">12(1) is 10&#x27;s  right child</span><br><span class="line">20(0) is 12&#x27;s   left child</span><br><span class="line">40(0) is 20&#x27;s   left child</span><br><span class="line">16(0) is 12&#x27;s  right child</span><br><span class="line"></span><br><span class="line">== 左倾堆(hb)中依次添加: 17 13 11 15 19 21 23 </span><br><span class="line">== 左倾堆(hb)的详细信息: </span><br><span class="line">11(2) is root</span><br><span class="line">15(1) is 11&#x27;s   left child</span><br><span class="line">19(0) is 15&#x27;s   left child</span><br><span class="line">21(0) is 15&#x27;s  right child</span><br><span class="line">13(1) is 11&#x27;s  right child</span><br><span class="line">17(0) is 13&#x27;s   left child</span><br><span class="line">23(0) is 13&#x27;s  right child</span><br><span class="line"></span><br><span class="line">== 合并ha和hb后的详细信息: </span><br><span class="line">10(2) is root</span><br><span class="line">11(2) is 10&#x27;s   left child</span><br><span class="line">15(1) is 11&#x27;s   left child</span><br><span class="line">19(0) is 15&#x27;s   left child</span><br><span class="line">21(0) is 15&#x27;s  right child</span><br><span class="line">12(1) is 11&#x27;s  right child</span><br><span class="line">13(1) is 12&#x27;s   left child</span><br><span class="line">17(0) is 13&#x27;s   left child</span><br><span class="line">16(0) is 13&#x27;s  right child</span><br><span class="line">23(0) is 16&#x27;s   left child</span><br><span class="line">20(0) is 12&#x27;s  right child</span><br><span class="line">40(0) is 20&#x27;s   left child</span><br><span class="line">24(1) is 10&#x27;s  right child</span><br><span class="line">30(0) is 24&#x27;s   left child</span><br><span class="line">36(0) is 24&#x27;s  right child</span><br></pre></td></tr></table></figure></p>
<h1 id="跳跃表原理"><a href="#跳跃表原理" class="headerlink" title="跳跃表原理"></a>跳跃表原理</h1><p>Skip List是在有序链表的基础上进行了扩展，解决了有序链表结构查找特定值困难的问题，查找特定值的时间复杂度为O(logn)，他是一种可以代替平衡树的数据结构。下面是skipList的一个介绍，转载来的，源地址：<a href="http://kenby.iteye.com/blog/1187303，">http://kenby.iteye.com/blog/1187303，</a></p>
<h2 id="什么选择跳表"><a href="#什么选择跳表" class="headerlink" title="什么选择跳表"></a>什么选择跳表</h2><p>目前经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, Treep等。想象一下，给你一张草稿纸，一只笔，一个编辑器，你能立即实现一颗红黑树，或者AVL树出来吗？ 很难吧，这需要时间，要考虑很多细节，要参考一堆算法与数据结构之类的树，还要参考网上的代码，相当麻烦。 </p>
<p>用跳表吧，跳表是一种随机化的数据结构，目前开源软件 Redis 和 LevelDB 都有用到它，它的效率和红黑树以及 AVL 树不相上下，但跳表的原理相当简单，只要你能熟练操作链表，就能轻松实现一个 SkipList。</p>
<h2 id="有序表的搜索"><a href="#有序表的搜索" class="headerlink" title="有序表的搜索"></a>有序表的搜索</h2><p>考虑一个有序表：<br><img src="/img/151151293294032.jpg" alt=""></p>
<p>从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数为 2 + 4 + 6 = 12 次。有没有优化的算法吗?  链表是有序的，但不能使用二分查找。类似二叉搜索树，我们把一些节点提取出来，作为索引。得到如下结构：<br><img src="/img/151151540794271.jpg" alt=""></p>
<p>这里我们把 &lt; 14, 34, 50, 72 &gt; 提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。 我们还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构：<br><img src="/img/151152187209308.jpg" alt=""></p>
<p>这里元素不多，体现不出优势，如果元素足够多，这种索引结构就能体现出优势来了。</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>下面的结构是就是跳表：-1 表示 INT_MIN， 链表的最小值，1 表示 INT_MAX，链表的最大值。<br><img src="/img/151152454708202.jpg" alt=""></p>
<p>跳表具有如下性质：</p>
<ol>
<li>由很多层结构组成</li>
<li>每一层都是一个有序的链表</li>
<li>最底层(Level 1)的链表包含所有元素</li>
<li>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</li>
<li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</li>
</ol>
<h2 id="跳表的搜索"><a href="#跳表的搜索" class="headerlink" title="跳表的搜索"></a>跳表的搜索</h2><p><img src="/img/151153099856214.jpg" alt=""></p>
<p>例子：查找元素 117</p>
<ol>
<li>比较 21， 比 21 大，往后面找</li>
<li>比较 37,   比 37大，比链表最大值小，从 37 的下面一层开始找</li>
<li>比较 71,  比 71 大，比链表最大值小，从 71 的下面一层开始找</li>
<li>比较 85， 比 85 大，从后面找</li>
<li>比较 117， 等于 117， 找到了节点。</li>
</ol>
<p>具体的搜索算法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 如果存在 x, 返回 x 所在的节点， </span><br><span class="line"> * 否则返回 x 的后继节点 */  </span><br><span class="line">find(x)   </span><br><span class="line">&#123;  </span><br><span class="line">    p = top;  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        while (p-&gt;next-&gt;key &lt; x)  </span><br><span class="line">            p = p-&gt;next;  </span><br><span class="line">        if (p-&gt;down == NULL)   </span><br><span class="line">            return p-&gt;next;  </span><br><span class="line">        p = p-&gt;down;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<h2 id="跳表的插入"><a href="#跳表的插入" class="headerlink" title="跳表的插入"></a>跳表的插入</h2><p>先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的），然后在 Level 1 … Level K 各个层的链表都插入元素。<br>例子：插入 119， K = 2<br><img src="/img/151153543146838.jpg" alt=""></p>
<p>如果 K 大于链表的层数，则要添加新的层。例子：插入 119， K = 4<br><img src="/img/151154183451463.jpg" alt=""></p>
<h2 id="丢硬币决定-K"><a href="#丢硬币决定-K" class="headerlink" title="丢硬币决定 K"></a>丢硬币决定 K</h2><p>插入元素的时候，元素所占有的层数完全是随机的，通过一下随机算法产生：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int random_level()  </span><br><span class="line">&#123;  </span><br><span class="line">    K = 1;  </span><br><span class="line">  </span><br><span class="line">    while (random(0,1))  </span><br><span class="line">        K++;  </span><br><span class="line">  </span><br><span class="line">    return K;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<p>相当与做一次丢硬币的实验，如果遇到正面，继续丢，遇到反面，则停止，用实验中丢硬币的次数 K 作为元素占有的层数。显然随机变量 K 满足参数为 p = 1/2 的几何分布，K 的期望值 E[K] = 1/p = 2. 就是说，各个元素的层数，期望值是 2 层。</p>
<h2 id="跳表的高度。"><a href="#跳表的高度。" class="headerlink" title="跳表的高度。"></a>跳表的高度。</h2><p>n 个元素的跳表，每个元素插入的时候都要做一次实验，用来决定元素占据的层数 K，跳表的高度等于这 n 次实验中产生的最大 K，</p>
<h2 id="跳表的空间复杂度分析"><a href="#跳表的空间复杂度分析" class="headerlink" title="跳表的空间复杂度分析"></a>跳表的空间复杂度分析</h2><p>根据上面的分析，每个元素的期望高度为 2， 一个大小为 n 的跳表，其节点数目的期望值是 2n。</p>
<h2 id="跳表的删除"><a href="#跳表的删除" class="headerlink" title="跳表的删除"></a>跳表的删除</h2><p>在各个层中找到包含 x 的节点，使用标准的 delete from list 方法删除该节点。<br>例子：删除 71<br><img src="/img/151154511262782.jpg" alt=""></p>
<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p>字典树又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来节约存储空间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。 </p>
<p>字典树与字典很相似,当你要查一个单词是不是在字典树中,首先看单词的第一个字母是不是在字典的第一层,如果不在,说明字典树里没有该单词,如果在就在该字母的孩子节点里找是不是有单词的第二个字母,没有说明没有该单词,有的话用同样的方法继续查找.字典树不仅可以用来储存字母,也可以储存数字等其它数据。</p>
<p>Trie的数据结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 26</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>   </span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    Trie *next[MAX];   </span><br><span class="line">    <span class="type">int</span> v;   <span class="comment">//根据需要变化</span></span><br><span class="line">&#125;;   </span><br><span class="line"> </span><br><span class="line">Trie *root;</span><br></pre></td></tr></table></figure></p>
<p>next是表示每层有多少种类的数，如果只是小写字母，则26即可，若改为大小写字母，则是52，若再加上数字，则是62了，这里根据题意来确定。<br>v可以表示一个字典树到此有多少相同前缀的数目，这里根据需要应当学会自由变化。</p>
<p>Trie的查找（最主要的操作）：</p>
<ol>
<li>每次从根结点开始一次搜索；</li>
<li>取得要查找关键词的第一个字母，并根据该字母选择对应的子树并转到该子树继续进行检索；</li>
<li>在相应的子树上，取得要查找关键词的第二个字母,并进一步选择对应的子树进行检索。 　　</li>
<li>迭代过程…… 　　</li>
<li>在某个结点处，关键词的所有字母已被取出，则读取附在该结点上的信息，即完成查找。</li>
</ol>
<p>这里给出生成字典树和查找的模版：<br>生成字典树：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createTrie</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    Trie *p = root, *q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[id] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q = (Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">            q-&gt;v = <span class="number">1</span>;    <span class="comment">//初始v==1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;MAX; ++j)</span><br><span class="line">                q-&gt;next[j] = <span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;next[id] = q;</span><br><span class="line">            p = p-&gt;next[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next[id]-&gt;v++;</span><br><span class="line">            p = p-&gt;next[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;v = <span class="number">-1</span>;   <span class="comment">//若为结尾，则将v改成-1表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是查找的过程了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findTrie</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    Trie *p = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        p = p-&gt;next[id];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)   <span class="comment">//若为空集，表示不存以此为前缀的串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;v == <span class="number">-1</span>)   <span class="comment">//字符集中已有串是此串的前缀</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//此串是字符集中某串的前缀</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于上述动态字典树，有时会超内存，这是就要记得释放空间了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dealTrie</span><span class="params">(Trie* T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;next[i]!=<span class="literal">NULL</span>)</span><br><span class="line">            deal(T-&gt;next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Trie的删除操作就稍微复杂一些，主要分为以下3种情况：</p>
<p>如果待删除的单词是另一个单词的前缀，只需要把该单词的最后一个节点的 isWord 的改成false<br><img src="/img/20190825201.png" alt=""></p>
<p>比如Trie中存在 panda 和 pan 这两个单词，删除 pan ，只需要把字符 n 对应的节点的 isWord 改成 false 即可</p>
<p>如果单词的所有字母的都没有多个分支（也就是说该单词所有的字符对应的Node都只有一个子节点），则删除整个单词<br><img src="/img/20190825202.png" alt=""></p>
<p>如果单词的除了最后一个字母，其他的字母有多个分支<br><img src="/img/20190825203.png" alt=""></p>
<h1 id="位图（BitMap）索引"><a href="#位图（BitMap）索引" class="headerlink" title="位图（BitMap）索引"></a>位图（BitMap）索引</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>　　有张表名为table的表，由三列组成，分别是姓名、性别和婚姻状况，其中性别只有男和女两项，婚姻状况由已婚、未婚、离婚这三项，该表共有100w个记录。现在有这样的查询：     select * from table where Gender=‘男’ and Marital=“未婚”。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>姓名(Name)</th>
<th style="text-align:center">性别(Gender)</th>
<th style="text-align:right">婚姻状况(Marital)</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td style="text-align:center">男</td>
<td style="text-align:right">已婚</td>
</tr>
<tr>
<td>李四</td>
<td style="text-align:center">女</td>
<td style="text-align:right">已婚</td>
</tr>
<tr>
<td>王五</td>
<td style="text-align:center">男</td>
<td style="text-align:right">未婚</td>
</tr>
<tr>
<td>赵六</td>
<td style="text-align:center">女</td>
<td style="text-align:right">离婚</td>
</tr>
<tr>
<td>孙七</td>
<td style="text-align:center">女</td>
<td style="text-align:right">未婚</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>不使用索引</li>
</ol>
<p>不使用索引时，数据库只能一行行扫描所有记录，然后判断该记录是否满足查询条件。</p>
<ol>
<li>B树索引</li>
</ol>
<p>对于性别，可取值的范围只有’男’,’女’，并且男和女可能各站该表的50%的数据，这时添加B树索引还是需要取出一半的数据， 因此完全没有必要。相反，如果某个字段的取值范围很广，几乎没有重复，比如身份证号，此时使用B树索引较为合适。事实上，当取出的行数据占用表中大部分的数据时，即使添加了B树索引，数据库如oracle、mysql也不会使用B树索引，很有可能还是一行行全部扫描。</p>
<h2 id="位图索引出马"><a href="#位图索引出马" class="headerlink" title="位图索引出马"></a>位图索引出马</h2><p>如果用户查询的列的基数非常的小， 即只有的几个固定值，如性别、婚姻状况、行政区等等。要为这些基数值比较小的列建索引，就需要建立位图索引。</p>
<p>对于性别这个列，位图索引形成两个向量，男向量为10100…，向量的每一位表示该行是否是男，如果是则位1，否为0，同理，女向量位01011。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>RowId</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>男</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>女</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>对于婚姻状况这一列，位图索引生成三个向量，已婚为11000…，未婚为00100…，离婚为00010…。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>RowId</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>已婚</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>未婚</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>离婚</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>当我们使用查询语句“select * from table where Gender=‘男’ and Marital=“未婚”;”的时候 首先取出男向量10100…，然后取出未婚向量00100…，将两个向量做and操作，这时生成新向量00100…，可以发现第三位为1，表示该表的第三行数据就是我们需要查询的结果。 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>RowId</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>男</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>未婚</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>结果</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h2 id="位图索引的适用条件"><a href="#位图索引的适用条件" class="headerlink" title="位图索引的适用条件"></a>位图索引的适用条件</h2><p>上面讲了，位图索引适合只有几个固定值的列，如性别、婚姻状况、行政区等等，而身份证号这种类型不适合用位图索引。</p>
<p>此外，位图索引适合静态数据，而不适合索引频繁更新的列。举个例子，有这样一个字段busy，记录各个机器的繁忙与否，当机器忙碌时，busy为1，当机器不忙碌时，busy为0。</p>
<p>这个时候有人会说使用位图索引，因为busy只有两个值。好，我们使用位图索引索引busy字段！假设用户A使用update更新某个机器的busy值，比如update table set table.busy=1 where rowid=100;，但还没有commit，而用户B也使用update更新另一个机器的busy值，update table set table.busy=1 where rowid=12; 这个时候用户B怎么也更新不了，需要等待用户A commit。</p>
<p>原因：用户A更新了某个机器的busy值为1，会导致所有busy为1的机器的位图向量发生改变，因此数据库会将busy＝1的所有行锁定，只有commit之后才解锁。</p>
<p>源地址：<a href="http://www.cnblogs.com/LBSer">http://www.cnblogs.com/LBSer</a></p>
<h1 id="Boyer-Moore-字符串匹配算法"><a href="#Boyer-Moore-字符串匹配算法" class="headerlink" title="Boyer-Moore 字符串匹配算法"></a>Boyer-Moore 字符串匹配算法</h1><p>在 1977 年，Robert S. Boyer (Stanford Research Institute) 和 J Strother Moore (Xerox Palo Alto Research Center) 共同发表了文章《A Fast String Searching Algorithm》，介绍了一种新的快速字符串匹配算法。这种算法在逻辑上相对于现有的算法有了显著的改进，它对要搜索的字符串进行倒序的字符比较，并且当字符比较不匹配时无需对整个模式串再进行搜索。 </p>
<p>Boyer-Moore 算法的主要特点有：</p>
<ul>
<li>对模式字符的比较顺序时从右向左；</li>
<li>预处理需要 O(m + σ) 的时间和空间复杂度；</li>
<li>匹配阶段需要 O(m × n) 的时间复杂度；</li>
<li>匹配阶段在最坏情况下需要 3n 次字符比较；</li>
<li>最优复杂度 O(n/m)；</li>
</ul>
<p>在 Naive 算法中，对文本 T 和模式 P 字符串均未做预处理。而在 KMP 算法中则对模式 P 字符串进行了预处理操作，以预先计算模式串中各位置的最长相同前后缀长度的数组。Boyer–Moore 算法同样也是对模式 P 字符串进行预处理。</p>
<p>我们知道，在 Naive 算法中，如果发现模式 P 中的字符与文本 T 中的字符不匹配时，需要将文本 T 的比较位置向后滑动一位，模式 P 的比较位置归 0 并从头开始比较。而 KMP 算法则是根据预处理的结果进行判断以使模式 P 的比较位置可以向后滑动多个位置。Boyer–Moore 算法的预处理过程也是为了达到相同效果。</p>
<p>Boyer–Moore 算法在对模式 P 字符串进行预处理时，将采用两种不同的启发式方法。这两种启发式的预处理方法称为：</p>
<ul>
<li>坏字符（Bad Character Heuristic）：当文本 T 中的某个字符跟模式 P 的某个字符不匹配时，我们称文本 T 中的这个失配字符为坏字符。</li>
<li>好后缀（Good Suffix Heuristic）：当文本 T 中的某个字符跟模式 P 的某个字符不匹配时，我们称文本 T 中的已经匹配的字符串为好后缀。</li>
</ul>
<p>Boyer–Moore 算法在预处理时，将为两种不同的启发法结果创建不同的数组，分别称为 Bad-Character-Shift（or The Occurrence Shift）和 Good-Suffix-Shift（or Matching Shift）。当进行字符匹配时，如果发现模式 P 中的字符与文本 T 中的字符不匹配时，将比较两种不同启发法所建议的移动位移长度，选择最大的一个值来对模式 P 的比较位置进行滑动。</p>
<p>此外，Naive 算法和 KMP 算法对模式 P 的比较方向是从前向后比较，而 Boyer–Moore 算法的设计则是从后向前比较，即从尾部向头部方向进行比较。</p>
<p>下面，我们将以 J Strother Moore 提供的例子作为示例。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Text T : HERE IS A SIMPLE EXAMPLE</span><br><span class="line">Pattern P : EXAMPLE</span><br></pre></td></tr></table></figure><br>首先将文本 T 与模式 P 头部对齐，并从尾部开始进行比较。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HERE IS A SIMPLE EXAMPLE</span><br><span class="line">EXAMPLE</span><br></pre></td></tr></table></figure><br>这样如果尾部的字符不匹配，则前面的字符也就无需比较了，直接跳过。我们看到，”S” 与 “E” 不匹配，我们称文本 T 中的失配字符 “S” 为<strong>坏字符</strong>（Bad Character）。由于字符 “S” 在模式 “EXAMPLE” 中不存在，则可将搜索位置滑动到 “S” 的后面。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HERE IS A SIMPLE EXAMPLE</span><br><span class="line">       EXAMPLE</span><br></pre></td></tr></table></figure><br>仍然从尾部开始比较，发现 “P” 与 “E” 不匹配，所以 “P” 是坏字符。但此时，”P” 包含在模式 “EXAMPLE” 之中。所以，将模式后移两位，使两个 “P” 对齐。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HERE IS A SIMPLE EXAMPLE</span><br><span class="line">         EXAMPLE</span><br></pre></td></tr></table></figure><br>由此总结坏字符启发法的规则是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模式后移位数 = 坏字符在模式中失配的位置 - 坏字符在模式中最后一次出现的位置</span><br></pre></td></tr></table></figure><br>坏字符启发法规则中的特殊情况：</p>
<ul>
<li>如果坏字符不存在于模式中，则最后一次出现的位置为 -1。</li>
<li>如果坏字符在模式中的位置位于失配位置的右侧，则此启发法不提供任何建议。</li>
</ul>
<p>以上面示例中坏字符 “P” 为例，它的失配位置为 “E” 的位置 6 （位置从 0 开始），在模式中最后一次出现的位置是 4，则模式后移位数为 6 - 4 = 2 位。模式移动的结果就是使模式中最后出现的 “P” 与文本中的坏字符 “P” 进行对齐。</p>
<p>实际上，前面的坏字符 “S” 出现时，其失配位置为 6，最后一次出现位置为 -1，所以模式后移位数为 6 - (-1) = 7 位。也就是将模式整体移过坏字符。</p>
<p>我们继续上面的过程，仍然从尾部开始比较。仍然从尾部开始比较，发现 “E” 与 “E” 匹配，则继续倒序比较。发现 “L” 与 “L” 匹配，则继续倒序比较。发现 “P” 与 “P” 匹配，则继续倒序比较。发现 “M” 与 “M” 匹配，则继续倒序比较。发现 “I” 与 “A” 不匹配，则 “I” 是坏字符。对于前面已经匹配的字符串 “MPLE”、”PLE”、”LE”、”E”，我们称它们为好后缀（Good Suffix）。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HERE IS A SIMPLE EXAMPLE</span><br><span class="line">         EXAMPLE</span><br></pre></td></tr></table></figure></p>
<p>而好后缀启发法的规则是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模式后移位数 = 好后缀在模式中的当前位置 - 好后缀在模式中最右出现且前缀字符不同的位置</span><br></pre></td></tr></table></figure><br>好后缀在模式中的当前位置以其最后一个字符为准。如果好后缀不存在于模式中，则最右出现的位置为 -1。这样，我们先来找出好后缀在模式中上一次出现的位置。</p>
<ul>
<li>“MPLE” : 未出现，最右出现的位置为 -1；</li>
<li>“PLE” : 未出现在头部，最右出现的位置为 -1；</li>
<li>“LE” : 未出现在头部，最右出现的位置为 -1；</li>
<li>“E” : 出现在头部，补充虚拟字符 ‘MPL’E，前缀字符为空，最右出现的位置为 0；</li>
</ul>
<p>由于只有 “E” 在模式中出现，其当前位置为 6，上一次出现的位置为 0，则依据好后缀启发法规则，模式后移位数为 6 - 0 = 6 位。而如果依据坏字符启发法规则，模式后移位数为 2 - (-1) = 3 位。</p>
<p>Boyer–Moore 算法的特点就在于此，选择上述两种启发法规则计算结果中最大的一个值来对模式 P 的比较位置进行滑动。这里将选择好后缀启发法的计算结果，即将模式向后移 6 位。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HERE IS A SIMPLE EXAMPLE</span><br><span class="line">               EXAMPLE</span><br></pre></td></tr></table></figure></p>
<p>此时，仍然从尾部开始比较。发现 “P” 与 “E” 不匹配，则 “P” 是坏字符，则模式后移位数为 6 - 4 = 2 位。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HERE IS A SIMPLE EXAMPLE</span><br><span class="line">                 EXAMPLE</span><br></pre></td></tr></table></figure><br>发现 “E” 与 “E” 匹配，则继续倒序比较，直到发现全部匹配，则匹配到的第一个完整的模式 P 被发现。</p>
<p>继续下去则是依据好后缀启示法规则计算好后缀 “E” 的后移位置为 6 - 0 = 6 位，然后继续倒序比较时发现已超出文本 T 的范围，搜索结束。</p>
<p>从上面的示例描述可以看出，Boyer–Moore 算法的精妙之处在于，其通过两种启示规则来计算后移位数，且其计算过程只与模式 P 有关，而与文本 T 无关。因此，在对模式 P 进行预处理时，可预先生成 “坏字符规则之向后位移表” 和 “好后缀规则之向后位移表”，在具体匹配时仅需查表比较两者中最大的位移即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> StringMatching</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Program</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="type">char</span>[] text1 = <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>.<span class="built_in">ToCharArray</span>();</span><br><span class="line">      <span class="type">char</span>[] pattern1 = <span class="string">&quot;ABCDABD&quot;</span>.<span class="built_in">ToCharArray</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> firstShift1;</span><br><span class="line">      <span class="type">bool</span> isMatched1 = BoyerMooreStringMatcher.<span class="built_in">TryMatch</span>(</span><br><span class="line">        text1, pattern1, out firstShift1);</span><br><span class="line">      Contract.<span class="built_in">Assert</span>(isMatched1);</span><br><span class="line">      Contract.<span class="built_in">Assert</span>(firstShift1 == <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span>[] text2 = <span class="string">&quot;ABABDAAAACAAAABCABAB&quot;</span>.<span class="built_in">ToCharArray</span>();</span><br><span class="line">      <span class="type">char</span>[] pattern2 = <span class="string">&quot;AAACAAAA&quot;</span>.<span class="built_in">ToCharArray</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> firstShift2;</span><br><span class="line">      <span class="type">bool</span> isMatched2 = BoyerMooreStringMatcher.<span class="built_in">TryMatch</span>(</span><br><span class="line">        text2, pattern2, out firstShift2);</span><br><span class="line">      Contract.<span class="built_in">Assert</span>(isMatched2);</span><br><span class="line">      Contract.<span class="built_in">Assert</span>(firstShift2 == <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span>[] text3 = <span class="string">&quot;ABAAACAAAAAACAAAABCABAAAACAAAAFDLAAACAAAAAACAAAA&quot;</span></span><br><span class="line">        .<span class="built_in">ToCharArray</span>();</span><br><span class="line">      <span class="type">char</span>[] pattern3 = <span class="string">&quot;AAACAAAA&quot;</span>.<span class="built_in">ToCharArray</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span>[] shiftIndexes3 = BoyerMooreStringMatcher.<span class="built_in">MatchAll</span>(text3, pattern3);</span><br><span class="line">      Contract.<span class="built_in">Assert</span>(shiftIndexes<span class="number">3.L</span>ength == <span class="number">5</span>);</span><br><span class="line">      Contract.<span class="built_in">Assert</span>(string.<span class="built_in">Join</span>(<span class="string">&quot;,&quot;</span>, shiftIndexes3) == <span class="string">&quot;2,9,22,33,40&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span>[] text4 = <span class="string">&quot;GCATCGCAGAGAGTATACAGTACG&quot;</span>.<span class="built_in">ToCharArray</span>();</span><br><span class="line">      <span class="type">char</span>[] pattern4 = <span class="string">&quot;GCAGAGAG&quot;</span>.<span class="built_in">ToCharArray</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> firstShift4;</span><br><span class="line">      <span class="type">bool</span> isMatched4 = BoyerMooreStringMatcher.<span class="built_in">TryMatch</span>(</span><br><span class="line">        text4, pattern4, out firstShift4);</span><br><span class="line">      Contract.<span class="built_in">Assert</span>(isMatched4);</span><br><span class="line">      Contract.<span class="built_in">Assert</span>(firstShift4 == <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span>[] text5 = <span class="string">&quot;HERE IS A SIMPLE EXAMPLE AND EXAMPLE OF BM.&quot;</span>.<span class="built_in">ToCharArray</span>();</span><br><span class="line">      <span class="type">char</span>[] pattern5 = <span class="string">&quot;EXAMPLE&quot;</span>.<span class="built_in">ToCharArray</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> firstShift5;</span><br><span class="line">      <span class="type">bool</span> isMatched5 = BoyerMooreStringMatcher.<span class="built_in">TryMatch</span>(</span><br><span class="line">        text5, pattern5, out firstShift5);</span><br><span class="line">      Contract.<span class="built_in">Assert</span>(isMatched5);</span><br><span class="line">      Contract.<span class="built_in">Assert</span>(firstShift5 == <span class="number">17</span>);</span><br><span class="line">      <span class="type">int</span>[] shiftIndexes5 = BoyerMooreStringMatcher.<span class="built_in">MatchAll</span>(text5, pattern5);</span><br><span class="line">      Contract.<span class="built_in">Assert</span>(shiftIndexes<span class="number">5.L</span>ength == <span class="number">2</span>);</span><br><span class="line">      Contract.<span class="built_in">Assert</span>(string.<span class="built_in">Join</span>(<span class="string">&quot;,&quot;</span>, shiftIndexes5) == <span class="string">&quot;17,29&quot;</span>);</span><br><span class="line"></span><br><span class="line">      Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;Well done!&quot;</span>);</span><br><span class="line">      Console.<span class="built_in">ReadKey</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoyerMooreStringMatcher</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="type">int</span> AlphabetSize = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> (a &gt; b) ? a : b; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span>[] <span class="built_in">PreprocessToBuildBadCharactorHeuristic</span>(<span class="type">char</span>[] pattern)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> m = pattern.Length;</span><br><span class="line">      <span class="type">int</span>[] badCharactorShifts = <span class="keyword">new</span> <span class="type">int</span>[AlphabetSize];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; AlphabetSize; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//badCharactorShifts[i] = -1;</span></span><br><span class="line">        badCharactorShifts[i] = m;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// fill the actual value of last occurrence of a character</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//badCharactorShifts[(int)pattern[i]] = i;</span></span><br><span class="line">        badCharactorShifts[(<span class="type">int</span>)pattern[i]] = m - <span class="number">1</span> - i;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> badCharactorShifts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span>[] <span class="built_in">PreprocessToBuildGoodSuffixHeuristic</span>(<span class="type">char</span>[] pattern)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> m = pattern.Length;</span><br><span class="line">      <span class="type">int</span>[] goodSuffixShifts = <span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line">      <span class="type">int</span>[] suffixLengthArray = <span class="built_in">GetSuffixLengthArray</span>(pattern);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">      &#123;</span><br><span class="line">        goodSuffixShifts[i] = m;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">-1</span>; --i)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span> || suffixLengthArray[i] == i + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">for</span> (; j &lt; m - <span class="number">1</span> - i; ++j)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (goodSuffixShifts[j] == m)</span><br><span class="line">            &#123;</span><br><span class="line">              goodSuffixShifts[j] = m - <span class="number">1</span> - i;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i)</span><br><span class="line">      &#123;</span><br><span class="line">        goodSuffixShifts[m - <span class="number">1</span> - suffixLengthArray[i]] = m - <span class="number">1</span> - i;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> goodSuffixShifts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span>[] <span class="built_in">GetSuffixLengthArray</span>(<span class="type">char</span>[] pattern)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> m = pattern.Length;</span><br><span class="line">      <span class="type">int</span>[] suffixLengthArray = <span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> f = <span class="number">0</span>, g = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      suffixLengthArray[m - <span class="number">1</span>] = m;</span><br><span class="line"></span><br><span class="line">      g = m - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; g &amp;&amp; suffixLengthArray[i + m - <span class="number">1</span> - f] &lt; i - g)</span><br><span class="line">        &#123;</span><br><span class="line">          suffixLengthArray[i] = suffixLengthArray[i + m - <span class="number">1</span> - f];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (i &lt; g)</span><br><span class="line">          &#123;</span><br><span class="line">            g = i;</span><br><span class="line">          &#125;</span><br><span class="line">          f = i;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// find different preceded character suffix</span></span><br><span class="line">          <span class="keyword">while</span> (g &gt;= <span class="number">0</span> &amp;&amp; pattern[g] == pattern[g + m - <span class="number">1</span> - f])</span><br><span class="line">          &#123;</span><br><span class="line">            --g;</span><br><span class="line">          &#125;</span><br><span class="line">          suffixLengthArray[i] = f - g;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> suffixLengthArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">bool</span> <span class="title">TryMatch</span><span class="params">(<span class="type">char</span>[] text, <span class="type">char</span>[] pattern, out <span class="type">int</span> firstShift)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      firstShift = <span class="number">-1</span>;</span><br><span class="line">      <span class="type">int</span> n = text.Length;</span><br><span class="line">      <span class="type">int</span> m = pattern.Length;</span><br><span class="line">      <span class="type">int</span> s = <span class="number">0</span>; <span class="comment">// s is shift of the pattern with respect to text</span></span><br><span class="line">      <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// fill the bad character and good suffix array by preprocessing</span></span><br><span class="line">      <span class="type">int</span>[] badCharShifts = <span class="built_in">PreprocessToBuildBadCharactorHeuristic</span>(pattern);</span><br><span class="line">      <span class="type">int</span>[] goodSuffixShifts = <span class="built_in">PreprocessToBuildGoodSuffixHeuristic</span>(pattern);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (s &lt;= (n - m))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// starts matching from the last character of the pattern</span></span><br><span class="line">        j = m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// keep reducing index j of pattern while characters of</span></span><br><span class="line">        <span class="comment">// pattern and text are matching at this shift s</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; pattern[j] == text[s + j])</span><br><span class="line">        &#123;</span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the pattern is present at current shift, then index j</span></span><br><span class="line">        <span class="comment">// will become -1 after the above loop</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          firstShift = s;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// shift the pattern so that the bad character in text</span></span><br><span class="line">          <span class="comment">// aligns with the last occurrence of it in pattern. the</span></span><br><span class="line">          <span class="comment">// max function is used to make sure that we get a positive</span></span><br><span class="line">          <span class="comment">// shift. We may get a negative shift if the last occurrence</span></span><br><span class="line">          <span class="comment">// of bad character in pattern is on the right side of the</span></span><br><span class="line">          <span class="comment">// current character.</span></span><br><span class="line">          <span class="comment">//s += Max(1, j - badCharShifts[(int)text[s + j]]);</span></span><br><span class="line">          <span class="comment">// now, compare bad char shift and good suffix shift to find best</span></span><br><span class="line">          s += <span class="built_in">Max</span>(goodSuffixShifts[j], badCharShifts[(<span class="type">int</span>)text[s + j]] - (m - <span class="number">1</span>) + j);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span>[] <span class="built_in">MatchAll</span>(<span class="type">char</span>[] text, <span class="type">char</span>[] pattern)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> n = text.Length;</span><br><span class="line">      <span class="type">int</span> m = pattern.Length;</span><br><span class="line">      <span class="type">int</span> s = <span class="number">0</span>; <span class="comment">// s is shift of the pattern with respect to text</span></span><br><span class="line">      <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span>[] shiftIndexes = <span class="keyword">new</span> <span class="type">int</span>[n - m + <span class="number">1</span>];</span><br><span class="line">      <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// fill the bad character and good suffix array by preprocessing</span></span><br><span class="line">      <span class="type">int</span>[] badCharShifts = <span class="built_in">PreprocessToBuildBadCharactorHeuristic</span>(pattern);</span><br><span class="line">      <span class="type">int</span>[] goodSuffixShifts = <span class="built_in">PreprocessToBuildGoodSuffixHeuristic</span>(pattern);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (s &lt;= (n - m))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// starts matching from the last character of the pattern</span></span><br><span class="line">        j = m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// keep reducing index j of pattern while characters of</span></span><br><span class="line">        <span class="comment">// pattern and text are matching at this shift s</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; pattern[j] == text[s + j])</span><br><span class="line">        &#123;</span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the pattern is present at current shift, then index j</span></span><br><span class="line">        <span class="comment">// will become -1 after the above loop</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          shiftIndexes[c] = s;</span><br><span class="line">          c++;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// shift the pattern so that the next character in text</span></span><br><span class="line">          <span class="comment">// aligns with the last occurrence of it in pattern.</span></span><br><span class="line">          <span class="comment">// the condition s+m &lt; n is necessary for the case when</span></span><br><span class="line">          <span class="comment">// pattern occurs at the end of text</span></span><br><span class="line">          <span class="comment">//s += (s + m &lt; n) ? m - badCharShifts[(int)text[s + m]] : 1;</span></span><br><span class="line">          s += goodSuffixShifts[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// shift the pattern so that the bad character in text</span></span><br><span class="line">          <span class="comment">// aligns with the last occurrence of it in pattern. the</span></span><br><span class="line">          <span class="comment">// max function is used to make sure that we get a positive</span></span><br><span class="line">          <span class="comment">// shift. We may get a negative shift if the last occurrence</span></span><br><span class="line">          <span class="comment">// of bad character in pattern is on the right side of the</span></span><br><span class="line">          <span class="comment">// current character.</span></span><br><span class="line">          <span class="comment">//s += Max(1, j - badCharShifts[(int)text[s + j]]);</span></span><br><span class="line">          <span class="comment">// now, compare bad char shift and good suffix shift to find best</span></span><br><span class="line">          s += <span class="built_in">Max</span>(goodSuffixShifts[j], badCharShifts[(<span class="type">int</span>)text[s + j]] - (m - <span class="number">1</span>) + j);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span>[] shifts = <span class="keyword">new</span> <span class="type">int</span>[c];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; c; y++)</span><br><span class="line">      &#123;</span><br><span class="line">        shifts[y] = shiftIndexes[y];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> shifts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="多阶hash表"><a href="#多阶hash表" class="headerlink" title="多阶hash表"></a>多阶hash表</h1><p>原文:<a href="https://blog.csdn.net/wm_1991/article/details/52218718">https://blog.csdn.net/wm_1991/article/details/52218718</a></p>
<p>多阶hash表实际上是一个锯齿数组，看起来是这个样子的：<br>■■■■■■■■■■■■■■■<br>■■■■■■■■■■■■■<br>■■■■■■■■■■<br>■■■■■■<br>■■■</p>
<p>每一行是一阶，上面的元素个数多，下面的元素个数依次减少。<br>每一行的元素个数都是素数的。</p>
<p>数组的每个节点用于存储数据的内容，其中，节点的前四个字节用于存储int类型的key或者是hash_code</p>
<p>创建多阶HASH的时候，用户通过参数来指定有多少阶，每一阶最多多少个元素。<br>那么，下面的每一阶究竟应该选择多少个元素呢？从代码注释上看来，是采用了素数集中原理的算法来查找的。<br>例如，假设每阶最多1000个元素，一共10阶，则算法选择十个比1000小的最大素数，从大到小排列，以此作为各阶的元素个数。通过素数集中的算法得到的10个素数分别是：997 991 983 977 971 967 953 947 941 937。<br>可见，虽然是锯齿数组，各层之间的差别并不是很多。</p>
<p>查找过程：</p>
<ol>
<li>先将key在第一阶内取模，看是否是这个元素，如果这个位置为空，直接返回不存在；如果是这个KEY，则返回这个位置。</li>
<li>如果这个位置有元素，但是又不是这个key，则说明hash冲突，再到第二阶去找。</li>
<li>循环往复。</li>
</ol>
<p>好处：</p>
<ol>
<li>hash冲突的处理非常简单；</li>
<li>有多个桶，使得空间利用率很高，你并不需要一个很大的桶来减少冲突。</li>
<li>可以考虑动态增长空间，不断加入新的一阶，且对原来的数据没影响。</li>
</ol>
<p>使用共享内存的多级哈希表的一种实现<br>在一个服务程序运行的时候，它往往要把数据写入共享内存以便在进城需要重新启动的时候可以直接从共享内存中读取数据，另一方面，在服务进程因某种原因挂掉的时候，共享内存中的数据仍然存在，这样就可以减少带来的损失。关于共享内存的内容请google之，在这里，实现了一种在共享内存中存取数据的hash表，它采用了多级存储求模取余的方法，具体内容请看以下代码：<br><a href="http://lmlf001.blog.sohu.com/">http://lmlf001.blog.sohu.com/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//hash_shm.h</span><br><span class="line">#ifndef _STORMLI_HASH_SHM_H_</span><br><span class="line">#define _STORMLI_HASH_SHM_H_</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;sys/shm.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename valueType,unsigned long maxLine,int lines&gt;</span><br><span class="line">class hash_shm</span><br><span class="line">&#123;</span><br><span class="line">public:    </span><br><span class="line">    int find(unsigned long _key);    </span><br><span class="line">    //if _key in the table,return 0,and set lastFound the position,otherwise return -1</span><br><span class="line">    int remove(unsigned long _key);    </span><br><span class="line">    //if _key not in the table,return-1,else remove the node,set the node key 0 and return 0</span><br><span class="line"></span><br><span class="line">    //insert node into the table,if the _key exists,return 1,if insert success,return 0;and if fail return -1</span><br><span class="line">    int insert(unsigned long _key,const valueType &amp;_value);</span><br><span class="line">    void clear();        </span><br><span class="line">    //remove all the data</span><br><span class="line"></span><br><span class="line">public:    </span><br><span class="line">//some statistic function</span><br><span class="line">    double getFullRate()const;        </span><br><span class="line">    //the rate of the space used</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    //constructor,with the share memory start position and the space size,if the space is not enough,the program will exit</span><br><span class="line">    hash_shm(void *startShm,unsigned long shmSize=sizeof(hash_node)*maxLine*lines);</span><br><span class="line"></span><br><span class="line">    //constructor,with the share memory key,it will get share memory,if fail,exit</span><br><span class="line">    hash_shm(key_t shm_key);</span><br><span class="line">    ~hash_shm()&#123;&#125;    </span><br><span class="line">    //destroy the class</span><br><span class="line">private:</span><br><span class="line">    void *mem;        </span><br><span class="line">    //the start position of the share memory  </span><br><span class="line">    // the mem+memSize  space used to storage the runtime data:currentSize</span><br><span class="line">    unsigned long memSize;    </span><br><span class="line">    //the size of the share memory</span><br><span class="line">    unsigned long modTable[lines];    </span><br><span class="line">    //modtable,the largest primes</span><br><span class="line">    unsigned long maxSize;        </span><br><span class="line">    //the size of the table</span><br><span class="line">    unsigned long *currentSize;    </span><br><span class="line">    //current size of the table ,the pointer of the shm mem+memSize</span><br><span class="line">    void *lastFound;        </span><br><span class="line">    //write by the find function,record the last find place</span><br><span class="line">    </span><br><span class="line">    struct hash_node&#123;        //the node of the hash table</span><br><span class="line">        unsigned long key;    //when key==0,the node is empty</span><br><span class="line">        valueType value;    //name-value pair</span><br><span class="line">    &#125;;</span><br><span class="line">private:</span><br><span class="line">    bool getShm(key_t shm_key);    </span><br><span class="line">    //get share memory,used by the constructor</span><br><span class="line">    void getMode();        </span><br><span class="line">    //get the largest primes blow maxLine,use by the constructor</span><br><span class="line">    void *getPos(unsigned int _row,unsigned long _col);</span><br><span class="line">    //get the positon with the (row,col)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">hash_shm&lt;vT,maxLine,lines&gt;::hash_shm(void *startShm,unsigned long shmSize)</span><br><span class="line">&#123;</span><br><span class="line">    if(startShm!=NULL)&#123;</span><br><span class="line">        cerr&lt;&lt;&quot;Argument error\n Please check the shm address\n&quot;;</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    getMode();</span><br><span class="line">    maxSize=0;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;lines;i++)    //count the maxSize</span><br><span class="line">        maxSize+=modTable[i];</span><br><span class="line">    if(shmSize&lt;sizeof(hash_node)*(maxSize+1))&#123;    </span><br><span class="line">        //check the share memory size</span><br><span class="line">        cerr&lt;&lt;&quot;Not enough share memory space\n&quot;;</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    memSize=shmSize;</span><br><span class="line">    if(*(currentSize=(unsigned long *)((long)mem+memSize))&lt;0)</span><br><span class="line">        *currentSize=0;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">hash_shm&lt;vT,maxLine,lines&gt;::hash_shm(key_t shm_key)</span><br><span class="line">&#123;    //constructor with get share memory</span><br><span class="line">    getMode();</span><br><span class="line">    maxSize=0;</span><br><span class="line">    for(int i=0;i&lt;lines;i++)</span><br><span class="line">        maxSize+=modTable[i];</span><br><span class="line">    memSize=sizeof(hash_node)*maxSize;    </span><br><span class="line">    if(!getShm(shm_key))&#123;</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">//    memset(mem,0,memSize);</span><br><span class="line">    if(*(currentSize=(unsigned long *)((long)mem+memSize))&lt;0)</span><br><span class="line">        *currentSize=0;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">int hash_shm&lt;vT,maxLine,lines&gt;::find(unsigned long _key)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long hash;</span><br><span class="line">    hash_node *pH=NULL;</span><br><span class="line">    for(int i=0;i&lt;lines;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash=(_key+maxLine)%modTable[i];    </span><br><span class="line">        //calculate the col position</span><br><span class="line">        pH=(hash_node *)getPos(i,hash);</span><br><span class="line">//        if(pH==NULL)return -2;    //almost not need</span><br><span class="line">        if(pH-&gt;key==_key)&#123;</span><br><span class="line">            lastFound=pH;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">int hash_shm&lt;vT,maxLine,lines&gt;::remove(unsigned long _key)</span><br><span class="line">&#123;</span><br><span class="line">    if(find(_key)==-1)return -1;    //not found</span><br><span class="line">    hash_node *pH=(hash_node *)lastFound;</span><br><span class="line">    pH-&gt;key=0;        //only set the key 0</span><br><span class="line">    (*currentSize)--;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">int hash_shm&lt;vT,maxLine,lines&gt;::insert(unsigned long _key,const vT &amp;_value)</span><br><span class="line">&#123;</span><br><span class="line">    if(find(_key)==0)return 1;    //if the key exists</span><br><span class="line">    unsigned long hash;</span><br><span class="line">    hash_node *pH=NULL;</span><br><span class="line">    for(int i=0;i&lt;lines;i++)&#123;    </span><br><span class="line">        hash=(_key+maxLine)%modTable[i];</span><br><span class="line">        pH=(hash_node *)getPos(i,hash);</span><br><span class="line">        if(pH-&gt;key==0)&#123;        //find the insert position,insert the value</span><br><span class="line">            pH-&gt;key=_key;</span><br><span class="line">            pH-&gt;value=_value;</span><br><span class="line">            (*currentSize)++;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;    //all the appropriate position filled</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">void hash_shm&lt;vT,maxLine,lines&gt;::clear()</span><br><span class="line">&#123;</span><br><span class="line">    memset(mem,0,memSize);</span><br><span class="line">    *currentSize=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">bool hash_shm&lt;vT,maxLine,lines&gt;::getShm(key_t shm_key)</span><br><span class="line">&#123;</span><br><span class="line">    int shm_id=shmget(shm_key,memSize,0666);</span><br><span class="line">    if(shm_id==-1)    //check if the shm exists</span><br><span class="line">    &#123;</span><br><span class="line">        shm_id=shmget(shm_key,memSize,0666|IPC_CREAT);//create the shm</span><br><span class="line">        if(shm_id==-1)&#123;</span><br><span class="line">            cerr&lt;&lt;&quot;Share memory get failed\n&quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mem=shmat(shm_id,NULL,0);    //mount the shm</span><br><span class="line">    if(int(mem)==-1)&#123;</span><br><span class="line">        cerr&lt;&lt;&quot;shmat system call failed\n&quot;;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">void hash_shm&lt;vT,maxLine,lines&gt;::getMode()</span><br><span class="line">&#123;        //采用 6n+1 6n-1 素数集中原理</span><br><span class="line">    if(maxLine&lt;5)&#123;exit(-1);&#125;</span><br><span class="line">    </span><br><span class="line">    unsigned long t,m,n,p;</span><br><span class="line">    int i,j,a,b,k;</span><br><span class="line">    int z=0;</span><br><span class="line">    </span><br><span class="line">    for(t=maxLine/6;t&gt;=0,z&lt;lines;t--)</span><br><span class="line">    &#123;</span><br><span class="line">        i=1;j=1; k=t%10;</span><br><span class="line">        m=6*t;                                        /**i,j的值 是是否进行验证的标志也是对应的6t-1和6t+1的素性标志**/</span><br><span class="line">        if(((k-4)==0)||((k-9)==0)||((m+1)%3==0))j=0;/*此处是简单验证6*t-1,6*t+1 是不是素数，借以提高素数纯度**/</span><br><span class="line">        if(((k-6)==0)||((m-1)%3==0))i=0;            /***先通过初步判断去除末尾是5，及被3整除的数***/</span><br><span class="line">        for(p=1;p*6&lt;=sqrt(m+1)+2;p++ )</span><br><span class="line">        &#123;</span><br><span class="line">            n=p*6;                                    /**将6*p-1和6*p+1看作伪素数来试除*****/</span><br><span class="line">            k=p%10;</span><br><span class="line">            a=1;b=1;                                /**同样此处a,b的值也是用来判断除数是否为素数提高除数的素数纯度**/</span><br><span class="line">            if(((k-4)==0)||((k-9)==0))a=0;</span><br><span class="line">            if(((k-6)==0))b=0;</span><br><span class="line">            if(i)&#123;                            /*如果i非零就对m-1即所谓6*t-1进行验证，当然还要看除数n+1,n-1,素性纯度*/</span><br><span class="line">                if(a)&#123;if((m-1)%(n+1)==0)i=0;&#125;        /***一旦被整除就说明不是素数故素性为零即将i 赋值为零***/</span><br><span class="line">                if(b)&#123;if((m-1)%(n-1)==0)i=0;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j)&#123;                           /**如果j非零就对m+1即所谓6*t+1进行验证，当然还要看除数n+1,n-1,素性纯度*/</span><br><span class="line">                if(a)&#123;if((m+1)%(n+1)==0)j=0;&#125;         /***一旦被整除就说明不是素数故素性为零即将j 赋值为零***/</span><br><span class="line">                if(b)&#123;if((m+1)%(n-1)==0)j=0;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if((i+j)==0)break;                     /**如果已经知道6*t-1,6*t+1都不是素数了那就结束试除循环***/</span><br><span class="line">        &#125;</span><br><span class="line">        if(j)&#123;modTable[z++]=m+1;if(z&gt;= lines)return;&#125;</span><br><span class="line">        if(i)&#123;modTable[z++]=m-1;if(z&gt;= lines)return;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">void *hash_shm&lt;vT,maxLine,lines&gt;::getPos(unsigned int _row,unsigned long _col)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long pos=0UL;</span><br><span class="line">    for(int i=0;i&lt;_row;i++)    //calculate the positon from the start</span><br><span class="line">        pos+=modTable[i];</span><br><span class="line">    pos+=_col;        </span><br><span class="line">    if(pos&gt;=maxSize)return NULL;</span><br><span class="line">    return (void *)((long)mem+pos*sizeof(hash_node));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">double hash_shm&lt;vT,maxLine,lines&gt;::getFullRate()const</span><br><span class="line">&#123;</span><br><span class="line">    return double(*currentSize)/maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//test.cpp</span><br><span class="line"></span><br><span class="line">#include&quot;hash_shm.h&quot;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    hash_shm&lt;int,1000,100&gt; ht(key_t(999));</span><br><span class="line">    double rate=0.0;</span><br><span class="line">//    ht.clear();</span><br><span class="line">    for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">        srand(time(NULL)+i);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(ht.insert(rand(),0)==-1)break;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ht.getFullRate()&lt;&lt;endl;</span><br><span class="line">        rate+=ht.getFullRate();</span><br><span class="line">        ht.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;\n\n\n&quot;;</span><br><span class="line">    cout&lt;&lt;rate/100&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码作测试的时候发现了一些问题，用gprof查看函数时间的时候发现，getPos函数占用了大部分的执行时间，始主要的性能瓶颈，后来又新设立了一个数组，用来记录每行开始时的位置，性能提高了很多，改动部分的代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename valueType,unsigned long maxLine,int lines&gt;</span><br><span class="line">class hash_shm</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    void *mem;        //the start position of the share memory  // the mem+memSize  space used to storage the runtime data:currentSize</span><br><span class="line">    unsigned long memSize;    //the size of the share memory</span><br><span class="line">    unsigned long modTable[lines];    //modtable,the largest primes</span><br><span class="line">    unsigned long modTotal[lines];    //modTotal[i] is the summary of the modTable when x&lt;=i  </span><br><span class="line">                    //used by getPos to improve the performance</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">hash_shm&lt;vT,maxLine,lines&gt;::hash_shm(void *startShm,unsigned long shmSize)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;lines;i++)&#123;    //count the maxSize</span><br><span class="line">        maxSize+=modTable[i];</span><br><span class="line">        if(i!=0)modTotal[i]=modTotal[i-1]+modTable[i-1];</span><br><span class="line">        else modTotal[i]=0;    //caculate the modTotal</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">hash_shm&lt;vT,maxLine,lines&gt;::hash_shm(key_t shm_key)</span><br><span class="line">&#123;    //constructor with get share memory </span><br><span class="line">    getMode();</span><br><span class="line">    maxSize=0;</span><br><span class="line">    for(int i=0;i&lt;lines;i++)&#123;</span><br><span class="line">        maxSize+=modTable[i];</span><br><span class="line">        if(i!=0)modTotal[i]=modTotal[i-1]+modTable[i-1];</span><br><span class="line">        else modTotal[i]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">void *hash_shm&lt;vT,maxLine,lines&gt;::getPos(unsigned int _row,unsigned long _col)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long pos=_col+modTotal[_row];</span><br><span class="line">    //for(int i=0;i&lt;_row;i++)    //calculate the positon from the start</span><br><span class="line">    //    pos+=modTable[i];</span><br><span class="line">    if(pos&lt;maxSize)</span><br><span class="line">        return (void *)((long)mem+pos*sizeof(hash_node));</span><br><span class="line">    return NULL;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增了一个用于遍历的函数foreach<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename vT,unsigned long maxLine,int lines&gt;</span><br><span class="line">void hash_shm&lt;vT,maxLine,lines&gt;::foreach(void (*fn)(unsigned long _key,vT &amp;_value))</span><br><span class="line">&#123;</span><br><span class="line">    typedef  unsigned long u_long;</span><br><span class="line">    u_long beg=(u_long)mem;</span><br><span class="line">    u_long end=(u_long)mem+sizeof(hash_node)*(modTable[lines-1]+modTotal[lines-1]);</span><br><span class="line">    hash_node *p=NULL;</span><br><span class="line">    for(u_long pos=beg;pos&lt;end;pos+=sizeof(hash_node))</span><br><span class="line">    &#123;</span><br><span class="line">        p=(hash_node *)pos;</span><br><span class="line">        if(p-&gt;key!=0)fn(p-&gt;key,p-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了利于使用新增一个用于查找的函数find,该函数同find(_key)类似，如果找到_key节点，把它赋给_value以返回<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int find(unsigned long _key,vT &amp;_value);</span><br></pre></td></tr></table></figure></p>
<h1 id="Hash碰撞冲突"><a href="#Hash碰撞冲突" class="headerlink" title="Hash碰撞冲突"></a>Hash碰撞冲突</h1><p>我们知道，对象Hash的前提是实现equals()和hashCode()两个方法，那么HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样时，这就发生了碰撞冲突。如下将介绍如何处理冲突，当然其前提是一致性hash。</p>
<ol>
<li><p>开放地址法<br>开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)<br>其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。<br>如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)，称二次探测再散列。<br>如果di取值可能为伪随机数列。称伪随机探测再散列。</p>
</li>
<li><p>再哈希法<br>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。<br>比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止</p>
</li>
<li><p>链地址法（拉链法）<br>将所有关键字为同义词的记录存储在同一线性链表中。如下：<br><img src="/img/20160918154444663.png" alt=""></p>
</li>
</ol>
<p>因此这种方法，可以近似的认为是筒子里面套筒子</p>
<ol>
<li>建立一个公共溢出区<br>假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录。</li>
</ol>
<p>拉链法的优缺点：<br>优点：</p>
<ul>
<li>拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</li>
<li>由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</li>
<li>开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</li>
<li>在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</li>
</ul>
<p>缺点：</p>
<ul>
<li>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</li>
</ul>
<h1 id="经典字符串hash函数介绍及性能比较"><a href="#经典字符串hash函数介绍及性能比较" class="headerlink" title="经典字符串hash函数介绍及性能比较"></a>经典字符串hash函数介绍及性能比较</h1><p>原文：<a href="https://blog.csdn.net/djinglan/article/details/8812934">https://blog.csdn.net/djinglan/article/details/8812934</a></p>
<p>今天根据自己的理解重新整理了一下几个字符串hash函数，使用了模板，使其支持宽字符串，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief BKDR Hash Function  </span></span><br><span class="line"><span class="comment">/// @detail 本 算法由于在Brian Kernighan与Dennis Ritchie的《The C Programming Language》一书被展示而得 名，是一种简单快捷的hash算法，也是Java目前采用的字符串的Hash算法（累乘因子为31）。  </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">BKDRHash</span><span class="params">(<span class="type">const</span> T *str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="type">size_t</span> ch = (<span class="type">size_t</span>)*str++)  </span><br><span class="line">    &#123;         </span><br><span class="line">        hash = hash * <span class="number">131</span> + ch;   <span class="comment">// 也可以乘以31、131、1313、13131、131313..  </span></span><br><span class="line">        <span class="comment">// 有人说将乘法分解为位运算及加减法可以提高效率，如将上式表达为：hash = hash &lt;&lt; 7 + hash &lt;&lt; 1 + hash + ch;  </span></span><br><span class="line">        <span class="comment">// 但其实在Intel平台上，CPU内部对二者的处理效率都是差不多的，  </span></span><br><span class="line">        <span class="comment">// 我分别进行了100亿次的上述两种运算，发现二者时间差距基本为0（如果是Debug版，分解成位运算后的耗时还要高1/3）；  </span></span><br><span class="line">        <span class="comment">// 在ARM这类RISC系统上没有测试过，由于ARM内部使用Booth&#x27;s Algorithm来模拟32位整数乘法运算，它的效率与乘数有关：  </span></span><br><span class="line">        <span class="comment">// 当乘数8-31位都为1或0时，需要1个时钟周期  </span></span><br><span class="line">        <span class="comment">// 当乘数16-31位都为1或0时，需要2个时钟周期  </span></span><br><span class="line">        <span class="comment">// 当乘数24-31位都为1或0时，需要3个时钟周期  </span></span><br><span class="line">        <span class="comment">// 否则，需要4个时钟周期  </span></span><br><span class="line">        <span class="comment">// 因此，虽然我没有实际测试，但是我依然认为二者效率上差别不大          </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> hash;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/// @brief SDBM Hash Function  </span></span><br><span class="line"><span class="comment">/// @detail 本算法是由于在开源项目SDBM（一种简单的数据库引擎）中被应用而得名，它与BKDRHash思想一致，只是种子不同而已。  </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">SDBMHash</span><span class="params">(<span class="type">const</span> T *str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="type">size_t</span> ch = (<span class="type">size_t</span>)*str++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        hash = <span class="number">65599</span> * hash + ch;         </span><br><span class="line">        <span class="comment">//hash = (size_t)ch + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> hash;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/// @brief RS Hash Function  </span></span><br><span class="line"><span class="comment">/// @detail 因Robert Sedgwicks在其《Algorithms in C》一书中展示而得名。  </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">RSHash</span><span class="params">(<span class="type">const</span> T *str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">size_t</span> magic = <span class="number">63689</span>;     </span><br><span class="line">    <span class="keyword">while</span> (<span class="type">size_t</span> ch = (<span class="type">size_t</span>)*str++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        hash = hash * magic + ch;  </span><br><span class="line">        magic *= <span class="number">378551</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> hash;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/// @brief AP Hash Function  </span></span><br><span class="line"><span class="comment">/// @detail 由Arash Partow发明的一种hash算法。  </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">APHash</span><span class="params">(<span class="type">const</span> T *str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">size_t</span> ch;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; ch = (<span class="type">size_t</span>)*str++; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            hash ^= ((hash &lt;&lt; <span class="number">7</span>) ^ ch ^ (hash &gt;&gt; <span class="number">3</span>));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            hash ^= (~((hash &lt;&lt; <span class="number">11</span>) ^ ch ^ (hash &gt;&gt; <span class="number">5</span>)));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> hash;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/// @brief JS Hash Function  </span></span><br><span class="line"><span class="comment">/// 由Justin Sobel发明的一种hash算法。  </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">JSHash</span><span class="params">(<span class="type">const</span> T *str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!*str)        <span class="comment">// 这是由本人添加，以保证空字符串返回哈希值0  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">1315423911</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="type">size_t</span> ch = (<span class="type">size_t</span>)*str++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        hash ^= ((hash &lt;&lt; <span class="number">5</span>) + ch + (hash &gt;&gt; <span class="number">2</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> hash;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/// @brief DEK Function  </span></span><br><span class="line"><span class="comment">/// @detail 本算法是由于Donald E. Knuth在《Art Of Computer Programming Volume 3》中展示而得名。  </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">DEKHash</span><span class="params">(<span class="type">const</span> T* str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!*str)        <span class="comment">// 这是由本人添加，以保证空字符串返回哈希值0  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">1315423911</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="type">size_t</span> ch = (<span class="type">size_t</span>)*str++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) ^ (hash &gt;&gt; <span class="number">27</span>)) ^ ch;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> hash;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/// @brief FNV Hash Function  </span></span><br><span class="line"><span class="comment">/// @detail Unix system系统中使用的一种著名hash算法，后来微软也在其hash_map中实现。  </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">FNVHash</span><span class="params">(<span class="type">const</span> T* str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!*str)   <span class="comment">// 这是由本人添加，以保证空字符串返回哈希值0  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">2166136261</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="type">size_t</span> ch = (<span class="type">size_t</span>)*str++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        hash *= <span class="number">16777619</span>;  </span><br><span class="line">        hash ^= ch;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> hash;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/// @brief DJB Hash Function  </span></span><br><span class="line"><span class="comment">/// @detail 由Daniel J. Bernstein教授发明的一种hash算法。  </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">DJBHash</span><span class="params">(<span class="type">const</span> T *str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!*str)   <span class="comment">// 这是由本人添加，以保证空字符串返回哈希值0  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">5381</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="type">size_t</span> ch = (<span class="type">size_t</span>)*str++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        hash += (hash &lt;&lt; <span class="number">5</span>) + ch;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> hash;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/// @brief DJB Hash Function 2  </span></span><br><span class="line"><span class="comment">/// @detail 由Daniel J. Bernstein 发明的另一种hash算法。  </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">DJB2Hash</span><span class="params">(<span class="type">const</span> T *str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!*str)   <span class="comment">// 这是由本人添加，以保证空字符串返回哈希值0  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">5381</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="type">size_t</span> ch = (<span class="type">size_t</span>)*str++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        hash = hash * <span class="number">33</span> ^ ch;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> hash;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/// @brief PJW Hash Function  </span></span><br><span class="line"><span class="comment">/// @detail 本算法是基于AT&amp;T贝尔实验室的Peter J. Weinberger的论文而发明的一种hash算法。  </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">PJWHash</span><span class="params">(<span class="type">const</span> T *str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> TotalBits       = <span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">8</span>;  </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> ThreeQuarters   = (TotalBits  * <span class="number">3</span>) / <span class="number">4</span>;  </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> OneEighth       = TotalBits / <span class="number">8</span>;  </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> HighBits        = ((<span class="type">size_t</span>)<span class="number">-1</span>) &lt;&lt; (TotalBits - OneEighth);      </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">size_t</span> magic = <span class="number">0</span>;     </span><br><span class="line">    <span class="keyword">while</span> (<span class="type">size_t</span> ch = (<span class="type">size_t</span>)*str++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        hash = (hash &lt;&lt; OneEighth) + ch;  </span><br><span class="line">        <span class="keyword">if</span> ((magic = hash &amp; HighBits) != <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            hash = ((hash ^ (magic &gt;&gt; ThreeQuarters)) &amp; (~HighBits));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> hash;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/// @brief ELF Hash Function  </span></span><br><span class="line"><span class="comment">/// @detail 由于在Unix的Extended Library Function被附带而得名的一种hash算法，它其实就是PJW Hash的变形。  </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  </span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ELFHash</span><span class="params">(<span class="type">const</span> T *str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> TotalBits       = <span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">8</span>;  </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> ThreeQuarters   = (TotalBits  * <span class="number">3</span>) / <span class="number">4</span>;  </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> OneEighth       = TotalBits / <span class="number">8</span>;  </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> HighBits        = ((<span class="type">size_t</span>)<span class="number">-1</span>) &lt;&lt; (TotalBits - OneEighth);      </span><br><span class="line">    <span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">size_t</span> magic = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="type">size_t</span> ch = (<span class="type">size_t</span>)*str++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        hash = (hash &lt;&lt; OneEighth) + ch;  </span><br><span class="line">        <span class="keyword">if</span> ((magic = hash &amp; HighBits) != <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            hash ^= (magic &gt;&gt; ThreeQuarters);  </span><br><span class="line">            hash &amp;= ~magic;  </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> hash;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>我对这些hash的散列质量及效率作了一个简单测试，测试结果如下：</p>
<p>测试1：对100000个由大小写字母与数字随机的ANSI字符串（无重复，每个字符串最大长度不超过64字符）进行散列：<br><img src="/img/20190411201.jpg" alt=""></p>
<p>测试2：对100000个由任意UNICODE组成随机字符串（无重复，每个字符串最大长度不超过64字符）进行散列：<br><img src="/img/20190411202.jpg" alt=""></p>
<p>测试3：对1000000个随机ANSI字符串（无重复，每个字符串最大长度不超过64字符）进行散列：<br><img src="/img/20190411203.jpg" alt=""></p>
<p>结论：也许是我的样本存在一些特殊性，在对ASCII码字符串进行散列时，PJW与ELF Hash（它们其实是同一种算法）无论是质量还是效率，都相当糟糕；例如：”b5”与“aE”，这两个字符串按照PJW散列出来的hash值就是一样的。 另外，其它几种依靠异或来散列的哈希函数，如：JS/DEK/DJB Hash，在对字母与数字组成的字符串的散列效果也不怎么好。相对而言，还是BKDR与SDBM这类简单的Hash效率与效果更好。</p>
<p>常用的字符串Hash函数还有ELFHash，APHash等等，都是十分简单有效的方法。这些函数使用位运算使得每一个字符都对最后的函数值产生 影响。另外还有以MD5和SHA1为代表的杂凑函数，这些函数几乎不可能找到碰撞。</p>
<p>常用字符串哈希函数有 BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash等等。对于以上几种哈 希函数，我对其进行了一个小小的评测。</p>
<p><img src="/img/20190411204.jpg" alt=""></p>
<p>其中数据1为100000个字母和数字组成的随机串哈希冲突个数。数据2为100000个有意义的英文句子哈希冲突个数。数据3为数据1的哈希值与 1000003(大素数)求模后存储到线性表中冲突的个数。数据4为数据1的哈希值与10000019(更大素数)求模后存储到线性表中冲突的个数。</p>
<p>经过比较，得出以上平均得分。平均数为平方平均数。可以发现，BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的。APHash也 是较为优秀的算法。DJBHash,JSHash,RSHash与SDBMHash各有千秋。PJWHash与ELFHash效果最差，但得分相似，其算 法本质是相似的。</p>
<h1 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/img/834896-20160527163537178-321412097.png" alt=""></p>
<p>Merkle Tree，通常也被称作Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块(例如，文件或者文件的集合)的hash值。非叶节点是其对应子节点串联字符串的hash。[1]</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash是一个把任意长度的数据映射成固定长度数据的函数[2]。例如，对于数据完整性校验，最简单的方法是对整个数据做Hash运算得到固定长度的Hash值，然后把得到的Hash值公布在网上，这样用户下载到数据之后，对数据再次进行Hash运算，比较运算结果和网上公布的Hash值进行比较，如果两个Hash值相等，说明下载的数据没有损坏。可以这样做是因为输入数据的稍微改变就会引起Hash运算结果的面目全非，而且根据Hash值反推原始输入数据的特征是困难的。<br><img src="/img/834896-20160527163705538-1394781481.png" alt=""></p>
<p>如果从一个稳定的服务器进行下载，采用单一Hash是可取的。但如果数据源不稳定，一旦数据损坏，就需要重新下载，这种下载的效率是很低的。</p>
<h3 id="Hash-List"><a href="#Hash-List" class="headerlink" title="Hash List"></a>Hash List</h3><p>在点对点网络中作数据传输的时候，会同时从多个机器上下载数据，而且很多机器可以认为是不稳定或者不可信的。为了校验数据的完整性，更好的办法是把大的文件分割成小的数据块（例如，把分割成2K为单位的数据块）。这样的好处是，如果小块数据在传输过程中损坏了，那么只要重新下载这一快数据就行了，不用重新下载整个文件。</p>
<p>怎么确定小的数据块没有损坏哪？只需要为每个数据块做Hash。BT下载的时候，在下载到真正数据之前，我们会先下载一个Hash列表。那么问题又来了，怎么确定这个Hash列表本事是正确的哪？答案是把每个小块数据的Hash值拼到一起，然后对这个长字符串在作一次Hash运算，这样就得到Hash列表的根Hash(Top Hash or Root Hash)。下载数据的时候，首先从可信的数据源得到正确的根Hash，就可以用它来校验Hash列表了，然后通过校验后的Hash列表校验数据块。<br><img src="/img/834896-20160527163900397-1043573061.png" alt=""></p>
<h3 id="Merkle-Tree-1"><a href="#Merkle-Tree-1" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h3><p>Merkle Tree可以看做Hash List的泛化（Hash List可以看作一种特殊的Merkle Tree，即树高为2的多叉Merkle Tree）。</p>
<p>在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应地哈希和它对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希就结婚生子，得到了一个”子哈希“。如果最底层的哈希总数是单数，那到最后必然出现一个单身哈希，这种情况就直接对它进行哈希运算，所以也能得到它的子哈希。于是往上推，依然是一样的方式，可以得到数目更少的新一级哈希，最终必然形成一棵倒挂的树，到了树根的这个位置，这一代就剩下一个根哈希了，我们把它叫做 Merkle Root[3]。</p>
<p>在p2p网络下载网络之前，先从可信的源获得文件的Merkle Tree树根。一旦获得了树根，就可以从其他从不可信的源获取Merkle tree。通过可信的树根来检查接受到的Merkle Tree。如果Merkle Tree是损坏的或者虚假的，就从其他源获得另一个Merkle Tree，直到获得一个与可信树根匹配的Merkle Tree。</p>
<p>Merkle Tree和Hash List的主要区别是，可以直接下载并立即验证Merkle Tree的一个分支。因为可以将文件切分成小的数据块，这样如果有一块数据损坏，仅仅重新下载这个数据块就行了。如果文件非常大，那么Merkle tree和Hash list都很到，但是Merkle tree可以一次下载一个分支，然后立即验证这个分支，如果分支验证通过，就可以下载数据了。而Hash list只有下载整个hash list才能验证。<br><img src="/img/834896-20160527163936819-725283544.png" alt=""></p>
<h2 id="Merkle-Tree的特点"><a href="#Merkle-Tree的特点" class="headerlink" title="Merkle Tree的特点"></a>Merkle Tree的特点</h2><p>MT是一种树，大多数是二叉树，也可以多叉树，无论是几叉树，它都具有树结构的所有特点；<br>Merkle Tree的叶子节点的value是数据集合的单元数据或者单元数据HASH。<br>非叶子节点的value是根据它下面所有的叶子节点值，然后按照Hash算法计算而得出的。[4][5]<br>　　<br>通常，加密的hash方法像SHA-2和MD5用来做hash。但如果仅仅防止数据不是蓄意的损坏或篡改，可以改用一些安全性低但效率高的校验和算法，如CRC。</p>
<p>Second Preimage Attack: Merkle tree的树根并不表示树的深度，这可能会导致second-preimage attack，即攻击者创建一个具有相同Merkle树根的虚假文档。一个简单的解决方法在Certificate Transparency中定义：当计算叶节点的hash时，在hash数据前加0x00。当计算内部节点是，在前面加0x01。另外一些实现限制hash tree的根，通过在hash值前面加深度前缀。因此，前缀每一步会减少，只有当到达叶子时前缀依然为正，提取的hash链才被定义为有效。</p>
<h2 id="Merkle-Tree的操作"><a href="#Merkle-Tree的操作" class="headerlink" title="Merkle Tree的操作"></a>Merkle Tree的操作</h2><h3 id="创建Merckle-Tree"><a href="#创建Merckle-Tree" class="headerlink" title="创建Merckle Tree"></a>创建Merckle Tree</h3><p>加入最底层有9个数据块。</p>
<p>step1：（红色线）对数据块做hash运算，Node0i = hash(Data0i), i=1,2,…,9</p>
<p>step2: （橙色线）相邻两个hash块串联，然后做hash运算，Node1((i+1)/2) = hash(Node0i+Node0(i+1)), i=1,3,5,7;对于i=9, Node1((i+1)/2) = hash(Node0i)</p>
<p>step3: （黄色线）重复step2</p>
<p>step4：（绿色线）重复step2</p>
<p>step5：（蓝色线）重复step2，生成Merkle Tree Root<br><img src="/img/834896-20160527164204428-1614047478.png" alt=""></p>
<p>易得，创建Merkle Tree是O(n)复杂度(这里指O(n)次hash运算)，n是数据块的大小。得到Merkle Tree的树高是log(n)+1。</p>
<h3 id="检索数据块"><a href="#检索数据块" class="headerlink" title="检索数据块"></a>检索数据块</h3><p>为了更好理解，我们假设有A和B两台机器，A需要与B相同目录下有8个文件，文件分别是f1 f2 f3 ….f8。这个时候我们就可以通过Merkle Tree来进行快速比较。假设我们在文件创建的时候每个机器都构建了一个Merkle Tree。具体如下图:<br><img src="/img/834896-20160527164248178-1144958521.png" alt=""></p>
<p>从上图可得知，叶子节点node7的value = hash(f1),是f1文件的HASH;而其父亲节点node3的value = hash(v7, v8)，也就是其子节点node7 node8的值得HASH。就是这样表示一个层级运算关系。root节点的value其实是所有叶子节点的value的唯一特征。</p>
<p>假如A上的文件5与B上的不一样。我们怎么通过两个机器的merkle treee信息找到不相同的文件? 这个比较检索过程如下:</p>
<p>Step1. 首先比较v0是否相同,如果不同，检索其孩子node1和node2.</p>
<p>Step2. v1 相同，v2不同。检索node2的孩子node5 node6;</p>
<p>Step3. v5不同，v6相同，检索比较node5的孩子node 11 和node 12</p>
<p>Step4. v11不同，v12相同。node 11为叶子节点，获取其目录信息。</p>
<p>Step5. 检索比较完毕。</p>
<p>以上过程的理论复杂度是Log(N)。过程描述图如下:<br><img src="/img/834896-20160527164334959-1957978022.png" alt=""></p>
<p>从上图可以得知真个过程可以很快的找到对应的不相同的文件。</p>
<h3 id="更新，插入和删除"><a href="#更新，插入和删除" class="headerlink" title="更新，插入和删除"></a>更新，插入和删除</h3><p>虽然网上有很多关于Merkle Tree的资料，但大部分没有涉及Merkle Tree的更新、插入和删除操作，讨论Merkle Tree的检索和遍历的比较多。我也是非常困惑，一种树结构的操作肯定不仅包括查找，也包括更新、插入和删除的啊。后来查到stackexchange上的一个问题，才稍微有点明白，原文见[6]。</p>
<p>对于Merkle Tree数据块的更新操作其实是很简单的，更新完数据块，然后接着更新其到树根路径上的Hash值就可以了，这样不会改变Merkle Tree的结构。但是，插入和删除操作肯定会改变Merkle Tree的结构，如下图，一种插入操作是这样的：<br><img src="/img/834896-20160527164540866-1551004387.png" alt=""></p>
<p>插入数据块0后(考虑数据块的位置)，Merkle Tree的结构是这样的：<br><img src="/img/834896-20160527164609772-233903093.png" alt=""></p>
<p>而[6]中的同学在考虑一种插入的算法，满足下面条件：</p>
<p>re-hashing操作的次数控制在log(n)以内<br>数据块的校验在log(n)+1以内<br>除非原始树的n是偶数，插入数据后的树没有孤儿，并且如果有孤儿，那么孤儿是最后一个数据块<br>数据块的顺序保持一致<br>插入后的Merkle Tree保持平衡<br>然后上面的插入结果就会变成这样：<br><img src="/img/834896-20160527164740491-297832995.png" alt=""></p>
<p>根据[6]中回答者所说，Merkle Tree的插入和删除操作其实是一个工程上的问题，不同问题会有不同的插入方法。如果要确保树是平衡的或者是树高是log(n)的，可以用任何的标准的平衡二叉树的模式，如AVL树，红黑树，伸展树，2-3树等。这些平衡二叉树的更新模式可以在O(lgn)时间内完成插入操作，并且能保证树高是O(lgn)的。那么很容易可以看出更新所有的Merkle Hash可以在O((lgn)2)时间内完成（对于每个节点如要更新从它到树根O(lgn)个节点，而为了满足树高的要求需要更新O(lgn)个节点）。如果仔细分析的话，更新所有的hash实际上可以在O(lgn)时间内完成，因为要改变的所有节点都是相关联的，即他们要不是都在从某个叶节点到树根的一条路径上，或者这种情况相近。</p>
<p>[6]的回答者说实际上Merkle Tree的结构(是否平衡，树高限制多少)在大多数应用中并不重要，而且保持数据块的顺序也在大多数应用中也不需要。因此，可以根据具体应用的情况，设计自己的插入和删除操作。一个通用的Merkle Tree插入删除操作是没有意义的。</p>
<h2 id="Merkle-Tree的应用"><a href="#Merkle-Tree的应用" class="headerlink" title="Merkle Tree的应用"></a>Merkle Tree的应用</h2><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>最初Merkle Tree目的是高效的处理Lamport one-time signatures。 每一个Lamport key只能被用来签名一个消息，但是与Merkle tree结合可以来签名多条Merkle。这种方法成为了一种高效的数字签名框架，即Merkle Signature Scheme。</p>
<h3 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h3><p>在P2P网络中，Merkle Tree用来确保从其他节点接受的数据块没有损坏且没有被替换，甚至检查其他节点不会欺骗或者发布虚假的块。大家所熟悉的BT下载就是采用了P2P技术来让客户端之间进行数据传输，一来可以加快数据下载速度，二来减轻下载服务器的负担。BT即BitTorrent，是一种中心索引式的P2P文件分分析通信协议[7]。</p>
<p>要进下载必须从中心索引服务器获取一个扩展名为torrent的索引文件（即大家所说的种子），torrent文件包含了要共享文件的信息，包括文件名，大小，文件的Hash信息和一个指向Tracker的URL[8]。Torrent文件中的Hash信息是每一块要下载的文件内容的加密摘要，这些摘要也可运行在下载的时候进行验证。大的torrent文件是Web服务器的瓶颈，而且也不能直接被包含在RSS或gossiped around(用流言传播协议进行传播)。一个相关的问题是大数据块的使用，因为为了保持torrent文件的非常小，那么数据块Hash的数量也得很小，这就意味着每个数据块相对较大。大数据块影响节点之间进行交易的效率，因为只有当大数据块全部下载下来并校验通过后，才能与其他节点进行交易。</p>
<p>就解决上面两个问题是用一个简单的Merkle Tree代替Hash List。设计一个层数足够多的满二叉树，叶节点是数据块的Hash，不足的叶节点用0来代替。上层的节点是其对应孩子节点串联的hash。Hash算法和普通torrent一样采用SHA1。其数据传输过程和第一节中描述的类似。<br><img src="/img/834896-20160527164948100-1323551447.png" alt=""></p>
<h3 id="Trusted-Computing"><a href="#Trusted-Computing" class="headerlink" title="Trusted Computing"></a>Trusted Computing</h3><p>可信计算是可信计算组为分布式计算环境中参与节点的计算平台提供端点可信性而提出的。可信计算技术在计算平台的硬件层引入可信平台模块(Trusted Platform，TPM)，实际上为计算平台提供了基于硬件的可信根(Root of trust，RoT)。从可信根出发，使用信任链传递机制，可信计算技术可对本地平台的硬件及软件实施逐层的完整性度量，并将度量结果可靠地保存再TPM的平台配置寄存器(Platform configuration register，PCR)中，此后远程计算平台可通过远程验证机制(Remote Attestation)比对本地PCR中度量结果，从而验证本地计算平台的可信性。可信计算技术让分布式应用的参与节点摆脱了对中心服务器的依赖，而直接通过用户机器上的TPM芯片来建立信任，使得创建扩展性更好、可靠性更高、可用性更强的安全分布式应用成为可能[10]。可信计算技术的核心机制是远程验证(remote attestation),分布式应用的参与结点正是通过远程验证机制来建立互信,从而保障应用的安全。<br><img src="/img/834896-20160527165022756-1215479209.png" alt=""></p>
<p>文献[10]提出了一种基于Merkle Tree的远程验证机制，其核心是完整性度量值哈希树。</p>
<p>首先,RAMT 在内核中维护的不再是一张完整性度量值列表(ML),而是一棵完整性度量值哈希树(integrity measurement hash tree,简称IMHT).其中,IMHT的叶子结点存储的数据对象是待验证计算平台上被度量的各种程序的完整性哈希值,而其内部结点则依据Merkle 哈希树的构建规则由子结点的连接的哈希值动态生成。</p>
<p>其次,为了维护IMHT 叶子结点的完整性,RAMT 需要使用TPM 中的一段存储器来保存IMHT 可信根哈希的值。</p>
<p>再次,RAMT 的完整性验证过程基于认证路径(authentication path)实施.认证路径是指IMHT 上从待验证叶子结点到根哈希的路径。</p>
<h3 id="IPFS"><a href="#IPFS" class="headerlink" title="IPFS"></a>IPFS</h3><p>IPFS(InterPlanetary File System)是很多NB的互联网技术的综合体，如DHT( Distributed HashTable，分布式哈希表)，Git版本控制系统，Bittorrent等。它创建了一个P2P的集群，这个集群允许IPFS对象的交换。全部的IPFS对象形成了一个被称作Merkle DAG的加密认证数据结构。</p>
<p>IPFS对象是一个含有两个域的数据结构:</p>
<ul>
<li>Data – 非结构的二进制数据，大小小于256kB</li>
<li>Links – 一个Link数据结构的数组。IPFS对象通过他们链接到其他对象</li>
</ul>
<p>Link数据结构包含三个域：</p>
<ul>
<li>Name – Link的名字</li>
<li>Hash – Link链接到对象的Hash</li>
<li>Size – Link链接到对象的累积大小，包括它的Links</li>
</ul>
<p><img src="/img/834896-20160527165254725-425200618.png" alt=""></p>
<p>通过Name和Links，IPFS的集合组成了一个Merkle DAG（有向无环图）。<br><img src="/img/834896-20160527165314334-321253475.png" alt=""></p>
<p>对于小文件（&lt;256kB），是一个没有Links的IPFS对象。<br><img src="/img/834896-20160527165335522-116819309.png" alt=""></p>
<p>对于大文件，被表示为一个文件块(&lt;256kB)的集合。只有拥有最小的Data的对象来代表这个大文件。这个对象的Links的名字都为空字符串。<br><img src="/img/834896-20160527165357725-656455407.png" alt=""><br><img src="/img/834896-20160527165407725-1225343216.png" alt=""></p>
<p>目录结构：目录是没有数据的IPFS对象，它的链接指向其包含的文件和目录。<br><img src="/img/834896-20160527165432803-1065863465.png" alt=""></p>
<p>IPFS可以表示Git使用的数据结构，Git commit object。Commit Object主要的特点是他有一个或多个名为’parent0’和‘parent1’等的链接（这些链接指向前一个版本），以及一个名为object的对象(在Git中成为tree)指向引用这个commit的文件系统结构。<br><img src="/img/834896-20160527165455647-337696972.png" alt=""></p>
<h3 id="BitCoin和Ethereum"><a href="#BitCoin和Ethereum" class="headerlink" title="BitCoin和Ethereum"></a>BitCoin和Ethereum</h3><p>Merkle Proof最早的应用是Bitcoin，它是由中本聪在2009年描述并创建的。Bitcoin的Blockchain利用Merkle proofs来存储每个区块的交易。<br><img src="/img/834896-20160527165613991-323413263.png" alt=""></p>
<p>而这样做的好处，也就是中本聪描述到的“简化支付验证”（Simplified Payment Verification，SPV）的概念:一个“轻客户端”（light client）可以仅下载链的区块头即每个区块中的80byte的数据块，仅包含五个元素，而不是下载每一笔交易以及每一个区块：</p>
<ul>
<li>上一区块头的哈希值</li>
<li>时间戳</li>
<li>挖矿难度值</li>
<li>工作量证明随机数（nonce）</li>
<li>包含该区块交易的Merkle Tree的根哈希</li>
</ul>
<p>如果客户端想要确认一个交易的状态，它只需简单的发起一个Merkle proof请求，这个请求显示出这个特定的交易在Merkle trees的一个之中，而且这个Merkle Tree的树根在主链的一个区块头中。</p>
<p>但是Bitcoin的轻客户端有它的局限。一个局限是，尽管它可以证明包含的交易，但是它不能进行涉及当前状态的证明（如数字资产的持有，名称注册，金融合约的状态等）。</p>
<p>Bitcoin如何查询你当前有多少币？一个比特币轻客户端，可以使用一种协议，它涉及查询多个节点，并相信其中至少会有一个节点会通知你，关于你的地址中任何特定的交易支出，而这可以让你实现更多的应用。但对于其他更为复杂的应用而言，这些远远是不够的。一笔交易影响的确切性质（precise nature），可以取决于此前的几笔交易，而这些交易本身则依赖于更为前面的交易，所以最终你可以验证整个链上的每一笔交易。为了解决这个问题，Ethereum的Merkle Tree的概念，会更进一步。</p>
<h3 id="Ethereum的Merkle-Proof"><a href="#Ethereum的Merkle-Proof" class="headerlink" title="Ethereum的Merkle Proof"></a>Ethereum的Merkle Proof</h3><p>每个以太坊区块头不是包括一个Merkle树，而是为三种对象设计的三棵树：</p>
<p>交易Transaction<br>收据Receipts(本质上是显示每个交易影响的多块数据)<br>状态State</p>
<p><img src="/img/834896-20160527165745163-1727084736.png" alt=""></p>
<p>这使得一个非常先进的轻客户端协议成为了可能，它允许轻客户端轻松地进行并核实以下类型的查询答案：</p>
<p>这笔交易被包含在特定的区块中了么？<br>告诉我这个地址在过去30天中，发出X类型事件的所有实例（例如，一个众筹合约完成了它的目标）<br>目前我的账户余额是多少？<br>这个账户是否存在？<br>假如在这个合约中运行这笔交易，它的输出会是什么？</p>
<p>第一种是由交易树（transaction tree）来处理的；第三和第四种则是由状态树（state tree）负责处理，第二种则由收据树（receipt tree）处理。计算前四个查询任务是相当简单的。服务器简单地找到对象，获取Merkle分支，并通过分支来回复轻客户端。</p>
<p>第五种查询任务同样也是由状态树处理，但它的计算方式会比较复杂。这里，我们需要构建一个Merkle状态转变证明（Merkle state transition proof）。从本质上来讲，这样的证明也就是在说“如果你在根S的状态树上运行交易T，其结果状态树将是根为S’，log为L，输出为O” （“输出”作为存在于以太坊的一种概念，因为每一笔交易都是一个函数调用；它在理论上并不是必要的）。</p>
<p>为了推断这个证明，服务器在本地创建了一个假的区块，将状态设为 S，并在请求这笔交易时假装是一个轻客户端。也就是说，如果请求这笔交易的过程，需要客户端确定一个账户的余额，这个轻客户端(由服务器模拟的)会发出一个余额查询请求。如果需要轻客户端在特点某个合约的存储中查询特定的条目，这个轻客户端就会发出这样的请求。也就是说服务器(通过模拟一个轻客户端)正确回应所有自己的请求，但服务器也会跟踪它所有发回的数据。</p>
<p>然后，服务器从上述的这些请求中把数据合并并把数据以一个证明的方式发送给客户端。</p>
<p>然后，客户端会进行相同的步骤，但会将服务器提供的证明作为一个数据库来使用。如果客户端进行步骤的结果和服务器提供的是一样的话，客户端就接受这个证明。<br><img src="/img/834896-20160527165840209-1558796638.png" alt=""></p>
<h3 id="MPT-Merkle-Patricia-Trees"><a href="#MPT-Merkle-Patricia-Trees" class="headerlink" title="MPT(Merkle Patricia Trees)"></a>MPT(Merkle Patricia Trees)</h3><p>前面我们提到，最为简单的一种Merkle Tree大多数情况下都是一棵二叉树。然而，Ethereum所使用的Merkle Tree则更为复杂，我们称之为“梅克尔.帕特里夏树”（Merkle Patricia tree）。</p>
<p>对于验证属于list格式（本质上来讲，它就是一系列前后相连的数据块）的信息而言，二叉Merkle Tree是非常好的数据结构。对于交易树来说，它们也同样是不错的，因为一旦树已经建立，花多少时间来编辑这棵树并不重要，树一旦建立了，它就会永远存在并且不会改变。</p>
<p>但是，对于状态树，情况会更复杂些。以太坊中的状态树基本上包含了一个键值映射，其中的键是地址，而值包括账户的声明、余额、随机数nounce、代码以及每一个账户的存储（其中存储本身就是一颗树）。例如，摩登测试网络（the Morden testnet ）的创始状态如下所示：<br><img src="/img/834896-20160527165928678-58958503.png" alt=""></p>
<p>然而，不同于交易历史记录，状态树需要经常地进行更新：账户余额和账户的随机数nonce经常会更变，更重要的是，新的账户会频繁地插入，存储的键（ key）也会经常被插入以及删除。我们需要这样的数据结构，它能在一次插入、更新、删除操作后快速计算到树根，而不需要重新计算整个树的Hash。这种数据结构同样得包括两个非常好的第二特征：</p>
<p>树的深度是有限制的，即使考虑攻击者会故意地制造一些交易，使得这颗树尽可能地深。不然，攻击者可以通过操纵树的深度，执行拒绝服务攻击（DOS attack），使得更新变得极其缓慢。<br>树的根只取决于数据，和其中的更新顺序无关。换个顺序进行更新，甚至重新从头计算树，并不会改变根。<br>　　MPT是最接近同时满足上面的性质的的数据结构。MPT的工作原理的最简单的解释是，值通过键来存储，键被编码到搜索树必须要经过的路径中。每个节点有16个孩子，因此路径又16进制的编码决定：例如，键‘dog’的16进制编码是6 4 6 15 6 7，所以从root开始到第六个分支，然后到第四个，再到第六个，再到第十五个，这样依次进行到达树的叶子。</p>
<p>在实践中，当树稀少时也会有一些额外的优化，我们会使过程更为有效，但这是基本的原则。</p>
<h1 id="Leetcode二分查找法小结"><a href="#Leetcode二分查找法小结" class="headerlink" title="Leetcode二分查找法小结"></a>Leetcode二分查找法小结</h1><p>二分查找法作为一种常见的查找方法，将原本是线性时间提升到了对数时间范围，大大缩短了搜索时间，具有很大的应用场景，而在 LeetCode 中，要运用二分搜索法来解的题目也有很多，但是实际上二分查找法的查找目标有很多种，而且在细节写法也有一些变化。之前有网友留言希望博主能针对二分查找法的具体写法做个总结，博主由于之前一直很忙，一直拖着没写，为了树立博主言出必行的正面形象，不能再无限制的拖下去了，那么今天就来做个了断吧，总结写起来~ (以下内容均为博主自己的总结，并不权威，权当参考，欢迎各位大神们留言讨论指正)</p>
<p>根据查找的目标不同，博主将二分查找法主要分为以下五类：</p>
<h2 id="第一类：-需查找和目标值完全相等的数"><a href="#第一类：-需查找和目标值完全相等的数" class="headerlink" title="第一类： 需查找和目标值完全相等的数"></a>第一类： 需查找和目标值完全相等的数</h2><p>这是最简单的一类，也是我们最开始学二分查找法需要解决的问题，比如我们有数组 [2, 4, 5, 6, 9]，target = 6，那么我们可以写出二分查找法的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int find(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int left = 0, right = nums.size();</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] == target) return mid;</span><br><span class="line">        else if (nums[mid] &lt; target) left = mid + 1;</span><br><span class="line">        else right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会返回3，也就是 target 的在数组中的位置。注意二分查找法的写法并不唯一，主要可以变动地方有四处： </p>
<ul>
<li>第一处是 right 的初始化，可以写成 nums.size() 或者 nums.size() - 1。</li>
<li>第二处是 left 和 right 的关系，可以写成 left &lt; right 或者 left &lt;= right。</li>
<li>第三处是更新 right 的赋值，可以写成 right = mid 或者 right = mid - 1。</li>
<li>第四处是最后返回值，可以返回 left，right，或 right - 1。</li>
</ul>
<p>但是这些不同的写法并不能随机的组合，像博主的那种写法，若 right 初始化为了 nums.size()，那么就必须用 left &lt; right，而最后的 right 的赋值必须用 right = mid。但是如果我们 right 初始化为 nums.size() - 1，那么就必须用 left &lt;= right，并且right的赋值要写成 right = mid - 1，不然就会出错。所以博主的建议是选择一套自己喜欢的写法，并且记住，实在不行就带简单的例子来一步一步执行，确定正确的写法也行。</p>
<p>第一类应用实例： Intersection of Two Arrays</p>
<h2 id="第二类：-查找第一个不小于目标值的数，可变形为查找最后一个小于目标值的数"><a href="#第二类：-查找第一个不小于目标值的数，可变形为查找最后一个小于目标值的数" class="headerlink" title="第二类： 查找第一个不小于目标值的数，可变形为查找最后一个小于目标值的数"></a>第二类： 查找第一个不小于目标值的数，可变形为查找最后一个小于目标值的数</h2><p>这是比较常见的一类，因为我们要查找的目标值不一定会在数组中出现，也有可能是跟目标值相等的数在数组中并不唯一，而是有多个，那么这种情况下 nums[mid] == target 这条判断语句就没有必要存在。比如在数组 [2, 4, 5, 6, 9] 中查找数字3，就会返回数字4的位置；在数组 [0, 1, 1, 1, 1] 中查找数字1，就会返回第一个数字1的位置。我们可以使用如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int find(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int left = 0, right = nums.size();</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] &lt; target) left = mid + 1;</span><br><span class="line">        else right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们需要返回的位置就是 right 指针指向的地方。在 C++ 的 STL 中有专门的查找第一个不小于目标值的数的函数 lower_bound，在博主的解法中也会时不时的用到这个函数。但是如果面试的时候人家不让使用内置函数，那么我们只能老老实实写上面这段二分查找的函数。</p>
<p>这一类可以轻松的变形为查找最后一个小于目标值的数，怎么变呢。我们已经找到了第一个不小于目标值的数，那么再往前退一位，返回 right - 1，就是最后一个小于目标值的数。</p>
<p>第二类应用实例：Heaters， Arranging Coins， Valid Perfect Square，Max Sum of Rectangle No Larger Than K，Russian Doll Envelopes</p>
<p>第二类变形应用：Valid Triangle Number</p>
<h2 id="第三类：-查找第一个大于目标值的数，可变形为查找最后一个不大于目标值的数"><a href="#第三类：-查找第一个大于目标值的数，可变形为查找最后一个不大于目标值的数" class="headerlink" title="第三类： 查找第一个大于目标值的数，可变形为查找最后一个不大于目标值的数"></a>第三类： 查找第一个大于目标值的数，可变形为查找最后一个不大于目标值的数</h2><p>这一类也比较常见，尤其是查找第一个大于目标值的数，在 C++ 的 STL 也有专门的函数 upper_bound，这里跟上面的那种情况的写法上很相似，只需要添加一个等号，将之前的 nums[mid] &lt; target 变成 nums[mid] &lt;= target，就这一个小小的变化，其实直接就改变了搜索的方向，使得在数组中有很多跟目标值相同的数字存在的情况下，返回最后一个相同的数字的下一个位置。比如在数组 [2, 4, 5, 6, 9] 中查找数字3，还是返回数字4的位置，这跟上面那查找方式返回的结果相同，因为数字4在此数组中既是第一个不小于目标值3的数，也是第一个大于目标值3的数，所以 make sense；在数组 [0, 1, 1, 1, 1] 中查找数字1，就会返回坐标5，通过对比返回的坐标和数组的长度，我们就知道是否存在这样一个大于目标值的数。参见下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int find(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int left = 0, right = nums.size();</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] &lt;= target) left = mid + 1;</span><br><span class="line">        else right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一类可以轻松的变形为查找最后一个不大于目标值的数，怎么变呢。我们已经找到了第一个大于目标值的数，那么再往前退一位，返回 right - 1，就是最后一个不大于目标值的数。比如在数组 [0, 1, 1, 1, 1] 中查找数字1，就会返回最后一个数字1的位置4，这在有些情况下是需要这么做的。</p>
<p>第三类应用实例：Kth Smallest Element in a Sorted Matrix</p>
<p>第三类变形应用示例： Sqrt(x)</p>
<h2 id="第四类：-用子函数当作判断关系（通常由-mid-计算得出）"><a href="#第四类：-用子函数当作判断关系（通常由-mid-计算得出）" class="headerlink" title="第四类： 用子函数当作判断关系（通常由 mid 计算得出）"></a>第四类： 用子函数当作判断关系（通常由 mid 计算得出）</h2><p>这是最令博主头疼的一类，而且通常情况下都很难。因为这里在二分查找法重要的比较大小的地方使用到了子函数，并不是之前三类中简单的数字大小的比较，比如 Split Array Largest Sum 那道题中的解法一，就是根据是否能分割数组来确定下一步搜索的范围。类似的还有 Guess Number Higher or Lower 这道题，是根据给定函数 guess 的返回值情况来确定搜索的范围。对于这类题目，博主也很无奈，遇到了只能自求多福了。</p>
<p>第四类应用实例：Split Array Largest Sum， Guess Number Higher or Lower，Find K Closest Elements，Find K-th Smallest Pair Distance，Kth Smallest Number in Multiplication Table，Maximum Average Subarray II，Minimize Max Distance to Gas Station，Swim in Rising Water，Koko Eating Bananas，Nth Magical Number</p>
<h2 id="第五类：-其他（通常-target-值不固定）"><a href="#第五类：-其他（通常-target-值不固定）" class="headerlink" title="第五类： 其他（通常 target 值不固定）"></a>第五类： 其他（通常 target 值不固定）</h2><p>有些题目不属于上述的四类，但是还是需要用到二分搜索法，比如这道 Find Peak Element，求的是数组的局部峰值。由于是求的峰值，需要跟相邻的数字比较，那么 target 就不是一个固定的值，而且这道题的一定要注意的是 right 的初始化，一定要是 nums.size() - 1，这是由于算出了 mid 后，nums[mid] 要和 nums[mid+1] 比较，如果 right 初始化为 nums.size() 的话，mid+1 可能会越界，从而不能找到正确的值，同时 while 循环的终止条件必须是 left &lt; right，不能有等号。</p>
<p>类似的还有一道 H-Index II，这道题的 target 也不是一个固定值，而是 len-mid，这就很意思了，跟上面的 nums[mid+1] 有异曲同工之妙，target 值都随着 mid 值的变化而变化，这里的right的初始化，一定要是 nums.size() - 1，而 while 循环的终止条件必须是 left &lt;= right，这里又必须要有等号，是不是很头大 -.-!!!</p>
<p>其实仔细分析的话，可以发现其实这跟第四类还是比较相似，相似点是都很难 -.-!!!，第四类中虽然是用子函数来判断关系，但大部分时候 mid 也会作为一个参数带入子函数进行计算，这样实际上最终算出的值还是受 mid 的影响，但是 right 却可以初始化为数组长度，循环条件也可以不带等号，大家可以对比区别一下～</p>
<h1 id="Top-k问题的一些算法"><a href="#Top-k问题的一些算法" class="headerlink" title="Top-k问题的一些算法"></a>Top-k问题的一些算法</h1><p>Top K问题是面试时手写代码的常考题，某些场景下的解法与堆排和快排的关系紧密，所以把它放在堆排后面讲。</p>
<p>言归正传，笔者见过关于Top K问题最全的分类总结是在这里（包括海量数据的处理），个人将这些题分成了两类：一类是容易写代码实现的；另一类侧重考察思路的。毫无疑问，后一种比较简单，你只要记住它的应用场景、解决思路，并能在面试的过程中将它顺利地表达出来，便能以不变应万变。前一种，需要手写代码，就必须要掌握一定的技巧，常见的解法有两种，就是前面说过的堆排和快排的变形。</p>
<p>本文主要来看看方便用代码解决的问题。</p>
<h2 id="堆排解法"><a href="#堆排解法" class="headerlink" title="堆排解法"></a>堆排解法</h2><p>用堆排来解决Top K的思路很直接。</p>
<p>前面已经说过，堆排利用的大（小）顶堆所有子节点元素都比父节点小（大）的性质来实现的，这里故技重施：既然一个大顶堆的顶是最大的元素，那我们要找最小的K个元素，是不是可以先建立一个包含K个元素的堆，然后遍历集合，如果集合的元素比堆顶元素小（说明它目前应该在K个最小之列），那就用该元素来替换堆顶元素，同时维护该堆的性质，那在遍历结束的时候，堆中包含的K个元素是不是就是我们要找的最小的K个元素？</p>
<p>实现：<br>在堆排的基础上，稍作了修改，buildHeap和heapify函数都是一样的实现，不难理解。</p>
<p>速记口诀：最小的K个用最大堆，最大的K个用最小堆。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class TopK &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        int[] a = &#123; 1, 17, 3, 4, 5, 6, 7, 16, 9, 10, 11, 12, 13, 14, 15, 8 &#125;;</span><br><span class="line">        int[] b = topK(a, 4);</span><br><span class="line">        for (int i = 0; i &lt; b.length; i++) &#123;</span><br><span class="line">            System.out.print(b[i] + &quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void heapify(int[] array, int index, int length) &#123;</span><br><span class="line">        int left = index * 2 + 1;</span><br><span class="line">        int right = index * 2 + 2;</span><br><span class="line">        int largest = index;</span><br><span class="line">        if (left &lt; length &amp;&amp; array[left] &gt; array[index]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        if (right &lt; length &amp;&amp; array[right] &gt; array[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index != largest) &#123;</span><br><span class="line">            swap(array, largest, index);</span><br><span class="line">            heapify(array, largest, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void swap(int[] array, int a, int b) &#123;</span><br><span class="line">        int temp = array[a];</span><br><span class="line">        array[a] = array[b];</span><br><span class="line">        array[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void buildHeap(int[] array) &#123;</span><br><span class="line">        int length = array.length;</span><br><span class="line">        for (int i = length / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            heapify(array, i, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setTop(int[] array, int top) &#123;</span><br><span class="line">        array[0] = top;</span><br><span class="line">        heapify(array, 0, array.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int[] topK(int[] array, int k) &#123;</span><br><span class="line">        int[] top = new int[k];</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            top[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        //先建堆，然后依次比较剩余元素与堆顶元素的大小，比堆顶小的， 说明它应该在堆中出现，则用它来替换掉堆顶元素，然后沉降。</span><br><span class="line">        buildHeap(top);</span><br><span class="line">        for (int j = k; j &lt; array.length; j++) &#123;</span><br><span class="line">            int temp = top[0];</span><br><span class="line">            if (array[j] &lt; temp) &#123;</span><br><span class="line">                setTop(top, array[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>时间复杂度<br><code>n*logK</code><br>速记：堆排的时间复杂度是<code>n*logn</code>，这里相当于只对前Top K个元素建堆排序，想法不一定对，但一定有助于记忆。</p>
<p>适用场景<br>实现的过程中，我们先用前K个数建立了一个堆，然后遍历数组来维护这个堆。这种做法带来了三个好处：（1）不会改变数据的输入顺序（按顺序读的）；（2）不会占用太多的内存空间（事实上，一次只读入一个数，内存只要求能容纳前K个数即可）；（3）由于（2），决定了它特别适合处理海量数据。</p>
<p>这三点，也决定了它最优的适用场景。</p>
<h2 id="快排解法"><a href="#快排解法" class="headerlink" title="快排解法"></a>快排解法</h2><p>用快排的思想来解Top K问题，必然要运用到”分治”。</p>
<p>与快排相比，两者唯一的不同是在对”分治”结果的使用上。我们知道，分治函数会返回一个position，在position左边的数都比第position个数小，在position右边的数都比第position大。我们不妨不断调用分治函数，直到它输出的position = K-1，此时position前面的K个数（0到K-1）就是要找的前K个数。</p>
<p>实现：<br>“分治”还是原来的那个分治，关键是getTopK的逻辑，务必要结合注释理解透彻，自动动手写写。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class TopK &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        int[] array = &#123; 9, 3, 1, 10, 5, 7, 6, 2, 8, 0 &#125;;</span><br><span class="line">        getTopK(array, 4);</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + &quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 分治</span><br><span class="line">    public static int partition(int[] array, int low, int high) &#123;</span><br><span class="line">        if (array != null &amp;&amp; low &lt; high) &#123;</span><br><span class="line">            int flag = array[low];</span><br><span class="line">            while (low &lt; high) &#123;</span><br><span class="line">                while (low &lt; high &amp;&amp; array[high] &gt;= flag) &#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">                array[low] = array[high];</span><br><span class="line">                while (low &lt; high &amp;&amp; array[low] &lt;= flag) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;</span><br><span class="line">                array[high] = array[low];</span><br><span class="line">            &#125;</span><br><span class="line">            array[low] = flag;</span><br><span class="line">            return low;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void getTopK(int[] array, int k) &#123;</span><br><span class="line">        if (array != null &amp;&amp; array.length &gt; 0) &#123;</span><br><span class="line">            int low = 0;</span><br><span class="line">            int high = array.length - 1;</span><br><span class="line">            int index = partition(array, low, high);</span><br><span class="line">            //不断调整分治的位置，直到position = k-1</span><br><span class="line">            while (index != k - 1) &#123;</span><br><span class="line">                //大了，往前调整</span><br><span class="line">                if (index &gt; k - 1) &#123;</span><br><span class="line">                    high = index - 1;</span><br><span class="line">                    index = partition(array, low, high);</span><br><span class="line">                &#125;</span><br><span class="line">                //小了，往后调整</span><br><span class="line">                if (index &lt; k - 1) &#123;</span><br><span class="line">                    low = index + 1;</span><br><span class="line">                    index = partition(array, low, high);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>速记：记住就行，基于partition函数的时间复杂度比较难证明，从来没考过。</p>
<p>适用场景<br>对照着堆排的解法来看，partition函数会不断地交换元素的位置，所以它肯定会改变数据输入的顺序；既然要交换元素的位置，那么所有元素必须要读到内存空间中，所以它会占用比较大的空间，至少能容纳整个数组；数据越多，占用的空间必然越大，海量数据处理起来相对吃力。</p>
<p>但是，它的时间复杂度很低，意味着数据量不大时，效率极高。</p>
<h1 id="多种不同的排序方法"><a href="#多种不同的排序方法" class="headerlink" title="多种不同的排序方法"></a>多种不同的排序方法</h1><h2 id="稳定排序和不稳定排序"><a href="#稳定排序和不稳定排序" class="headerlink" title="稳定排序和不稳定排序"></a>稳定排序和不稳定排序</h2><p>首先，排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</p>
<p>其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，对基于比较的排序算法而言，元素交换的次数可能会少一些（个人感觉，没有证实）。</p>
<p>回到主题，现在分析一下常见的排序算法的稳定性，每个都给出简单的理由。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<p>第一次从R[0]~R[n-1]中选取最小值，与R[0]交换，第二次从R[1]~R[n-1]中选取最小值，与R[1]交换，….，第i次从R[i-1]~R[n-1]中选取最小值，与R[i-1]交换，…..，第n-1次从R[n-2]~R[n-1]中选取最小值，与R[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。因此它的时间复杂度固定为O(n^2)</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<p>算法分析：</p>
<ol>
<li>从序列第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，设为待插入元素，在已经排序的元素序列中从后向前扫描，如果该元素（已排序）大于待插入元素，将该元素移到下一位置。</li>
<li>重复步骤2，直到找到已排序的元素小于或者等于待排序元素的位置，插入元素</li>
<li>重复2，3步骤，完成排序。</li>
</ol>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序有两个方向，左边的i下标一直往右走，当<code>a[i] &lt;= a[center_index]</code>，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当<code>a[j] &gt; a[center_index]</code>。如果i和j都走不动了，<code>i &lt;= j</code>，交换<code>a[i]</code>和<code>a[j]</code>，重复上面的过程，直到<code>i &gt; j</code>。 交换<code>a[j]</code>和<code>a[center_index]</code>，完成一趟快速排序。在中枢元素和<code>a[j]</code>交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和<code>a[j]</code>交换的时刻。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p>
<p>二路归并排序主旨是“分解”与“归并”</p>
<ul>
<li>分解：　　<ul>
<li>将一个数组分成两个数组，分别对两个数组进行排序。</li>
<li>循环第一步，直到划分出来的“小数组”只包含一个元素，只有一个元素的数组默认为已经排好序。</li>
</ul>
</li>
<li>归并：<ul>
<li>将两个有序的数组合并到一个大的数组中。</li>
<li>从最小的只包含一个元素的数组开始两两合并。此时，合并好的数组也是有序的。</li>
</ul>
</li>
</ul>
<h3 id="希尔排序-shell"><a href="#希尔排序-shell" class="headerlink" title="希尔排序(shell)"></a>希尔排序(shell)</h3><p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>我们知道堆的结构是节点i的孩子为<code>2 * i</code>和<code>2 * i + 1</code>节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， … 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p>
<p>综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法<br><img src="/img/20210421222000.gif" alt=""></p>
<h2 id="100万个32位整数，如何最快找到中位数。能保证每个数是唯一的，如何实现O-N-算法？"><a href="#100万个32位整数，如何最快找到中位数。能保证每个数是唯一的，如何实现O-N-算法？" class="headerlink" title="100万个32位整数，如何最快找到中位数。能保证每个数是唯一的，如何实现O(N)算法？"></a>100万个32位整数，如何最快找到中位数。能保证每个数是唯一的，如何实现O(N)算法？</h2><ol>
<li>内存足够时：快排</li>
<li>内存不足时：分桶法：化大为小，把所有数划分到各个小区间，把每个数映射到对应的区间里，对每个区间中数的个数进行计数，数一遍各个区间，看看中位数落在哪个区间，若够小，使用基于内存的算法，否则 继续划分</li>
</ol>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="数据背景"><a href="#数据背景" class="headerlink" title="数据背景"></a>数据背景</h3><p>在基数排序中，我们不能再只用一位数的序列来列举示例了。一位数的序列对基数排序来说就是一个计数排序。<br>这里我们列举无序序列 T = [ 2314, 5428, 373, 2222, 17 ]</p>
<h3 id="排序原理"><a href="#排序原理" class="headerlink" title="排序原理"></a>排序原理</h3><p>上面说到基数排序不需要进行元素的比较与交换。如果你有一些算法的功底，或者丰富的项目经验，我想你可能已经想到了这可能类似于一些“打表”或是哈希的做法。而计数排序则是打表或是哈希思想最简单的实现。</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的核心思想是，构建一个足够大的数组 hashArray[]，数组大小需要保证能够把所有元素都包含在这个数组上 。<br>假设我们有无序序列 T = [ 2314, 5428, 373, 2222, 17 ]<br>首先初始化数组 hashArray[] 为一个全零数组。当然，在 Java 里，这一步就不需要了，因为默认就是零了。<br>在对序列 T 进行排序时，只要依次读取序列 T 中的元素，并修改数组 hashArray[] 中把元素值对应位置上的值即可。这一句有一些绕口。打个比方，我们要把 T[0] 映射到 hashArray[] 中，就是 hashArray[T[0]] = 1. 也就是 hashArray[2314] = 1. 如果序列 T 中有两个相同元素，那么在 hashArray 的相应位置上的值就是 2。<br>下图是计数排序的原理图：<br>（假设有无序序列：[ 5, 8, 9, 1, 4, 2, 9, 3, 7, 1, 8, 6, 2, 3, 4, 0, 8 ]）<br><img src="/img/20160616230144072" alt=""></p>
<h3 id="基数排序原理图"><a href="#基数排序原理图" class="headerlink" title="基数排序原理图"></a>基数排序原理图</h3><p>上面的计数排序只是一个引导，好让你可以循序渐进地了解基数排序。<br><img src="/img/20160616230403191" alt=""></p>
<p>上面这幅图，或许你已经在其他的博客里见到过。这是一个很好的引导跟说明。在基数排序里，我们需要一个很大的二维数组，二维数组的大小是 （10 * n）。10 代表的是我们每个元素的每一位都有 10 种可能，也就是 10 进制数。在上图中，我们是以每个数的个位来代表这个数，于是，5428 就被填充到了第 8 个桶中了。下次再进行填充的时候，就是以十位进行填充，比如 5428 在此时，就会选择以 2 来代表它。<br><img src="/img/20160616230636486" alt=""></p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>在算法的原理中，我们是以一张二维数组的表来存储这些无序的元素。使用二维数组有一个很明显的不足就是二维数组太过稀疏。数组的利用率为 10%。<br>在寻求优化的路上，我们想到一种可以压缩空间的方法，且时间复杂度并没有偏离得太厉害。那就是设计了两个辅助数组，一个是 count[]，一个是 bucket[]。count 用于记录在某个桶中的最后一个元素的下标，然后再把原数组中的元素计算一下它应该属于哪个“桶”，并修改相应位置的 count 值。直到最大数的最高位也被添加到桶中，或者说，当所有的元素都被被在第 0 个桶中，基数排序就结束了。<br>优化后的原理图如下：<br><img src="/img/20160616230836459" alt=""></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.algorithm.array.sort.interf.Sortable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 基数排序/桶排序</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * 2016年1月19日</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author &lt;a href=&quot;http://weibo.com/u/5131020927&quot;&gt;Q-WHai&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * @see &lt;a href=&quot;http://blog.csdn.net/lemon_tree12138&quot;&gt;http://blog.csdn.net/lemon_tree12138&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * @version 0.1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> implements Sortable &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] <span class="built_in">sort</span>(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> maxLength = <span class="built_in">maxLength</span>(array);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sortCore</span>(array, <span class="number">0</span>, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] <span class="built_in">sortCore</span>(<span class="type">int</span>[] array, <span class="type">int</span> digit, <span class="type">int</span> maxLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digit &gt;= maxLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> radix = <span class="number">10</span>; <span class="comment">// 基数</span></span><br><span class="line">        <span class="type">int</span> arrayLength = array.length;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="type">int</span>[radix];</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="type">int</span>[arrayLength];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计将数组中的数字分配到桶中后，各个桶中的数字个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrayLength; i++) &#123;</span><br><span class="line">            count[<span class="built_in">getDigit</span>(array[i], digit)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将各个桶中的数字个数，转化成各个桶中最后一个数字的下标索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; radix; i++) &#123;</span><br><span class="line">            count[i] = count[i] + count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将原数组中的数字分配给辅助数组 bucket</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = arrayLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> number = array[i];</span><br><span class="line">            <span class="type">int</span> d = <span class="built_in">getDigit</span>(number, digit);</span><br><span class="line">            bucket[count[d] - <span class="number">1</span>] = number;</span><br><span class="line">            count[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sortCore</span>(bucket, digit + <span class="number">1</span>, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 一个数组中最大数字的位数</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param array</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">maxLength</span><span class="params">(<span class="type">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> arrayLength = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrayLength; i++) &#123;</span><br><span class="line">            <span class="type">int</span> currentLength = <span class="built_in">length</span>(array[i]);</span><br><span class="line">            <span class="keyword">if</span> (maxLength &lt; currentLength) &#123;</span><br><span class="line">                maxLength = currentLength;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 计算一个数字共有多少位</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param number</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">length</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.<span class="built_in">valueOf</span>(number).<span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取 x 这个数的 d 位数上的数字</span></span><br><span class="line"><span class="comment">     * 比如获取 123 的 0 位数,结果返回 3</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param x</span></span><br><span class="line"><span class="comment">     * @param d</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">getDigit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>, <span class="number">10000000</span>, <span class="number">100000000</span>, <span class="number">1000000000</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> ((x / a[d]) % <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基数排序过程图"><a href="#基数排序过程图" class="headerlink" title="基数排序过程图"></a>基数排序过程图</h3><p>如果我们的无序是 T = [ 2314, 5428, 373, 2222, 17 ]，那么其排序的过程就如下两幅所示。<br>基数排序过程图-1<br><img src="/img/20160616230950318" alt=""><br>基数排序过程图-2<br><img src="/img/20160616231008959" alt=""></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="定义和前置条件"><a href="#定义和前置条件" class="headerlink" title="定义和前置条件"></a>定义和前置条件</h3><p>定义：将有向图中的顶点以线性方式进行排序。即对于任何连接自顶点u到顶点v的有向边uv，在最后的排序结果中，顶点u总是在顶点v的前面。</p>
<p>如果这个概念还略显抽象的话，那么不妨考虑一个非常非常经典的例子——选课。我想任何看过数据结构相关书籍的同学都知道它吧。假设我非常想学习一门机器学习的课程，但是在修这么课程之前，我们必须要学习一些基础课程，比如计算机科学概论，C语言程序设计，数据结构，算法等等。那么这个制定选修课程顺序的过程，实际上就是一个拓扑排序的过程，每门课程相当于有向图中的一个顶点，而连接顶点之间的有向边就是课程学习的先后关系。只不过这个过程不是那么复杂，从而很自然的在我们的大脑中完成了。将这个过程以算法的形式描述出来的结果，就是拓扑排序。</p>
<p>那么是不是所有的有向图都能够被拓扑排序呢？显然不是。继续考虑上面的例子，如果告诉你在选修计算机科学概论这门课之前需要你先学习机器学习，你是不是会被弄糊涂？在这种情况下，就无法进行拓扑排序，因为它中间存在互相依赖的关系，从而无法确定谁先谁后。在有向图中，这种情况被描述为存在环路。因此，一个有向图能被拓扑排序的充要条件就是它是一个有向无环图(DAG：Directed Acyclic Graph)。</p>
<h3 id="偏序-全序关系"><a href="#偏序-全序关系" class="headerlink" title="偏序/全序关系"></a>偏序/全序关系</h3><p>偏序和全序实际上是离散数学中的概念。这里不打算说太多形式化的定义，形式化的定义教科书上或者上面给的链接中就说的很详细。</p>
<p>还是以上面选课的例子来描述这两个概念。假设我们在学习完了算法这门课后，可以选修机器学习或者计算机图形学。这个或者表示，学习机器学习和计算机图形学这两门课之间没有特定的先后顺序。因此，在我们所有可以选择的课程中，任意两门课程之间的关系要么是确定的(即拥有先后关系)，要么是不确定的(即没有先后关系)，绝对不存在互相矛盾的关系(即环路)。以上就是偏序的意义，抽象而言，有向图中两个顶点之间不存在环路，至于连通与否，是无所谓的。所以，有向无环图必然是满足偏序关系的。</p>
<p>理解了偏序的概念，那么全序就好办了。所谓全序，就是在偏序的基础之上，有向无环图中的任意一对顶点还需要有明确的关系(反映在图中，就是单向连通的关系，注意不能双向连通，那就成环了)。可见，全序就是偏序的一种特殊情况。回到我们的选课例子中，如果机器学习需要在学习了计算机图形学之后才能学习(可能学的是图形学领域相关的机器学习算法……)，那么它们之间也就存在了确定的先后顺序，原本的偏序关系就变成了全序关系。</p>
<p>实际上，很多地方都存在偏序和全序的概念。</p>
<p>比如对若干互不相等的整数进行排序，最后总是能够得到唯一的排序结果(从小到大，下同)。这个结论应该不会有人表示疑问吧:)但是如果我们以偏序/全序的角度来考虑一下这个再自然不过的问题，可能就会有别的体会了。</p>
<p>那么如何用偏序/全序来解释排序结果的唯一性呢？</p>
<p>我们知道不同整数之间的大小关系是确定的，即1总是小于4的，不会有人说1大于或者等于4吧。这就是说，这个序列是满足全序关系的。而对于拥有全序关系的结构(如拥有不同整数的数组)，在其线性化(排序)之后的结果必然是唯一的。对于排序的算法，我们评价指标之一是看该排序算法是否稳定，即值相同的元素的排序结果是否和出现的顺序一致。比如，我们说快速排序是不稳定的，这是因为最后的快排结果中相同元素的出现顺序和排序前不一致了。如果用偏序的概念可以这样解释这一现象：相同值的元素之间的关系是无法确定的。因此它们在最终的结果中的出现顺序可以是任意的。而对于诸如插入排序这种稳定性排序，它们对于值相同的元素，还有一个潜在的比较方式，即比较它们的出现顺序，出现靠前的元素大于出现后出现的元素。因此通过这一潜在的比较，将偏序关系转换为了全序关系，从而保证了结果的唯一性。</p>
<p>拓展到拓扑排序中，结果具有唯一性的条件也是其所有顶点之间都具有全序关系。如果没有这一层全序关系，那么拓扑排序的结果也就不是唯一的了。在后面会谈到，如果拓扑排序的结果唯一，那么该拓扑排序的结果同时也代表了一条哈密顿路径。</p>
<h3 id="典型实现算法"><a href="#典型实现算法" class="headerlink" title="典型实现算法"></a>典型实现算法</h3><h4 id="Kahn算法"><a href="#Kahn算法" class="headerlink" title="Kahn算法"></a>Kahn算法</h4><p>摘一段维基百科上关于Kahn算法的伪码描述：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">L← Empty list that will contain the sorted elements</span><br><span class="line">S ← Set of all nodes with no incoming edges</span><br><span class="line">while S is non-empty do</span><br><span class="line">    remove a node n from S</span><br><span class="line">    insert n into L</span><br><span class="line">    foreach node m with an edge e from nto m do</span><br><span class="line">        remove edge e from thegraph</span><br><span class="line">        ifm has no other incoming edges then</span><br><span class="line">            insert m into S</span><br><span class="line">if graph has edges then</span><br><span class="line">    return error (graph has at least onecycle)</span><br><span class="line">else</span><br><span class="line">    return L (a topologically sortedorder)</span><br></pre></td></tr></table></figure></p>
<p>不难看出该算法的实现十分直观，关键在于需要维护一个入度为0的顶点的集合：</p>
<p>每次从该集合中取出(没有特殊的取出规则，随机取出也行，使用队列/栈也行，下同)一个顶点，将该顶点放入保存结果的List中。</p>
<p>紧接着循环遍历由该顶点引出的所有边，从图中移除这条边，同时获取该边的另外一个顶点，如果该顶点的入度在减去本条边之后为0，那么也将这个顶点放到入度为0的集合中。然后继续从集合中取出一个顶点…………</p>
<p>当集合为空之后，检查图中是否还存在任何边，如果存在的话，说明图中至少存在一条环路。不存在的话则返回结果List，此List中的顺序就是对图进行拓扑排序的结果。</p>
<p>实现代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KahnTopological</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; result;   <span class="comment">// 用来存储结果集</span></span><br><span class="line">	<span class="keyword">private</span> Queue&lt;Integer&gt; setOfZeroIndegree;  <span class="comment">// 用来存储入度为0的顶点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] indegrees;  <span class="comment">// 记录每个顶点当前的入度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> edges;</span><br><span class="line">	<span class="keyword">private</span> Digraph di;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">KahnTopological</span><span class="params">(Digraph di)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.di = di;</span><br><span class="line">		<span class="keyword">this</span>.edges = di.<span class="built_in">getE</span>();</span><br><span class="line">		<span class="keyword">this</span>.indegrees = <span class="keyword">new</span> <span class="type">int</span>[di.<span class="built_in">getV</span>()];</span><br><span class="line">		<span class="keyword">this</span>.result = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">this</span>.setOfZeroIndegree = <span class="keyword">new</span> <span class="built_in">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 对入度为0的集合进行初始化</span></span><br><span class="line">		Iterable&lt;Integer&gt;[] adjs = di.<span class="built_in">getAdj</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; adjs.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 对每一条边 v -&gt; w </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> w : adjs[i])</span><br><span class="line">			&#123;</span><br><span class="line">				indegrees[w]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; indegrees.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">0</span> == indegrees[i])</span><br><span class="line">			&#123;</span><br><span class="line">				setOfZeroIndegree.<span class="built_in">enqueue</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">process</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(!setOfZeroIndegree.<span class="built_in">isEmpty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> v = setOfZeroIndegree.<span class="built_in">dequeue</span>();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 将当前顶点添加到结果集中</span></span><br><span class="line">			result.<span class="built_in">add</span>(v);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 遍历由v引出的所有边</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> w : di.<span class="built_in">adj</span>(v))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 将该边从图中移除，通过减少边的数量来表示</span></span><br><span class="line">				edges--;</span><br><span class="line">				<span class="keyword">if</span>(<span class="number">0</span> == --indegrees[w])   <span class="comment">// 如果入度为0，那么加入入度为0的集合</span></span><br><span class="line">				&#123;</span><br><span class="line">					setOfZeroIndegree.<span class="built_in">enqueue</span>(w);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果此时图中还存在边，那么说明图中含有环路</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span> != edges)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">IllegalArgumentException</span>(<span class="string">&quot;Has Cycle !&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/img/1341373589_4609.png" alt=""><br>对上图进行拓扑排序的结果：</p>
<p>2-&gt;8-&gt;0-&gt;3-&gt;7-&gt;1-&gt;5-&gt;6-&gt;9-&gt;4-&gt;11-&gt;10-&gt;12</p>
<p>复杂度分析：</p>
<ul>
<li>初始化入度为0的集合需要遍历整张图，检查每个节点和每条边，因此复杂度为O(E+V);</li>
<li>然后对该集合进行操作，又需要遍历整张图中的，每条边，复杂度也为O(E+V);</li>
<li>因此Kahn算法的复杂度即为O(E+V)。</li>
</ul>
<h4 id="基于DFS的拓扑排序"><a href="#基于DFS的拓扑排序" class="headerlink" title="基于DFS的拓扑排序"></a>基于DFS的拓扑排序</h4><p>除了使用上面直观的Kahn算法之外，还能够借助深度优先遍历来实现拓扑排序。这个时候需要使用到栈结构来记录拓扑排序的结果。</p>
<p>同样摘录一段维基百科上的伪码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">L ← Empty list that will contain the sorted nodes</span><br><span class="line">S ← Set of all nodes with no outgoing edges</span><br><span class="line">for each node n in S do</span><br><span class="line">    visit(n)</span><br><span class="line">function visit(node n)</span><br><span class="line">    if n has not been visited yet then</span><br><span class="line">        mark n as visited</span><br><span class="line">        for each node m with an edgefrom m to ndo</span><br><span class="line">            visit(m)</span><br><span class="line">        add n to L</span><br></pre></td></tr></table></figure><br>DFS的实现更加简单直观，使用递归实现。利用DFS实现拓扑排序，实际上只需要添加一行代码，即上面伪码中的最后一行：add n to L。</p>
<p>需要注意的是，将顶点添加到结果List中的时机是在visit方法即将退出之时。</p>
<p>这个算法的实现非常简单，但是要理解的话就相对复杂一点。</p>
<p>关键在于为什么在visit方法的最后将该顶点添加到一个集合中，就能保证这个集合就是拓扑排序的结果呢？</p>
<p>因为添加顶点到集合中的时机是在dfs方法即将退出之时，而dfs方法本身是个递归方法，只要当前顶点还存在边指向其它任何顶点，它就会递归调用dfs方法，而不会退出。因此，退出dfs方法，意味着当前顶点没有指向其它顶点的边了，即当前顶点是一条路径上的最后一个顶点。</p>
<p>下面简单证明一下它的正确性：</p>
<p>考虑任意的边v-&gt;w，当调用dfs(v)的时候，有如下三种情况：</p>
<ul>
<li>dfs(w)还没有被调用，即w还没有被mark，此时会调用dfs(w)，然后当dfs(w)返回之后，dfs(v)才会返回</li>
<li>dfs(w)已经被调用并返回了，即w已经被mark</li>
<li>dfs(w)已经被调用但是在此时调用dfs(v)的时候还未返回</li>
</ul>
<p>需要注意的是，以上第三种情况在拓扑排序的场景下是不可能发生的，因为如果情况3是合法的话，就表示存在一条由w到v的路径。而现在我们的前提条件是由v到w有一条边，这就导致我们的图中存在环路，从而该图就不是一个有向无环图(DAG)，而我们已经知道，非有向无环图是不能被拓扑排序的。</p>
<p>那么考虑前两种情况，无论是情况1还是情况2，w都会先于v被添加到结果列表中。所以边v-&gt;w总是由结果集中后出现的顶点指向先出现的顶点。为了让结果更自然一些，可以使用栈来作为存储最终结果的数据结构，从而能够保证边v-&gt;w总是由结果集中先出现的顶点指向后出现的顶点。</p>
<p>实现代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectedDepthFirstOrder</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// visited数组，DFS实现需要用到</span></span><br><span class="line">	<span class="keyword">private</span> boolean[] visited;</span><br><span class="line">	<span class="comment">// 使用栈来保存最后的结果</span></span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; reversePost;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Topological Sorting Constructor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DirectedDepthFirstOrder</span><span class="params">(Digraph di, boolean detectCycle)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 这里的DirectedDepthFirstCycleDetection是一个用于检测有向图中是否存在环路的类</span></span><br><span class="line">		DirectedDepthFirstCycleDetection detect = <span class="keyword">new</span> <span class="built_in">DirectedDepthFirstCycleDetection</span>(</span><br><span class="line">				di);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (detectCycle &amp;&amp; detect.<span class="built_in">hasCycle</span>())</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">IllegalArgumentException</span>(<span class="string">&quot;Has cycle&quot;</span>);</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">this</span>.visited = <span class="keyword">new</span> boolean[di.<span class="built_in">getV</span>()];</span><br><span class="line">		<span class="keyword">this</span>.reversePost = <span class="keyword">new</span> <span class="built_in">Stack</span>&lt;Integer&gt;();</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; di.<span class="built_in">getV</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs</span>(di, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(Digraph di, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		visited[v] = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w : di.<span class="built_in">adj</span>(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[w])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs</span>(di, w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 在即将退出dfs方法的时候，将当前顶点添加到结果集中</span></span><br><span class="line">		reversePost.<span class="built_in">push</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">getReversePost</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> reversePost;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>复杂度分析：</p>
<p>复杂度同DFS一致，即O(E+V)。具体而言，首先需要保证图是有向无环图，判断图是DAG可以使用基于DFS的算法，复杂度为O(E+V)，而后面的拓扑排序也是依赖于DFS，复杂度为O(E+V)</p>
<p>还是对上文中的那张有向图进行拓扑排序，只不过这次使用的是基于DFS的算法，结果是：</p>
<p>8-&gt;7-&gt;2-&gt;3-&gt;0-&gt;6-&gt;9-&gt;10-&gt;11-&gt;12-&gt;1-&gt;5-&gt;4</p>
<h4 id="两种实现算法的总结"><a href="#两种实现算法的总结" class="headerlink" title="两种实现算法的总结"></a>两种实现算法的总结</h4><p>这两种算法分别使用链表和栈来表示结果集。</p>
<p>对于基于DFS的算法，加入结果集的条件是：顶点的出度为0。这个条件和Kahn算法中入度为0的顶点集合似乎有着异曲同工之妙，这两种算法的思想犹如一枚硬币的两面，看似矛盾，实则不然。一个是从入度的角度来构造结果集，另一个则是从出度的角度来构造。</p>
<p>实现上的一些不同之处：</p>
<p>Kahn算法不需要检测图为DAG，如果图为DAG，那么在出度为0的集合为空之后，图中还存在没有被移除的边，这就说明了图中存在环路。而基于DFS的算法需要首先确定图为DAG，当然也能够做出适当调整，让环路的检测和拓扑排序同时进行，毕竟环路检测也能够在DFS的基础上进行。</p>
<p>二者的复杂度均为O(V+E)。</p>
<p>环路检测和拓扑排序同时进行的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectedDepthFirstTopoWithCircleDetection</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> boolean[] visited;</span><br><span class="line">	<span class="comment">// 用于记录dfs方法的调用栈，用于环路检测</span></span><br><span class="line">	<span class="keyword">private</span> boolean[] onStack;</span><br><span class="line">	<span class="comment">// 用于当环路存在时构造之</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] edgeTo;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; reversePost;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; cycle;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Topological Sorting Constructor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DirectedDepthFirstTopoWithCircleDetection</span><span class="params">(Digraph di)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.visited = <span class="keyword">new</span> boolean[di.<span class="built_in">getV</span>()];</span><br><span class="line">		<span class="keyword">this</span>.onStack = <span class="keyword">new</span> boolean[di.<span class="built_in">getV</span>()];</span><br><span class="line">		<span class="keyword">this</span>.edgeTo = <span class="keyword">new</span> <span class="type">int</span>[di.<span class="built_in">getV</span>()];</span><br><span class="line">		<span class="keyword">this</span>.reversePost = <span class="keyword">new</span> <span class="built_in">Stack</span>&lt;Integer&gt;();</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; di.<span class="built_in">getV</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs</span>(di, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(Digraph di, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		visited[v] = <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 在调用dfs方法时，将当前顶点记录到调用栈中</span></span><br><span class="line">		onStack[v] = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w : di.<span class="built_in">adj</span>(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">hasCycle</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!visited[w])</span><br><span class="line">			&#123;</span><br><span class="line">				edgeTo[w] = v;</span><br><span class="line">				<span class="built_in">dfs</span>(di, w);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(onStack[w])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 当w已经被访问，同时w也存在于调用栈中时，即存在环路</span></span><br><span class="line">				cycle = <span class="keyword">new</span> <span class="built_in">Stack</span>&lt;Integer&gt;();</span><br><span class="line">				cycle.<span class="built_in">push</span>(w);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> start = v; start != w; start = edgeTo[start])</span><br><span class="line">				&#123;</span><br><span class="line">					cycle.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">				cycle.<span class="built_in">push</span>(w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 在即将退出dfs方法时，将顶点添加到拓扑排序结果集中，同时从调用栈中退出</span></span><br><span class="line">		reversePost.<span class="built_in">push</span>(v);</span><br><span class="line">		onStack[v] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> boolean <span class="title">hasCycle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (null != cycle);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">getReversePost</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">hasCycle</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> reversePost;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">IllegalArgumentException</span>(<span class="string">&quot;Has Cycle: &quot;</span> + <span class="built_in">getCycle</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">getCycle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cycle;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="拓扑排序解的唯一性"><a href="#拓扑排序解的唯一性" class="headerlink" title="拓扑排序解的唯一性"></a>拓扑排序解的唯一性</h3><h3 id="哈密顿路径"><a href="#哈密顿路径" class="headerlink" title="哈密顿路径"></a>哈密顿路径</h3><p>哈密顿路径是指一条能够对图中所有顶点正好访问一次的路径。本文中只会解释一些哈密顿路径和拓扑排序的关系，至于哈密顿路径的具体定义以及应用，可以参见本文开篇给出的链接。</p>
<p>前面说过，当一个DAG中的任何两个顶点之间都存在可以确定的先后关系时，对该DAG进行拓扑排序的解是唯一的。这是因为它们形成了全序的关系，而对存在全序关系的结构进行线性化之后的结果必然是唯一的(比如对一批整数使用稳定的排序算法进行排序的结果必然就是唯一的)。</p>
<p>需要注意的是，非DAG也是能够含有哈密顿路径的，为了利用拓扑排序来实现判断，所以这里讨论的主要是判断DAG中是否含有哈密顿路径的算法，因此下文中的图指代的都是DAG。</p>
<p>那么知道了哈密顿路径和拓扑排序的关系，我们如何快速检测一张图是否存在哈密顿路径呢？</p>
<p>根据前面的讨论，是否存在哈密顿路径的关键，就是确定图中的顶点是否存在全序的关系，而全序的关键，就是任意一对顶点之间都是能够确定先后关系的。因此，我们能够设计一个算法，用来遍历顶点集中的每一对顶点，然后检查它们之间是否存在先后关系，如果所有的顶点对有先后关系，那么该图的顶点集就存在全序关系，即图中存在哈密顿路径。</p>
<p>但是很显然，这样的算法十分低效。对于大规模的顶点集，是无法应用这种解决方案的。通常一个低效的解决办法，十有八九是因为没有抓住现有问题的一些特征而导致的。因此我们回过头来再看看这个问题，有什么特征使我们没有利用的。还是举对整数进行排序的例子：</p>
<p>比如现在有3， 2， 1三个整数，我们要对它们进行排序，按照之前的思想，我们分别对(1,2)，(2,3)，(1,3)进行比较，这样需要三次比较，但是我们很清楚，1和3的那次比较实际上是多余的。我们为什么知道这次比较是多余的呢？我认为，是我们下意识的利用了整数比较满足传递性的这一规则。但是计算机是无法下意识的使用传递性的，因此只能通过其它的方式来告诉计算机，有一些比较是不必要的。所以，也就有了相对插入排序，选择排序更加高效的排序算法，比如归并排序，快速排序等，将n2的算法加速到了nlogn。或者是利用了问题的特点，采取了更加独特的解决方案，比如基数排序等。</p>
<p>扯远了一点，回到正题。现在我们没有利用到的就是全序关系中传递性这一规则。如何利用它呢，最简单的想法往往就是最实用的，我们还是选择排序，排序后对每对相邻元素进行检测不就间接利用了传递性这一规则嘛？所以，我们先使用拓扑排序对图中的顶点进行排序。排序后，对每对相邻顶点进行检测，看看是否存在先后关系，如果每对相邻顶点都存在着一致的先后关系(在有向图中，这种先后关系以有向边的形式体现，即查看相邻顶点对之间是否存在有向边)。那么就可以确定该图中存在哈密顿路径了，反之则不存在。</p>
<p>实现代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hamilton Path Detection for DAG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DAGHamiltonPath</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> boolean hamiltonPathPresent;</span><br><span class="line">	<span class="keyword">private</span> Digraph di;</span><br><span class="line">	<span class="keyword">private</span> KahnTopological kts;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这里使用Kahn算法进行拓扑排序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DAGHamiltonPath</span><span class="params">(Digraph di, KahnTopological kts)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.di = di;</span><br><span class="line">		<span class="keyword">this</span>.kts = kts;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">process</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Integer[] topoResult = kts.<span class="built_in">getResultAsArray</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 依次检查每一对相邻顶点，如果二者之间没有路径，则不存在哈密顿路径</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; topoResult.length - <span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">hasPath</span>(topoResult[i], topoResult[i + <span class="number">1</span>]))</span><br><span class="line">			&#123;</span><br><span class="line">				hamiltonPathPresent = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		hamiltonPathPresent = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> boolean <span class="title">hasPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> w : di.<span class="built_in">adj</span>(start))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(w == end)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> boolean <span class="title">hasHamiltonPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hamiltonPathPresent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/09/%E9%A2%91%E7%B9%81%E9%A1%B9%E9%9B%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/09/%E9%A2%91%E7%B9%81%E9%A1%B9%E9%9B%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">频繁项集的两个算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-09 10:34:00" itemprop="dateCreated datePublished" datetime="2021-11-09T10:34:00+08:00">2021-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 17:40:00" itemprop="dateModified" datetime="2022-12-26T17:40:00+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="频繁项集的评估标准"><a href="#频繁项集的评估标准" class="headerlink" title="频繁项集的评估标准"></a>频繁项集的评估标准</h1><p>什么样的数据才是频繁项集呢？也许你会说，这还不简单，肉眼一扫，一起出现次数多的数据集就是频繁项集吗！的确，这也没有说错，但是有两个问题，第一是当数据量非常大的时候，我们没法直接肉眼发现频繁项集，这催生了关联规则挖掘的算法，比如Apriori，PrefixSpan，CBA。第二是我们缺乏一个频繁项集的标准。比如10条记录，里面A和B同时出现了三次，那么我们能不能说A和B一起构成频繁项集呢？因此我们需要一个评估频繁项集的标准。</p>
<p>常用的频繁项集的评估标准有支持度，置信度和提升度三个。</p>
<p>支持度就是几个关联的数据在数据集中出现的次数占总数据集的比重。或者说几个数据关联出现的概率。如果我们有两个想分析关联性的数据X和Y，则对应的支持度为:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Support(X,Y)=P(XY)=number(XY)/num(AllSamples)</span><br></pre></td></tr></table></figure></p>
<p>以此类推，如果我们有三个想分析关联性的数据X，Y和Z，则对应的支持度为:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Support(X,Y,Z)=P(XYZ)=number(XYZ)/num(AllSamples)</span><br></pre></td></tr></table></figure></p>
<p>一般来说，支持度高的数据不一定构成频繁项集，但是支持度太低的数据肯定不构成频繁项集。</p>
<p>置信度体现了一个数据出现后，另一个数据出现的概率，或者说数据的条件概率。如果我们有两个想分析关联性的数据X和Y，X对Y的置信度为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Confidence(X⇐Y)=P(X|Y)=P(XY)/P(Y)</span><br></pre></td></tr></table></figure></p>
<p>也可以以此类推到多个数据的关联置信度，比如对于三个数据X，Y，Z，则X对于Y和Z的置信度为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Confidence(X⇐YZ)=P(X|YZ)=P(XYZ)/P(YZ)</span><br></pre></td></tr></table></figure></p>
<p>举个例子，在购物数据中，纸巾对应鸡爪的置信度为40%，支持度为1%。则意味着在购物数据中，总共有1%的用户既买鸡爪又买纸巾；同时买鸡爪的用户中有40%的用户购买纸巾。</p>
<p>提升度表示含有Y的条件下，同时含有X的概率，与X总体发生的概率之比，即:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lift(X⇐Y)=P(X|Y)/P(X)=Confidence(X⇐Y)/P(X)</span><br></pre></td></tr></table></figure></p>
<p>提升度体先了X和Y之间的关联关系，提升度大于1则X⇐Y是有效的强关联规则， 提升度小于等于1则X⇐Y是无效的强关联规则 。一个特殊的情况，如果X和Y独立，则有Lift(X⇐Y)=1，因为此时P(X|Y)=P(X)。</p>
<p>一般来说，要选择一个数据集合中的频繁数据集，则需要自定义评估标准。最常用的评估标准是用自定义的支持度，或者是自定义支持度和置信度的一个组合。</p>
<h1 id="Apriori算法"><a href="#Apriori算法" class="headerlink" title="Apriori算法"></a>Apriori算法</h1><p>Apriori算法是常用的用于挖掘出数据关联规则的算法，它用来找出数据值中频繁出现的数据集合，找出这些集合的模式有助于我们做一些决策。比如在常见的超市购物数据集，或者电商的网购数据集中，如果我们找到了频繁出现的数据集，那么对于超市，我们可以优化产品的位置摆放，对于电商，我们可以优化商品所在的仓库位置，达到节约成本，增加经济效益的目的。下面我们就对Apriori算法做一个总结。</p>
<p>对于Apriori算法，我们使用支持度来作为我们判断频繁项集的标准。Apriori算法的目标是找到最大的K项频繁集。这里有两层意思，首先，我们要找到符合支持度标准的频繁集。但是这样的频繁集可能有很多。第二层意思就是我们要找到最大个数的频繁集。比如我们找到符合支持度的频繁集AB和ABE，那么我们会抛弃AB，只保留ABE，因为AB是2项频繁集，而ABE是3项频繁集。那么具体的，Apriori算法是如何做到挖掘K项频繁集的呢？</p>
<p>Apriori算法采用了迭代的方法，先搜索出候选1项集及对应的支持度，剪枝去掉低于支持度的1项集，得到频繁1项集。然后对剩下的频繁1项集进行连接，得到候选的频繁2项集，筛选去掉低于支持度的候选频繁2项集，得到真正的频繁二项集，以此类推，迭代下去，直到无法找到频繁k+1项集为止，对应的频繁k项集的集合即为算法的输出结果。</p>
<p>可见这个算法还是很简洁的，第i次的迭代过程包括扫描计算候选频繁i项集的支持度，剪枝得到真正频繁i项集和连接生成候选频繁i+1项集三步。</p>
<p>我们下面这个简单的例子看看：<br><img src="/img/1042406-20170117161036255-1753157633.png" alt=""></p>
<p>我们的数据集D有4条记录，分别是134，235，1235和25。现在我们用Apriori算法来寻找频繁k项集，最小支持度设置为50%。首先我们生成候选频繁1项集，包括我们所有的5个数据并计算5个数据的支持度，计算完毕后我们进行剪枝，数据4由于支持度只有25%被剪掉。我们最终的频繁1项集为1235，现在我们链接生成候选频繁2项集，包括12，13，15，23，25，35共6组。此时我们的第一轮迭代结束。</p>
<p>进入第二轮迭代，我们扫描数据集计算候选频繁2项集的支持度，接着进行剪枝，由于12和15的支持度只有25%而被筛除，得到真正的频繁2项集，包括13，23，25，35。现在我们链接生成候选频繁3项集，123，135和235共3组，这部分图中没有画出。通过计算候选频繁3项集的支持度，我们发现123和135的支持度均为25%，因此接着被剪枝，最终得到的真正频繁3项集为235一组。由于此时我们无法再进行数据连接，进而得到候选频繁4项集，最终的结果即为频繁3三项集235。</p>
<h2 id="Aprior算法流程"><a href="#Aprior算法流程" class="headerlink" title="Aprior算法流程"></a>Aprior算法流程</h2><p>下面我们对Aprior算法流程做一个总结。</p>
<ul>
<li>输入：数据集合D，支持度阈值α</li>
<li>输出：最大的频繁k项集</li>
</ul>
<ol>
<li>扫描整个数据集，得到所有出现过的数据，作为候选频繁1项集。k=1，频繁0项集为空集。</li>
<li>挖掘频繁k项集<ol>
<li>扫描数据计算候选频繁k项集的支持度</li>
<li>去除候选频繁k项集中支持度低于阈值的数据集，得到频繁k项集。如果得到的频繁k项集为空，则直接返回频繁k-1项集的集合作为算法结果，算法结束。如果得到的频繁k项集只有一项，则直接返回频繁k项集的集合作为算法结果，算法结束。</li>
<li>基于频繁k项集，连接生成候选频繁k+1项集。</li>
</ol>
</li>
<li>令k=k+1，转入步骤2。</li>
</ol>
<p>从算法的步骤可以看出，Aprior算法每轮迭代都要扫描数据集，因此在数据集很大，数据种类很多的时候，算法效率很低。</p>
<h2 id="Aprior算法总结"><a href="#Aprior算法总结" class="headerlink" title="Aprior算法总结"></a>Aprior算法总结</h2><p>Aprior算法是一个非常经典的频繁项集的挖掘算法，很多算法都是基于Aprior算法而产生的，包括FP-Tree，GSP，CBA等。这些算法利用了Aprior算法的思想，但是对算法做了改进，数据挖掘效率更好一些，因此现在一般很少直接用Aprior算法来挖掘数据了，但是理解Aprior算法是理解其它Aprior类算法的前提，同时算法本身也不复杂，因此值得好好研究一番。</p>
<h1 id="FP-Tree"><a href="#FP-Tree" class="headerlink" title="FP Tree"></a>FP Tree</h1><p>Apriori算法需要多次扫描数据，I/O是很大的瓶颈。为了解决这个问题，FP Tree算法（也称FP Growth算法）采用了一些技巧，无论多少数据，只需要扫描两次数据集，因此提高了算法运行的效率。下面我们就对FP Tree算法做一个总结。</p>
<h2 id="FP-Tree数据结构"><a href="#FP-Tree数据结构" class="headerlink" title="FP Tree数据结构"></a>FP Tree数据结构</h2><p>为了减少I/O次数，FP Tree算法引入了一些数据结构来临时存储数据。这个数据结构包括三部分，如下图所示：<br><img src="/img/1042406-20170119165628718-395589856.png" alt=""></p>
<p>第一部分是一个项头表。里面记录了所有的1项频繁集出现的次数，按照次数降序排列。比如上图中B在所有10组数据中出现了8次，因此排在第一位，这部分好理解。第二部分是FP Tree，它将我们的原始数据集映射到了内存中的一颗FP树，这个FP树比较难理解，它是怎么建立的呢？这个我们后面再讲。第三部分是节点链表。所有项头表里的1项频繁集都是一个节点链表的头，它依次指向FP树中该1项频繁集出现的位置。这样做主要是方便项头表和FP Tree之间的联系查找和更新，也好理解。</p>
<h2 id="项头表的建立"><a href="#项头表的建立" class="headerlink" title="项头表的建立"></a>项头表的建立</h2><p>FP树的建立需要首先依赖项头表的建立。首先我们看看怎么建立项头表。</p>
<p>我们第一次扫描数据，得到所有频繁一项集的的计数。然后删除支持度低于阈值的项，将1项频繁集放入项头表，并按照支持度降序排列。接着第二次也是最后一次扫描数据，将读到的原始数据剔除非频繁1项集，并按照支持度降序排列。</p>
<p>上面这段话很抽象，我们用下面这个例子来具体讲解。我们有10条数据，首先第一次扫描数据并对1项集计数，我们发现O，I，L，J，P，M， N都只出现一次，支持度低于20%的阈值，因此他们不会出现在下面的项头表中。剩下的A，C，E，G，B，D，F按照支持度的大小降序排列，组成了我们的项头表。</p>
<p>接着我们第二次扫描数据，对于每条数据剔除非频繁1项集，并按照支持度降序排列。比如数据项ABCEFO，里面O是非频繁1项集，因此被剔除，只剩下了ABCEF。按照支持度的顺序排序，它变成了ACEBF。其他的数据项以此类推。为什么要将原始数据集里的频繁1项数据项进行排序呢？这是为了我们后面的FP树的建立时，可以尽可能的共用祖先节点。</p>
<p>通过两次扫描，项头表已经建立，排序后的数据集也已经得到了，下面我们再看看怎么建立FP树。<br><img src="/img/1042406-20170119161846125-505903867.png" alt=""></p>
<h2 id="FP-Tree的建立"><a href="#FP-Tree的建立" class="headerlink" title="FP Tree的建立"></a>FP Tree的建立</h2><p>有了项头表和排序后的数据集，我们就可以开始FP树的建立了。开始时FP树没有数据，建立FP树时我们一条条的读入排序后的数据集，插入FP树，插入时按照排序后的顺序，插入FP树中，排序靠前的节点是祖先节点，而靠后的是子孙节点。如果有共用的祖先，则对应的公用祖先节点计数加1。插入后，如果有新节点出现，则项头表对应的节点会通过节点链表链接上新节点。直到所有的数据都插入到FP树后，FP树的建立完成。</p>
<p>似乎也很抽象，我们还是用第二节的例子来描述。</p>
<p>首先，我们插入第一条数据ACEBF，如下图所示。此时FP树没有节点，因此ACEBF是一个独立的路径，所有节点计数为1，项头表通过节点链表链接上对应的新增节点。<br><img src="/img/1042406-20170119163935296-1386696266.png" alt=""></p>
<p>接着我们插入数据ACG，如下图所示。由于ACG和现有的FP树可以有共有的祖先节点序列AC，因此只需要增加一个新节点G，将新节点G的计数记为1。同时A和C的计数加1成为2。当然，对应的G节点的节点链表要更新<br><img src="/img/1042406-20170119164235343-504556889.png" alt=""></p>
<p>同样的办法可以更新后面8条数据，如下8张图。由于原理类似，这里就不多文字讲解了，大家可以自己去尝试插入并进行理解对比。相信如果大家自己可以独立的插入这10条数据，那么FP树建立的过程就没有什么难度了。</p>
<p><img src="/img/1042406-20170119165253265-145701384.png" alt=""><br><img src="/img/1042406-20170119165307640-1886233741.png" alt=""><br><img src="/img/1042406-20170119165315890-467841267.png" alt=""><br><img src="/img/1042406-20170119165326484-481251658.png" alt=""><br><img src="/img/1042406-20170119165335968-745891027.png" alt=""><br><img src="/img/1042406-20170119165346437-1176754608.png" alt=""><br><img src="/img/1042406-20170119165356531-138078582.png" alt=""><br><img src="/img/1042406-20170119165427593-1237891371.png" alt=""></p>
<h1 id="FP-Tree的挖掘"><a href="#FP-Tree的挖掘" class="headerlink" title="FP Tree的挖掘"></a>FP Tree的挖掘</h1><p>下面我们讲如何从FP树里挖掘频繁项集。得到了FP树和项头表以及节点链表，我们首先要从项头表的底部项依次向上挖掘。对于项头表对应于FP树的每一项，我们要找到它的条件模式基。所谓条件模式基是以我们要挖掘的节点作为叶子节点所对应的FP子树。得到这个FP子树，我们将子树中每个节点的的计数设置为叶子节点的计数，并删除计数低于支持度的节点。从这个条件模式基，我们就可以递归挖掘得到频繁项集了。</p>
<p>实在太抽象了，之前我看到这也是一团雾水。还是以上面的例子来讲解。我们看看先从最底下的F节点开始，我们先来寻找F节点的条件模式基，由于F在FP树中只有一个节点，因此候选就只有下图左所示的一条路径，对应{A:8,C:8,E:6,B:2,F:2}。我们接着将所有的祖先节点计数设置为叶子节点的计数，即FP子树变成{A:2,C:2,E:2,B:2,F:2}。一般我们的条件模式基可以不写叶子节点，因此最终的F的条件模式基如下图右所示。<br><img src="/img/1042406-20170119170723421-1812925376.png" alt=""></p>
<p>通过它，我们很容易得到F的频繁2项集为{A:2,F:2}，{C:2,F:2}，{E:2,F:2}，{B:2,F:2}。递归合并二项集，得到频繁三项集为{A:2,C:2,F:2}，{A:2,E:2,F:2}，…还有一些频繁三项集，就不写了。当然一直递归下去，最大的频繁项集为频繁5项集，为{A:2,C:2,E:2,B:2,F:2}。</p>
<p>F挖掘完了，我们开始挖掘D节点。D节点比F节点复杂一些，因为它有两个叶子节点，因此首先得到的FP子树如下图左。我们接着将所有的祖先节点计数设置为叶子节点的计数，即变成{A:2,C:2,E:1 G:1,D:1,D:1}此时E节点和G节点由于在条件模式基里面的支持度低于阈值，被我们删除，最终在去除低支持度节点并不包括叶子节点后D的条件模式基为{A:2,C:2}。通过它，我们很容易得到D的频繁2项集为{A:2,D:2}，{C:2,D:2}。递归合并二项集，得到频繁三项集为{A:2,C:2,D:2}。D对应的最大的频繁项集为频繁3项集。<br><img src="/img/1042406-20170119171924093-1331841220.png" alt=""></p>
<p>同样的方法可以得到B的条件模式基如下图右边，递归挖掘到B的最大频繁项集为频繁4项集{A:2,C:2,E:2,B:2}。<br><img src="/img/1042406-20170119205610265-1248946944.png" alt=""></p>
<p>继续挖掘G的频繁项集，挖掘到的G的条件模式基如下图右边，递归挖掘到G的最大频繁项集为频繁4项集{A:5,C:5,E:4,G:4}。<br><img src="/img/1042406-20170119205839703-739252492.png" alt=""></p>
<p>E的条件模式基如下图右边，递归挖掘到E的最大频繁项集为频繁3项集{A:6,C:6,E:6}。<br><img src="/img/1042406-20170119210046375-59327550.png" alt=""></p>
<p>C的条件模式基如下图右边，递归挖掘到C的最大频繁项集为频繁2项集{A:8,C:8}。<br><img src="/img/1042406-20170119210254812-1959388744.png" alt=""></p>
<p>至于A，由于它的条件模式基为空，因此可以不用去挖掘了。</p>
<p>至此我们得到了所有的频繁项集，如果我们只是要最大的频繁K项集，从上面的分析可以看到，最大的频繁项集为5项集。包括{A:2,C:2,E:2,B:2,F:2}。</p>
<p>通过上面的流程，相信大家对FP Tree的挖掘频繁项集的过程也很熟悉了。</p>
<h2 id="FP-Tree算法归纳"><a href="#FP-Tree算法归纳" class="headerlink" title="FP Tree算法归纳"></a>FP Tree算法归纳</h2><p>这里我们对FP Tree算法流程做一个归纳。FP Tree算法包括以下几步：</p>
<ol>
<li>扫描数据，得到所有频繁一项集的的计数。然后删除支持度低于阈值的项，将1项频繁集放入项头表，并按照支持度降序排列。</li>
<li>扫描数据，将读到的原始数据剔除非频繁1项集，并按照支持度降序排列。</li>
<li>读入排序后的数据集，插入FP树，插入时按照排序后的顺序，插入FP树中，排序靠前的节点是祖先节点，而靠后的是子孙节点。如果有共用的祖先，则对应的公用祖先节点计数加1。插入后，如果有新节点出现，则项头表对应的节点会通过节点链表链接上新节点。直到所有的数据都插入到FP树后，FP树的建立完成。</li>
<li>从项头表的底部项依次向上找到项头表项对应的条件模式基。从条件模式基递归挖掘得到项头表项项的频繁项集（可以参见第4节对F的条件模式基的频繁二项集到频繁5五项集的挖掘）。</li>
<li>如果不限制频繁项集的项数，则返回步骤4所有的频繁项集，否则只返回满足项数要求的频繁项集。 </li>
</ol>
<h2 id="FP-tree算法总结"><a href="#FP-tree算法总结" class="headerlink" title="FP tree算法总结"></a>FP tree算法总结</h2><p>FP Tree算法改进了Apriori算法的I/O瓶颈，巧妙的利用了树结构，这让我们想起了BIRCH聚类，BIRCH聚类也是巧妙的利用了树结构来提高算法运行速度。利用内存数据结构以空间换时间是常用的提高算法运行时间瓶颈的办法。</p>
<p>在实践中，FP Tree算法是可以用于生产环境的关联算法，而Apriori算法则做为先驱，起着关联算法指明灯的作用。除了FP Tree，像GSP，CBA之类的算法都是Apriori派系的。</p>
<h1 id="PrefixSpan算法"><a href="#PrefixSpan算法" class="headerlink" title="PrefixSpan算法"></a>PrefixSpan算法</h1><p>前面我们讲到频繁项集挖掘的关联算法Apriori和FP Tree。这两个算法都是挖掘频繁项集的。而今天我们要介绍的PrefixSpan算法也是关联算法，但是它是挖掘频繁序列模式的，因此要解决的问题目标稍有不同。</p>
<h2 id="项集数据和序列数据"><a href="#项集数据和序列数据" class="headerlink" title="项集数据和序列数据"></a>项集数据和序列数据</h2><p>首先我们看看项集数据和序列数据有什么不同，如下图所示。<br><img src="/img/1042406-20170120160812015-470353744.png" alt=""></p>
<p>左边的数据集就是项集数据，在Apriori和FP Tree算法中我们也已经看到过了，每个项集数据由若干项组成，这些项没有时间上的先后关系。而右边的序列数据则不一样，它是由若干数据项集组成的序列。比如第一个序列<a(abc)(ac)d(cf)>,它由a,abc,ac,d,cf共5个项集数据组成，并且这些项有时间上的先后关系。对于多于一个项的项集我们要加上括号，以便和其他的项集分开。同时由于项集内部是不区分先后顺序的，为了方便数据处理，我们一般将序列数据内所有的项集内部按字母顺序排序。</p>
<h2 id="子序列与频繁序列"><a href="#子序列与频繁序列" class="headerlink" title="子序列与频繁序列"></a>子序列与频繁序列</h2><p>了解了序列数据的概念，我们再来看看上面是子序列。子序列和我们数学上的子集的概念很类似，也就是说，如果某个序列A所有的项集在序列B中的项集都可以找到，则A就是B的子序列。当然，如果用严格的数学描述，子序列是这样的：</p>
<p>对于序列A={a1,a2,…an}和序列B={b1,b2,…bm},n≤m，如果存在数字序列1≤j1≤j2≤…≤jn≤m, 满足a1⊆bj1,a2⊆bj2…an⊆bjn，则称A是B的子序列。当然反过来说， B就是A的超序列。</p>
<p>而频繁序列则和我们的频繁项集很类似，也就是频繁出现的子序列。比如对于下图，支持度阈值定义为50%，也就是需要出现两次的子序列才是频繁序列。而子序列<code>&lt;(ab)c&gt;</code>是频繁序列，因为它是图中的第一条数据和第三条序列数据的子序列，对应的位置用蓝色标示。<br><img src="/img/1042406-20170120163415968-357017982.png" alt=""></p>
<h2 id="PrefixSpan算法的一些概念"><a href="#PrefixSpan算法的一些概念" class="headerlink" title="PrefixSpan算法的一些概念"></a>PrefixSpan算法的一些概念</h2><p>PrefixSpan算法的全称是Prefix-Projected Pattern Growth，即前缀投影的模式挖掘。里面有前缀和投影两个词。那么我们首先看看什么是PrefixSpan算法中的前缀prefix。</p>
<p>在PrefixSpan算法中的前缀prefix通俗意义讲就是序列数据前面部分的子序列。比如对于序列数据<code>B=&lt;a(abc)(ac)d(cf)&gt;</code>，而<code>A=&lt;a(abc)a&gt;</code>,则A是B的前缀。当然B的前缀不止一个，比如<code>&lt;a&gt;</code>，<code>&lt;aa&gt;</code>，<code>&lt;a(ab)&gt;</code>也都是B的前缀。</p>
<p>看了前缀，我们再来看前缀投影，其实前缀投影这儿就是我们的后缀，有前缀就有后缀嘛。前缀加上后缀就可以构成一个我们的序列。下面给出前缀和后缀的例子。对于某一个前缀，序列里前缀后面剩下的子序列即为我们的后缀。如果前缀最后的项是项集的一部分，则用一个“_”来占位表示。</p>
<p>下面这个例子展示了序列<code>&lt;a(abc)(ac)d(cf)&gt;</code>的一些前缀和后缀，还是比较直观的。要注意的是，如果前缀的末尾不是一个完全的项集，则需要加一个占位符。</p>
<p>在PrefixSpan算法中，相同前缀对应的所有后缀的结合我们称为前缀对应的投影数据库。<br><img src="/img/1042406-20170120204305781-1880778940.png" alt=""></p>
<h2 id="PrefixSpan算法思想"><a href="#PrefixSpan算法思想" class="headerlink" title="PrefixSpan算法思想"></a>PrefixSpan算法思想</h2><p>现在我们来看看PrefixSpan算法的思想，PrefixSpan算法的目标是挖掘出满足最小支持度的频繁序列。那么怎么去挖掘出所有满足要求的频繁序列呢。回忆Aprior算法，它是从频繁1项集出发，一步步的挖掘2项集，直到最大的K项集。PrefixSpan算法也类似，它从长度为1的前缀开始挖掘序列模式，搜索对应的投影数据库得到长度为1的前缀对应的频繁序列，然后递归的挖掘长度为2的前缀所对应的频繁序列，。。。以此类推，一直递归到不能挖掘到更长的前缀挖掘为止。</p>
<p>比如对应于我们第二节的例子，支持度阈值为50%。里面长度为1的前缀包括<code>&lt;a&gt;</code>，<code>&lt;b&gt;</code>，<code>&lt;c&gt;</code>，<code>&lt;d&gt;</code>，<code>&lt;e&gt;</code>，<code>&lt;f&gt;</code>，<code>&lt;g&gt;</code>我们需要对这6个前缀分别递归搜索找各个前缀对应的频繁序列。如下图所示，每个前缀对应的后缀也标出来了。由于g只在序列4出现，支持度计数只有1，因此无法继续挖掘。我们的长度为1的频繁序列为<code>&lt;a&gt;</code>，<code>&lt;b&gt;</code>，<code>&lt;c&gt;</code>，<code>&lt;d&gt;</code>，<code>&lt;e&gt;</code>，<code>&lt;f&gt;</code>。去除所有序列中的g，即第4条记录变成<code>&lt;e(af)cbc&gt;</code>。</p>
<p><img src="/img/1042406-20170120214250703-974535125.png" alt=""></p>
<p>现在我们开始挖掘频繁序列,分别从长度为1的频繁项开始。这里我们以d为例子来递归挖掘，其他的节点递归挖掘方法和D一样。方法如下图，首先我们对ｄ的后缀进行计数，得到{a:1, b:2, c:3, d:0, e:1, f:1，_f:1}。注意f和_f是不一样的，因为前者是在和前缀d不同的项集，而后者是和前缀d同项集。由于此时a,d,e,f,_f都达不到支持度阈值，因此我们递归得到的前缀为d的2项频繁序列为<code>&lt;db&gt;</code>和<code>&lt;dc&gt;</code>。接着我们分别递归db和dc为前缀所对应的投影序列。首先看db前缀，此时对应的投影后缀只有<code>&lt;_c(ae)&gt;</code>，此时_c,a,e支持度均达不到阈值，因此无法找到以db为前缀的频繁序列。现在我们来递归另外一个前缀dc。以dc为前缀的投影序列为<code>&lt;_f&gt;</code>，<code>&lt;(bc)(ae)&gt;</code>，<code>&lt;b&gt;</code>，此时我们进行支持度计数，结果为{b:2, a:1, c:1, e:1, _f:1}，只有b满足支持度阈值，因此我们得到前缀为dc的三项频繁序列为<code>&lt;dcb&gt;</code>。我们继续递归以<code>&lt;dcb&gt;</code>为前缀的频繁序列。由于前缀<code>&lt;dcb&gt;</code>对应的投影序列<code>&lt;(_c)ae&gt;</code>支持度全部不达标，因此不能产生4项频繁序列。至此以d为前缀的频繁序列挖掘结束，产生的频繁序列为<code>&lt;d&gt;&lt;db&gt;&lt;dc&gt;&lt;dcb&gt;</code>。</p>
<p>同样的方法可以得到其他以<code>&lt;a&gt;</code>，<code>&lt;b&gt;</code>，<code>&lt;c&gt;</code>，<code>&lt;e&gt;</code>，<code>&lt;f&gt;</code>为前缀的频繁序列。</p>
<p><img src="/img/1042406-20170120222303515-615199517.png" alt=""></p>
<h2 id="PrefixSpan算法流程"><a href="#PrefixSpan算法流程" class="headerlink" title="PrefixSpan算法流程"></a>PrefixSpan算法流程</h2><p>下面我们对PrefixSpan算法的流程做一个归纳总结。</p>
<ul>
<li>输入：序列数据集S和支持度阈值α</li>
<li>输出：所有满足支持度要求的频繁序列集</li>
</ul>
<ol>
<li>找出所有长度为1的前缀和对应的投影数据库</li>
<li>对长度为1的前缀进行计数，将支持度低于阈值α的前缀对应的项从数据集S删除，同时得到所有的频繁1项序列，i=1.</li>
<li>对于每个长度为i满足支持度要求的前缀进行递归挖掘：<ol>
<li>找出前缀所对应的投影数据库。如果投影数据库为空，则递归返回。</li>
<li>统计对应投影数据库中各项的支持度计数。如果所有项的支持度计数都低于阈值α，则递归返回。</li>
<li>将满足支持度计数的各个单项和当前的前缀进行合并，得到若干新的前缀。</li>
<li>令i=i+1，前缀为合并单项后的各个前缀，分别递归执行第3步。</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/01/jemalloc%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/01/jemalloc%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">jemalloc源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-01 23:57:00" itemprop="dateCreated datePublished" datetime="2021-11-01T23:57:00+08:00">2021-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 15:40:51" itemprop="dateModified" datetime="2022-12-26T15:40:51+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>jemalloc</code>是一个通用的<code>malloc(3)</code>实现，着重于减少内存碎片和提高并发性能，在许多项目中都有用到，比如<code>Rust</code>和<code>Redis</code>。</p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="内存的来源"><a href="#内存的来源" class="headerlink" title="内存的来源"></a>内存的来源</h2><p><code>Linux</code>提供了几个系统调用用于分配内存:</p>
<ul>
<li><code>brk()</code>：调整<code>program break</code>，改变<code>data segment</code>的大小。</li>
<li><code>mmap()</code>：在进程的虚拟地址空间中创建新的内存映射。内存分配器一般使用该系统调用创建私有匿名映射分配内存，内核会以<code>page size</code>大小倍数来分配，<code>page size</code>一般为 4096 字节。</li>
</ul>
<p>对应的释放内存也有几种方式:</p>
<ul>
<li><code>brk()</code>：既可以增大也可以缩小。</li>
<li><code>munmap()</code>：解除映射。</li>
<li><code>madvise()</code>：该系统调用会告诉操作系统这块内存之后会如何使用，由操作系统进行处理。释放时，会使用<code>MADV_DONTNEED</code>或 <code>MADV_FREE</code>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MADV_DONTNEED</span><br><span class="line">           Do not expect access in the near future.  (For the time being,</span><br><span class="line">           the application is finished with the given range, so the</span><br><span class="line">           kernel can free resources associated with it.)</span><br><span class="line"></span><br><span class="line">           After a successful MADV_DONTNEED operation, the semantics of</span><br><span class="line">           memory access in the specified region are changed: subsequent</span><br><span class="line">           accesses of pages in the range will succeed, but will result</span><br><span class="line">           in either repopulating the memory contents from the up-to-date</span><br><span class="line">           contents of the underlying mapped file (for shared file</span><br><span class="line">           mappings, shared anonymous mappings, and shmem-based</span><br><span class="line">           techniques such as System V shared memory segments) or zero-</span><br><span class="line">           fill-on-demand pages for anonymous private mappings.</span><br><span class="line"></span><br><span class="line">           Note that, when applied to shared mappings, MADV_DONTNEED</span><br><span class="line">           might not lead to immediate freeing of the pages in the range.</span><br><span class="line">           The kernel is free to delay freeing the pages until an</span><br><span class="line">           appropriate moment.  The resident set size (RSS) of the</span><br><span class="line">           calling process will be immediately reduced however.</span><br><span class="line"></span><br><span class="line">           MADV_DONTNEED cannot be applied to locked pages, Huge TLB</span><br><span class="line">           pages, or VM_PFNMAP pages.  (Pages marked with the kernel-</span><br><span class="line">           internal VM_PFNMAP flag are special memory areas that are not</span><br><span class="line">           managed by the virtual memory subsystem.  Such pages are</span><br><span class="line">           typically created by device drivers that map the pages into</span><br><span class="line">           user space.)</span><br></pre></td></tr></table></figure>
<p>可以看出来，对于私有匿名映射会立即释放，而在之后再次访问这块内存时，不需要重新分配。</p>
<h2 id="False-cache-line-sharing"><a href="#False-cache-line-sharing" class="headerlink" title="False cache line sharing"></a>False cache line sharing</h2><p>为了减少存储器访问延迟，<code>CPU</code>中会有本地<code>Cache</code>，<code>Cache</code>被划分为<code>cache line</code>，大小一般为<code>64B</code>。<code>CPU</code>访问内存时，会首先将内存缓存在<code>cache line</code>中。 在多处理器系统中，每个<code>CPU</code>都有自己的本地<code>Cache</code>，会导致数据多副本，也就带来了一致性问题：多个<code>CPU</code>的<code>cache line</code>中有相同地址的内存。需要实现<code>Cache Coherence Protocol</code>来解决这个问题。现代处理器一般使用<code>MESI</code>协议实现<code>Cache Coherence</code>，这会带来通讯耗时、总线压力、导致<code>cache line</code>的抖动，影响性能。</p>
<p>避免这个问题主要有下面几个方法：</p>
<ul>
<li><code>__declspec (align(64))</code>：变量起始地址按<code>cache line</code>对齐</li>
<li>当使用数组或结构体时，不仅需要起始地址对齐，还需要<code>padding</code>，使得数组元素或结构体大小为<code>cache line</code>倍数</li>
<li>避免多线程使用相近地址的内存，多使用局部变量</li>
</ul>
<h2 id="内存着色"><a href="#内存着色" class="headerlink" title="内存着色"></a>内存着色</h2><p>现代<code>CPU</code>的<code>Cache</code>映射策略有很多，如组相联、全相联、直接相联。不同地址的内存有可能映射到相同的<code>cache line</code>(主要发生在地址对齐的情况，如不同对象的地址按照<code>page size</code>对齐)，如果频繁交替访问映射到相同<code>cache line</code>的内存，就会造成<code>cache line</code>的颠簸。 内存着色通过给对象地址增加<code>cache line</code>大小倍数的偏移，从而映射到不同的<code>cache line</code>，来避免上面的问题。</p>
<h2 id="为什么需要内存分配器"><a href="#为什么需要内存分配器" class="headerlink" title="为什么需要内存分配器"></a>为什么需要内存分配器</h2><p>因为<code>mmap()</code>按照<code>page size</code>进行分配，一般是 4096 字节，若每次分配时都调用一次会造成极大的内存浪费，并且性能不好。若由程序员自己管理<code>page</code>，容易出错且性能不好，所以<code>glibc</code>中提供了标准<code>malloc(3)</code>供程序员使用。</p>
<h2 id="内存分配器的目标"><a href="#内存分配器的目标" class="headerlink" title="内存分配器的目标"></a>内存分配器的目标</h2><p>内存分配器的目标主要有2个：</p>
<ul>
<li>减少内存碎片，包括内部碎片和外部碎片:<ul>
<li>内部碎片：分配出去的但没有使用到的内存，比如需要 32 字节，分配了 40 字节，多余的 8 字节就是内部碎片。</li>
<li>外部碎片：大小不合适导致无法分配出去的内存，比如一直申请 16 字节的内存，但是内存分配器中保存着部分 8 字节的内存，一直分配不出去。</li>
</ul>
</li>
<li>提高性能:<ul>
<li>单线程性能</li>
<li>多线程性能</li>
</ul>
</li>
</ul>
<p><code>jemalloc</code>和<code>tcmalloc</code>都是对<code>glibc</code>中的优化，目的也是为了减少内存碎片和提高性能。</p>
<h1 id="常用内存分配器算法"><a href="#常用内存分配器算法" class="headerlink" title="常用内存分配器算法"></a>常用内存分配器算法</h1><h2 id="Dynamic-memory-allocation"><a href="#Dynamic-memory-allocation" class="headerlink" title="Dynamic memory allocation"></a>Dynamic memory allocation</h2><p>首先分配一整块内存，然后按需从这块内存中分配。一般会在分配出的内存前面保存<code>metadata</code>，还会维护<code>freelist</code>用于查找空闲内存。但这会导致比较严重的外部碎片:<br><img src="/img/20211102100900.png" alt=""></p>
<h2 id="Buddy-memory-allocation"><a href="#Buddy-memory-allocation" class="headerlink" title="Buddy memory allocation"></a>Buddy memory allocation</h2><p>以<code>Binary buddy algorithm</code>为例：同样从一块内存中分配，但此时不是按需分配大小，而是这块内存不断分成一半，直到到达目标大小或者下界。在释放的时候，会和之前分裂的且空闲的进行合并。 一般会用有序结构如红黑树，来存储不同大小的<code>buddy block</code>，这样分配和合并时可以快速查找合适的内存。</p>
<p>这种算法能够有效减少外部碎片，但内部碎片很严重，<code>Binary buddy algorithm</code>最严重会带来 50% 的内部碎片。</p>
<h2 id="Slab-allocation"><a href="#Slab-allocation" class="headerlink" title="Slab allocation"></a>Slab allocation</h2><p>对象的初始化和释放往往比内存的分配和释放代价大，基于此发明了<code>slab</code>。<code>slab</code>会提前分配一块内存，然后将这块连续内存划分为大小相同的<code>slots</code>，使用相应的数据结构记录每个<code>slots</code>的分配状况，如<code>bitmap</code>。 当需要分配时，就查找对应大小的<code>slab</code>，分配出一个空闲<code>slot</code>，而释放时就是把这个<code>slot</code>标记为空闲。</p>
<p><code>slab</code>的<code>size classes</code>影响碎片的产生，需要精心选择：</p>
<ul>
<li><code>size classes</code>太稀疏会导致内部碎片</li>
<li><code>size classes</code>太密集又会导致外部碎片</li>
</ul>
<h1 id="jemalloc-源码分析"><a href="#jemalloc-源码分析" class="headerlink" title="jemalloc 源码分析"></a>jemalloc 源码分析</h1><p><code>Redis</code>一般不使用<code>glibc</code>中默认的内存分配器，在编译时可以指定使用自带的<code>jemalloc</code>，版本为 4.0.3，编译参数如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-lg-quantum=3 --with-jemalloc-prefix=je_ --enable-cc-silence CFLAGS=&quot;-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops &quot; LDFLAGS=&quot;&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>--with-lg-quantum=&lt;lg-quantum&gt;</code>：Base 2 log of minimum allocation alignment. 8字节对齐</li>
<li><code>--with-jemalloc-prefix=&lt;prefix&gt;</code>：Prefix to prepend to all public APIs.</li>
<li><code>--disable-cc-silence</code>：Do not silence irrelevant compiler warnings.</li>
</ol>
<p><code>jemalloc</code>可以在编译时配置也支持运行时配置，配置项可以查看文档，可配置的有 page size、chunksize、quantum 等。配置支持 4 种方式:</p>
<ul>
<li><code>/etc/malloc.conf</code> 符号链接</li>
<li><code>MALLOC_OPTIONS</code> 环境变量</li>
<li><code>_malloc_options</code> 全局变量</li>
<li><code>je_mallctl()</code> 在代码里进行配置</li>
</ul>
<p><img src="/img/c2dv3kuw94.png" alt=""></p>
<h2 id="1-Some-structures"><a href="#1-Some-structures" class="headerlink" title="1 - Some structures"></a>1 - Some structures</h2><h3 id="page"><a href="#page" class="headerlink" title="page"></a>page</h3><p>最底层是从操作系统申请内存，由<code>pages.h/pages.c</code>封装了跨平台实现，<code>Linux</code>中使用<code>mmap(2)</code>。主要关注下面几个函数:</p>
<ul>
<li><code>pages_map()</code>：调用<code>mmap()</code>分配可读可写、私有匿名映射。</li>
<li><code>pages_unmap()</code>：调用<code>mummap()</code>删除指定范围的映射。</li>
<li><code>pages_trim()</code>：<code>trim</code>头尾部分的内存映射，用于内存对齐。</li>
<li><code>pages_purge()</code>：调用<code>madvise()</code>清除(purge)部分内存页，也就是释放。</li>
</ul>
<p><code>mmap()</code>会以<code>page size</code>的倍数分配内存，匿名映射会初始化为0，私有映射采用 COW 策略。</p>
<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>每当内存不够用了，<code>jemalloc</code>会以<code>chunk</code>为单位从操作系统申请内存，大小为<code>page size</code>倍数，默认为 2 MiB，分配的函数为<code>chunk_alloc_mmap()</code>。<code>chunk_alloc_map()</code>会调用<code>pages_map()</code>分配地址按<code>chunk_size</code>对齐的内存，既可以避免 false cache line sharing，也可以在常量时间内得到起始地址。 但是<code>pages_map()</code>不能保证对齐，首先会调用<code>pages_map()</code>分配一块内存查看是否对齐，若没对齐，会重新多分配一些内存，然后调用<code>pages_trim()</code>截取两端使内存对齐 ，所以可能会有多次<code>mmap()</code>和<code>munmap()</code>的过程。</p>
<p><code>chunk</code>分配出来需要进行管理，每个<code>chunk</code>会分配一个头部<code>extent_node_t</code>记录其中的信息，如:</p>
<ul>
<li><code>en_arena</code>：负责该<code>chunk</code>的<code>arena</code>(后面介绍)。</li>
<li><code>en_addr</code>：该<code>chunk</code>的起始地址。<br>  <code>chunk</code>分配出来会插入到<code>chunks_rtree(radix tree)</code>中，保存<code>chunk</code>地址到<code>extent_node_t</code>的映射，以便能快速从地址找到<code>node</code>，方便后面<code>huge object</code>的释放。</li>
</ul>
<h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p><code>jemalloc</code>不可能只使用栈空间或全局变量，内部也需要动态分配一些内存。<code>base.h/base.c</code>实现了内部使用的内存分配器。</p>
<p><code>base</code>通过地址对齐和<code>padding</code>避免 false cache line sharing：<code>chunk</code>会按照<code>chunksize</code>地址对齐，且分配的大小会<code>padding</code>到<code>cache line</code>大小倍数。</p>
<p><code>base</code>以<code>chunk</code>为单位申请内存，记录<code>chunk</code>信息的<code>extent_node_t</code>使用<code>chunk</code>的起始内存:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">extent_node_t</span> *</span><br><span class="line"><span class="title function_">base_chunk_alloc</span><span class="params">(<span class="type">size_t</span> minsize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">extent_node_t</span> *node;</span><br><span class="line">	<span class="type">size_t</span> csize, nsize;</span><br><span class="line">	<span class="type">void</span> *addr;</span><br><span class="line"></span><br><span class="line">	assert(minsize != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* 尝试从 base_nodes 中复用 node */</span></span><br><span class="line">	node = base_node_try_alloc();</span><br><span class="line">	<span class="comment">/* Allocate enough space to also carve a node out if necessary. */</span></span><br><span class="line">        <span class="comment">// 需要分配的 node 的内存</span></span><br><span class="line">	nsize = (node == <span class="literal">NULL</span>) ? CACHELINE_CEILING(<span class="keyword">sizeof</span>(<span class="type">extent_node_t</span>)) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 多分配 node size，也按照 chunk size 对齐</span></span><br><span class="line">	csize = CHUNK_CEILING(minsize + nsize);</span><br><span class="line">        <span class="comment">// 内部调用 chunk_alloc_mmap()</span></span><br><span class="line">	addr = chunk_alloc_base(csize);</span><br><span class="line">	<span class="keyword">if</span> (addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">			base_node_dalloc(node);</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	base_mapped += csize;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用 chunk 的起始内存</span></span><br><span class="line">		node = (<span class="type">extent_node_t</span> *)addr;</span><br><span class="line">		addr = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)addr + nsize);</span><br><span class="line">		csize -= nsize;</span><br><span class="line">		<span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">			base_allocated += nsize;</span><br><span class="line">			base_resident += PAGE_CEILING(nsize);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	extent_node_init(node, <span class="literal">NULL</span>, addr, csize, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">return</span> (node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>base</code>使用<code>extent_node_t</code>组成的红黑树<code>base_avail_szad</code>管理<code>chunk</code>。每次需要分配时，会从红黑树中查找内存大小相同或略大的、地址最低的<code>node</code>，然后从<code>node</code>负责的<code>chunk</code>中分配内存，剩下的内存会继续由该<code>node</code>负责，修改大小和地址后再次插入到红黑树中；若该<code>node</code>负责的内存全部分配完了，会将该<code>node</code>添加到链表头<code>base_nodes</code>，留待后续分配时复用。当没有合适的<code>node</code>时，会新分配<code>chunk</code>大小倍数的内存，由<code>node</code>负责，这个<code>node</code>优先从链表<code>base_nodes</code>中分配，也可能是新分配的连续内存的起始位置构成的<code>node</code>。</p>
<p><code>base_alloc()</code>：从<code>base_avail_szad</code>中查找大小相同或略大的、地址最低的<code>extent_node_t</code>，再从<code>chunk</code>里分配内存。如果没有合适的内存，会先调用<code>base_chunk_alloc()</code>分配<code>chunk</code>大小倍数的内存，返回负责这块内存的<code>node</code>，然后进行分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ret = extent_node_addr_get(node); <span class="comment">/* node 中用于分配内存的起始地址 */</span></span><br><span class="line"><span class="keyword">if</span> (extent_node_size_get(node) &gt; csize) &#123;</span><br><span class="line">    extent_node_addr_set(node, (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)ret + csize)); <span class="comment">/* 起始地址增加 csize，表明之前的内存被分配出去 */</span></span><br><span class="line">    extent_node_size_set(node, extent_node_size_get(node) - csize); <span class="comment">/* 内存大小减少 */</span></span><br><span class="line">    extent_tree_szad_insert(&amp;base_avail_szad, node); <span class="comment">/* 按照大小、地址顺序插入到红黑树 */</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* 这种情况只发生在 extent_node_size_get(node) == csize 这种情况。</span></span><br><span class="line"><span class="comment">     * 此时该 node 负责的内存已经全部分配了，会将该 node 插入到一个链表中去，备用。</span></span><br><span class="line"><span class="comment">     * 该链表用嵌入式实现，在 node 的起始内存存放下一个 node 的地址，节省空间 */</span></span><br><span class="line">    base_node_dalloc(node);</span><br></pre></td></tr></table></figure>
<p>为了减少内存浪费，<code>base_nodes</code>链表缓存了之前分配的<code>extent_node_t</code>，<code>base_nodes</code>指向链表头，<code>base_node_dalloc()</code>将<code>node</code>添加到表头，而<code>base_node_try_alloc()</code>移除表头。 采用嵌入式实现，比较晦涩:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">extent_node_t</span> *</span><br><span class="line"><span class="title function_">base_node_try_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">extent_node_t</span> *node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (base_nodes == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 返回链表头</span></span><br><span class="line">	node = base_nodes;</span><br><span class="line">        <span class="comment">// base_nodes 指向下一个 node</span></span><br><span class="line">	base_nodes = *(<span class="type">extent_node_t</span> **)node;</span><br><span class="line">	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(node, <span class="keyword">sizeof</span>(<span class="type">extent_node_t</span>));</span><br><span class="line">	<span class="keyword">return</span> (node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* base_mtx must be held. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">base_node_dalloc</span><span class="params">(<span class="type">extent_node_t</span> *node)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(node, <span class="keyword">sizeof</span>(<span class="type">extent_node_t</span>));</span><br><span class="line">        <span class="comment">// 将 base_nodes 指向的地址保存在 node 的指向的内存起始处</span></span><br><span class="line">        <span class="comment">// 形成一个 node 的链表，base_nodes 指向链表头，内存起始处为</span></span><br><span class="line">        <span class="comment">// 下一个 node 的地址</span></span><br><span class="line">	*(<span class="type">extent_node_t</span> **)node = base_nodes;</span><br><span class="line">	base_nodes = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p><code>arena</code>是<code>jemalloc</code>中最重要的部分，内存大多数由<code>arena</code>管理，分配算法是<code>Buddy allocation</code>和<code>Slab allocation</code>的组合:</p>
<ul>
<li><code>chunk</code>使用<code>Buddy allocation</code>划分为不同大小的<code>run</code>。</li>
<li><code>run</code>使用<code>Slab allocation</code>划分为固定大小的<code>region</code>，大部分内存分配直接查找对应的<code>run</code>，从中分配空闲的<code>region</code>，释放就是标记<code>region</code>为空闲。</li>
<li><code>run</code>被释放会和空闲的、相邻的<code>run</code>进行合并。当合并为整个<code>chunk</code>时，若发现有相邻的空闲<code>chunk</code>，也会进行合并。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* This arena&#x27;s index within the arenas array. */</span></span><br><span class="line">	<span class="type">unsigned</span>		ind;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of threads currently assigned to this arena.  This field is</span></span><br><span class="line"><span class="comment">	 * protected by arenas_lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span>		nthreads;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There are three classes of arena operations from a locking</span></span><br><span class="line"><span class="comment">	 * perspective:</span></span><br><span class="line"><span class="comment">	 * 1) Thread assignment (modifies nthreads) is protected by arenas_lock.</span></span><br><span class="line"><span class="comment">	 * 2) Bin-related operations are protected by bin locks.</span></span><br><span class="line"><span class="comment">	 * 3) Chunk- and run-related operations are protected by this mutex.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">malloc_mutex_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	<span class="type">arena_stats_t</span>		stats;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * List of tcaches for extant threads associated with this arena.</span></span><br><span class="line"><span class="comment">	 * Stats from these are merged incrementally, and at exit if</span></span><br><span class="line"><span class="comment">	 * opt_stats_print is enabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ql_head(<span class="type">tcache_t</span>)	tcache_ql;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>		prof_accumbytes;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * PRNG state for cache index randomization of large allocation base</span></span><br><span class="line"><span class="comment">	 * pointers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint64_t</span>		offset_state;</span><br><span class="line"></span><br><span class="line">	<span class="type">dss_prec_t</span>		dss_prec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In order to avoid rapid chunk allocation/deallocation when an arena</span></span><br><span class="line"><span class="comment">	 * oscillates right on the cusp of needing a new chunk, cache the most</span></span><br><span class="line"><span class="comment">	 * recently freed chunk.  The spare is left in the arena&#x27;s chunk trees</span></span><br><span class="line"><span class="comment">	 * until it is deleted.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * There is one spare chunk per arena, rather than one spare total, in</span></span><br><span class="line"><span class="comment">	 * order to avoid interactions between multiple threads that could make</span></span><br><span class="line"><span class="comment">	 * a single spare inadequate.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">arena_chunk_t</span>		*spare;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Minimum ratio (log base 2) of nactive:ndirty. */</span></span><br><span class="line">	<span class="type">ssize_t</span>			lg_dirty_mult;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* True if a thread is currently executing arena_purge(). */</span></span><br><span class="line">	<span class="type">bool</span>			purging;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of pages in active runs and huge regions. */</span></span><br><span class="line">        <span class="comment">// 已经分配出的 page 个数</span></span><br><span class="line">	<span class="type">size_t</span>			nactive;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Current count of pages within unused runs that are potentially</span></span><br><span class="line"><span class="comment">	 * dirty, and for which madvise(... MADV_DONTNEED) has not been called.</span></span><br><span class="line"><span class="comment">	 * By tracking this, we can institute a limit on how much dirty unused</span></span><br><span class="line"><span class="comment">	 * memory is mapped for each arena.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// runs_dirty 中的page数目(包含 chunk)</span></span><br><span class="line">	<span class="type">size_t</span>			ndirty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Size/address-ordered tree of this arena&#x27;s available runs.  The tree</span></span><br><span class="line"><span class="comment">	 * is used for first-best-fit run allocation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// 红黑树</span></span><br><span class="line">	<span class="type">arena_avail_tree_t</span>	runs_avail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Unused dirty memory this arena manages.  Dirty memory is conceptually</span></span><br><span class="line"><span class="comment">	 * tracked as an arbitrarily interleaved LRU of dirty runs and cached</span></span><br><span class="line"><span class="comment">	 * chunks, but the list linkage is actually semi-duplicated in order to</span></span><br><span class="line"><span class="comment">	 * avoid extra arena_chunk_map_misc_t space overhead.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   LRU-----------------------------------------------------------MRU</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *        /-- arena ---\</span></span><br><span class="line"><span class="comment">	 *        |            |</span></span><br><span class="line"><span class="comment">	 *        |            |</span></span><br><span class="line"><span class="comment">	 *        |------------|                             /- chunk -\</span></span><br><span class="line"><span class="comment">	 *   ...-&gt;|chunks_cache|&lt;---------------------------&gt;|  /----\ |&lt;--...</span></span><br><span class="line"><span class="comment">	 *        |------------|                             |  |node| |</span></span><br><span class="line"><span class="comment">	 *        |            |                             |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |            |    /- run -\    /- run -\   |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |            |    |       |    |       |   |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |            |    |       |    |       |   |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |------------|    |-------|    |-------|   |  |----| |</span></span><br><span class="line"><span class="comment">	 *   ...-&gt;|runs_dirty  |&lt;--&gt;|rd     |&lt;--&gt;|rd     |&lt;----&gt;|rd  |&lt;----...</span></span><br><span class="line"><span class="comment">	 *        |------------|    |-------|    |-------|   |  |----| |</span></span><br><span class="line"><span class="comment">	 *        |            |    |       |    |       |   |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |            |    |       |    |       |   |  \----/ |</span></span><br><span class="line"><span class="comment">	 *        |            |    \-------/    \-------/   |         |</span></span><br><span class="line"><span class="comment">	 *        |            |                             |         |</span></span><br><span class="line"><span class="comment">	 *        |            |                             |         |</span></span><br><span class="line"><span class="comment">	 *        \------------/                             \---------/</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// 空闲的 dirty run 会存在这，用于 purge</span></span><br><span class="line">	<span class="type">arena_runs_dirty_link_t</span>	runs_dirty;</span><br><span class="line">        <span class="comment">// 都是 runs_dirty 中存在的，是为了保存脏的 chunk</span></span><br><span class="line">	<span class="type">extent_node_t</span>		chunks_cache;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Extant huge allocations. */</span></span><br><span class="line">	ql_head(<span class="type">extent_node_t</span>)	huge;</span><br><span class="line">	<span class="comment">/* Synchronizes all huge allocation/update/deallocation. */</span></span><br><span class="line">	<span class="type">malloc_mutex_t</span>		huge_mtx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Trees of chunks that were previously allocated (trees differ only in</span></span><br><span class="line"><span class="comment">	 * node ordering).  These are used when allocating chunks, in an attempt</span></span><br><span class="line"><span class="comment">	 * to re-use address space.  Depending on function, different tree</span></span><br><span class="line"><span class="comment">	 * orderings are needed, which is why there are two trees with the same</span></span><br><span class="line"><span class="comment">	 * contents.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// 用于复用 chunk</span></span><br><span class="line">        <span class="comment">// 2种树的内容一样，order 不同</span></span><br><span class="line">	<span class="type">extent_tree_t</span>		chunks_szad_cached;</span><br><span class="line">	<span class="type">extent_tree_t</span>		chunks_ad_cached;</span><br><span class="line">	<span class="type">extent_tree_t</span>		chunks_szad_retained;</span><br><span class="line">	<span class="type">extent_tree_t</span>		chunks_ad_retained;</span><br><span class="line"></span><br><span class="line">	<span class="type">malloc_mutex_t</span>		chunks_mtx;</span><br><span class="line">	<span class="comment">/* Cache of nodes that were allocated via base_alloc(). */</span></span><br><span class="line">	ql_head(<span class="type">extent_node_t</span>)	node_cache;</span><br><span class="line">	<span class="type">malloc_mutex_t</span>		node_cache_mtx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* User-configurable chunk hook functions. */</span></span><br><span class="line">    <span class="comment">// chunk_hooks_default</span></span><br><span class="line">	<span class="type">chunk_hooks_t</span>		chunk_hooks;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bins is used to store trees of free regions. */</span></span><br><span class="line">	<span class="type">arena_bin_t</span>		bins[NBINS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整体的结构图如下，忽略了很多细节：<br><img src="/img/20211102100901.png" alt=""></p>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p><code>small classes</code>从<code>run</code>中使用<code>slab</code>算法分配，每个<code>run</code>对应一块连续的内存，大小为<code>page size</code>倍数，划分为等大小的<code>region</code>，分配时就从<code>run</code>中分配一个空闲<code>region</code>，释放时就标记该<code>region</code>为空闲，留待之后分配。</p>
<p><code>arena_run_t</code>记录了<code>run</code>的分配情况:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_run_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Index of bin this run is associated with. */</span></span><br><span class="line">	<span class="type">szind_t</span>		binind;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of free regions in run. */</span></span><br><span class="line">	<span class="type">unsigned</span>	nfree;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per region allocated/deallocated bitmap. */</span></span><br><span class="line">        <span class="comment">// 记录 run 中 region 的分配情况，每 bit 对应1个 region</span></span><br><span class="line">	<span class="type">bitmap_t</span>	bitmap[BITMAP_GROUPS_MAX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在看一下如何从<code>run</code>中分配:</p>
<ul>
<li>首先设置<code>bitmap</code>中第一个未设置的并返回，也就是要分配的<code>region id</code></li>
<li>返回对应的<code>region</code>，具体的地址计算后面再来看</li>
<li><code>nfree--</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE_C <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_run_reg_alloc</span><span class="params">(<span class="type">arena_run_t</span> *run, <span class="type">arena_bin_info_t</span> *bin_info)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line">	<span class="type">unsigned</span> regind;</span><br><span class="line">	<span class="type">arena_chunk_map_misc_t</span> *miscelm;</span><br><span class="line">	<span class="type">void</span> *rpages;</span><br><span class="line"></span><br><span class="line">	assert(run-&gt;nfree &gt; <span class="number">0</span>);</span><br><span class="line">	assert(!bitmap_full(run-&gt;bitmap, &amp;bin_info-&gt;bitmap_info));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set first unset 并 返回</span></span><br><span class="line">	regind = bitmap_sfu(run-&gt;bitmap, &amp;bin_info-&gt;bitmap_info);</span><br><span class="line">	miscelm = arena_run_to_miscelm(run);</span><br><span class="line">	rpages = arena_miscelm_to_rpages(miscelm);</span><br><span class="line">        <span class="comment">// 获取 run 中对应的 region，返回</span></span><br><span class="line">	ret = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)rpages + (<span class="type">uintptr_t</span>)bin_info-&gt;reg0_offset +</span><br><span class="line">	    (<span class="type">uintptr_t</span>)(bin_info-&gt;reg_interval * regind));</span><br><span class="line">	run-&gt;nfree--;</span><br><span class="line">	<span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放是相反的过程:</p>
<ul>
<li>首先获取该<code>ptr</code>的<code>region id</code></li>
<li><code>unset</code>对应的<code>bitmap</code></li>
<li><code>nfree++</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE_C <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_run_reg_dalloc</span><span class="params">(<span class="type">arena_run_t</span> *run, <span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">arena_chunk_t</span> *chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(run);</span><br><span class="line">	<span class="type">size_t</span> pageind = ((<span class="type">uintptr_t</span>)ptr - (<span class="type">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE;</span><br><span class="line">	<span class="type">size_t</span> mapbits = arena_mapbits_get(chunk, pageind);</span><br><span class="line">	<span class="type">szind_t</span> binind = arena_ptr_small_binind_get(ptr, mapbits);</span><br><span class="line">	<span class="type">arena_bin_info_t</span> *bin_info = &amp;arena_bin_info[binind];</span><br><span class="line">	<span class="type">unsigned</span> regind = arena_run_regind(run, bin_info, ptr);</span><br><span class="line"></span><br><span class="line">	assert(run-&gt;nfree &lt; bin_info-&gt;nregs);</span><br><span class="line">	<span class="comment">/* Freeing an interior pointer can cause assertion failure. */</span></span><br><span class="line">	assert(((<span class="type">uintptr_t</span>)ptr -</span><br><span class="line">	    ((<span class="type">uintptr_t</span>)arena_miscelm_to_rpages(arena_run_to_miscelm(run)) +</span><br><span class="line">	    (<span class="type">uintptr_t</span>)bin_info-&gt;reg0_offset)) %</span><br><span class="line">	    (<span class="type">uintptr_t</span>)bin_info-&gt;reg_interval == <span class="number">0</span>);</span><br><span class="line">	assert((<span class="type">uintptr_t</span>)ptr &gt;=</span><br><span class="line">	    (<span class="type">uintptr_t</span>)arena_miscelm_to_rpages(arena_run_to_miscelm(run)) +</span><br><span class="line">	    (<span class="type">uintptr_t</span>)bin_info-&gt;reg0_offset);</span><br><span class="line">	<span class="comment">/* Freeing an unallocated pointer can cause assertion failure. */</span></span><br><span class="line">	assert(bitmap_get(run-&gt;bitmap, &amp;bin_info-&gt;bitmap_info, regind));</span><br><span class="line"></span><br><span class="line">	bitmap_unset(run-&gt;bitmap, &amp;bin_info-&gt;bitmap_info, regind);</span><br><span class="line">	run-&gt;nfree++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p><code>jemalloc</code>中<code>small size classes</code>都使用<code>slab</code>算法分配，所以会有多种不同的<code>run</code>。<code>bin</code>管理相同类型的<code>run</code>，<code>bin_info</code>记录了对应的<code>run</code>的内存格式。</p>
<p><code>bin_info_init()</code>根据<code>size classes</code>初始化<code>small class bins</code>的信息<code>arena_bin_info[NBINS]</code>。数组中每个元素记录了<code>bin</code>对应的<code>run</code>的信息:</p>
<ul>
<li><code>reg_size</code>：每个<code>region</code>的大小，对应着<code>small size classes</code>大小</li>
<li><code>run_size</code>：<code>bin</code>对应的整个<code>run</code>的大小，<code>page_size</code>的倍数，一般为<code>reg_size</code>和<code>page_size</code>的最小公倍数，但是不能超过<code>arena_maxrun</code>。</li>
<li><code>nregs</code>：该<code>run</code>中<code>region</code>的个数</li>
<li><code>reg0_offset</code>：第一个<code>region</code>距离<code>run</code>起始地址的偏移</li>
</ul>
<p>还有一些其他的信息，主要用于<code>debug</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read-only information associated with each element of arena_t&#x27;s bins array</span></span><br><span class="line"><span class="comment"> * is stored separately, partly to reduce memory usage (only one copy, rather</span></span><br><span class="line"><span class="comment"> * than one per arena), but mainly to avoid false cacheline sharing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Each run has the following layout:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *               /--------------------\</span></span><br><span class="line"><span class="comment"> *               | pad?               |</span></span><br><span class="line"><span class="comment"> *               |--------------------|</span></span><br><span class="line"><span class="comment"> *               | redzone            |</span></span><br><span class="line"><span class="comment"> *   reg0_offset | region 0           |</span></span><br><span class="line"><span class="comment"> *               | redzone            |</span></span><br><span class="line"><span class="comment"> *               |--------------------| \</span></span><br><span class="line"><span class="comment"> *               | redzone            | |</span></span><br><span class="line"><span class="comment"> *               | region 1           |  &gt; reg_interval</span></span><br><span class="line"><span class="comment"> *               | redzone            | /</span></span><br><span class="line"><span class="comment"> *               |--------------------|</span></span><br><span class="line"><span class="comment"> *               | ...                |</span></span><br><span class="line"><span class="comment"> *               | ...                |</span></span><br><span class="line"><span class="comment"> *               | ...                |</span></span><br><span class="line"><span class="comment"> *               |--------------------|</span></span><br><span class="line"><span class="comment"> *               | redzone            |</span></span><br><span class="line"><span class="comment"> *               | region nregs-1     |</span></span><br><span class="line"><span class="comment"> *               | redzone            |</span></span><br><span class="line"><span class="comment"> *               |--------------------|</span></span><br><span class="line"><span class="comment"> *               | alignment pad?     |</span></span><br><span class="line"><span class="comment"> *               \--------------------/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * reg_interval has at least the same minimum alignment as reg_size; this</span></span><br><span class="line"><span class="comment"> * preserves the alignment constraint that sa2u() depends on.  Alignment pad is</span></span><br><span class="line"><span class="comment"> * either 0 or redzone_size; it is present only if needed to align reg0_offset.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><code>bin</code>的结构如下:</p>
<ul>
<li><code>runcur</code>：指向有空闲<code>region</code>且地址最低的<code>run</code></li>
<li><code>runs</code>：红黑树，管理有空闲<code>region</code>的<code>run</code>，按照<code>run</code>的地址排序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_bin_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All operations on runcur, runs, and stats require that lock be</span></span><br><span class="line"><span class="comment">	 * locked.  Run allocation/deallocation are protected by the arena lock,</span></span><br><span class="line"><span class="comment">	 * which may be acquired while holding one or more bin locks, but not</span></span><br><span class="line"><span class="comment">	 * vise versa.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">malloc_mutex_t</span>	lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Current run being used to service allocations of this bin&#x27;s size</span></span><br><span class="line"><span class="comment">	 * class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">arena_run_t</span>	*runcur;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Tree of non-full runs.  This tree is used when looking for an</span></span><br><span class="line"><span class="comment">	 * existing run when runcur is no longer usable.  We choose the</span></span><br><span class="line"><span class="comment">	 * non-full run that is lowest in memory; this policy tends to keep</span></span><br><span class="line"><span class="comment">	 * objects packed well, and it can also help reduce the number of</span></span><br><span class="line"><span class="comment">	 * almost-empty chunks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// 红黑树 non-full runs，按照地址排序</span></span><br><span class="line">	<span class="type">arena_run_tree_t</span> runs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bin statistics. */</span></span><br><span class="line">	<span class="type">malloc_bin_stats_t</span> stats;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>来看下如何从<code>bin</code>中分配<code>run</code>:</p>
<ul>
<li>若<code>runcur != NULL</code>，则从该<code>run</code>分配</li>
<li>从<code>runs</code>中查找地址最低的<code>run</code>，分配</li>
</ul>
<p>当从<code>run</code>中释放<code>region</code>时，根据<code>run</code>的状态会有不同的操作:</p>
<ul>
<li>若该<code>run</code>原先已满，则会调用<code>arena_bin_lower_run()</code>设置为<code>runcur</code>或者插入到<code>runs</code>中</li>
<li>若该<code>run</code>之前有空闲空间，说明是<code>runcur</code>或已经在<code>runs</code>中，此时无特殊处理</li>
<li>若该<code>run</code>释放<code>region</code>后已空，则会将该<code>run</code>与<code>bin</code>解除关系，返回到<code>arena</code>中，后面再来看这种情况</li>
</ul>
<p><code>bin-&gt;runcur</code>指向的永远是地址最低的<code>run</code>，目的是减少<code>active pages</code>。</p>
<h3 id="chunk-1"><a href="#chunk-1" class="headerlink" title="chunk"></a>chunk</h3><p><code>chunk</code>是<code>jemalloc</code>中申请内存的基本单位。<code>arena</code>中有如下元素管理<code>chunk</code>:</p>
<ul>
<li><code>spare</code>：缓存最近空闲的<code>chunk</code>，为了避免频繁的<code>chunk</code>分配和释放</li>
<li><code>chunks_szad_cached/chunks_ad_cached</code>：<code>extent_node_t</code>的红黑树，缓存之前分配的、空闲的<code>chunk</code>，数据一样，只是顺序不同:</li>
<li><code>szad</code>：按照<code>size</code>、<code>address</code>排序</li>
<li><code>ad</code>：按照<code>address</code>排序</li>
<li><code>chunks_szad_retained/chunks_ad_retained</code>：<code>extent_node_t</code>的红黑树，缓存已经被释放的、空闲的<code>chunk</code>，在后面<code>purge</code>阶段会看到</li>
</ul>
<p>现在来看一下<code>chunk</code>的申请过程:</p>
<ul>
<li>若<code>spare != NULL</code>，则返回<code>spare</code></li>
<li>从<code>cached</code>中查找</li>
<li>从<code>retained</code>中查找</li>
<li>调用<code>chunk_alloc_mmap()</code>新分配一个<code>chunk</code></li>
</ul>
<p>第2、3步会调用<code>chunk_recycle()</code>实施伙伴算法的分裂过程：从对应的树中进行分配指定大小的<code>chunk</code>，<code>chunk</code>起始地址会按<code>chunk_size</code>对齐。因为需要对齐且大小不一定相等，所以前后需要进行裁剪，<code>leadsize</code>和<code>trailsize</code>也会重新插入树中，留待之后的分配使用。</p>
<p>相对应的，<code>chunk</code>释放过程如下:</p>
<ul>
<li>若<code>spare == NULL</code>，则设置为<code>spare</code></li>
<li>将原先的<code>spare</code>插入到<code>cached</code>中，设置为<code>spare</code></li>
</ul>
<p>第2步会调用<code>chunk_record()</code>实施伙伴算法的合并过程：会查找连续地址空间的前后的<code>chunk</code>在不在树中，如果在的话会进行合并，然后再插入到树中。</p>
<h3 id="arena-chunk-t"><a href="#arena-chunk-t" class="headerlink" title="arena_chunk_t"></a>arena_chunk_t</h3><p><code>run</code>从<code>chunk</code>中分配，同样采用伙伴算法。一整个<code>chunk</code>的内存分为4个部分:</p>
<ul>
<li><code>extent_node_t</code>：记录<code>chunk</code>的状态，用于之后管理<code>chunk</code></li>
<li><code>arena_chunk_map_bits_t</code>：一一对应<code>chunk</code>内每个<code>page</code>，记录从<code>chunk</code>分配出去的<code>run</code>的大小和信息、记录<code>page</code>的分配状态。</li>
<li><code>arena_chunk_map_misc_t</code>：一一对应<code>chunk</code>内每个<code>page</code>对应的<code>run</code></li>
<li><code>page</code>：大小为 4096B</li>
</ul>
<p>这些记录<code>chunk</code>信息的<code>header</code>存放在每个<code>chunk</code>起始地址处，所以会占用掉部分内存。这些<code>header</code>和<code>chunk</code>中的<code>page</code>个数有关，而<code>chunk</code>中减去<code>header</code>的内存又和<code>page</code>的个数有关，所以<code>arena_boot()</code>中使用循环计算<code>header</code>占用的<code>page</code>个数(map_bias):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Compute the header size such that it is large enough to contain the</span></span><br><span class="line"><span class="comment">* page map.  The page map is biased to omit entries for the header</span></span><br><span class="line"><span class="comment">* itself, so some iteration is necessary to compute the map bias.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 1) Compute safe header_size and map_bias values that include enough</span></span><br><span class="line"><span class="comment">*    space for an unbiased page map.</span></span><br><span class="line"><span class="comment">* 2) Refine map_bias based on (1) to omit the header pages in the page</span></span><br><span class="line"><span class="comment">*    map.  The resulting map_bias may be one too small.</span></span><br><span class="line"><span class="comment">* 3) Refine map_bias based on (2).  The result will be &gt;= the result</span></span><br><span class="line"><span class="comment">*    from (2), and will always be correct.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">map_bias = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="type">size_t</span> header_size = offsetof(<span class="type">arena_chunk_t</span>, map_bits) +</span><br><span class="line">        ((<span class="keyword">sizeof</span>(<span class="type">arena_chunk_map_bits_t</span>) +</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="type">arena_chunk_map_misc_t</span>)) * (chunk_npages-map_bias));</span><br><span class="line">    map_bias = (header_size + PAGE_MASK) &gt;&gt; LG_PAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>header</code>使用连续内存存放而不是每个<code>page</code>头部存放有如下好处:</p>
<ul>
<li>提高<code>header</code>的缓存局部性</li>
<li>提高<code>page</code>中分配出去的缓存局部性</li>
<li>可以减少<code>rss</code>占用，因为操作系统按照<code>page</code>管理虚拟地址，若每个空闲<code>page</code>都有些<code>header</code>占用，会使一整个<code>page</code>驻留在内存中</li>
</ul>
<p><code>arena_chunk_map_bits_t</code>在64位系统上，共有<code>64bits</code>，记录了<code>chunk</code>内每个<code>page</code>的分配情况，这些信息用于快速的查找<code>metadata</code>。对于不同状态的<code>page</code>有不同的格式:</p>
<ul>
<li>未分配<code>page</code>：连续、未分配的<code>page</code>会作为一个整体，由起始<code>page</code>对应的<code>run</code>进行管理。首尾<code>page</code>对应的<code>arena_chunk_map_bits_t</code>中会设置连续的空闲<code>page</code>的数量，中间的<code>page</code>不设置。同时，管理这些空闲<code>page</code>的<code>run</code>会插入到<code>runs_avail</code>中，该<code>run</code>的大小就是整个空闲<code>page</code>的大小(从<code>arena_chunk_map_bits_t</code>中获取)</li>
<li>已分配的<code>run</code>对应的<code>page</code>：每个<code>page</code>会设置该<code>page</code>是<code>run</code>中第几个<code>page</code>(<code>run page offset</code>)，并且设置<code>run</code>对应的<code>bin id</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Run address (or size) and various flags are stored together.  The bit</span></span><br><span class="line"><span class="comment">* layout looks like (assuming 32-bit system):</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   ???????? ???????? ???nnnnn nnndumla</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ? : Unallocated: Run address for first/last pages, unset for internal</span></span><br><span class="line"><span class="comment">*                  pages.</span></span><br><span class="line"><span class="comment">*     Small: Run page offset.</span></span><br><span class="line"><span class="comment">*     Large: Run page count for first page, unset for trailing pages.</span></span><br><span class="line"><span class="comment">* n : binind for small size class, BININD_INVALID for large size class.</span></span><br><span class="line"><span class="comment">* d : dirty?</span></span><br><span class="line"><span class="comment">* u : unzeroed?</span></span><br><span class="line"><span class="comment">* m : decommitted?</span></span><br><span class="line"><span class="comment">* l : large?</span></span><br><span class="line"><span class="comment">* a : allocated?</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Following are example bit patterns for the three types of runs.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* p : run page offset (这个page是run中第几个page (offset))</span></span><br><span class="line"><span class="comment">* s : run size (连续的空闲 page 个数)</span></span><br><span class="line"><span class="comment">* n : binind for size class; large objects set these to BININD_INVALID(该 page 对应的 bin Id)</span></span><br><span class="line"><span class="comment">* x : don&#x27;t care</span></span><br><span class="line"><span class="comment">* - : 0</span></span><br><span class="line"><span class="comment">* + : 1</span></span><br><span class="line"><span class="comment">* [DUMLA] : bit set</span></span><br><span class="line"><span class="comment">* [dumla] : bit unset</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Unallocated (clean):</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++dum-a</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxx-Uxxx</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++dUm-a</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Unallocated (dirty):</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++D-m-a</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++D-m-a</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Small:</span></span><br><span class="line"><span class="comment">*     pppppppp pppppppp pppnnnnn nnnd---A</span></span><br><span class="line"><span class="comment">*     pppppppp pppppppp pppnnnnn nnn----A</span></span><br><span class="line"><span class="comment">*     pppppppp pppppppp pppnnnnn nnnd---A</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Large:</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span></span><br><span class="line"><span class="comment">*     -------- -------- ---+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Large (sampled, size &lt;= LARGE_MINCLASS):</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sssnnnnn nnnD--LA</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span></span><br><span class="line"><span class="comment">*     -------- -------- ---+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Large (not sampled, size == LARGE_MINCLASS):</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span></span><br><span class="line"><span class="comment">*     -------- -------- ---+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>arena_chunk_map_misc_t</code>顾名思义，有很多用途，主要用于记录<code>run</code>的<code>metadata</code>。<code>run</code>大小是<code>page size</code>倍数，每个<code>run</code>会由起始<code>page</code>对应的<code>arena_chunk_map_misc_t</code>中的<code>run</code>管理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_chunk_map_misc_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Linkage for run trees.  There are two disjoint uses:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1) arena_t&#x27;s runs_avail tree.</span></span><br><span class="line"><span class="comment">	 * 2) arena_run_t conceptually uses this linkage for in-use non-full</span></span><br><span class="line"><span class="comment">	 *    runs, rather than directly embedding linkage.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rb_node(<span class="type">arena_chunk_map_misc_t</span>)		rb_link;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* Linkage for list of dirty runs. */</span></span><br><span class="line">		<span class="type">arena_runs_dirty_link_t</span>		rd;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Profile counters, used for large object runs. */</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">			<span class="type">void</span>				*prof_tctx_pun;</span><br><span class="line">			<span class="type">prof_tctx_t</span>			*prof_tctx;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Small region run metadata. */</span></span><br><span class="line">		<span class="type">arena_run_t</span>			run;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来看一下如何从<code>chunk</code>中分配<code>run</code>。</p>
<p>第一个<code>chunk</code>是调用<code>chunk_alloc_mmap()</code>分配的，然后调用<code>arena_mapbits_unallocated_set()</code>设置首尾<code>page</code>对应的<code>arena_chunk_map_bits_t</code>，然后将整个空闲<code>chunk</code>作为大小为<code>arena_maxrun</code>的空闲<code>run</code>插入到<code>runs_avail</code>中:<br><img src="/img/20211102100902.png" alt=""></p>
<p>然后调用<code>arena_run_split_small()</code>将该<code>run</code>分解为对应的<code>bin</code>管理的<code>run</code>:</p>
<ul>
<li>从<code>run</code>中分配出需要的<code>page</code>，多余的<code>page</code>会设置首尾<code>page</code>对应的<code>map_bits</code>，再次插入到<code>avail_runs</code>中留待后续分配</li>
<li>设置分配出去的<code>run</code>对应的<code>map_bits</code>，返回分配出去的第一个<code>page</code>对应的<code>misc</code>中的<code>run</code></li>
<li>之后<code>run</code>就会有对应的<code>bin</code>进行管理</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">arena_run_split_small</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_run_t</span> *run, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">    <span class="type">szind_t</span> binind)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">arena_chunk_t</span> *chunk;</span><br><span class="line">	<span class="type">arena_chunk_map_misc_t</span> *miscelm;</span><br><span class="line">	<span class="type">size_t</span> flag_dirty, flag_decommitted, run_ind, need_pages, i;</span><br><span class="line"></span><br><span class="line">	assert(binind != BININD_INVALID);</span><br><span class="line"></span><br><span class="line">	chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(run);</span><br><span class="line">	miscelm = arena_run_to_miscelm(run);</span><br><span class="line">	run_ind = arena_miscelm_to_pageind(miscelm);</span><br><span class="line">	flag_dirty = arena_mapbits_dirty_get(chunk, run_ind);</span><br><span class="line">	flag_decommitted = arena_mapbits_decommitted_get(chunk, run_ind);</span><br><span class="line">        <span class="comment">// size 是 bin 对应的 run_size </span></span><br><span class="line">	need_pages = (size &gt;&gt; LG_PAGE);</span><br><span class="line">	assert(need_pages &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag_decommitted != <span class="number">0</span> &amp;&amp; arena-&gt;chunk_hooks.commit(chunk, chunksize,</span><br><span class="line">	    run_ind &lt;&lt; LG_PAGE, size, arena-&gt;ind))</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	arena_run_split_remove(arena, chunk, run_ind, flag_dirty,</span><br><span class="line">	    flag_decommitted, need_pages);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置分配出去的 page 对应的 map_bits</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; need_pages; i++) &#123;</span><br><span class="line">		<span class="type">size_t</span> flag_unzeroed = arena_mapbits_unzeroed_get(chunk,</span><br><span class="line">		    run_ind+i);</span><br><span class="line">		arena_mapbits_small_set(chunk, run_ind+i, i, binind,</span><br><span class="line">		    flag_unzeroed);</span><br><span class="line">		<span class="keyword">if</span> (config_debug &amp;&amp; flag_dirty == <span class="number">0</span> &amp;&amp; flag_unzeroed == <span class="number">0</span>)</span><br><span class="line">			arena_run_page_validate_zeroed(chunk, run_ind+i);</span><br><span class="line">	&#125;</span><br><span class="line">	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED((<span class="type">void</span> *)((<span class="type">uintptr_t</span>)chunk +</span><br><span class="line">	    (run_ind &lt;&lt; LG_PAGE)), (need_pages &lt;&lt; LG_PAGE));</span><br><span class="line">	<span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 run_ind 对应 run 中分配出 need_pages，剩余的再次插入到 avail_runs 中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_run_split_remove</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">size_t</span> run_ind,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> flag_dirty, <span class="type">size_t</span> flag_decommitted, <span class="type">size_t</span> need_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> total_pages, rem_pages;</span><br><span class="line"></span><br><span class="line">	assert(flag_dirty == <span class="number">0</span> || flag_decommitted == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	total_pages = arena_mapbits_unallocated_size_get(chunk, run_ind) &gt;&gt;</span><br><span class="line">	    LG_PAGE;</span><br><span class="line">	assert(arena_mapbits_dirty_get(chunk, run_ind+total_pages<span class="number">-1</span>) ==</span><br><span class="line">	    flag_dirty);</span><br><span class="line">	assert(need_pages &lt;= total_pages);</span><br><span class="line">	rem_pages = total_pages - need_pages;</span><br><span class="line"></span><br><span class="line">	arena_avail_remove(arena, chunk, run_ind, total_pages);</span><br><span class="line">	<span class="keyword">if</span> (flag_dirty != <span class="number">0</span>)</span><br><span class="line">		arena_run_dirty_remove(arena, chunk, run_ind, total_pages);</span><br><span class="line">	arena_cactive_update(arena, need_pages, <span class="number">0</span>);</span><br><span class="line">	arena-&gt;nactive += need_pages;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Keep track of trailing unused pages for later use. */</span></span><br><span class="line">	<span class="keyword">if</span> (rem_pages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">size_t</span> flags = flag_dirty | flag_decommitted;</span><br><span class="line">		<span class="type">size_t</span> flag_unzeroed_mask = (flags == <span class="number">0</span>) ?  CHUNK_MAP_UNZEROED :</span><br><span class="line">		    <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置 run 对应的 page 的信息，设置开头和结尾的 page 对应的 map_bits 的</span></span><br><span class="line">            <span class="comment">// 未分配内存大小</span></span><br><span class="line">		arena_mapbits_unallocated_set(chunk, run_ind+need_pages,</span><br><span class="line">		    (rem_pages &lt;&lt; LG_PAGE), flags |</span><br><span class="line">		    (arena_mapbits_unzeroed_get(chunk, run_ind+need_pages) &amp;</span><br><span class="line">		    flag_unzeroed_mask));</span><br><span class="line">		arena_mapbits_unallocated_set(chunk, run_ind+total_pages<span class="number">-1</span>,</span><br><span class="line">		    (rem_pages &lt;&lt; LG_PAGE), flags |</span><br><span class="line">		    (arena_mapbits_unzeroed_get(chunk, run_ind+total_pages<span class="number">-1</span>) &amp;</span><br><span class="line">		    flag_unzeroed_mask));</span><br><span class="line">		<span class="keyword">if</span> (flag_dirty != <span class="number">0</span>) &#123;</span><br><span class="line">			arena_run_dirty_insert(arena, chunk, run_ind+need_pages,</span><br><span class="line">			    rem_pages);</span><br><span class="line">		&#125;</span><br><span class="line">		arena_avail_insert(arena, chunk, run_ind+need_pages, rem_pages);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20211102100903.png" alt=""></p>
<p>当<code>bin</code>中有完全空闲的<code>run</code>时，会返回给<code>arena</code>管理:</p>
<ul>
<li>调用<code>arena_dissociate_bin_run()</code>解除该<code>run</code>和<code>bin</code>的关系:</li>
<li>若该<code>run</code>为<code>bin-&gt;runcur</code>，设置<code>bin-&gt;runcur =NULL</code></li>
<li>从<code>bin-&gt;runs</code>中移除</li>
<li>调用<code>arena_run_coalesce()</code>尝试合并相邻的空闲<code>run</code></li>
<li>将<code>run</code>插入到<code>avail_runs</code>中</li>
<li>若该<code>run</code>大小已经达到<code>arena_maxrun</code>，表明整个<code>chunk</code>都是空闲的，调用<code>arena_chunk_dalloc()</code>释放<code>run</code></li>
</ul>
<h2 id="2-Basic-structures"><a href="#2-Basic-structures" class="headerlink" title="2 - Basic structures"></a>2 - Basic structures</h2><p>相对于Dl, Je引入了更多更复杂的分配结构，如arena，chunk，bin，run，region，tcache等等。其中有些类似Dl，但更多的具有不同含义，本节将对它们做一一介绍。</p>
<h3 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1 - Overview"></a>2.1 - Overview</h3><p>首先，先给出一个整体的概念。Je对内存划分按照如下由高到低的顺序，</p>
<ol>
<li>内存是由一定数量的arenas进行管理。</li>
<li>一个arena被分割成若干chunks，后者主要负责记录bookkeeping.</li>
<li>chunk内部又包含着若干runs，作为分配小块内存的基本单元。</li>
<li>run由pages组成，最终被划分成一定数量的regions,</li>
<li>对于small size的分配请求来说，这些region就相当于user memory.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    Arena #0</span><br><span class="line">+----------------------------------------------------------------------------+</span><br><span class="line">|                                                                            |</span><br><span class="line">|    Chunk #0                             Chunk #1                           |</span><br><span class="line">|  +---------------------------------+  +---------------------------------+  |</span><br><span class="line">|  |                                 |  |                                 |  |</span><br><span class="line">|  |   Run #0          Run #1        |  |   Run #0          Run #1        |  |</span><br><span class="line">|  | +-------------+ +-------------+ |  | +-------------+ +-------------+ |  |</span><br><span class="line">|  | |             | |             | |  | |             | |             | |  |</span><br><span class="line">|  | |   Page      | |   Page      | |  | |   Page      | |   Page      | |  |</span><br><span class="line">|  | | +---------+ | | +---------+ | |  | | +---------+ | | +---------+ | |  |</span><br><span class="line">|  | | |         | | | |         | | |  | | |         | | | |         | | |  |</span><br><span class="line">|  | | | Regions | | | | Regions | | |  | | | Regions | | | | Regions | | |  |</span><br><span class="line">|  | | |[] [] [] | | | |[] [] [] | | |  | | |[] [] [] | | | |[] [] [] | | |  |</span><br><span class="line">|  | | |         | | | |         | | |  | | |         | | | |         | | |  |</span><br><span class="line">|  | | +---------+ | | +---------+ | |  | | +---------+ | | +---------+ | |  |  </span><br><span class="line">|  | |             | |             | |  | |             | |             | |  |</span><br><span class="line">|  | |   Page      | |   Page      | |  | |   Page      | |   Page      | |  |</span><br><span class="line">|  | | +---------+ | | +---------+ | |  | | +---------+ | | +---------+ | |  |</span><br><span class="line">|  | | |         | | | |         | | |  | | |         | | | |         | | |  |</span><br><span class="line">|  | | | ...     | | | | ...     | | |  | | | ...     | | | | ...     | | |  |</span><br><span class="line">|  | | +---------+ | | +---------+ | |  | | +---------+ | | +---------+ | |  |</span><br><span class="line">|  | +-------------+ +-------------+ |  | +-------------+ +-------------+ |  |</span><br><span class="line">|  +---------------------------------+  +---------------------------------+  |</span><br><span class="line">+----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Arena-arena-t"><a href="#2-2-Arena-arena-t" class="headerlink" title="2.2 - Arena (arena_t)"></a>2.2 - Arena (arena_t)</h3><p>如前所述，Arena是Je中最大或者说最顶层的基础结构。这个概念其实上是针对”对称多处理机(SMP)”产生的。在SMP中，导致性能劣化的一个重要原因在于”false sharing”导致cache-line失效。</p>
<p>为了解决cache-line共享问题，同时保证更少的内部碎片(internal fragmentation)，Je使用了arena。</p>
<h4 id="2-2-1-CPU-Cache-Line"><a href="#2-2-1-CPU-Cache-Line" class="headerlink" title="2.2.1 - CPU Cache-Line"></a>2.2.1 - CPU Cache-Line</h4><p>Cache是嵌入到cpu内部的一组SRAM，速度是主存的N倍，但造价较高，因此一般容量很小。有些cpu设计了容量逐级逐渐增大的多级cache，但速度逐级递减。多级处理更复杂，但原理类似，为了简化，仅讨论L1 data cache。</p>
<p>cache同主存进行数据交换有一个最小粒度，称为cache-line，通常这个值为64。例如在一个ILP32的机器上，一次cache交换可以读写连续16个int型数据。因此当访问数组#0元素时，后面15个元素也被同时”免费”读到了cache中，这对于数组的连续访问是非常有利的。</p>
<p>然而这种免费加载不总是会带来好处，有时候甚至起到反效果，所谓”false sharing”。试想两个线程A和B分别执行在不同的cpu核心中并分别操作各自上下文中的变量x和y，如果因为某种原因(比如x，y可能位于同一个class内部，或者分别是数组中的两个相邻元素)，两者位于相同的cache-line中，则在两个core的L1 cache里都存在x和y的副本。</p>
<p>倘若线程A修改了x的值，就会导致在B中的x与A中看到的不一致。尽管这个变量x对B可能毫无用处，但cpu为了保证前后的正确和一致性，只能判定core #1的cache失效。因此core #0必须将cache-line回写到主存，然后core #1再重新加载cache-line，反之亦然。如果恰好两个线程交替操作同一cache-line中的数据，将对cache将造成极大的损害，导致严重的性能退化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+        +-----------------------+</span><br><span class="line">| core #0               |        | core #1               |</span><br><span class="line">|                       |        |                       |</span><br><span class="line">|  +----------+         |        |  +----------+         |</span><br><span class="line">|  | ThreadA  |         |        |  | ThreadB  |         |</span><br><span class="line">|  +----------+         |        |  +----------+         |</span><br><span class="line">|        |              |        |        |              |</span><br><span class="line">|    +---+              |        |        |              |</span><br><span class="line">|    |                  |        |        |              |</span><br><span class="line">|    v        D-cache   |        |        v     D-cache  |</span><br><span class="line">|  +-----------------+  |        |  +-----------------+  |</span><br><span class="line">|  | x&#x27;| y | ... ... | &lt;---+  +---&gt; | x | y&#x27;| ... ... |  |</span><br><span class="line">|  |-----------------|  |  |  |  |  |-----------------|  |</span><br><span class="line">|  |    ... ...      |  |  |  |  |  |    ... ...      |  |</span><br><span class="line">|  |    ... ...      |  |  |  |  |  |    ... ...      |  |</span><br><span class="line">|  |    ... ...      |  |  |  |  |  |    ... ...      |  |</span><br><span class="line">|  +-----------------+  |  |  |  |  +-----------------+  |</span><br><span class="line">+-----------------------+  |  |  +-----------------------+</span><br><span class="line">                           |  |  </span><br><span class="line">                    +------+  |</span><br><span class="line">                    |         |</span><br><span class="line">                    v         v</span><br><span class="line">   memory   +-----------------------------</span><br><span class="line">            | ... | x | y |     ... ...     </span><br><span class="line">            +-----------------------------</span><br></pre></td></tr></table></figure>
<p>说到底，从程序的角度看，变量是独立的地址单元，但在CPU看来则是以cache-line为整体的单元。单独的变量竞争可以在代码中增加同步来解决，而cache-line的竞争是透明的，不可控的，只能被动由CPU仲裁。这种观察角度和处理方式的区别，正是false sharing的根源。</p>
<h4 id="2-2-2-Arena原理"><a href="#2-2-2-Arena原理" class="headerlink" title="2.2.2 - Arena原理"></a>2.2.2 - Arena原理</h4><p>回到memory allocator的话题上。对于一个多线程+多CPU核心的运行环境，传统分配器中大量开销被浪费在lock contention和false sharing上，随着线程数量和核心数量增多，这种分配压力将越来越大。</p>
<p>针对多线程，一种解决方法是将一把global lock分散成很多与线程相关的lock。而针对多核心，则要尽量把不同线程下分配的内存隔离开，避免不同线程使用同一个cache-line的情况。按照上面的思路，一个较好的实现方式就是引入arena。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+---------+     +---------+     +---------+     +---------+     +---------+</span><br><span class="line">| threadA |     | threadB |     | threadC |     | threadD |     | threadE |     </span><br><span class="line">+---------+     +---------+     +---------+     +---------+     +---------+</span><br><span class="line">     |               |               |               |               |</span><br><span class="line">     |               +---------------|---------------|---------+     |</span><br><span class="line">     +------------------+    +-------+        +------+         |     |</span><br><span class="line">      +-----------------|----|----------------|----------------|-----+  </span><br><span class="line">      |                 |    |                |                |</span><br><span class="line">      v                 v    v                v                v</span><br><span class="line">+----------+        +----------+        +----------+        +----------+     </span><br><span class="line">|          |        |          |        |          |        |          |</span><br><span class="line">| Arena #0 |        | Arena #1 |        | Arena #2 |        | Arena #3 |</span><br><span class="line">|          |        |          |        |          |        |          |</span><br><span class="line">+----------+        +----------+        +----------+        +----------+</span><br></pre></td></tr></table></figure>
<p>Je将内存划分成若干数量的arenas，线程最终会与某一个arena绑定。比如上图中的threadA和B就分别绑定到arena #1和#3上。由于两个arena在地址空间上几乎不存在任何联系，就可以在无锁的状态下完成分配。同样由于空间不连续，落到同一个cache-line中的几率也很小，保证了各自独立。</p>
<p>由于arena的数量有限，因此不能保证所有线程都能独占arena，比如，图中threadA和C就都绑定到了arena1上。分享同一个arena的所有线程，由该arena内部的lock保持同步。</p>
<p>Je将arena保存到一个数组中，该数组全局记录了所有arenas，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_t</span>            **arenas;</span><br></pre></td></tr></table></figure></p>
<p>事实上，该数组是动态分配的，arenas仅仅是一个数组指针。默认情况下arenas数组的长度与如下变量相关，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span>    narenas_total;</span><br><span class="line"><span class="type">unsigned</span>    narenas_auto;</span><br><span class="line"><span class="type">size_t</span>        opt_narenas = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>而它们又与当前cpu核心数量相关。核心数量记录在另外一个全局变量<code>ncpus</code>里，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span>    ncpus;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>ncpus</code>等于1，则有且仅有一个arena，如果大于1，则默认arenas的数量为<code>ncpus</code>的四倍。即双核下8个arena，四核下16个arena，依此类推。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p ncpus</span><br><span class="line">$<span class="number">20</span> = <span class="number">4</span></span><br><span class="line">(gdb) p narenas_total</span><br><span class="line">$<span class="number">21</span> = <span class="number">16</span></span><br></pre></td></tr></table></figure></p>
<p>jemalloc变体很多，不同变体对arenas的数量有所调整，比如firefox中arena固定为1，而android被限定为最大不超过2. 这个限制被写到android jemalloc的mk文件中。</p>
<h4 id="2-2-3-choose-arena"><a href="#2-2-3-choose-arena" class="headerlink" title="2.2.3 - choose_arena"></a>2.2.3 - choose_arena</h4><p>最早引入arena并非由Je首创，但早期线程与arena绑定是通过hash线程id实现的，相对来说随机性比较强。Je改进了绑定的算法，使之更加科学合理。</p>
<p>Je中线程与arena绑定由函数<code>choose_arena</code>完成，被绑定的arena记录在该线程的tls中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="type">arena_t</span> *</span><br><span class="line"><span class="title function_">choose_arena</span><span class="params">(<span class="type">arena_t</span> *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">// xf: 通常情况下线程所绑定的arena记录在arenas_tls中</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = *arenas_tsd_get()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// xf: 如果当前thread未绑定arena，则为其指定一个，并保存到tls</span></span><br><span class="line">        ret = choose_arena_hard();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初次搜索<code>arenas_tsd_get</code>可能找不到该函数在何处被定义。实际上，Je使用了一组宏，来生成一个函数族，以达到类似函数模板的目的。<code>tsd</code>相关的函数族被定义在<code>tsd.h</code>中。</p>
<ol>
<li><code>malloc_tsd_protos</code> - 定义了函数声明，包括初始化函数boot, get/set函数</li>
<li><code>malloc_tsd_externs</code> - 定义变量声明，包括tls，初始化标志等等</li>
<li><code>malloc_tsd_data</code> - tls变量定义</li>
<li><code>malloc_tsd_funcs</code> - 定义了1中声明函数的实现。</li>
</ol>
<p>与<code>arena tsd</code>相关的函数和变量声明如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">malloc_tsd_protos(JEMALLOC_ATTR(unused), arenas, <span class="type">arena_t</span> *)</span><br><span class="line">malloc_tsd_externs(arenas, <span class="type">arena_t</span> *)</span><br><span class="line">malloc_tsd_data(, arenas, <span class="type">arena_t</span> *, <span class="literal">NULL</span>)</span><br><span class="line">malloc_tsd_funcs(JEMALLOC_ALWAYS_INLINE, arenas, <span class="type">arena_t</span> *, <span class="literal">NULL</span>, arenas_cleanup)</span><br></pre></td></tr></table></figure></p>
<p>当线程还未与任何arena绑定时，会进一步通过<code>choose_arena_hard</code>寻找一个合适的<code>arena</code>进行绑定。Je会遍历arenas数组，并按照优先级由高到低的顺序挑选，</p>
<ol>
<li>如果找到当前线程绑定数为0的arena，则优先使用它。</li>
<li>如果当前已初始化arena中没有线程绑定数为0的，则优先使用剩余空的数组位置构造一个新的arena. 需要说明的是，arenas数组遵循lazy create原则，初始状态整个数组只有0号元素是被初始化的，其他的slot位置都是null指针。因此随着新的线程不断创造出来，arena数组也被逐渐填满。</li>
<li>如果1，2两条都不满足，则选择当前绑定数最小的，且slot位置更靠前的一个arena。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_t</span> * <span class="title function_">choose_arena_hard</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (narenas_auto &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        first_null = narenas_auto;</span><br><span class="line">        <span class="comment">// xf: 循环遍历所有arenas，找到绑定thread数量最小的arena，并记录</span></span><br><span class="line">        <span class="comment">// first_null索引值</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; narenas_auto; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arenas[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arenas[i]-&gt;nthreads &lt;</span><br><span class="line">                    arenas[choose]-&gt;nthreads)</span><br><span class="line">                    choose = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first_null == narenas_auto) &#123;</span><br><span class="line">                first_null = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 若选定的arena绑定thread为0，或者当前arena数组中已满，则返回</span></span><br><span class="line">        <span class="comment">// 被选中的arena</span></span><br><span class="line">        <span class="keyword">if</span> (arenas[choose]-&gt;nthreads == <span class="number">0</span></span><br><span class="line">            || first_null == narenas_auto) &#123;</span><br><span class="line">            ret = arenas[choose];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// xf: 否则构造并初始化一个新的arena</span></span><br><span class="line">            ret = arenas_extend(first_null);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// xf: 若不存在多于一个arena(单核cpu或人为强制设定)，则返回唯一的</span></span><br><span class="line">        <span class="comment">// 0号arena</span></span><br><span class="line">        ret = arenas[<span class="number">0</span>];</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 将已绑定的arena设置到tsd中</span></span><br><span class="line">    arenas_tsd_set(&amp;ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比早期的绑定方式，Je的算法显然更加公平，尽可能的让各个cpu核心平分当前线程，平衡负载。</p>
<h4 id="2-2-4-Arena结构"><a href="#2-2-4-Arena结构" class="headerlink" title="2.2.4 - Arena结构"></a>2.2.4 - Arena结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_s</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span>        ind;        </span><br><span class="line">    <span class="type">unsigned</span>        nthreads;   </span><br><span class="line">    <span class="type">malloc_mutex_t</span>        lock;</span><br><span class="line">    <span class="type">arena_stats_t</span>        stats;  </span><br><span class="line">    ql_head(<span class="type">tcache_t</span>)    tcache_ql;</span><br><span class="line">    <span class="type">uint64_t</span>        prof_accumbytes;</span><br><span class="line">    <span class="type">dss_prec_t</span>        dss_prec;   </span><br><span class="line">    <span class="type">arena_chunk_tree_t</span>    chunks_dirty;</span><br><span class="line">    <span class="type">arena_chunk_t</span>        *spare;</span><br><span class="line">    <span class="type">size_t</span>            nactive;</span><br><span class="line">    <span class="type">size_t</span>            ndirty;</span><br><span class="line">    <span class="type">size_t</span>            npurgatory;</span><br><span class="line">    <span class="type">arena_avail_tree_t</span>    runs_avail;</span><br><span class="line">    <span class="type">chunk_alloc_t</span>        *chunk_alloc;</span><br><span class="line">    <span class="type">chunk_dalloc_t</span>        *chunk_dalloc;</span><br><span class="line">    <span class="type">arena_bin_t</span>        bins[NBINS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ind</code>: 在arenas数组中的索引值。</li>
<li><code>nthreads</code>: 当前绑定的线程数。</li>
<li><code>lock</code>: 局部arena lock，取代传统分配器的global lock。一般地，如下操作需要arena lock同步，<ul>
<li>线程绑定，需要修改nthreads</li>
<li>new chunk alloc</li>
<li>new run alloc</li>
</ul>
</li>
<li><code>stats</code>: 全局统计，需要打开统计功能。</li>
<li><code>tcache_ql</code>: ring queue，注册所有绑定线程的tcache，作为统计用途，需要打开统计功能。</li>
<li><code>dss_prec</code>: 代表当前chunk alloc时对系统内存的使用策略，分为几种情况，　　　　　</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  dss_prec_disabled  = <span class="number">0</span>,</span><br><span class="line">  dss_prec_primary   = <span class="number">1</span>,</span><br><span class="line">  dss_prec_secondary = <span class="number">2</span>,</span><br><span class="line">  dss_prec_limit     = <span class="number">3</span></span><br><span class="line">&#125; <span class="type">dss_prec_t</span>;</span><br></pre></td></tr></table></figure>
<p>第一个代表禁止使用系统DSS，后两种代表是否优先选用DSS。如果使用<code>primary</code>，则本着先<code>dss-&gt;mmap</code>的顺序，否则按照先<code>mmap-&gt;dss</code>。默认使用<code>dss_prec_secondary</code>。</p>
<ul>
<li><code>chunks_dirty</code>: rb tree，代表所有包含dirty page的chunk集合。后面在chunk中会详细介绍。</li>
<li><code>spare</code>: 是一个缓存变量，记录最近一次被释放的chunk。当arena收到一个新的chunk alloc请求时，会优先从spare中开始查找，由此提高频繁分配释放时，可能导致内部chunk利用率下降的情况。</li>
<li><code>runs_avail</code>: rb tree，记录所有未被分配的runs，用来在分配new run时寻找合适的available run。一般作为alloc run时的仓库。</li>
<li><code>chunk_alloc</code>/<code>chunk_dalloc</code>: 用户可定制的chunk分配/释放函数，Je提供了默认的版本，<code>chunk_alloc_default</code>/<code>chunk_dalloc_default</code></li>
<li><code>bins</code>: bins数组，记录不同class size可用free regions的分配信息，后面会详细介绍。</li>
</ul>
<h3 id="2-3-Chunk-arena-chunk-t"><a href="#2-3-Chunk-arena-chunk-t" class="headerlink" title="2.3 - Chunk (arena_chunk_t)"></a>2.3 - Chunk (arena_chunk_t)</h3><p>chunk是仅次于arena的次级内存结构。如果有了解过Dlmalloc，就会知道在Dl中同样定义了名为’chunk’的基础结构。但这个概念在两个分配器中含义完全不同，Dl中的chunk指代最低级分配单元，而Je中则是一个较大的内存区域。</p>
<h4 id="2-3-1-overview"><a href="#2-3-1-overview" class="headerlink" title="2.3.1 - overview"></a>2.3.1 - overview</h4><p>从前面arena的数据结构可以发现，它是一个非常抽象的概念，其大小也不代表实际的内存分配量。原始的内存数据既非挂载在arena外部，也并没有通过内部指针引用，而是记录在chunk中。按照一般的思路，chunk包含原始内存数据，又从属于arena，因此后者应该会有一个数组之类的结构以记录所有chunk信息。但事实上同样找不到这样的记录。那Je又如何获得chunk指针呢?</p>
<p>所谓的chunk结构，只是整个chunk的一个header，bookkeeping以及user memory都挂在header外面。另外Je对chunk又做了规定，默认每个chunk大小为4MB，同时还必须对齐到4MB的边界上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    LG_CHUNK_DEFAULT    22</span></span><br></pre></td></tr></table></figure></p>
<p>这个宏定义了chunk的大小。注意到前缀<code>LG_</code>，代表log即指数部分。Je中所有该前缀的代码都是这个含义，便于通过bit操作进行快速的运算。</p>
<p>有了上述规定，获得chunk就变得几乎没有代价。因为返回给user程序的内存地址肯定属于某个chunk，而该chunk header对齐到4M边界上，且不可能超过4M大小，所以只需要对该地址做一个下对齐就得到chunk指针，如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    CHUNK_ADDR2BASE(a)                        \</span></span><br><span class="line"><span class="meta">    ((void *)((uintptr_t)(a) &amp; ~chunksize_mask))</span></span><br></pre></td></tr></table></figure></p>
<p>计算相对于chunk header的偏移量，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    CHUNK_ADDR2OFFSET(a)                        \</span></span><br><span class="line"><span class="meta">    ((size_t)((uintptr_t)(a) &amp; chunksize_mask))</span></span><br></pre></td></tr></table></figure></p>
<p>以及上对齐到chunk边界的计算，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    CHUNK_CEILING(s)                        \</span></span><br><span class="line"><span class="meta">    (((s) + chunksize_mask) &amp; ~chunksize_mask)</span></span><br></pre></td></tr></table></figure></p>
<p>用图来表示如下，  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chunk_ptr(4M aligned)                memory for user</span><br><span class="line"> |                                   |</span><br><span class="line"> v                                   v</span><br><span class="line"> +--------------+--------------------------------------------</span><br><span class="line"> | chunk header |        ... ...     | region |   ... ...     </span><br><span class="line"> +--------------+--------------------------------------------</span><br><span class="line"> |&lt;------------- offset ------------&gt;|</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-Chunk结构"><a href="#2-3-2-Chunk结构" class="headerlink" title="2.3.2 - Chunk结构"></a>2.3.2 - Chunk结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_chunk_s</span> &#123;</span></span><br><span class="line">    <span class="type">arena_t</span>            *arena;</span><br><span class="line">    rb_node(<span class="type">arena_chunk_t</span>)    dirty_link;</span><br><span class="line">    <span class="type">size_t</span>            ndirty;</span><br><span class="line">    <span class="type">size_t</span>            nruns_avail;</span><br><span class="line">    <span class="type">size_t</span>            nruns_adjac;</span><br><span class="line">    <span class="type">arena_chunk_map_t</span>    <span class="built_in">map</span>[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>arena</code>: chunk属于哪个arena</li>
<li><code>dirty_link</code>: 用于rb tree的链接节点。如果某个chunk内部含有任何dirty page，就会被挂载到arena中的chunks_dirty tree上。</li>
<li><code>ndirty</code>: 内部dirty page数量。</li>
<li><code>nruns_avail</code>: 内部available runs数量。</li>
<li><code>nruns_adjac</code>: available runs又分为dirty和clean两种，相邻的两种run是无法合并的，除非其中的dirty runs通过purge才可以。该数值记录的就是可以通过purge合并的run数量。</li>
<li><code>map</code>: 动态数组，每一项对应chunk中的一个page状态(不包含header即map本身的占用)。chunk(包括内部的run)都是由page组成的。<ul>
<li>page又分为unallocated，small，large三种。</li>
<li>unallocated指的那些还未建立run的page。</li>
<li>small/large分别指代该page所属run的类型是small/large run。</li>
<li>这些page的分配状态，属性，偏移量，及其他的标记信息等等，都记录在arena_chunk_map_t中。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|&lt;--------- map_bias -----------&gt;|</span><br><span class="line">| page | page |  ... ...  | page |</span><br><span class="line">+-----------------------------------------------------------------------+</span><br><span class="line">| chunk_header |    chunk <span class="built_in">map</span>    | page #<span class="number">0</span>  | page #<span class="number">1</span>  | ... | page <span class="meta">#n  |</span></span><br><span class="line">|    ... ...   | [<span class="number">0</span>] [<span class="number">1</span>] ... [n] |          |          |     |          |</span><br><span class="line">+-----------------|---|-------|-----------------------------------------+</span><br><span class="line">                  |   |       |       ^          ^                 ^</span><br><span class="line">                  +---|-------|-------+          |                 |</span><br><span class="line">                      +-------|------------------+                 |</span><br><span class="line">                              + -----------------------------------+</span><br></pre></td></tr></table></figure>
<p>至于由chunk header和chunk map占用的page数量，保存在map_bias变量中。该变量是Je在arena boot时通过迭代算法预先计算好的，所有chunk都是相同的。迭代方法如下，</p>
<ol>
<li>第一次迭代初始map_bias等于0，计算最大可能大小，即<code>header_size + chunk_npages * map_size</code>获得header+map需要的page数量，结果肯定高于最终的值。</li>
<li>第二次将之前计算的map_bias迭代回去，将最大page数减去map_bias数，重新计算header+map大小，由于第一次迭代map_bias过大，第二次迭代必定小于最终结果。</li>
<li>第三次再将map_bias迭代回去，得到最终大于第二次且小于第一次的计算结果。</li>
</ol>
<p>相关代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_boot</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    map_bias = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        header_size = offsetof(<span class="type">arena_chunk_t</span>, <span class="built_in">map</span>) +</span><br><span class="line">            (<span class="keyword">sizeof</span>(<span class="type">arena_chunk_map_t</span>) * (chunk_npages-map_bias));</span><br><span class="line">        map_bias = (header_size &gt;&gt; LG_PAGE) + ((header_size &amp; PAGE_MASK)</span><br><span class="line">            != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-chunk-map-arena-chunk-map-t"><a href="#2-3-3-chunk-map-arena-chunk-map-t" class="headerlink" title="2.3.3 - chunk map (arena_chunk_map_t)"></a>2.3.3 - chunk map (arena_chunk_map_t)</h4><p>chunk记录page状态的结构为<code>arena_chunk_map_t</code>，为了节省空间，使用了bit压缩存储信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_chunk_map_s</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JEMALLOC_PROF</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        rb_node(<span class="type">arena_chunk_map_t</span>)    rb_link;</span><br><span class="line">        ql_elm(<span class="type">arena_chunk_map_t</span>)    ql_link;</span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="type">prof_ctx_t</span>            *prof_ctx;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JEMALLOC_PROF</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">size_t</span>                bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chunk map内部包含两个link node，分别可以挂载到rb tree或环形队列上，同时为了节省空间又使用了union。由于run本身也是由连续page组成的，因此chunk map除了记录page状态之外，还负责run的基址检索。</p>
<p>举例来说，Je会把所有已分配run记录在内部rb tree上以快速检索，实际地操作是将该run中第一个page对应的chunk_map作为rb node挂载到tree上。检索时也是先找出将相应的chunk map，再进行地址转换得到run的基址。</p>
<p>按照通常的设计思路，我们可能会把run指针作为节点直接保存到rb tree中。但Je中的设计明显要更复杂。究其原因，如果把link node放到run中，后果是bookkeeping和user memory将混淆在一起，这对于分配器的安全性是很不利的。包括Dl在内的传统分配器都具有这样的缺陷。而如果单独用link node记录run，又会造成空间浪费。</p>
<p>正因为Je中无论是chunk还是run都是连续page组成，所以用首个page对应的chunk map就能同时代表该run的基址。</p>
<p>Je中通常用mapelm换算出pageind，再将<code>pageind &lt;&lt; LG_PAGE + chunk_base</code>，就能得到run指针，代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_chunk_t</span> *run_chunk = CHUNK_ADDR2BASE(mapelm);</span><br><span class="line"><span class="type">size_t</span> pageind = arena_mapelm_to_pageind(mapelm);</span><br><span class="line">run = (<span class="type">arena_run_t</span> *)((<span class="type">uintptr_t</span>)run_chunk + (pageind &lt;&lt;</span><br><span class="line">    LG_PAGE));</span><br><span class="line"></span><br><span class="line">JEMALLOC_INLINE_C <span class="type">size_t</span></span><br><span class="line"><span class="title function_">arena_mapelm_to_pageind</span><span class="params">(<span class="type">arena_chunk_map_t</span> *mapelm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uintptr_t</span> map_offset =</span><br><span class="line">        CHUNK_ADDR2OFFSET(mapelm) - offsetof(<span class="type">arena_chunk_t</span>, <span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((map_offset / <span class="keyword">sizeof</span>(<span class="type">arena_chunk_map_t</span>)) + map_bias);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chunk map对page状态描述都压缩记录到bits中，由于内容较多，直接引用Je代码中的注释，</p>
<ul>
<li>下面是一个假想的ILP32系统下的bits layout,</li>
<li>???????? ???????? ????nnnn nnnndula</li>
<li>“?”的部分分三种情况，分别对应unallocated, small和large.<ul>
<li>Unallocated: 首尾page写入该run的地址，而内部page则不做要求。</li>
<li>Small: 全部是page的偏移量。</li>
<li>Large: 首page是run size，后续的page不做要求。</li>
</ul>
</li>
<li>n : 对于small run指其所在bin的index，对large run写入BININD_INVALID.</li>
<li>d : dirty?</li>
<li>u : unzeroed?</li>
<li>l : large?</li>
<li><p>a : allocated?</p>
</li>
<li><p>下面是对三种类型的run page做的举例，</p>
<ul>
<li>p : run page offset</li>
<li>s : run size</li>
<li>n : binind for size class; large objects set these to BININD_INVALID</li>
<li>x : don’t care</li>
<li><ul>
<li>: 0</li>
</ul>
</li>
<li><ul>
<li>: 1</li>
</ul>
</li>
<li>[DULA] : bit set</li>
<li>[dula] : bit unset</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Unallocated (clean):</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++du-a</span><br><span class="line">  xxxxxxxx xxxxxxxx xxxxxxxx xxxx-Uxx</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++dU-a</span><br><span class="line"></span><br><span class="line">Unallocated (dirty):</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++D--a</span><br><span class="line">  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++D--a</span><br><span class="line"></span><br><span class="line">Small:      </span><br><span class="line">  pppppppp pppppppp ppppnnnn nnnnd--A</span><br><span class="line">  pppppppp pppppppp ppppnnnn nnnn---A</span><br><span class="line">  pppppppp pppppppp ppppnnnn nnnnd--A</span><br></pre></td></tr></table></figure>
<p>Small page需要注意的是，这里代表的p并非是一个固定值，而是该page相对于其所在run的第一个page的偏移量，比如可能是这样，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  00000000 00000000 0000nnnn nnnnd--A</span><br><span class="line">  00000000 00000000 0001nnnn nnnn---A</span><br><span class="line">  00000000 00000000 0010nnnn nnnn---A</span><br><span class="line">  00000000 00000000 0011nnnn nnnn---A</span><br><span class="line">  ...</span><br><span class="line">  00000000 00000001 1010nnnn nnnnd--A</span><br><span class="line"></span><br><span class="line">Large:</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++D-LA</span><br><span class="line">  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span><br><span class="line">  -------- -------- ----++++ ++++D-LA</span><br><span class="line"></span><br><span class="line">Large (sampled, size &lt;= PAGE):</span><br><span class="line">  ssssssss ssssssss ssssnnnn nnnnD-LA</span><br><span class="line"></span><br><span class="line">Large (not sampled, size == PAGE):</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++D-LA</span><br></pre></td></tr></table></figure></p>
<p>为了提取/设置map bits内部的信息，Je提供了一组函数，这里列举两个最基本的，剩下的都是读取mapbits后做一些位运算而已，</p>
<p>读取mapbits<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">size_t</span></span><br><span class="line"><span class="title function_">arena_mapbits_get</span><span class="params">(<span class="type">arena_chunk_t</span> *chunk, <span class="type">size_t</span> pageind)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (arena_mapbitsp_read(arena_mapbitsp_get(chunk, pageind)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据pageind获取对应的chunk map<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">arena_chunk_map_t</span> *</span><br><span class="line"><span class="title function_">arena_mapp_get</span><span class="params">(<span class="type">arena_chunk_t</span> *chunk, <span class="type">size_t</span> pageind)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (&amp;chunk-&gt;<span class="built_in">map</span>[pageind-map_bias]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-Run-arena-run-t"><a href="#2-4-Run-arena-run-t" class="headerlink" title="2.4 - Run (arena_run_t)"></a>2.4 - Run (arena_run_t)</h3><p>如同在2.1节所述，在Je中run才是真正负责分配的主体(前提是对small region来说)。run的大小对齐到page size上，并且在内部划分成大小相同的region。当有外部分配请求时，run就会从内部挑选一个free region返回。可以认为run就是small region仓库。</p>
<h4 id="2-4-1-Run结构"><a href="#2-4-1-Run结构" class="headerlink" title="2.4.1 - Run结构"></a>2.4.1 - Run结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_run_s</span> &#123;</span></span><br><span class="line">    <span class="type">arena_bin_t</span>    *bin;</span><br><span class="line">    <span class="type">uint32_t</span>    nextind;</span><br><span class="line">    <span class="type">unsigned</span>    nfree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>run的结构非常简单，但同chunk类似，所谓的arena_run_t不过是整个run的header部分。</p>
<ul>
<li><code>bin</code>:     与该run相关联的bin。每个run都有其所属的bin，详细内容在之后介绍。</li>
<li><code>nextind</code>: 记录下一个clean region的索引。</li>
<li><code>nfree</code>:   记录当前空闲region数量。</li>
</ul>
<p>除了header部分之外，run的真实layout如下，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">              /--------------------\</span><br><span class="line">              | arena_run_t header |</span><br><span class="line">              | ...                |</span><br><span class="line">bitmap_offset | bitmap             |</span><br><span class="line">              | ...                |</span><br><span class="line">              |--------------------|</span><br><span class="line">              | redzone            |</span><br><span class="line">  reg0_offset | region 0           |</span><br><span class="line">              | redzone            |</span><br><span class="line">              |--------------------| \</span><br><span class="line">              | redzone            |  |</span><br><span class="line">              | region 1           |  &gt; reg_interval</span><br><span class="line">              | redzone            | /</span><br><span class="line">              |--------------------|</span><br><span class="line">              | ...                |</span><br><span class="line">              | ...                |</span><br><span class="line">              | ...                |</span><br><span class="line">              |--------------------|</span><br><span class="line">              | redzone            |</span><br><span class="line">              | region nregs-1     |</span><br><span class="line">              | redzone            |</span><br><span class="line">              |--------------------|</span><br><span class="line">              | alignment pad?     |</span><br><span class="line">              \--------------------/</span><br></pre></td></tr></table></figure></p>
<p>正如chunk通过chunk map记录内部所有page状态一样，run通过在header后挂载bitmap来记录其内部的region状态。bitmap之后是regions区域。内部region大小相等，且在前后都有redzone保护(需要在设置里打开redzone选项)。</p>
<p>简单来说，run就是通过查询bitmap来找到可用的region。而传统分配器由于使用boundary tag，空闲region一般是被双向链表管理的。相比之下，传统方式查找速度更快，也更简单。缺点之前也提到过，安全和稳定性都存在缺陷。从这一点可以看到，Je在设计思路上将bookkeeping和user memory分离是贯穿始终的原则，更甚于对性能的影响(事实上这点影响在并发条件下被大大赚回来了).</p>
<h4 id="2-4-2-size-classes"><a href="#2-4-2-size-classes" class="headerlink" title="2.4.2 - size classes"></a>2.4.2 - size classes</h4><p>内存分配器对内部管理的region往往按照某种特殊规律来分配。比如Dl将内存划分成small和large两种类型。small类型从8字节开始每8个字节为一个分割直至256字节。而large类型则从256字节开始，挂载到dst上。这种划分方式有助于分配器对内存进行有效的管理和控制，让已分配的内存更加紧实(tightly packed)，以降低外部碎片率。</p>
<p>Je进一步优化了分配效率。采用了类似于”二分伙伴(Binary Buddy)算法”的分配方式。在Je中将不同大小的类型称为size class。</p>
<p>在Je源码的size_classes.h文件中，定义了不同体系架构下的region size。该文件实际是通过名为size_classes.sh的shell script自动生成的。script按照四种不同量纲定义来区分各个体系平台的区别，然后将它们做排列组合，就可以兼容各个体系。这四种量纲分别是，</p>
<ul>
<li><code>LG_SIZEOF_PTR</code>: 代表指针长度，ILP32下是2, LP64则是3.</li>
<li><code>LG_QUANTUM</code>: 量子，binary buddy分得的最小单位。除了tiny size，其他的size classes都是quantum的整数倍大小。</li>
<li><code>LG_TINY_MIN</code>: 是比quantum更小的size class，且必须对齐到2的指数倍上。它是Je可分配的最小的size class.</li>
<li><code>LG_PAGE</code>: 就是page大小</li>
</ul>
<p>根据binary buddy算法，Je会将内存不断的二平分，每一份称作一个group。同一个group内又做四等分。例如，一个典型的ILP32, tiny等于8byte, quantum为16byte，page为4096byte的系统，其size classes划分是这样的，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#if (LG_SIZEOF_PTR == 2 &amp;&amp; LG_TINY_MIN == 3 &amp;&amp; LG_QUANTUM == 4 &amp;&amp; LG_PAGE == 12)</span><br><span class="line">#define    SIZE_CLASSES \</span><br><span class="line">    index, lg_grp, lg_delta, ndelta,  bin, lg_delta_lookup  \</span><br><span class="line">    SC(  0,      3,        3,      0,   yes,        3) \        </span><br><span class="line">                                                       \</span><br><span class="line">    SC(  1,      3,        3,      1,   yes,        3) \        </span><br><span class="line">    SC(  2,      4,        4,      1,   yes,        4) \        </span><br><span class="line">    SC(  3,      4,        4,      2,   yes,        4) \        </span><br><span class="line">    SC(  4,      4,        4,      3,   yes,        4) \        </span><br><span class="line">                                                       \</span><br><span class="line">    SC(  5,      6,        4,      1,   yes,        4) \        </span><br><span class="line">    SC(  6,      6,        4,      2,   yes,        4) \        </span><br><span class="line">    SC(  7,      6,        4,      3,   yes,        4) \        </span><br><span class="line">    SC(  8,      6,        4,      4,   yes,        4) \        </span><br><span class="line">                                                       \</span><br><span class="line">    SC(  9,      7,        5,      1,   yes,        5) \        </span><br><span class="line">    SC( 10,      7,        5,      2,   yes,        5) \        </span><br><span class="line">    SC( 11,      7,        5,      3,   yes,        5) \        </span><br><span class="line">    SC( 12,      7,        5,      4,   yes,        5) \        </span><br><span class="line">                                                       </span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure>
<p>宏SIZE_CLASSES主要功能就是可以生成几种类型的table。而SC则根据不同的情况被定义成不同的含义。SC传入的6个参数的含义如下，</p>
<ul>
<li><code>index</code>:      在table中的位置</li>
<li><code>lg_grp</code>:     所在group的指数</li>
<li><code>lg_delta</code>:   group内偏移量指数</li>
<li><code>ndelta</code>:     group内偏移数</li>
<li><code>bin</code>:        是否由bin记录。small region是记录在bins中</li>
<li><code>lg_delta_lookup</code>:    在lookup table中的调用S2B_#的尾数后缀</li>
</ul>
<p>因此得到reg_size的计算公式，<code>reg_size = 1 &lt;&lt; lg_grp + ndelta &lt;&lt; lg_delta</code>根据该公式，可以得到region的范围，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌─────────┬─────────┬───────────────────────────────────────┐</span><br><span class="line">│Category │ Spacing │ Size                                  │</span><br><span class="line">├─────────┼─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │      lg │ [8]                                   │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │      16 │ [16, 32, 48, ..., 128]                │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │      32 │ [160, 192, 224, 256]                  │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│Small    │      64 │ [320, 384, 448, 512]                  │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │     128 │ [640, 768, 896, 1024]                 │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │     256 │ [1280, 1536, 1792, 2048]              │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │     512 │ [2560, 3072, 3584]                    │</span><br><span class="line">├─────────┼─────────┼───────────────────────────────────────┤</span><br><span class="line">│Large    │   4 KiB │ [4 KiB, 8 KiB, 12 KiB, ..., 4072 KiB] │</span><br><span class="line">├─────────┼─────────┼───────────────────────────────────────┤</span><br><span class="line">│Huge     │   4 MiB │ [4 MiB, 8 MiB, 12 MiB, ...]           │</span><br><span class="line">└─────────┴─────────┴───────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>除此之外，在<code>size_classes.h</code>中还定义了一些常量，</p>
<p>tiny bins的数量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    NTBINS            1</span></span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">可以通过lookup table查询的bins数量</span><br><span class="line">```C</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    NLBINS            29</span></span><br></pre></td></tr></table></figure></p>
<p>small bins的数量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    NBINS            28</span></span><br></pre></td></tr></table></figure></p>
<p>最大tiny size class的指数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    LG_TINY_MAXCLASS    3</span></span><br></pre></td></tr></table></figure></p>
<p>最大lookup size class，也就是NLBINS - 1个bins<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    LOOKUP_MAXCLASS        ((((size_t)1) &lt;&lt; 11) + (((size_t)4) &lt;&lt; 9))</span></span><br></pre></td></tr></table></figure></p>
<p>最大small size class，也就是NBINS - 1个bins<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    SMALL_MAXCLASS        ((((size_t)1) &lt;&lt; 11) + (((size_t)3) &lt;&lt; 9))</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-4-3-size2bin-bin2size"><a href="#2-4-3-size2bin-bin2size" class="headerlink" title="2.4.3 - size2bin/bin2size"></a>2.4.3 - size2bin/bin2size</h4><p>通过SIZE_CLASSES建立的table就是为了在O(1)的时间复杂度内快速进行size2bin或者bin2size切换。同样的技术在Dl中有所体现，来看Je是如何实现的。</p>
<p>size2bin切换提供了两种方式，较快的是通过查询lookup table，较慢的是计算得到。从原理上，只有small size class需要查找bins，但可通过lookup查询的size class数量要小于整个small size class数量。因此，部分size class只能计算得到。在原始Je中统一只采用查表法，但在android版本中可能是考虑减小lookup table size，而增加了直接计算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">size_t</span></span><br><span class="line"><span class="title function_">small_size2bin</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= LOOKUP_MAXCLASS)</span><br><span class="line">        <span class="keyword">return</span> (small_size2bin_lookup(size));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (small_size2bin_compute(size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小于LOOKUP_MAXCLASS的请求通过small_size2bin_lookup直接查表。查询的算法是这样的，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> ret = ((<span class="type">size_t</span>)(small_size2bin_tab[(size<span class="number">-1</span>) &gt;&gt; LG_TINY_MIN]));</span><br></pre></td></tr></table></figure></p>
<p>也就是说，Je通过一个<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x) = (x - <span class="number">1</span>) / <span class="number">2</span>^LG_TINY_MIN</span><br></pre></td></tr></table></figure></p>
<p>的变换将size映射到lookup table的相应区域。这个table在gdb中可能是这样的，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p  /d small_size2bin</span><br><span class="line">$6 = &#123;0, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10,</span><br><span class="line">      11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14,</span><br><span class="line">      14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16,</span><br><span class="line">      16, 16, 17 &lt;repeats 16 times&gt;, 18 &lt;repeats 16 times&gt;, 19 &lt;repeats 16 times&gt;,</span><br><span class="line">      20 &lt;repeats 16 times&gt;, 21 &lt;repeats 32 times&gt;, 22 &lt;repeats 32 times&gt;,</span><br><span class="line">      23 &lt;repeats 32 times&gt;, 24 &lt;repeats 32 times&gt;, 25 &lt;repeats 64 times&gt;,</span><br><span class="line">      26 &lt;repeats 64 times&gt;, 27 &lt;repeats 64 times&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>该数组的含义与binary buddy算法是一致的。对应的bin index越高，其在数组中占用的字节数就越多。除了0号bin之外，相邻的4个bin属于同一group，两个group之间相差二倍，因此在数组中占用的字节数也就相差2倍。所以，上面数组的group划分如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;, &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;, ...</span><br></pre></td></tr></table></figure></p>
<p>以bin#9为例，其所管辖的范围(128, 160]，由于其位于更高一级group，因此相比bin#8在lookup table中多一倍的字节数，假设我们需要查询132，经过映射，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">132</span> - <span class="number">1</span>) &gt;&gt; <span class="number">3</span> = <span class="number">16</span></span><br></pre></td></tr></table></figure></p>
<p>这样可以快速得到其所在的bin #9。如图，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    bin #1     bin #3          132 is HERE!</span><br><span class="line">       |          |                |</span><br><span class="line">       v          v                v</span><br><span class="line"> +----------------------------------------------------------------</span><br><span class="line"> | 0 | 1 | 2 2 | 3 3 | ... | 8 8 | 9 9 9 9 | ... | 16 ... 16 | ...</span><br><span class="line"> +----------------------------------------------------------------</span><br><span class="line">   ^        ^                 ^       ^                ^</span><br><span class="line">   |        |                 |       |                |</span><br><span class="line">bin #0    bin #2            bin #8  bin #9          bin #16 </span><br></pre></td></tr></table></figure>
<p>Je巧妙的通过前面介绍CLASS_SIZE宏生成了这个lookup table，代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALIGNED(CACHELINE)</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span>    small_size2bin_tab[] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_3(i)    i,</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_4(i)    S2B_3(i) S2B_3(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_5(i)    S2B_4(i) S2B_4(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_6(i)    S2B_5(i) S2B_5(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_7(i)    S2B_6(i) S2B_6(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_8(i)    S2B_7(i) S2B_7(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_9(i)    S2B_8(i) S2B_8(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_no(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup) \</span></span><br><span class="line"><span class="meta">    S2B_##lg_delta_lookup(index)</span></span><br><span class="line">    SIZE_CLASSES</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_3</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_4</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_8</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_no</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> SC</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的S2B_xx是一系列宏的嵌套展开，最终对应的就是不同group在lookup table中占据的字节数以及bin索引。相信看懂了前面的介绍就不难理解。</p>
<p>另一方面，大于LOOKUP_MAXCLASS但小于SMALL_MAXCLASS的size class不能查表获得，需要进行计算。简言之，一个bin number是三部分组成的，</p>
<p><code>bin_number = NTBIN + group_number &lt;&lt; LG_SIZE_CLASS_GROUP + mod</code></p>
<p>即tiny bin数量加上其所在group再加上group中的偏移(0-2)。源码如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="type">size_t</span></span><br><span class="line"><span class="title function_">small_size2bin_compute</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// xf: lg_floor相当于ffs</span></span><br><span class="line">        <span class="type">size_t</span> x = lg_floor((size&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 计算size class所在group number</span></span><br><span class="line">        <span class="type">size_t</span> shift = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? <span class="number">0</span> :</span><br><span class="line">            x - (LG_SIZE_CLASS_GROUP + LG_QUANTUM);</span><br><span class="line">        <span class="type">size_t</span> grp = shift &lt;&lt; LG_SIZE_CLASS_GROUP;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> lg_delta = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM + <span class="number">1</span>)</span><br><span class="line">            ? LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> delta_inverse_mask = ZI(<span class="number">-1</span>) &lt;&lt; lg_delta;</span><br><span class="line">        <span class="comment">// xf: 计算剩余mod部分</span></span><br><span class="line">        <span class="type">size_t</span> mod = ((((size<span class="number">-1</span>) &amp; delta_inverse_mask) &gt;&gt; lg_delta)) &amp;</span><br><span class="line">            ((ZU(<span class="number">1</span>) &lt;&lt; LG_SIZE_CLASS_GROUP) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 组合计算bin number</span></span><br><span class="line">        <span class="type">size_t</span> bin = NTBINS + grp + mod;</span><br><span class="line">        <span class="keyword">return</span> (bin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中LG_SIZE_CLASS_GROUP是size_classes.h中的定值，代表一个group中包含的bin数量，根据binary buddy算法，该值通常情况下是2。而要找到size class所在的group，与其最高有效位相关。Je通过类似于ffs的函数<br>首先获得size的最高有效位x<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> x = lg_floor((size&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>);</span><br></pre></td></tr></table></figure></p>
<p>至于group number，则与quantum size有关。因为除了tiny class, quantum size位于group #0的第一个。因此不难推出，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group_number = <span class="number">2</span>^x / quantum_size / <span class="number">2</span>^LG_SIZE_CLASS_GROUP</span><br></pre></td></tr></table></figure></p>
<p>对应代码就是，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> shift = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? <span class="number">0</span> :</span><br><span class="line">        x - (LG_SIZE_CLASS_GROUP + LG_QUANTUM);</span><br></pre></td></tr></table></figure></p>
<p>而对应group起始位置就是，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> grp = shift &lt;&lt; LG_SIZE_CLASS_GROUP;</span><br></pre></td></tr></table></figure></p>
<p>至于mod部分，与之相关的是最高有效位之后的两个bit。Je在这里经过了复杂的位变换，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> lg_delta = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM + <span class="number">1</span>) ? LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - <span class="number">1</span>;</span><br><span class="line"><span class="type">size_t</span> delta_inverse_mask = ZI(<span class="number">-1</span>) &lt;&lt; lg_delta;</span><br><span class="line"><span class="type">size_t</span> mod = ((((size<span class="number">-1</span>) &amp; delta_inverse_mask) &gt;&gt; lg_delta)) &amp; ((ZU(<span class="number">1</span>) &lt;&lt; LG_SIZE_CLASS_GROUP) - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码直白的翻译，实际上就是要求得如下两个bit,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">                        1 0000</span><br><span class="line">                       10 0000</span><br><span class="line">                       11 0000</span><br><span class="line">group #0              100 0000</span><br><span class="line">-------------------------------------------------</span><br><span class="line">                                      +--+</span><br><span class="line">                      101 0000 - 1 = 1|00| 1111</span><br><span class="line">                      110 0000 - 1 = 1|01| 1111</span><br><span class="line">                      111 0000 - 1 = 1|10| 1111</span><br><span class="line">group #1             1000 0000 - 1 = 1|11| 1111</span><br><span class="line">                                      +--+</span><br><span class="line">--------------------------------------------------                                         </span><br><span class="line">                                      +--+</span><br><span class="line">                     1010 0000 - 1 = 1|00|1 1111    </span><br><span class="line">                     1100 0000 - 1 = 1|01|1 1111</span><br><span class="line">                     1110 0000 - 1 = 1|10|1 1111</span><br><span class="line">group #2            10000 0000 - 1 = 1|11|1 1111</span><br><span class="line">                                      +--+</span><br><span class="line">--------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>根据这个图示再去看Je的代码就不难理解了。mod的计算结果就是从0-3的数值。</p>
<p>而最终的结果是前面三部分的组合即，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> bin = NTBINS + grp + mod;</span><br></pre></td></tr></table></figure></p>
<p>而bin2size查询就简单得多。上一节介绍SIZE_CLASSES时提到过small region的计算公式，只需要根据该公式提前计算出所有bin对应的region size，直接查表即可。</p>
<h3 id="2-5-bins-arena-bin-t"><a href="#2-5-bins-arena-bin-t" class="headerlink" title="2.5 - bins (arena_bin_t)"></a>2.5 - bins (arena_bin_t)</h3><p>run是分配的执行者，而分配的调度者是bin。这个概念同Dl中的bin是类似的，但Je中bin要更复杂一些。直白地说，可以把bin看作non-full run的仓库，bin负责记录当前arena中某一个size class范围内所有non-full run的使用情况。当有分配请求时，arena查找相应size class的bin，找出可用于分配的run，再由run分配region。当然，因为只有small region分配需要run，所以bin也只对应small size class。</p>
<p>与bin相关的数据结构主要有两个，分别是arena_bin_t和arena_bin_info_t。在2.1.3中提到arena_t内部保存了一个bin数组，其中的成员就是arena_bin_t。其结构如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_bin_s</span> &#123;</span></span><br><span class="line">    <span class="type">malloc_mutex_t</span>        lock;    </span><br><span class="line">    <span class="type">arena_run_t</span>            *runcur;</span><br><span class="line">    <span class="type">arena_run_tree_t</span>    runs;</span><br><span class="line">    <span class="type">malloc_bin_stats_t</span>  stats;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>lock</code>: 该lock同arena内部的lock不同，主要负责保护current run。而对于run本身的分配和释放还是需要依赖arena lock。通常情况下，获得bin lock的前提是获得arena lock，但反之不成立。</li>
<li><code>runcur</code>: 当前可用于分配的run，一般情况下指向地址最低的non-full run，同一时间一个bin只有一个current run用于分配。</li>
<li><code>runs</code>: rb tree，记录当前arena中该bin对应size class的所有non-full runs。因为分配是通过current run完成的，所以也相当于current run的仓库。</li>
<li><code>stats</code>: 统计信息。</li>
</ul>
<p>另一个与bin相关的结构是arena_bin_info_t。与前者不同，bin_info保存的是arena_bin_t的静态信息，包括相对应size class run的bitmap offset，region size，region number，bitmap info等等(此类信息只要class size决定，就固定下来)。所有上述信息在Je中由全局数组arena_bin_info记录。因此与arena无关，全局仅保留一份。</p>
<p>arena_bin_info_t的定义如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_bin_info_s</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span>        reg_size;</span><br><span class="line">    <span class="type">size_t</span>        redzone_size;</span><br><span class="line">    <span class="type">size_t</span>        reg_interval;</span><br><span class="line">    <span class="type">size_t</span>        run_size;</span><br><span class="line">    <span class="type">uint32_t</span>    nregs;</span><br><span class="line">    <span class="type">uint32_t</span>    bitmap_offset;</span><br><span class="line">    <span class="type">bitmap_info_t</span>    bitmap_info;</span><br><span class="line">    <span class="type">uint32_t</span>    reg0_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>reg_size</code>: 与当前bin的size class相关联的region size.</li>
<li><code>reg_interval</code>: reg_size+redzone_size</li>
<li><code>run_size</code>: 当前bin的size class相关联的run size.</li>
<li><code>nregs</code>: 当前bin的size class相关联的run中region数量。</li>
<li><code>bitmap_offset</code>: 当前bin的size class相关联的run中bitmap偏移。</li>
<li><code>bitmap_info</code>: 记录当前bin的size class相关联的run中bitmap信息。</li>
<li><code>reg0_offset</code>: index为0的region在run中的偏移量。</li>
</ul>
<p>以上记录的静态信息中尤为重要的是bitmap_info和bitmap_offset.</p>
<p>其中bitmap_info_t定义如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap_info_s</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> nbits;</span><br><span class="line">    <span class="type">unsigned</span> nlevels;</span><br><span class="line">    <span class="type">bitmap_level_t</span> levels[BITMAP_MAX_LEVELS+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>nbits</code>: bitmap中逻辑bit位数量(特指level#0的bit数)</li>
<li><code>nlevels</code>: bitmap的level数量</li>
<li><code>levels</code>: level偏移量数组，每一项记录该级level在bitmap中的起始index</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap_level_s</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> group_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在2.3.1节中介绍arena_run_t时曾提到Je通过外挂bitmap将bookkeeping和user memory分离。但bitmap查询速度要慢于boundary tag。为了弥补这个缺陷，Je对此做了改进，通过多级level缓冲以替代线性查找。</p>
<p>Je为bitmap增加了多级level, bottom level同普通bitmap一致，每1bit代表一个region。而高一级level中1bit代表前一级level中一个byte。譬如说，若我们在当前run中存在128个region，则在ILP32系统上，需要128/32 = 4byte来表示这128个region。Je将这4个byte看作level #0。为了进一步表示这4个字节是否被占用，又额外需要1byte以缓存这4byte的内容(仅使用了4bit)，此为level#1。即整个bitmap，一共有2级level，共5byte来描述。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                  +--------------+              +--------+</span><br><span class="line">      +-----------|------------ +|   +----------|-------+|</span><br><span class="line">      v           v             ||   v          v       ||</span><br><span class="line">+--------------------------------------------------------------------------</span><br><span class="line">| 1101 0010 | 0000 0000 | ... | 10?? ???? | ???? ???? | 1??? ????    | ...</span><br><span class="line">+--------------------------------------------------------------------------</span><br><span class="line">|&lt;--------- level #0 --------&gt;|&lt;----- level #1 ------&gt;|&lt;- level #2 -&gt;|</span><br></pre></td></tr></table></figure>
<h3 id="2-6-Thread-caches-tcache-t"><a href="#2-6-Thread-caches-tcache-t" class="headerlink" title="2.6 - Thread caches (tcache_t)"></a>2.6 - Thread caches (tcache_t)</h3><p>TLS/TSD是另一种针对多线程优化使用的分配技术，Je中称为tcache。tcache解决的是同一cpu core下不同线程对heap的竞争。通过为每个线程指定专属分配区域，来减小线程间的干扰。但显然这种方法会增大整体内存消耗量。为了减小副作用，je将tcache设计成一个bookkeeping结构，在tcache中保存的仅仅是指向外部region的指针，region对象仍然位于各个run当中。换句话说，如果一个region被tcache记录了，那么从run的角度看，它就已经被分配了。</p>
<p>tcache的内容如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_s</span> &#123;</span></span><br><span class="line">    ql_elm(<span class="type">tcache_t</span>) link;        </span><br><span class="line">    <span class="type">uint64_t</span>         prof_accumbytes;</span><br><span class="line">    <span class="type">arena_t</span>             *arena;        </span><br><span class="line">    <span class="type">unsigned</span>         ev_cnt;        </span><br><span class="line">    <span class="type">unsigned</span>         next_gc_bin;    </span><br><span class="line">    <span class="type">tcache_bin_t</span>     tbins[<span class="number">1</span>];    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>link</code>: 链接节点，用于将同一个arena下的所有tcache链接起来。</li>
<li><code>prof_accumbytes</code>: memory profile相关。</li>
<li><code>arena</code>: 该tcache所属的arena指针。</li>
<li><code>ev_cnt</code>: 是tcache内部的一个周期计数器。每当tcache执行一次分配或释放时，ev_cnt会记录一次。直到周期到来，Je会执行一次incremental gc.这里的gc会清理tcache中多余的region，将它们释放掉。尽管这不意味着系统内存会获得释放，但可以解放更多的region交给其他更饥饿的线程以分配。</li>
<li><code>next_gc_bin</code>: 指向下一次gc的binidx。tcache gc按照一周期清理一个bin执行。</li>
<li><code>tbins</code>: tcache bin数组。同样外挂在tcache后面。</li>
</ul>
<p>同arena bin类似，tcache同样有tcache_bin_t和tcache_bin_info_t。tcache_bin_t作用类似于arena bin，但其结构要比后者更简单。准确的说，tcache bin并没有分配调度的功能，而仅起到记录作用。其内部通过一个stack记录指向外部arena run中的region指针。而一旦region被cache到tbins内，就不能再被其他任何线程所使用，尽管它可能甚至与其他线程tcache中记录的region位于同一个arena run中。</p>
<p>tcache bin结构如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_bin_s</span> &#123;</span></span><br><span class="line">    <span class="type">tcache_bin_stats_t</span> tstats;</span><br><span class="line">    <span class="type">int</span>     low_water;</span><br><span class="line">    <span class="type">unsigned</span>    lg_fill_div;</span><br><span class="line">    <span class="type">unsigned</span>    ncached;</span><br><span class="line">    <span class="type">void</span>        **avail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tstats</code>: tcache bin内部统计。</li>
<li><code>low_water</code>: 记录两次gc间tcache内部使用的最低水线。该数值与下一次gc时尝试释放的region数量有关。释放量相当于low water数值的3/4.</li>
<li><code>lg_fill_div</code>: 用作tcache refill时作为除数。当tcache耗尽时，会请求arena run进行refill。但refill不会一次性灌满tcache，而是依照其最大容量缩小2^lg_fill_div的倍数。该数值同low_water一样是动态的，两者互相配合确保tcache处于一个合理的充满度。</li>
<li><code>ncached</code>: 指当前缓存的region数量，同时也代表栈顶index.</li>
<li><code>avail</code>: 保存region指针的stack，称为avail-stack.</li>
</ul>
<p>tcache_bin_info_t保存tcache bin的静态信息。其本身只保存了tcache max容量。该数值是在tcache boot时根据相对应的arena bin的nregs决定的。通常等于nregs的二倍，但不得超过TCACHE_NSLOTS_SMALL_MAX。该数值默认为200，但在android中大大提升了该限制，small bins不得超过8, large bins则为16.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_bin_info_s</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span>    ncached_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>tcache layout如下，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">                +---------------+</span><br><span class="line">              / | link          |</span><br><span class="line">   tcache_t  &lt;  | next_gc_bin   |</span><br><span class="line">              \ | ...           |</span><br><span class="line">                |---------------|</span><br><span class="line">              / | tstats        |</span><br><span class="line">   tbins[0]  &lt;  | ...           |</span><br><span class="line">              | | ncached       |</span><br><span class="line">              \ | avail --------------+</span><br><span class="line">                |---------------|     |</span><br><span class="line">                | ...           |     |  </span><br><span class="line">                | ...           |     |  </span><br><span class="line">                | ...           |     |  </span><br><span class="line">                |---------------|     |</span><br><span class="line">              / | tstats        |     |</span><br><span class="line">  tbins[nhb  &lt;  | ...           |     |</span><br><span class="line">     ins]     | | ncached       |     |                   </span><br><span class="line">              \ | avail --------------|---+               </span><br><span class="line">                |---------------|     |   |               current arena run</span><br><span class="line">                | padding       |     |   |               +----------------+      </span><br><span class="line">                |---------------| &lt;---+   |               | run header     |</span><br><span class="line">              / | stack[0]      |         |               | ...            |</span><br><span class="line">avail-stack  &lt;  | stack[1]      |         |               | bitmap         |</span><br><span class="line">for tbins[0]  | | ...           |         |               | ...            |</span><br><span class="line">              | | ...           |         |               |----------------|</span><br><span class="line">              | | stack[ncached |         |               | region #0      |</span><br><span class="line">              \ | _max - 1]     |         |               | ...            |</span><br><span class="line">                |---------------|         |               |----------------|</span><br><span class="line">                | ...           |         |    +--------&gt; | region #1      |</span><br><span class="line">                | ...           |         |    |          | ...            |</span><br><span class="line">                | ...           |         |    |          |----------------|</span><br><span class="line">                |---------------| &lt;-------+    |          | ...            |</span><br><span class="line">avail-stack   / | stack[0]      |--------------|--+       | ...            |</span><br><span class="line">for tbins[   &lt;  | ...           |              |  |       |----------------|</span><br><span class="line"> nhbins]      | | stack[n]      |--------------|--|-----&gt; | region #n      |</span><br><span class="line">              | | ...           |              |  |       | ...            |</span><br><span class="line">              | | stack[ncached |              |  |       |----------------|</span><br><span class="line">              \ | _max - 1]     |--------------+  |       | ...            |</span><br><span class="line">                +---------------+                 |       | ...            |</span><br><span class="line">                                                  |       |----------------|</span><br><span class="line">                                                  +-----&gt; | region #nregs-1|</span><br><span class="line">                                                          | ...            |</span><br><span class="line">                                                          +----------------+</span><br></pre></td></tr></table></figure>
<h3 id="2-7-Extent-Node-extent-node-t"><a href="#2-7-Extent-Node-extent-node-t" class="headerlink" title="2.7 - Extent Node (extent_node_t)"></a>2.7 - Extent Node (extent_node_t)</h3><p>extent node代表huge region，即大于chunk大小的内存单元。同arena run不同，extent node并非是一个header构造，而是外挂的。因此其本身仍属small region。只不过并不通过bin分配，而由base_nodes直接动态创建。</p>
<p>Je中对所有huge region都是通过rb tree管理。因此extent node同时也是tree node。一个node节点被同时挂载到两棵rb tree上。一棵采用szad的查询方式，另一棵则采用纯ad的方式。作用是当执行chunk recycle时查询到可用region，后面会详述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">extent_node_s</span> &#123;</span></span><br><span class="line">    rb_node(<span class="type">extent_node_t</span>)    link_szad;</span><br><span class="line">    rb_node(<span class="type">extent_node_t</span>)    link_ad;</span><br><span class="line">    <span class="type">prof_ctx_t</span>        *prof_ctx;</span><br><span class="line">    <span class="type">void</span>            *addr;</span><br><span class="line">    <span class="type">size_t</span>            size;</span><br><span class="line">    <span class="type">arena_t</span>            *arena;</span><br><span class="line">    <span class="type">bool</span>            zeroed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>link_szad</code>: szad tree的link节点。</li>
<li><code>link_ad</code>: ad tree的link节点。</li>
<li><code>prof_ctx</code>: 用于memory profile.</li>
<li><code>addr</code>: 指向huge region的指针。</li>
<li><code>size</code>: region size.</li>
<li><code>arena</code>: huge region所属arena.</li>
<li><code>zeroed</code>: 代表是否zero-filled, chunk recycle时会用到。</li>
</ul>
<h3 id="2-8-Base"><a href="#2-8-Base" class="headerlink" title="2.8 - Base"></a>2.8 - Base</h3><p>base并不是数据类型，而是一块特殊区域，主要服务于内部meta data(例如arena_t，tcache_t，extent_node_t等等)的分配。base区域管理与如下变量相关，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">malloc_mutex_t</span>    base_mtx;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>        *base_pages;    </span><br><span class="line"><span class="type">static</span> <span class="type">void</span>        *base_next_addr;     </span><br><span class="line"><span class="type">static</span> <span class="type">void</span>        *base_past_addr;</span><br><span class="line"><span class="type">static</span> <span class="type">extent_node_t</span>    *base_nodes;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>base_mtx</code>:       base lock</li>
<li><code>base_pages</code>:     base page指针，代表整个区域的起始位置。</li>
<li><code>base_next_addr</code>: 当前base指针，类似于brk指针。</li>
<li><code>base_past_addr</code>: base page的上限指针。</li>
<li><code>base_nodes</code>:     指向extent_node_t链表的外挂头指针。</li>
</ul>
<p>base page源于arena中的空闲chunk，通常情况下，大小相当于chunk。当base耗尽时，会以chunk alloc的名义重新申请新的base pages。 </p>
<p>为了保证内部meta data的快速分配和访问。Je将内部请求大小都对齐到cache-line上，以避免在SMP下的false sharing。而分配方式上，采用了快速移动base_next_addr指针进行高速开采的方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">base_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 将内部分配请求对齐的cache-line上，阻止false sharing</span></span><br><span class="line">    csize = CACHELINE_CEILING(size);</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;base_mtx);</span><br><span class="line">    <span class="comment">// xf: 如果base耗尽，则重新分配base_pages。默认大小为chunksize.</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uintptr_t</span>)base_next_addr + csize &gt; (<span class="type">uintptr_t</span>)base_past_addr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (base_pages_alloc(csize)) &#123;</span><br><span class="line">            malloc_mutex_unlock(&amp;base_mtx);</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: 快速向前开采</span></span><br><span class="line">    ret = base_next_addr;</span><br><span class="line">    base_next_addr = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)base_next_addr + csize);</span><br><span class="line">    malloc_mutex_unlock(&amp;base_mtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与通常的base alloc有所不同，分配extent_node_t会优先从一个node链表中获取节点，而base_nodes则为该链表的外挂头指针。只有当其耗尽时，才使用前面的分配方式。这里区别对待extent_node_t与其他类型，主要与chunk recycle机制有关，后面会做详细说明。有意思的是，该链表实际上借用了extent node内部rb tree node的左子树节点指针作为其link指针。如2.7节所述，extent_node_t结构的起始位置存放一个rb node.但在这里，当base_nodes赋值给ret后，会强制将ret转型成(extent_node_t **),实际上就是指向extent_node_t结构体的第一个field的指针，并将其指向的node指针记录到base_nodes里，成为新的header节点。这里需要仔细体会这个强制类型转换的巧妙之处。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ret = base_nodes</span><br><span class="line">     |</span><br><span class="line">     v   +---- (extent_node_t**)ret</span><br><span class="line">     +---|------------------------------ +</span><br><span class="line">     |   |              extent_node      |</span><br><span class="line">     | +-|-------------------------+     |</span><br><span class="line">     | | v       rb_node           |     |</span><br><span class="line">     | | +----------+-----------+  |     |</span><br><span class="line">     | | | rbn_left | rbn_right |  | ... |</span><br><span class="line">     | | +----------+-----------+  |     |</span><br><span class="line">     | +-------|-------------------+     |</span><br><span class="line">     +---------|-------------------------+</span><br><span class="line">               v</span><br><span class="line">base_nodes---&gt; +---------------+</span><br><span class="line">               | extent_node   |</span><br><span class="line">               +---------------+</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">extent_node_t</span> *</span><br><span class="line"><span class="title function_">base_node_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">extent_node_t</span> *ret;</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;base_mtx);</span><br><span class="line">    <span class="keyword">if</span> (base_nodes != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = base_nodes;</span><br><span class="line">        <span class="comment">// xf: 这里也可以理解为，base_nodes = (extent_node_t*)(*ret);</span></span><br><span class="line">        base_nodes = *(<span class="type">extent_node_t</span> **)ret;</span><br><span class="line">        malloc_mutex_unlock(&amp;base_mtx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        malloc_mutex_unlock(&amp;base_mtx);</span><br><span class="line">        ret = (<span class="type">extent_node_t</span> *)base_alloc(<span class="keyword">sizeof</span>(<span class="type">extent_node_t</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Allocation"><a href="#3-Allocation" class="headerlink" title="3 - Allocation"></a>3 - Allocation</h2><h3 id="3-1-Overview"><a href="#3-1-Overview" class="headerlink" title="3.1 - Overview"></a>3.1 - Overview</h3><p>在2.3.2节中得知，Je将size class划分成small, large, huge三种类型。分配时这三种类型分别按照不同的算法执行。后面的章节也将按照这个类型顺序描述。</p>
<p>总体来说，Je分配函数从je_malloc入口开始，经过，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">je_malloc -&gt; imalloc_body -&gt; imalloc -&gt; imalloct ---&gt; arena_malloc</span><br><span class="line">                                                  |                  </span><br><span class="line">                                                  +-&gt; huge_malloc</span><br></pre></td></tr></table></figure>
<p>实际执行分配的分别是对应small/large的arena malloc和对应huge的huge malloc。分配算法可以概括如下，</p>
<ol>
<li>首先检查Je是否初始化，如果没有则初始化Je，并标记全局malloc_initialized标记。</li>
<li>检查请求size是否大于huge，如果是则执行8，否则进入下一步。</li>
<li>执行arena_malloc，首先检查size是否小于等于small maxclass，如果是则下一步，否则执行6.</li>
<li>如果允许且当前线程已绑定tcache，则从tcache分配small，并返回。否则下一步。</li>
<li>choose arena，并执行arena malloc small，返回。</li>
<li>如果允许且当前线程已绑定tcache，则从tcache分配large，并返回。否则下一步。</li>
<li>choose arena，并执行arena malloc large，返回。</li>
<li>执行huge malloc，并返回。</li>
</ol>
<h3 id="3-2-Initialize"><a href="#3-2-Initialize" class="headerlink" title="3.2 - Initialize"></a>3.2 - Initialize</h3><p>Je通过全局标记malloc_initialized指代是否初始化。在每次分配时，需要检查该标记，如果没有则执行malloc_init。</p>
<p>但通常条件下，malloc_init是在Je库被载入之前就调用的。通过gcc的编译扩展属性”constructor”实现，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ATTR(constructor)</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">jemalloc_constructor</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    malloc_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来由malloc_init_hard执行各项初始化工作。这里首先需要考虑的是多线程初始化导致的重入，Je通过malloc_initialized和malloc_initializer两个标记来识别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">malloc_mutex_lock(&amp;init_lock);</span><br><span class="line"><span class="comment">// xf: 如果在获得init_lock前已经有其他线程完成malloc_init,</span></span><br><span class="line"><span class="comment">// 或者当前线程在初始化过程中执行了malloc，导致递归初始化，则立即退出。</span></span><br><span class="line"><span class="keyword">if</span> (malloc_initialized || IS_INITIALIZER) &#123;</span><br><span class="line">    malloc_mutex_unlock(&amp;init_lock);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// xf: 如果开启多线程初始化，需要执行busy wait直到malloc_init在另外线程中</span></span><br><span class="line"><span class="comment">// 执行完毕后返回。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> JEMALLOC_THREADED_INIT</span></span><br><span class="line"><span class="keyword">if</span> (malloc_initializer != NO_INITIALIZER &amp;&amp; IS_INITIALIZER == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        malloc_mutex_unlock(&amp;init_lock);</span><br><span class="line">        CPU_SPINWAIT;</span><br><span class="line">        malloc_mutex_lock(&amp;init_lock);</span><br><span class="line">    &#125; <span class="keyword">while</span> (malloc_initialized == <span class="literal">false</span>);</span><br><span class="line">    malloc_mutex_unlock(&amp;init_lock);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// xf: 将当前线程注册为initializer</span></span><br><span class="line">malloc_initializer = INITIALIZER;</span><br></pre></td></tr></table></figure>
<p>初始化工作由各个xxx_boot函数完成。注意的是，boot函数返回false代表成功，否则代表失败。</p>
<ul>
<li><code>tsd boot</code>: Thread specific data初始化，主要负责tsd析构函数数组长度初始化。</li>
<li><code>base boot</code>: base是Je内部用于meta data分配的保留区域，使用内部独立的分配方式。base boot负责base node和base mutex的初始化。</li>
<li><code>chunk boot</code>: 主要有三件工作，<ul>
<li>确认chunk_size和chunk_npages</li>
<li>chunk_dss_boot，chunk dss指chunk分配的dss(Data Storage Segment)方式。其中涉及dss_base，dss_prev指针的初始化工作。</li>
<li>chunk tree的初始化，在chunk recycle时要用到。</li>
</ul>
</li>
<li><code>arena boot</code>: 主要是确认arena_maxclass，这个size代表arena管理的最大region，超过该值被认为huge region.在2.2.2小节中有过介绍，先通过多次迭代计算出map_bias，再用chunksize - (map_bias &lt;&lt; LG_PAGE)即可得到。另外还对另一个重要的静态数组arena_bin_info执行了初始化。可参考2.3.2介绍class size的部分。</li>
<li><code>tcache boot</code>: 分为tcache_boot0和tcache_boot1两个部分执行。前者负责tcache所有静态信息，包含tcache_bin_info，stack_nelms,nhbins等的初始化。后者负责tcache tsd数据的初始化(tcache保存到线程tsd中).</li>
<li><code>huge boot</code>: 负责huge mutex和huge tree的初始化。</li>
</ul>
<p>除此之外，其他重要的初始化还包括分配arenas数组。注意arenas是一个指向指针数组的指针，因此各个arena还需要动态创建。这里Je采取了lazy create的方式，只有当choose_arena时才可能由choose_arena_hard创建真实的arena实例。但在malloc_init中，首个arena还是会在此时创建，以保证基本的分配。</p>
<p>相关代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_t</span> *init_arenas[<span class="number">1</span>];</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 此时narenas_total只有1</span></span><br><span class="line">narenas_total = narenas_auto = <span class="number">1</span>;</span><br><span class="line">arenas = init_arenas;</span><br><span class="line"><span class="built_in">memset</span>(arenas, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">arena_t</span> *) * narenas_auto);</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 创建首个arena实例，保存到临时数组init_arenas中</span></span><br><span class="line">arenas_extend(<span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 获得当前系统核心数量</span></span><br><span class="line">ncpus = malloc_ncpus();</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 默认的narenas为核心数量的4倍</span></span><br><span class="line"><span class="keyword">if</span> (opt_narenas == <span class="number">0</span>) &#123;    </span><br><span class="line">    <span class="keyword">if</span> (ncpus &gt; <span class="number">1</span>)</span><br><span class="line">        opt_narenas = ncpus &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        opt_narenas = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: android中max arenas限制为2，参考mk文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ANDROID_MAX_ARENAS)</span></span><br><span class="line"><span class="keyword">if</span> (opt_narenas &gt; ANDROID_MAX_ARENAS)</span><br><span class="line">    opt_narenas = ANDROID_MAX_ARENAS;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">narenas_auto = opt_narenas;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 修正narenas_total</span></span><br><span class="line">narenas_total = narenas_auto;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 根据total数量，构造arenas数组，并置空</span></span><br><span class="line">arenas = (<span class="type">arena_t</span> **)base_alloc(<span class="keyword">sizeof</span>(<span class="type">arena_t</span> *) * narenas_total);</span><br><span class="line">......</span><br><span class="line"><span class="built_in">memset</span>(arenas, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">arena_t</span> *) * narenas_total);</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 将之前的首个arena实例指针保存到新构造的arenas数组中</span></span><br><span class="line">arenas[<span class="number">0</span>] = init_arenas[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h3 id="3-3-Small-allocation-Arena"><a href="#3-3-Small-allocation-Arena" class="headerlink" title="3.3 - Small allocation (Arena)"></a>3.3 - Small allocation (Arena)</h3><p>先介绍最复杂的arena malloc small.</p>
<ol>
<li>先通过small_size2bin查到bin index(2.4.3节有述).</li>
<li>若对应bin中current run可用则进入下一步，否则执行4.</li>
<li>由arena_run_reg_alloc在current run中直接分配，并返回。</li>
<li>current run耗尽或不存在，尝试从bin中获得可用run以填充current run，成功则执行9，否则进入下一步。</li>
<li>当前bin的run tree中没有可用run，转而从arena的avail-tree上尝试切割一个可用run，成功则执行9，否则进入下一步。</li>
<li>当前arena没有可用的空闲run，构造一个新的chunk以分配new run. 成功则执行9，否则进入下一步。</li>
<li>chunk分配失败，再次查询arena的avail-tree，查找可用run. 成功则执行9，否则进入下一步。</li>
<li>alloc run尝试彻底失败，则再次查询当前bin的run-tree，尝试获取run。</li>
<li>在使用新获得run之前，重新检查当前bin的current run，如果可用(这里有两种可能，其一是其他线程可能通过free释放了多余的region或run，另一种可能是抢在当前线程之前已经分配了新run)，则使用其分配，并返回。另外，如果当前手中的new run是空的，则将其释放掉。否则若其地址比current run更低，则交换二者，将旧的current run插回avail-tree。</li>
<li>在new run中分配region，并返回。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_malloc_small</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">size_t</span> size, <span class="type">bool</span> zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 根据size计算bin index</span></span><br><span class="line">    binind = small_size2bin(size);</span><br><span class="line">    assert(binind &lt; NBINS);</span><br><span class="line">    bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">    size = small_bin2size(binind);</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: 如果bin中current run不为空，且存在空闲region，则在current</span></span><br><span class="line">    <span class="comment">// run中分配。否则在其他run中分配。</span></span><br><span class="line">    <span class="keyword">if</span> ((run = bin-&gt;runcur) != <span class="literal">NULL</span> &amp;&amp; run-&gt;nfree &gt; <span class="number">0</span>)</span><br><span class="line">        ret = arena_run_reg_alloc(run, &amp;arena_bin_info[binind]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = arena_bin_malloc_hard(arena, bin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 若返回null，则分配失败。</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-arena-run-reg-alloc"><a href="#3-3-1-arena-run-reg-alloc" class="headerlink" title="3.3.1 - arena_run_reg_alloc"></a>3.3.1 - arena_run_reg_alloc</h4><ol>
<li>首先根据bin_info中的静态信息bitmap_offset计算bitmap基址。</li>
<li>扫描当前run的bitmap，获得第一个free region所在的位置。</li>
<li>region地址 = run基址 + 第一个region的偏移量 + free region索引 * region内部size</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_run_reg_alloc</span><span class="params">(<span class="type">arena_run_t</span> *run, <span class="type">arena_bin_info_t</span> *bin_info)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 计算bitmap基址</span></span><br><span class="line">    <span class="type">bitmap_t</span> *bitmap = (<span class="type">bitmap_t</span> *)((<span class="type">uintptr_t</span>)run +</span><br><span class="line">        (<span class="type">uintptr_t</span>)bin_info-&gt;bitmap_offset);</span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// xf: 获得当前run中第一个free region所在bitmap中的位置</span></span><br><span class="line">    regind = bitmap_sfu(bitmap, &amp;bin_info-&gt;bitmap_info);</span><br><span class="line">    <span class="comment">// xf: 计算返回值</span></span><br><span class="line">    ret = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)run + (<span class="type">uintptr_t</span>)bin_info-&gt;reg0_offset +</span><br><span class="line">        (<span class="type">uintptr_t</span>)(bin_info-&gt;reg_interval * regind));</span><br><span class="line">    <span class="comment">// xf: free减1</span></span><br><span class="line">    run-&gt;nfree--;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中bitmap_sfu是执行bitmap遍历并设置第一个unset bit。如2.5节所述，bitmap由多级组成，遍历由top level开始循环迭代，直至bottom level。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="type">size_t</span></span><br><span class="line"><span class="title function_">bitmap_sfu</span><span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">const</span> <span class="type">bitmap_info_t</span> *binfo)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 找到最高级level，并计算ffs</span></span><br><span class="line">    i = binfo-&gt;nlevels - <span class="number">1</span>;</span><br><span class="line">    g = bitmap[binfo-&gt;levels[i].group_offset];</span><br><span class="line">    bit = jemalloc_ffsl(g) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// xf: 循环迭代，直到level0</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="comment">// xf: 根据上一级level的结果，计算当前level的group</span></span><br><span class="line">        g = bitmap[binfo-&gt;levels[i].group_offset + bit];</span><br><span class="line">        <span class="comment">// xf: 根据当前level group，计算下一级需要的bit</span></span><br><span class="line">        bit = (bit &lt;&lt; LG_BITMAP_GROUP_NBITS) + (jemalloc_ffsl(g) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 得到level0的bit，设置bitmap</span></span><br><span class="line">    bitmap_set(bitmap, binfo, bit);</span><br><span class="line">    <span class="keyword">return</span> (bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bitmap_set同普通bitmap操作没有什么区别，只是在set/unset之后需要反向迭代更新各个高等级level对应的bit位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">bitmap_set</span><span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">const</span> <span class="type">bitmap_info_t</span> *binfo, <span class="type">size_t</span> bit)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 计算该bit所在level0中的group</span></span><br><span class="line">    goff = bit &gt;&gt; LG_BITMAP_GROUP_NBITS;</span><br><span class="line">    <span class="comment">// xf: 得到目标group的值g</span></span><br><span class="line">    gp = &amp;bitmap[goff];</span><br><span class="line">    g = *gp;</span><br><span class="line">    <span class="comment">// xf: 根据remainder，找到target bit，并反转</span></span><br><span class="line">    g ^= <span class="number">1LU</span> &lt;&lt; (bit &amp; BITMAP_GROUP_NBITS_MASK);</span><br><span class="line">    *gp = g;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 若target bit所在group为0，则需要更新highlevel的相应bit,</span></span><br><span class="line">    <span class="comment">// 是bitmap_sfu的反向操作。</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">unsigned</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; binfo-&gt;nlevels; i++) &#123;</span><br><span class="line">            bit = goff;</span><br><span class="line">            goff = bit &gt;&gt; LG_BITMAP_GROUP_NBITS;</span><br><span class="line">            gp = &amp;bitmap[binfo-&gt;levels[i].group_offset + goff];</span><br><span class="line">            g = *gp;</span><br><span class="line">            assert(g &amp; (<span class="number">1LU</span> &lt;&lt; (bit &amp; BITMAP_GROUP_NBITS_MASK)));</span><br><span class="line">            g ^= <span class="number">1LU</span> &lt;&lt; (bit &amp; BITMAP_GROUP_NBITS_MASK);</span><br><span class="line">            *gp = g;</span><br><span class="line">            <span class="keyword">if</span> (g != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-arena-bin-malloc-hard"><a href="#3-3-2-arena-bin-malloc-hard" class="headerlink" title="3.3.2 - arena_bin_malloc_hard"></a>3.3.2 - arena_bin_malloc_hard</h4><ol>
<li>从bin中获得可用的nonfull run，这个过程中bin-&gt;lock有可能被解锁。</li>
<li>暂不使用new run，返回检查bin-&gt;runcur是否重新可用。如果是，则直接在其中分配region(其他线程在bin lock解锁期间可能提前修改了runcur)。否则，执行4.</li>
<li>重新检查1中得到的new run，如果为空，则释放该run.否则与当前runcur作比较，若地址低于runcur，则与其做交换。将旧的runcur插回run tree。并返回new rigion.</li>
<li>用new run填充runcur，并在其中分配region，返回。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_bin_malloc_hard</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_bin_t</span> *bin)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 获得bin对应的arena_bin_info，并将current run置空</span></span><br><span class="line">    binind = arena_bin_index(arena, bin);</span><br><span class="line">    bin_info = &amp;arena_bin_info[binind];</span><br><span class="line">    bin-&gt;runcur = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 从指定bin中获得一个可用的run</span></span><br><span class="line">    run = arena_bin_nonfull_run_get(arena, bin);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对bin-&gt;runcur做重新检查。如果可用且未耗尽，则直接分配。</span></span><br><span class="line">    <span class="keyword">if</span> (bin-&gt;runcur != <span class="literal">NULL</span> &amp;&amp; bin-&gt;runcur-&gt;nfree &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = arena_run_reg_alloc(bin-&gt;runcur, bin_info);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 若new run为空，则将其释放。否则重新插入run tree.</span></span><br><span class="line">        <span class="keyword">if</span> (run != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">arena_chunk_t</span> *chunk;</span><br><span class="line">            chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(run);</span><br><span class="line">            <span class="keyword">if</span> (run-&gt;nfree == bin_info-&gt;nregs)</span><br><span class="line">                arena_dalloc_bin_run(arena, chunk, run, bin);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                arena_bin_lower_run(arena, chunk, run, bin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (run == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 到这里在bin-&gt;runcur中分配失败，用当前新获得的run填充current run</span></span><br><span class="line">    bin-&gt;runcur = run;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 在new run中分配region</span></span><br><span class="line">    <span class="keyword">return</span> (arena_run_reg_alloc(bin-&gt;runcur, bin_info));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-arena-bin-nonfull-run-get"><a href="#3-3-3-arena-bin-nonfull-run-get" class="headerlink" title="3.3.3 - arena_bin_nonfull_run_get"></a>3.3.3 - arena_bin_nonfull_run_get</h4><ol>
<li>尝试在当前run tree中寻找可用run，成功则返回，否则进入下一步</li>
<li>解锁bin lock，并加锁arena lock，尝试在当前arena中分配new run。之后重新解锁arena lock，并加锁bin lock。如果成功则返回，否则进入下一步。</li>
<li>分配失败，重新在当前run tree中寻找一遍可用run.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">arena_run_t</span> *</span><br><span class="line"><span class="title function_">arena_bin_nonfull_run_get</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_bin_t</span> *bin)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 尝试从当前run tree中寻找一个可用run，如果存在就返回</span></span><br><span class="line">    run = arena_bin_nonfull_run_tryget(bin);</span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (run);    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 打开bin lock，让其他线程可以操作当前的bin tree</span></span><br><span class="line">    malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: 锁住arena lock，以分配new run</span></span><br><span class="line">    malloc_mutex_lock(&amp;arena-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 尝试分配new run</span></span><br><span class="line">    run = arena_run_alloc_small(arena, bin_info-&gt;run_size, binind);</span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化new run和bitmap</span></span><br><span class="line">        <span class="type">bitmap_t</span> *bitmap = (<span class="type">bitmap_t</span> *)((<span class="type">uintptr_t</span>)run +</span><br><span class="line">            (<span class="type">uintptr_t</span>)bin_info-&gt;bitmap_offset);</span><br><span class="line"></span><br><span class="line">        run-&gt;bin = bin;</span><br><span class="line">        run-&gt;nextind = <span class="number">0</span>;</span><br><span class="line">        run-&gt;nfree = bin_info-&gt;nregs;</span><br><span class="line">        bitmap_init(bitmap, &amp;bin_info-&gt;bitmap_info);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 解锁arena lock</span></span><br><span class="line">    malloc_mutex_unlock(&amp;arena-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: 重新加锁bin lock</span></span><br><span class="line">    malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 如果run alloc失败，则回过头重新try get一次(前面解锁bin lock</span></span><br><span class="line">    <span class="comment">// 给了其他线程机会).</span></span><br><span class="line">    run = arena_bin_nonfull_run_tryget(bin);</span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-4-Small-Run-Alloc"><a href="#3-3-4-Small-Run-Alloc" class="headerlink" title="3.3.4 - Small Run Alloc"></a>3.3.4 - Small Run Alloc</h4><ol>
<li>从arena avail tree上获得一个可用run，并对其切割。失败进入下一步。</li>
<li>尝试给arena分配新的chunk，以构造new run。此过程可能会解锁arena lock.失败进入下一步。</li>
<li>其他线程可能在此过程中释放了某些run，重新检查avail-tree，尝试获取run。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">arena_run_t</span> *</span><br><span class="line"><span class="title function_">arena_run_alloc_small</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">size_t</span> size, <span class="type">size_t</span> binind)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 从available tree上尝试寻找并切割一个合适的run，并对其初始化</span></span><br><span class="line">    run = arena_run_alloc_small_helper(arena, size, binind);</span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 当前arena内没有可用的空闲run，构造一个新的chunk以分配new run.</span></span><br><span class="line">    chunk = arena_chunk_alloc(arena);</span><br><span class="line">    <span class="keyword">if</span> (chunk != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        run = (<span class="type">arena_run_t</span> *)((<span class="type">uintptr_t</span>)chunk + (map_bias &lt;&lt; LG_PAGE));</span><br><span class="line">        arena_run_split_small(arena, run, size, binind);</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 重新检查arena avail-tree.</span></span><br><span class="line">    <span class="keyword">return</span> (arena_run_alloc_small_helper(arena, size, binind));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">arena_run_t</span> *</span><br><span class="line"><span class="title function_">arena_run_alloc_small_helper</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">size_t</span> size, <span class="type">size_t</span> binind)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 在arena的available tree中寻找一个大于等于size大小的最小run</span></span><br><span class="line">    key = (<span class="type">arena_chunk_map_t</span> *)(size | CHUNK_MAP_KEY);</span><br><span class="line">    mapelm = arena_avail_tree_nsearch(&amp;arena-&gt;runs_avail, key);</span><br><span class="line">    <span class="keyword">if</span> (mapelm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">arena_chunk_t</span> *run_chunk = CHUNK_ADDR2BASE(mapelm);</span><br><span class="line">        <span class="type">size_t</span> pageind = arena_mapelm_to_pageind(mapelm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 计算候选run的地址</span></span><br><span class="line">        run = (<span class="type">arena_run_t</span> *)((<span class="type">uintptr_t</span>)run_chunk + (pageind &lt;&lt;</span><br><span class="line">            LG_PAGE));</span><br><span class="line">        <span class="comment">// xf: 根据分配需求，切割候选run</span></span><br><span class="line">        arena_run_split_small(arena, run, size, binind);</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切割small run主要分为4步，</p>
<ol>
<li>将候选run的arena_chunk_map_t节点从avail-tree上摘除。</li>
<li>根据节点储存的原始page信息，以及need pages信息，切割该run.</li>
<li>更新remainder节点信息(只需更新首尾page)，重新插入avail-tree.</li>
<li>设置切割后new run所有page对应的map节点信息(根据2.3.3节所述).</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_run_split_small</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_run_t</span> *run, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> binind)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 获取目标run的dirty flag</span></span><br><span class="line">    chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(run);</span><br><span class="line">    run_ind = (<span class="type">unsigned</span>)(((<span class="type">uintptr_t</span>)run - (<span class="type">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE);</span><br><span class="line">    flag_dirty = arena_mapbits_dirty_get(chunk, run_ind);</span><br><span class="line">    need_pages = (size &gt;&gt; LG_PAGE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 1. 将候选run从available tree上摘除</span></span><br><span class="line">    <span class="comment">//     2. 根据need pages对候选run进行切割</span></span><br><span class="line">    <span class="comment">//     3. 将remainder重新插入available tree    </span></span><br><span class="line">    arena_run_split_remove(arena, chunk, run_ind, flag_dirty, need_pages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 设置刚刚被split后的run的第一个page</span></span><br><span class="line">    arena_mapbits_small_set(chunk, run_ind, <span class="number">0</span>, binind, flag_dirty);</span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// xf: 依次设置run中的其他page, run index依次递增</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; need_pages - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arena_mapbits_small_set(chunk, run_ind+i, i, binind, <span class="number">0</span>);</span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 设置run中的最后一个page</span></span><br><span class="line">    arena_mapbits_small_set(chunk, run_ind+need_pages<span class="number">-1</span>, need_pages<span class="number">-1</span>,</span><br><span class="line">        binind, flag_dirty);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-5-Chunk-Alloc"><a href="#3-3-5-Chunk-Alloc" class="headerlink" title="3.3.5 - Chunk Alloc"></a>3.3.5 - Chunk Alloc</h4><p>arena获取chunk一般有两个途径。其一是通过内部的spare指针。该指针缓存了最近一次chunk被释放的记录。因此该方式速度很快。另一种更加常规，通过内部分配函数分配，最终将由chunk_alloc_core执行。但在Je的设计中，执行arena chunk的分配器是可定制的，你可以替换任何第三方chunk分配器。这里仅讨论默认情况。</p>
<p>Je在chunk_alloc_core中同传统分配器如Dl有较大区别。通常情况下，从系统获取内存无非是morecore或mmap两种方式。Dl中按照先morecore-&gt;mmap的顺序，而Je更为灵活，具体的顺序由dss_prec_t决定。</p>
<p>该类型是一个枚举，定义如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    dss_prec_disabled  = <span class="number">0</span>,</span><br><span class="line">    dss_prec_primary   = <span class="number">1</span>,</span><br><span class="line">    dss_prec_secondary = <span class="number">2</span>,</span><br><span class="line">    dss_prec_limit     = <span class="number">3</span></span><br><span class="line">&#125; <span class="type">dss_prec_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里dss和morecore含义是相同的。primary表示优先dss，secondary则优先mmap。Je默认使用后者。</p>
<p>实际分配时，无论采用哪种策略，都会优先执行chunk_recycle，再执行chunk alloc，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">chunk_alloc_core</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> alignment, <span class="type">bool</span> base, <span class="type">bool</span> *zero,</span></span><br><span class="line"><span class="params">    <span class="type">dss_prec_t</span> dss_prec)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (have_dss &amp;&amp; dss_prec == dss_prec_primary) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = chunk_recycle(&amp;chunks_szad_dss, &amp;chunks_ad_dss, size,</span><br><span class="line">            alignment, base, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (ret);</span><br><span class="line">        <span class="keyword">if</span> ((ret = chunk_alloc_dss(size, alignment, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = chunk_recycle(&amp;chunks_szad_mmap, &amp;chunks_ad_mmap, size,</span><br><span class="line">        alignment, base, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">    <span class="keyword">if</span> ((ret = chunk_alloc_mmap(size, alignment, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (have_dss &amp;&amp; dss_prec == dss_prec_secondary) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = chunk_recycle(&amp;chunks_szad_dss, &amp;chunks_ad_dss, size,</span><br><span class="line">            alignment, base, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (ret);</span><br><span class="line">        <span class="keyword">if</span> ((ret = chunk_alloc_dss(size, alignment, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓chunk recycle是在alloc chunk之前，优先在废弃的chunk tree上搜索可用chunk，并分配base node以储存meta data的过程。好处是其一可以加快分配速度，其二是使空间分配更加紧凑，并节省内存。</p>
<p>在Je中存在4棵全局的rb tree，分别为，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">extent_tree_t</span>    chunks_szad_mmap;</span><br><span class="line"><span class="type">static</span> <span class="type">extent_tree_t</span>    chunks_ad_mmap;</span><br><span class="line"><span class="type">static</span> <span class="type">extent_tree_t</span>    chunks_szad_dss;</span><br><span class="line"><span class="type">static</span> <span class="type">extent_tree_t</span>    chunks_ad_dss;</span><br></pre></td></tr></table></figure>
<p>它们分别对应mmap和dss方式。当一个chunk或huge region被释放后，将收集到这4棵tree中。szad和ad在内容上并无本质区别，只是检索方式不一样。前者采用先size后address的方式，后者则是纯address的检索。</p>
<p>recycle算法概括如下，</p>
<ol>
<li>检查base标志，如果为真则直接返回，否则进入下一步。开始的检查是必要的，因为recycle过程中可能会创建新的extent node，要求调用base allocator分配。另一方面，base alloc可能因为耗尽的原因而反过来调用chunk alloc。如此将导致dead loop.</li>
<li>根据alignment计算分配大小，并在szad tree(mmap还是dss需要上一级决定)上寻找一个大于等于alloc size的最小node.</li>
<li>chunk tree上的node未必对齐到alignment上，将地址对齐，之后将得到leadsize和trailsize.</li>
<li>将原node从chunk tree上remove。若leadsize不为0，则将其作为新的chunk重新insert回chunk tree。trailsize不为0的情况亦然。若leadsize和trailsize同时不为0，则通过base_node_alloc为trailsize生成新的node并插入。若base alloc失败，则整个新分配的region都要销毁。</li>
<li>若leadsize和trailsize都为0，则将node(注意仅仅是节点)释放。返回对齐后的chunk地址。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">chunk_recycle</span><span class="params">(<span class="type">extent_tree_t</span> *chunks_szad, <span class="type">extent_tree_t</span> *chunks_ad, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> alignment, <span class="type">bool</span> base, <span class="type">bool</span> *zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 由于构造extent_node时可能因为内存不足的原因，同样需要构造chunk,</span></span><br><span class="line">    <span class="comment">// 这样就导致recursively dead loop。因此依靠base标志，区分普通alloc和</span></span><br><span class="line">    <span class="comment">// base node alloc。如果是base alloc，则立即返回。</span></span><br><span class="line">    <span class="keyword">if</span> (base) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 计算分配大小</span></span><br><span class="line">    alloc_size = size + alignment - chunksize;</span><br><span class="line">    ......</span><br><span class="line">    key.addr = <span class="literal">NULL</span>;</span><br><span class="line">    key.size = alloc_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 在指定的szad tree上寻找大于等于alloc size的最小可用node</span></span><br><span class="line">    malloc_mutex_lock(&amp;chunks_mtx);</span><br><span class="line">    node = extent_tree_szad_nsearch(chunks_szad, &amp;key);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 将候选节点基址对齐到分配边界上，并计算leadsize, trailsize</span></span><br><span class="line">    <span class="comment">// 以及返回地址。</span></span><br><span class="line">    leadsize = ALIGNMENT_CEILING((<span class="type">uintptr_t</span>)node-&gt;addr, alignment) -</span><br><span class="line">        (<span class="type">uintptr_t</span>)node-&gt;addr;</span><br><span class="line">    trailsize = node-&gt;size - leadsize - size;</span><br><span class="line">    ret = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)node-&gt;addr + leadsize);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 将原node从szad/ad tree上移除</span></span><br><span class="line">    extent_tree_szad_remove(chunks_szad, node);</span><br><span class="line">    extent_tree_ad_remove(chunks_ad, node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 如果存在leadsize，则将前面多余部分作为一个chunk重新插入</span></span><br><span class="line">    <span class="comment">// szad/ad tree上。</span></span><br><span class="line">    <span class="keyword">if</span> (leadsize != <span class="number">0</span>) &#123;</span><br><span class="line">        node-&gt;size = leadsize;</span><br><span class="line">        extent_tree_szad_insert(chunks_szad, node);</span><br><span class="line">        extent_tree_ad_insert(chunks_ad, node);</span><br><span class="line">        node = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 同样如果存在trailsize，也将后面的多余部分插入。</span></span><br><span class="line">    <span class="keyword">if</span> (trailsize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// xf: 如果leadsize不为0，这时原来的extent_node已经被用过了，</span></span><br><span class="line">        <span class="comment">// 则必须为trailsize部分重新分配新的extent_node</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            malloc_mutex_unlock(&amp;chunks_mtx);</span><br><span class="line">            node = base_node_alloc();</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// xf: 计算trail chunk，并插入</span></span><br><span class="line">        node-&gt;addr = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)(ret) + size);</span><br><span class="line">        node-&gt;size = trailsize;</span><br><span class="line">        node-&gt;zeroed = zeroed;</span><br><span class="line">        extent_tree_szad_insert(chunks_szad, node);</span><br><span class="line">        extent_tree_ad_insert(chunks_ad, node);</span><br><span class="line">        node = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    malloc_mutex_unlock(&amp;chunks_mtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: leadsize &amp; basesize都不存在，将node释放。</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        base_node_dalloc(node);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常规分配方式先来看dss。由于dss是与当前进程的brk指针相关的，任何线程(包括可能不通过Je执行分配的线程)都有权修改该指针值。因此，首先要把dss指针调整到对齐在chunksize边界的位置，否则很多与chunk相关的计算都会失效。接下来，还要做第二次调整对齐到外界请求的alignment边界。在此基础上再进行分配。</p>
<p>与dss分配相关的变量如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">malloc_mutex_t</span>    dss_mtx;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>        *dss_base;      </span><br><span class="line"><span class="type">static</span> <span class="type">void</span>        *dss_prev;      </span><br><span class="line"><span class="type">static</span> <span class="type">void</span>        *dss_max;       </span><br></pre></td></tr></table></figure>
<ul>
<li><code>dss_mtx</code>:  dss lock。注意其并不能起到保护dss指针的作用，因为brk是一个系统资源。该lock保护的是dss_prev, dss_max指针。</li>
<li><code>dss_base</code>: 只在chunk_dss_boot时更新一次。主要用作识别chunk在线性地址空间中所处的位置，与mmap作出区别。</li>
<li><code>dss_prev</code>: 当前dss指针，是系统brk指针的副本，值等于-1代表dss耗尽。</li>
<li><code>dss_max</code>:  当前dss区域上限。</li>
</ul>
<p>dss alloc算法如下，</p>
<ol>
<li>获取brk指针，更新到dss_max.</li>
<li>将dss_max对齐到chunksize边界上，计算padding大小gap_size</li>
<li>再将dss_max对齐到aligment边界上，得到cpad_size</li>
<li>计算需要分配的大小，并尝试sbrk。<code>incr = gap_size + cpad_size + size</code></li>
<li>分配成功，检查cpad是否非0，是则将这部分重新回收。而gap_size部分因为不可用则被废弃。</li>
<li>如果分配失败，则检查dss是否耗尽，如果没有则返回1重新尝试。否则返回。</li>
</ol>
<p>示意图，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chunk_base             cpad        ret        dss_next</span><br><span class="line">    |                   |           |            |</span><br><span class="line">    v                   v           v            v</span><br><span class="line">    +--------+----------+-----------+------   ---+</span><br><span class="line">    |  used  | gap_size | cpad_size | size ...   |</span><br><span class="line">    +--------+----------+-----------+------   ---+</span><br><span class="line">             |&lt;------------- incr --------------&gt;|            </span><br><span class="line">             ^          ^           ^  </span><br><span class="line">             |          |           |</span><br><span class="line">          dss_max  chunk_base +     +-- chunk_base +</span><br><span class="line">                     chunk_size          alignment</span><br></pre></td></tr></table></figure>
<p>源码注释，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">chunk_alloc_dss</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> alignment, <span class="type">bool</span> *zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">// xf: dss是否耗尽</span></span><br><span class="line">    malloc_mutex_lock(&amp;dss_mtx);</span><br><span class="line">    <span class="keyword">if</span> (dss_prev != (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// xf: 获取当前dss指针</span></span><br><span class="line">            dss_max = chunk_dss_sbrk(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// xf: 计算对齐到chunk size边界需要的padding大小</span></span><br><span class="line">            gap_size = (chunksize - CHUNK_ADDR2OFFSET(dss_max)) &amp;</span><br><span class="line">                chunksize_mask;</span><br><span class="line">            <span class="comment">// xf: 对齐到chunk边界的chunk起始地址</span></span><br><span class="line">            cpad = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)dss_max + gap_size);</span><br><span class="line">            <span class="comment">// xf: 对齐到alignment边界的起始地址</span></span><br><span class="line">            ret = (<span class="type">void</span> *)ALIGNMENT_CEILING((<span class="type">uintptr_t</span>)dss_max,</span><br><span class="line">                alignment);</span><br><span class="line">            cpad_size = (<span class="type">uintptr_t</span>)ret - (<span class="type">uintptr_t</span>)cpad;</span><br><span class="line">            <span class="comment">// xf: dss_max分配后的更新地址</span></span><br><span class="line">            dss_next = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)ret + size);</span><br><span class="line">            ......</span><br><span class="line">            incr = gap_size + cpad_size + size;</span><br><span class="line">            <span class="comment">// xf: 从dss分配</span></span><br><span class="line">            dss_prev = chunk_dss_sbrk(incr);</span><br><span class="line">            <span class="keyword">if</span> (dss_prev == dss_max) &#123;</span><br><span class="line">                dss_max = dss_next;</span><br><span class="line">                malloc_mutex_unlock(&amp;dss_mtx);</span><br><span class="line">                <span class="comment">// xf: 如果ret和cpad对齐不在同一个位置，则将cpad开始</span></span><br><span class="line">                <span class="comment">// cpad_size大小的内存回收到szad/ad tree中。而以之前</span></span><br><span class="line">                <span class="comment">// dss起始的gap_size大小内存由于本身并非对齐到</span></span><br><span class="line">                <span class="comment">// chunk_size，则被废弃。</span></span><br><span class="line">                <span class="keyword">if</span> (cpad_size != <span class="number">0</span>)</span><br><span class="line">                    chunk_unmap(cpad, cpad_size);</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">return</span> (ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (dss_prev != (<span class="type">void</span> *)<span class="number">-1</span>);   <span class="comment">// xf: 反复尝试直至dss耗尽</span></span><br><span class="line">    &#125;</span><br><span class="line">    malloc_mutex_unlock(&amp;dss_mtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后介绍chunk_alloc_mmap。同dss方式类似，mmap也存在对齐的问题。由于系统mmap调用无法指定alignment，因此Je实现了一个可以实现对齐但速度更慢的mmap slow方式。作为弥补，在chunk alloc mmap时先尝试依照普通方式mmap，如果返回值恰好满足对齐要求则直接返回(多数情况下是可行的)。否则将返回值munmap，再调用mmap slow.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">chunk_alloc_mmap</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> alignment, <span class="type">bool</span> *zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    ret = pages_map(<span class="literal">NULL</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    offset = ALIGNMENT_ADDR2OFFSET(ret, alignment);</span><br><span class="line">    <span class="keyword">if</span> (offset != <span class="number">0</span>) &#123;</span><br><span class="line">        pages_unmap(ret, size);</span><br><span class="line">        <span class="keyword">return</span> (chunk_alloc_mmap_slow(size, alignment, zero));</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mmap slow通过事先分配超量size，对齐后再执行trim，去掉前后余量实现mmap对齐。page trim通过两次munmap将leadsize和trailsize部分分别释放。因此理论上，mmap slow需要最多三次munmap.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|&lt;-------------alloc_size----------&gt;|</span><br><span class="line">+-----------+-----   --+------------+</span><br><span class="line">| lead_size | size...  | trail_size |</span><br><span class="line">+-----------+-----   --+------------+</span><br><span class="line">^           ^</span><br><span class="line">|           |</span><br><span class="line">pages      ret(alignment)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">chunk_alloc_mmap_slow</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> alignment, <span class="type">bool</span> *zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    alloc_size = size + alignment - PAGE;</span><br><span class="line">    <span class="keyword">if</span> (alloc_size &lt; size)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        pages = pages_map(<span class="literal">NULL</span>, alloc_size);</span><br><span class="line">        <span class="keyword">if</span> (pages == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">        leadsize = ALIGNMENT_CEILING((<span class="type">uintptr_t</span>)pages, alignment) -</span><br><span class="line">            (<span class="type">uintptr_t</span>)pages;</span><br><span class="line">        ret = pages_trim(pages, alloc_size, leadsize, size);</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret == <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">pages_trim</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> alloc_size, <span class="type">size_t</span> leadsize, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)addr + leadsize);</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> trailsize = alloc_size - leadsize - size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leadsize != <span class="number">0</span>)</span><br><span class="line">            pages_unmap(addr, leadsize);</span><br><span class="line">        <span class="keyword">if</span> (trailsize != <span class="number">0</span>)</span><br><span class="line">            pages_unmap((<span class="type">void</span> *)((<span class="type">uintptr_t</span>)ret + size), trailsize);</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-Small-allocation-tcache"><a href="#3-4-Small-allocation-tcache" class="headerlink" title="3.4 - Small allocation (tcache)"></a>3.4 - Small allocation (tcache)</h3><p>tcache内分配按照先easy后hard的方式。easy方式直接从tcache bin的avail-stack中获得可用region。如果tbin耗尽，使用hard方式，先refill avail-stack，再执行easy分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_alloc_small</span><span class="params">(<span class="type">tcache_t</span> *tcache, <span class="type">size_t</span> size, <span class="type">bool</span> zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 先从tcache bin尝试分配</span></span><br><span class="line">    ret = tcache_alloc_easy(tbin);</span><br><span class="line">    <span class="comment">// xf: 如果尝试失败，则refill tcache bin，并尝试分配</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = tcache_alloc_small_hard(tcache, tbin, binind);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 执行tcache event</span></span><br><span class="line">    tcache_event(tcache);</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_alloc_easy</span><span class="params">(<span class="type">tcache_bin_t</span> *tbin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 如果tcache bin耗尽，更新水线为-1</span></span><br><span class="line">    <span class="keyword">if</span> (tbin-&gt;ncached == <span class="number">0</span>) &#123;</span><br><span class="line">        tbin-&gt;low_water = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: pop栈顶的region，如果需要更新水线</span></span><br><span class="line">    tbin-&gt;ncached--;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">int</span>)tbin-&gt;ncached &lt; tbin-&gt;low_water)</span><br><span class="line">        tbin-&gt;low_water = tbin-&gt;ncached;</span><br><span class="line">    ret = tbin-&gt;avail[tbin-&gt;ncached];</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_alloc_small_hard</span><span class="params">(<span class="type">tcache_t</span> *tcache, <span class="type">tcache_bin_t</span> *tbin, <span class="type">size_t</span> binind)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    arena_tcache_fill_small(tcache-&gt;arena, tbin, binind,</span><br><span class="line">        config_prof ? tcache-&gt;prof_accumbytes : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (config_prof)</span><br><span class="line">        tcache-&gt;prof_accumbytes = <span class="number">0</span>;</span><br><span class="line">    ret = tcache_alloc_easy(tbin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcache fill同普通的arena bin分配类似。首先，获得与tbin相同index的arena bin。之后确定fill值，该数值与2.7节介绍的lg_fill_div有关。如果arena run的runcur可用则直接分配并push stack，否则arena_bin_malloc_hard分配region。push后的顺序按照从低到高排列，低地址的region更靠近栈顶位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_tcache_fill_small</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">tcache_bin_t</span> *tbin, <span class="type">size_t</span> binind,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> prof_accumbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 得到与tbin同index的arena bin</span></span><br><span class="line">    bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">    malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: tbin的充满度与lg_fill_div相关</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, nfill = (tcache_bin_info[binind].ncached_max &gt;&gt;</span><br><span class="line">        tbin-&gt;lg_fill_div); i &lt; nfill; i++) &#123;</span><br><span class="line">        <span class="comment">// xf: 如果current run可用，则从中分配</span></span><br><span class="line">        <span class="keyword">if</span> ((run = bin-&gt;runcur) != <span class="literal">NULL</span> &amp;&amp; run-&gt;nfree &gt; <span class="number">0</span>)</span><br><span class="line">            ptr = arena_run_reg_alloc(run, &amp;arena_bin_info[binind]);</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// xf: current run耗尽，则从bin中查找其他run分配</span></span><br><span class="line">            ptr = arena_bin_malloc_hard(arena, bin);</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: 低地址region优先放入栈顶</span></span><br><span class="line">        tbin-&gt;avail[nfill - <span class="number">1</span> - i] = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: 更新ncached</span></span><br><span class="line">    tbin-&gt;ncached = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如2.7节所述，tcache在每次分配和释放后都会更新ev_cnt计数器。当计数周期达到TCACHE_GC_INCR时，就会启动tcache gc。gc过程中会清理相当于low_water 3/4数量的region，并根据当前的low_water和lg_fill_div动态调整下一次refill时，tbin的充满度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_bin_flush_small</span><span class="params">(<span class="type">tcache_bin_t</span> *tbin, <span class="type">size_t</span> binind, <span class="type">unsigned</span> rem,</span></span><br><span class="line"><span class="params">    <span class="type">tcache_t</span> *tcache)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......   </span><br><span class="line">    <span class="comment">// xf: 循环scan，直到nflush为空。</span></span><br><span class="line">    <span class="comment">// 因为avail-stack中的region可能来自不同arena，因此需要多次scan.</span></span><br><span class="line">    <span class="comment">// 每次scan将不同arena的region移动到栈顶，留到下一轮scan时清理。</span></span><br><span class="line">    <span class="keyword">for</span> (nflush = tbin-&gt;ncached - rem; nflush &gt; <span class="number">0</span>; nflush = ndeferred) &#123;</span><br><span class="line">        <span class="comment">// xf: 获得栈顶region所属的arena和arena bin</span></span><br><span class="line">        <span class="type">arena_chunk_t</span> *chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(</span><br><span class="line">            tbin-&gt;avail[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">arena_t</span> *arena = chunk-&gt;arena;</span><br><span class="line">        <span class="type">arena_bin_t</span> *bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: 锁住栈顶region的arena bin</span></span><br><span class="line">        malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: ndefered代表所属不同arena的region被搬移的位置，默认从0开始。</span></span><br><span class="line">        <span class="comment">// 本意是随着scan进行，nflush逐渐递增，nflush之前的位置空缺出来。</span></span><br><span class="line">        <span class="comment">// 当scan到不同arena region时，将其指针移动到nflush前面的空缺中，</span></span><br><span class="line">        <span class="comment">// 留到下一轮scan, nflush重新开始。直到ndefered和nflush重新为0.</span></span><br><span class="line">        ndeferred = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nflush; i++) &#123;</span><br><span class="line">            ptr = tbin-&gt;avail[i];</span><br><span class="line">            chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(ptr);</span><br><span class="line">            <span class="comment">// xf: 如果scan的region与栈顶region位于同一arena，则释放，</span></span><br><span class="line">            <span class="comment">// 否则移动到ndefered标注的位置，留到后面scan.</span></span><br><span class="line">            <span class="keyword">if</span> (chunk-&gt;arena == arena) &#123;</span><br><span class="line">                <span class="type">size_t</span> pageind = ((<span class="type">uintptr_t</span>)ptr -</span><br><span class="line">                    (<span class="type">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE;</span><br><span class="line">                <span class="type">arena_chunk_map_t</span> *mapelm =</span><br><span class="line">                    arena_mapp_get(chunk, pageind);</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// xf: 释放多余region</span></span><br><span class="line">                arena_dalloc_bin_locked(arena, chunk, ptr,</span><br><span class="line">                    mapelm);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tbin-&gt;avail[ndeferred] = ptr;</span><br><span class="line">                ndeferred++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 将remainder regions指针移动到栈顶位置，完成gc过程</span></span><br><span class="line">    memmove(tbin-&gt;avail, &amp;tbin-&gt;avail[tbin-&gt;ncached - rem],</span><br><span class="line">        rem * <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">    <span class="comment">// xf: 修正ncached以及low_water</span></span><br><span class="line">    tbin-&gt;ncached = rem;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">int</span>)tbin-&gt;ncached &lt; tbin-&gt;low_water)</span><br><span class="line">        tbin-&gt;low_water = tbin-&gt;ncached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-Large-allocation"><a href="#3-5-Large-allocation" class="headerlink" title="3.5 - Large allocation"></a>3.5 - Large allocation</h3><p>Arena上的large alloc同small相比除了省去arena bin的部分之外，并无本质区别。基本算法如下，</p>
<ol>
<li>把请求大小对齐到page size上，直接从avail-tree上寻找first-best-fit runs.如果成功，则根据请求大小切割内存。切割过程也同切割small run类似，区别在之后对chunk map的初始化不同。chunk map细节可回顾2.3.3。如果失败，则进入下一步。</li>
<li>没有可用runs，尝试创建new chunk，成功同样切割run，失败进入下一步。</li>
<li>再次尝试从avail-tree上寻找可用runs，并返回。</li>
</ol>
<p>同上面的过程可以看出，所谓large region分配相当于small run的分配。区别仅在于chunk map信息不同。</p>
<p>Tcache上的large alloc同样按照先easy后hard的顺序。尽管常规arena上的分配不存在large bin，但在tcache中却存在large tbin，因此仍然是先查找avail-stack.如果tbin中找不到，就会向arena申请large runs。这里与small alloc的区别在不执行tbin refill，因为考虑到过多large region的占用量问题。large tbin仅在tcache_dalloc_large的时候才负责收集region。当tcache已满或GC周期到时执行tcache gc.</p>
<h3 id="3-6-Huge-allocation"><a href="#3-6-Huge-allocation" class="headerlink" title="3.6 - Huge allocation"></a>3.6 - Huge allocation</h3><p>Huge alloc相对于前面就更加简单。因为对于Je而言，huge region和chunk是等同的，这在前面有过叙述。Huge alloc就是调用chunk alloc，并将extent_node记录在huge tree上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">huge_palloc</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">size_t</span> size, <span class="type">size_t</span> alignment, <span class="type">bool</span> zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line">    <span class="type">size_t</span> csize;</span><br><span class="line">    <span class="type">extent_node_t</span> *node;</span><br><span class="line">    <span class="type">bool</span> is_zeroed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: huge alloc对齐到chunksize</span></span><br><span class="line">    csize = CHUNK_CEILING(size);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: create extent node以记录huge region</span></span><br><span class="line">    node = base_node_alloc();</span><br><span class="line">    ......</span><br><span class="line">    arena = choose_arena(arena);</span><br><span class="line">    <span class="comment">// xf: 调用chunk alloc分配</span></span><br><span class="line">    ret = arena_chunk_alloc_huge(arena, csize, alignment, &amp;is_zeroed);</span><br><span class="line">    <span class="comment">// xf: 失败则清除extent node</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        base_node_dalloc(node);</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node-&gt;addr = ret;</span><br><span class="line">    node-&gt;size = csize;</span><br><span class="line">    node-&gt;arena = arena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 插入huge tree上</span></span><br><span class="line">    malloc_mutex_lock(&amp;huge_mtx);</span><br><span class="line">    extent_tree_ad_insert(&amp;huge, node);</span><br><span class="line">    malloc_mutex_unlock(&amp;huge_mtx);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="4-Deallocation"><a href="#4-Deallocation" class="headerlink" title="4 - Deallocation"></a>4 - Deallocation</h2><h3 id="4-1-Overview"><a href="#4-1-Overview" class="headerlink" title="4.1 - Overview"></a>4.1 - Overview</h3><p>释放同分配过程相反，按照一个从ptr -&gt; run -&gt; bin -&gt; chunk -&gt; arena的路径。但因为涉及page合并和purge，实现更为复杂。dalloc的入口从je_free -&gt; ifree -&gt; iqalloc -&gt; iqalloct -&gt; idalloct.对dalloc的分析从idalloct开始。代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">idalloct</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">bool</span> try_tcache)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 获得被释放地址所在的chunk</span></span><br><span class="line">    chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(ptr);</span><br><span class="line">    <span class="keyword">if</span> (chunk != ptr)</span><br><span class="line">        arena_dalloc(chunk, ptr, try_tcache);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        huge_dalloc(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会检测被释放指针ptr所在chunk的首地址与ptr是否一致，如果是，则一定为huge region，否则为small/large。从这里分为arena和huge两条线。</p>
<p>再看一下arena_dalloc，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_dalloc</span><span class="params">(<span class="type">arena_chunk_t</span> *chunk, <span class="type">void</span> *ptr, <span class="type">bool</span> try_tcache)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 得到页面mapbits</span></span><br><span class="line">    mapbits = arena_mapbits_get(chunk, pageind);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> ((mapbits &amp; CHUNK_MAP_LARGE) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (try_tcache &amp;&amp; (tcache = tcache_get(<span class="literal">false</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// xf: ptr所在tcache的index</span></span><br><span class="line">            binind = arena_ptr_small_binind_get(ptr, mapbits);</span><br><span class="line">            tcache_dalloc_small(tcache, ptr, binind);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            arena_dalloc_small(chunk-&gt;arena, chunk, ptr, pageind);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> size = arena_mapbits_large_size_get(chunk, pageind);</span><br><span class="line">        <span class="keyword">if</span> (try_tcache &amp;&amp; size &lt;= tcache_maxclass &amp;&amp; (tcache =</span><br><span class="line">            tcache_get(<span class="literal">false</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tcache_dalloc_large(tcache, ptr, size);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            arena_dalloc_large(chunk-&gt;arena, chunk, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过得到ptr所在page的mapbits，判断其来自于small还是large。然后再分别作处理。</p>
<p>因此，在dalloc一开始基本上分成了small/large/huge三条路线执行。事实上，结合前面的知识，large/huge可以看作run和chunk的特例。所以，这三条dalloc路线最终会汇到一起，只需要搞清楚其中最为复杂的small region dalloc就可以了。</p>
<p>无论small/large region，都会先尝试释放回tcache，不管其是否从tache中分配而来。所谓tcache dalloc只不过是将region记录在tbin中，并不算真正的释放。除非两种情况，一是如果当前线程tbin已满，会直接执行一次tbin flush，释放出部分tbin空间。二是如果tcache_event触发发了tache gc，也会执行flush。两者的区别在于，前者会回收指定tbin 1/2的空间，而后者则释放next_gc_bin相当于3/4low water数量的空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_dalloc_small</span><span class="params">(<span class="type">tcache_t</span> *tcache, <span class="type">void</span> *ptr, <span class="type">size_t</span> binind)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    tbin = &amp;tcache-&gt;tbins[binind];</span><br><span class="line">    tbin_info = &amp;tcache_bin_info[binind];</span><br><span class="line">    <span class="comment">// xf: 如果当前tbin已满，则执行flush清理tbin</span></span><br><span class="line">    <span class="keyword">if</span> (tbin-&gt;ncached == tbin_info-&gt;ncached_max) &#123;</span><br><span class="line">        tcache_bin_flush_small(tbin, binind, (tbin_info-&gt;ncached_max &gt;&gt;</span><br><span class="line">            <span class="number">1</span>), tcache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: 将被释放的ptr重新push进tbin</span></span><br><span class="line">    tbin-&gt;avail[tbin-&gt;ncached] = ptr;</span><br><span class="line">    tbin-&gt;ncached++;</span><br><span class="line"></span><br><span class="line">    tcache_event(tcache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcache gc和tcache flush在2.7和3.4节中已经介绍，不再赘述。</p>
<h3 id="4-2-arena-dalloc-bin"><a href="#4-2-arena-dalloc-bin" class="headerlink" title="4.2 - arena_dalloc_bin"></a>4.2 - arena_dalloc_bin</h3><p>small region dalloc的第一步是尝试将region返还给所属的bin。首要的步骤就是根据用户传入的ptr推算出其所在run的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run addr = chunk base + run page offset &lt;&lt; LG_PAGE</span><br></pre></td></tr></table></figure>
<p>而run page offset根据2.3.3小节的说明，可以通过ptr所在page的mapbits获得。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run page offset = ptr page index - ptr page offset</span><br></pre></td></tr></table></figure>
<p>得到run后就进一步拿到所属的bin，接着对bin加锁并回收，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_dalloc_bin</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">void</span> *ptr,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> pageind, <span class="type">arena_chunk_map_t</span> *mapelm)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 计算ptr所在run地址。    </span></span><br><span class="line">    run = (<span class="type">arena_run_t</span> *)((<span class="type">uintptr_t</span>)chunk + (<span class="type">uintptr_t</span>)((pageind -</span><br><span class="line">        arena_mapbits_small_runind_get(chunk, pageind)) &lt;&lt; LG_PAGE));</span><br><span class="line">    bin = run-&gt;bin;</span><br><span class="line"> </span><br><span class="line">    malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">    arena_dalloc_bin_locked(arena, chunk, ptr, mapelm);</span><br><span class="line">    malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock的内容无非是将region在run内部的bitmap上标记为可用。bitmap unset的过程此处省略，请参考3.3.1小节中分配算法的解释。与tcache dalloc类似，通常情况下region并不会真正释放。但如果run内部全部为空闲region，则会进一步触发run的释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_dalloc_bin_locked</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">void</span> *ptr,</span></span><br><span class="line"><span class="params">    <span class="type">arena_chunk_map_t</span> *mapelm)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">// xf: 通过run回收region，在bitmap上重新标记region可用。</span></span><br><span class="line">    arena_run_reg_dalloc(run, ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 如果其所在run完全free，则尝试释放该run.</span></span><br><span class="line">    <span class="comment">// 如果所在run处在将满状态(因为刚刚的释放腾出一个region的空间),</span></span><br><span class="line">    <span class="comment">// 则根据地址高低优先将其交换到current run的位置(MRU).</span></span><br><span class="line">    <span class="keyword">if</span> (run-&gt;nfree == bin_info-&gt;nregs) &#123;</span><br><span class="line">        arena_dissociate_bin_run(chunk, run, bin);</span><br><span class="line">        arena_dalloc_bin_run(arena, chunk, run, bin);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (run-&gt;nfree == <span class="number">1</span> &amp;&amp; run != bin-&gt;runcur)</span><br><span class="line">        arena_bin_lower_run(arena, chunk, run, bin);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外还有一种情况是，如果原先run本来是满的，因为前面的释放多出一个空闲位置，就会尝试与current run交换位置。若当前run比current run地址更低，会替代后者并成为新的current run，这样的好处显然可以保证低地址的内存更紧实。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_bin_lower_run</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">arena_run_t</span> *run,</span></span><br><span class="line"><span class="params">    <span class="type">arena_bin_t</span> *bin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uintptr_t</span>)run &lt; (<span class="type">uintptr_t</span>)bin-&gt;runcur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bin-&gt;runcur-&gt;nfree &gt; <span class="number">0</span>)</span><br><span class="line">            arena_bin_runs_insert(bin, bin-&gt;runcur);</span><br><span class="line">        bin-&gt;runcur = run;</span><br><span class="line">        <span class="keyword">if</span> (config_stats)</span><br><span class="line">            bin-&gt;stats.reruns++;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        arena_bin_runs_insert(bin, run);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下，至此一个small region就释放完毕了，准确的说是回收了。但如前面所说，若整个run都为空闲region，则进入run dalloc。这是一个比较复杂的过程。</p>
<h3 id="4-3-small-run-dalloc"><a href="#4-3-small-run-dalloc" class="headerlink" title="4.3 - small run dalloc"></a>4.3 - small run dalloc</h3><p>一个non-full的small run被记录在bin内的run tree上，因此要移除它，首先要移除其在run tree中的信息，即arena_dissociate_bin_run.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_dissociate_bin_run</span><span class="params">(<span class="type">arena_chunk_t</span> *chunk, <span class="type">arena_run_t</span> *run,</span></span><br><span class="line"><span class="params">    <span class="type">arena_bin_t</span> *bin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// xf: 如果当前run为current run，清除runcur。否则，从run tree上remove.</span></span><br><span class="line">    <span class="keyword">if</span> (run == bin-&gt;runcur)</span><br><span class="line">        bin-&gt;runcur = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (bin_info-&gt;nregs != <span class="number">1</span>) &#123;</span><br><span class="line">            arena_bin_runs_remove(bin, run);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来要通过arena_dalloc_bin_run()正式释放run，由于过程稍复杂，这里先给出整个算法的梗概，</p>
<ol>
<li>计算nextind region所在page的index。所谓nextind是run内部clean-dirty region的边界。如果内部存在clean pages则执行下一步，否则执行3.</li>
<li>将原始的small run转化成large run，之后根据上一步得到的nextind将run切割成dirty和clean两部分，且单独释放掉clean部分。  </li>
<li>将待remove的run pages标记为unalloc。且根据传入的dirty和cleaned两个hint决定标记后的page mapbits的dirty flag.</li>
<li>检查unalloc后的run pages是否可以前后合并。合并的标准是，<ol>
<li>不超过chunk范围</li>
<li>前后毗邻的page同样为unalloc</li>
<li>前后毗邻page的dirty flag与run pages相同。</li>
</ol>
</li>
<li>将合并后(也可能没合并)的unalloc run插入avail-tree.</li>
<li>检查如果unalloc run的大小等于chunk size，则将chunk释放掉。</li>
<li>如果之前释放run pages为dirty，则检查当前arena内部的dirty-active pages比例。若dirty数量超过了active的1/8(Android这里的标准有所不同)，则启动arena purge.否则直接返回。</li>
<li>计算当前arena可以清理的dirty pages数量npurgatory.</li>
<li>从dirty tree上依次取出dirty chunk，并检查内部的unalloc dirty pages，将其重新分配为large pages，并插入到临时的queue中。</li>
<li>对临时队列中的dirty pages执行purge，返回值为unzeroed标记。再将purged pages的unzeroed标记设置一遍。</li>
<li>最后对所有purged pages重新执行一遍dalloc run操作，将其重新释放回avail-tree.</li>
</ol>
<p>可以看到，释放run本质上是将其回收至avail-tree。但额外的dirty page机制却增加了整个算法的复杂程度。原因就在于，Je使用了不同以往的内存释放方式。</p>
<p>在Dl这样的经典分配器中，系统内存回收方式更加”古板”。比如在heap区需要top-most space存在大于某个threshold的连续free空间时才能进行auto-trimming。而mmap区则更要等到某个segment全部空闲才能执行munmap。这对于回收系统内存是极为不利的，因为条件过于严格。</p>
<p>而Je使用了更为聪明的方式，并不会直接交还系统内存，而是通过madvise暂时释放掉页面与物理页面之间的映射。本质上这同sbrk/munmap之类的调用要达到的目的是类似的，只不过从进程内部的角度看，该地址仍然被占用。但Je对这些使用过的地址都详细做了记录，因此再分配时可以recycle，并不会导致对线性地址无休止的开采。</p>
<p>另外，为了提高对已释放page的利用率，Je将unalloc pages用dirty flag(注意，这里同page replacement中的含义不同)做了标记。所有pages被分成active, dirty和clean三种。dirty pages表示曾经使用过，且仍可能关联着物理页面，recycle速度较快。而clean则代表尚未使用，或已经通过purge释放了物理页面，较前者速度慢。显然，需要一种内置算法来保持三种page的动态平衡，以兼顾分配速度和内存占用量。如果当前dirty pages数量超过了active pages数量的1/2^opt_lg_dirty_mult，就会启动arena_purge()。这个值默认是1/8，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_maybe_purge</span><span class="params">(<span class="type">arena_t</span> *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 如果当前dirty pages全部在执行purging，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (arena-&gt;ndirty &lt;= arena-&gt;npurgatory)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// xf: 检查purageable pages是否超出active-dirty比率，超出则</span></span><br><span class="line">    <span class="comment">// 执行purge。google在这里增加了ANDROID_ALWAYS_PURGE开关，</span></span><br><span class="line">    <span class="comment">// 打开则总会执行arena_purge(默认是打开的).</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(ANDROID_ALWAYS_PURGE)</span></span><br><span class="line">    npurgeable = arena-&gt;ndirty - arena-&gt;npurgatory;</span><br><span class="line">    threshold = (arena-&gt;nactive &gt;&gt; opt_lg_dirty_mult);</span><br><span class="line">    <span class="keyword">if</span> (npurgeable &lt;= threshold)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 执行purge</span></span><br><span class="line">    arena_purge(arena, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但google显然希望对dirty pages管理更严格一些，以适应移动设备上内存偏小的问题。这里增加了一个ALWAYS_PURGE的开关，打开后会强制每次释放时都执行arena_purge.</p>
<p>arena_run_dalloc代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_run_dalloc</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_run_t</span> *run, <span class="type">bool</span> dirty, <span class="type">bool</span> cleaned)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 如果run pages的dirty flag实际读取为true，且cleaned不为true,</span></span><br><span class="line">    <span class="comment">// 则同样认为该pages在dalloc后是dirty的，否则被视为clean(该情况适用于</span></span><br><span class="line">    <span class="comment">// chunk purge后，重新dalloc时，此时的run pages虽然dirty flag可能为ture,</span></span><br><span class="line">    <span class="comment">// 但经过purge后应该修改为clean).</span></span><br><span class="line">    <span class="keyword">if</span> (cleaned == <span class="literal">false</span> &amp;&amp; arena_mapbits_dirty_get(chunk, run_ind) != <span class="number">0</span>)</span><br><span class="line">        dirty = <span class="literal">true</span>;</span><br><span class="line">    flag_dirty = dirty ? CHUNK_MAP_DIRTY : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 将被remove的run标记为unalloc pages。前面的判断如果是dirty，则pages</span></span><br><span class="line">    <span class="comment">// mapbits将带有dirty flag，否则将不带有dirty flag.</span></span><br><span class="line">    <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        arena_mapbits_unallocated_set(chunk, run_ind, size,</span><br><span class="line">            CHUNK_MAP_DIRTY);</span><br><span class="line">        arena_mapbits_unallocated_set(chunk, run_ind+run_pages<span class="number">-1</span>, size,</span><br><span class="line">            CHUNK_MAP_DIRTY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arena_mapbits_unallocated_set(chunk, run_ind, size,</span><br><span class="line">            arena_mapbits_unzeroed_get(chunk, run_ind));</span><br><span class="line">        arena_mapbits_unallocated_set(chunk, run_ind+run_pages<span class="number">-1</span>, size,</span><br><span class="line">            arena_mapbits_unzeroed_get(chunk, run_ind+run_pages<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 尝试将被remove run与前后unalloc pages 合并。</span></span><br><span class="line">    arena_run_coalesce(arena, chunk, &amp;size, &amp;run_ind, &amp;run_pages,</span><br><span class="line">        flag_dirty);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 将执行过合并后的run重新insert到avail-tree</span></span><br><span class="line">    arena_avail_insert(arena, chunk, run_ind, run_pages, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 检查如果合并后的size已经完全unallocated，则dalloc整个chunk</span></span><br><span class="line">    <span class="keyword">if</span> (size == arena_maxclass) &#123;</span><br><span class="line">        ......</span><br><span class="line">        arena_chunk_dalloc(arena, chunk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dirty)</span><br><span class="line">        arena_maybe_purge(arena);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>coalesce代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_run_coalesce</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">size_t</span> *p_size,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> *p_run_ind, <span class="type">size_t</span> *p_run_pages, <span class="type">size_t</span> flag_dirty)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 尝试与后面的pages合并</span></span><br><span class="line">    <span class="keyword">if</span> (run_ind + run_pages &lt; chunk_npages &amp;&amp;</span><br><span class="line">        arena_mapbits_allocated_get(chunk, run_ind+run_pages) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        arena_mapbits_dirty_get(chunk, run_ind+run_pages) == flag_dirty) &#123;</span><br><span class="line">        <span class="type">size_t</span> nrun_size = arena_mapbits_unallocated_size_get(chunk,</span><br><span class="line">            run_ind+run_pages);</span><br><span class="line">        <span class="type">size_t</span> nrun_pages = nrun_size &gt;&gt; LG_PAGE;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: 如果与后面的unalloc pages合并，remove page时后方的adjacent</span></span><br><span class="line">        <span class="comment">// hint应为true</span></span><br><span class="line">        arena_avail_remove(arena, chunk, run_ind+run_pages, nrun_pages,</span><br><span class="line">            <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        size += nrun_size;</span><br><span class="line">        run_pages += nrun_pages;</span><br><span class="line"></span><br><span class="line">        arena_mapbits_unallocated_size_set(chunk, run_ind, size);</span><br><span class="line">        arena_mapbits_unallocated_size_set(chunk, run_ind+run_pages<span class="number">-1</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 尝试与前面的pages合并</span></span><br><span class="line">    <span class="keyword">if</span> (run_ind &gt; map_bias &amp;&amp; arena_mapbits_allocated_get(chunk,</span><br><span class="line">        run_ind<span class="number">-1</span>) == <span class="number">0</span> &amp;&amp; arena_mapbits_dirty_get(chunk, run_ind<span class="number">-1</span>) ==</span><br><span class="line">        flag_dirty) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p_size = size;</span><br><span class="line">    *p_run_ind = run_ind;</span><br><span class="line">    *p_run_pages = run_pages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>avail-tree remove代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_avail_remove</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">size_t</span> pageind,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> npages, <span class="type">bool</span> maybe_adjac_pred, <span class="type">bool</span> maybe_adjac_succ)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 该调用可能将导致chunk内部的碎片化率改变，从而影响其在dirty tree</span></span><br><span class="line">    <span class="comment">// 中的排序。因此，在正式remove之前需要将chunk首先从dirty tree中remove,</span></span><br><span class="line">    <span class="comment">// 待更新内部ndirty后，再将其重新insert回dirty tree.</span></span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;ndirty != <span class="number">0</span>)</span><br><span class="line">        arena_chunk_dirty_remove(&amp;arena-&gt;chunks_dirty, chunk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: maybe_adjac_pred/succ是外界传入的hint，根据该值检查前后是否存在</span></span><br><span class="line">    <span class="comment">// clean-dirty边界。若存在边界，则remove avail pages后边界将减1.</span></span><br><span class="line">    <span class="keyword">if</span> (maybe_adjac_pred &amp;&amp; arena_avail_adjac_pred(chunk, pageind))</span><br><span class="line">        chunk-&gt;nruns_adjac--;</span><br><span class="line">    <span class="keyword">if</span> (maybe_adjac_succ &amp;&amp; arena_avail_adjac_succ(chunk, pageind, npages))</span><br><span class="line">        chunk-&gt;nruns_adjac--;</span><br><span class="line">    chunk-&gt;nruns_avail--;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 更新arena及chunk中dirty pages统计。</span></span><br><span class="line">    <span class="keyword">if</span> (arena_mapbits_dirty_get(chunk, pageind) != <span class="number">0</span>) &#123;</span><br><span class="line">        arena-&gt;ndirty -= npages;</span><br><span class="line">        chunk-&gt;ndirty -= npages;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: 如果chunk内部dirty不为0，将其重新insert到arena dirty tree.</span></span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;ndirty != <span class="number">0</span>)</span><br><span class="line">        arena_chunk_dirty_insert(&amp;arena-&gt;chunks_dirty, chunk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 从chunk avail-tree中remove掉unalloc pages.</span></span><br><span class="line">    arena_avail_tree_remove(&amp;arena-&gt;runs_avail, arena_mapp_get(chunk,</span><br><span class="line">        pageind));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从avail-tree上remove pages可能会改变当前chunk内部clean-dirty碎片率，因此一开始要将其所在chunk从dirty tree上remove，再从avail-tree上remove pages。另外，arena_avail_insert()的算法同remove是一样的，只是方向相反，不再赘述。</p>
<h3 id="4-4-arena-purge"><a href="#4-4-arena-purge" class="headerlink" title="4.4 - arena purge"></a>4.4 - arena purge</h3><p>清理arena的方式是按照从小到大的顺序遍历一棵dirty tree，直到将dirty pages降低到threshold以下。dirty tree挂载所有dirty chunks，同其他tree的区别在于它的cmp函数较特殊，决定了最终的purging order，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">arena_chunk_dirty_comp</span><span class="params">(<span class="type">arena_chunk_t</span> *a, <span class="type">arena_chunk_t</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> a_val = (a-&gt;nruns_avail - a-&gt;nruns_adjac) *</span><br><span class="line">            b-&gt;nruns_avail;</span><br><span class="line">        <span class="type">size_t</span> b_val = (b-&gt;nruns_avail - b-&gt;nruns_adjac) *</span><br><span class="line">            a-&gt;nruns_avail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_val &lt; b_val)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a_val &gt; b_val)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> a_chunk = (<span class="type">uintptr_t</span>)a;</span><br><span class="line">        <span class="type">uintptr_t</span> b_chunk = (<span class="type">uintptr_t</span>)b;</span><br><span class="line">        <span class="type">int</span> ret = ((a_chunk &gt; b_chunk) - (a_chunk &lt; b_chunk));</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;nruns_adjac == <span class="number">0</span>) &#123;</span><br><span class="line">            assert(b-&gt;nruns_adjac == <span class="number">0</span>);</span><br><span class="line">            ret = -ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Je在这里给出的算法是这样的，</p>
<ol>
<li>首先排除short cut，即a和b相同的特例。</li>
<li>计算a, b的fragmentation，该数值越高，相应的在dirty tree上就越靠前。<br> 其计算方法为，</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前平均avail run大小    所有avail run数量 - 边界数量</span><br><span class="line">--------------------- =  -----------------------------</span><br><span class="line"> 去碎片后的平均大小           所有avail run数量</span><br></pre></td></tr></table></figure>
<p>注意，这个fragment不是通常意义理解的碎片。这里指由于clean-dirty边界形成的所谓碎片，并且是可以通过purge清除掉的，如图，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nruns_adjac = <span class="number">2</span>    </span><br><span class="line">+--------+----------+--------+-------+---------+----------+--------+-----</span><br><span class="line">| dirty  |  clean   |        | clean |  dirty  |          | dirty  | ...</span><br><span class="line">+--------+----------+--------+-------+---------+----------+--------+-----</span><br><span class="line">         ^                           ^</span><br><span class="line">         |                           |</span><br><span class="line">         +--adjac #<span class="number">0</span>                 +--adjac #<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ol>
<li>当a, b的fragmentation相同时，同通常的方法类似，按地址大小排序。但若nruns_adjac为0，即不存在clean-dirty边界时，反而会将低地址chunk排到后面。因为adjac为0的chunk再利用价值是比较高的，所以放到后面可以增加其在purge中的幸存几率，从而提升recycle效率。</li>
</ol>
<p>purge代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_purge</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">bool</span> all)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 计算purgeable pages，结果加入到npurgatory信息中。</span></span><br><span class="line">    npurgatory = arena_compute_npurgatory(arena, all);</span><br><span class="line">    arena-&gt;npurgatory += npurgatory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 从dirty chunk tree上逐chunk执行purge，直到期望值npurgatory为0</span></span><br><span class="line">    <span class="keyword">while</span> (npurgatory &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        chunk = arena_chunk_dirty_first(&amp;arena-&gt;chunks_dirty);</span><br><span class="line">        <span class="comment">// xf: traversal结束，当前线程无法完成purge任务，返回。</span></span><br><span class="line">        <span class="keyword">if</span> (chunk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            arena-&gt;npurgatory -= npurgatory;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        npurgeable = chunk-&gt;ndirty;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf:  如果当前chunk中purgeable大于前期计算的purgatory,</span></span><br><span class="line">        <span class="comment">// 且其clean-dirty碎片为0，则让当前线程负责purge所有prgeable pages.</span></span><br><span class="line">        <span class="comment">// 原因是为了尽可能避免避免多个线程对该chunk的purge竞争。</span></span><br><span class="line">        <span class="keyword">if</span> (npurgeable &gt; npurgatory &amp;&amp; chunk-&gt;nruns_adjac == <span class="number">0</span>) &#123;</span><br><span class="line">            arena-&gt;npurgatory += npurgeable - npurgatory;</span><br><span class="line">            npurgatory = npurgeable;</span><br><span class="line">        &#125;</span><br><span class="line">        arena-&gt;npurgatory -= npurgeable;</span><br><span class="line">        npurgatory -= npurgeable;</span><br><span class="line">        npurged = arena_chunk_purge(arena, chunk, all);</span><br><span class="line">        <span class="comment">// xf: 计算purge期望值npurgatory和实际purge值npurged差值</span></span><br><span class="line">        nunpurged = npurgeable - npurged;</span><br><span class="line">        arena-&gt;npurgatory += nunpurged;</span><br><span class="line">        npurgatory += nunpurged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chunk purge如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">arena_chunk_purge</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">bool</span> all)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (chunk == arena-&gt;spare) &#123;</span><br><span class="line">        ......</span><br><span class="line">        arena_chunk_alloc(arena);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 为了减小arena purge时arena lock的暂停时间，先将所有满足</span></span><br><span class="line">    <span class="comment">// 需求的unalloc dirty pages重新&quot;alloc&quot;并保存，待purge结束再重新</span></span><br><span class="line">    <span class="comment">// 释放回avail-tree.</span></span><br><span class="line">    arena_chunk_stash_dirty(arena, chunk, all, &amp;mapelms);</span><br><span class="line">    npurged = arena_chunk_purge_stashed(arena, chunk, &amp;mapelms);</span><br><span class="line">    arena_chunk_unstash_purged(arena, chunk, &amp;mapelms);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (npurged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chunk purge重点在于这是一个线性查找dirty pages过程，Je在这里会导致性能下降。更糟糕的是，之前和之后都是在arena lock被锁定的条件下被执行，绑定同一arena的线程不得不停下工作。因此，在正式purge前需要先把unalloc dirtypages全部临时分配出来，当purging时解锁arena lock，而结束后再一次将它们全部释放。</p>
<p>stash dirty代码，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_chunk_stash_dirty</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">bool</span> all,</span></span><br><span class="line"><span class="params">    <span class="type">arena_chunk_mapelms_t</span> *mapelms)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (pageind = map_bias; pageind &lt; chunk_npages; pageind += npages) &#123;</span><br><span class="line">        <span class="type">arena_chunk_map_t</span> *mapelm = arena_mapp_get(chunk, pageind);</span><br><span class="line">        <span class="keyword">if</span> (arena_mapbits_allocated_get(chunk, pageind) == <span class="number">0</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (arena_mapbits_dirty_get(chunk, pageind) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (all || arena_avail_adjac(chunk, pageind,</span><br><span class="line">                npages))) &#123;</span><br><span class="line">                <span class="type">arena_run_t</span> *run = (<span class="type">arena_run_t</span> *)((<span class="type">uintptr_t</span>)</span><br><span class="line">                    chunk + (<span class="type">uintptr_t</span>)(pageind &lt;&lt; LG_PAGE));</span><br><span class="line">                <span class="comment">// xf: 暂时将这些unalloc dirty pages通过split large</span></span><br><span class="line">                <span class="comment">// 重新分配出来。                   </span></span><br><span class="line">                arena_run_split_large(arena, run, run_size,</span><br><span class="line">                    <span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 加入临时列表，留待后用。   </span></span><br><span class="line">                ql_elm_new(mapelm, u.ql_link);</span><br><span class="line">                ql_tail_insert(mapelms, mapelm, u.ql_link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">            <span class="comment">//xf: 跳过allocated pages</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stash时会根据传入的hint all判断，如果为false，只会stash存在clean-dirty adjac的pages，否则会全部加入列表。</p>
<p>purge stashed pages代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">arena_chunk_purge_stashed</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk,</span></span><br><span class="line"><span class="params">    <span class="type">arena_chunk_mapelms_t</span> *mapelms)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 暂时解锁arena lock，前面已经realloc过，这里不考虑contention问题。</span></span><br><span class="line">    malloc_mutex_unlock(&amp;arena-&gt;lock);</span><br><span class="line">    ......</span><br><span class="line">    ql_foreach(mapelm, mapelms, u.ql_link) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: 逐个purge dirty page，返回pages是否unzeroed.</span></span><br><span class="line">        unzeroed = pages_purge((<span class="type">void</span> *)((<span class="type">uintptr_t</span>)chunk + (pageind &lt;&lt;</span><br><span class="line">            LG_PAGE)), (npages &lt;&lt; LG_PAGE));</span><br><span class="line">        flag_unzeroed = unzeroed ? CHUNK_MAP_UNZEROED : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// xf: 逐pages设置unzeroed标志。</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;</span><br><span class="line">            arena_mapbits_unzeroed_set(chunk, pageind+i,</span><br><span class="line">                flag_unzeroed);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: purging结束重新lock arena</span></span><br><span class="line">    malloc_mutex_lock(&amp;arena-&gt;lock);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (npurged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，在page purge过后，会逐一设置unzero flag。这是因为有些操作系统在demand page后会有一步zero-fill-on-demand。因此，被purge过的clean page当再一次申请到物理页面时会全部填充为0.</p>
<p>unstash代码，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_chunk_unstash_purged</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk,</span></span><br><span class="line"><span class="params">    <span class="type">arena_chunk_mapelms_t</span> *mapelms)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (mapelm = ql_first(mapelms); mapelm != <span class="literal">NULL</span>;</span><br><span class="line">        mapelm = ql_first(mapelms)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        run = (<span class="type">arena_run_t</span> *)((<span class="type">uintptr_t</span>)chunk + (<span class="type">uintptr_t</span>)(pageind &lt;&lt;</span><br><span class="line">            LG_PAGE));</span><br><span class="line">        ql_remove(mapelms, mapelm, u.ql_link);</span><br><span class="line">        arena_run_dalloc(arena, run, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unstash需要再一次调用arena_run_dalloc()以释放临时分配的pages。要注意此时我们已经位于arena_run_dalloc调用栈中，而避免无限递归重入依靠参数cleaned flag.</p>
<h3 id="4-5-arena-chunk-dalloc"><a href="#4-5-arena-chunk-dalloc" class="headerlink" title="4.5 - arena chunk dalloc"></a>4.5 - arena chunk dalloc</h3><p>当free chunk被Je释放时，根据局部性原理，会成为下一个spare chunk而保存起来，其真身并未消散。而原先的spare则会根据内部dalloc方法被处理掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_chunk_dalloc</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 将chunk从avail-tree上remove</span></span><br><span class="line">    arena_avail_remove(arena, chunk, map_bias, chunk_npages-map_bias,</span><br><span class="line">        <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 如果spare不为空，则将被释放的chunk替换原spare chunk.</span></span><br><span class="line">    <span class="keyword">if</span> (arena-&gt;spare != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">arena_chunk_t</span> *spare = arena-&gt;spare;</span><br><span class="line"></span><br><span class="line">        arena-&gt;spare = chunk;</span><br><span class="line">        arena_chunk_dalloc_internal(arena, spare);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        arena-&gt;spare = chunk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同chunk alloc一样，chunk dalloc算法也是可定制的。Je提供的默认算法chunk_dalloc_default最终会调用chunk_unmap，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">chunk_unmap</span><span class="params">(<span class="type">void</span> *chunk, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 如果启用dss，且当前chunk在dss内，将其record在dss tree上。</span></span><br><span class="line">    <span class="comment">// 否则如果就记录在mmap tree上，或者直接munmap释放掉。</span></span><br><span class="line">    <span class="keyword">if</span> (have_dss &amp;&amp; chunk_in_dss(chunk))</span><br><span class="line">        chunk_record(&amp;chunks_szad_dss, &amp;chunks_ad_dss, chunk, size);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (chunk_dalloc_mmap(chunk, size))</span><br><span class="line">        chunk_record(&amp;chunks_szad_mmap, &amp;chunks_ad_mmap, chunk, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在3.3.5小节中alloc时会根据dss和mmap优先执行recycle。源自在dalloc时record在四棵chunk tree上的记录。但同spare记录的不同，这里的记录仅仅只剩下躯壳，record时会强行释放物理页面，因此recycle速度相比spare较慢。</p>
<p>chunk record算法如下，</p>
<ol>
<li>先purge chunk内部所有pages</li>
<li>预分配base node，以记录释放后的chunk。这里分配的node到后面可能没有用，提前分配是因为接下来要加锁chunks_mtx。而如果在临界段内再分配base node,则可能因为base pages不足而申请新的chunk，这样一来就会导致dead lock.</li>
<li>寻找与要插入chunk的毗邻地址。首先尝试与后面的地址合并，成功则用后者的base node记录，之后执行5.</li>
<li>合并失败，用预分配的base node记录chunk.</li>
<li>尝试与前面的地址合并。</li>
<li>如果预分配的base node没有使用，释放掉。</li>
</ol>
<p>代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">chunk_record</span><span class="params">(<span class="type">extent_tree_t</span> *chunks_szad, <span class="type">extent_tree_t</span> *chunks_ad, <span class="type">void</span> *chunk,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: purge all chunk pages</span></span><br><span class="line">    unzeroed = pages_purge(chunk, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 预先分配extent_node以记录chunk。如果该chunk可以进行合并，该node</span></span><br><span class="line">    <span class="comment">// 可能并不会使用。这里预先分配主要是避免dead lock。因为某些情况</span></span><br><span class="line">    <span class="comment">// base_node_alloc同样可能会alloc base chunk，由于后面chunk mutex被lock,</span></span><br><span class="line">    <span class="comment">// 那样将导致dead lock.</span></span><br><span class="line">    xnode = base_node_alloc();</span><br><span class="line">    xprev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;chunks_mtx);</span><br><span class="line">    <span class="comment">// xf: 首先尝试与后面的chunk合并。</span></span><br><span class="line">    key.addr = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)chunk + size);</span><br><span class="line">    node = extent_tree_ad_nsearch(chunks_ad, &amp;key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span> &amp;&amp; node-&gt;addr == key.addr) &#123;</span><br><span class="line">        extent_tree_szad_remove(chunks_szad, node);</span><br><span class="line">        node-&gt;addr = chunk;</span><br><span class="line">        node-&gt;size += size;</span><br><span class="line">        node-&gt;zeroed = (node-&gt;zeroed &amp;&amp; (unzeroed == <span class="literal">false</span>));</span><br><span class="line">        extent_tree_szad_insert(chunks_szad, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="comment">// xf: 合并失败，用提前分配好的xnode保存当前chunk信息。</span></span><br><span class="line">        <span class="keyword">if</span> (xnode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> label_return;</span><br><span class="line">        &#125;</span><br><span class="line">        node = xnode;</span><br><span class="line">        xnode = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;addr = chunk;</span><br><span class="line">        node-&gt;size = size;</span><br><span class="line">        node-&gt;zeroed = (unzeroed == <span class="literal">false</span>);</span><br><span class="line">        extent_tree_ad_insert(chunks_ad, node);</span><br><span class="line">        extent_tree_szad_insert(chunks_szad, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 再尝试与前面的chunk合并</span></span><br><span class="line">    prev = extent_tree_ad_prev(chunks_ad, node);</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span> &amp;&amp; (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)prev-&gt;addr + prev-&gt;size) ==</span><br><span class="line">        chunk) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">label_return:</span><br><span class="line">    malloc_mutex_unlock(&amp;chunks_mtx);</span><br><span class="line">    <span class="comment">// xf: 如果预先分配的node没有使用，则在此将之销毁</span></span><br><span class="line">    <span class="keyword">if</span> (xnode != <span class="literal">NULL</span>)</span><br><span class="line">        base_node_dalloc(xnode);</span><br><span class="line">    <span class="keyword">if</span> (xprev != <span class="literal">NULL</span>)</span><br><span class="line">        base_node_dalloc(xprev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后顺带一提，对于mmap区的pages, Je也可以直接munmap，前提是需要在jemalloc_internal_defs.h中开启JEMALLOC_MUNMAP，这样就不会执行pages purge.默认该选项是不开启的。但源自dss区中的分配则不存在反向释放一说，默认Je也不会优先选择dss就是了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">chunk_dalloc_mmap</span><span class="params">(<span class="type">void</span> *chunk, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config_munmap)</span><br><span class="line">        pages_unmap(chunk, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (config_munmap == <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-large-huge-dalloc"><a href="#4-6-large-huge-dalloc" class="headerlink" title="4.6 - large/huge dalloc"></a>4.6 - large/huge dalloc</h3><p>前面说过large/huge相当于以run和chunk为粒度的特例。因此对于arena dalloc large来说，最终就是arena_run_dalloc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_dalloc_large_locked</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config_fill || config_stats) &#123;</span><br><span class="line">        <span class="type">size_t</span> pageind = ((<span class="type">uintptr_t</span>)ptr - (<span class="type">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE;</span><br><span class="line">        <span class="type">size_t</span> usize = arena_mapbits_large_size_get(chunk, pageind);</span><br><span class="line"></span><br><span class="line">        arena_dalloc_junk_large(ptr, usize);</span><br><span class="line">        <span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">            arena-&gt;stats.ndalloc_large++;</span><br><span class="line">            arena-&gt;stats.allocated_large -= usize;</span><br><span class="line">            arena-&gt;stats.lstats[(usize &gt;&gt; LG_PAGE) - <span class="number">1</span>].ndalloc++;</span><br><span class="line">            arena-&gt;stats.lstats[(usize &gt;&gt; LG_PAGE) - <span class="number">1</span>].curruns--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arena_run_dalloc(arena, (<span class="type">arena_run_t</span> *)ptr, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而huge dalloc，则是在huge tree上搜寻，最终执行chunk_dalloc,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">huge_dalloc</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    malloc_mutex_lock(&amp;huge_mtx);</span><br><span class="line"></span><br><span class="line">    key.addr = ptr;</span><br><span class="line">    node = extent_tree_ad_search(&amp;huge, &amp;key);</span><br><span class="line">    assert(node != <span class="literal">NULL</span>);</span><br><span class="line">    assert(node-&gt;addr == ptr);</span><br><span class="line">    extent_tree_ad_remove(&amp;huge, node);</span><br><span class="line"></span><br><span class="line">    malloc_mutex_unlock(&amp;huge_mtx);</span><br><span class="line"></span><br><span class="line">    huge_dalloc_junk(node-&gt;addr, node-&gt;size);</span><br><span class="line">    arena_chunk_dalloc_huge(node-&gt;arena, node-&gt;addr, node-&gt;size);</span><br><span class="line">    base_node_dalloc(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_chunk_dalloc_huge</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">void</span> *chunk, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">chunk_dalloc_t</span> *chunk_dalloc;</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;arena-&gt;lock);</span><br><span class="line">    chunk_dalloc = arena-&gt;chunk_dalloc;</span><br><span class="line">    <span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">        arena-&gt;stats.mapped -= size;</span><br><span class="line">        arena-&gt;stats.allocated_huge -= size;</span><br><span class="line">        arena-&gt;stats.ndalloc_huge++;</span><br><span class="line">        stats_cactive_sub(size);</span><br><span class="line">    &#125;</span><br><span class="line">    arena-&gt;nactive -= (size &gt;&gt; LG_PAGE);</span><br><span class="line">    malloc_mutex_unlock(&amp;arena-&gt;lock);</span><br><span class="line">    chunk_dalloc(chunk, size, arena-&gt;ind);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-总结-与Dl的对比"><a href="#5-总结-与Dl的对比" class="headerlink" title="5 - 总结: 与Dl的对比"></a>5 - 总结: 与Dl的对比</h2><ol>
<li>单核单线程分配能力上两者不相上下，甚至小块内存分配速度理论上Dl还略占优势。原因是Dl利用双向链表组织free chunk可以做到O(1)，而尽管Je在bitmap上做了一定优化，但不能做到常数时间。</li>
<li>多核多线程下，Je可以秒杀Dl。arena的加入既可以避免false sharing，又可以减少线程间lock contention。另外，tcache也是可以大幅加快多线程分配速度的技术。这些Dl完全不具备竞争力。</li>
<li>系统内存交换效率上也是Je占明显优势。Je使用mmap/madvise的组合要比Dl使用sbrk/mmap/munmap灵活的多。实际对系统的压力也更小。另外，Dl使用dss-&gt;mmap,追求的是速度，而Je相反mmap-&gt;dss，为的是灵活性。</li>
<li>小块内存的碎片抑制上双方做的都不错，但总体上个人觉得Je更好一些。首先dalloc时，两者对空闲内存都可以实时coalesce。alloc时Dl依靠dv约束外部碎片，Je更简单暴力，直接在固定的small runs里分配。   <ol>
<li>两相比较，dv的候选者是随机的，大小不固定，如果选择比较小的chunk，效果其实有限。更甚者，当找不到dv时，Dl会随意切割top-most space，通常这不利于heap trim.</li>
<li>而small runs则是固定大小，同时是页面的整数倍，对外部碎片的约束力和规整度上都更好。</li>
<li>但Dl的优势在算法更简单，速度更快。无论是coalesce还是split代价都很低。在Je中有可能因为分配8byte的内存而实际去分配并初始化4k甚至4M的空间。</li>
</ol>
</li>
<li>大块内存分配能力上，Dl使用dst管理，而Je采用rb tree。原理上，据说rb tree的cache亲和力较差，不适合memory allocator。我没有仔细研究Je的rb tree实现有何过人之处，暂且认为各有千秋吧。可以肯定的是Je的large/huge region具有比Dl更高的内部碎片，皆因为其更规整的size class划分导致的。</li>
<li>说到size class，可以看到Je的划分明显比Dl更细致，tiny/small/large/huge四种分类能兼顾更多的内存使用模型。且根据不同架构和配置，可以灵活改变划分方式，具有更好的兼容性。Dl划分的相对粗糙很多且比较固定。一方面可能在当时256byte以上就可以算作大块的分配了吧。另一方面某种程度是碍于算法的限制。比如在boundary tag中为了容纳更多的信息，就不能小于8byte(实际有效的最小chunk是16byte), bin数量不得多余31个也是基于位运算的方式。</li>
<li>bookkeeping占用上Dl因为算法简单，本应该占用更少内存。但由于boundary tag本身导致的占用，chunk数量越多，bookkeeping就越大。再考虑到系统回收效率上的劣势，应该说，应用内存占用越大，尤其是小内存使用量越多，运行时间越长，Dl相对于Je内存使用量倾向越大。</li>
<li>安全健壮性。只说一点，boundary tag是原罪，其他的可以免谈了。</li>
</ol>
<h1 id="常量时间获取-metadata"><a href="#常量时间获取-metadata" class="headerlink" title="常量时间获取 metadata"></a>常量时间获取 metadata</h1><p>有了上面的铺垫，现在可以来看一下<code>jemalloc</code>中的地址运算操作及如何在常量时间获取<code>metadata</code>。</p>
<h2 id="从-run-到-region"><a href="#从-run-到-region" class="headerlink" title="从 run 到 region"></a>从 run 到 region</h2><p><code>arena_run_t</code>中只记录了<code>run</code>的分配情况，并没有地址，需要快速的获取到需要分配的<code>region</code>的地址:</p>
<p>先获取到<code>misc</code>的地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_chunk_map_misc_t</span> *miscelm = (<span class="type">arena_chunk_map_misc_t</span></span><br><span class="line"> *)((<span class="type">uintptr_t</span>)run - offsetof(<span class="type">arena_chunk_map_misc_t</span>, run));</span><br></pre></td></tr></table></figure></p>
<p>获取包含该<code>misc</code>的<code>chunk</code>起始地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 因为内存申请以chunk为单位，且按照chunk size对齐，所以只要将低位置零即可获取chunk起始地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	CHUNK_ADDR2BASE(a)						\</span></span><br><span class="line"><span class="meta"> ((void *)((uintptr_t)(a) &amp; ~chunksize_mask))</span></span><br><span class="line"><span class="type">arena_chunk_t</span> *chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(miscelm);</span><br></pre></td></tr></table></figure></p>
<p>获取该<code>misc</code>的<code>page id</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_chunk_t</span> *chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(miscelm);</span><br><span class="line"><span class="comment">/* (该 misc 在数组中的地址偏移 / misc 大小) 即可获取是数组中第几个元素 */</span></span><br><span class="line"><span class="type">size_t</span> pageind = ((<span class="type">uintptr_t</span>)miscelm - ((<span class="type">uintptr_t</span>)chunk +</span><br><span class="line"> map_misc_offset)) / <span class="keyword">sizeof</span>(<span class="type">arena_chunk_map_misc_t</span>) + map_bias;</span><br></pre></td></tr></table></figure></p>
<p>获取<code>misc</code>对应的<code>page</code>地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((<span class="type">void</span> *)((<span class="type">uintptr_t</span>)chunk + (pageind &lt;&lt; LG_PAGE)));</span><br></pre></td></tr></table></figure></p>
<p>获取对应的<code>region</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page 起始地址 + region0 的偏移 + (region id * region size) */</span></span><br><span class="line">ret = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)rpages + (<span class="type">uintptr_t</span>)bin_info-&gt;reg0_offset +</span><br><span class="line"> (<span class="type">uintptr_t</span>)(bin_info-&gt;reg_interval * regind));</span><br></pre></td></tr></table></figure></p>
<h2 id="从-region-到-run"><a href="#从-region-到-run" class="headerlink" title="从 region 到 run"></a>从 region 到 run</h2><p>当释放<code>region</code>时，需要快速查找<code>region</code>对应的<code>run</code>及<code>region id</code>:</p>
<p>先获取到<code>chunk</code>起始地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(ptr);</span><br></pre></td></tr></table></figure></p>
<p>获取<code>region</code>的<code>page id</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pageind = ((<span class="type">uintptr_t</span>)ptr - (<span class="type">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE;</span><br></pre></td></tr></table></figure></p>
<p>获取<code>page</code>对应的<code>map_bits</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (&amp;chunk-&gt;map_bits[pageind-map_bias]);</span><br></pre></td></tr></table></figure></p>
<p>根据<code>map_bits</code>中设置的<code>run page offset</code>获取<code>run</code>的起始<code>page id</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rpages_ind = pageind - arena_mapbits_small_runind_get(chunk, pageind);</span><br><span class="line"></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">size_t</span></span><br><span class="line"><span class="title function_">arena_mapbits_small_runind_get</span><span class="params">(<span class="type">arena_chunk_t</span> *chunk, <span class="type">size_t</span> pageind)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> mapbits;</span><br><span class="line">    mapbits = arena_mapbits_get(chunk, pageind);</span><br><span class="line">    assert((mapbits &amp; (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) ==</span><br><span class="line">        CHUNK_MAP_ALLOCATED);</span><br><span class="line">    <span class="keyword">return</span> (mapbits &gt;&gt; CHUNK_MAP_RUNIND_SHIFT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取管理该<code>region</code>的<code>run</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run = &amp;arena_miscelm_get(chunk, rpages_ind)-&gt;run;</span><br></pre></td></tr></table></figure></p>
<p>从<code>run</code>中得到<code>bin_info</code>，再根据<code>bin_info</code>获取<code>region id</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* diff 为 region 在 run 中的偏移 */</span></span><br><span class="line">diff = (<span class="type">unsigned</span>)((<span class="type">uintptr_t</span>)ptr - (<span class="type">uintptr_t</span>)rpages -</span><br><span class="line">    bin_info-&gt;reg0_offset);</span><br><span class="line"><span class="comment">/* region id 可以通过 diff / bin_info-&gt;reg_interval 得到，但是 jemalloc 使用了复杂的运算为了提高性能，下面是它的注释 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Avoid doing division with a variable divisor if possible.  Using</span></span><br><span class="line"><span class="comment"> * actual division here can reduce allocator throughput by over 20%!</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>之后就可以设置<code>region</code>对应的<code>bitmap</code>进行释放了</p>
<h2 id="run-的合并"><a href="#run-的合并" class="headerlink" title="run 的合并"></a>run 的合并</h2><p>前面看到<code>run</code>释放时会前后进行合并:</p>
<ol>
<li>查看<code>run</code>相邻的后面的<code>page</code>是不是空闲的:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 根据后面 page 的 map_bits 获取分配状态</span></span><br><span class="line"><span class="comment">arena_mapbits_allocated_get(chunk, run_ind+run_pages) == 0</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>根据<code>map_bits</code>获取空闲<code>page</code>的大小:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> nrun_size = arena_mapbits_unallocated_size_get(chunk, run_ind+run_pages);</span><br><span class="line"><span class="type">size_t</span> nrun_pages = nrun_size &gt;&gt; LG_PAGE;</span><br></pre></td></tr></table></figure></p>
<p>然后将大小合并，在设置首尾<code>page</code>的<code>map_bits</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size += nrun_size;</span><br><span class="line">run_pages += nrun_pages;</span><br><span class="line"></span><br><span class="line">arena_mapbits_unallocated_size_set(chunk, run_ind, size);</span><br><span class="line">arena_mapbits_unallocated_size_set(chunk, run_ind+run_pages<span class="number">-1</span>, size);</span><br></pre></td></tr></table></figure></p>
<p>查看<code>run</code>相邻的前面的<code>page</code>是不是空闲的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arena_mapbits_allocated_get(chunk, run_ind<span class="number">-1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>根据<code>map_bits</code>获取空闲<code>page</code>的大小:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> prun_size = arena_mapbits_unallocated_size_get(chunk, run_ind<span class="number">-1</span>);</span><br><span class="line"><span class="type">size_t</span> prun_pages = prun_size &gt;&gt; LG_PAGE;</span><br></pre></td></tr></table></figure></p>
<p>然后将大小合并，再设置首尾<code>page</code>的<code>map_bits</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size += prun_size;</span><br><span class="line">run_pages += prun_pages;</span><br><span class="line"></span><br><span class="line">arena_mapbits_unallocated_size_set(chunk, run_ind, size);</span><br><span class="line">arena_mapbits_unallocated_size_set(chunk, run_ind+run_pages<span class="number">-1</span>, size);</span><br></pre></td></tr></table></figure></p>
<p>由此得知，因为前后都需要进行合并，所以首尾<code>page</code>对应的<code>map_bits</code>都会设置大小。</p>
<h1 id="size-classes"><a href="#size-classes" class="headerlink" title="size classes"></a>size classes</h1><p><code>jemalloc</code>将对象按大小分为3类，不同大小类别的分配算法不同:</p>
<ul>
<li><code>small</code>:从对应<code>bin</code>管理的<code>run</code>中返回一个<code>region</code></li>
<li><code>large</code>:大小比<code>chunk</code>小，比<code>page</code>大，会单独返回一个<code>run</code></li>
<li><code>huge</code>:大小为<code>chunk</code>倍数，会分配<code>chunk</code></li>
</ul>
<p>在 2MiB chunk，4KiB page 的64位系统上，<code>size classes</code>如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+---------+---------+--------------------------------------+</span><br><span class="line">|Category | Spacing | Size                                 |</span><br><span class="line">+---------+---------+--------------------------------------+</span><br><span class="line">|         |      lg | [<span class="number">8</span>]                                  |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |      <span class="number">16</span> | [<span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>]   |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |      <span class="number">32</span> | [<span class="number">160</span>, <span class="number">192</span>, <span class="number">224</span>, <span class="number">256</span>]                 |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |      <span class="number">64</span> | [<span class="number">320</span>, <span class="number">384</span>, <span class="number">448</span>, <span class="number">512</span>]                 |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|Small    |     <span class="number">128</span> | [<span class="number">640</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>]                |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |     <span class="number">256</span> | [<span class="number">1280</span>, <span class="number">1536</span>, <span class="number">1792</span>, <span class="number">2048</span>]             |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |     <span class="number">512</span> | [<span class="number">2560</span>, <span class="number">3072</span>, <span class="number">3584</span>, <span class="number">4096</span>]             |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">1</span> KiB | [<span class="number">5</span> KiB, <span class="number">6</span> KiB, <span class="number">7</span> KiB, <span class="number">8</span> KiB]         |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">2</span> KiB | [<span class="number">10</span> KiB, <span class="number">12</span> KiB, <span class="number">14</span> KiB]             |</span><br><span class="line">+---------+---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">2</span> KiB | [<span class="number">16</span> KiB]                             |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">4</span> KiB | [<span class="number">20</span> KiB, <span class="number">24</span> KiB, <span class="number">28</span> KiB, <span class="number">32</span> KiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">8</span> KiB | [<span class="number">40</span> KiB, <span class="number">48</span> KiB, <span class="number">54</span> KiB, <span class="number">64</span> KiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |  <span class="number">16</span> KiB | [<span class="number">80</span> KiB, <span class="number">96</span> KiB, <span class="number">112</span> KiB, <span class="number">128</span> KiB]   |</span><br><span class="line">|Large    +---------+--------------------------------------+</span><br><span class="line">|         |  <span class="number">32</span> KiB | [<span class="number">160</span> KiB, <span class="number">192</span> KiB, <span class="number">224</span> KiB, <span class="number">256</span> KiB] |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |  <span class="number">64</span> KiB | [<span class="number">320</span> KiB, <span class="number">384</span> KiB, <span class="number">448</span> KiB, <span class="number">512</span> KiB] |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         | <span class="number">128</span> KiB | [<span class="number">640</span> KiB, <span class="number">768</span> KiB, <span class="number">896</span> KiB, <span class="number">1</span> MiB]   |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         | <span class="number">256</span> KiB | [<span class="number">1280</span> KiB, <span class="number">1536</span> KiB, <span class="number">1792</span> KiB]       |</span><br><span class="line">+---------+---------+--------------------------------------+</span><br><span class="line">|         | <span class="number">256</span> KiB | [<span class="number">2</span> MiB]                              |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         | <span class="number">512</span> KiB | [<span class="number">2560</span> KiB, <span class="number">3</span> MiB, <span class="number">3584</span> KiB, <span class="number">4</span> MiB]   |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">1</span> MiB | [<span class="number">5</span> MiB, <span class="number">6</span> MiB, <span class="number">7</span> MiB, <span class="number">8</span> MiB]         |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|Huge     |   <span class="number">2</span> MiB | [<span class="number">10</span> MiB, <span class="number">12</span> MiB, <span class="number">14</span> MiB, <span class="number">16</span> MiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">4</span> MiB | [<span class="number">20</span> MiB, <span class="number">24</span> MiB, <span class="number">28</span> MiB, <span class="number">32</span> MiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">8</span> MiB | [<span class="number">40</span> MiB, <span class="number">48</span> MiB, <span class="number">56</span> MiB, <span class="number">64</span> MiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |     ... | ...                                  |</span><br><span class="line">+---------+---------+--------------------------------------+</span><br></pre></td></tr></table></figure></p>
<h2 id="small"><a href="#small" class="headerlink" title="small"></a>small</h2><p><code>small</code>的分配流程如下：</p>
<ul>
<li>查找对应<code>size classes</code>的<code>bin</code></li>
<li>从<code>bin</code>中获取<code>run</code>:<ul>
<li><code>bin-&gt;runcur</code></li>
<li>从<code>bin-&gt;runs</code>查找未满的<code>run</code></li>
</ul>
</li>
<li>从<code>arena</code>中获取<code>run</code>:<ul>
<li>从<code>arena-&gt;avail_runs</code>中查找空闲<code>run</code></li>
<li>当没有合适<code>run</code>时，从<code>chunk</code>中分配<code>run</code>:<ul>
<li><code>arena-&gt;spare</code></li>
<li><code>arena-&gt;cached_tree</code></li>
<li><code>arena-&gt;retained_tree</code></li>
<li>调用<code>mmap()</code>新分配一块<code>chunk</code></li>
</ul>
</li>
</ul>
</li>
<li>从<code>run</code>中返回一个空闲<code>region</code></li>
</ul>
<p><code>small</code>的释放流程如下：</p>
<ul>
<li>将该<code>region</code>返回给对应的<code>run</code>，即设置<code>bitmap</code>为空闲，增加<code>nfree</code></li>
<li>将<code>run</code>还给<code>bin</code>:<ul>
<li>如果<code>run-&gt;nfree == 1</code>，则设置为<code>bin-&gt;runcur</code>或者插入到<code>bin-&gt;runs</code>中</li>
</ul>
</li>
<li>如果<code>run-&gt;nfree == bin_info-&gt;nregs</code>，则将该<code>run</code>与<code>bin</code>分离，再将<code>run</code>还给<code>arena</code>:<ul>
<li>尝试与相同<code>chunk</code>中前后相邻的空闲<code>run</code>进行合并，然后插入到<code>arena-&gt;avail_runs</code>中</li>
<li>若合并完后，整个<code>chunk</code>为空，则尝试与连续地址空间的空闲<code>chunk</code>进行合并，然后插入到<code>arena-&gt;cached_tree</code>中</li>
</ul>
</li>
</ul>
<h2 id="large"><a href="#large" class="headerlink" title="large"></a>large</h2><p>分配<code>large</code>和分配<code>small</code>类似:</p>
<ul>
<li>先从<code>arena-&gt;avail_runs</code>中查找，因为<code>large object</code>不由<code>bin</code>管理，所以与<code>small object</code>相比，少了从<code>bin-&gt;runs</code>中查找的一步</li>
<li>分配<code>chunk</code>，步骤和<code>small</code>一样，然后从<code>chunk</code>中分配需要的<code>run</code>大小，此时<code>run</code>的大小为单个<code>object</code>的大小，而<code>small run</code>的大小会从<code>bin_info[]</code>中获取</li>
</ul>
<p>因为<code>large</code>大小是<code>page</code>的倍数，且会按照<code>page size</code>地址对齐，有可能造成<code>cache line</code>颠簸， 所以会根据配置多分配一个<code>page</code>，用于内存着色，防止<code>cache line</code>的颠簸<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config_cache_oblivious) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Compute a uniformly distributed offset within the first page</span></span><br><span class="line"><span class="comment">     * that is a multiple of the cacheline size, e.g. [0 .. 63) * 64</span></span><br><span class="line"><span class="comment">     * for 4 KiB pages and 64-byte cachelines.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    prng64(r, LG_PAGE - LG_CACHELINE, arena-&gt;offset_state,</span><br><span class="line">        UINT64_C(<span class="number">6364136223846793009</span>),</span><br><span class="line">        UINT64_C(<span class="number">1442695040888963409</span>));</span><br><span class="line">    random_offset = ((<span class="type">uintptr_t</span>)r) &lt;&lt; LG_CACHELINE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>large</code>和<code>small</code>的<code>arena_chunk_map_misc_t</code>格式也不同，<code>large</code>只在首个<code>page</code>设置<code>run</code>的大小。释放流程和<code>small</code>一样，只是缺少了<code>run</code>在<code>bin</code>中的处理，直接将<code>run</code>还给<code>arena</code>。</p>
<h2 id="huge"><a href="#huge" class="headerlink" title="huge"></a>huge</h2><p><code>huge object</code>大小比<code>chunk</code>大。分配策略和上面分配<code>chunk</code>一样:</p>
<ul>
<li>从<code>arena</code>中分配<code>extent_node_t</code></li>
<li>从<code>arena</code>中分配<code>chunk</code>:<ul>
<li>从<code>arena-&gt;cached_tree</code>中分配<code>chunk</code></li>
<li>从<code>arena-&gt;retained_tree</code>中分配</li>
<li>调用<code>mmap()</code>新分配一块<code>chunk</code></li>
</ul>
</li>
<li>将<code>chunk</code>和<code>node</code>插入到<code>chunks_rtree</code>中</li>
<li>插入到<code>arena-&gt;huge</code>链表中</li>
</ul>
<p>释放和分配过程相反:</p>
<ul>
<li>从<code>chunks_rtree</code>中获取<code>chunk</code>对应的<code>node</code>，从而获取对应的<code>arena</code></li>
<li>移出<code>arena-&gt;huge</code></li>
<li>释放<code>chunk</code>，插入到<code>arena-&gt;cached_tree</code>中</li>
<li>释放<code>node</code></li>
</ul>
<p><code>huge</code>使用了线程间共享的<code>chunks_rtree</code>来保存信息，这会导致锁的竞争，但是应用程序很少会分配如此大的内存，所以带来的影响很小。</p>
<h2 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h2><p>前面的释放只是将之前分配的缓存起来，备用，现在来看一下真正的释放操作。</p>
<p><code>arena</code>中会统计<code>dirty</code>和<code>active</code>的数目：</p>
<ul>
<li><code>nactive</code>：已经分配出去的<code>page</code>数目</li>
<li><code>ndirty</code>：分配出去又被释放的<code>page</code>数目</li>
<li><code>arena</code>中会保存最多<code>nactive &gt;&gt; lg_dirty_mult</code>的<code>dirty pages</code>暂存使用，当超出时，就会释放掉多余的部分。</li>
</ul>
<p><code>purge</code>按照<code>page</code>维度进行回收。<code>arena</code>中<code>runs_dirty</code>和<code>chunks_cache</code>存放着<code>dirty pages</code>，当<code>run</code>和<code>chunk</code>被释放时，会插入到这里(<code>chunk</code>也会插入到<code>runs_dirty</code>中，同时也插入到<code>chunks_cache</code>)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">* Unused dirty memory this arena manages.  Dirty memory is conceptually</span><br><span class="line">* tracked as an arbitrarily interleaved LRU of dirty runs and cached</span><br><span class="line">* chunks, but the <span class="built_in">list</span> linkage is actually semi-duplicated in order to</span><br><span class="line">* avoid extra <span class="type">arena_chunk_map_misc_t</span> space overhead.</span><br><span class="line">*</span><br><span class="line">*   LRU-----------------------------------------------------------MRU</span><br><span class="line">*</span><br><span class="line">*        /-- arena ---\</span><br><span class="line">*        |            |</span><br><span class="line">*        |            |</span><br><span class="line">*        |------------|                             /- chunk -\</span><br><span class="line">*   ...-&gt;|chunks_cache|&lt;---------------------------&gt;|  /----\ |&lt;--...</span><br><span class="line">*        |------------|                             |  |node| |</span><br><span class="line">*        |            |                             |  |    | |</span><br><span class="line">*        |            |    /- run -\    /- run -\   |  |    | |</span><br><span class="line">*        |            |    |       |    |       |   |  |    | |</span><br><span class="line">*        |            |    |       |    |       |   |  |    | |</span><br><span class="line">*        |------------|    |-------|    |-------|   |  |----| |</span><br><span class="line">*   ...-&gt;|runs_dirty  |&lt;--&gt;|rd     |&lt;--&gt;|rd     |&lt;----&gt;|rd  |&lt;----...</span><br><span class="line">*        |------------|    |-------|    |-------|   |  |----| |</span><br><span class="line">*        |            |    |       |    |       |   |  |    | |</span><br><span class="line">*        |            |    |       |    |       |   |  \----/ |</span><br><span class="line">*        |            |    \-------/    \-------/   |         |</span><br><span class="line">*        |            |                             |         |</span><br><span class="line">*        |            |                             |         |</span><br><span class="line">*        \------------/                             \---------/</span><br><span class="line">*</span><br></pre></td></tr></table></figure></p>
<p>在每次<code>dalloc run/chunk</code>时都会调用<code>arena_maybe_purge()</code>尝试<code>purge</code>。<code>arena</code>根据<code>lg_dirty_mult</code>判断是否需要<code>purge</code>，当<code>(nactive &gt;&gt; lg_dirty_mult) &lt;= ndirty</code>时进行<code>purge</code>，默认配置为<code>8 ： 1</code>。</p>
<p><code>purge</code>分为4步：</p>
<ul>
<li><code>arena_compute_npurge()</code>：返回需要<code>purge</code>的<code>page</code>数目，为超出<code>nactive &gt;&gt; lg_dirty_mult</code>的<code>page</code>数。</li>
<li><code>arena_stash_dirty()</code>：将需要<code>purge</code>的部分从<code>arena-&gt;cached_tree</code>或<code>arena-&gt;avail_runs</code>中移除，防止<code>purge</code>过程中被其他线程分配出去，并插入到需要<code>purge</code>的循环链表中。</li>
<li><code>arena_purge_stashed()</code>：将循环链表中的<code>run</code>进行<code>purge</code></li>
<li><code>arena_unstash_purged()</code>：将<code>chunk</code>进行<code>purge</code>。将<code>purged</code>插入到<code>arena-&gt;cached_tree</code>或<code>arena-&gt;avail_runs</code>，留待后面分配。</li>
</ul>
<p>对<code>chunk</code>和<code>run</code>采取不同的<code>purge</code>：</p>
<ul>
<li>对于<code>run</code>而言，并不是真正的释放，根据操作系统的不同，会使用不同的方式，在<code>linux</code>中会调用<code>madvise(addr, size, MADV_DONTNEED)</code>。</li>
<li><code>jemalloc</code>以<code>chunk</code>为单位向操作系统申请内存，在释放<code>chunk</code>时，会尽量调用<code>munmap()</code>(因为根据操作系统和配置的不同，<code>chunk</code>的来源也不同)，否则会类似<code>run</code>，调用<code>madvise()</code>然后再插入到<code>chunk_retained_tree</code>中，留待后续分配。</li>
</ul>
<p><code>jemalloc</code>中单线程的部分就到此结束了，下面开始看<code>jemalloc</code>是如何提升多线程性能的。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><code>jemalloc</code>的一个目标就是提高多线程的性能，多线程的分配思路和单线程是一样的，每个线程还是从<code>arena</code>中分配内存，不过会多了线程间的同步和竞争。想要提高多线程性能，主要通过下面 2 个方式:</p>
<ul>
<li>减少锁的竞争：缩小临界区，更细粒度的锁</li>
<li>避免锁的竞争：线程间不共享数据，使用局部变量、线程特有数据(tsd)、线程局部存储(tls)等</li>
</ul>
<h2 id="arena-1"><a href="#arena-1" class="headerlink" title="arena"></a>arena</h2><p><code>jemalloc</code>会创建多个<code>arena</code>，每个线程由一个<code>arena</code>负责。在<code>malloc_init_hard_finish()</code>中会设置<code>arena</code>的相关配置，<code>narenas_auto</code>和<code>narenas_total</code>都设置为<code>cpu核数*4</code>，默认最多创建那么多<code>arena</code>。<code>arena-&gt;nthreads</code>记录负责的线程数量。</p>
<p>每个线程分配时会首先调用<code>arena_choose()</code>选择一个<code>arena</code>来负责该线程的分配。选择<code>arena</code>的逻辑如下:</p>
<ol>
<li>若有空闲的(<code>nthreads==0</code>)已创建的<code>arena</code>，则选择该<code>arena</code></li>
<li>若还有未创建的<code>arena</code>，则选择新创建一个<code>arena</code></li>
<li>选择负载最低的<code>arena</code>(<code>nthreads</code>最小)</li>
</ol>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><code>mutex</code>尽量使用<code>spinlock</code>，减少线程间的上下文切换:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_mutex_lock</span><span class="params">(<span class="type">malloc_mutex_t</span> *mutex)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isthreaded) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#  <span class="keyword">if</span> _WIN32_WINNT &gt;= 0x0600</span></span><br><span class="line">		AcquireSRWLockExclusive(&amp;mutex-&gt;lock);</span><br><span class="line"><span class="meta">#  <span class="keyword">else</span></span></span><br><span class="line">		EnterCriticalSection(&amp;mutex-&gt;lock);</span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (defined(JEMALLOC_OSSPIN))</span></span><br><span class="line">		OSSpinLockLock(&amp;mutex-&gt;lock);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		pthread_mutex_lock(&amp;mutex-&gt;lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了缩小临界区，<code>arena</code>中有多个锁管理不同的部分:</p>
<ul>
<li><code>arenas_lock</code>：<code>arena</code>的初始化、分配等</li>
<li><code>arena-&gt;lock</code>：<code>run</code>和<code>chunk</code>的管理</li>
<li><code>arena-&gt;huge_mtx</code>：<code>huge object</code>的管理</li>
<li><code>bin-&gt;lock</code>：<code>bin</code>中的操作</li>
</ul>
<h2 id="tsd"><a href="#tsd" class="headerlink" title="tsd"></a>tsd</h2><p>当选择完<code>arena</code>后，会将<code>arena</code>绑定到<code>tsd</code>中，之后会直接从<code>tsd</code>中获取<code>arena</code>。</p>
<p><code>tsd</code>用于保存每个线程特有的数据，主要是<code>arena</code>和<code>tcache</code>，避免锁的竞争。<code>tsd_t</code>中的数据会在第一次访问时延迟初始化(调用相应的<code>get_hard()</code>)，<code>tsd</code>中各元素使用宏生成对应的<code>get/set</code>函数来获取/设置，在线程退出时，会调用相应的<code>cleanup</code>函数清理。下面只介绍<code>linux</code>平台中的实现。</p>
<p>在<code>linux</code>中会使用<code>tls(__thread)</code>和<code>tsd(pthread_key_create(), pthread_setspecific())</code>来实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> (defined(JEMALLOC_TLS))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	malloc_tsd_data(a_attr, a_name, a_type, a_initializer)		\</span></span><br><span class="line"><span class="meta">a_attr __thread a_type JEMALLOC_TLS_MODEL				\</span></span><br><span class="line"><span class="meta">    a_name##tsd_tls = a_initializer;					\</span></span><br><span class="line"><span class="meta">a_attr pthread_key_t	a_name##tsd_tsd;				\</span></span><br><span class="line"><span class="meta">a_attr bool		a_name##tsd_booted = false;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>__thread</code>保存需要线程局部存储的数据<code>tsd_t</code></li>
<li><code>pthread_key_t</code>将<code>key</code>与<code>__thread</code>联系起来，用于注册<code>destructor，</code>在线程退出时清理<code>tsd_t</code></li>
</ul>
<p>其实可以只用<code>pthread_key_t</code>来实现，但使用<code>__thread</code>可以直接获取数据，不用再调用<code>pthread_getspecific()</code>。</p>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><p><code>tcache</code>用于<code>small</code>和<code>large</code>的分配，避免多线程的同步。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;opt.tcache&quot;</span> (<span class="type">bool</span>) r- [--enable-tcache]</span><br><span class="line">        Thread-specific <span class="title function_">caching</span> <span class="params">(tcache)</span> enabled/disabled. When there are multiple threads, each thread uses a tcache <span class="keyword">for</span> objects up to a certain size. Thread-specific caching allows many allocations to be satisfied without performing any</span><br><span class="line">        thread synchronization, at the cost of increased memory use. See the &quot;opt.lg_tcache_max&quot; option <span class="keyword">for</span> related tuning information. This option is enabled by <span class="keyword">default</span> unless running inside Valgrind[2], in which <span class="keyword">case</span> it is forcefully</span><br><span class="line">        disabled.</span><br><span class="line"></span><br><span class="line">&quot;opt.lg_tcache_max&quot; <span class="params">(<span class="type">size_t</span>)</span> r- [--enable-tcache]</span><br><span class="line">    Maximum size <span class="title function_">class</span> <span class="params">(<span class="built_in">log</span> base <span class="number">2</span>)</span> to cache in the thread-specific <span class="title function_">cache</span> <span class="params">(tcache)</span>. At a minimum, all small size classes are cached, and at a maximum all large size classes are cached. The <span class="keyword">default</span> maximum is 32 <span class="title function_">KiB</span> <span class="params">(<span class="number">2</span>^<span class="number">15</span>)</span>.</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_s</span> &#123;</span></span><br><span class="line">	ql_elm(<span class="type">tcache_t</span>) link;		<span class="comment">/* Used for aggregating stats. */</span></span><br><span class="line">	<span class="type">uint64_t</span>	prof_accumbytes;<span class="comment">/* Cleared after arena_prof_accum(). */</span></span><br><span class="line">	<span class="type">unsigned</span>	ev_cnt;		<span class="comment">/* Event count since incremental GC. */</span></span><br><span class="line">	<span class="type">szind_t</span>		next_gc_bin;	<span class="comment">/* Next bin to GC. */</span></span><br><span class="line">	<span class="type">tcache_bin_t</span>	tbins[<span class="number">1</span>];	<span class="comment">/* Dynamically sized. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The pointer stacks associated with tbins follow as a contiguous</span></span><br><span class="line"><span class="comment">	 * array.  During tcache initialization, the avail pointer in each</span></span><br><span class="line"><span class="comment">	 * element of tbins is initialized to point to the proper offset within</span></span><br><span class="line"><span class="comment">	 * this array.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_bin_s</span> &#123;</span></span><br><span class="line">	<span class="type">tcache_bin_stats_t</span> tstats;</span><br><span class="line">	<span class="type">int</span>		low_water;	<span class="comment">/* Min # cached since last GC. */</span></span><br><span class="line">	<span class="type">unsigned</span>	lg_fill_div;	<span class="comment">/* Fill (ncached_max &gt;&gt; lg_fill_div). */</span></span><br><span class="line">	<span class="type">unsigned</span>	ncached;	<span class="comment">/* # of cached objects. */</span></span><br><span class="line">	<span class="type">void</span>		**avail;	<span class="comment">/* Stack of available objects. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>tcache</code>同样使用<code>slab</code>算法分配:</p>
<ul>
<li><code>tcache</code>中有多种<code>bin</code>，每个<code>bin</code>管理一个<code>size class</code></li>
<li>当分配时，从对应<code>bin</code>中返回一个<code>cache slot</code></li>
<li>当释放时，将<code>cache slot</code>返回给对应的<code>bin</code></li>
</ul>
<p><code>tcache</code>中<code>avail</code>是指针数组，每个数组元素指向对应的<code>cache slot</code>，<code>cache slot</code>是从<code>arena</code>中分配的，缓存在<code>tcache</code>中。</p>
<p><code>tcache_boot()</code>：根据配置<code>opt.lg_tcache_max</code>设置<code>tcache</code>中<code>bin</code>的范围(<code>nhbins</code>)。设置<code>tcache_bin_info</code>，保存每种<code>bin</code>的<code>cache slots</code>个数(类似<code>arena_bin_info</code>中<code>nregs</code>)，<code>small</code>在<code>TCACHE_NSLOTS_SMALL_MIN</code>到<code>TCACHE_NSLOTS_SMALL_MAX</code>间，<code>large</code>固定为<code>TCACHE_NSLOTS_LARGE</code>。</p>
<p><code>tcache_create()</code>：<code>tcache_t</code>中保存着<code>tbins[]</code>信息，<code>tcache_bin_t</code>中<code>avail</code>指向每一个<code>cache slot</code>(类似<code>arena-&gt;bin</code>中<code>region</code>)，<code>tcache_create()</code>根据<code>tcache_boot()</code>设置的配置分配<code>tcache_t</code>和<code>tcache_bin_t</code>的内存，<code>tcache_t</code>和<code>tbins[]</code>为连续内存，<code>tbins[]</code>中<code>avail</code>使用后面连续空间的内存。</p>
<p><img src="/img/20211102100904.png" alt=""></p>
<h2 id="small-1"><a href="#small-1" class="headerlink" title="small"></a>small</h2><p><code>small</code>分配流程如下:</p>
<ol>
<li><code>tcache_alloc_small()</code>：先获取对应的<code>tbin</code>，调用<code>tcache_alloc_easy()</code>，若<code>tbin</code>中还有剩余的元素，返回<code>tbin-&gt;avail[tbin-&gt;ncached]</code>(从后往前分配，<code>ncached</code>既是剩余数量也是索引)，<code>tbin-&gt;low_water</code>保存着<code>tbin-&gt;ncached</code>的最小值。</li>
<li><code>tcache_alloc_small_hard()</code>：<code>tbin</code>已空，先调用<code>arena_tcache_fill_small()</code>重新装载<code>tbin</code>，再调用<code>tcache_alloc_easy()</code>分配。</li>
<li><code>arena_tcache_fill_small()</code>：从<code>arena</code>中对应的<code>bin</code>分配<code>region</code>保存在<code>tbin-&gt;avail</code>中，只会填充<code>ncached_max &gt;&gt; lg_fill_div</code>个。</li>
</ol>
<p><code>small</code>释放流程如下:</p>
<ol>
<li><code>tcache_dalloc_small()</code>：通过<code>ptr</code>对应的<code>map_bits</code>获取<code>binind</code>，然后将<code>ptr</code>释放(保存在<code>tbin-&gt;avail[tbin-&gt;ncached]</code>，同时<code>tbin-&gt;ncached++</code>)。若该<code>tbin</code>已满(<code>tbin-&gt;ncached == tbin_info-&gt;ncached_max</code>)，会调用<code>tcache_bin_flush_small()</code>，释放一半<code>cache slots</code>给<code>arena</code>。</li>
<li><code>tcache_bin_flush_small()</code>：会释放<code>tbin</code>中部分<code>avail</code>返回给<code>arena</code>中对应的<code>bin</code>，这里为了减少锁的调用，会在一次加锁中，释放所有对应该锁(bin)的<code>cache slot</code>。</li>
</ol>
<h2 id="large-1"><a href="#large-1" class="headerlink" title="large"></a>large</h2><p>分配和<code>small</code>类似，先调用<code>tcache_alloc_easy()</code>，不过若<code>tbin</code>为空时，不会像<code>small</code>一样分配所有的<code>avail</code>，而是调用<code>arena_malloc_large()</code>从<code>arena</code>中分配一个<code>run</code>。因为创建多个<code>large object</code>太过昂贵，并且有可能会用不到，浪费空间。</p>
<p>释放和<code>small</code>类似，先释放到<code>tbin-&gt;avail[tbin-&gt;ncached]</code>中，备用。若该<code>tbin</code>已满，调用<code>arena_bin_flush_large()</code>释放一半到<code>arena</code>中。</p>
<h2 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h2><p>前面注意到，当从<code>arena</code>分配<code>small</code>时， 会分配<code>ncached_max &gt;&gt; lg_fill_div</code>个，若每次均分配固定数目，有可能会造成内存浪费，<code>jemalloc</code>对<code>tcache</code>中的<code>bin</code>采用渐进式<code>GC</code>，动态的调整分配数目。有 2 个宏控制着<code>GC</code>的进行:</p>
<ul>
<li><code>TCACHE_GC_SWEEP</code>：可以近似认为每发生该数量的分配或释放操作，所有的<code>bin</code>都被<code>GC</code></li>
<li><code>TCACHE_GC_INCR</code>：每发生该数量的分配或释放操作，单个<code>bin</code>进行一次<code>GC</code></li>
</ul>
<p><code>tcache</code>中每个<code>bin</code>会有如下2个字段:</p>
<ul>
<li><code>low_water</code>：保存着一次<code>GC</code>时间间隔内，<code>ncached</code>的最小值，也就意味着在这之下的<code>avail</code>都没被分配</li>
<li><code>lg_fill_div</code>：用于控制每次分配的数量(<code>ncached_max &gt;&gt; lg_fill_div</code>)，初始为 1</li>
</ul>
<p>在每次分配和释放时，都会调用<code>tcache_event()</code>，增加<code>tcache-&gt;ev_cnt</code>，若和<code>TCACHE_GC_INCR</code>相等，则调用<code>tcache_event_hard()</code>对单个<code>bin</code>进行<code>GC</code>(只对<code>small object</code>有效)。<code>tcache_event_hard()</code>：对单个<code>bin</code>(<code>next_gc_bin</code>)进行<code>GC</code>:</p>
<ol>
<li>若<code>tbin-&gt;low_water &gt; 0</code>：说明<code>tbin-&gt;avail</code>中有些未被用到，可以尝试减少分配。对应的操作就是释放掉<code>3/4 low_water</code>，<code>lg_fill_div++</code>(下次分配时会减少一半)</li>
<li>若<code>tbin-&gt;low_water &lt; 0</code>：只有在该<code>tbin-&gt;avail</code>全部分配完才会置<code>low_water = -1</code>，说明不够用，所以会<code>lg_fill_div--</code>(下次分配时加倍)</li>
</ol>
<p><code>tcache</code>中的<code>tbin</code>分配数量就会一直动态调整。</p>
<h2 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h2><p>线程退出时，会调用<code>tsd_cleanup()</code>对<code>tsd</code>中数据进行清理:</p>
<ul>
<li><code>arena</code>：降低<code>arena</code>负载(<code>arena-&gt;nthreads--</code>)</li>
<li><code>tcache</code>：调用<code>tcache_bin_flush_small/large()</code>释放<code>tcache-&gt;tbins[]</code>所有元素，释放<code>tcache</code>本身</li>
</ul>
<p>当从一个线程分配的内存由另一个线程释放时，该内存还是由原先的<code>arena</code>来管理，通过<code>chunk</code>的<code>extent_node_t</code>来获取对应的<code>arena</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>jemalloc</code>中大量使用了宏生成代码，比较晦涩，不过其他部分还是比较清楚的，只要理解了它的思路就容易看懂，一层一层的。现在来总结一下<code>jemalloc</code>的思路：</p>
<ul>
<li>通过避免<code>false cache line sharing</code>，使用内存着色等，提高<code>cache line</code>效率</li>
<li>使用<code>slab</code>分配不同大小的对象，精心选择<code>size classes</code>，减少内存碎片</li>
<li>使用多层缓存，内存的释放和分配会经历很多阶段，提升速度</li>
<li><code>metadata</code>存放在连续内存，降低<code>metadata</code>的<code>overhead</code>，同时能减少<code>active pages</code></li>
<li>地址对齐从而在常量时间内获取<code>metadata</code></li>
<li>首先复用低地址的内存，减少<code>active pages</code></li>
<li>使用多个<code>arena</code>管理、更细粒度的锁、<code>tsd</code>、<code>tcache</code>等，最小化锁竞争</li>
</ul>
<h1 id="JeMalloc-5-1-0-版本"><a href="#JeMalloc-5-1-0-版本" class="headerlink" title="JeMalloc-5.1.0 版本"></a>JeMalloc-5.1.0 版本</h1><p>这篇文章介绍JeMalloc-5.1.0 版本（release 日期：2018年5月9日）的实现细节。</p>
<p>对于对老版本比较熟悉的人来说，有几点需要说明：</p>
<ul>
<li><code>chunk</code>这一概念被替换成了 extent</li>
<li><code>dirty page</code>的<code>decay</code>（或者说 gc） 变成了两阶段，dirty -&gt; muzzy -&gt; retained</li>
<li><code>huge class</code>这一概念不再存在</li>
<li>红黑树不再使用，取而代之的是 pairing heap</li>
</ul>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>以下内容介绍 JeMalloc 中比较重要的概念以及数据结构。</p>
<h3 id="size-class"><a href="#size-class" class="headerlink" title="size_class"></a>size_class</h3><p>每个<code>size_class</code>代表<code>jemalloc</code>分配的内存大小，共有<code>NSIZES</code>（232）个小类（如果用户申请的大小位于两个小类之间，会取较大的，比如申请14字节，位于8和16字节之间，按16字节分配），分为2大类：</p>
<ul>
<li><code>small_class</code>（小内存） : 对于64位机器来说，通常区间是 [8, 14kb]，常见的有 8, 16, 32, 48, 64, …, 2kb, 4kb, 8kb，注意为了减少内存碎片并不都是2的次幂，比如如果没有48字节，那当申请33字节时，分配64字节显然会造成约50%的外部碎片</li>
<li><code>large_class</code>（大内存）: 对于64位机器来说，通常区间是 [16kb, 7EiB]，从 4 * page_size 开始，常见的比如 16kb, 32kb, …, 1mb, 2mb, 4mb，最大是<code>2^63 + 3^60</code></li>
<li><code>size_index</code>: size 位于 size_class 中的索引号，区间为 [0，231]，比如8字节则为0，14字节（按16计算）为1，4kb字节为28，当<code>size</code>是<code>small_class</code>时，<code>size_index</code>也称作<code>binind</code></li>
</ul>
<h3 id="base-1"><a href="#base-1" class="headerlink" title="base"></a>base</h3><p>用于分配 jemalloc 元数据内存的结构，通常一个 base 大小为 2mb， 所有 base 组成一个链表。</p>
<ul>
<li><code>base.extents[NSIZES]</code>: 存放每个<code>size_class</code>的<code>extent</code>元数据</li>
</ul>
<h3 id="bin-1"><a href="#bin-1" class="headerlink" title="bin"></a>bin</h3><p>管理正在使用中的<code>slab</code>（即用于小内存分配的 extent） 的集合，每个<code>bin</code>对应一个<code>size_class</code></p>
<ul>
<li><code>bin.slabcur</code>: 当前使用中的 slab</li>
<li><code>bin.slabs_nonfull</code>: 有空闲内存块的 slab</li>
</ul>
<h3 id="extent"><a href="#extent" class="headerlink" title="extent"></a>extent</h3><p>管理 jemalloc 内存块（即用于用户分配的内存）的结构，每一个内存块大小可以是<code>N * page_size(4kb)</code>（N &gt;= 1）。每个<code>extent</code>有一个序列号（serial number）。</p>
<p>一个<code>extent</code>可以用来分配一次<code>large_class</code>的内存申请，但可以用来分配多次<code>small_class</code>的内存申请。</p>
<ul>
<li><code>extent.e_bits</code>: 8字节长，记录多种信息</li>
<li><code>extent.e_addr</code>: 管理的内存块的起始地址</li>
<li><code>extent.e_slab_data</code>: 位图，当此<code>extent</code>用于分配<code>small_class</code>内存时，用来记录这个<code>extent</code>的分配情况，此时每个<code>extent</code>的内的小内存称为<code>region</code></li>
</ul>
<h3 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h3><p>当<code>extent</code>用于分配<code>small_class</code>内存时，称其为<code>slab</code>。一个<code>extent</code>可以被用来处理多个同一<code>size_class</code>的内存申请。</p>
<h3 id="extents"><a href="#extents" class="headerlink" title="extents"></a>extents</h3><p>管理<code>extent</code>的集合。</p>
<ul>
<li><code>extents.heaps[NPSIZES+1]</code>: 各种 page(4kb) 倍数大小的 extent</li>
<li><code>extents.lru</code>: 存放所有<code>extent</code>的双向链表</li>
<li><code>extents.delay_coalesce</code>: 是否延迟<code>extent</code>的合并</li>
</ul>
<h3 id="arena-2"><a href="#arena-2" class="headerlink" title="arena"></a>arena</h3><p>用于分配&amp;回收<code>extent</code>的结构，每个用户线程会被绑定到一个<code>arena</code>上，默认每个逻辑 CPU 会有 4 个<code>arena</code>来减少锁的竞争，各个<code>arena</code>所管理的内存相互独立。</p>
<ul>
<li><code>arena.extents_dirty</code>：刚被释放后空闲<code>extent</code>位于的地方</li>
<li><code>arena.extents_muzzy</code>：<code>extents_dirty</code>进行<code>lazy purge</code>后位于的地方，dirty -&gt; muzzy</li>
<li><code>arena.extents_retained</code>：<code>extents_muzzy</code>进行<code>decommit</code>或<code>force purge</code>后<code>extent</code>位于的地方，muzzy -&gt; retained</li>
<li><code>arena.large</code>：存放<code>large extent</code>的 extents</li>
<li><code>arena.extent_avail</code>：<code>heap</code>，存放可用的<code>extent</code>元数据</li>
<li><code>arena.bins[NBINS]</code>：所以用于分配小内存的<code>bin</code></li>
<li><code>arena.base</code>：用于分配元数据的<code>base</code></li>
</ul>
<h3 id="rtree"><a href="#rtree" class="headerlink" title="rtree"></a>rtree</h3><p>全局唯一的存放每个<code>extent</code>信息的 Radix Tree，以<code>extent-&gt;e_addr</code>即<code>uintptr_t</code>为<code>key</code>，以我的机器为例，<code>uintptr_t</code>为64位（8字节），<code>rtree</code>的高度为3，由于<code>extent-&gt;e_addr</code>是<code>page(1 &lt;&lt; 12)</code>对齐的，也就是说需要 64 - 12 = 52 位即可确定在树中的位置，每一层分别通过第0-16位，17-33位，34-51位来进行访问。</p>
<p><img src="/img/v2-92f9c4741a626e4a48a9ca987d36b82c_1440w.jpg" alt=""></p>
<h3 id="cache-bin"><a href="#cache-bin" class="headerlink" title="cache_bin"></a>cache_bin</h3><p>每个线程独有的用于分配小内存的缓存</p>
<ul>
<li><code>low_water</code>：上一次 gc 后剩余的缓存数量</li>
<li><code>cache_bin.ncached</code>：当前 cache_bin 存放的缓存数量</li>
<li><code>cache_bin.avail</code>：可直接用于分配的内存，从左往右依次分配（注意这里的寻址方式）</li>
</ul>
<p><img src="/img/v2-4ce3efe4b89f927df4b4c0cfbd588558_1440w.jpg" alt=""></p>
<h3 id="tcache-1"><a href="#tcache-1" class="headerlink" title="tcache"></a>tcache</h3><p>每个线程独有的缓存（Thread Cache），大多数内存申请都可以在 tcache 中直接得到，从而避免加锁</p>
<ul>
<li><code>tcache.bins_small[NBINS]</code>：小内存的<code>cache_bin</code></li>
</ul>
<h3 id="tsd-1"><a href="#tsd-1" class="headerlink" title="tsd"></a>tsd</h3><p>Thread Specific Data，每个线程独有，用于存放与这个线程相关的结构</p>
<ul>
<li><code>tsd.rtree_ctx</code>：当前线程的<code>rtree context</code>，用于快速访问<code>extent</code>信息</li>
<li><code>tsd.arena</code>：当前线程绑定的<code>arena</code></li>
<li><code>tsd.tcache</code>：当前线程的<code>tcache</code></li>
</ul>
<h2 id="内存分配（malloc）"><a href="#内存分配（malloc）" class="headerlink" title="内存分配（malloc）"></a>内存分配（malloc）</h2><h3 id="小内存-small-class-分配"><a href="#小内存-small-class-分配" class="headerlink" title="小内存(small_class)分配"></a>小内存(small_class)分配</h3><p>首先从<code>tsd-&gt;tcache-&gt;bins_small[binind]</code>中获取对应<code>size_class</code>的内存，有的话将内存直接返回给用户，如果<code>bins_small[binind]</code>中没有的话，需要通过<code>slab(extent)</code>对<code>tsd-&gt;tcache-&gt;bins_small[binind]</code>进行填充，一次填充多个以备后续分配，填充方式如下（当前步骤无法成功则进行下一步）：</p>
<ol>
<li>通过<code>bin-&gt;slabcur</code>分配</li>
<li>从<code>bin-&gt;slabs_nonfull</code>中获取可使用的<code>extent</code></li>
<li>从<code>arena-&gt;extents_dirty</code>中回收<code>extent</code>，回收方式为<code>best-fit</code>，即满足大小要求的最小<code>extent</code>，在<code>arena-&gt;extents_dirty-&gt;bitmap</code>中找到满足大小要求并且第一个非空<code>heap</code>的索引<code>i</code>，然后从<code>extents-&gt;heaps[i]</code>中获取第一个<code>extent</code>。由于<code>extent</code>可能较大，为了防止产生内存碎片，需要对<code>extent</code>进行分裂（伙伴算法），然后将分裂后不使用的<code>extent</code>放回<code>extents_dirty</code>中</li>
<li>从<code>arena-&gt;extents_muzzy</code>中回收<code>extent</code>，回收方式为<code>first-fit</code>，即满足大小要求且序列号最小地址最低（最旧）的<code>extent</code>，遍历每个满足大小要求并且非空的<code>arena-&gt;extents_dirty-&gt;bitmap</code>，获取其对应<code>extents-&gt;heaps</code>中第一个<code>extent</code>，然后进行比较，找到最旧的<code>extent</code>，之后仍然需要分裂</li>
<li>从<code>arena-&gt;extents_retained</code>中回收<code>extent</code>，回收方式与<code>extents_muzzy</code>相同</li>
<li>尝试通过<code>mmap</code>向内核获取所需的<code>extent</code>内存，并且在<code>rtree</code>中注册新<code>extent</code>的信息</li>
<li>再次尝试从<code>bin-&gt;slabs_nonfull</code>中获取可使用的<code>extent</code></li>
</ol>
<p>简单来说，这个流程是这样的，<code>cache_bin -&gt; slab -&gt; slabs_nonfull -&gt; extents_dirty -&gt; extents_muzzy -&gt; extents_retained -&gt; kernal</code>。</p>
<p><img src="/img/v2-07d44c859efbc6ac177b27793acb96e8_1440w.jpg" alt=""></p>
<h3 id="大内存-large-class-分配"><a href="#大内存-large-class-分配" class="headerlink" title="大内存(large_class)分配"></a>大内存(large_class)分配</h3><p>大内存不存放在<code>tsd-&gt;tcache</code>中，因为这样可能会浪费内存，所以每次申请都需要重新分配一个<code>extent</code>，申请的流程和小内存申请<code>extent</code>流程中的3, 4, 5, 6是一样的。</p>
<h2 id="内存释放（free）"><a href="#内存释放（free）" class="headerlink" title="内存释放（free）"></a>内存释放（free）</h2><h3 id="小内存释放"><a href="#小内存释放" class="headerlink" title="小内存释放"></a>小内存释放</h3><p>在<code>rtree</code>中找到需要被释放内存所属的<code>extent</code>信息，将要被释放的内存还给<code>tsd-&gt;tcache-&gt;bins_small[binind]</code>，如果<code>tsd-&gt;tcache-&gt;bins_small[binind]</code>已满，需要对其进行<code>flush</code>，流程如下：</p>
<ol>
<li>将这块内存返还给所属<code>extent</code>，如果这个<code>extent</code>中空闲的内存块变成了最大（即没有一份内存被分配），跳到2；如果这个<code>extent</code>中的空闲块变成了1并且这个<code>extent</code>不是<code>arena-&gt;bins[binind]-&gt;slabcur</code>，跳到3</li>
<li>将这个<code>extent</code>释放，即插入<code>arena-&gt;extents_dirty</code>中</li>
<li>将<code>arena-&gt;bins[binind]-&gt;slabcur</code>切换为这个<code>extent</code>，前提是这个<code>extent</code>“更旧”（序列号更小地址更低），并且将替换后的<code>extent</code>移入<code>arena-&gt;bins[binind]-&gt;slabs_nonfull</code></li>
</ol>
<h3 id="大内存释放"><a href="#大内存释放" class="headerlink" title="大内存释放"></a>大内存释放</h3><p>因为大内存不存放在<code>tsd-&gt;tcache</code>中，所以大内存释放只进行小内存释放的步骤2，即将<code>extent</code>插入<code>arena-&gt;extents_dirty</code>中。</p>
<h2 id="内存再分配（realloc）"><a href="#内存再分配（realloc）" class="headerlink" title="内存再分配（realloc）"></a>内存再分配（realloc）</h2><h3 id="小内存再分配"><a href="#小内存再分配" class="headerlink" title="小内存再分配"></a>小内存再分配</h3><ol>
<li>尝试进行 no move 分配，如果之前的实际分配满足条件的话，可以不做任何事情，直接返回。比如第一次申请了12字节，但实际上 jemalloc 会实际分配16字节，然后第二次申请将12扩大到15字节或者缩小到9字节，那这时候16字节就已经满足需求了，所以不做任何事情，如果无法满足，跳到2</li>
<li>重新分配，申请新内存大小（参考内存分配），然后将旧内存内容拷贝到新地址，之后释放旧内存（参考内存释放），最后返回新内存</li>
</ol>
<h3 id="大内存再分配"><a href="#大内存再分配" class="headerlink" title="大内存再分配"></a>大内存再分配</h3><ol>
<li>尝试进行 no move 分配，如果两次申请位于同一 size class 的话就可以不做任何事情，直接返回。</li>
<li>尝试进行 no move resize 分配，如果第二次申请的大小大于第一次，则尝试对当前地址所属<code>extent</code>的下一地址查看是否可以分配，比如当前<code>extent</code>地址是 0x1000，大小是 0x1000，那么我们查看地址 0x2000 开始的<code>extent</code>是否存在（通过 rtree）并且是否满足要求，如果满足要求那两个<code>extent</code>可以进行合并，成为一个新的<code>extent</code>而不需要重新分配；如果第二次申请的大小小于第一次，那么尝试对当前<code>extent</code>进行<code>split</code>，移除不需要的后半部分，以减少内存碎片；如果无法进行 no move resize 分配，跳到3</li>
<li>重新分配，申请新内存大小（参考内存分配），然后将旧内存内容拷贝到新地址，之后释放旧内存（参考内存释放），最后返回新内存</li>
</ol>
<h2 id="内存-GC"><a href="#内存-GC" class="headerlink" title="内存 GC"></a>内存 GC</h2><p>分为2种， tcache 和 extent GC。其实更准确来说是 decay，为了方便还是用 gc 吧。</p>
<h3 id="tcache-GC"><a href="#tcache-GC" class="headerlink" title="tcache GC"></a>tcache GC</h3><p>针对 small_class，防止某个线程预先分配了内存但是却没有实际分配给用户，会定期将缓存 flush 到 extent。</p>
<p>GC 策略：每次对于 tcache 进行 malloc 或者 free 操作都会执行一次计数，默认情况下达到228次就会触发 gc，每次 gc 一个<code>cache_bin</code>。</p>
<p>如何 GC：</p>
<ol>
<li><code>cache_bin.low_water &gt; 0</code>: gc 掉 low_water 的 3/4，同时，将<code>cache_bin</code>能缓存的最大数量缩小一倍</li>
<li><code>cache_bin.low_water &lt; 0</code>: 将<code>cache_bin</code>能缓存的最大数量增大一倍</li>
</ol>
<p>总的来说保证当前<code>cache_bin</code>分配越频繁，则会缓存更多的内存，否则则会减少。</p>
<h3 id="extent-GC"><a href="#extent-GC" class="headerlink" title="extent GC"></a>extent GC</h3><p>调用<code>free</code>时，内存并没有归还给内核。<code>jemalloc</code>内部会不定期地将没有用于分配的<code>extent</code>逐步GC，流程和内存申请是反向的，<code>free -&gt; extents_dirty -&gt; extents_muzzy -&gt; extents_retained -&gt; kernal</code>。</p>
<p>GC 策略：默认10s为<code>extents_dirty</code>和<code>extents_muzzy</code>的一个 gc 周期，每次对于<code>arena</code>进行<code>malloc</code>或者<code>free</code>操作都会执行一次计数，达到1000次会检测有没有达到<code>gc</code>的<code>deadline</code>，如果是的话进行 gc。</p>
<p>注意并不是每隔10s一次性 gc，实际上 jemalloc 会将10s划分成200份，即每隔0.05s进行一次 gc，这样一来如果<code>t</code>时刻有<code>N</code>个<code>page</code>需要<code>gc</code>，那么<code>jemalloc</code>尽力保证在<code>t+10</code>时刻这<code>N</code>个<code>page</code>会被<code>gc</code>完成。</p>
<p>对于<code>N</code>个需要<code>gc</code>的<code>page</code>来说，并不是简单地每0.05s处理<code>N/200</code>个<code>page</code>，<code>jemalloc</code>引入了<code>Smoothstep</code>（主要用于计算机图形学）来获得更加平滑的<code>gc</code>机制，这也是 jemalloc 非常有意思的一个点。</p>
<p>jemalloc 内部维护了一个长度为200的数组，用来计算在10s的 gc 周期内每个时间点应该对多少 page 进行 gc。这样保证两次 gc 的时间段内产生的需要 gc 的 page 都会以图中绿色线条（默认使用 smootherstep）的变化曲线在10s的周期内从 N 减为 0（从右往左）。</p>
<p>如何 GC：先进行<code>extents_dirty</code>的 gc，后进行<code>extents_muzzy</code>。</p>
<ol>
<li>将<code>extents_dirty</code>中的<code>extent</code>移入<code>extents_muzzy</code>：<ol>
<li>在<code>extents_dirty</code>中的<code>LRU</code>链表中，获得要进行<code>gc</code>的<code>extent</code>，尝试对<code>extent</code>进行前后合并（前提是两个<code>extent</code>位于同一<code>arena</code>并且位于同一<code>extents</code>中），获得新的<code>extent</code>，然后将其移除</li>
<li>对当前<code>extent</code>管理的地址进行<code>lazy purge</code>，即通过<code>madvise</code>使用<code>MADV_FREE</code>参数告诉内核当前<code>extent</code>管理的内存可能不会再被访问</li>
<li>在<code>extents_muzzy</code>中尝试对当前<code>extent</code>进行前后合并，获得新的<code>extent</code>，最后将其插入<code>extents_muzzy</code></li>
</ol>
</li>
<li>将<code>extents_muzzy</code>中的<code>extent</code>移入<code>extents_retained</code>:<ol>
<li>在<code>extents_muzzy</code>中的<code>LRU</code>链表中，获得要进行<code>gc</code>的<code>extent</code>，尝试对<code>extent</code>进行前后合并，获得新的<code>extent</code>，然后将其移除</li>
<li>对当前<code>extent</code>管理的地址进行<code>decommit</code>，即调用<code>mmap</code>带上<code>PROT_NONE</code>告诉内核当前<code>extent</code>管理的地址可能不会再被访问，如果<code>decommit</code>失败，会进行<code>force purge</code>，即通过<code>madvise</code>使用<code>MADV_DONTNEED</code>参数告诉内核当前<code>extent</code>管理的内存可能不会再被访问</li>
<li>在<code>extents_retained</code>中尝试对当前<code>extent</code>进行前后合并，获得新的<code>extent</code>，最后将其插入<code>extents_retained</code></li>
</ol>
</li>
<li>jemalloc 默认不会将内存归还给内核，只有进程结束时，所有内存才会<code>munmap</code>，从而归还给内核。不过可以手动进行<code>arena</code>的销毁，从而将<code>extents_retained</code>中的内存进行<code>munmap</code></li>
</ol>
<h2 id="附-快速调试Jemalloc"><a href="#附-快速调试Jemalloc" class="headerlink" title="附: 快速调试Jemalloc"></a>附: 快速调试Jemalloc</h2><p>一个简单的调试Je的方法是以静态库的方式将其编译到你的应用程序中。先编译Je的静态库，在源码目录下执行，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>就可以编译并安装Je到系统路径。调试还必须打开一些选项，例如，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-debug  --with-jemalloc-prefix=&lt;prefix&gt;</span><br></pre></td></tr></table></figure>
<p>这些选项的意义可以参考INSTALL文档。比如，</p>
<ul>
<li><code>--disable-tcache</code> 是否禁用tcache，对调试非tcache流程有用。</li>
<li><code>--disable-prof</code>   是否禁用heap profile.</li>
<li><code>--enable-debug</code>   打开调试模式，启动assert并关闭优化。</li>
<li><code>--with-jemalloc-prefix</code>  将编译出的malloc加上设定的前缀，以区别c库的调用。</li>
</ul>
<p>之后就可以将其编译到你的代码中，如，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c /usr/local/lib/libjemalloc.a -std=c99 -O0 -g3 -pthread -o jhello</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/15/ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/15/ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">glibc内存管理ptmalloc源代码分析1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-15 17:42:00" itemprop="dateCreated datePublished" datetime="2021-10-15T17:42:00+08:00">2021-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 20:30:46" itemprop="dateModified" datetime="2022-12-26T20:30:46+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="X86平台Linux进程内存布局"><a href="#X86平台Linux进程内存布局" class="headerlink" title="X86平台Linux进程内存布局"></a>X86平台Linux进程内存布局</h2><p><code>Linux</code>系统在装载<code>elf</code>格式的程序文件时，会调用<code>loader</code>把可执行文件中的各个段依次载入到从某一地址开始的空间中（载入地址取决<code>link editor(ld)</code>和机器地址位数，在32位机器上是0x8048000，即<code>128M</code>处）。如下图所示，以32位机器为例，首先被载入的是<code>.text</code>段，然后是<code>.data</code>段，最后是<code>.bss</code>段。这可以看作是程序的开始空间。程序所能访问的最后的地址是<code>0xbfffffff</code>，也就是到<code>3G</code>地址处，<code>3G</code>以上的<code>1G</code>空间是内核使用的，应用程序不可以直接访问。应用程序的堆栈从最高地址处开始向下生长，<code>.bss</code>段与堆栈之间的空间是空闲的，空闲空间被分成两部分，一部分为<code>heap</code>，一部分为<code>mmap</code>映射区域，<code>mmap</code>映射区域一般从<code>TASK_SIZE/3</code>的地方开始。</p>
<p><code>heap</code>和<code>mmap</code>区域都可以供用户自由使用，但是它在刚开始的时候并没有映射到内存空间内，是不可访问的。在向内核请求分配该空间之前，对这个空间的访问会导致<code>segmentation fault</code>。用户程序可以直接使用系统调用来管理<code>heap</code>和<code>mmap</code>映射区域，但更多的时候程序都是使用<code>C</code>语言提供的<code>malloc()</code>和<code>free()</code>函数来动态的分配和释放内存。 Stack`区域是唯一不需要映射，用户却可以访问的内存区域，这也是利用堆栈溢出进行攻击的基础。</p>
<h3 id="32位模式下进程内存经典布局"><a href="#32位模式下进程内存经典布局" class="headerlink" title="32位模式下进程内存经典布局"></a>32位模式下进程内存经典布局</h3><p><img src="/img/1634291202.jpg" alt=""><br>这种布局是<code>Linux</code>内核2.6.7以前的默认进程内存布局形式，<code>mmap</code>区域与栈区域相对增长，这意味着堆只有<code>1GB</code>的虚拟地址空间可以使用，继续增长就会进入<code>mmap</code>映射区域，这显然不是我们想要的。这是由于32模式地址空间限制造成的，所以内核引入了另一种虚拟地址空间的布局形式。但对于64位系统，提供了巨大的虚拟地址空间，这种布局就相当好。</p>
<h3 id="32位模式下进程默认内存布局"><a href="#32位模式下进程默认内存布局" class="headerlink" title="32位模式下进程默认内存布局"></a>32位模式下进程默认内存布局</h3><p><img src="/img/1634291292.jpg" alt=""><br>从上图可以看到，栈至顶向下扩展，并且栈是有界的。堆至底向上扩展，<code>mmap</code>映射区域至顶向下扩展，<code>mmap</code>映射区域和堆相对扩展，直至耗尽虚拟地址空间中的剩余区域，这种结构便于<code>C</code>运行时库使用<code>mmap</code>映射区域和堆进行内存分配。上图的布局形式是在内核2.6.7以后才引入的，这是32位模式下进程的默认内存布局形式。</p>
<h3 id="64位模式下进程内存布局"><a href="#64位模式下进程内存布局" class="headerlink" title="64位模式下进程内存布局"></a>64位模式下进程内存布局</h3><p>在64位模式下各个区域的起始位置是什么呢？对于<code>AMD64</code>系统，内存布局采用经典内存布局，<code>text</code>的起始地址为<code>0x0000000000400000</code>，堆紧接着<code>BSS</code>段向上增长，<code>mmap</code>映射区域开始位置一般设为<code>TASK_SIZE/3</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE_MAX ((1UL &lt;&lt; 47) - PAGE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE (test_thread_flag(TIF_IA32) ? \</span></span><br><span class="line"><span class="meta">IA32_PAGE_OFFSET : TASK_SIZE_MAX)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_TOP TASK_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNMAPPED_BASE (PAGE_ALIGN(TASK_SIZE / 3))</span></span><br></pre></td></tr></table></figure></p>
<p>计算一下可知，<code>mmap</code>的开始区域地址为0x00002AAAAAAAA000，栈顶地址为0x00007FFFFFFFF0006</p>
<p><img src="/img/1634291332.jpg" alt=""><br>上图是<code>X86_64</code>下<code>Linux</code>进程的默认内存布局形式，这只是一个示意图，当前内核默认配置下，进程的栈和<code>mmap</code>映射区域并不是从一个固定地址开始，并且每次启动时的值都不一样，这是程序在启动时随机改变这些值的设置，使得使用缓冲区溢出进行攻击更加困难。当然也可以让进程的栈和<code>mmap</code>映射区域从一个固定位置开始，只需要设置全局变量<code>randomize_va_space</code>值为0，这个变量默认值为1。用户可以通过设置<code>/proc/sys/kernel/randomize_va_space</code>来停用该特性，也可以用如下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure></p>
<h2 id="操作系统内存分配的相关函数"><a href="#操作系统内存分配的相关函数" class="headerlink" title="操作系统内存分配的相关函数"></a>操作系统内存分配的相关函数</h2><p>上节提到<code>heap</code>和<code>mmap</code>映射区域是可以提供给用户程序使用的虚拟内存空间，如何获得该区域的内存呢？操作系统提供了相关的系统调用来完成相关工作。对<code>heap</code>的操作，操作系统提供了<code>brk()</code>函数，<code>C</code>运行时库提供了<code>sbrk()</code>函数；对<code>mmap</code>映射区域的操作，操作系统提供了<code>mmap()</code>和<code>munmap()</code>函数。<code>sbrk()</code>，<code>brk()</code>或者<code>mmap()</code>都可以用来向我们的进程添加额外的虚拟内存。<code>Glibc</code>同样是使用这些函数向操作系统申请虚拟内存。</p>
<p>这里要提到一个很重要的概念，内存的延迟分配，只有在真正访问一个地址的时候才建立这个地址的物理映射，这是<code>Linux</code>内存管理的基本思想之一。 Linux`内核在用户申请内存的时候，只是给它分配了一个线性区（也就是虚拟内存），并没有分配实际物理内存；只有当用户使用这块内存的时候，内核才会分配具体的物理页面给用户，这时候才占用宝贵的物理内存。内核释放物理页面是通过释放线性区，找到其所对应的物理页面，将其全部释放的过程。</p>
<h3 id="heap操作相关函数"><a href="#heap操作相关函数" class="headerlink" title="heap操作相关函数"></a>heap操作相关函数</h3><p><code>heap</code>操作函数主要有两个，<code>brk()</code>为系统调用，<code>sbrk()</code>为<code>C</code>库函数。系统调用通常提供一种最小功能，而库函数通常提供比较复杂的功能。<code>Glibc</code>的<code>malloc</code>函数族（<code>realloc</code>，<code>calloc</code>等）就调用<code>sbrk()</code>函数将数据段的下界移动，<code>sbrk()</code>函数在内核的管理下将虚拟地址空间映射到内存，供<code>malloc()</code>函数使用。</p>
<p>内核数据结构<code>mm_struct</code>中的成员变量<code>start_code</code>和<code>end_code</code>是进程代码段的起始和终止地址，<code>start_data</code>和<code>end_data</code>是进程数据段的起始和终止地址，<code>start_stack</code>是进程堆栈段起始地址，<code>start_brk</code>是进程动态内存分配起始地址（堆的起始地址），还有一个<code>brk</code>（堆的当前最后地址），就是动态内存分配当前的终止地址。<code>C</code>语言的动态内存分配基本函数是<code>malloc()</code>，在<code>Linux</code>上的实现是通过内核的<code>brk</code>系统调用。<code>brk()</code>是一个非常简单的系统调用，只是简单地改变<code>mm_struct</code>结构的成员变量<code>brk</code>的值。</p>
<p>这两个函数的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">brk</span><span class="params">(<span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure></p>
<p>需要说明的是，<code>sbrk()</code>的参数<code>increment</code>为0时，<code>sbrk()</code>返回的是进程的当前<code>brk</code>值，<code>increment</code>为正数时扩展<code>brk</code>值，当<code>increment</code>为负值时收缩<code>brk</code>值。</p>
<h3 id="mmap映射区域操作相关函数"><a href="#mmap映射区域操作相关函数" class="headerlink" title="mmap映射区域操作相关函数"></a>mmap映射区域操作相关函数</h3><p><code>mmap()</code>函数将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。<code>munmap</code>执行相反的操作，删除特定地址区域的对象映射。函数的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li><code>start</code>：映射区的开始地址。</li>
<li><code>length</code>：映射区的长度。</li>
<li><code>prot</code>：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过<code>or</code>运算合理地组合在一起。<code>ptmalloc</code>中主要使用了如下的几个标志：<ul>
<li><code>PROT_EXEC</code>//页内容可以被执行，<code>ptmalloc</code>中没有使用</li>
<li><code>PROT_READ</code>//页内容可以被读取，<code>ptmalloc</code>直接用<code>mmap</code>分配内存并立即返回给用户时设置该标志</li>
<li><code>PROT_WRITE</code>//页可以被写入，<code>ptmalloc</code>直接用<code>mmap</code>分配内存并立即返回给用户时设置该标志</li>
<li><code>PROT_NONE</code>//页不可访问，<code>ptmalloc</code>用<code>mmap</code>向系统“批发”一块内存进行管理时设置该标志</li>
</ul>
</li>
<li><code>flags</code>：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体<ul>
<li><code>MAP_FIXED</code> //使用指定的映射起始地址，如果由<code>start</code>和<code>len</code>参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。<code>ptmalloc</code>在回收从系统中“批发”的内存时设置该标志。</li>
<li><code>MAP_PRIVATE</code> //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。<code>ptmalloc</code>每次调用<code>mmap</code>都设置该标志。</li>
<li><code>MAP_NORESERVE</code> //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。 ptmalloc`向系统“批发”内存块时设置该标志。</li>
<li><code>MAP_ANONYMOUS</code> //匿名映射，映射区不与任何文件关联。<code>ptmalloc</code>每次调用<code>mmap</code>都设置该标志。</li>
</ul>
</li>
<li><code>fd</code>：有效的文件描述词。如果<code>MAP_ANONYMOUS</code>被设定，为了兼容问题，其值应为-1。</li>
<li><code>offset</code>：被映射对象内容的起点。</li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="内存管理一般性描述"><a href="#内存管理一般性描述" class="headerlink" title="内存管理一般性描述"></a>内存管理一般性描述</h2><p>当不知道程序的每个部分将需要多少内存时，系统内存空间有限，而内存需求又是变化的，这时就需要内存管理程序来负责分配和回收内存。程序的动态性越强，内存管理就越重要，内存分配程序的选择也就更重要。</p>
<h3 id="内存管理的方法"><a href="#内存管理的方法" class="headerlink" title="内存管理的方法"></a>内存管理的方法</h3><p>可用于内存管理的方法有许多种，它们各有好处与不足，不同的内存管理方法有最适用的情形。</p>
<h4 id="C风格的内存管理程序"><a href="#C风格的内存管理程序" class="headerlink" title="C风格的内存管理程序"></a>C风格的内存管理程序</h4><p><code>C</code>风格的内存管理程序主要实现<code>malloc()</code>和<code>free()</code>函数。内存管理程序主要通过调用<code>brk()</code>或者<code>mmap()</code>进程添加额外的虚拟内存。<code>Doug Lea Malloc</code>，<code>ptmalloc</code>，<code>BSD malloc</code>，<code>Hoard</code>，<code>TCMalloc</code>都属于这一类内存管理程序。</p>
<p>基于<code>malloc()</code>的内存管理器仍然有很多缺点，不管使用的是哪个分配程序。对于那些需要保持长期存储的程序使用<code>malloc()</code>来管理内存可能会非常令人失望。如果有大量的不固定的内存引用，经常难以知道它们何时被释放。生存期局限于当前函数的内存非常容易管理，但是对于生存期超出该范围的内存来说，管理内存则困难得多。因为管理内存的问题，很多程序倾向于使用它们自己的内存管理规则。</p>
<h4 id="池式内存管理"><a href="#池式内存管理" class="headerlink" title="池式内存管理"></a>池式内存管理</h4><p>内存池是一种半内存管理方法。内存池帮助某些程序进行自动内存管理，这些程序会经历一些特定的阶段，而且每个阶段中都有分配给进程的特定阶段的内存。在池式内存管理中，每次内存分配都会指定内存池，从中分配内存。每个内存池都有不同的生存期限。另外，有一些实现允许注册清除函数（cleanup functions），在清除内存池之前，恰好可以调用它，来完成在内存被清理前需要完成的其他所有任务（类似于面向对象中的析构函数）。</p>
<p>使用池式内存分配的优点如下所示：</p>
<ul>
<li>应用程序可以简单地管理内存。</li>
<li>内存分配和回收更快，因为每次都是在一个池中完成的。分配可以在<code>O(1)</code>时间内完成，释放内存池所需时间也差不多（实际上是<code>O(n)</code>时间，不过在大部分情况下会除以一个大的因数，使其变成<code>O(1)</code>）。</li>
<li>可以预先分配错误处理池（Error-handling pools），以便程序在常规内存被耗尽时仍可以恢复。</li>
<li>有非常易于使用的标准实现。</li>
</ul>
<p>池式内存的缺点是：</p>
<ul>
<li>内存池只适用于操作可以分阶段的程序。</li>
<li>内存池通常不能与第三方库很好地合作。</li>
<li>如果程序的结构发生变化，则不得不修改内存池，这可能会导致内存管理系统的重新设计。</li>
<li>您必须记住需要从哪个池进行分配。另外，如果在这里出错，就很难捕获该内存池。</li>
</ul>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>在引用计数中，所有共享的数据结构都有一个域来包含当前活动“引用”结构的次数。当向一个程序传递一个指向某个数据结构指针时，该程序会将引用计数增加1。实质上，是在告诉数据结构，它正在被存储在多少个位置上。然后，当进程完成对它的使用后，该程序就会将引用计数减少1。结束这个动作之后，它还会检查计数是否已经减到零。如果是，那么它将释放内存。</p>
<p>在<code>Java</code>，<code>Perl</code>等高级语言中，进行内存管理时使用引用计数非常广泛。在这些语言中，引用计数由语言自动地处理，所以您根本不必担心它，除非要编写扩展模块。由于所有内容都必须进行引用计数，所以这会对速度产生一些影响，但它极大地提高了编程的安全性和方便性。</p>
<p>以下是引用计数的好处：</p>
<ul>
<li>实现简单。</li>
<li>易于使用。</li>
<li>由于引用是数据结构的一部分，所以它有一个好的缓存位置。</li>
</ul>
<p>不过，它也有其不足之处：</p>
<ul>
<li>要求您永远不要忘记调用引用计数函数。</li>
<li>无法释放作为循环数据结构的一部分的结构。</li>
<li>减缓几乎每一个指针的分配。</li>
<li>尽管所使用的对象采用了引用计数，但是当使用异常处理（比如<code>try</code>或<code>setjmp()</code>/<code>longjmp()</code>）时，您必须采取其他方法。</li>
<li>需要额外的内存来处理引用。</li>
<li>引用计数占用了结构中的第一个位置，在大部分机器中最快可以访问到的就是这个位置。</li>
<li>在多线程环境中更慢也更难以使用。</li>
</ul>
<h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>垃圾收集（Garbage collection）是全自动地检测并移除不再使用的数据对象。垃圾收集器通常会在当可用内存减少到少于一个具体的阈值时运行。通常，它们以程序所知的可用的一组“基本”数据——栈数据、全局变量、寄存器——作为出发点。然后它们尝试去追踪通过这些数据连接到每一块数据。收集器找到的都是有用的数据；它没有找到的就是垃圾，可以被销毁并重新使用这些无用的数据。为了有效地管理内存，很多类型的垃圾收集器都需要知道数据结构内部指针的规划，所以，为了正确运行垃圾收集器，它们必须是语言本身的一部分。</p>
<p>垃圾收集的一些优点：<br>-永远不必担心内存的双重释放或者对象的生命周期。<br>-使用某些收集器，您可以使用与常规分配相同的`API。</p>
<p>其缺点包括：</p>
<ul>
<li>使用大部分收集器时，您都无法干涉何时释放内存。</li>
<li>在多数情况下，垃圾收集比其他形式的内存管理更慢。</li>
<li>垃圾收集错误引发的缺陷难于调试。</li>
<li>如果您忘记将不再使用的指针设置为<code>null</code>，那么仍然会有内存泄漏。</li>
</ul>
<h3 id="内存管理器的设计目标"><a href="#内存管理器的设计目标" class="headerlink" title="内存管理器的设计目标"></a>内存管理器的设计目标</h3><p>分析内存管理算法之前，我们先看看对内存管理算法的质量需求有哪些：</p>
<ol>
<li>最大化兼容性：要实现内存管理器时，先要定义出分配器的接口函数。接口函数没有必要标新立异，而是要遵循现有标准（如<code>POSIX</code>），让使用者可以平滑的过度到新的内存管理器上。</li>
<li>最大化可移植性：通常情况下，内存管理器要向<code>OS</code>申请内存，然后进行二次分配。所以，在适当的时候要扩展内存或释放多余的内存，这要调用<code>OS</code>提供的函数才行。<code>OS</code>提供的函数则是因平台而异，尽量抽象出平台相关的代码，保证内存管理器的可移植性。</li>
<li>浪费最小的空间：内存管理器要管理内存，必然要使用自己一些数据结构，这些数据结构本身也要占内存空间。在用户眼中，这些内存空间毫无疑问是浪费掉了，如果浪费在内存管理器身的内存太多，显然是不可以接受的。内存碎片也是浪费空间的罪魁祸首，若内存管理器中有大量的内存碎片，它们是一些不连续的小块内存，它们总量可能很大，但无法使用，这也是不可以接受的。</li>
<li>最快的速度：内存分配/释放是常用的操作。按着2/8原则，常用的操作就是性能热点，热点函数的性能对系统的整体性能尤为重要。</li>
<li>最大化可调性（以适应于不同的情况）：内存管理算法设计的难点就在于要适应用不同的情况。事实上，如果缺乏应用的上下文，是无法评估内存管理算法的好坏的。可以说在任何情况下，专用算法都比通用算法在时/空性能上的表现更优。设计一套通用内存管理算法，通过一些参数对它进行配置，可以让它在特定情况也有相当出色的表现，这就是可调性。</li>
<li>最大化局部性（Locality）：大家都知道，使用<code>cache</code>可以提高程度的速度，但很多人未必知道<code>cache</code>使程序速度提高的真正原因。拿<code>CPU</code>内部的<code>cache</code>和<code>RAM</code>的访问速度相比，速度可能相差一个数量级。<br>两者的速度上的差异固然重要，但这并不是提高速度的充分条件，只是必要条件。另外一个条件是程序访问内存的局部性（Locality）。大多数情况下，程序总访问一块内存附近的内存，把附近的内存先加入到<code>cache</code>中，下次访问<code>cache</code>中的数据，速度就会提高。否则，如果程序一会儿访问这里，一会儿访问另外一块相隔十万八千里的内存，这只会使数据在内存与<code>cache</code>之间来回搬运，不但于提高速度无益，反而会大大降低程序的速度。因此，内存管理算法要考虑这一因素，减少<code>cache miss</code>和<code>page fault</code>。</li>
<li>最大化调试功能：内存管理器提供的调试功能，强大易用，特别对于嵌入式环境来说，内存错误检测工具缺乏，内存管理器提供的调试功能就更是不可或缺了。</li>
<li>最大化适应性：对于不同情况都要去调设置，无疑太麻烦，是非用户友好的。要尽量让内存管理器适用于很广的情况，只有极少情况下才去调设置。</li>
</ol>
<p>为了提高分配、释放的速度，多核计算机上，主要做的工作是避免所有核同时在竞争内存，常用的做法是内存池，简单来说就是批量申请内存，然后切割成各种长度，各种长度都有一个链表，申请、释放都只要在链表上操作，可以认为是<code>O(1)</code>的。不可能所有的长度都对应一个链表。很多内存池是假设，<code>A</code>释放掉一块内存后，<code>B</code>会申请类似大小的内存，但是<code>A</code>释放的内存跟<code>B</code>需要的内存不一定完全相等，可能有一个小的误差，如果严格按大小分配，会导致复用率很低，这样各个链表上都会有很多释放了，但是没有复用的内存，导致利用率很低。这个问题也是可以解决的，可以回收这些空闲的内存，这就是传统的内存管理，不停地对内存块作切割和合并，会导致效率低下。所以通常的做法是只分配有限种类的长度。一般的内存池只提供几十种选择。</p>
<h3 id="常见C内存管理程序"><a href="#常见C内存管理程序" class="headerlink" title="常见C内存管理程序"></a>常见C内存管理程序</h3><p>比较著名的几个<code>C</code>内存管理程序包括：</p>
<ul>
<li>Doug Lea Malloc：<ul>
<li><code>Doug Lea Malloc</code>实际上是完整的一组分配程序，其中包括<code>Doug Lea</code>的原始分配程序，<code>GNU libc</code>分配程序和<code>ptmalloc</code>。</li>
<li><code>Doug Lea</code>的分配程序加入了索引，这使得搜索速度更快，并且可以将多个没有被使用的块组合为一个大的块。</li>
<li>它还支持缓存，以便更快地再次使用最近释放的内存。</li>
<li><code>ptmalloc</code>是<code>Doug Lea Malloc</code>的一个扩展版本，支持多线程。在本文后面的部分详细分析<code>ptamlloc2</code>的源代码实现。</li>
</ul>
</li>
<li>BSD Malloc：<ul>
<li><code>BSD Malloc</code>是随4.2 BSD发行的实现，包含在<code>FreeBSD</code>之中，这个分配程序可以从预先确实大小的对象构成的池中分配对象。</li>
<li>它有一些用于对象大小的<code>size</code>类，这些对象的大小为2的若干次幂减去某一常数。所以，如果您请求给定大小的一个对象，它就简单地分配一个与之匹配的<code>size</code>类。这样就提供了一个快速的实现，但是可能会浪费内存。</li>
</ul>
</li>
<li>Hoard：<ul>
<li>编写<code>Hoard</code>的目标是使内存分配在多线程环境中进行得非常快。因此，它的构造以锁的使用为中心，从而使所有进程不必等待分配内存。它可以显著地加快那些进行很多分配和回收的多线程进程的速度。</li>
</ul>
</li>
<li>TCMalloc（Thread-Caching Malloc）：<ul>
<li>是<code>google</code>开发的开源工具──“google-perftools”中的成员。与标准的<code>Glibc</code>库的<code>malloc</code>相比，<code>TCMalloc</code>在内存的分配上效率和速度要高得多。<code>TCMalloc</code>是一种通用内存管理程序，集成了内存池和垃圾回收的优点，对于小内存，按8的整数次倍分配，对于大内存，按<code>4K</code>的整数次倍分配。这样做有两个好处：<ul>
<li>一是分配的时候比较快，那种提供几十种选择的内存池，往往要遍历一遍各种长度，才能选出合适的种类，而<code>TCMalloc</code>则可以简单地做几个运算就行了。</li>
<li>二是短期的收益比较大，分配的小内存至多浪费7个字节，大内存则4K。</li>
<li>但是长远来说，TCMalloc分配的种类还是比别的内存池要多很多的，可能会导致复用率很低。</li>
</ul>
</li>
<li><code>TCMalloc</code>还有一套高效的机制回收这些空闲的内存。当一个线程的空闲内存比较多的时候，会交还给进程，进程可以把它调配给其他线程使用；如果某种长度交还给进程后，其他线程并没有需求，进程则把这些长度合并成内存页，然后切割成其他长度。如果进程占据的资源比较多，不会交回给操作系统。周期性的内存回收，避免可能出现的内存爆炸式增长的问题。</li>
<li><code>TCMalloc</code>有比较高的空间利用率，只额外花费1%的空间。尽量避免加锁（一次加锁解锁约浪费100ns），使用更高效的<code>spinlock</code>，采用更合理的粒度。</li>
<li>小块内存和打开内存分配采取不同的策略：小于<code>32K</code>的被定义为小块内存，小块内存按大小被分为<code>8Bytes</code>，<code>16Bytes</code>，。。。，<code>236Bytes</code>进行分级。不是某个级别整数倍的大小都会被分配向上取整。如<code>13Bytes</code>的会按<code>16Bytes</code>分配，分配时，首先在本线程相应大小级别的空闲链表里面找，如果找到的话可以避免加锁操作（本线程的<code>cache</code>只有本线程自己使用）。如果找不到的话，则尝试从中心内存区的相应级别的空闲链表里搬一些对象到本线程的链表。</li>
<li>如果中心内存区相应链表也为空的话，则向中心页分配器请求内存页面，然后分割成该级别的对象存储。</li>
<li>大块内存处理方式：按页分配，每页大小是4K`，然后内存按1页，2页，……，255页的大小分类，相同大小的内存块也用链表连接。</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>策略</th>
<th>分配速度</th>
<th>回收速度</th>
<th>局部缓存</th>
<th>易用性</th>
<th>通用性</th>
<th><code>SMP</code>线程友好度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GNU Malloc</code></td>
<td>中</td>
<td>快</td>
<td>中</td>
<td>容</td>
<td>易</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td><code>Hoard</code></td>
<td>中</td>
<td>中</td>
<td>中</td>
<td>容</td>
<td>易</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td><code>TCMalloc</code></td>
<td>快</td>
<td>快</td>
<td>中</td>
<td>容</td>
<td>易</td>
<td>高</td>
<td>高</td>
</tr>
</tbody>
</table>
</div>
<p>从上表可以看出，<code>TCMalloc</code>的优势还是比较大的，<code>TCMalloc</code>的优势体现在：</p>
<ul>
<li>分配内存页的时候，直接跟<code>OS</code>打交道，而常用的内存池一般是基于别的内存管理器上分配，如果完全一样的内存管理策略，明显<code>TCMalloc</code>在性能及内存利用率上要省掉第三方内存管理的开销。</li>
<li>大部分的内存池只负责分配，不管回收。当然了，没有回收策略，也有别的方法解决问题。比如线程之间协调资源，模索模块一般是一写多读，也就是只有一个线程申请、释放内存，就不存在线程之间协调资源；为了避免某些块大量空闲，常用的做法是减少内存块的种类，提高复用率，这可能会造成内部碎片比较多，如果空闲的内存实在太多了，还可以直接重启。</li>
</ul>
<p>作为一个通用的内存管理库，<code>TCMalloc</code>也未必能超过专用的比较粗糙的内存池。比如应用中主要用到7种长度的块，专用的内存池，可以只分配这7种长度，使得没有内部碎片。或者利用统计信息设置内存池的长度，也可以使得内部碎片比较少。所以<code>TCMalloc</code>的意义在于，不需要增加任何开发代价，就能使得内存的开销比较少，而且可以从理论上证明，最优的分配不会比<code>TCMalloc</code>的分配好很多。</p>
<p>对比<code>Glibc</code>可以发现，两者的思想其实是差不多的，差别只是在细节上，细节上的差别，对工程项目来说也是很重要的，至少在性能与内存使用率上<code>TCMalloc</code>是领先很多的。 Glibc在内存回收方面做得不太好，常见的一个问题，申请很多内存，然后又释放，只是有一小块没释放，这时候<code>Glibc</code>就必须要等待这一小块也释放了，也把整个大块释放，极端情况下，可能会造成几个<code>G</code>的浪费。</p>
<h2 id="ptmalloc内存管理概述"><a href="#ptmalloc内存管理概述" class="headerlink" title="ptmalloc内存管理概述"></a>ptmalloc内存管理概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Linux</code>中<code>malloc</code>的早期版本是由<code>Doug Lea</code>实现的，它有一个重要问题就是在并行处理时多个线程共享进程的内存空间，各线程可能并发请求内存，在这种情况下应该如何保证分配和回收的正确和高效。<code>Wolfram Gloger</code>在<code>Doug Lea</code>的基础上改进使得<code>Glibc</code>的<code>malloc</code>可以支持多线程——<code>ptmalloc</code>，在<code>glibc-2.3.x</code>中已经集成了<code>ptmalloc2</code>，这就是我们平时使用的<code>malloc</code>，目前<code>ptmalloc</code>的最新版本<code>ptmalloc3</code>。<code>ptmalloc2</code>的性能略微比<code>ptmalloc3</code>要高一点点。</p>
<p><code>ptmalloc</code>实现了<code>malloc()</code>，<code>free()</code>以及一组其它的函数.以提供动态内存管理的支持。分配器处在用户程序和内核之间，它响应用户的分配请求，向操作系统申请内存，然后将其返回给用户程序，为了保持高效的分配，分配器一般都会预先分配一块大于用户请求的内存，并通过某种算法管理这块内存。来满足用户的内存分配要求，用户释放掉的内存也并不是立即就返回给操作系统，相反，分配器会管理这些被释放掉的空闲空间，以应对用户以后的内存分配要求。也就是说，分配器不但要管理已分配的内存块，还需要管理空闲的内存块，当响应用户分配要求时，分配器会首先在空闲空间中寻找一块合适的内存给用户，在空闲空间中找不到的情况下才分配一块新的内存。为实现一个高效的分配器，需要考虑很多的因素。比如，分配器本身管理内存块所占用的内存空间必须很小，分配算法必须要足够的快。</p>
<h3 id="内存管理的设计假设"><a href="#内存管理的设计假设" class="headerlink" title="内存管理的设计假设"></a>内存管理的设计假设</h3><p><code>ptmalloc</code>在设计时折中了高效率，高空间利用率，高可用性等设计目标。在其实现代码中，隐藏着内存管理中的一些设计假设，由于某些设计假设，导致了在某些情况下<code>ptmalloc</code>的行为很诡异。这些设计假设包括：</p>
<ol>
<li>具有长生命周期的大内存分配使用<code>mmap</code>。</li>
<li>特别大的内存分配总是使用<code>mmap</code>。</li>
<li>具有短生命周期的内存分配使用<code>brk</code>，因为用<code>mmap</code>映射匿名页，当发生缺页异常时，<code>linux</code>内核为缺页分配一个新物理页，并将该物理页清0，一个<code>mmap</code>的内存块需要映射多个物理页，导致多次清0操作，很浪费系统资源，所以引入了<code>mmap</code>分配阈值动态调整机制，保证在必要的情况下才使用<code>mmap</code>分配内存。</li>
<li>尽量只缓存临时使用的空闲小内存块，对大内存块或是长生命周期的大内存块在释放时都直接归还给操作系统。</li>
<li>对空闲的小内存块只会在<code>malloc</code>和<code>free</code>的时候进行合并，<code>free</code>时空闲内存块可能放入<code>pool</code>中，不一定归还给操作系统。</li>
<li>收缩堆的条件是当前<code>free</code>的块大小加上前后能合并<code>chunk</code>的大小大于<code>64KB</code>，并且堆顶的大小达到阈值，才有可能收缩堆，把堆最顶端的空闲内存返回给操作系统。</li>
<li>需要保持长期存储的程序不适合用<code>ptmalloc</code>来管理内存。</li>
<li>为了支持多线程，多个线程可以从同一个分配区（<code>arena</code>）中分配内存，<code>ptmalloc</code>假设线程<code>A</code>释放掉一块内存后，线程<code>B</code>会申请类似大小的内存，但是<code>A</code>释放的内存跟<code>B</code>需要的内存不一定完全相等，可能有一个小的误差，就需要不停地对内存块作切割和合并，这个过程中可能产生内存碎片。</li>
</ol>
<h3 id="内存管理数据结构概述"><a href="#内存管理数据结构概述" class="headerlink" title="内存管理数据结构概述"></a>内存管理数据结构概述</h3><h4 id="Main-arena与non-main-arena"><a href="#Main-arena与non-main-arena" class="headerlink" title="Main_arena与non_main_arena"></a>Main_arena与non_main_arena</h4><p>在<code>Doug Lea</code>实现的内存分配器中只有一个主分配区（main arena），每次分配内存都必须对主分配区加锁，分配完成后释放锁，在<code>SMP</code>多线程环境下，对主分配区的锁的争用很激烈，严重影响了<code>malloc</code>的分配效率。于是<code>Wolfram Gloger</code>在<code>Doug Lea</code>的基础上改进使得<code>Glibc</code>的<code>malloc</code>可以支持多线程，增加了非主分配区（non main arena）支持，主分配区与非主分配区用环形链表进行管理。每一个分配区利用互斥锁（mutex）使线程对于该分配区的访问互斥。</p>
<p>每个进程只有一个主分配区，但可能存在多个非主分配区，<code>ptmalloc</code>根据系统对分配区的争用情况动态增加非主分配区的数量，分配区的数量一旦增加，就不会再减少了。主分配区可以访问进程的<code>heap</code>区域和<code>mmap</code>映射区域，也就是说主分配区可以使用<code>sbrk</code>和<code>mmap</code>向操作系统申请虚拟内存。而非主分配区只能访问进程的<code>mmap</code>映射区域，非主分配区每次使用<code>mmap()</code>向操作系统“批发”<code>HEAP_MAX_SIZE</code>（32位系统上默认为<code>1MB</code>，64位系统默认为<code>64MB</code>）大小的虚拟内存，当用户向非主分配区请求分配内存时再切割成小块“零售”出去，毕竟系统调用是相对低效的，直接从用户空间分配内存快多了。所以<code>ptmalloc</code>在必要的情况下才会调用<code>mmap()</code>函数向操作系统申请虚拟内存。</p>
<p>主分配区可以访问<code>heap</code>区域，如果用户不调用<code>brk()</code>或是<code>sbrk()</code>函数，分配程序就可以保证分配到连续的虚拟地址空间，因为每个进程只有一个主分配区使用<code>sbrk()</code>分配<code>heap</code>区域的虚拟内存。内核对<code>brk</code>的实现可以看着是<code>mmap</code>的一个精简版，相对高效一些。如果主分配区的内存是通过<code>mmap()</code>向系统分配的，当<code>free</code>该内存时，主分配区会直接调用<code>munmap()</code>将该内存归还给系统。</p>
<p>当某一线程需要调用<code>malloc()</code>分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么<code>malloc()</code>会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。在释放操作中，线程同样试图获得待释放内存块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行释放操作。</p>
<p>申请小块内存时会产生很多内存碎片，<code>ptmalloc</code>在整理时也需要对分配区做加锁操作。每个加锁操作大概需要5～10个<code>cpu</code>指令，而且程序线程很多的情况下，锁等待的时间就会延长，导致<code>malloc</code>性能下降。一次加锁操作需要消耗<code>100ns</code>左右，正是锁的缘故，导致<code>ptmalloc</code>在多线程竞争情况下性能远远落后于<code>tcmalloc</code>。最新版的<code>ptmalloc</code>对锁进行了优化，加入了<code>PER_THREAD</code>和<code>ATOMIC_FASTBINS</code>优化，但默认编译不会启用该优化，这两个对锁的优化应该能够提升多线程内存的分配的效率。</p>
<h4 id="chunk的组织"><a href="#chunk的组织" class="headerlink" title="chunk的组织"></a>chunk的组织</h4><p>不管内存是在哪里被分配的，用什么方法分配，用户请求分配的空间在<code>ptmalloc</code>中都使用一个<code>chunk</code>来表示。用户调用<code>free()</code>函数释放掉的内存也并不是立即就归还给操作系统，相反，它们也会被表示为一个<code>chunk</code>，<code>ptmalloc</code>使用特定的数据结构来管理这些空闲的<code>chunk</code>。</p>
<h5 id="chunk格式"><a href="#chunk格式" class="headerlink" title="chunk格式"></a>chunk格式</h5><p><code>ptmalloc</code>在给用户分配的空间的前后加上了一些控制信息，用这样的方法来记录分配的信息，以便完成分配和释放工作。一个使用中的<code>chunk</code>（使用中，就是指还没有被<code>free</code>掉）在内存中的样子如图所示：<br><img src="/img/1634304883.jpg" alt=""></p>
<p>在图中，<code>chunk</code>指针指向一个<code>chunk</code>的开始，一个<code>chunk</code>中包含了用户请求的内存区域和相关的控制信息。图中的<code>mem</code>指针才是真正返回给用户的内存指针。<code>chunk</code>的第二个域的最低一位为<code>P</code>，它表示前一个块是否在使用中，<code>P</code>为0则表示前一个<code>chunk</code>为空闲，这时<code>chunk</code>的第一个域<code>prev_size</code>才有效，<code>prev_size</code>表示前一个<code>chunk</code>的<code>size</code>，程序可以使用这个值来找到前一个<code>chunk</code>的开始地址。当<code>P</code>为1时，表示前一个<code>chunk</code>正在使用中，<code>prev_size</code>无效，程序也就不可以得到前一个<code>chunk</code>的大小。不能对前一个<code>chunk</code>进行任何操作。<code>ptmalloc</code>分配的第一个块总是将<code>P</code>设为1，以防止程序引用到不存在的区域。</p>
<p><code>chunk</code>的第二个域的倒数第二个位为<code>M</code>，他表示当前<code>chunk</code>是从哪个内存区域获得的虚拟内存。<code>M</code>为1表示该<code>chunk</code>是从<code>mmap</code>映射区域分配的，否则是从<code>heap</code>区域分配的。<code>chunk</code>的第二个域倒数第三个位为<code>A</code>，表示该<code>chunk</code>属于主分配区或者非主分配区，如果属于非主分配区，将该位置为1，否则置为0。</p>
<p>空闲<code>chunk</code>在内存中的结构如图所示：<br><img src="/img/1634304988.jpg" alt=""></p>
<p>当<code>chunk</code>空闲时，其<code>M</code>状态不存在，只有<code>AP</code>状态，原本是用户数据区的地方存储了四个指针，指针<code>fd</code>指向后一个空闲的<code>chunk</code>，而<code>bk</code>指向前一个空闲的<code>chunk</code>，<code>ptmalloc</code>通过这两个指针将大小相近的<code>chunk</code>连成一个双向链表。对于<code>large bin</code>中的空闲<code>chunk</code>，还有两个指针，<code>fd_nextsize</code>和<code>bk_nextsize</code>，这两个指针用于加快在<code>large bin</code>中查找最近匹配的空闲<code>chunk</code>。不同的<code>chunk</code>链表又是通过<code>bins</code>或者<code>fastbins</code>来组织的。</p>
<h5 id="chunk中的空间复用"><a href="#chunk中的空间复用" class="headerlink" title="chunk中的空间复用"></a>chunk中的空间复用</h5><p>为了使得<code>chunk</code>所占用的空间最小，<code>ptmalloc</code>使用了空间复用，一个<code>chunk</code>或者正在被使用，或者已经被<code>free</code>掉，所以<code>chunk</code>的中的一些域可以在使用状态和空闲状态表示不同的意义，来达到空间复用的效果。以32位系统为例，空闲时，一个<code>chunk</code>中至少需要4个<code>size_t</code>（4B）大小的空间，用来存储<code>prev_size</code>，<code>size</code>，<code>fd</code>和<code>bk</code>，也就是<code>16B</code>，<code>chunk</code>的大小要对齐到8B。当一个<code>chunk</code>处于使用状态时，它的下一个<code>chunk</code>的<code>prev_size</code>域肯定是无效的。所以实际上，这个空间也可以被当前<code>chunk</code>使用。这听起来有点不可思议，但确实是合理空间复用的例子。故而实际上，一个使用中的<code>chunk</code>的大小的计算公式应该是：<code>in_use_size = (用户请求大小+ 8 - 4 ) align to 8B</code>，这里加8是因为需要存储<code>prev_size</code>和<code>size</code>，但又因为向下一个<code>chunk</code>“借”了<code>4B</code>，所以要减去4。最后，因为空闲的<code>chunk</code>和使用中的<code>chunk</code>使用的是同一块空间。所以肯定要取其中最大者作为实际的分配空间。即最终的分配空间<code>chunk_size = max(in_use_size, 16)</code>。</p>
<h4 id="空闲chunk容器"><a href="#空闲chunk容器" class="headerlink" title="空闲chunk容器"></a>空闲chunk容器</h4><h5 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h5><p>用户<code>free</code>掉的内存并不是都会马上归还给系统，<code>ptmalloc</code>会统一管理<code>heap</code>和<code>mmap</code>映射区域中的空闲的<code>chunk</code>，当用户进行下一次分配请求时，<code>ptmalloc</code>会首先试图在空闲的<code>chunk</code>中挑选一块给用户，这样就避免了频繁的系统调用，降低了内存分配的开销。 <code>ptmalloc</code>将相似大小的<code>chunk</code>用双向链表链接起来，这样的一个链表被称为一个<code>bin</code>。<code>ptmalloc</code>一共维护了128个<code>bin</code>，并使用一个数组来存储这些<code>bin</code>（如下图所示）。<br><img src="/img/1634306475.jpg" alt=""></p>
<p>数组中的第一个为<code>unsorted bin</code>，数组中从2开始编号的前64个<code>bin</code>称为<code>small bins</code>，同一个<code>small bin</code>中的<code>chunk</code>具有相同的大小。两个相邻的<code>small bin</code>中的<code>chunk</code>大小相差8bytes。</p>
<p><code>small bins</code>中的<code>chunk</code>按照最近使用顺序进行排列，最后释放的<code>chunk</code>被链接到链表的头部，而申请<code>chunk</code>是从链表尾部开始，这样，每一个<code>chunk</code>都有相同的机会被<code>ptmalloc</code>选中。<code>small bins</code>后面的<code>bin</code>被称作<code>large bins</code>。<code>large bins</code>中的每一个<code>bin</code>分别包含了一个给定范围内的<code>chunk</code>，其中的<code>chunk</code>按大小序排列。相同大小的<code>chunk</code>同样按照最近使用顺序排列。</p>
<p><code>ptmalloc</code>使用<code>smallest-first</code>，<code>best-fit</code>原则在空闲<code>large bins</code>中查找合适的<code>chunk</code>。当空闲的<code>chunk</code>被链接到<code>bin</code>中的时候，<code>ptmalloc</code>会把表示该<code>chunk</code>是否处于使用中的标志<code>P</code>设为0（注意，这个标志实际上处在下一个<code>chunk</code>中），同时<code>ptmalloc</code>还会检查它前后的<code>chunk</code>是否也是空闲的，如果是的话，<code>ptmalloc</code>会首先把它们合并为一个大的<code>chunk</code>，然后将合并后的<code>chunk</code>放到<code>unstored bin</code>中。要注意的是，并不是所有的<code>chunk</code>被释放后就立即被放到<code>bin</code>中。<code>ptmalloc</code>为了提高分配的速度，会把一些小的的<code>chunk</code>先放到一个叫做<code>fast bins</code>的容器内。</p>
<h5 id="Fast-Bins"><a href="#Fast-Bins" class="headerlink" title="Fast Bins"></a>Fast Bins</h5><p>一般的情况是，程序在运行时会经常需要申请和释放一些较小的内存空间。当分配器合并了相邻的几个小的<code>chunk</code>之后，也许马上就会有另一个小块内存的请求，这样分配器又需要从大的空闲内存中切分出一块，这样无疑是比较低效的，故而，<code>ptmalloc</code>中在分配过程中引入了<code>fast bins</code>，不大于<code>max_fast</code>（默认值为64B）的<code>chunk</code>被释放后，首先会被放到<code>fast bins</code>中，<code>fast bins</code>中的<code>chunk</code>并不改变它的使用标志<code>P</code>。这样也就无法将它们合并，当需要给用户分配的<code>chunk</code>小于或等于<code>max_fast</code>时，<code>ptmalloc</code>首先会在<code>fast bins</code>中查找相应的空闲块，然后才会去查找<code>bins</code>中的空闲<code>chunk</code>。在某个特定的时候，<code>ptmalloc</code>会遍历<code>fast bins</code>中的<code>chunk</code>，将相邻的空闲<code>chunk</code>进行合并，并将合并后的<code>chunk</code>加入<code>unsorted bin</code>中，然后再将<code>usorted bin</code>里的<code>chunk</code>加入<code>bins</code>中。</p>
<h5 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h5><p><code>unsorted bin</code>的队列使用<code>bins</code>数组的第一个，如果被用户释放的<code>chunk</code>大于<code>max_fast</code>，或者<code>fast bins</code>中的空闲<code>chunk</code>合并后，这些<code>chunk</code>首先会被放到<code>unsorted bin</code>队列中，在进行<code>malloc</code>操作的时候，如果在<code>fast bins</code>中没有找到合适的<code>chunk</code>，则<code>ptmalloc</code>会先在<code>unsorted bin</code>中查找合适的空闲<code>chunk</code>，然后才查找<code>bins</code>。如果<code>unsorted bin</code>不能满足分配要求。<code>malloc</code>便会将<code>unsorted bin</code>中的<code>chunk</code>加入<code>bins</code>中。然后再从<code>bins</code>中继续进行查找和分配过程。从这个过程可以看出来，<code>unsorted bin</code>可以看做是<code>bins</code>的一个缓冲区，增加它只是为了加快分配的速度。</p>
<h5 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h5><p>并不是所有的<code>chunk</code>都按照上面的方式来组织，实际上，有三种例外情况。<code>top chunk</code>，<code>mmaped chunk</code>和<code>last remainder</code>，下面会分别介绍这三类特殊的<code>chunk</code>。</p>
<p><code>top chunk</code>对于主分配区和非主分配区是不一样的。</p>
<p>对于非主分配区会预先从<code>mmap</code>区域分配一块较大的空闲内存模拟<code>sub-heap</code>，通过管理<code>sub-heap</code>来响应用户的需求，因为内存是按地址从低向高进行分配的，在空闲内存的最高处，必然存在着一块空闲<code>chunk</code>，叫做<code>top chunk</code>。当<code>bins</code>和<code>fast bins</code>都不能满足分配需要的时候，<code>ptmalloc</code>会设法在<code>top chunk</code>中分出一块内存给用户，如果<code>top chunk</code>本身不够大，分配程序会重新分配一个<code>sub-heap</code>，并将<code>top chunk</code>迁移到新的<code>sub-heap</code>上，新的<code>sub-heap</code>与已有的<code>sub-heap</code>用单向链表连接起来，然后在新的<code>top chunk</code>上分配所需的内存以满足分配的需要，实际上，<code>top chunk</code>在分配时总是在<code>fast bins</code>和<code>bins</code>之后被考虑，所以，不论<code>top chunk</code>有多大，它都不会被放到<code>fast bins</code>或者是<code>bins</code>中。<code>top chunk</code>的大小是随着分配和回收不停变换的，如果从<code>top chunk</code>分配内存会导致<code>top chunk</code>减小，如果回收的<code>chunk</code>恰好与<code>top chunk</code>相邻，那么这两个<code>chunk</code>就会合并成新的<code>top chunk</code>，从而使<code>top chunk</code>变大。如果在<code>free</code>时回收的内存大于某个阈值，并且<code>top chunk</code>的大小也超过了收缩阈值，<code>ptmalloc</code>会收缩<code>sub-heap</code>，如果<code>top-chunk</code>包含了整个<code>sub-heap</code>，<code>ptmalloc</code>会调用<code>munmap</code>把整个<code>sub-heap</code>的内存返回给操作系统。</p>
<p>由于主分配区是唯一能够映射进程<code>heap</code>区域的分配区，它可以通过<code>sbrk()</code>来增大或是收缩进程<code>heap</code>的大小，<code>ptmalloc</code>在开始时会预先分配一块较大的空闲内存（也就是所谓的<code>heap</code>），主分配区的<code>top chunk</code>在第一次调用<code>malloc</code>时会分配一块<code>(chunk_size + 128KB) align 4KB</code>大小的空间作为初始的<code>heap</code>，用户从<code>top chunk</code>分配内存时，可以直接取出一块内存给用户。在回收内存时，回收的内存恰好与<code>top chunk</code>相邻则合并成新的<code>top chunk</code>，当该次回收的空闲内存大小达到某个阈值，并且<code>top chunk</code>的大小也超过了收缩阈值，会执行内存收缩，减小<code>top chunk</code>的大小，但至少要保留一个页大小的空闲内存，从而把内存归还给操作系统。如果向主分配区的<code>top chunk</code>申请内存，而<code>top chunk</code>中没有空闲内存，<code>ptmalloc</code>会调用<code>sbrk()</code>将进程<code>heap</code>的边界<code>brk</code>上移，然后修改<code>top chunk</code>的大小。</p>
<h5 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h5><p>当需要分配的<code>chunk</code>足够大，而且<code>fast bins</code>和<code>bins</code>都不能满足要求，甚至<code>top chunk</code>本身也不能满足分配需求时，<code>ptmalloc</code>会使用<code>mmap</code>来直接使用内存映射来将页映射到进程空间。这样分配的<code>chunk</code>在被<code>free</code>时将直接解除映射，于是就将内存归还给了操作系统，再次对这样的内存区的引用将导致<code>segmentation fault</code>错误。这样的<code>chunk</code>也不会包含在任何<code>bin</code>中。</p>
<h5 id="Last-remainder"><a href="#Last-remainder" class="headerlink" title="Last remainder"></a>Last remainder</h5><p><code>last remainder</code>是另外一种特殊的<code>chunk</code>，就像<code>top chunk</code>和<code>mmaped chunk</code>一样，不会在任何<code>bins</code>中找到这种<code>chunk</code>。当需要分配一个<code>small chunk</code>，但在<code>small bins</code>中找不到合适的<code>chunk</code>，如果<code>last remainder chunk</code>的大小大于所需的<code>small chunk</code>大小，<code>last remainder chunk</code>被分裂成两个<code>chunk</code>，其中一个<code>chunk</code>返回给用户，另一个<code>chunk</code>变成新的<code>last remainder chuk</code>。</p>
<h4 id="sbrk与mmap"><a href="#sbrk与mmap" class="headerlink" title="sbrk与mmap"></a>sbrk与mmap</h4><p>从进程的内存布局可知，<code>.bss</code>段之上的这块分配给用户程序的空间被称为<code>heap</code>（堆）。<code>start_brk</code>指向<code>heap</code>的开始，而<code>brk</code>指向<code>heap</code>的顶部。可以使用系统调用<code>brk()</code>和<code>sbrk()</code>来增加标识<code>heap</code>顶部的<code>brk</code>值，从而线性的增加分配给用户的<code>heap</code>空间。在使<code>malloc</code>之前，<code>brk</code>的值等于<code>start_brk</code>，也就是说<code>heap</code>大小为0。<code>ptmalloc</code>在开始时，若请求的空间小于<code>mmap</code>分配阈值（<code>mmap threshold</code>，默认值为128KB）时，主分配区会调用<code>sbrk()</code>增加一块大小为<code>(128KB + chunk_size) align 4KB</code>的空间作为<code>heap</code>。非主分配区会调用<code>mmap</code>映射一块大小为<code>HEAP_MAX_SIZE</code>（32位系统上默认为<code>1MB</code>，64位系统上默认为<code>64MB</code>）的空间作为<code>sub-heap</code>。</p>
<p>这就是前面所说的<code>ptmalloc</code>所维护的分配空间，当用户请求内存分配时，首先会在这个区域内找一块合适的<code>chunk</code>给用户。当用户释放了<code>heap</code>中的<code>chunk</code>时，<code>ptmalloc</code>又会使用<code>fast bins</code>和<code>bins</code>来组织空闲<code>chunk</code>。以备用户的下一次分配。若需要分配的<code>chunk</code>大小小于<code>mmap</code>分配阈值，而<code>heap</code>空间又不够，则此时主分配区会通过<code>sbrk()</code>调用来增加<code>heap</code>大小，非主分配区会调用<code>mmap</code>映射一块新的<code>sub-heap</code>，也就是增加<code>top chunk</code>的大小，每次<code>heap</code>增加的值都会对齐到<code>4KB</code>。</p>
<p>当用户的请求超过<code>mmap</code>分配阈值，并且主分配区使用<code>sbrk()</code>分配失败的时候，或是非主分配区在<code>top chunk</code>中不能分配到需要的内存时，<code>ptmalloc</code>会尝试使用<code>mmap()</code>直接映射一块内存到进程内存空间。使用<code>mmap()</code>直接映射的<code>chunk</code>在释放时直接解除映射，而不再属于进程的内存空间。任何对该内存的访问都会产生段错误。而在<code>heap</code>中或是<code>sub-heap</code>中分配的空间则可能会留在进程内存空间内，还可以再次引用（当然是很危险的）。</p>
<p>当<code>ptmalloc munmap chunk</code>时，如果回收的<code>chunk</code>空间大小大于<code>mmap</code>分配阈值的当前值，并且小于<code>DEFAULT_MMAP_THRESHOLD_MAX</code>（32位系统默认为<code>512KB</code>，64位系统默认为32MB），<code>ptmalloc</code>会把<code>mmap</code>分配阈值调整为当前回收的<code>chunk</code>的大小，并将<code>mmap</code>收缩阈值（mmap trim threshold）设置为<code>mmap</code>分配阈值的2倍。这就是<code>ptmalloc</code>的对<code>mmap</code>分配阈值的动态调整机制，该机制是默认开启的，当然也可以用<code>mallopt()</code>关闭该机制。</p>
<h3 id="内存分配概述"><a href="#内存分配概述" class="headerlink" title="内存分配概述"></a>内存分配概述</h3><h4 id="分配算法概述"><a href="#分配算法概述" class="headerlink" title="分配算法概述"></a>分配算法概述</h4><p>以32系统为例，64位系统类似。</p>
<ul>
<li>小于等于64字节：用<code>pool</code>算法分配。</li>
<li>64到512字节之间：在最佳匹配算法分配和<code>pool</code>算法分配中取一种合适的。</li>
<li>大于等于512字节：用最佳匹配算法分配。</li>
<li>大于等于<code>mmap</code>分配阈值（默认值128KB）：根据设置的<code>mmap</code>的分配策略进行分配，如果没有开启<code>mmap</code>分配阈值的动态调整机制，大于等于<code>128KB</code>就直接调用<code>mmap</code>分配。否则，大于等于<code>mmap</code>分配阈值时才直接调用<code>mmap()</code>分配。</li>
</ul>
<p>ptmalloc的响应用户内存分配要求的具体步骤为:</p>
<ol>
<li>获取分配区的锁，为了防止多个线程同时访问同一个分配区，在进行分配之前需要取得分配区域的锁。线程先查看线程私有实例中是否已经存在一个分配区，如果存在尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，否则，该线程搜索分配区循环链表试图获得一个空闲（没有加锁）的分配区。如果所有的分配区都已经加锁，那么<code>ptmalloc</code>会开辟一个新的分配区，把该分配区加入到全局分配区循环链表和线程的私有实例中并加锁，然后使用该分配区进行分配操作。开辟出来的新分配区一定为非主分配区，因为主分配区是从父进程那里继承来的。开辟非主分配区时会调用<code>mmap()</code>创建一个<code>sub-heap</code>，并设置好<code>top chunk</code>。</li>
<li>将用户的请求大小转换为实际需要分配的<code>chunk</code>空间大小。</li>
<li>判断所需分配<code>chunk</code>的大小是否满足<code>chunk_size &lt;= max_fast</code> (<code>max_fast</code>默认为64B)，如果是的话，则转下一步，否则跳到第5步。</li>
<li>首先尝试在<code>fast bins</code>中取一个所需大小的<code>chunk</code>分配给用户。如果可以找到，则分配结束。否则转到下一步。</li>
<li>判断所需大小是否处在<code>small bins</code>中，即判断<code>chunk_size &lt; 512B</code>是否成立。如果<code>chunk</code>大小处在<code>small bins</code>中，则转下一步，否则转到第6步。</li>
<li>根据所需分配的<code>chunk</code>的大小，找到具体所在的某个<code>small bin</code>，从该<code>bin</code>的尾部摘取一个恰好满足大小的<code>chunk</code>。若成功，则分配结束，否则，转到下一步。</li>
<li>到了这一步，说明需要分配的是一块大的内存，或者<code>small bins</code>中找不到合适的<code>chunk</code>。于是，<code>ptmalloc</code>首先会遍历<code>fast bins</code>中的<code>chunk</code>，将相邻的<code>chunk</code>进行合并，并链接到<code>unsorted bin</code>中，然后遍历<code>unsorted bin</code>中的<code>chunk</code>，如果<code>unsorted bin</code>只有一个<code>chunk</code>，并且这个<code>chunk</code>在上次分配时被使用过，并且所需分配的<code>chunk</code>大小属于<code>small bins</code>，并且<code>chunk</code>的大小大于等于需要分配的大小，这种情况下就直接将该<code>chunk</code>进行切割，分配结束，否则将根据<code>chunk</code>的空间大小将其放入<code>small bins</code>或是<code>large bins</code>中，遍历完成后，转入下一步。</li>
<li>到了这一步，说明需要分配的是一块大的内存，或者<code>small bins</code>和<code>unsorted bin</code>中都找不到合适的<code>chunk</code>，并且<code>fast bins</code>和<code>unsorted bin</code>中所有的<code>chunk</code>都清除干净了。从<code>large bins</code>中按照<code>smallest-first</code>，<code>best-fit</code>原则，找一个合适的<code>chunk</code>，从中划分一块所需大小的<code>chunk</code>，并将剩下的部分链接回到<code>bins</code>中。若操作成功，则分配结束，否则转到下一步。</li>
<li>如果搜索<code>fast bins</code>和<code>bins</code>都没有找到合适的<code>chunk</code>，那么就需要操作<code>top chunk</code>来进行分配了。判断<code>top chunk</code>大小是否满足所需<code>chunk</code>的大小，如果是，则从<code>top chunk</code>中分出一块来。否则转到下一步。</li>
<li>到了这一步，说明<code>top chunk</code>也不能满足分配要求，所以，于是就有了两个选择:如果是主分配区，调用<code>sbrk()</code>，增加<code>top chunk</code>大小；如果是非主分配区，调用<code>mmap</code>来分配一个新的<code>sub-heap</code>，增加<code>top chunk</code>大小；或者使用<code>mmap()</code>来直接分配。在这里，需要依靠<code>chunk</code>的大小来决定到底使用哪种方法。判断所需分配的<code>chunk</code>大小是否大于等于<code>mmap</code>分配阈值，如果是的话，则转下一步，调用<code>mmap</code>分配，否则跳到第12步，增加<code>top chunk</code>的大小。</li>
<li>使用<code>mmap</code>系统调用为程序的内存空间映射一块<code>chunk_size align 4kB</code>大小的空间。然后将内存指针返回给用户。</li>
<li>判断是否为第一次调用<code>malloc</code>，若是主分配区，则需要进行一次初始化工作，分配一块大小为<code>(chunk_size + 128KB) align 4KB</code>大小的空间作为初始的<code>heap</code>。若已经初始化过了，主分配区则调用<code>sbrk()</code>增加<code>heap</code>空间，非主分配区则在<code>top chunk</code>中切割出一个<code>chunk</code>，使之满足分配需求，并将内存指针返回给用户。</li>
</ol>
<p>总结一下：根据用户请求分配的内存的大小，<code>ptmalloc</code>有可能会在两个地方为用户分配内存空间。在第一次分配内存时，一般情况下只存在一个主分配区，但也有可能从父进程那里继承来了多个非主分配区，在这里主要讨论主分配区的情况，<code>brk</code>值等于<code>start_brk</code>，所以实际上<code>heap</code>大小为0，<code>top chunk</code>大小也是0。这时，如果不增加<code>heap</code>大小，就不能满足任何分配要求。所以，若用户的请求的内存大小小于<code>mmap</code>分配阈值，则<code>ptmalloc</code>会初始<code>heap</code>。然后在<code>heap</code>中分配空间给用户，以后的分配就基于这个<code>heap</code>进行。若第一次用户的请求就大于<code>mmap</code>分配阈值，则<code>ptmalloc</code>直接使用<code>mmap()</code>分配一块内存给用户，而<code>heap</code>也就没有被初始化，直到用户第一次请求小于<code>mmap</code>分配阈值的内存分配。</p>
<p>第一次以后的分配就比较复杂了，简单说来，<code>ptmalloc</code>首先会查找<code>fast bins</code>，如果不能找到匹配的<code>chunk</code>，则查找<code>small bins</code>。若还是不行，合并<code>fast bins</code>，把<code>chunk</code>加入<code>unsorted bin</code>，在<code>unsorted bin</code>中查找，若还是不行，把<code>unsorted bin</code>中的<code>chunk</code>全加入<code>large bins</code>中，并查找<code>large bins</code>。在<code>fast bins</code>和<code>small bins</code>中的查找都需要精确匹配，而在<code>large bins</code>中查找时，则遵循<code>smallest-first</code>，<code>best-fit</code>的原则，不需要精确匹配。</p>
<p>若以上方法都失败了，则<code>ptmalloc</code>会考虑使用<code>top chunk</code>。若<code>top chunk</code>也不能满足分配要求。而且所需<code>chunk</code>大小大于<code>mmap</code>分配阈值，则使用<code>mmap</code>进行分配。否则增加<code>heap</code>，增大<code>top chunk</code>。以满足分配要求。</p>
<h3 id="内存回收概述"><a href="#内存回收概述" class="headerlink" title="内存回收概述"></a>内存回收概述</h3><p><code>free()</code>函数接受一个指向分配区域的指针作为参数，释放该指针所指向的<code>chunk</code>。而具体的释放方法则看该<code>chunk</code>所处的位置和该<code>chunk</code>的大小。<code>free()</code>函数的工作步骤如下：</p>
<ol>
<li><code>free()</code>函数同样首先需要获取分配区的锁，来保证线程安全。</li>
<li>判断传入的指针是否为0，如果为0，则什么都不做，直接<code>return</code>。否则转下一步。</li>
<li>判断所需释放的<code>chunk</code>是否为<code>mmaped chunk</code>，如果是，则调用<code>munmap()</code>释放<code>mmaped chunk</code>，解除内存空间映射，该该空间不再有效。如果开启了<code>mmap</code>分配阈值的动态调整机制，并且当前回收的<code>chunk</code>大小大于<code>mmap</code>分配阈值，将<code>mmap</code>分配阈值设置为该<code>chunk</code>的大小，将<code>mmap</code>收缩阈值设定为<code>mmap</code>分配阈值的2倍，释放完成，否则跳到下一步。</li>
<li>判断<code>chunk</code>的大小和所处的位置，若<code>chunk_size &lt;= max_fast</code>，并且<code>chunk</code>并不位于<code>heap</code>的顶部，也就是说并不与<code>top chunk</code>相邻，则转到下一步，否则跳到第6步。（因为与<code>top chunk</code>相邻的小<code>chunk</code>也和<code>top chunk</code>进行合并，所以这里不仅需要判断大小，还需要判断相邻情况）</li>
<li>将<code>chunk</code>放到<code>fast bins</code>中，<code>chunk</code>放入到<code>fast bins</code>中时，并不修改该<code>chunk</code>使用状态位<code>P</code>。也不与相邻的<code>chunk</code>进行合并。只是放进去，如此而已。这一步做完之后释放便结束了，程序从<code>free()</code>函数中返回。</li>
<li>判断前一个<code>chunk</code>是否处在使用中，如果前一个块也是空闲块，则合并。并转下一步。</li>
<li>判断当前释放<code>chunk</code>的下一个块是否为<code>top chunk</code>，如果是，则转第9步，否则转下一步。</li>
<li>判断下一个<code>chunk</code>是否处在使用中，如果下一个<code>chunk</code>也是空闲的，则合并，并将合并后的<code>chunk</code>放到<code>unsorted bin</code>中。注意，这里在合并的过程中，要更新<code>chunk</code>的大小，以反映合并后的<code>chunk</code>的大小。并转到第10步。</li>
<li>如果执行到这一步，说明释放了一个与<code>top chunk</code>相邻的<code>chunk</code>。则无论它有多大，都将它与<code>top chunk</code>合并，并更新<code>top chunk</code>的大小等信息。转下一步。</li>
<li>判断合并后的<code>chunk</code>的大小是否大于<code>FASTBIN_CONSOLIDATION_THRESHOLD</code>（默认64KB），如果是的话，则会触发进行<code>fast bins</code>的合并操作，<code>fast bins</code>中的<code>chunk</code>将被遍历，并与相邻的空闲<code>chunk</code>进行合并，合并后的<code>chunk</code>会被放到<code>unsorted bin</code>中。<code>fast bins</code>将变为空，操作完成之后转下一步。</li>
<li>判断<code>top chunk</code>的大小是否大于<code>mmap</code>收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还<code>top chunk</code>中的一部分给操作系统。但是最先分配的<code>128KB</code>空间是不会归还的，<code>ptmalloc</code>会一直管理这部分内存，用于响应用户的分配请求；<ol>
<li>如果为非主分配区，会进行<code>sub-heap</code>收缩，将<code>top chunk</code>的一部分返回给操作系统，</li>
<li>如果<code>top chunk</code>为整个<code>sub-heap</code>，会把整个<code>sub-heap</code>还回给操作系统。</li>
<li>做完这一步之后，释放结束，从<code>free()</code>函数退出。可以看出，收缩堆的条件是当前<code>free</code>的<code>chunk</code>大小加上前后能合并<code>chunk</code>的大小大于<code>64k</code>，并且要<code>top chunk</code>的大小要达到<code>mmap</code>收缩阈值，才有可能收缩堆。</li>
</ol>
</li>
</ol>
<h3 id="配置选项概述"><a href="#配置选项概述" class="headerlink" title="配置选项概述"></a>配置选项概述</h3><p><code>ptmalloc</code>主要提供以下几个配置选项用于调优，这些选项可以通过<code>mallopt()</code>进行设置：</p>
<p><code>M_MXFAST</code>用于设置<code>fast bins</code>中保存的<code>chunk</code>的最大大小，默认值为<code>64B</code>，<code>fast bins</code>中保存的<code>chunk</code>在一段时间内不会被合并，分配小对象时可以首先查找<code>fast bins</code>，如果<code>fast bins</code>找到了所需大小的<code>chunk</code>，就直接返回该<code>chunk</code>，大大提高小对象的分配速度，但这个值设置得过大，会导致大量内存碎片，并且会导致<code>ptmalloc</code>缓存了大量空闲内存，去不能归还给操作系统，导致内存暴增。</p>
<p><code>M_MXFAST</code>的最大值为<code>80B</code>，不能设置比80B更大的值，因为设置为更大的值并不能提高分配的速度。<code>fast bins</code>是为需要分配许多小对象的程序设计的，比如需要分配许多小<code>struct</code>，小对象，小的<code>string</code>等等。</p>
<p>如果设置该选项为0，就会不使用<code>fast bins</code>。</p>
<p><code>M_TRIM_THRESHOLD</code>用于设置<code>mmap</code>收缩阈值，默认值为<code>128KB</code>。自动收缩只会在<code>free</code>时才发生，如果当前<code>free</code>的<code>chunk</code>大小加上前后能合并<code>chunk</code>的大小大于<code>64KB</code>，并且<code>top chunk</code>的大小达到<code>mmap</code>收缩阈值，对于主分配区，调用<code>malloc_trim()</code>返回一部分内存给操作系统，对于非主分配区，调用<code>heap_trim()</code>返回一部分内存给操作系统，在发生内存收缩时，还是从新设置<code>mmap</code>分配阈值和<code>mmap</code>收缩阈值。</p>
<p>这个选项一般与<code>M_MMAP_THRESHOLD</code>选项一起使用，<code>M_MMAP_THRESHOLD</code>用于设置<code>mmap</code>分配阈值，对于长时间运行的程序，需要对这两个选项进行调优，尽量保证在<code>ptmalloc</code>中缓存的空闲<code>chunk</code>能够得到重用，尽量少用<code>mmap</code>分配临时用的内存。不停地使用系统调用<code>mmap</code>分配内存，然后很快又<code>free</code>掉该内存，这样是很浪费系统资源的，并且这样分配的内存的速度比从<code>ptmalloc</code>的空闲<code>chunk</code>中分配内存慢得多，由于需要页对齐导致空间利用率降低，并且操作系统调用<code>mmap()</code>分配内存是串行的，在发生缺页异常时加载新的物理页，需要对新的物理页做清0操作，大大影响效率。</p>
<p><code>M_TRIM_THRESHOLD</code>的值必须设置为页大小对齐，设置为-1会关闭内存收缩设置。</p>
<p>注意：试图在程序开始运行时分配一块大内存，并马上释放掉，以期望来触发内存收缩，这是不可能的，因为该内存马上就返回给操作系统了。</p>
<p><code>M_MMAP_THRESHOLD</code>用于设置<code>mmap</code>分配阈值，默认值为<code>128KB</code>，<code>ptmalloc</code>默认开启动态调整<code>mmap</code>分配阈值和<code>mmap</code>收缩阈值。当用户需要分配的内存大于<code>mmap</code>分配阈值，<code>ptmalloc</code>的<code>malloc()</code>函数其实相当于<code>mmap()</code>的简单封装，<code>free</code>函数相当于<code>munmap()</code>的简单封装。相当于直接通过系统调用分配内存，回收的内存就直接返回给操作系统了。因为这些大块内存不能被<code>ptmalloc</code>缓存管理，不能重用，所以<code>ptmalloc</code>也只有在万不得已的情况下才使用该方式分配内存。</p>
<p>但使用<code>mmap</code>分配有如下的好处：</p>
<ul>
<li><code>mmap</code>的空间可以独立从系统中分配和释放的系统，对于长时间运行的程序，申请长生命周期的大内存块就很适合有这种方式。</li>
<li><code>mmap</code>的空间不会被<code>ptmalloc</code>锁在缓存的<code>chunk</code>中，不会导致<code>ptmalloc</code>内存暴增的问题。</li>
<li>对有些系统的虚拟地址空间存在洞，只能用<code>mmap()</code>进行分配内存，<code>sbrk()</code>不能运行。</li>
</ul>
<p>使用<code>mmap</code>分配内存的缺点：</p>
<ul>
<li>该内存不能被<code>ptmalloc</code>回收再利用。</li>
<li>会导致更多的内存浪费，因为<code>mmap</code>需要按页对齐。</li>
<li>它的分配效率跟操作系统提供的<code>mmap()</code>函数的效率密切相关，<code>Linux</code>系统强制把匿名<code>mmap</code>的内存物理页清0是很低效的。</li>
</ul>
<p>所以用<code>mmap</code>来分配长生命周期的大内存块就是最好的选择，其他情况下都不太高效。</p>
<p><code>M_MMAP_MAX</code>用于设置进程中用<code>mmap</code>分配的内存块的最大限制，默认值为<code>64K</code>，因为有些系统用<code>mmap</code>分配的内存块太多会导致系统的性能下降。如果将<code>M_MMAP_MAX</code>设置为0，<code>ptmalloc</code>将不会使用<code>mmap</code>分配大块内存。<code>ptmalloc</code>为优化锁的竞争开销，做了<code>PER_THREAD</code>的优化，也提供了两个选项，<code>M_ARENA_TEST</code>和<code>M_ARENA_MAX</code>，由于<code>PER_THREAD</code>的优化默认没有开启，这里暂不对这两个选项做介绍。</p>
<p>另外，<code>ptmalloc</code>没有提供关闭<code>mmap</code>分配阈值动态调整机制的选项，<code>mmap</code>分配阈值动态调整时默认开启的，如果要关闭<code>mmap</code>分配阈值动态调整机制，可以设置<code>M_TRIM_THRESHOLD</code>，<code>M_MMAP_THRESHOLD</code>，<code>M_TOP_PAD</code>和<code>M_MMAP_MAX</code>中的任意一个。</p>
<p>但是强烈建议不要关闭该机制，该机制保证了<code>ptmalloc</code>尽量重用缓存中的空闲内存，不用每次对相对大一些的内存使用系统调用<code>mmap</code>去分配内存。</p>
<h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><p>为了避免<code>Glibc</code>内存暴增，使用时需要注意以下几点：</p>
<ol>
<li>后分配的内存先释放，因为<code>ptmalloc</code>收缩内存是从<code>top chunk</code>开始，如果与<code>top chunk</code>相邻的<code>chunk</code>不能释放，<code>top chunk</code>以下的<code>chunk</code>都无法释放。</li>
<li><code>ptmalloc</code>不适合用于管理长生命周期的内存，特别是持续不定期分配和释放长生命周期的内存，这将导致<code>ptmalloc</code>内存暴增。如果要用<code>ptmalloc</code>分配长周期内存，在32位系统上，分配的内存块最好大于<code>1MB</code>，64位系统上，分配的内存块大小大于32MB。这是由于<code>ptmalloc</code>默认开启<code>mmap</code>分配阈值动态调整功能，<code>1MB</code>是32位系统<code>mmap</code>分配阈值的最大值，32MB是64位系统<code>mmap</code>分配阈值的最大值，这样可以保证<code>ptmalloc</code>分配的内存一定是从<code>mmap</code>映射区域分配的，当<code>free</code>时，<code>ptmalloc</code>会直接把该内存返回给操作系统，避免了被<code>ptmalloc</code>缓存。</li>
<li>不要关闭<code>ptmalloc</code>的<code>mmap</code>分配阈值动态调整机制，因为这种机制保证了短生命周期的内存分配尽量从<code>ptmalloc</code>缓存的内存<code>chunk</code>中分配，更高效，浪费更少的内存。如果关闭了该机制，对大于<code>128KB</code>的内存分配就会使用系统调用<code>mmap</code>向操作系统分配内存，使用系统调用分配内存一般会比从<code>ptmalloc</code>缓存的<code>chunk</code>中分配内存慢，特别是在多线程同时分配大内存块时，操作系统会串行调用<code>mmap()</code>，并为发生缺页异常的页加载新物理页时，默认强制清0。频繁使用<code>mmap</code>向操作系统分配内存是相当低效的。使用<code>mmap</code>分配的内存只适合长生命周期的大内存块。</li>
<li>多线程分阶段执行的程序不适合用<code>ptmalloc</code>，这种程序的内存更适合用内存池管理，就像<code>Appach</code>那样，每个连接请求处理分为多个阶段，每个阶段都有自己的内存池，每个阶段完成后，将相关的内存就返回给相关的内存池。<code>ptmalloc</code>假设了线程<code>A</code>释放的内存块能在线程<code>B</code>中得到重用，但<code>B</code>不一定会分配和<code>A</code>线程同样大小的内存块，于是就需要不断地做切割和合并，可能导致内存碎片。</li>
<li>尽量减少程序的线程数量和避免频繁分配/释放内存，<code>ptmalloc</code>在多线程竞争激烈的情况下，首先查看线程私有变量是否存在分配区，如果存在则尝试加锁，如果加锁不成功会尝试其它分配区，如果所有的分配区的锁都被占用着，就会增加一个非主分配区供当前线程使用。由于在多个线程的私有变量中可能会保存同一个分配区，所以当线程较多时，加锁的代价就会上升，<code>ptmalloc</code>分配和回收内存都要对分配区加锁，从而导致了多线程<br>竞争环境下<code>ptmalloc</code>的效率降低。</li>
<li>防止内存泄露，<code>ptmalloc</code>对内存泄露是相当敏感的，根据它的内存收缩机制，如果与<code>top chunk</code>相邻的那个<code>chunk</code>没有回收，将导致<code>top chunk</code>一下很多的空闲内存都无法返回给操作系统。</li>
<li>防止程序分配过多内存，或是由于<code>Glibc</code>内存暴增，导致系统内存耗尽，程序因<code>OOM</code>被系统杀掉。预估程序可以使用的最大物理内存大小，配置系统的<code>/proc/sys/vm/overcommit_memory</code>，<code>/proc/sys/vm/overcommit_ratio</code>，以及使用<code>ulimt –v</code>限制程序能使用虚拟内存空间大小，防止程序因<code>OOM</code>被杀掉。</li>
</ol>
<h1 id="问题分析及解决"><a href="#问题分析及解决" class="headerlink" title="问题分析及解决"></a>问题分析及解决</h1><p>通过前面几节对<code>ptmalloc</code>实现的粗略分析，尝试去分析和解决我们遇到的问题，我们系统遇到的问题是<code>glibc</code>内存暴增，现象是程序已经把内存返回给了<code>Glibc</code>库，但<code>Glibc</code>库却没有把内存归还给操作系统，最终导致系统内存耗尽，程序因为<code>OOM</code>被系统杀掉。原因有如下几点：</p>
<ol>
<li>在64位系统上使用默认的系统配置，也就是说<code>ptmalloc</code>的<code>mmap</code>分配阈值动态调整机制是开启的。我们的<code>NoSql</code>系统经常分配内存为<code>2MB</code>，并且这2MB的内存很快会被释放，在<code>ptmalloc</code>回收2MB内存时，<code>ptmalloc</code>的动态调整机制会认为2MB对我们的系统来说是一个临时的内存分配，每次都用系统调用<code>mmap()</code>向操作系统分配内存，<code>ptmalloc</code>认为这太低效了，于是把<code>mmap</code>的阈值设置成了2MB+4K<code>，当下次再分配2MB的内存时，
尽量从</code>ptmalloc<code>缓存的</code>chunk<code>中分配，缓存的</code>chunk<code>不能满足要求，才考虑调用</code>mmap()`进行分配，提高分配的效率。</li>
<li>系统中分配2M内存的地方主要有两处，一处是全局的内存<code>cache</code>，另一处是网络模块，网络模块每次分配2MB内存用于处理网络的请求，处理完成后就释放该内存。这可以看成是一个短生命周期的内存。内存<code>cache</code>每次分配<code>2MB</code>，但不确定什么时候释放，也不确定下次会什么时候会再分配2MB内存，但有一点可以确定，每次分配的2MB内存，要经过比较长的一段时间才会释放，所以可以看成是长生命周期的内存块，对于这些<code>cache</code>中的多个2M内存块没有使用<code>free list</code>管理，每次都是先从<code>cache</code>中<code>free</code>调用一个2M内存块，再从<code>Glibc</code>中分配一块新的2M内存块。 <code>ptmalloc</code>不擅长管理长生命周期的内存块，<code>ptmalloc</code>设计的假设中就明确假设缓存的内存块都用于短生命周期的内存分配，因为<code>ptmalloc</code>的内存收缩是从<code>top chunk</code>开始，如果与<code>top chunk</code>相邻的那个<code>chunk</code>在我们<code>NoSql</code>的内存池中没有释放，<code>top chunk</code>以下的空闲内存都无法返回给系统，即使这些空闲内存有几十个<code>G</code>也不行。</li>
<li><code>Glibc</code>内存暴增的问题我们定位为全局内存池中的内存块长时间没有释放，其中还有一个原因就是全局内存池会不定期的分配内存，可能下次分配的内存是在<code>top chunk</code>分配的，分配以后又短时间不释放，导致<code>top chunk</code>升到了一个更高的虚拟地址空间，从而使<code>ptmalloc</code>中缓存的内存块更多，但无法返回给操作系统。</li>
<li>另一个原因就是进程的线程数越多，在高压力高并发环境下，频繁分配和释放内存，由于分配内存时锁争用更激烈，<code>ptmalloc</code>会为进程创建更多的分配区，由于我们的全局内存池的长时间不释放内存的缘故，会导致<code>ptmalloc</code>缓存的<code>chunk</code>数量增长得更快，从而更容易重现<code>Glibc</code>内存暴增的问题。</li>
<li>内存池管理内存的方式导致<code>Glibc</code>大量的内存碎片。我们的内存池对于小于等于64K的内存分配，则从内存池中分配64K的内存块，如果内存池中没有，则调用<code>malloc()</code>分配64K的内存块，释放时，该64K的内存块加入内存中，永不还回给操作系统，对于大于64K的内存分配，调用<code>malloc()</code>分配，释放时调用<code>free()</code>函数换回给Glibc。这些大量的64K的内存块长时间存在于内存池中，导致了<code>Glibc</code>中缓存了大量的内存碎片不能释放回<br>操作系统。</li>
</ol>
<p>比如：假如应用层分配内存的顺序是<code>64K</code>，<code>100K</code>，<code>64K</code>，然后释放100K的内存块，Glibc会缓存这个100K的内存块，其中的两个64K内存块都在<code>mempool</code>中，一直不释放，如果下次再分配64K的内存，就会将100K的内存块拆分成64K和36K的两个内存块，64K的内存块返回给应用层，并被<code>mempool</code>缓存，但剩下的36K被<code>Glibc</code>缓存，再也不能被应用层分配了，因为应用层分配的最小内存为64K`，这个36K的内存块就是内存碎片，这也是内存暴增的原因之一。</p>
<p>问题找到了，解决的办法可以参考如下几种:</p>
<ol>
<li>禁用<code>ptmalloc</code>的<code>mmap</code>分配阈值动态调整机制。通过<code>mallopt()</code>设置<code>M_TRIM_THRESHOLD</code>，<code>M_MMAP_THRESHOLD</code>，<code>M_TOP_PAD</code>和<code>M_MMAP_MAX</code>中任意一个，关闭<code>mmap</code>分配阈值动态调整机制，同时需要将<code>mmap</code>分配阈值设置为<code>64K</code>，大于64K的内存分配都使用<code>mmap</code>向系统分配，释放大于64K的内存将调用<code>munmap</code>释放回系统。但强烈建议不要这么做，这会大大降低<code>ptmalloc</code>的分配释放效率。因为系统调用<code>mmap</code>是串行的，操作系统需要对<code>mmap</code>分配内存加锁，而且操作系统对<code>mmap</code>的物理页强制清0很慢。</li>
<li>我们系统的关键问题出在全局内存池，它分配的内存是长生命周期的大内存块，通过前面的分析可知，对长生命周期的大内存块分配最好用<code>mmap</code>系统调用直接向操作系统分配，回收时用<code>munmap</code>返回给操作系统。比如内存池每次用<code>mmap</code>向操作系统分配8M或是更多的虚拟内存。如果非要用<code>ptmalloc</code>的<code>malloc</code>函数分配内存，就得绕过<code>ptmalloc</code>的<code>mmap</code>分配阈值动态调整机制，<code>mmap</code>分配阈值在64位系统上的最大值为<code>32M</code>，如果分配的内存大于<code>32M</code>，可以保证<code>malloc</code>分配的内存肯定是用<code>mmap</code>向操作系统分配的，回收时<code>free</code>一定会返回给操作系统，而不会被<code>ptmalloc</code>缓存用于下一次分配。但是如果这样使用<code>malloc</code>分配的话，其实<code>malloc</code>就是<code>mmap</code>的简单封装，还不如直接使用<code>mmap</code>系统调用想操作系统分配内存来得简单，并且显式调用<code>munmap</code>回收分配的内存，根本不依赖<code>ptmalloc</code>的实现。</li>
<li>改写内存<code>cache</code>，使用<code>free list</code>管理所分配的内存块。使用预分配优化已有的代码，尽量在每个请求过程中少分配内存。并使用线程私有内存块来存放线程所使用的私有实例。这种解决办法也是暂时的。</li>
<li>从长远的设计来看，我们的系统也是分阶段执行的，每次网络请求都会分配2MB为单位内存，请求完成后释放请求锁分配的内存，内存池最适合这种情景的操作。我们的线程池至少需要包含对2MB和几种系统中常用分配大小的支持，采用与<code>TCMalloc</code>类似的无锁设计，使用线程私用变量的形式尽量减少分配时线程对锁的争用。或者直接使用<code>TCMalloc</code>，免去了很多的线程池设计考虑。</li>
</ol>
<h1 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h1><p>本部分主要对源代码实现技巧的细节做分析，希望能进一步理解<code>ptmalloc</code>的实现，做到终极无惑。主要分析的文件包括<code>arena.c</code>和<code>malloc.c</code>，这两个文件包括了<code>ptmalloc</code>的核心实现，其中<code>arena.c</code>主要是对多线程支持的实现，<code>malloc.c</code>定义了公用的<code>malloc()</code>，<code>free()</code>等函数，实现了基于分配区的内存管理算法。</p>
<h2 id="边界标记法"><a href="#边界标记法" class="headerlink" title="边界标记法"></a>边界标记法</h2><p><code>ptmalloc</code>使用<code>chunk</code>实现内存管理，对<code>chunk</code>的管理基于独特的边界标记法。</p>
<p>在不同的平台下，每个<code>chunk</code>的最小大小，地址对齐方式是不同的，<code>ptmalloc</code>依赖平台定义的<code>size_t</code>长度，对于32位平台，<code>size_t</code>长度为4字节，对64位平台，<code>size_t</code>长度可能为4字节，也可能为8字节，在<code>Linux X86_64</code>上<code>size_t</code>为8字节，这里就以<code>size_t</code>为4字节和8字节的情况进行分析。先看一段源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding word size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_SZ (sizeof(INTERNAL_SIZE_T))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MALLOC_ALIGNMENT is the minimum alignment for malloc&#x27;ed chunks.</span></span><br><span class="line"><span class="comment">It must be a power of two at least 2 * SIZE_SZ, even on machines</span></span><br><span class="line"><span class="comment">for which smaller alignments would suffice. It may be defined as</span></span><br><span class="line"><span class="comment">larger than this though. Note however that code and data structures</span></span><br><span class="line"><span class="comment">are optimized for the case of 8-byte alignment.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* The corresponding bit mask value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure>
<p><code>ptmalloc</code>使用宏来屏蔽不同平台的差异，将<code>INTERNAL_SIZE_T</code>定义为<code>size_t</code>，<code>SIZE_SZ</code>定义为<code>size_t</code>的大小，在32位平台下位4字节，在64位平台下位4字节或者8字节。另外分配<code>chunk</code>时必须以<code>2*SIZE_SZ</code>对齐，<code>MALLOC_ALIGNMENT</code>和<code>MALLOC_ALIGN_MASK</code>是用来处理<code>chunk</code>地址对齐的宏。在32平台<code>chunk</code>地址按8字节对齐，64位平台按8字节或是16字节对齐。</p>
<p><code>ptmalloc</code>采用边界标记法将内存划分成很多块，从而对内存的分配与回收进行管理。在<code>ptmalloc</code>的实现源码中定义结构体<code>malloc_chunk</code>来描述这些块，并使用宏封装了对<code>chunk</code>中每个域的读取，修改，校验，遍历等等。<code>malloc_chunk</code>定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">    INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free). */</span></span><br><span class="line">    INTERNAL_SIZE_T size; <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only used for large blocks: pointer to next larger size. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>chunk</code>的定义相当简单明了，对各个域做一下简单介绍:</p>
<ul>
<li><code>prev_size</code>:如果前一个<code>chunk</code>是空闲的，该域表示前一个<code>chunk</code>的大小，如果前一个<code>chunk</code>不空闲，该域无意义。</li>
<li><code>size</code>：当前<code>chunk</code>的大小，并且记录了当前<code>chunk</code>和前一个<code>chunk</code>的一些属性，包括前一个<code>chunk</code>是否在使用中，当前<code>chunk</code>是否是通过<code>mmap</code>获得的内存，当前<code>chunk</code>是否属于非主分配区。</li>
<li><code>fd</code>和<code>bk</code>：指针<code>fd</code>和<code>bk</code>只有当该<code>chunk</code>块空闲时才存在，其作用是用于将对应的空闲<code>chunk</code>块加入到空闲<code>chunk</code>块链表中统一管理，如果该<code>chunk</code>块被分配给应用程序使用，那么这两个指针也就没有用（该<code>chunk</code>块已经从空闲链中拆出）了，所以也当作应用程序的使用空间，而不至于浪费。</li>
<li><code>fd_nextsize</code>和<code>bk_nextsize</code>:当当前的<code>chunk</code>存在于<code>large bins</code>中时，<code>large bins</code>中的空闲<code>chunk</code>是按照大小排序的，但同一个大小的<code>chunk</code>可能有多个，增加了这两个字段可以加快遍历空闲<code>chunk</code>，并查找满足需要的空闲<code>chunk</code>，<code>fd_nextsize</code>指向下一个比当前<code>chunk</code>大小大的第一个空闲<code>chunk</code>，<code>bk_nextszie</code>指向前一个比当前<code>chunk</code>大小小的第一个空闲<code>chunk</code>。如果该<code>chunk</code>块被分配给应用程序使用，那么这两个指针也就没有用（该<code>chunk</code>块已经从<code>size</code>链中拆出）了，所以也当作应用程序的使用空间，而不至于浪费。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">malloc_chunk details:</span></span><br><span class="line"><span class="comment">Chunks of memory are maintained using a `boundary tag&#x27; method as</span></span><br><span class="line"><span class="comment">described in e.g., Knuth or Standish. Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">in the front of each chunk and at the end. This makes</span></span><br><span class="line"><span class="comment">consolidating fragmented chunks into bigger chunks very fast. The</span></span><br><span class="line"><span class="comment">size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">in use.</span></span><br><span class="line"><span class="comment">An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment">chunk-&gt;     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            | Size of previous chunk, if allocated  |   |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            | Size of chunk, in bytes               |M|P|</span></span><br><span class="line"><span class="comment">            mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            | User data starts here...                  .</span></span><br><span class="line"><span class="comment">            .                                           .</span></span><br><span class="line"><span class="comment">            .       (malloc_usable_size() bytes)        .</span></span><br><span class="line"><span class="comment">            .                                           |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |                 Size of chunk                 |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">the malloc code, but &quot;mem&quot; is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">user. &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment">Chunks always begin on even word boundries, so the mem portion</span></span><br><span class="line"><span class="comment">(which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">thus at least double-word aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment">chunk-&gt;     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |                   Size of previous chunk                      |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">`head:&#x27;     |                   Size of chunk, in bytes                   |P|</span></span><br><span class="line"><span class="comment">mem-&gt;       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |               Unused space (may be 0 bytes long)              .</span></span><br><span class="line"><span class="comment">            .                                                               .</span></span><br><span class="line"><span class="comment">            .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">`foot:&#x27;     |                   Size of chunk, in bytes                     |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">bit for the *previous* chunk. If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment">Note that the `foot&#x27; of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">to extend or adapt this code.</span></span><br><span class="line"><span class="comment">The two exceptions to all this are</span></span><br><span class="line"><span class="comment">1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">that would have to index off it. After initialization, `top&#x27;30</span></span><br><span class="line"><span class="comment">is forced to always exist. If it would become less than</span></span><br><span class="line"><span class="comment">MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment">2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">bit M (IS_MMAPPED) set in their size fields. Because they are</span></span><br><span class="line"><span class="comment">allocated one-by-one, each must contain its own trailing size field.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上面这段注释详细描述了<code>chunk</code>的细节，已分配的<code>chunk</code>和空闲的<code>chunk</code>形式不一样，充分利用空间复用，设计相当的巧妙。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((void_t*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE \</span></span><br><span class="line"><span class="meta">(unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta">((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta">&amp; MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>
<p>对于已经分配的<code>chunk</code>，通过<code>chunk2mem</code>宏根据<code>chunk</code>地址获得返回给用户的内存地址，反过来通过<code>mem2chunk</code>宏根据<code>mem</code>地址得到<code>chunk</code>地址，<code>chunk</code>的地址是按<code>2*SIZE_SZ</code>对齐的，而<code>chunk</code>结构体的前两个域刚好也是<code>2*SIZE_SZ</code>大小，所以，<code>mem</code>地址也是<code>2*SIZE_SZ</code>对齐的。宏<code>aligned_OK</code>和<code>misaligned_chunk(p)</code>用于校验地址是否是按<code>2*SIZE_SZ</code>对齐的。<code>MIN_CHUNK_SIZE</code>定义了最小的<code>chunk</code>的大小，32位平台上位16字节，64位平台为24字节或是32字节。<code>MINSIZE</code>定义了最小的分配的内存大小，是对<code>MIN_CHUNK_SIZE</code>进行了<br><code>2*SIZE_SZ</code>对齐，地址对齐后与<code>MIN_CHUNK_SIZE</code>的大小仍然是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req) \</span></span><br><span class="line"><span class="meta">((unsigned long)(req) &gt;= \</span></span><br><span class="line"><span class="meta">(unsigned long)(INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req) \</span></span><br><span class="line"><span class="meta">(((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? \</span></span><br><span class="line"><span class="meta">MINSIZE : \</span></span><br><span class="line"><span class="meta">((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"><span class="comment">/* Same, except also perform argument check */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz) \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123; \</span></span><br><span class="line"><span class="meta">MALLOC_FAILURE_ACTION; \</span></span><br><span class="line"><span class="meta">return 0; \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">(sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>
<p>这几个宏用于将用户请求的分配大小转换成内部需要分配的<code>chunk</code>大小，这里需要注意的在转换时不但考虑的地址对齐，还额外加上了<code>SIZE_SZ</code>，这意味着<code>ptmalloc</code>分配内存需要一个额外的<code>overhead</code>，为<code>SIZE_SZ</code>字节，通过<code>chunk</code>的空间复用，我们很容易得出这个<code>overhead</code>为<code>SIZE_SZ</code>。</p>
<p>以<code>Linux X86_64</code>平台为例，假设<code>SIZE_SZ</code>为8字节，空闲时，一个<code>chunk</code>中至少要4个<code>size_t</code>（8B）大小的空间，用来存储<code>prev_size</code>，<code>size</code>，<code>fd</code>和<code>bk</code>，也就是<code>MINSIZE</code>（32B），<code>chunk</code>的大小要对齐到<code>2*SIZE_SZ</code>（16B）。当一个<code>chunk</code>处于使用状态时，它的下一个<code>chunk</code>的<code>prev_size</code>域肯定是无效的。所以实际上，这个空间也可以被当前<code>chunk</code>使用。这听起来有点不可思议，但确实是合理空间复用的例子。</p>
<p>故而实际上，一个使用中的<code>chunk</code>的大小的计算公式应该是：<code>in_use_size = (用户请求大小+ 16 - 8 ) align to 8B</code>，这里加16是因为需要存储<code>prev_size</code>和<code>size</code>，但又因为向下一个<code>chunk</code>“借”了<code>8B</code>，所以要减去8，每分配一个<code>chunk</code>的<code>overhead</code>为<code>8B</code>，即<code>SIZE_SZ</code>的大小。最后，因为空闲的<code>chunk</code>和使用中的<code>chunk</code>使用的是同一块空间。所以肯定要取其中最大者作为实际的分配空间。即最终的分配空间<code>chunk_size = max(in_use_size, 32)</code>。这就是当用户请求内存分配时，<code>ptmalloc</code>实际需要分配的内存大小。</p>
<p>注意：如果<code>chunk</code>是由<code>mmap()</code>直接分配的，则该<code>chunk</code>不会有前一个<code>chunk</code>和后一个<code>chunk</code>，所有本<code>chunk</code>没有下一个<code>chunk</code>的<code>prev_size</code>的空间可以“借”，所以对于直接<code>mmap()</code>分配内存的<code>overhead</code>为<code>2*SIZE_SZ</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">from a non-main arena. This is only set immediately before handing</span></span><br><span class="line"><span class="comment">the chunk to the user, if necessary. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x432</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>
<p><code>chunk</code>在分割时总是以地址对齐（默认是8字节，可以自由设置，但是8字节是最小值并且设置的值必须是2为底的幂函数值，即是<code>alignment = 2^n</code>，<code>n</code>为整数且<code>n&gt;=3</code>）的方式来进行的，所以用<code>chunk-&gt;size</code>来存储本<code>chunk</code>块大小字节数的话，其末3bit位总是0，因此这三位可以用来存储其它信息，比如：</p>
<ul>
<li>以第0位作为<code>P</code>状态位，标记前一<code>chunk</code>块是否在使用中，为1表示使用，为0表示空闲。</li>
<li>以第1位作为<code>M</code>状态位，标记本<code>chunk</code>块是否是使用<code>mmap()</code>直接从进程的<code>mmap</code>映射区域分配的，为1表示是，为0表示否。</li>
<li>以第2位作为<code>A</code>状态位，标记本<code>chunk</code>是否属于非主分配区，为1表示是，为0表示否。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment">Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS) ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)-&gt;prev_size) ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char*)(p)) + (s)))</span></span><br></pre></td></tr></table></figure>
<p><code>prev_size</code>字段虽然在当前<code>chunk</code>块结构体内，记录的却是前一个邻接<code>chunk</code>块的信息，这样做的好处就是我们通过本块<code>chunk</code>结构体就可以直接获取到前一<code>chunk</code>块的信息，从而方便做进一步的处理操作。相对的，当前<code>chunk</code>块的<code>foot</code>信息就存在于下一个邻接<code>chunk</code>块的结构体内。字段<code>prev_size</code>记录的什么信息呢？有两种情况：</p>
<ol>
<li>如果前一个邻接<code>chunk</code>块空闲，那么当前<code>chunk</code>块结构体内的<code>prev_size</code>字段记录的是前一个邻接<code>chunk</code>块的大小。这就是由当前<code>chunk</code>指针获得前一个空闲<code>chunk</code>地址的依据。宏<code>prev_chunk(p)</code>就是依赖这个假设实现的。</li>
<li>如果前一个邻接<code>chunk</code>在使用中，则当前<code>chunk</code>的<code>prev_size</code>的空间被前一个<code>chunk</code>借用中，其中的值是前一个<code>chunk</code>的内存内容，对当前<code>chunk</code>没有任何意义。字段<code>size</code>记录了本<code>chunk</code>的大小，无论下一个<code>chunk</code>是空闲状态或是被使用状态，都可以通过本<code>chunk</code>的地址加上本<code>chunk</code>的大小，得到下一个<code>chunk</code>的地址，由于<code>size</code>的低3个<code>bit</code>记录了控制信息，需要屏蔽掉这些控制信息，取出实际的<code>size</code>在进行计算下一个<code>chunk</code>地址，这是<code>next_chunk(p)</code>的实现原理。</li>
</ol>
<p>宏<code>chunksize(p)</code>用于获得<code>chunk</code>的实际大小，需要屏蔽掉<code>size</code>中的控制信息。宏<code>chunk_at_offset(p, s)</code>将<code>p+s</code>的地址强制看作一个<code>chunk</code>。</p>
<p>注意：按照边界标记法，可以有多个连续的并且正在被使用中的<code>chunk</code>块，但是不会有多个连续的空闲<code>chunk</code>块，因为连续的多个空闲<code>chunk</code>块一定会合并成一个大的空闲<code>chunk</code>块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)\</span></span><br><span class="line"><span class="meta">((((mchunkptr)(((char*)(p))+((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)\</span></span><br><span class="line"><span class="meta">((mchunkptr)(((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)\</span></span><br><span class="line"><span class="meta">((mchunkptr)(((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的这一组宏用于<code>check/set/clear</code>当前<code>chunk</code>使用标志位，有当前<code>chunk</code>的使用标志位存储在下一个<code>chunk</code>的<code>size</code>的第0 bit （<code>P</code>状态位），所以首先要获得下一个<code>chunk</code>的地址，然后<code>check/set/clear</code>下一个<code>chunk</code>的<code>size</code>域的第0 bit。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span></span><br></pre></td></tr></table></figure>
<p>上面的三个宏用于<code>check/set/clear</code>指定<code>chunk</code>的<code>size</code>域中的使用标志位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s) ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s) (((mchunkptr)((char*)(p) + (s)))-&gt;prev_size = (s))</span></span><br></pre></td></tr></table></figure>
<p>宏<code>set_head_size(p, s)</code>用于设置当前<code>chunk</code> <code>p</code>的<code>size</code>域并保留<code>size</code>域的控制信息。宏<code>set_head(p, s)</code>用于设置当前<code>chunk</code> <code>p</code>的<code>size</code>域并忽略已有的<code>size</code>域控制信息。宏<code>set_foot(p, s)</code>用于设置当前<code>chunk</code> <code>p</code>的下一个<code>chunk</code>的<code>prev_size</code>为<code>s</code>，<code>s</code>为当前<code>chunk</code>的<code>size</code>，只有当<code>chunk</code> <code>p</code>为空闲时才能使用这个宏，当前<code>chunk</code>的<code>foot</code>的内存空间存在于下一个<code>chunk</code>，即下一个<code>chunk</code>的<code>prev_size</code>。</p>
<h2 id="分箱式内存管理"><a href="#分箱式内存管理" class="headerlink" title="分箱式内存管理"></a>分箱式内存管理</h2><p>对于空闲的<code>chunk</code>，<code>ptmalloc</code>采用分箱式内存管理方式，根据空闲<code>chunk</code>的大小和处于的状态将其放在四个不同的<code>bin</code>中，这四个空闲<code>chunk</code>的容器包括<code>fast bins</code>，<code>unsorted bin</code>，<code>small bins</code>和<code>large bins</code>。<code>fast bins</code>是小内存块的高速缓存，当一些大小小于64字节的<code>chunk</code>被回收时，首先会放入<code>fast bins</code>中，在分配小内存时，首先会查看<code>fast bins</code>中是否有合适的内存块，如果存在，则直接返回<code>fast bins</code>中的内存块，以加快分配速度。</p>
<p><code>usorted bin</code>只有一个，回收的<code>chunk</code>块必须先放到<code>unsorted bin</code>中，分配内存时会查看<code>unsorted bin</code>中是否有合适的<code>chunk</code>，如果找到满足条件的<code>chunk</code>，则直接返回给用户，否则将<code>unsorted bin</code>的所有<code>chunk</code>放入<code>small bins</code>或是<code>large bins</code>中。</p>
<p><code>small bins</code>用于存放固定大小的<code>chunk</code>，共64个<code>bin</code>，最小的<code>chunk</code>大小为16字节或32字节，每个<code>bin</code>的大小相差8字节或是16字节，当<br>分配小内存块时，采用精确匹配的方式从<code>small bins</code>中查找合适的<code>chunk</code>。</p>
<p><code>large bins</code>用于存储大于等于512B或1024B的空闲<code>chunk</code>，这些<code>chunk</code>使用双向链表的形式按大小顺序排序，分配内存时按最近匹配方式从<code>large bins</code>中分配<code>chunk</code>。</p>
<h3 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h3><p><code>ptmalloc</code>使用<code>small bins</code>管理空闲小<code>chunk</code>，每个<code>small bin</code>中的<code>chunk</code>的大小与<code>bin</code>的<code>index</code>有如下关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_size=2 * SIZE_SZ * index</span><br></pre></td></tr></table></figure></p>
<p>在<code>SIZE_SZ</code>为4B的平台上，<code>small bins</code>中的<code>chunk</code>大小是以<code>8B</code>为公差的等差数列，最大的<code>chunk</code>大小为<code>504B</code>，最小的<code>chunk</code>大小为<code>16B</code>，所以实际共62个bin。分别为<code>16B</code>、<code>24B</code>、<code>32B</code>，„„，<code>504B</code>。在<code>SIZE_SZ</code>为8B的平台上，<code>small bins</code>中的<code>chunk</code>大小是以<code>16B</code>为公差的等差数列，最大的<code>chunk</code>大小为<code>1008B</code>，最小的<code>chunk</code>大小为<code>32B</code>，所以实际共62个<code>bin</code>。分别为<code>32B</code>、<code>48B</code>、<code>64B</code>，„„，<code>1008B</code>。</p>
<p><code>ptmalloc</code>维护了62个双向环形链表（每个链表都具有链表头节点，加头节点的最大作用就是便于对链表内节点的统一处理，即简化编程），每一个链表内的各空闲<code>chunk</code>的大小一致，因此当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了，这样既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。我们可以用如下图来表示在<code>SIZE_SZ</code>为4B的平台上<code>ptmalloc</code>对512B字节以下的空闲<code>chunk</code>组织方式（所谓的分箱机制）。<br><img src="/img/1634402543.jpg" alt=""></p>
<h3 id="large-bins"><a href="#large-bins" class="headerlink" title="large bins"></a>large bins</h3><p>在<code>SIZE_SZ</code>为4B的平台上，大于等于512B的空闲<code>chunk</code>，或者，在<code>SIZE_SZ</code>为8B的平台上，大小大于等于1024B的空闲<code>chunk</code>，由<code>sorted bins</code>管理。<code>large bins</code>一共包括63个<code>bin</code>，每个<code>bin</code>中的<code>chunk</code>大小不是一个固定公差的等差数列，而是分成6组<code>bin</code>，每组<code>bin</code>是一个<br>固定公差的等差数列，每组的<code>bin</code>数量依次为32、 16、 8、 4、 2、 1，公差依次为64B、 512B、4096B、 32768B、 262144B等。</p>
<p>以<code>SIZE_SZ</code>为4B的平台为例，第一个<code>large bin</code>的起始<code>chunk</code>大小为<code>512B</code>，共32个<code>bin</code>，公差为<code>64B</code>，等差数列满足如下关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_size=512 + 64 * index</span><br></pre></td></tr></table></figure></p>
<p>第二个<code>large bin</code>的起始<code>chunk</code>大小为第一组<code>bin</code>的结束<code>chunk</code>大小，满足如下关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_size=512 + 64 * 32 + 512 * index</span><br></pre></td></tr></table></figure></p>
<p>同理，我们可计算出每个<code>bin</code>的起始<code>chunk</code>大小和结束<code>chunk</code>大小。这些<code>bin</code>都是很有规律的，其实<code>small bins</code>也是满足类似规律，<code>small bins</code>可以看着是公差为8的等差数列，一共有64个<code>bin</code>（第0和1<code>bin</code>不存在），所以我们可以将<code>small bins</code>和<code>large bins</code>存放在同一个包含128个<code>chunk</code>的数组上，数组的前一部分位<code>small bins</code>，后一部分为<code>large bins</code>，每个<code>bin</code>的<code>index</code>为<code>chunk</code>数组的下标，于是，我们可以根据数组下标计算出该<code>bin</code>的<code>chunk</code>大小（<code>small bins</code>）或是<code>chunk</code>大小范围（<code>large bins</code>），也可以根据需要分配内存块大小计算出所需<code>chunk</code>所属<code>bin</code>的<code>index</code>，<code>ptmalloc</code>使用了一组宏巧妙的实现了这种计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE (NSMALLBINS * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz) \</span></span><br><span class="line"><span class="meta">((unsigned long)(sz) &lt; (unsigned long)MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">(SMALLBIN_WIDTH == 16 ? (((unsigned)(sz)) &gt;&gt; 4) : (((unsigned)(sz)) &gt;&gt; 3))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz) \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 38)? 56 + (((unsigned long)(sz)) &gt;</span>&gt; 6): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 9) <span class="string">&lt;= 20)? 91 + (((unsigned long)(sz)) &gt;</span>&gt; 9): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;= 4)? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;= 2)? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18): \</span></span><br><span class="line"><span class="meta">126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz) \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 48)? 48 + (((unsigned long)(sz)) &gt;</span>&gt; 6): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 9) <span class="string">&lt;= 20)? 91 + (((unsigned long)(sz)) &gt;</span>&gt; 9): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;= 4)? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;= 2)? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18): \</span></span><br><span class="line"><span class="meta">126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">(SIZE_SZ == 8 ? largebin_index_64 (sz) : largebin_index_32 (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))</span></span><br></pre></td></tr></table></figure>
<p>宏<code>bin_index(sz)</code>根据所需内存大小计算出所需<code>bin</code>的<code>index</code>，如果所需内存大小属于<code>small bins</code>的大小范围，调用<code>smallbin_index(sz)</code>，否则调用<code>largebin_index(sz))</code>。<code>smallbin_index(sz)</code>的计算相当简单，如果<code>SIZE_SZ</code>为<code>4B</code>，则将<code>sz</code>除以8，如果<code>SIZE_SZ</code>为<code>8B</code>，则将<code>sz</code>除以16，也就是除以<code>small bins</code>中等差数列的公差。<code>largebin_index(sz)</code>的计算相对复杂一些，可以用如下的表格直观的显示<code>chunk</code>的大小范围与<code>bin index</code>的关系。以<code>SIZE_SZ</code>为4B的平台为例，<code>chunk</code>大小与<code>bin index</code>的对应关系如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>开始(字节)</th>
<th>结束（字节）</th>
<th>Bin index</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>7</td>
<td>不存在</td>
</tr>
<tr>
<td>8</td>
<td>15</td>
<td>不存在</td>
</tr>
<tr>
<td>16</td>
<td>23</td>
<td>2</td>
</tr>
<tr>
<td>24</td>
<td>31</td>
<td>3</td>
</tr>
<tr>
<td>32</td>
<td>39</td>
<td>4</td>
</tr>
<tr>
<td>40</td>
<td>47</td>
<td>5</td>
</tr>
<tr>
<td>48</td>
<td>55</td>
<td>6</td>
</tr>
<tr>
<td>56</td>
<td>63</td>
<td>7</td>
</tr>
<tr>
<td>64</td>
<td>71</td>
<td>8</td>
</tr>
<tr>
<td>72</td>
<td>79</td>
<td>9</td>
</tr>
<tr>
<td>80</td>
<td>87</td>
<td>10</td>
</tr>
<tr>
<td>88</td>
<td>95</td>
<td>11</td>
</tr>
<tr>
<td>96</td>
<td>103</td>
<td>12</td>
</tr>
<tr>
<td>104</td>
<td>111</td>
<td>13</td>
</tr>
<tr>
<td>112</td>
<td>119</td>
<td>14</td>
</tr>
<tr>
<td>120</td>
<td>127</td>
<td>15</td>
</tr>
<tr>
<td>128</td>
<td>135</td>
<td>16</td>
</tr>
<tr>
<td>136</td>
<td>143</td>
<td>17</td>
</tr>
<tr>
<td>144</td>
<td>151</td>
<td>18</td>
</tr>
<tr>
<td>152</td>
<td>159</td>
<td>19</td>
</tr>
<tr>
<td>160</td>
<td>167</td>
<td>20</td>
</tr>
<tr>
<td>168</td>
<td>175</td>
<td>21</td>
</tr>
<tr>
<td>176</td>
<td>183</td>
<td>22</td>
</tr>
<tr>
<td>184</td>
<td>191</td>
<td>23</td>
</tr>
<tr>
<td>192</td>
<td>199</td>
<td>24</td>
</tr>
<tr>
<td>200</td>
<td>207</td>
<td>25</td>
</tr>
<tr>
<td>208</td>
<td>215</td>
<td>26</td>
</tr>
<tr>
<td>216</td>
<td>223</td>
<td>27</td>
</tr>
<tr>
<td>224</td>
<td>231</td>
<td>28</td>
</tr>
<tr>
<td>232</td>
<td>239</td>
<td>29</td>
</tr>
<tr>
<td>240</td>
<td>247</td>
<td>30</td>
</tr>
<tr>
<td>248</td>
<td>255</td>
<td>31</td>
</tr>
<tr>
<td>256</td>
<td>263</td>
<td>32</td>
</tr>
<tr>
<td>264</td>
<td>271</td>
<td>33</td>
</tr>
<tr>
<td>272</td>
<td>279</td>
<td>34</td>
</tr>
<tr>
<td>280</td>
<td>287</td>
<td>35</td>
</tr>
<tr>
<td>288</td>
<td>295</td>
<td>36</td>
</tr>
<tr>
<td>296</td>
<td>303</td>
<td>37</td>
</tr>
<tr>
<td>304</td>
<td>311</td>
<td>38</td>
</tr>
<tr>
<td>312</td>
<td>319</td>
<td>39</td>
</tr>
<tr>
<td>320</td>
<td>327</td>
<td>40</td>
</tr>
<tr>
<td>328</td>
<td>335</td>
<td>41</td>
</tr>
<tr>
<td>336</td>
<td>343</td>
<td>42</td>
</tr>
<tr>
<td>344</td>
<td>351</td>
<td>43</td>
</tr>
<tr>
<td>352</td>
<td>359</td>
<td>44</td>
</tr>
<tr>
<td>360</td>
<td>367</td>
<td>45</td>
</tr>
<tr>
<td>368</td>
<td>375</td>
<td>46</td>
</tr>
<tr>
<td>376</td>
<td>383</td>
<td>47</td>
</tr>
<tr>
<td>384</td>
<td>391</td>
<td>48</td>
</tr>
<tr>
<td>392</td>
<td>399</td>
<td>49</td>
</tr>
<tr>
<td>400</td>
<td>407</td>
<td>50</td>
</tr>
<tr>
<td>408</td>
<td>415</td>
<td>51</td>
</tr>
<tr>
<td>416</td>
<td>423</td>
<td>52</td>
</tr>
<tr>
<td>424</td>
<td>431</td>
<td>53</td>
</tr>
<tr>
<td>432</td>
<td>439</td>
<td>54</td>
</tr>
<tr>
<td>440</td>
<td>447</td>
<td>55</td>
</tr>
<tr>
<td>448</td>
<td>455</td>
<td>56</td>
</tr>
<tr>
<td>456</td>
<td>463</td>
<td>57</td>
</tr>
<tr>
<td>464</td>
<td>471</td>
<td>58</td>
</tr>
<tr>
<td>472</td>
<td>479</td>
<td>59</td>
</tr>
<tr>
<td>480</td>
<td>487</td>
<td>60</td>
</tr>
<tr>
<td>488</td>
<td>495</td>
<td>61</td>
</tr>
<tr>
<td>496</td>
<td>503</td>
<td>62</td>
</tr>
<tr>
<td>504</td>
<td>511</td>
<td>63</td>
</tr>
<tr>
<td>512</td>
<td>575</td>
<td>64</td>
</tr>
<tr>
<td>576</td>
<td>639</td>
<td>65</td>
</tr>
<tr>
<td>640</td>
<td>703</td>
<td>66</td>
</tr>
<tr>
<td>704</td>
<td>767</td>
<td>67</td>
</tr>
<tr>
<td>768</td>
<td>831</td>
<td>68</td>
</tr>
<tr>
<td>832</td>
<td>895</td>
<td>69</td>
</tr>
<tr>
<td>896</td>
<td>959</td>
<td>70</td>
</tr>
<tr>
<td>960</td>
<td>1023</td>
<td>71</td>
</tr>
<tr>
<td>1024</td>
<td>1087</td>
<td>72</td>
</tr>
<tr>
<td>1088</td>
<td>1151</td>
<td>73</td>
</tr>
<tr>
<td>1152</td>
<td>1215</td>
<td>74</td>
</tr>
<tr>
<td>1216</td>
<td>1279</td>
<td>75</td>
</tr>
<tr>
<td>1280</td>
<td>1343</td>
<td>76</td>
</tr>
<tr>
<td>1344</td>
<td>1407</td>
<td>77</td>
</tr>
<tr>
<td>1408</td>
<td>1471</td>
<td>78</td>
</tr>
<tr>
<td>1472</td>
<td>1535</td>
<td>79</td>
</tr>
<tr>
<td>1536</td>
<td>1599</td>
<td>80</td>
</tr>
<tr>
<td>1600</td>
<td>1663</td>
<td>81</td>
</tr>
<tr>
<td>1664</td>
<td>1727</td>
<td>82</td>
</tr>
<tr>
<td>1728</td>
<td>1791</td>
<td>83</td>
</tr>
<tr>
<td>1792</td>
<td>1855</td>
<td>84</td>
</tr>
<tr>
<td>1856</td>
<td>1919</td>
<td>85</td>
</tr>
<tr>
<td>1920</td>
<td>1983</td>
<td>86</td>
</tr>
<tr>
<td>1984</td>
<td>2047</td>
<td>87</td>
</tr>
<tr>
<td>2048</td>
<td>2111</td>
<td>88</td>
</tr>
<tr>
<td>2112</td>
<td>2175</td>
<td>89</td>
</tr>
<tr>
<td>2176</td>
<td>2239</td>
<td>90</td>
</tr>
<tr>
<td>2240</td>
<td>2303</td>
<td>91</td>
</tr>
<tr>
<td>2304</td>
<td>2367</td>
<td>92</td>
</tr>
<tr>
<td>2368</td>
<td>2431</td>
<td>93</td>
</tr>
<tr>
<td>2432</td>
<td>2495</td>
<td>94</td>
</tr>
<tr>
<td>2496</td>
<td>2559</td>
<td>95</td>
</tr>
<tr>
<td>2560</td>
<td>3071</td>
<td>96</td>
</tr>
<tr>
<td>3072</td>
<td>3583</td>
<td>97</td>
</tr>
<tr>
<td>3584</td>
<td>4095</td>
<td>98</td>
</tr>
<tr>
<td>4096</td>
<td>4607</td>
<td>99</td>
</tr>
<tr>
<td>4608</td>
<td>5119</td>
<td>100</td>
</tr>
<tr>
<td>5120</td>
<td>5631</td>
<td>101</td>
</tr>
<tr>
<td>5632</td>
<td>6143</td>
<td>102</td>
</tr>
<tr>
<td>6144</td>
<td>6655</td>
<td>103</td>
</tr>
<tr>
<td>6656</td>
<td>7167</td>
<td>104</td>
</tr>
<tr>
<td>7168</td>
<td>7679</td>
<td>105</td>
</tr>
<tr>
<td>7680</td>
<td>8191</td>
<td>106</td>
</tr>
<tr>
<td>8192</td>
<td>8703</td>
<td>107</td>
</tr>
<tr>
<td>8704</td>
<td>9215</td>
<td>108</td>
</tr>
<tr>
<td>9216</td>
<td>9727</td>
<td>109</td>
</tr>
<tr>
<td>9728</td>
<td>10239</td>
<td>110</td>
</tr>
<tr>
<td>10240</td>
<td>10751</td>
<td>111</td>
</tr>
<tr>
<td>10752</td>
<td>14847</td>
<td>112</td>
</tr>
<tr>
<td>14848</td>
<td>18943</td>
<td>113</td>
</tr>
<tr>
<td>18944</td>
<td>23039</td>
<td>114</td>
</tr>
<tr>
<td>23040</td>
<td>27135</td>
<td>115</td>
</tr>
<tr>
<td>27136</td>
<td>31231</td>
<td>116</td>
</tr>
<tr>
<td>31232</td>
<td>35327</td>
<td>117</td>
</tr>
<tr>
<td>35328</td>
<td>39423</td>
<td>118</td>
</tr>
<tr>
<td>39424</td>
<td>43519</td>
<td>119</td>
</tr>
<tr>
<td>43520</td>
<td>76287</td>
<td>120</td>
</tr>
<tr>
<td>76288</td>
<td>109055</td>
<td>121</td>
</tr>
<tr>
<td>109056</td>
<td>141823</td>
<td>122</td>
</tr>
<tr>
<td>141824</td>
<td>174591</td>
<td>123</td>
</tr>
<tr>
<td>174592</td>
<td>436735</td>
<td>124</td>
</tr>
<tr>
<td>436736</td>
<td>698879</td>
<td>125</td>
</tr>
<tr>
<td>698880</td>
<td>2^32或2^64</td>
<td>126</td>
</tr>
</tbody>
</table>
</div>
<p>注意：上表是<code>chunk</code>大小与<code>bin index</code>的对应关系，如果对于用户要分配的内存大小<code>size</code>，必须先使用<code>checked_request2size(req, sz)</code>计算出<code>chunk</code>的大小，再使用<code>bin_index(sz)</code>计算出<code>chunk</code>所属的<code>bin index</code>。</p>
<p>对于<code>SIZE_SZ</code>为4B的平台，<code>bin[0]</code>和<code>bin[1]</code>是不存在的，因为最小的<code>chunk</code>为<code>16B</code>，<code>small bins</code>一共62个，<code>large bins</code>一共63个，加起来一共125个<code>bin</code>。而<code>NBINS</code>定义为128，其实<code>bin[0]</code>和<code>bin[127]</code>都不存在，<code>bin[1]</code>为<code>unsorted bin</code>的<code>chunk</code>链表头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">(mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2])) \</span></span><br><span class="line"><span class="meta">- offsetof (struct malloc_chunk, fd))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char*)(b) + (sizeof(mchunkptr)&lt;&lt;1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b) ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b) ((b)-&gt;bk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(P, BK, FD) &#123; \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd; \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \</span></span><br><span class="line"><span class="meta">        malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123; \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK; \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size) \</span></span><br><span class="line"><span class="meta">        &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \</span></span><br><span class="line"><span class="meta">            assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P); \</span></span><br><span class="line"><span class="meta">            assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123; \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P) \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123; \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \</span></span><br><span class="line"><span class="meta">                &#125; \</span></span><br><span class="line"><span class="meta">            &#125; <span class="keyword">else</span> &#123; \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \</span></span><br><span class="line"><span class="meta">            &#125; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>宏<code>bin_at(m, i)</code>通过<code>bin index</code>获得<code>bin</code>的链表头，<code>chunk</code>中的<code>fb</code>和<code>bk</code>用于将空闲<code>chunk</code>链入链表中，而对于每个<code>bin</code>的链表头，只需要这两个域就可以了，<code>prev_size</code>和<code>size</code>对链表都来说都没有意义，浪费空间，<code>ptmalloc</code>为了节约这点内存空间，增大<code>cpu</code>高速缓存的命中率，在<code>bins</code>数组中只为每个<code>bin</code>预留了两个指针的内存空间用于存放<code>bin</code>的链表头的<code>fb</code>和<code>bk</code>指针。</p>
<p>从<code>bin_at(m, i)</code>的定义可以看出，<code>bin[0]</code>不存在，以<code>SIZE_SZ</code>为4B的平台为例，<code>bin[1]</code>的前4B存储的是指针<code>fb</code>，后4B存储的是指针<code>bk</code>，而<code>bin_at</code>返回的是<code>malloc_chunk</code>的指针，由于<code>fb</code>在<code>malloc_chunk</code>的偏移地址为<code>offsetof (struct malloc_chunk, fd))=8</code>，所以用<code>fb</code>的地址减去8就得到<code>malloc_chunk</code>的地址。但切记，对<code>bin</code>的链表头的<code>chunk</code>，一定不能修改<code>prev_size</code>和<code>size</code>域，这两个域是与其他<code>bin</code>的链表头的<code>fb</code>和<code>bk</code>内存复用的。</p>
<p>宏<code>next_bin(b)</code>用于获得下一个<code>bin</code>的地址，根据前面的分析，我们知道只需要将当前<code>bin</code>的地址向后移动两个指针的长度就得到下一个<code>bin</code>的链表头地址。每个<code>bin</code>使用双向循环链表管理空闲<code>chunk</code>，<code>bin</code>的链表头的指针<code>fb</code>指向第一个可用的<code>chunk</code>，指针<code>bk</code>指向最后一个可用的<code>chunk</code>。</p>
<p>宏<code>first(b)</code>用于获得<code>bin</code>的第一个可用<code>chunk</code>，宏<code>last(b)</code>用于获得<code>bin</code>的最后一个可用的<code>chunk</code>，这两个宏便于遍历<code>bin</code>，而跳过<code>bin</code>的链表头。</p>
<p>宏<code>unlink(P, BK, FD)</code>用于将<code>chunk</code>从所在的空闲链表中取出来，注意<code>large bins</code>中的空闲<code>chunk</code>可能处于两个双向循环链表中，<code>unlink</code>时需要从两个链表中都删除。</p>
<h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p><code>unsorted bin</code>可以看作是<code>small bins</code>和<code>large bins</code>的<code>cache</code>，只有一个<code>unsorted bin</code>，以双向链表管理空闲<code>chunk</code>，空闲<code>chunk</code>不排序，所有的<code>chunk</code>在回收时都要先放到<code>unsorted bin</code>中，分配时，如果在<code>unsorted bin</code>中没有合适的<code>chunk</code>，就会把<code>unsorted bin</code>中的所有<code>chunk</code>分别加入到所属的<code>bin</code>中，然后再在<code>bin</code>中分配合适的<code>chunk</code>。<code>bins</code>数组中的元素<code>bin[1]</code>用于存储<code>unsorted bin</code>的<code>chunk</code>链表头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Unsorted chunks</span></span><br><span class="line"><span class="comment">All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment">The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Top</span></span><br><span class="line"><span class="comment">The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">M_TRIM_THRESHOLD). Because top initially</span></span><br><span class="line"><span class="comment">points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">sYSMALLOc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure>
<p>上面的宏的定义比较明显，把<code>bin[1]</code>设置为<code>unsorted bin</code>的<code>chunk</code>链表头，对<code>top chunk</code>的初始化，也暂时把<code>top chunk</code>初始化为<code>unsorted chunk</code>，仅仅是初始化一个值而已，这个<code>chunk</code>的内容肯定不能用于<code>top chunk</code>来分配内存，主要原因是<code>top chunk</code>不属于任何<code>bin</code>，但<code>ptmalloc</code>中的一些<code>check</code>代码，可能需要<code>top chunk</code>属于一个合法的<code>bin</code>。</p>
<h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><p><code>fast bins</code>主要是用于提高小内存的分配效率，默认情况下，对于<code>SIZE_SZ</code>为4B的平台，小于<code>64B</code>的<code>chunk</code>分配请求，对于<code>SIZE_SZ</code>为8B的平台，小于128B的<code>chunk</code>分配请求，首先会查找<code>fast bins</code>中是否有所需大小的<code>chunk</code>存在（精确匹配），如果存在，就直接返回。<code>fast bins</code>可以看着是<code>small bins</code>的一小部分<code>cache</code>，默认情况下，<code>fast bins</code>只<code>cache</code>了<code>small bins</code>的前7个大小的空闲<code>chunk</code>，也就是说，对于<code>SIZE_SZ</code>为4B的平台，<code>fast bins</code>有7个<code>chunk</code>空闲链表（bin），每个<code>bin</code>的<code>chunk</code>大小依次为<code>16B</code>，<code>24B</code>，<code>32B</code>，<code>40B</code>，<code>48B</code>，<code>56B</code>，<code>64B</code>；对于<code>SIZE_SZ</code>为8B的平台，<code>fast bins</code>有7个<code>chunk</code>空闲链表（bin），每个<code>bin</code>的<code>chunk</code>大小依次为<code>32B</code>，<code>48B</code>，<code>64B</code>，<code>80B</code>，<code>96B</code>，<code>112B</code>，<code>128B</code>。以32为系统为例，分配的内存大小与<code>chunk</code>大小和<code>fast bins</code>的对应关系如下表所示：<br><img src="/img/1634435791.jpg" alt=""></p>
<p><code>fast bins</code>可以看着是<code>LIFO</code>的栈，使用单向链表实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Fastbins</span></span><br><span class="line"><span class="comment">An array of lists holding recently freed small chunks. Fastbins</span></span><br><span class="line"><span class="comment">are not doubly linked. It is faster to single-link them, and</span></span><br><span class="line"><span class="comment">since chunks are never removed from the middles of these lists,</span></span><br><span class="line"><span class="comment">double linking is not necessary. Also, unlike regular bins, they</span></span><br><span class="line"><span class="comment">are not even processed in FIFO order (they use faster LIFO) since</span></span><br><span class="line"><span class="comment">ordering doesn&#x27;t much matter in the transient contexts in which</span></span><br><span class="line"><span class="comment">fastbins are normally used.</span></span><br><span class="line"><span class="comment">Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">be consolidated with other free chunks. malloc_consolidate43</span></span><br><span class="line"><span class="comment">releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">other free chunks.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure>
<p>根据<code>fast bin</code>的<code>index</code>，获得<code>fast bin</code>的地址。<code>fast bins</code>的数字定义在<code>malloc_state</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">((((unsigned int)(sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure>
<p>宏<code>fastbin_index(sz)</code>用于获得<code>fast bin</code>在<code>fast bins</code>数组中的<code>index</code>，由于<code>bin[0]</code>和<code>bin[1]</code>中的<code>chunk</code>不存在，所以需要减2，对于<code>SIZE_SZ</code>为4B的平台，将<code>sz</code>除以8减2得到<code>fast bin index</code>，对于<code>SIZE_SZ</code>为8B的平台，将<code>sz</code>除以16减去2得到<code>fast bin index</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE))+1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span></span><br><span class="line"><span class="comment">that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment">fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment">matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment">compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment">to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment">consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment">if trimming is not used.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br></pre></td></tr></table></figure>
<p>根据<code>SIZE_SZ</code>的不同大小，定义<code>MAX_FAST_SIZE</code>为<code>80B</code>或是<code>160B</code>，<code>fast bins</code>数组的大小<code>NFASTBINS</code>为10，<code>FASTBIN_CONSOLIDATION_THRESHOLD</code>为<code>64k</code>，当每次释放的<code>chunk</code>与该<code>chunk</code>相邻的空闲<code>chunk</code>合并后的大小大于64K时，就认为内存碎片可能比较多了，就需要把<code>fast bins</code>中的所有<code>chunk</code>都进行合并，以减少内存碎片对系统的影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Set value of max_fast.</span></span><br><span class="line"><span class="comment">Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment">Precondition: there are no existing fastbin chunks.</span></span><br><span class="line"><span class="comment">Setting the value clears fastchunk bit but preserves noncontiguous bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta">global_max_fast = (((s) == 0) \</span></span><br><span class="line"><span class="meta">? SMALLBIN_WIDTH: ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br></pre></td></tr></table></figure>
<p>上面的宏<code>DEFAULT_MXFAST</code>定义了默认的<code>fast bins</code>中最大的<code>chunk</code>大小，对于<code>SIZE_SZ</code>为<code>4B</code>的平台，最大<code>chunk</code>为<code>64B</code>，对于<code>SIZE_SZ</code>为8B的平台，最大<code>chunk</code>为128B。<code>ptmalloc</code>默认情况下调用<code>set_max_fast(s)</code>将全局变量<code>global_max_fast</code>设置为<code>DEFAULT_MXFAST</code>，也就是设置<code>fast bins</code>中<code>chunk</code>的最大值，<code>get_max_fast()</code>用于获得这个全局变量<code>global_max_fast</code>的值。</p>
<h2 id="核心结构体分析"><a href="#核心结构体分析" class="headerlink" title="核心结构体分析"></a>核心结构体分析</h2><p>每个分配区是<code>struct malloc_state</code>的一个实例，<code>ptmalloc</code>使用<code>malloc_state</code>来管理分配区，而参数管理使用<code>struct malloc_par</code>，全局拥有一个唯一的<code>malloc_par</code>实例。</p>
<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p><code>struct malloc_state</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Serialize access. */</span></span><br><span class="line">    <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags (formerly in max_fast). */</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> THREAD_STATS</span></span><br><span class="line">    <span class="comment">/* Statistics for locking. Only used if THREAD_STATS is defined. */</span></span><br><span class="line">    <span class="type">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    mchunkptr top;</span><br><span class="line">    <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line">    <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">    mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">    <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line">    <span class="comment">/* Linked list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">    <span class="comment">/* Linked list for free arenas. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Memory allocated from the system in this arena. */</span></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>mutex</code>用于串行化访问分配区，当有多个线程访问同一个分配区时，第一个获得这个<code>mutex</code>的线程将使用该分配区分配内存，分配完成后，释放该分配区的<code>mutex</code>，以便其它线程使用该分配区。</p>
<p><code>flags</code>记录了分配区的一些标志，<code>bit0</code>用于标识分配区是否包含至少一个<code>fast bin chunk</code>，<code>bit1</code>用于标识分配区是否能返回连续的虚拟地址空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment">The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">initialization checks.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) ((M)-&gt;flags |= FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) ((M)-&gt;flags &amp;= ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>上面的宏用于设置或是置位<code>flags</code>中<code>fast chunk</code>的标志位<code>bit0</code>，如果<code>bit0</code>为0，表示分配区中有<code>fast chunk</code>，如果为1表示没有<code>fast chunk</code>，初始化完成后的<code>malloc_state</code>实例中，<code>flags</code>值为0，表示该分配区中有<code>fast chunk</code>，但实际上没有，试图从<code>fast bins</code>中分配<code>chunk</code>都会返回<code>NULL</code>，在第一次调用函数<code>malloc_consolidate()</code>对<code>fast bins</code>进行<code>chunk</code>合并时，如果<code>max_fast</code>大于0，会调用<code>clear_fastchunks</code>宏，标志该分配区中已经没有<code>fast chunk</code>，因为函数<code>malloc_consolidate()</code>会合并所有的<code>fast bins</code>中的<code>chunk</code>。<code>clear_fastchunks</code>宏只会在函数<code>malloc_consolidate()</code>中调用。当有<code>fast chunk</code>加入<code>fast bins</code>时，就是调用<code>set_fastchunks</code>宏标46识分配区的<code>fast bins</code>中存在<code>fast chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">regions. Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment">The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">changed dynamically if`mmap`is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br></pre></td></tr></table></figure>
<p><code>flags</code>的<code>bit1</code>如果为0，表示<code>MORCORE</code>返回连续虚拟地址空间，<code>bit1</code>为1，表示<code>MORCORE</code>返回非连续虚拟地址空间，对于主分配区，<code>MORECORE</code>其实为<code>sbr()</code>，默认返回连续虚拟地址空间，对于非主分配区，使用<code>mmap()</code>分配大块虚拟内存，然后进行切分来模拟主分配区的行为，而默认情况下<code>mmap</code>映射区域是不保证虚拟地址空间连续的，所以非住分配区默认分配非连续虚拟地址空间。</p>
<p><code>malloc_state</code>中声明了几个对锁的统计变量，默认没有定义<code>THREAD_STATS</code>，所以不会对锁的争用情况做统计。</p>
<p><code>fastbinsY</code>拥有10（<code>NFASTBINS</code>）个元素的数组，用于存放每个<code>fast chunk</code>链表头指针，所以<code>fast bins</code>最多包含10个<code>fast chunk</code>的单向链表。</p>
<p><code>top</code>是一个<code>chunk</code>指针，指向分配区的<code>top chunk</code>。</p>
<p><code>last_remainder</code>是一个<code>chunk</code>指针，分配区上次分配<code>small chunk</code>时，从一个<code>chunk</code>中分裂出一个<code>small chunk</code>返回给用户，分裂后的剩余部分形成一个<code>chunk</code>，<code>last_remainder</code>就是指向的这个<code>chunk</code>。</p>
<p><code>bins</code>用于存储<code>unstored bin</code>，<code>small bins</code>和<code>large bins</code>的<code>chunk</code>链表头，<code>small bins</code>一共62个，<code>large bins</code>一共63个，加起来一共125个<code>bin</code>。而<code>NBINS</code>定义为128，其实<code>bin[0]</code>和<code>bin[127]</code>都不存在，<code>bin[1]</code>为<code>unsorted bin</code>的<code>chunk</code>链表头，所以实际只有126个<code>bins</code>。<code>bins</code>数组能存放了254（<code>NBINS*2 – 2</code>）个<code>mchunkptr</code>指针，而我们实现需要存储<code>chunk</code>的实例，一般情况下，<code>chunk</code>实例的大小为6个<code>mchunkptr</code>大小，这254个指针的大小怎么能存下126个<code>chunk</code>呢？</p>
<p>这里使用了一个技巧，如果按照我们的常规想法，也许会申请126个<code>malloc_chunk</code>结构体指针元素的数组，然后再给链表申请一个头节点（即126个），再让每个指针元素正确指向而形成126个具有头节点的链表。事实上，对于<code>malloc_chunk</code>类型的链表“头节点”，其内的<code>prev_size</code>和<code>size</code>字段是没有任何实际作用的，<code>fd_nextsize</code>和<code>bk_nextsize</code>字段只有<code>large bins</code>中的空闲<code>chunk</code>才会用到，而对于<code>large bins</code>的空闲<code>chunk</code>链表头不需要这两个字段，因此这四个字段所占空间如果不合理使用的话那就是白白的浪费。</p>
<p>我们再来看一看128个<code>malloc_chunk</code>结构体指针元素的数组占了多少内存空间呢？假设<code>SIZE_SZ</code>的大小为<code>8B</code>，则指针的大小也为<code>8B</code>，结果为<code>126*2*8=2016</code>字节。而126个<code>malloc_chunk</code>类型的链表“头节点”需要多少内存呢？ <code>126*6*8=6048</code>，真的是6048B么？不是，刚才不是说了，<code>prev_size</code>，<code>size</code>，<code>fd_nextsize</code>和<code>bk_nextsize</code>这四个字段是没有任何实际作用的，因此完全可以被重用（覆盖），因此实际需要内存为<code>126*2*8=2016</code>。<code>bins</code>指针数组的大小为，<code>(128*2-2) *8=2032</code>，2032大于2016（事实上最后16个字节都被浪费掉了），那么这254个<code>malloc_chunk</code>结构体指针元素数组所占内存空间就可以存储这126个头节点了。</p>
<p><code>binmap</code>字段是一个<code>int</code>数组，<code>ptmalloc</code>用一个<code>bit</code>来标识该<code>bit</code>对应的<code>bin</code>中是否包含空闲<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Binmap</span></span><br><span class="line"><span class="comment">To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">structure is used for bin-by-bin searching. `binmap&#x27; is a</span></span><br><span class="line"><span class="comment">bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">be skipped over during during traversals. The bits are NOT always</span></span><br><span class="line"><span class="comment">cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSHIFT 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE (NBINS / BITSPERMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT)-1))))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m,i) ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))</span></span><br></pre></td></tr></table></figure>
<p><code>binmap</code>一共<code>128bit</code>，16字节，4个<code>int</code>大小，<code>binmap</code>按<code>int</code>分成4个<code>block</code>，每个<code>block</code>有32个<code>bit</code>，根据<code>bin indx</code>可以使用宏<code>idx2block</code>计算出该<code>bin</code>在<code>binmap</code>对应的<code>bit</code>属于哪个<code>block</code>。<code>idx2bit</code>宏取第<code>i</code>位为1，其它位都为0的掩码，举个例子：<code>idx2bit(3)</code>为“0000 1000”（只显示8位）。<code>mark_bin</code>设置第<code>i</code>个<code>bin</code>在<code>binmap</code>中对应的<code>bit</code>位为1； <code>unmark_bin</code>设置第<code>i</code>个<code>bin</code>在<code>binmap</code>中对应的<code>bit</code>位为0；<code>get_binmap</code>获取第<code>i</code>个<code>bin</code>在<code>binmap</code>中对应的<code>bit</code>。</p>
<p><code>next</code>字段用于将分配区以单向链表链接起来。</p>
<p><code>next_free</code>字段空闲的分配区链接在单向链表中，只有在定义了<code>PER_THREAD</code>的情况下才定义该字段。</p>
<p><code>system_mem</code>字段记录了当前分配区已经分配的内存大小。</p>
<p><code>max_system_mem</code>记录了当前分配区最大能分配的内存大小。</p>
<h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><p><code>struct malloc_par</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Tunable parameters */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;<span class="number">48</span></span><br><span class="line">    INTERNAL_SIZE_T top_pad;</span><br><span class="line">    INTERNAL_SIZE_T mmap_threshold;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">    INTERNAL_SIZE_T arena_test;</span><br><span class="line">    INTERNAL_SIZE_T arena_max;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Memory map support */</span></span><br><span class="line">    <span class="type">int</span> n_mmaps;</span><br><span class="line">    <span class="type">int</span> n_mmaps_max;</span><br><span class="line">    <span class="type">int</span> max_n_mmaps;</span><br><span class="line">    <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment">    it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment">    dynamic behavior. */</span></span><br><span class="line">    <span class="type">int</span> no_dyn_threshold;</span><br><span class="line">    <span class="comment">/* Cache malloc_getpagesize */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pagesize;</span><br><span class="line">    <span class="comment">/* Statistics */</span></span><br><span class="line">    INTERNAL_SIZE_T mmapped_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_mmapped_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_total_mem; <span class="comment">/* only kept for NO_THREADS */</span></span><br><span class="line">    <span class="comment">/* First address handed out by MORECORE/sbrk. */</span></span><br><span class="line">    <span class="type">char</span>* sbrk_base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>trim_threshold</code>字段表示收缩阈值，默认为<code>128KB</code>，当每个分配区的<code>top chunk</code>大小大于这个阈值时，在一定的条件下，调用<code>free</code>时会收缩内存，减小<code>top chunk</code>的大小。由于<code>mmap</code>分配阈值的动态调整，在<code>free</code>时可能将收缩阈值修改为<code>mmap</code>分配阈值的2倍，在64位系统上，<code>mmap</code>分配阈值最大值为<code>32MB</code>，所以收缩阈值的最大值为<code>64MB</code>，在32位系统上，<code>mmap</code>分配阈值最大值为<code>512KB</code>，所以收缩阈值的最大值为<code>1MB</code>。收缩阈值可以通过函数<code>mallopt()</code>进行设置。</p>
<p><code>top_pad</code>字段表示在分配内存时是否添加额外的<code>pad</code>，默认该字段为0。</p>
<p><code>mmap_threshold</code>字段表示<code>mmap</code>分配阈值，默认值为<code>128KB</code>，在32位系统上最大值为<code>512KB</code>，64位系统上的最大值为<code>32MB</code>，由于默认开启<code>mmap</code>分配阈值动态调整，该字段的值会动态修改，但不会超过最大值。</p>
<p><code>arena_test</code>和<code>arena_max</code>用于<code>PER_THREAD</code>优化，在32位系统上<code>arena_test</code>默认值为2，64位系统上的默认值为8，当每个进程的分配区数量小于等于<code>arena_test</code>时，不会重用已有的分配区。为了限制分配区的总数，用<code>arena_max</code>来保存分配区的最大数量，当系统中的分配区数量达到<code>arena_max</code>，就不会再创建新的分配区，只会重用已有的分配区。这两个字段都可以使用<code>mallopt()</code>函数设置。</p>
<p><code>n_mmaps</code>字段表示当前进程使用<code>mmap()</code>函数分配的内存块的个数。</p>
<p><code>n_mmaps_max</code>字段表示进程使用<code>mmap()</code>函数分配的内存块的最大数量，默认值为4965536，可以使用<code>mallopt()</code>函数修改。</p>
<p><code>max_n_mmaps</code>字段表示当前进程使用<code>mmap()</code>函数分配的内存块的数量的最大值，有关系<code>n_mmaps &lt;= max_n_mmaps</code>成立。这个字段是由于<code>mstats()</code>函数输出统计需要这个字段。</p>
<p><code>no_dyn_threshold</code>字段表示是否开启<code>mmap</code>分配阈值动态调整机制，默认值为0，也就是默认开启<code>mmap</code>分配阈值动态调整机制。</p>
<p><code>pagesize</code>字段表示系统的页大小，默认为4KB。<code>mmapped_mem</code>和<code>max_mmapped_mem</code>都用于统计<code>mmap</code>分配的内存大小，一般情况下两个字段的值相等，<code>max_mmapped_mem</code>用于<code>mstats()</code>函数。</p>
<p><code>max_total_mem</code>字段在单线程情况下用于统计进程分配的内存总数。<code>sbrk_base</code>字段表示堆的起始地址。</p>
<h3 id="分配区的初始化"><a href="#分配区的初始化" class="headerlink" title="分配区的初始化"></a>分配区的初始化</h3><p><code>ptmalloc</code>定义了如下几个全局变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are several instances of this struct (&quot;arenas&quot;) in this</span></span><br><span class="line"><span class="comment">malloc. If you are adapting this malloc in a way that does NOT use</span></span><br><span class="line"><span class="comment">a static or mmapped malloc_state, you MUST explicitly zero-fill it</span></span><br><span class="line"><span class="comment">before using. This malloc relies on the property that malloc_state</span></span><br><span class="line"><span class="comment">is initialized to all zeroes (as is true of C statics). */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span>;</span></span><br><span class="line"><span class="comment">/* There is only one instance of the malloc parameters. */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span>;</span></span><br><span class="line"><span class="comment">/* Maximum size of memory handled in fastbins. */</span></span><br><span class="line"><span class="type">static</span> INTERNAL_SIZE_T global_max_fast;</span><br></pre></td></tr></table></figure></p>
<p><code>main_arena</code>表示主分配区，任何进程有且仅有一个全局的主分配区，<code>mp_</code>是全局唯一的一个<code>malloc_par</code>实例，用于管理参数和统计信息，<code>global_max_fast</code>全局变量表示<code>fast bins</code>中最大的<code>chunk</code>大小。</p>
<p>分配区<code>main_arena</code>初始化函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Initialize a malloc_state struct.</span></span><br><span class="line"><span class="comment">This is called only from within malloc_consolidate, which needs</span></span><br><span class="line"><span class="comment">be called in the same contexts anyway. It is never called directly</span></span><br><span class="line"><span class="comment">outside of malloc_consolidate because some optimizing compilers try</span></span><br><span class="line"><span class="comment">to inline it at all call points, which turns out not to be an</span></span><br><span class="line"><span class="comment">optimization at all. (Inlining it in malloc_consolidate is fine though.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_init_state</span><span class="params">(mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_init_state</span><span class="params">(av)</span> mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    mbinptr bin;</span><br><span class="line">    <span class="comment">/* Establish circular links for normal bins */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) &#123;</span><br><span class="line">        bin = bin_at(av,i);</span><br><span class="line">        bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        set_noncontiguous(av);</span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">        set_max_fast(DEFAULT_MXFAST);</span><br><span class="line">    av-&gt;flags |= FASTCHUNKS_BIT;</span><br><span class="line">    av-&gt;top = initial_top(av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分配区的初始化函数默认分配区的实例<code>av</code>是全局静态变量或是已经将<code>av</code>中的所有字段都清0了。初始化函数做的工作比较简单，首先遍历所有的<code>bins</code>，初始化每个<code>bin</code>的空闲链表为空，即将<code>bin</code>的<code>fb</code>和<code>bk</code>都指向<code>bin</code>本身。由于<code>av</code>中所有字段默认为0，即默认分配连续的虚拟地址空间，但只有主分配区才能分配连续的虚拟地址空间，所以对于非主分配区，需要设置为分配非连续虚拟地址空间。如果初始化的是主分配区，需要设置<code>fast bins</code>中最大<code>chunk</code>大小，由于主分配区只有一个，并且一定是最先初始化，这就保证了对全局变量<code>global_max_fast</code>只初始化了一次，只要该全局变量的值非0，也就意味着主分配区初始化了。最后初始化<code>top chunk</code>。</p>
<p><code>ptmalloc</code>参数初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set up basic state so that _int_malloc et al can work. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_init_minimal</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEFAULT_TOP_PAD != 0</span></span><br><span class="line">    mp_.top_pad = DEFAULT_TOP_PAD;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    mp_.n_mmaps_max = DEFAULT_MMAP_MAX;</span><br><span class="line">    mp_.mmap_threshold = DEFAULT_MMAP_THRESHOLD;</span><br><span class="line">    mp_.trim_threshold = DEFAULT_TRIM_THRESHOLD;</span><br><span class="line">    mp_.pagesize = malloc_getpagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span></span><br><span class="line">    mp_.arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>);</span><br><span class="line">    narenas = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是将全局变量<code>mp_</code>的字段初始化为默认值，值得一提的是，如果定义了编译选项<code>PER_THREAD</code>，会根据系统<code>cpu</code>的个数设置<code>arena_test</code>的值，默认32位系统是双核，64位系统为8核，<code>arena_test</code>也就设置为相应的值。</p>
<h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><p><code>ptmalloc</code>的配置选项不多，在3.2.6节已经做过概要描述，这里给出<code>mallopt()</code>函数的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mallopt</span><span class="params">(<span class="type">int</span> param_number, <span class="type">int</span> value)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mallopt</span><span class="params">(param_number, value)</span> <span class="type">int</span> param_number; <span class="type">int</span> value;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mstate av = &amp;main_arena;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">0</span>)</span><br><span class="line">        ptmalloc_init ();</span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">    <span class="comment">/* Ensure initialization/consolidation */</span></span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">    <span class="keyword">switch</span>(param_number) &#123;</span><br><span class="line">        <span class="keyword">case</span> M_MXFAST:</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= MAX_FAST_SIZE) &#123;</span><br><span class="line">                set_max_fast(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_TRIM_THRESHOLD:</span><br><span class="line">            mp_.trim_threshold = value;</span><br><span class="line">            mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_TOP_PAD:</span><br><span class="line">            mp_.top_pad = value;</span><br><span class="line">            mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_MMAP_THRESHOLD:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_ARENAS</span></span><br><span class="line">            <span class="comment">/* Forbid setting the threshold too high. */</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)value &gt; HEAP_MAX_SIZE/<span class="number">2</span>)</span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                mp_.mmap_threshold = value;</span><br><span class="line">            mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_MMAP_MAX:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !HAVE_MMAP</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="number">0</span>)</span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                mp_.n_mmaps_max = value;</span><br><span class="line">            mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_CHECK_ACTION:</span><br><span class="line">            check_action = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_PERTURB:</span><br><span class="line">            perturb_byte = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">        <span class="keyword">case</span> M_ARENA_TEST:</span><br><span class="line">            <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line">                mp_.arena_test = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_ARENA_MAX:</span><br><span class="line">            <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line">                mp_.arena_max = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mallopt()</code>函数配置前，需要检查主分配区是否初始化了，如果没有初始化，调用<code>ptmalloc_init()</code>函数初始化<code>ptmalloc</code>，然后获得主分配区的锁，调用<code>malloc_consolidate()</code>函数，<code>malloc_consolidate()</code>函数会判断主分配区是否已经初始化，如果没有，则初始化主分配区。同时我们也看到，<code>mp_</code>都没有锁，对<code>mp_</code>中参数字段的修改，是通过主分配区的锁来同步的。</p>
<h2 id="ptmalloc的初始化"><a href="#ptmalloc的初始化" class="headerlink" title="ptmalloc的初始化"></a>ptmalloc的初始化</h2><p><code>ptmalloc</code>的初始化发生在进程的第一个内存分配请求，当<code>ptmalloc</code>的初始化一般都在用户的第一次调用<code>malloc()</code>或<code>remalloc()</code>之前，因为操作系统和<code>Glibc</code>库为进程的初始化做了不少工作，在用户分配内存以前，<code>Glibc</code>已经分配了多次内存。在<code>ptmalloc</code>中<code>malloc()</code>函数的实际接口函数为<code>public_malloc()</code>，这个函数最开始会执行如下的一段代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__malloc_ptr_t</span> (*hook) (<span class="type">size_t</span>, __const <span class="type">__malloc_ptr_t</span>) = force_reg (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure></p>
<p>在定义了<code>__malloc_hook()</code>全局函数的情况下，只是执行<code>__malloc_hook()</code>函数，在进程初始化时<code>__malloc_hook</code>指向的函数为<code>malloc_hook_ini()</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__malloc_ptr_t</span> <span class="title function_">weak_variable</span> <span class="params">(*__malloc_hook)</span></span><br><span class="line"><span class="params">(<span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">__malloc_ptr_t</span>)</span> = malloc_hook_ini;</span><br></pre></td></tr></table></figure></p>
<p><code>malloc_hook_ini()</code>函数定义在<code>hooks.c</code>中，实现代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void_t</span>*</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">malloc_hook_ini(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">__malloc_ptr_t</span> caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">malloc_hook_ini(sz, caller)</span><br><span class="line"><span class="type">size_t</span> sz; </span><br><span class="line"><span class="type">const</span> <span class="type">__malloc_ptr_t</span> caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    __malloc_hook = <span class="literal">NULL</span>;</span><br><span class="line">    ptmalloc_init();</span><br><span class="line">    <span class="keyword">return</span> public_malloc(sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>malloc_hook_ini()</code>函数处理很简单，就是调用<code>ptmalloc</code>的初始化函数<code>ptmalloc_init()</code>，然后再重新调用<code>pbulit_malloc()</code>函数分配内存。<code>ptmalloc_init()</code>函数在初始化<code>ptmalloc</code>完成后，将全局变量<code>__malloc_initialized</code>设置为1，当<code>pbulit_malloc()</code>函数再次执行时，先执行<code>malloc_hook_ini()</code>函数，<code>malloc_hook_ini()</code>函数调用<code>ptmalloc_init()</code>，<code>ptmalloc_init()</code>函数首先判断<code>__malloc_initialized</code>是否为1，如果是，则退出<code>ptmalloc_init()</code>，不再执行<code>ptmalloc</code>初始化。</p>
<h3 id="ptmalloc未初始化时分配-释放内存"><a href="#ptmalloc未初始化时分配-释放内存" class="headerlink" title="ptmalloc未初始化时分配/释放内存"></a>ptmalloc未初始化时分配/释放内存</h3><p>当<code>ptmalloc</code>的初始化函数<code>ptmalloc_init()</code>还没有调用之前，<code>Glibc</code>中可能需要分配内存，比如线程私有实例的初始化需要分配内存，为了解决这一问题，<code>ptmalloc</code>封装了内部的分配释放函数供在这种情况下使用。<code>ptmalloc</code>提供了三个函数，<code>malloc_starter()</code>，<code>memalign_starter()</code>，<code>free_starter()</code>，但没有提供<code>realloc_starter()</code>函数。这几个函数的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void_t</span>*</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">malloc_starter(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void_t</span> *caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">malloc_starter(sz, caller) <span class="type">size_t</span> sz; <span class="type">const</span> <span class="type">void_t</span> *caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void_t</span>* victim;</span><br><span class="line">    victim = _int_malloc(&amp;main_arena, sz);</span><br><span class="line">    <span class="keyword">return</span> victim ? BOUNDED_N(victim, sz) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void_t</span>*</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">memalign_starter(<span class="type">size_t</span> align, <span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void_t</span> *caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">memalign_starter(align, sz, caller) <span class="type">size_t</span> align, sz; <span class="type">const</span> <span class="type">void_t</span> *caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void_t</span>* victim;</span><br><span class="line">    victim = _int_memalign(&amp;main_arena, align, sz);</span><br><span class="line">    <span class="keyword">return</span> victim ? BOUNDED_N(victim, sz) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">free_starter(<span class="type">void_t</span>* mem, <span class="type">const</span> <span class="type">void_t</span> *caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">free_starter(mem, caller) <span class="type">void_t</span>* mem; <span class="type">const</span> <span class="type">void_t</span> *caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mchunkptr p;</span><br><span class="line">    <span class="keyword">if</span>(!mem) <span class="keyword">return</span>;</span><br><span class="line">    p = mem2chunk(mem);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) &#123;</span><br><span class="line">        munmap_chunk(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    _int_free(&amp;main_arena, p, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    _int_free(&amp;main_arena, p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的实现都很简单，只是调用<code>ptmalloc</code>的内部实现函数。</p>
<h3 id="ptmalloc-init-函数"><a href="#ptmalloc-init-函数" class="headerlink" title="ptmalloc_init()函数"></a>ptmalloc_init()函数</h3><p><code>ptmalloc_init()</code>函数比较长，将分段对这个函数做介绍。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* s;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">char</span>* s;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> secure = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(__malloc_initialized &gt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    __malloc_initialized = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>首先检查全局变量<code>__malloc_initialized</code>是否大于等于0，如果该值大于0，表示<code>ptmalloc</code>已经初始化，如果改值为0，表示<code>ptmalloc</code>正在初始化，全局变量<code>__malloc_initialized</code>用来保证全局只初始化<code>ptmalloc</code>一次。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined SHARED &amp;&amp; !USE___THREAD</span></span><br><span class="line"><span class="comment">/* ptmalloc_init_minimal may already have been called via</span></span><br><span class="line"><span class="comment">   __libc_malloc_pthread_startup, above. */</span></span><br><span class="line"><span class="keyword">if</span> (mp_.pagesize == <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ptmalloc_init_minimal();</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_THREADS</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC</span></span><br><span class="line"><span class="comment">/* We know __pthread_initialize_minimal has already been called, and that is enough. */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> NO_STARTER</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> NO_STARTER</span></span><br><span class="line"><span class="comment">/* With some threads implementations, creating thread-specific data</span></span><br><span class="line"><span class="comment">or initializing a mutex may call malloc() itself. Provide a simple starter version (realloc() wont work). */</span></span><br><span class="line">save_malloc_hook = __malloc_hook;</span><br><span class="line">save_memalign_hook = __memalign_hook;</span><br><span class="line">save_free_hook = __free_hook;</span><br><span class="line">__malloc_hook = malloc_starter;</span><br><span class="line">__memalign_hook = memalign_starter;</span><br><span class="line">__free_hook = free_starter;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line"><span class="comment">/* Initialize the pthreads interface. */</span></span><br><span class="line"><span class="keyword">if</span> (__pthread_initialize != <span class="literal">NULL</span>)</span><br><span class="line">__pthread_initialize();</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> <span class="comment">/* !defined _LIBC */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> <span class="comment">/* !defined NO_STARTER */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !defined NO_THREADS */</span></span></span><br></pre></td></tr></table></figure></p>
<p>为多线程版本的<code>ptmalloc</code>的<code>pthread</code>初始化做准备，保存当前的<code>hooks</code>函数，并把<code>ptmalloc</code>为初始化时所有使用的分配/释放函数赋给<code>hooks</code>函数，因为在线程初始化一些私有实例时，<code>ptmalloc</code>还没有初始化，所以需要做特殊处理。从这些<code>hooks</code>函数可以看出，在<code>ptmalloc</code>未初始化时，不能使用<code>remalloc</code>函数。在相关的<code>hooks</code>函数赋值以后，执行<code>pthread_initilaize()</code>初始化<code>pthread</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutex_init(&amp;main_arena.mutex);</span><br><span class="line">main_arena.next = &amp;main_arena;</span><br></pre></td></tr></table></figure></p>
<p>初始化主分配区的<code>mutex</code>，并将主分配区的<code>next</code>指针指向自身组成环形链表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC &amp;&amp; defined SHARED</span></span><br><span class="line"><span class="comment">/* In case this libc copy is in a non-default namespace, never use brk.</span></span><br><span class="line"><span class="comment">Likewise if dlopened from statically linked program. */</span></span><br><span class="line">Dl_info di;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line"><span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">|| (_dl_addr (ptmalloc_init, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">&amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">    __morecore = __failing_morecore;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>ptmalloc</code>需要保证只有主分配区才能使用<code>sbrk()</code>分配连续虚拟内存空间，如果有多个分配区使用<code>sbrk()</code>就不能获得连续的虚拟地址空间，大多数情况下<code>Glibc</code>库都是以动态链接库的形式加载的，处于默认命名空间，多个进程共用<code>Glibc</code>库，<code>Glibc</code>库代码段在内存中只有一份拷贝，数据段在每个用户进程都有一份拷贝。但如果<code>Glibc</code>库不在默认名字空间，或是用户程序是静态编译的并调用了<code>dlopen</code>函数加载<code>Glibc</code>库中的<code>ptamalloc_init()</code>，这种情况下的<code>ptmalloc</code>不允许使用<code>sbrk()</code>分配内存，只需修改<code>__morecore</code>函数指针指向<code>__failing_morecore</code>就可以禁止使用<code>sbrk()</code>了，<code>__morecore</code>默认指向<code>sbrk()</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex_init(&amp;list_lock);</span><br><span class="line">tsd_key_create(&amp;arena_key, <span class="literal">NULL</span>);</span><br><span class="line">tsd_setspecific(arena_key, (<span class="type">void_t</span> *)&amp;main_arena);</span><br><span class="line">thread_atfork(ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2);</span><br></pre></td></tr></table></figure></p>
<p>初始化全局锁<code>list_lock</code>，<code>list_lock</code>主要用于同步分配区的单向循环链表。然后创建线程私有实例<code>arena_key</code>，该私有实例保存的是分配区（<code>arena</code>）的<code>malloc_state</code>实例指针。<code>arena_key</code>指向的可能是主分配区的指针，也可能是非主分配区的指针，这里将调用<code>ptmalloc_init()</code>的线程的<code>arena_key</code>绑定到主分配区上。意味着本线程首选从主分配区分配内存。</p>
<p>然后调用<code>thread_atfork()</code>设置当前进程在<code>fork</code>子线程（linux下线程是轻量级进程，使用类似<code>fork</code>进程的机制创建）时处理<code>mutex</code>的回调函数，在本进程<code>fork</code>子线程时，调用<code>ptmalloc_lock_all()</code>获得所有分配区的锁，禁止所有分配区分配内存，当子线程创建完毕，父进程调用<code>ptmalloc_unlock_all()</code>重新<code>unlock</code>每个分配区的锁<code>mutex</code>，子线程调用<code>ptmalloc_unlock_all2()</code>重新初始化每个分配区的锁<code>mutex</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_THREADS</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> NO_STARTER</span></span><br><span class="line">__malloc_hook = save_malloc_hook;</span><br><span class="line">__memalign_hook = save_memalign_hook;</span><br><span class="line">__free_hook = save_free_hook;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">undef</span> NO_STARTER</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>当<code>pthread</code>初始化完成后，将相应的<code>hooks</code>函数还原为原值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">secure = __libc_enable_secure;</span><br><span class="line">s = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (_environ != <span class="literal">NULL</span>, <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> **runp = _environ;</span><br><span class="line">    <span class="type">char</span> *envline;</span><br><span class="line">    <span class="keyword">while</span> (__builtin_expect ((envline = next_env_entry (&amp;runp)) != <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> len = <span class="built_in">strcspn</span> (envline, <span class="string">&quot;=&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (envline[len] != <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">        <span class="comment">/* This is a &quot;MALLOC_&quot; variable at the end of the string58</span></span><br><span class="line"><span class="comment">        without a &#x27;=&#x27; character. Ignore it since otherwise we</span></span><br><span class="line"><span class="comment">        will access invalid memory below. */</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">switch</span> (len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;CHECK_&quot;</span>, <span class="number">6</span>) == <span class="number">0</span>)</span><br><span class="line">                    s = &amp;envline[<span class="number">7</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">if</span> (! secure)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TOP_PAD_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">                        mALLOPt(M_TOP_PAD, atoi(&amp;envline[<span class="number">9</span>]));</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;PERTURB_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">                        mALLOPt(M_PERTURB, atoi(&amp;envline[<span class="number">9</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                <span class="keyword">if</span> (! secure)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_MAX_&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">                        mALLOPt(M_MMAP_MAX, atoi(&amp;envline[<span class="number">10</span>]));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_MAX&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">                        mALLOPt(M_ARENA_MAX, atoi(&amp;envline[<span class="number">10</span>]));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> (! secure)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_TEST&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>)</span><br><span class="line">                    mALLOPt(M_ARENA_TEST, atoi(&amp;envline[<span class="number">11</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">                <span class="keyword">if</span> (! secure)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TRIM_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">                        mALLOPt(M_TRIM_THRESHOLD, atoi(&amp;envline[<span class="number">16</span>]));<span class="number">59</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">                        mALLOPt(M_MMAP_THRESHOLD, atoi(&amp;envline[<span class="number">16</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> (! secure)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_TRIM_THRESHOLD_&quot;</span>)))</span><br><span class="line">        mALLOPt(M_TRIM_THRESHOLD, atoi(s));</span><br><span class="line">    <span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_TOP_PAD_&quot;</span>)))</span><br><span class="line">        mALLOPt(M_TOP_PAD, atoi(s));</span><br><span class="line">    <span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_PERTURB_&quot;</span>)))</span><br><span class="line">        mALLOPt(M_PERTURB, atoi(s));</span><br><span class="line">    <span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_MMAP_THRESHOLD_&quot;</span>)))</span><br><span class="line">        mALLOPt(M_MMAP_THRESHOLD, atoi(s));</span><br><span class="line">    <span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_MMAP_MAX_&quot;</span>)))</span><br><span class="line">        mALLOPt(M_MMAP_MAX, atoi(s));</span><br><span class="line">&#125;</span><br><span class="line">s = getenv(<span class="string">&quot;MALLOC_CHECK_&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span>(s &amp;&amp; s[<span class="number">0</span>]) &#123;</span><br><span class="line">    mALLOPt(M_CHECK_ACTION, (<span class="type">int</span>)(s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">if</span> (check_action != <span class="number">0</span>)</span><br><span class="line">        __malloc_check_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从环境变量中读取相应的配置参数值，这些参数包括<code>MALLOC_TRIM_THRESHOLD_</code>，<code>MALLOC_TOP_PAD_</code>，<code>MALLOC_PERTURB_</code>，<code>MALLOC_MMAP_THRESHOLD_</code>，<code>MALLOC_CHECK_</code>，<code>MALLOC_MMAP_MAX_</code>，<code>MALLOC_ARENA_MAX</code>，<code>MALLOC_ARENA_TEST</code>，如果这些选项中的某些项存在，调用<code>mallopt()</code>函数设置相应的选项。如果这段程序是在<code>Glibc</code>库初始化中执行的，会做更多的安全检查工作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span>) = force_reg (__malloc_initialize_hook);</span><br><span class="line"><span class="keyword">if</span> (hook != <span class="literal">NULL</span>)</span><br><span class="line">    (*hook)();</span><br><span class="line">__malloc_initialized = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>在<code>ptmalloc_init()</code>函数结束处，查看是否存在<code>__malloc_initialize_hook</code>函数，如果存在，执行该<code>hook</code>函数。最后将全局变量<code>__malloc_initialized</code>设置为1，表示<code>ptmalloc_init()</code>已经初始化完成。</p>
<h3 id="ptmalloc-lock-all-ptmalloc-unlock-all-ptmalloc-unlock-all2"><a href="#ptmalloc-lock-all-ptmalloc-unlock-all-ptmalloc-unlock-all2" class="headerlink" title="ptmalloc_lock_all(),ptmalloc_unlock_all(),ptmalloc_unlock_all2()"></a>ptmalloc_lock_all(),ptmalloc_unlock_all(),ptmalloc_unlock_all2()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Magic value for the thread-specific arena pointer when</span></span><br><span class="line"><span class="comment">malloc_atfork() is in use. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATFORK_ARENA_PTR ((void_t*)-1)</span></span><br><span class="line"><span class="comment">/* The following hooks are used while the `atfork&#x27; handling mechanism is active. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void_t</span>*</span><br><span class="line"><span class="title function_">malloc_atfork</span><span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void_t</span> *caller)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void_t</span> *vptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void_t</span> *victim;</span><br><span class="line">    tsd_getspecific(arena_key, vptr);</span><br><span class="line">    <span class="keyword">if</span>(vptr == ATFORK_ARENA_PTR) &#123;</span><br><span class="line">        <span class="comment">/* We are the only thread that may allocate at all. */</span></span><br><span class="line">        <span class="keyword">if</span>(save_malloc_hook != malloc_check) &#123;</span><br><span class="line">            <span class="keyword">return</span> _int_malloc(&amp;main_arena, sz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(top_check()&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            victim = _int_malloc(&amp;main_arena, sz+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> mem2mem_check(victim, sz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Suspend the thread until the `atfork&#x27; handlers have completed.</span></span><br><span class="line"><span class="comment">        By that time, the hooks will have been reset as well, so that</span></span><br><span class="line"><span class="comment">        malloc() can be used again. */</span></span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line">        <span class="keyword">return</span> public_malloc(sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当父进程中的某个线程使用<code>fork</code>的机制创建子线程时，如果进程中的线程需要分配内存，将使用<code>malloc_atfork()</code>函数分配内存。<code>malloc_atfork()</code>函数首先查看自己的线程私有实例中的分配区指针，如果该指针为<code>ATFORK_ARENA_PTR</code>，意味着本线程正在<code>fork</code>新线程，并锁住了全局锁<code>list_lock</code>和每个分配区，当前只有本线程可以分配内存，如果在<code>fork</code>线程前的分配函数不是处于<code>check</code>模式，直接调用内部分配函数<code>_int_malloc()</code>。否则在分配内存的同时做检查。如果线程私有实例中的指针不是<code>ATFORK_ARENA_PTR</code>，意味着当前线程只是常规线程，有另外的线程在<code>fork</code>子线程，当前线程只能等待<code>fork</code>子线程的线程完成分配，于是等待获得全局锁<code>list_lock</code>，如果获得全局锁成功，表示<code>fork</code>子线程的线程已经完成<code>fork</code>操作，当前线程可以分配内存了，于是是释放全局所<code>list_lock</code>，并调用<code>public_malloc()</code>分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">free_atfork</span><span class="params">(<span class="type">void_t</span>* mem, <span class="type">const</span> <span class="type">void_t</span> *caller)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void_t</span> *vptr = <span class="literal">NULL</span>;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p = mem2chunk(mem); <span class="comment">/* do not bother to replicate free_check here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">        munmap_chunk(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    ar_ptr = arena_for_chunk(p);</span><br><span class="line">    tsd_getspecific(arena_key, vptr);</span><br><span class="line">    _int_free(ar_ptr, p, vptr == ATFORK_ARENA_PTR);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ar_ptr = arena_for_chunk(p);</span><br><span class="line">    tsd_getspecific(arena_key, vptr);</span><br><span class="line">    <span class="keyword">if</span>(vptr != ATFORK_ARENA_PTR)</span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">    _int_free(ar_ptr, p);</span><br><span class="line">    <span class="keyword">if</span>(vptr != ATFORK_ARENA_PTR)</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当父进程中的某个线程使用<code>fork</code>的机制创建子线程时，如果进程中的线程需要释放内存，将使用<code>free_atfork()</code>函数释放内存。 <code>free_atfork()</code>函数首先通过需<code>free</code>的内存块指针获得<code>chunk</code>的指针，如果该<code>chunk</code>是通过<code>mmap</code>分配的，调用<code>munmap()</code>释放该<code>chunk</code>，否则调用<code>_int_free()</code>函数释放内存。在调用<code>_int_free()</code>函数前，先根据<code>chunk</code>指针获得分配区指针，并读取本线程私用实例的指针，如果开启了<code>ATOMIC_FASTBINS</code>优化，这个优化使用了<code>lock-free</code>的技术优化<code>fastbins</code>中单向链表操作。如果没有开启了<code>ATOMIC_FASTBINS</code>优化，并且当前线程没有正在<code>fork</code>新子线程，则对分配区加锁，然后调用<code>_int_free()</code>函数，然后对分配区解锁。而对于正在<code>fork</code>子线程的线程来说，是不需要对分配区加锁的，因为该线程已经对所有的分配区加锁了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Counter for number of times the list is locked by the same thread. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> atfork_recursive_cntr;</span><br><span class="line"><span class="comment">/* The following two functions are registered via thread_atfork() to</span></span><br><span class="line"><span class="comment">make sure that the mutexes remain in a consistent state in the</span></span><br><span class="line"><span class="comment">fork()ed version of a thread. Also adapt the malloc and free hooks</span></span><br><span class="line"><span class="comment">temporarily, because the `atfork&#x27; handler mechanism may use</span></span><br><span class="line"><span class="comment">malloc/free internally (e.g. in LinuxThreads). */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_lock_all</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (mutex_trylock(&amp;list_lock))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void_t</span> *my_arena;</span><br><span class="line">        tsd_getspecific(arena_key, my_arena);</span><br><span class="line">        <span class="keyword">if</span> (my_arena == ATFORK_ARENA_PTR)</span><br><span class="line">        <span class="comment">/* This is the same thread which already locks the global list.</span></span><br><span class="line"><span class="comment">        Just bump the counter. */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="comment">/* This thread has to wait its turn. */</span></span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ar_ptr = &amp;main_arena;;) &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        ar_ptr = ar_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(ar_ptr == &amp;main_arena) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    save_malloc_hook = __malloc_hook;</span><br><span class="line">    save_free_hook = __free_hook;</span><br><span class="line">    __malloc_hook = malloc_atfork;</span><br><span class="line">    __free_hook = free_atfork;</span><br><span class="line">    <span class="comment">/* Only the current thread may perform malloc/free calls now. */</span></span><br><span class="line">    tsd_getspecific(arena_key, save_arena);</span><br><span class="line">    tsd_setspecific(arena_key, ATFORK_ARENA_PTR);</span><br><span class="line">out:</span><br><span class="line">    ++atfork_recursive_cntr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当父进程中的某个线程使用<code>fork</code>的机制创建子线程时，首先调用<code>ptmalloc_lock_all()</code>函数暂时对全局锁<code>list_lock</code>和所有的分配区加锁，从而保证分配区状态的一致性。<code>ptmalloc_lock_all()</code>函数首先检查<code>ptmalloc</code>是否已经初始化，如果没有初始化，退出，如果已经初始化，尝试对全局锁<code>list_lock</code>加锁，直到获得全局锁<code>list_lock</code>，接着对所有的分配区加锁，接着保存原有的分配释放函数，将<code>malloc_atfork()</code>和<code>free_atfork()</code>函数作为<code>fork</code>子线程期间所使用的内存分配释放函数，然后保存当前线程的私有实例中的原有分配区指针，将<code>ATFORK_ARENA_PTR</code>存放到当前线程的私有实例中，用于标识当前现在正在<code>fork</code>子线程。为了保证父线程<code>fork</code>多个子线程工作正常，也就是说当前线程需要<code>fork</code>多个子线程，当一个子线程已经创建，当前线程继续创建其它子线程时，发现当前线程已经对<code>list_lock</code>和所有分配区加锁，于是对全局变量<code>atfork_recursive_cntr</code>加1，表示递归<code>fork</code>子线程的层数，保证父线程在<code>fork</code>子线程过程中，调用<code>ptmalloc_unlock_all()</code>函数加锁的次数与调用<code>ptmalloc_lock_all()</code>函数解锁的次数保持一致，同时也保证保证所有的子线程调用<code>ptmalloc_unlock_all()</code>函数加锁的次数与父线程调用<code>ptmalloc_lock_all()</code>函数解锁的次数保持一致，防止没有释放锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_unlock_all</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (--atfork_recursive_cntr != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    tsd_setspecific(arena_key, save_arena);</span><br><span class="line">    __malloc_hook = save_malloc_hook;</span><br><span class="line">    __free_hook = save_free_hook;</span><br><span class="line">    <span class="keyword">for</span>(ar_ptr = &amp;main_arena;;) &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        ar_ptr = ar_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(ar_ptr == &amp;main_arena) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当进程的某个线程完成<code>fork</code>子线程后，父线程和子线程都调用<code>ptmall_unlock_all()</code>函数释放全局锁<code>list_lock</code>，释放所有分配区的锁。<code>ptmall_unlock_all()</code>函数首先检查<code>ptmalloc</code>是否初始化，只有初始化后才能调用该函数，接着将全局变量<code>atfork_recursive_cntr</code>减1，如果<code>atfork_recursive_cntr</code>为0，才继续执行，这保证了递归<code>fork</code>子线程只会解锁一次。接着将当前线程的私有实例还原为原来的分配区，<code>__malloc_hook</code>和<code>__free_hook</code>还原为由来的<code>hook</code>函数。然后遍历所有分配区，依次解锁每个分配区，最后解锁<code>list_lock</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __linux__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* In NPTL, unlocking a mutex in the child process after a </span></span><br><span class="line"><span class="comment">fork() is currently unsafe, whereas re-initializing it is safe and</span></span><br><span class="line"><span class="comment">does not leak resources. Therefore, a special atfork handler is</span></span><br><span class="line"><span class="comment">installed for the child. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_unlock_all2</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined MALLOC_HOOKS</span></span><br><span class="line">    tsd_setspecific(arena_key, save_arena);</span><br><span class="line">    __malloc_hook = save_malloc_hook;</span><br><span class="line">    __free_hook = save_free_hook;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">    free_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(ar_ptr = &amp;main_arena;;) &#123;</span><br><span class="line">        mutex_init(&amp;ar_ptr-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">        <span class="keyword">if</span> (ar_ptr != save_arena) &#123;</span><br><span class="line">            ar_ptr-&gt;next_free = free_list;</span><br><span class="line">            free_list = ar_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        ar_ptr = ar_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(ar_ptr == &amp;main_arena) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_init(&amp;list_lock);</span><br><span class="line">    atfork_recursive_cntr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ptmalloc_unlock_all2 ptmalloc_unlock_all</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>函数<code>ptmalloc_unlock_all2()</code>被<code>fork</code>出的子线程调用，在<code>Linux</code>系统中，子线程（进程）<code>unlock</code>从父线程（进程）中继承的<code>mutex</code>不安全，会导致资源泄漏，但重新初始化<code>mutex</code>是安全的，所有增加了这个特殊版本用于<code>Linux</code>下的<code>atfork handler</code>。<code>ptmalloc_unlock_all2()</code>函数的处理流程跟<code>ptmalloc_unlock_all()</code>函数差不多，使用<code>mutex_init()</code>代替了<code>mutex_unlock()</code>，如果开启了<code>PER_THREAD</code>的优化，将从父线程中继承来的分配区加入到<code>free_list</code>中，对于子线程来说，无论全局变量<code>atfork_recursive_cntr</code>的值是多少，都将该值设置为0，因为<code>ptmalloc_unlock_all2()</code>函数只会被子线程调用一次。</p>
<h2 id="多分配区支持"><a href="#多分配区支持" class="headerlink" title="多分配区支持"></a>多分配区支持</h2><p>由于只有一个主分配区从堆中分配小内存块，而稍大的内存块都必须从<code>mmap</code>映射区域分配，如果有多个线程都要分配小内存块，但多个线程是不能同时调用<code>sbrk()</code>函数的，因为只有一个函数调用<code>sbrk()</code>时才能保证分配的虚拟地址空间是连续的。如果多个线程都从主分配区中分配小内存块，效率很低效。为了解决这个问题，<code>ptmalloc</code>使用非主分配区来模拟主分配区的功能，非主分配区同样可以分配小内存块，并且可以创建多个非主分配区，从而在线程分配内存竞争比较激烈的情况下，可以创建更多的非主分配区来完成分配任务，减少分配区的锁竞争，提高分配效率。</p>
<p><code>ptmalloc</code>怎么用非主分配区来模拟主分配区的行为呢？首先创建一个新的非主分配区，非主分配区使用<code>mmap()</code>函数分配一大块内存来模拟堆（sub-heap），所有的从该非主分配区总分配的小内存块都从<code>sub-heap</code>中切分出来，如果一个<code>sub-heap</code>的内存用光了，或是<code>sub-heap</code>中的内存不够用时，使用<code>mmap()</code>分配一块新的内存块作为<code>sub-heap</code>，并将新的<code>sub-heap</code>链接在非主分配区中<code>sub-heap</code>的单向链表中。</p>
<p>分主分配区中的<code>sub-heap</code>所占用的内存不会无限的增长下去，同样会像主分配区那样进行进行<code>sub-heap</code>收缩，将<code>sub-heap</code>中<code>top chunk</code>的一部分返回给操作系统，如果<code>top chunk</code>为整个<code>sub-heap</code>，会把整个<code>sub-heap</code>还回给操作系统。收缩堆的条件是当前<code>free</code>的<code>chunk</code>大小加上前后能合并<code>chunk</code>的大小大于<code>64KB</code>，并且<code>top chunk</code>的大小达到<code>mmap</code>收缩阈值，才有可能收缩堆。</p>
<p>一般情况下，进程中有多个线程，也有多个分配区，线程的数据一般会比分配区数量多，所以必能保证没有线程独享一个分配区，每个分配区都有可能被多个线程使用，为了保证分配区的线程安全，对分配区的访问需要锁保护，当线程获得分配区的锁时，可以使用该分配区分配内存，并将该分配区的指针保存在线程的私有实例中。</p>
<p>当某一线程需要调用<code>malloc</code>分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜分配区索循环链表试图获得一个空闲的分配区。如果所有的分配区都已经加锁，那么<code>malloc</code>会开辟一个新的分配区，把该分配区加入到分配区的全局分配区循环链表并加锁，然后使用该分配区进行分配操作。在回收操作中，线程同样试图获得待回收块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行回收操作。</p>
<h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p><code>struct heap_info</code>定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">malloc_chunks. It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">address aligned to HEAP_MAX_SIZE. Not used unless compiling with</span></span><br><span class="line"><span class="comment">USE_ARENAS. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> &#123;</span></span><br><span class="line">    mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">    <span class="type">size_t</span> size; <span class="comment">/* Current size in bytes. */</span><span class="number">66</span></span><br><span class="line">    <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */</span></span><br><span class="line">    <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">    that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">    MALLOC_ALIGNMENT. */</span></span><br><span class="line">    <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure></p>
<p><code>ar_ptr</code>是指向所属分配区的指针，<code>mstate</code>的定义为： <code>typedef struct malloc_state *mstate;</code></p>
<p><code>prev</code>字段用于将同一个分配区中的<code>sub_heap</code>用单向链表链接起来。<code>prev</code>指向链表中的前一个<code>sub_heap</code>。<code>size</code>字段表示当前<code>sub_heap</code>中的内存大小，以<code>page</code>对齐。<code>mprotect_size</code>字段表示当前<code>sub_heap</code>中被读写保护的内存大小，也就是说还没有被分配的内存大小。</p>
<p><code>pad</code>字段用于保证<code>sizeof (heap_info) + 2 * SIZE_SZ</code>是按<code>MALLOC_ALIGNMENT</code>对齐的。<code>MALLOC_ALIGNMENT_MASK</code>为<code>2 * SIZE_SZ - 1</code>，无论<code>SIZE_SZ</code>为4或8，<code>-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK</code>的值为0 ，如果<code>sizeof (heap_info) + 2 * SIZE_SZ</code>不是按<code>MALLOC_ALIGNMENT</code>对齐，编译的时候就会报错，编译时会执行下面的宏。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get a compile-time error if the heap_info padding is not correct</span></span><br><span class="line"><span class="comment">to make alignment work as expected in sYSMALLOc. */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> sanity_check_heap_info_alignment[(<span class="keyword">sizeof</span> (heap_info)</span><br><span class="line">+ <span class="number">2</span> * SIZE_SZ) % MALLOC_ALIGNMENT ? <span class="number">-1</span> : <span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>为什么一定要保证对齐呢？作为分主分配区的第一个<code>sub_heap</code>，<code>heap_info</code>存放在<code>sub_heap</code>的头部，紧跟<code>heap_info</code>之后是该非主分配区的<code>malloc_state</code>实例，紧跟<code>malloc_state</code>实例后，是<code>sub_heap</code>中的第一个<code>chunk</code>，但<code>chunk</code>的首地址必须按照<code>MALLOC_ALIGNMENT</code>对齐，所以在<code>malloc_state</code>实例和第一个<code>chunk</code>之间可能有几个字节的<code>pad</code>，但如果<code>sub_heap</code>不是非主分配区的第一个<code>sub_heap</code>，则紧跟<code>heap_info</code>后是第一个<code>chunk</code>，但<code>sysmalloc()</code>函数默认<code>heap_info</code>是按照<code>MALLOC_ALIGNMENT</code>对齐的，没有再做对齐的工作，直接将<code>heap_info</code>后的内存强制转换成一个<code>chunk</code>。所以这里在编译时保证<code>sizeof (heap_info) + 2 * SIZE_SZ</code>是按<code>MALLOC_ALIGNMENT</code>对齐的，在运行时就不用再做检查了，也不必再做对齐。</p>
<h3 id="获取分配区"><a href="#获取分配区" class="headerlink" title="获取分配区"></a>获取分配区</h3><p>为了支持多线程，<code>ptmalloc</code>定义了如下的全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">tsd_key_t</span> arena_key;</span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> list_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> narenas;</span><br><span class="line"><span class="type">static</span> mstate free_list;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Mapped memory in non-main arenas (reliable only for NO_THREADS). */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> arena_mem;<span class="number">67</span></span><br><span class="line"><span class="comment">/* Already initialized? */</span></span><br><span class="line"><span class="type">int</span> __malloc_initialized = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p><code>arena_key</code>存放的是线程的私用实例，该私有实例保存的是分配区（arena）的<code>malloc_state</code>实例的指针。<code>arena_key</code>指向的可能是主分配区的指针，也可能是非主分配区的指针。<code>list_lock</code>用于同步分配区的单向环形链表。</p>
<p>如果定义了<code>PRE_THREAD</code>，<code>narenas</code>全局变量表示当前分配区的数量，<code>free_list</code>全局变量是空闲分配区的单向链表，这些空闲的分配区可能是从父进程那里继承来的。全局变量<code>narenas</code>和<code>free_list</code>都用锁<code>list_lock</code>同步。</p>
<p><code>arena_mem</code>只用于单线程的<code>ptmalloc</code>版本，记录了非主分配区所分配的内存大小。</p>
<p><code>__malloc_initializd</code>全局变量用来标识是否<code>ptmalloc</code>已经初始化了，其值大于0时表示已经初始化。</p>
<p><code>ptmalloc</code>使用如下的宏来获得分配区：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arena_get() acquires an arena and locks the corresponding mutex.</span></span><br><span class="line"><span class="comment">First, try the one last locked successfully by this thread. (This</span></span><br><span class="line"><span class="comment">is the common case and handled with a macro for speed.) Then, loop</span></span><br><span class="line"><span class="comment">once over the circularly linked list of arenas. If no arena is</span></span><br><span class="line"><span class="comment">readily available, create a new one. In this latter case, `size&#x27;</span></span><br><span class="line"><span class="comment">is just a hint as to how much memory will be required immediately</span></span><br><span class="line"><span class="comment">in the new arena. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">    arena_lookup(ptr); \</span></span><br><span class="line"><span class="meta">    arena_lock(ptr, size); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lookup(ptr) do &#123; \</span></span><br><span class="line"><span class="meta">    void_t *vptr = NULL; \</span></span><br><span class="line"><span class="meta">    ptr = (mstate)tsd_getspecific(arena_key, vptr); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lock(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(ptr) \</span></span><br><span class="line"><span class="meta">        (void)mutex_lock(&amp;ptr-&gt;mutex); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">        ptr = arena_get2(ptr, (size)); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lock(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(ptr &amp;&amp; !mutex_trylock(&amp;ptr-&gt;mutex)) &#123; \</span></span><br><span class="line"><span class="meta">        THREAD_STAT(++(ptr-&gt;stat_lock_direct)); \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">        ptr = arena_get2(ptr, (size)); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* find the heap and corresponding arena for a given ptr */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="meta">((heap_info *)((unsigned long)(ptr) &amp; ~(HEAP_MAX_SIZE-1)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="meta">(chunk_non_main_arena(ptr) ? heap_for_ptr(ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br></pre></td></tr></table></figure></p>
<p><code>arena_get</code>首先调用<code>arena_lookup</code>查找本线程的私用实例中是否包含一个分配区的指针，返回该指针，调用<code>arena_lock</code>尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果对该分配区加锁失败，调用<code>arena_get2</code>获得一个分配区指针。如果定义了<code>PRE_THREAD</code>，<code>arena_lock</code>的处理有些不同，如果本线程拥有的私用实例中包含分配区的指针，则直接对该分配区加锁，否则，调用<code>arena_get2</code>获得分配区指针，<code>PRE_THREAD</code>的优化保证了每个线程尽量从自己所属的分配区中分配内存，减少与其它线程因共享分配区带来的锁开销，但<code>PRE_THREAD</code>的优化并不能保证每个线程都有一个不同的分配区，当系统中的分配区数量达到配置的最大值时，不能再增加新的分配区，如果再增加新的线程，就会有多个线程共享同一个分配区。所以<code>ptmalloc</code>的<code>PRE_THREAD</code>优化，对线程少时可能会提升一些性能，但线程多时，提升性能并不明显。即使没有线程共享分配区的情况下，任然需要加锁，这是不必要的开销，每次加锁操作会消耗<code>100ns</code>左右的时间。</p>
<p>每个<code>sub_heap</code>的内存块使用<code>mmap()</code>函数分配，并以<code>HEAP_MAX_SIZE</code>对齐，所以可以根据<code>chunk</code>的指针地址，获得这个<code>chunk</code>所属的<code>sub_heap</code>的地址。<code>heap_for_ptr</code>根据<code>chunk</code>的地址获得<code>sub_heap</code>的地址。由于<code>sub_heap</code>的头部存放的是<code>heap_info</code>的实例，<code>heap_info</code>中保存了分配区的指针，所以可以通过<code>chunk</code>的地址获得分配区的地址，前提是这个<code>chunk</code>属于非主分配区，<code>arena_for_chunk</code>用来做这样的转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MIN_SIZE (32*1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_MAX_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MAX_SIZE (1024*1024) <span class="comment">/* must be a power of two */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>HEAP_MIN_SIZE</code>定义了<code>sub_heap</code>内存块的最小值，32KB。<code>HEAP_MAX_SIZE</code>定义了<code>sub_heap</code>内存块的最大值，在32位系统上，<code>HEAP_MAX_SIZE</code>默认值为1MB<code>，64为系统上，</code>HEAP_MAX_SIZE`的默认值为64MB。</p>
<h3 id="arena-get2"><a href="#arena-get2" class="headerlink" title="arena_get2()"></a>arena_get2()</h3><p><code>arena_get</code>宏尝试查看线程的私用实例中是否包含一个分配区，如果不存在分配区或是存在分配区，但对该分配区加锁失败，就会调用<code>arena_get2()</code>函数获得一个分配区，下面将分析<code>arena_get2()</code>函数的实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line">internal_function</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">arena_get2(mstate a_tsd, <span class="type">size_t</span> size)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">arena_get2(a_tsd, size) mstate a_tsd; <span class="type">size_t</span> size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mstate a;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">    <span class="keyword">if</span> ((a = get_free_list ()) == <span class="literal">NULL</span></span><br><span class="line">    &amp;&amp; (a = reused_arena ()) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">/* Nothing immediately available, so generate a new arena. */</span></span><br><span class="line">    a = _int_new_arena(size);</span><br></pre></td></tr></table></figure></p>
<p>如果开启了<code>PER_THREAD</code>优化，首先尝试从分配区的<code>free list</code>中获得一个分配区，分配区的<code>free list</code>是从父线程（进程）中继承而来，如果<code>free list</code>中没有分配区，尝试重用已有的分配区，只有当分配区的数达到限制时才重用分配区，如果仍未获得可重用的分配区，创建一个新的分配区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span>(!a_tsd)</span><br><span class="line">        a = a_tsd = &amp;main_arena;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        a = a_tsd-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">            <span class="comment">/* This can only happen while initializing the new arena. */</span></span><br><span class="line">            (<span class="type">void</span>)mutex_lock(&amp;main_arena.mutex);</span><br><span class="line">            THREAD_STAT(++(main_arena.stat_lock_wait));</span><br><span class="line">            <span class="keyword">return</span> &amp;main_arena;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果线程的私有实例中没有分配区，将主分配区作为候选分配区，如果线程私有实例中存在分配区，但不能获得该分配区的锁，将该分配区的下一个分配区作为候选分配区，如果候选分配区为空，意味着当前线程私用实例中的分配区正在初始化，还没有加入到全局的分配区链表中，这种情况下，只有主分配区可选了，等待获得主分配区的锁，如果获得住分配区的锁成功，返回主分配区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check the global, circularly linked list for available arenas. */</span></span><br><span class="line"><span class="type">bool</span> retried = <span class="literal">false</span>;</span><br><span class="line">repeat:</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!mutex_trylock(&amp;a-&gt;mutex)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retried)</span><br><span class="line">            (<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line">        THREAD_STAT(++(a-&gt;stat_lock_loop));</span><br><span class="line">        tsd_setspecific(arena_key, (<span class="type">void_t</span> *)a);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    a = a-&gt;next;</span><br><span class="line">&#125; <span class="keyword">while</span>(a != a_tsd);</span><br></pre></td></tr></table></figure></p>
<p>遍历全局分配区链表，尝试对当前遍历中的分配区加锁，如果对分配区加锁成功，将该分配区加入线程私有实例中并返回该分配区。如果<code>retried</code>为<code>true</code>，意味着这是第二次遍历全局分配区链表，并且获得了全局锁<code>list_lock</code>，当对分配区加锁成功时，需要释放全局锁<code>list_lock</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If not even the list_lock can be obtained, try again. This can</span></span><br><span class="line"><span class="comment">happen during `atfork&#x27;, or for example on systems where thread</span></span><br><span class="line"><span class="comment">creation makes it temporarily impossible to obtain _any_</span></span><br><span class="line"><span class="comment">locks. */</span></span><br><span class="line"><span class="keyword">if</span>(!retried &amp;&amp; mutex_trylock(&amp;list_lock)) &#123;</span><br><span class="line">    <span class="comment">/* We will block to not run in a busy loop. */</span></span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line">    <span class="comment">/* Since we blocked there might be an arena available now. */</span></span><br><span class="line">    retried = <span class="literal">true</span>;</span><br><span class="line">    a = a_tsd;</span><br><span class="line">    <span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在<code>atfork</code>时，父线程（进程）会对所有的分配区加锁，并对全局锁<code>list_lock</code>加锁，在有线程在创建子线程的情况下，当前线程是不能获得分配区的，所以在没有重试的情况下，先尝试获得全局锁<code>list_lock</code>，如果不能获得全局锁<code>list_lock</code>，阻塞在全局锁<code>list_lock</code>上，直到获得全局锁<code>list_lock</code>，也就是说当前已没有线程在创建子线程，然后再重新遍历全局分配区链表，尝试对分配区加锁，如果经过第二次尝试仍然未能获得一个分配区，只能创建一个新的非主分配区了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Nothing immediately available, so generate a new arena. */</span></span><br><span class="line">a = _int_new_arena(size);</span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br></pre></td></tr></table></figure></p>
<p>通过前面的所有尝试都未能获得一个可用的分配区，只能创建一个新的非主分配区，执行到这里，可以确保获得了全局锁<code>list_lock</code>，在创建完新的分配区，并将分配区加入了全局分配区链表中以后，需要对全局锁<code>list_lock</code>解锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="int-new-arena"><a href="#int-new-arena" class="headerlink" title="_int_new_arena()"></a>_int_new_arena()</h3><p><code>_int_new_arena()</code>函数用于创建一个非主分配区，在<code>arena_get2()</code>函数中被调用，该函数的实现代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line">_int_new_arena(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    mstate a;</span><br><span class="line">    heap_info *h;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> misalign;</span><br><span class="line">    h = new_heap(size + (<span class="keyword">sizeof</span>(*h) + <span class="keyword">sizeof</span>(*a) + MALLOC_ALIGNMENT),</span><br><span class="line">    mp_.top_pad);</span><br><span class="line">    <span class="keyword">if</span>(!h) &#123;</span><br><span class="line">        <span class="comment">/* Maybe size is too large to fit in a single heap. So, just try</span></span><br><span class="line"><span class="comment">        to create a minimally-sized arena and let _int_malloc() attempt</span></span><br><span class="line"><span class="comment">        to deal with the large request via mmap_chunk(). */</span></span><br><span class="line">        h = new_heap(<span class="keyword">sizeof</span>(*h) + <span class="keyword">sizeof</span>(*a) + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line">        <span class="keyword">if</span>(!h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于一个新的非主分配区，至少包含一个<code>sub_heap</code>，每个非主分配区中都有相应的管理数据结构，每个非主分配区都有一个<code>heap_info</code>实例和<code>malloc_state</code>的实例，这两个实例都位于非主分配区的第一个<code>sub_heap</code>的开始部分，<code>malloc_state</code>实例紧接着<code>heap_info</code>实例。所以在创建非主分配区时，需要为管理数据结构分配额外的内存空间。 <code>new_heap()</code>函数创建一个新的<code>sub_heap</code>，并返回<code>sub_heap</code>的指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = h-&gt;ar_ptr = (mstate)(h+<span class="number">1</span>);</span><br><span class="line">malloc_init_state(a);</span><br><span class="line"><span class="comment">/*a-&gt;next = NULL;*/</span></span><br><span class="line">a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;</span><br><span class="line">arena_mem += h-&gt;size;</span><br></pre></td></tr></table></figure></p>
<p>在<code>heap_info</code>实例后紧接着<code>malloc_state</code>实例，初始化<code>malloc_state</code>实例，更新该分配区所分配的内存大小的统计值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_THREADS</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmapped_mem + arena_mem + main_arena.system_mem) &gt; mp_.max_total_mem)</span><br><span class="line">        mp_.max_total_mem = mp_.mmapped_mem + arena_mem + main_arena.system_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Set up the top chunk, with proper alignment. */</span></span><br><span class="line">    ptr = (<span class="type">char</span> *)(a + <span class="number">1</span>);</span><br><span class="line">    misalign = (<span class="type">unsigned</span> <span class="type">long</span>)chunk2mem(ptr) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">    <span class="keyword">if</span> (misalign &gt; <span class="number">0</span>)</span><br><span class="line">    ptr += MALLOC_ALIGNMENT - misalign;</span><br><span class="line">    top(a) = (mchunkptr)ptr;</span><br><span class="line">    set_head(top(a), (((<span class="type">char</span>*)h + h-&gt;size) - ptr) | PREV_INUSE);</span><br></pre></td></tr></table></figure></p>
<p>在<code>sub_heap</code>中<code>malloc_state</code>实例后的内存可以分配给用户使用，<code>ptr</code>指向存储<code>malloc_state</code>实例后的空闲内存，对<code>ptr</code>按照<code>2*SZ_SIZE</code>对齐后，将<code>ptr</code>赋值给分配区的<code>top chunk</code>，也就是说把<code>sub_heap</code>中整个空闲内存块作为<code>top chunk</code>，然后设置<code>top chunk</code>的<code>size</code>，并标识<code>top chunk</code>的前一个<code>chunk</code>为已处于分配状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tsd_setspecific(arena_key, (<span class="type">void_t</span> *)a);</span><br><span class="line">mutex_init(&amp;a-&gt;mutex);</span><br><span class="line">(<span class="type">void</span>)mutex_lock(&amp;a-&gt;mutex);</span><br></pre></td></tr></table></figure></p>
<p>将创建好的非主分配区加入线程的私有实例中，然后对非主分配区的锁进行初始化，并获得该锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Add the new arena to the global list. */</span></span><br><span class="line">    a-&gt;next = main_arena.next;</span><br><span class="line">    atomic_write_barrier ();</span><br><span class="line">    main_arena.next = a;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">    ++narenas;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>将刚创建的非主分配区加入到分配区的全局链表中，如果开启了<code>PER_THREAD</code>优化，在<code>arena_get2()</code>函数中没有对全局锁<code>list_lock</code>加锁，这里修改全局分配区链表时需要获得全局锁<code>list_lock</code>。如果没有开启<code>PER_THREAD</code>优化，<code>arene_get2()</code>函数调用<code>_int_new_arena()</code>函数时已经获得了全局锁<code>list_lock</code>，所以对全局分配区链表的修改不用再加锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    THREAD_STAT(++(a-&gt;stat_lock_loop));</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new-heap"><a href="#new-heap" class="headerlink" title="new_heap()"></a>new_heap()</h3><p><code>new_heap()</code>函数负责从<code>mmap</code>区域映射一块内存来作为<code>sub_heap</code>，在32位系统上，该函数每次映射<code>1M</code>内存，映射的内存块地址按<code>1M</code>对齐；在64位系统上，该函数映射<code>64M</code>内存，映射的内存块地址按<code>64M</code>对齐。<code>new_heap()</code>函数只是映射一块虚拟地址空间，该空间不可读写，不会被<code>swap</code>。<code>new_heap()</code>函数的实现源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If consecutive mmap (0, HEAP_MAX_SIZE &lt;&lt; 1, ...) calls return decreasing</span></span><br><span class="line"><span class="comment">addresses as opposed to increasing, new_heap would badly fragment the</span></span><br><span class="line"><span class="comment">address space. In that case remember the second HEAP_MAX_SIZE part73</span></span><br><span class="line"><span class="comment">aligned to HEAP_MAX_SIZE from last mmap (0, HEAP_MAX_SIZE &lt;&lt; 1, ...)</span></span><br><span class="line"><span class="comment">call (if it is already aligned) and try to reuse it next time. We need</span></span><br><span class="line"><span class="comment">no locking for it, as kernel ensures the atomicity for us - worst case</span></span><br><span class="line"><span class="comment">we&#x27;ll call mmap (addr, HEAP_MAX_SIZE, ...) for some value of addr in</span></span><br><span class="line"><span class="comment">multiple threads, but only one will succeed. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *aligned_heap_area;</span><br><span class="line"><span class="comment">/* Create a new heap. size is automatically rounded up to a multiple</span></span><br><span class="line"><span class="comment">of the page size. */</span></span><br><span class="line"><span class="type">static</span> heap_info *</span><br><span class="line">internal_function</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">new_heap(<span class="type">size_t</span> size, <span class="type">size_t</span> top_pad)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">new_heap(size, top_pad) <span class="type">size_t</span> size, top_pad;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_mask = malloc_getpagesize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *p1, *p2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ul;</span><br><span class="line">    heap_info *h;</span><br><span class="line">    <span class="keyword">if</span>(size+top_pad &lt; HEAP_MIN_SIZE)</span><br><span class="line">        size = HEAP_MIN_SIZE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size+top_pad &lt;= HEAP_MAX_SIZE)</span><br><span class="line">        size += top_pad;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &gt; HEAP_MAX_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        size = HEAP_MAX_SIZE;</span><br><span class="line">    size = (size + page_mask) &amp; ~page_mask;</span><br></pre></td></tr></table></figure><br>调整<code>size</code>的大小，<code>size</code>的最小值为<code>32K</code>，最大值<code>HEAP_MAX_SIZE</code>在不同的系统上不同，在32位系统为<code>1M</code>，64位系统为<code>64M</code>，将<code>size</code>的大小调整到最小值与最大值之间，并以页对齐，如果<code>size</code>大于最大值，直接报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A memory region aligned to a multiple of HEAP_MAX_SIZE is needed.</span></span><br><span class="line"><span class="comment">No swap space needs to be reserved for the following large</span></span><br><span class="line"><span class="comment">mapping (on Linux, this is the case for all non-writable mappings</span></span><br><span class="line"><span class="comment">anyway). */</span></span><br><span class="line">    p2 = MAP_FAILED;</span><br><span class="line">    <span class="keyword">if</span>(aligned_heap_area) &#123;</span><br><span class="line">        p2 = (<span class="type">char</span> *)MMAP(aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,</span><br><span class="line">        MAP_PRIVATE|MAP_NORESERVE);</span><br><span class="line">        aligned_heap_area = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (p2 != MAP_FAILED &amp;&amp; ((<span class="type">unsigned</span> <span class="type">long</span>)p2 &amp; (HEAP_MAX_SIZE<span class="number">-1</span>))) &#123;</span><br><span class="line">            munmap(p2, HEAP_MAX_SIZE);</span><br><span class="line">            p2 = MAP_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>全局变量<code>aligned_heap_area</code>是上一次调用<code>mmap</code>分配内存的结束虚拟地址，并已经按照<code>HEAP_MAX_SIZE</code>大小对齐。如果<code>aligned_heap_area</code>不为空，尝试从上次映射结束地址开始映射大小为<code>HEAP_MAX_SIZE</code>的内存块，由于全局变量<code>aligned_heap_area</code>没有锁保护，可能存在多个线程同时<code>mmap()</code>函数从<code>aligned_heap_area</code>开始映射新的虚拟内存块，操作系统会保证只会有一个线程会成功，其它在同一地址映射新虚拟内存块都会失败。无论映射是否成功，都将全局变量<code>aligned_heap_area</code>设置为<code>NULL</code>。如果映射成功，但返回的虚拟地址不是按<code>HEAP_MAX_SIZE</code>大小对齐的，取消该区域的映射，映射失败。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p2 == MAP_FAILED) &#123;</span><br><span class="line">    p1 = (<span class="type">char</span> *)MMAP(<span class="number">0</span>, HEAP_MAX_SIZE&lt;&lt;<span class="number">1</span>, PROT_NONE,</span><br><span class="line">    MAP_PRIVATE|MAP_NORESERVE);</span><br></pre></td></tr></table></figure></p>
<p>全局变量<code>aligned_heap_area</code>为<code>NULL</code>，或者从<code>aligned_heap_area</code>开始映射失败了，尝试映射2倍<code>HEAP_MAX_SIZE</code>大小的虚拟内存，便于地址对齐，因为在最坏可能情况下，需要映射2倍<code>HEAP_MAX_SIZE</code>大小的虚拟内存才能实现地址按照<code>HEAP_MAX_SIZE</code>大小对齐。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1 != MAP_FAILED) &#123;</span><br><span class="line">    p2 = (<span class="type">char</span> *)(((<span class="type">unsigned</span> <span class="type">long</span>)p1 + (HEAP_MAX_SIZE<span class="number">-1</span>)) &amp; ~(HEAP_MAX_SIZE<span class="number">-1</span>));</span><br><span class="line">    ul = p2 - p1;</span><br><span class="line">    <span class="keyword">if</span> (ul)</span><br><span class="line">        munmap(p1, ul);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        aligned_heap_area = p2 + HEAP_MAX_SIZE;</span><br><span class="line">    munmap(p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>映射2倍<code>HEAP_MAX_SIZE</code>大小的虚拟内存成功，将大于等于<code>p1</code>并按<code>HEAP_MAX_SIZE</code>大小对齐的第一个虚拟地址赋值给<code>p2</code>，<code>p2</code>作为<code>sub_heap</code>的起始虚拟地址，<code>p2+HEAP_MAX_SIZE</code>作为<code>sub_heap</code>的结束地址，并将<code>sub_heap</code>的结束地址赋值给全局变量<code>aligned_heap_area</code>，最后还需要将多余的虚拟内存还回给操作系统。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Try to take the chance that an allocation of only HEAP_MAX_SIZE</span></span><br><span class="line"><span class="comment">    is already aligned. */</span></span><br><span class="line">    p2 = (<span class="type">char</span> *)MMAP(<span class="number">0</span>, HEAP_MAX_SIZE, PROT_NONE, MAP_PRIVATE|MAP_NORESERVE);</span><br><span class="line">    <span class="keyword">if</span>(p2 == MAP_FAILED)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)p2 &amp; (HEAP_MAX_SIZE<span class="number">-1</span>)) &#123;</span><br><span class="line">        munmap(p2, HEAP_MAX_SIZE);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>映射2倍<code>HEAP_MAX_SIZE</code>大小的虚拟内存失败了，再尝试映射<code>HEAP_MAX_SIZE</code>大小的虚拟内存，如果失败，返回；如果成功，但该虚拟地址不是按照<code>HEAP_MAX_SIZE</code>大小对齐的，返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mprotect(p2, size, PROT_READ|PROT_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">    munmap(p2, HEAP_MAX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">h = (heap_info *)p2;</span><br><span class="line">h-&gt;size = size;</span><br><span class="line">h-&gt;mprotect_size = size;</span><br><span class="line">THREAD_STAT(stat_n_heaps++);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>mprotect()</code>函数将<code>size</code>大小的内存设置为可读可写，如果失败，解除整个<code>sub_heap</code>的映射。然后更新<code>heap_info</code>实例中的相关字段。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="get-free-list-和reused-arena"><a href="#get-free-list-和reused-arena" class="headerlink" title="get_free_list()和reused_arena()"></a>get_free_list()和reused_arena()</h3><p>这两个函数在开启了<code>PER_THRAD</code>优化时用于获取分配区（arena），<code>arena_get2</code>首先调用<code>get_free_list()</code>尝试获得<code>arena</code>，如果失败在尝试调用<code>reused_arena()</code>获得<code>arena</code>，如果仍然没有获得分配区，调用<code>_int_new_arena()</code>创建一个新的分配区。<code>get_free_list()</code>函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">get_free_list</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mstate result = free_list;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line">        result = free_list;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">            free_list = result-&gt;next_free;</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (<span class="type">void</span>)mutex_lock(&amp;result-&gt;mutex);</span><br><span class="line">            tsd_setspecific(arena_key, (<span class="type">void_t</span> *)result);</span><br><span class="line">            THREAD_STAT(++(result-&gt;stat_lock_loop));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数实现很简单，首先查看<code>arena</code>的<code>free_list</code>中是否为<code>NULL</code>，如果不为<code>NULL</code>，获得全局锁<code>list_lock</code>，将<code>free_list</code>的第一个<code>arena</code>从单向链表中取出，解锁<code>list_lock</code>。如果从<code>free_list</code>中获得一个<code>arena</code>，对该<code>arena</code>加锁，并将该<code>arena</code>加入线程的私有实例中。</p>
<p><code>reused_arena()</code>函数的源代码实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">reused_arena</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (narenas &lt;= mp_.arena_test)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p>首先判断全局分配区的总数是否小于分配区的个数的限定值（arena_test） ，在32位系统上<code>arena_test</code>默认值为2，64位系统上的默认值为8，如果当前进程的分配区数量没有达到限定值，直接返回<code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> narenas_limit;</span><br><span class="line"><span class="keyword">if</span> (narenas_limit == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>)</span><br><span class="line">        narenas_limit = mp_.arena_max;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = __get_nprocs ();</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">            narenas_limit = NARENAS_FROM_NCORES (n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">/* We have no information about the system. Assume two cores. */</span></span><br><span class="line">            narenas_limit = NARENAS_FROM_NCORES (<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (narenas &lt; narenas_limit)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>设定全局变量<code>narenas_limit</code>，如果应用层设置了进程的最大分配区个数（arena_max），将<code>arena_max</code>赋值给<code>narenas_limit</code>，否则根据系统的<code>cpu</code>个数和系统的字大小设定<code>narenas_limit</code>的大小，<code>narenas_limit</code>的大小默认与<code>arena_test</code>大小相同。然后再次判断进程的当前分配区个数是否达到了分配区的限制个数，如果没有达到限定值，返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    mstate result;</span><br><span class="line">    <span class="type">static</span> mstate next_to_use;</span><br><span class="line">    <span class="keyword">if</span> (next_to_use == <span class="literal">NULL</span>)</span><br><span class="line">        next_to_use = &amp;main_arena;</span><br><span class="line">    result = next_to_use;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mutex_trylock(&amp;result-&gt;mutex))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        result = result-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != next_to_use);</span><br><span class="line">    <span class="comment">/* No arena available. Wait for the next in line. */</span></span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;result-&gt;mutex);</span><br><span class="line">out:</span><br><span class="line">    tsd_setspecific(arena_key, (<span class="type">void_t</span> *)result);</span><br><span class="line">    THREAD_STAT(++(result-&gt;stat_lock_loop));</span><br><span class="line">    next_to_use = result-&gt;next;</span><br></pre></td></tr></table></figure></p>
<p>全局变量<code>next_to_use</code>指向下一个可能可用的分配区，该全局变量没有锁保护，主要用于记录上次遍历分配区循环链表到达的位置，避免每次都从同一个分配区开始遍历，导致从某个分配区分配的内存过多。首先判断<code>next_to_use</code>是否为<code>NULL</code>，如果是，将主分配区赋值给<code>next_to_use</code>。然后从<code>next_to_use</code>开始遍历分配区链表，尝试对遍历的分配区加锁，如果加锁成功，退出循环，如果遍历分配区循环链表中的所有分配区，尝试加锁都失败了，等待获得<code>next_to_use</code>指向的分配区的锁。执行到<code>out</code>的代码，意味着已经获得一个分配区的锁，将该分配区加入线程私有实例，并将当前分配区的下一个分配区赋值给<code>next_to_use</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="grow-heap-shrink-heap-delete-heap-heap-trim"><a href="#grow-heap-shrink-heap-delete-heap-heap-trim" class="headerlink" title="grow_heap(),shrink_heap(),delete_heap(),heap_trim()"></a>grow_heap(),shrink_heap(),delete_heap(),heap_trim()</h3><p>这几个函数实现<code>sub_heap</code>和增长和收缩，<code>grow_heap()</code>函数主要将<code>sub_heap</code>中可读可写区域扩大；<code>shrink_heap()</code>函数缩小<code>sub_heap</code>的虚拟内存区域，减小该<code>sub_heap</code>的虚拟内存占用量；<code>delete_heap()</code>为一个宏，如果<code>sub_heap</code>中所有的内存都空闲，使用该宏函数将<code>sub_heap</code>的虚拟内存还回给操作系统；<code>heap_trim()</code>函数根据<code>sub_heap</code>的<code>top chunk</code>大小调用<code>shrink_heap()</code>函数收缩<code>sub_heap</code>。</p>
<p><code>grow_heap()</code>函数的实现代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">grow_heap(heap_info *h, <span class="type">long</span> diff)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">grow_heap(h, diff) heap_info *h; <span class="type">long</span> diff;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_mask = malloc_getpagesize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> new_size;</span><br><span class="line">    diff = (diff + page_mask) &amp; ~page_mask;</span><br><span class="line">    new_size = (<span class="type">long</span>)h-&gt;size + diff;</span><br><span class="line">    <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>) new_size &gt; (<span class="type">unsigned</span> <span class="type">long</span>) HEAP_MAX_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>) new_size &gt; h-&gt;mprotect_size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mprotect((<span class="type">char</span> *)h + h-&gt;mprotect_size,</span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">long</span>) new_size - h-&gt;mprotect_size,</span><br><span class="line">        PROT_READ|PROT_WRITE) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        h-&gt;mprotect_size = new_size;</span><br><span class="line">    &#125;</span><br><span class="line">    -&gt;size = new_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>grow_heap()</code>函数的实现比较简单，首先将要增加的可读可写的内存大小按照页对齐，然后计算<code>sub_heap</code>总的可读可写的内存大小<code>new_size</code>，判断<code>new_size</code>是否大于<code>HEAP_MAX_SIZE</code>，如果是，返回，否则判断<code>new_size</code>是否大于当前<code>sub_heap</code>的可读可写区域大小，如果否，调用<code>mprotect()</code>设置新增的区域可读可写，并更新当前<code>sub_heap</code>的可读可写区域的大小为<code>new_size</code>。最后将当前<code>sub_heap</code>的字段<code>size</code>更新为<code>new_size</code>。<code>shrink_heap()</code>函数的实现源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">shrink_heap(heap_info *h, <span class="type">long</span> diff)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">shrink_heap(h, diff) heap_info *h; <span class="type">long</span> diff;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> new_size;</span><br><span class="line">    new_size = (<span class="type">long</span>)h-&gt;size - diff;</span><br><span class="line">    <span class="keyword">if</span>(new_size &lt; (<span class="type">long</span>)<span class="keyword">sizeof</span>(*h))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* Try to re-map the extra heap space freshly to save memory, and make it inaccessible. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC79</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="type">char</span> *)MMAP((<span class="type">char</span> *)h + new_size, diff, PROT_NONE,</span><br><span class="line">        MAP_PRIVATE|MAP_FIXED) == (<span class="type">char</span> *) MAP_FAILED)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        h-&gt;mprotect_size = new_size;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        madvise ((<span class="type">char</span> *)h + new_size, diff, MADV_DONTNEED);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*fprintf(stderr, &quot;shrink %p %08lx\n&quot;, h, new_size);*/</span></span><br><span class="line">    h-&gt;size = new_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>shrink_heap()</code>函数的参数<code>diff</code>已经页对齐，同时<code>sub_heap</code>的<code>size</code>也是安装页对齐的，所以计算<code>sub_heap</code>的<code>new_size</code>时不用再处理页对齐。如果<code>new_size</code>比<code>sub_heap</code>的首地址还小，报错退出，如果该函数运行在非<code>Glibc</code>中，则从<code>sub_heap</code>中切割出<code>diff</code>大小的虚拟内存，创建一个新的不可读写的映射区域，注意<code>mmap()</code>函数这里使用了<code>MAP_FIXED</code>标志，然后更新<code>sub_heap</code>的可读可写内存大小。如果该函数运行在<code>Glibc</code>库中，则调用<code>madvise()</code>函数，实际上<code>madvise()</code>函数什么也不做，只是返回错误，这里并没有处理<code>madvise()</code>函数的返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> delete_heap(heap) \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((char *)(heap) + HEAP_MAX_SIZE == aligned_heap_area) \</span></span><br><span class="line"><span class="meta">        aligned_heap_area = NULL; \</span></span><br><span class="line"><span class="meta">    munmap((char*)(heap), HEAP_MAX_SIZE); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>
<p><code>delete_heap()</code>宏函数首先判断当前删除的<code>sub_heap</code>的结束地址是否与全局变量<code>aligned_heap_area</code>指向的地址相同，如果相同，则将全局变量<code>aligned_heap_area</code>设置为<code>NULL</code>，因为当前<code>sub_heap</code>删除以后，就可以从当前<code>sub_heap</code>的起始地址或是更低的地址开始映射新的<code>sub_heap</code>，这样可以尽量从地地址映射内存。然后调用<code>munmap()</code>函数将整个<code>sub_heap</code>的虚拟内存区域释放掉。在调用<code>munmap()</code>函数时，<code>heap_trim()</code>函数调用<code>shrink_heap()</code>函数可能已将<code>sub_heap</code>切分成多个子区域，<code>munmap()</code>函数的第二个参数为<code>HEAP_MAX_SIZE</code>，无论该<code>sub_heap</code>（大小为<code>HEAP_MAX_SIZE</code>）的内存区域被切分成多少个子区域，将整个<code>sub_heap</code>都释放掉了。</p>
<p><code>heap_trim()</code>函数的源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">internal_function80</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">heap_trim(heap_info *heap, <span class="type">size_t</span> pad)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">heap_trim(heap, pad) heap_info *heap; <span class="type">size_t</span> pad;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr = heap-&gt;ar_ptr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pagesz = mp_.pagesize;</span><br><span class="line">    mchunkptr top_chunk = top(ar_ptr), p, bck, fwd;</span><br><span class="line">    heap_info *prev_heap;</span><br><span class="line">    <span class="type">long</span> new_size, top_size, extra;</span><br><span class="line">    <span class="comment">/* Can this heap go away completely? */</span></span><br><span class="line">    <span class="keyword">while</span>(top_chunk == chunk_at_offset(heap, <span class="keyword">sizeof</span>(*heap))) &#123;</span><br></pre></td></tr></table></figure></p>
<p>每个非主分配区至少有一个<code>sub_heap</code>，每个非主分配区的第一个<code>sub_heap</code>中包含了一个<code>heap_info</code>的实例和<code>malloc_state</code>的实例，分主分配区中的其它<code>sub_heap</code>中只有一个<code>heap_info</code>实例，紧跟<code>heap_info</code>实例后，为可以用于分配的内存块。当当前非主分配区的<code>topchunk</code>与当前<code>sub_heap</code>的<code>heap_info</code>实例的结束地址相同时，意味着当前<code>sub_heap</code>中只有一个空闲<code>chunk</code>，没有已分配的<code>chunk</code>。所以可以将当前整个<code>sub_heap</code>都释放掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">prev_heap = heap-&gt;prev;</span><br><span class="line">p = chunk_at_offset(prev_heap, prev_heap-&gt;size - (MINSIZE<span class="number">-2</span>*SIZE_SZ));</span><br><span class="line">assert(p-&gt;size == (<span class="number">0</span>|PREV_INUSE)); <span class="comment">/* must be fencepost */</span></span><br><span class="line">p = prev_chunk(p);</span><br><span class="line">new_size = chunksize(p) + (MINSIZE<span class="number">-2</span>*SIZE_SZ);</span><br><span class="line">assert(new_size&gt;<span class="number">0</span> &amp;&amp; new_size&lt;(<span class="type">long</span>)(<span class="number">2</span>*MINSIZE));</span><br><span class="line"><span class="keyword">if</span>(!prev_inuse(p))</span><br><span class="line">    new_size += p-&gt;prev_size;</span><br><span class="line">assert(new_size&gt;<span class="number">0</span> &amp;&amp; new_size&lt;HEAP_MAX_SIZE);</span><br><span class="line"><span class="keyword">if</span>(new_size + (HEAP_MAX_SIZE - prev_heap-&gt;size) &lt; pad + MINSIZE + pagesz)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>每个<code>sub_heap</code>的可读可写区域的末尾都有两个<code>chunk</code>用于<code>fencepost</code>，以64位系统为例，最后一个<code>chunk</code>占用的空间为<code>MINSIZE-2*SIZE_SZ</code>，为<code>16B</code>，最后一个<code>chuk</code>的<code>size</code>字段记录的前一个<code>chunk</code>为<code>inuse</code>状态，并标识当前<code>chunk</code>大小为0，倒数第二个<code>chunk</code>为<code>inuse</code>状态，这个<code>chunk</code>也是<code>fencepost</code>的一部分，这个<code>chunk</code>的大小为<code>2*SIZE_SZ</code>，为<code>16B</code>，所以用于<code>fencepost</code>的两个<code>chunk</code>的空间大小为32B。<code>fencepost</code>也有可能大于32B<code>，第二个</code>chunk<code>仍然为</code>16B<code>，第一个</code>chunk<code>的大小大于16B</code>，这种情况发生在<code>top chunk</code>的空间小于<code>2*MINSIZE</code>，大于<code>MINSIZE</code>，但对于一个完全空闲的<code>sub_heap</code>来说，<code>top chunk</code>的空间肯定大于<code>2*MINSIZE</code>，所以在这里不考虑这种情况。用于<code>fencepost</code>的<code>chunk</code>空间其实都是被分配给应用层使用的，<code>new_size</code>表示当前<code>sub_heap</code>中可读可写区域的可用空间，如果倒数第二个<code>chunk</code>的前一个<code>chunk</code>为空闲状态，当前<code>sub_heap</code>中可读可写区域的可用空间大小还需要加上这个空闲<code>chunk</code>的大小。如果<code>new_size</code>与<code>sub_heap</code>中剩余的不可读写的区域大小之和小于32+4K（64位系统），意味着前一个<code>sub_heap</code>的可用空间太少了，不能释放当前的<code>sub_heap</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    ar_ptr-&gt;system_mem -= heap-&gt;size;</span><br><span class="line">    arena_mem -= heap-&gt;size;</span><br><span class="line">    delete_heap(heap);</span><br><span class="line">    heap = prev_heap;</span><br><span class="line">    <span class="keyword">if</span>(!prev_inuse(p)) &#123; <span class="comment">/* consolidate backward */</span></span><br><span class="line">        p = prev_chunk(p);</span><br><span class="line">        unlink(p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line">assert(((<span class="type">unsigned</span> <span class="type">long</span>)((<span class="type">char</span>*)p + new_size) &amp; (pagesz<span class="number">-1</span>)) == <span class="number">0</span>);</span><br><span class="line">assert( ((<span class="type">char</span>*)p + new_size) == ((<span class="type">char</span>*)heap + heap-&gt;size) );</span><br><span class="line">top(ar_ptr) = top_chunk = p;</span><br><span class="line">set_head(top_chunk, new_size | PREV_INUSE);</span><br><span class="line"><span class="comment">/*check_chunk(ar_ptr, top_chunk);*/</span></span><br></pre></td></tr></table></figure></p>
<p>首先更新非主分配区的内存统计，然后调用<code>delete_heap()</code>宏函数释放该<code>sub_heap</code>，把当前<code>heap</code>设置为被释放<code>sub_heap</code>的前一个<code>sub_heap</code>，<code>p</code>指向的是被释放<code>sub_heap</code>的前一个<code>sub_heap</code>的倒数第二个<code>chunk</code>，如果<code>p</code>的前一个<code>chunk</code>为空闲状态，由于不可能出现多个连续的空闲<code>chunk</code>，所以将<code>p</code>设置为<code>p</code>的前一个<code>chunk</code>，也就是<code>p</code>指向空闲<code>chunk</code>，并将该空闲<code>chunk</code>从空闲<code>chunk</code>链表中移除，并将将该空闲<code>chunk</code>赋值给<code>sub_heap</code>的<code>top chunk</code>，并设置<code>top chunk</code>的<code>size</code>，标识<code>top chunk</code>的前一个<code>chunk</code>处于<code>inuse</code>状态。然后继续判断循环条件，如果循环条件不满足，退出循环，如果条件满足，继续对当前<code>sub_heap</code>进行收缩。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">    top_size = chunksize(top_chunk);</span><br><span class="line">    extra = ((top_size - pad - MINSIZE + (pagesz<span class="number">-1</span>))/pagesz - <span class="number">1</span>) * pagesz;</span><br><span class="line">    <span class="keyword">if</span>(extra &lt; (<span class="type">long</span>)pagesz)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Try to shrink. */</span></span><br><span class="line">    <span class="keyword">if</span>(shrink_heap(heap, extra) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ar_ptr-&gt;system_mem -= extra;</span><br><span class="line">    arena_mem -= extra;</span><br><span class="line">    <span class="comment">/* Success. Adjust top accordingly. */</span></span><br><span class="line">    set_head(top_chunk, (top_size - extra) | PREV_INUSE);</span><br><span class="line">    <span class="comment">/*check_chunk(ar_ptr, top_chunk);*/</span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">首先查看`top chunk`的大小，如果`top chunk`的大小减去`pad`和`MINSIZE`小于一页大小，返回退出，否则调用`shrink_heap()`函数对当前`sub_heap`进行收缩，将空闲的整数个页收缩掉，仅剩下不足一页的空闲内存，如果`shrink_heap()`失败，返回退出，否则，更新内存使用统计，更新`top chunk`的大小。</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存分配malloc"><a href="#内存分配malloc" class="headerlink" title="内存分配malloc"></a>内存分配malloc</h2><p><code>ptmalloc2</code>主要的内存分配函数为<code>malloc()</code>，但源代码中并不能找到该函数，该函数是用宏定义为<code>public_malloc()</code>，因为该函数在不同的编译条件下，具有不同的名称。<code>public_malloc()</code>函数只是简单的封装<code>_int_malloc()</code>函数，<code>_int_malloc()</code>函数才是内存分配的核心实现。下面我们将分析<code>malloc</code>的实现。</p>
<h3 id="public-malloc"><a href="#public-malloc" class="headerlink" title="public_malloc()"></a>public_malloc()</h3><p>先给出源代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void_t</span>*</span><br><span class="line"><span class="title function_">public_malloc</span><span class="params">(<span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void_t</span> *victim;</span><br><span class="line">    <span class="type">__malloc_ptr_t</span> (*hook) (<span class="type">size_t</span>, __const <span class="type">__malloc_ptr_t</span>)</span><br><span class="line">    = force_reg (__malloc_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure></p>
<p>首先检查是否存在内存分配的<code>hook</code>函数，如果存在，调用<code>hook</code>函数，并返回，<code>hook</code>函数主要用于进程在创建新线程过程中分配内存，或者支持用户提供的内存分配函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arena_lookup(ar_ptr);</span><br><span class="line">arena_lock(ar_ptr, bytes);</span><br><span class="line"><span class="keyword">if</span>(!ar_ptr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">victim = _int_malloc(ar_ptr, bytes);</span><br></pre></td></tr></table></figure>
<p>获取分配区指针，如果获取分配区失败，返回退出，否则，调用<code>_int_malloc()</code>函数分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!victim) &#123;</span><br><span class="line">    <span class="comment">/* Maybe the failure is due to running out of mmapped areas. */</span></span><br><span class="line">    <span class="keyword">if</span>(ar_ptr != &amp;main_arena) &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        ar_ptr = &amp;main_arena;</span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br></pre></td></tr></table></figure>
<p>如果<code>_int_malloc()</code>函数分配内存失败，并且使用的分配区不是主分配区，这种情况可能是<code>mmap</code>区域的内存被用光了，当主分配区可以从堆中分配内存，所以需要再尝试从主分配区中分配内存。首先释放所使用分配区的锁，然后获得主分配区的锁，并调用<code>_int_malloc()</code>函数分配内存，最后释放主分配区的锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_ARENAS</span></span><br><span class="line">            <span class="comment">/* ... or sbrk() has failed and there is still a chance to mmap() */</span></span><br><span class="line">            ar_ptr = arena_get2(ar_ptr-&gt;next ? ar_ptr : <span class="number">0</span>, bytes);</span><br><span class="line">            (<span class="type">void</span>)mutex_unlock(&amp;main_arena.mutex);</span><br><span class="line">            <span class="keyword">if</span>(ar_ptr) &#123;</span><br><span class="line">                victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">                (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>_int_malloc()</code>函数分配内存失败，并且使用的分配区是主分配区，查看是否有非主分配区，如果有，调用<code>arena_get2()</code>获取分配区，然后对主分配区解锁，如果<code>arena_get2()</code>返回一个非主分配区，尝试调用<code>_int_malloc()</code>函数从该非主分配区分配内存，最后释放该非主分配区的锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br></pre></td></tr></table></figure></p>
<p>如果<code>_int_malloc()</code>函数分配内存成功，释放所使用的分配区的锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||</span><br><span class="line">    ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br><span class="line">    <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc()"></a>_int_malloc()</h3><p><code>_int_malloc()</code>函数是内存分配的核心，根据分配的内存块的大小，该函数中实现了四种分配内存的路径，下面将分别分析这四种分配路径。</p>
<p>先给出<code>_int_malloc()</code>函数的函数定义及临时变量的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void_t</span>*</span><br><span class="line">_int_malloc(mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T nb; <span class="comment">/* normalized request size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx; <span class="comment">/* associated bin index */</span></span><br><span class="line">    mbinptr bin; <span class="comment">/* associated bin */</span></span><br><span class="line">    mchunkptr victim; <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">    INTERNAL_SIZE_T size; <span class="comment">/* its size */</span></span><br><span class="line">    <span class="type">int</span> victim_index; <span class="comment">/* its bin index */</span></span><br><span class="line">    mchunkptr remainder; <span class="comment">/* remainder from a split */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* its size */</span><span class="number">84</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> block; <span class="comment">/* bit map traverser */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bit; <span class="comment">/* bit map traverser */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>; <span class="comment">/* current word of binmap */</span></span><br><span class="line">    mchunkptr fwd; <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    mchunkptr bck; <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">    overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">    to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">    size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">    that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">    aligned.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    checked_request2size(bytes, nb);</span><br></pre></td></tr></table></figure></p>
<p><code>checked_request2size()</code>函数将需要分配的内存大小<code>bytes</code>转换为需要分配的<code>chunk</code>大小<code>nb</code>。<code>ptmalloc</code>内部分配都是以<code>chunk</code>为单位，根据<code>chunk</code>的大小，决定如何获得满足条件的<code>chunk</code>。</p>
<h4 id="分配fast-bin-chunk"><a href="#分配fast-bin-chunk" class="headerlink" title="分配fast bin chunk"></a>分配fast bin chunk</h4><p>如果所需的<code>chunk</code>大小小于等于<code>fast bins</code>中的最大<code>chunk</code>大小，首先尝试从<code>fast bins</code>中分配<code>chunk</code>。源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())) &#123;</span><br><span class="line">        idx = fastbin_index(nb);</span><br><span class="line">        mfastbinptr* fb = &amp;fastbin (av, idx);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">        mchunkptr pp = *fb;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            victim = pp;</span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        victim = *fb;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">errout:</span><br><span class="line">                malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ATOMIC_FASTBINS</span></span><br><span class="line">            *fb = victim-&gt;fd;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            check_remalloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">                alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有开启<code>ATOMIC_FASTBINS</code>优化，从<code>fast bins</code>中分配一个<code>chunk</code>相当简单，首先根据所需<code>chunk</code>的大小获得该<code>chunk</code>所属<code>fast bin</code>的<code>index</code>，根据该<code>index</code>获得所需<code>fast bin</code>的空闲<code>chunk</code>链表的头指针，然后将头指针的下一个<code>chunk</code>作为空闲<code>chunk</code>链表的头部。为了加快从<code>fast bins</code>中分配<code>chunk</code>，处于<code>fast bins</code>中<code>chunk</code>的状态仍然保持为<code>inuse</code>状态，避免被相邻的空闲<code>chunk</code>合并，从<code>fast bins</code>中分配<code>chunk</code>，只需取出第一个<code>chunk</code>，并调用<code>chunk2mem()</code>函数返回用户所需的内存块。</p>
<p>如果开启<code>ATOMIC_FASTBINS</code>优化，这里使用了<code>lock-free</code>的技术实现单向链表删除第一个<code>node</code>的操作。<code>lock-free</code>算法的基础是<code>CAS</code>(Compareand-Swap)原子操作。当某个地址的原始值等于某个比较值时，把值改成新值，无论有否修改，返回这个地址的原始值。目前的<code>cpu</code>支持最多64位的<code>CAS</code>，并且指针<code>p</code>必须对齐。原子操作指一个<code>cpu</code>时钟周期内就可以完成的操作，不会被其他线程干扰。</p>
<p>一般的<code>CAS</code>使用方式是：假设有指针<code>p</code>，它指向一个32位或者64位数，</p>
<ol>
<li>复制<code>p</code>的内容（<code>*p</code>）到比较量<code>cmp</code>（原子操作）。</li>
<li>基于这个比较量计算一个新值<code>xchg</code>（非原子操作）。</li>
<li>调用<code>CAS</code>比较当前<code>*p</code>和<code>cmp</code>，如果相等把<code>*p</code>替换成<code>xchg</code>（原子操作）。</li>
<li>如果成功退出，否则回到第一步重新进行。</li>
</ol>
<p>第3步的<code>CAS</code>操作保证了写入的同时<code>p</code>没有被其他线程更改。如果<code>*p</code>已经被其他线程更改，那么第2步计算新值所使用的值<code>cmp</code>已经过期了，因此这个整个过程失败，重新来过。多线程环境下，由于3是一个原子操作，那么起码有一个线程（最快执行到3）的<code>CAS</code>操作可以成功，这样整体上看，就保证了所有的线程上在“前进”，而不需要使用效率低下的锁来协调线程，更不会导致死锁之类的麻烦。</p>
<p><code>ABA</code>问题，当<code>A</code>线程执行2的时候，被<code>B</code>线程更改了<code>*p</code>为<code>x</code>，而<code>C</code>线程又把它改回了原始值，这时回到<code>A</code>线程，<code>A</code>线程无法监测到原始值已经被更改过了，<code>CAS</code>操作会成功（实际上应该失败）。<code>ABA</code>大部分情况下会造成一些问题，因为<code>p</code>的内容一般不可能是独立的，其他内容已经更改，而<code>A</code>线程认为它没有更改就会带来不可预知的结果。</p>
<p>如果开启<code>ATOMIC_FASTBINS</code>优化，这里的实现会出现<code>ABA</code>问题吗？不会出现，如果开启了<code>ATOMIC_FASTBINS</code>优化，在<code>free</code>时，如果释放的<code>chunk</code>属于<code>fast bin</code>，不需要对分配区加锁，可以通过<code>lock-free</code>技术将该<code>chunk</code>加入<code>fast bins</code>的链表中。当从分配区分配内存时，需要对分配区加锁，所以当<code>A</code>线程获得了分配区的锁，并从<code>fast bin</code>中分配内存执行2的时候，被<code>B</code>线程调用<code>free</code>函数向<code>fast bin</code>的链表中加入了一个新的<code>chunk</code>，即更改了<code>*fb</code>为<code>x</code>，但不会存在<code>C</code>线程将<code>*fb</code>改回原值，如果存在，意味着<code>C</code>线程先分配了<code>*fb</code>所存的<code>chunk</code>，并将该<code>chunk</code>释放回了<code>fast bin</code>，但<code>C</code>线程分配<code>*fb</code>所存的<code>chunk</code>需要获得分配区的锁，但分配区的锁被<code>A</code>线程持有，所以<code>C</code>线程不可能将<code>*fb</code>改回原值，也就不会存在<code>ABA</code>问题。</p>
<h4 id="分配small-bin-chunk"><a href="#分配small-bin-chunk" class="headerlink" title="分配small bin chunk"></a>分配small bin chunk</h4><p>如果所需的<code>chunk</code>大小属于<code>small bin</code>，则会执行如下的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If a small request, check regular bin. Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">(For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">        bin = bin_at(av,idx);</span><br><span class="line">        <span class="keyword">if</span> ( (victim = last(bin)) != bin) &#123;</span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">                malloc_consolidate(av);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                bck = victim-&gt;bk;</span><br><span class="line">                <span class="keyword">if</span> (__builtin_expect (bck-&gt;fd != victim, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">                set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">                bin-&gt;bk = bck;</span><br><span class="line">                bck-&gt;fd = bin;</span><br><span class="line">                <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;<span class="number">87</span></span><br><span class="line">                check_malloced_chunk(av, victim, nb);</span><br><span class="line">                <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">                <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">                    alloc_perturb (p, bytes);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果分配的<code>chunk</code>属于<code>small bin</code>，首先查找<code>chunk</code>所对应<code>small bins</code>数组的<code>index</code>，然后根据<code>index</code>获得某个<code>small bin</code>的空闲<code>chunk</code>双向循环链表表头，然后将最后一个<code>chunk</code>赋值给<code>victim</code>，如果<code>victim</code>与表头相同，表示该链表为空，不能从<code>small bin</code>的空闲<code>chunk</code>链表中分配，这里不处理，等后面的步骤来处理。如果<code>victim</code>与表头不同，有两种情况，如果<code>victim</code>为0，表示<code>small bin</code>还没有初始化为双向循环链表，调用<code>malloc_consolidate()</code>函数将<code>fast bins</code>中的<code>chunk</code>合并。否则，将<code>victim</code>从<code>small bin</code>的双向循环链表中取出，设置<code>victim chunk</code>的<code>inuse</code>标志，该标志处于<code>victim chunk</code>的下一个相邻<code>chunk</code>的<code>size</code>字段的第一个<code>bit</code>。从<code>small bin</code>中取出一个<code>chunk</code>也可以用<code>unlink()</code>宏函数，只是这里没有使用。</p>
<p>接着判断当前分配区是否为非主分配区，如果是，将<code>victim chunk</code>的<code>size</code>字段中的表示非主分配区的标志<code>bit</code>清零，最后调用<code>chunk2mem()</code>函数获得<code>chunk</code>的实际可用的内存指针，将该内存指针返回给应用层。到此从<code>small bins</code>中分配<code>chunk</code>的工作完成了，但我们看到，当对应的<code>small bin</code>中没有空闲<code>chunk</code>，或是对应的<code>small bin</code>还没有初始化完成，并没有获取到<code>chunk</code>，这两种情况都需要后面的步骤来处理。</p>
<h4 id="分配large-bin-chunk"><a href="#分配large-bin-chunk" class="headerlink" title="分配large bin chunk"></a>分配large bin chunk</h4><p>如果所需的<code>chunk</code>不属于<code>small bins</code>，首先会执行如下的代码段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        idx = largebin_index(nb);</span><br><span class="line">        <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>所需<code>chunk</code>不属于<code>small bins</code>，那么就一定属于<code>large bins</code>，首先根据<code>chunk</code>的大小获得对应的<code>large bin</code>的<code>index</code>，接着判断当前分配区的<code>fast bins</code>中是否包含<code>chunk</code>，如果存在，调用<code>malloc_consolidate()</code>函数合并<code>fast bins</code>中的<code>chunk</code>，并将这些空闲<code>chunk</code>加入<code>unsorted bin</code>中。</p>
<p>下面的源代码实现从<code>last remainder chunk</code>，<code>large bins</code>和<code>top chunk</code>中分配所需的<code>chunk</code>，这里包含了多个多层循环，在这些循环中，主要工作是分配前两步都未分配成功的<code>small bin chunk</code>，<code>large bin chunk</code>和<code>large chunk</code>。最外层的循环用于重新尝试分配<code>small bin chunk</code>，因为如果在前一步分配<code>small bin chunk</code>不成功，并没有调用<code>malloc_consolidate()</code>函数合并<code>fast bins</code>中的<code>chunk</code>，将空闲<code>chunk</code>加入<code>unsorted bin</code>中，如果第一尝试从<code>last remainder chunk</code>，<code>top chunk</code>中分配<code>small bin chunk</code>都失败以后，如果<code>fast bins</code>中存在空闲<code>chunk</code>，会调用<code>malloc_consolidate()</code>函数，那么在<code>usorted bin</code>中就可能存在合适的<code>small bin chunk</code>供分配，所以需要再次尝试。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">the most recent non-exact fit. Place other traversed chunks in</span></span><br><span class="line"><span class="comment">bins. Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">chunks are placed in bins.</span></span><br><span class="line"><span class="comment">The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( (victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br></pre></td></tr></table></figure></p>
<p>反向遍历<code>unsorted bin</code>的双向循环链表，遍历结束的条件是循环链表中只剩下一个头结点。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>, chunk2mem (victim));</span><br><span class="line">size = chunksize(victim);</span><br></pre></td></tr></table></figure></p>
<p>检查当前遍历的<code>chunk</code>是否合法，<code>chunk</code>的大小不能小于等于<code>2 * SIZE_SZ</code>，也不能超过该分配区总的内存分配量。然后获取<code>chunk</code>的大小并赋值给<code>size</code>。这里的检查似乎有点小问题，直接使用了<code>victim-&gt;size</code>，但<code>victim-&gt;size</code>中包含了相关的标志位信息，使用<code>chunksize(victim)</code>才比较合理，但在<code>unsorted bin</code>中的空闲<code>chunk</code>的所有标志位都清零了，所以这里直接<code>victim-&gt;size</code>没有问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">only chunk in unsorted bin. This helps promote locality for</span></span><br><span class="line"><span class="comment">runs of consecutive small requests. This is the only89</span></span><br><span class="line"><span class="comment">exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;</span><br><span class="line">            bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">            victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br></pre></td></tr></table></figure>
<p>如果需要分配一个<code>small bin chunk</code>，在5.7.2.2节中的<code>small bins</code>中没有匹配到合适的<code>chunk</code>，并且<code>unsorted bin</code>中只有一个<code>chunk</code>，并且这个<code>chunk</code>为<code>last remainder chunk</code>，并且这个<code>chunk</code>的大小大于所需<code>chunk</code>的大小加上<code>MINSIZE</code>，在满足这些条件的情况下，可以使用这个<code>chunk</code>切分出需要的<code>small bin chunk</code>。这是唯一的从<code>unsorted bin</code>中分配<code>small bin chunk</code>的情况，这种优化利于<code>cpu</code>的高速缓存命中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* split and reattach remainder */</span></span><br><span class="line">remainder_size = size - nb;</span><br><span class="line">remainder = chunk_at_offset(victim, nb);</span><br><span class="line">unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">av-&gt;last_remainder = remainder;</span><br><span class="line">remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">&#123;</span><br><span class="line">    remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从该<code>chunk</code>中切分出所需大小的<code>chunk</code>，计算切分后剩下<code>chunk</code>的大小，将剩下的<code>chunk</code>加入<code>unsorted bin</code>的链表中，并将剩下的<code>chunk</code>作为分配区的<code>last remainder chunk</code>，若剩下的<code>chunk</code>属于<code>large bin chunk</code>，将该<code>chunk</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>设置为<code>NULL</code>，因为这个<code>chunk</code>仅仅存在于<code>unsorted bin</code>中，并且<code>unsorted bin</code>中有且仅有这一个<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">set_foot(remainder, remainder_size);</span><br><span class="line">check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<p>设置分配出的<code>chunk</code>和<code>last remainder chunk</code>的相关信息，如<code>chunk</code>的<code>size</code>，状态标志位，对于<code>last remainder chunk</code>，需要调用<code>set_foot</code>宏，因为只有处于空闲状态的<code>chunk</code>的<code>foot</code>信息（<code>prev_size</code>）才是有效的，处于<code>inuse</code>状态的<code>chunk</code>的<code>foot</code>无效，该<code>foot</code>是返回给应用层的内存块的一部分。设置完成<code>chunk</code>的相关信息，调用<code>chunk2mem()</code>获得<code>chunk</code>中可用的内存指针，返回给应用层，退出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks(av);</span><br></pre></td></tr></table></figure></p>
<p>将双向循环链表中的最后一个<code>chunk</code>移除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">    set_inuse_bit_at_offset(victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前遍历的<code>chunk</code>与所需的<code>chunk</code>大小一致，将当前<code>chunk</code>返回。首先设置当前<code>chunk</code>处于<code>inuse</code>状态，该标志位处于相邻的下一个<code>chunk</code>的<code>size</code>中，如果当前分配区不是主分配区，设置当前<code>chunk</code>的非主分配区标志位，最后调用<code>chunk2mem()</code>获得<code>chunk</code>中可用的内存指针，返回给应用层，退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">    victim_index = smallbin_index(size);</span><br><span class="line">    bck = bin_at(av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>chunk</code>属于<code>small bins</code>，获得当前<code>chunk</code>所属<code>small bin</code>的<code>index</code>，并将该<code>small bin</code>的链表表头赋值给<code>bck</code>，第一个<code>chunk</code>赋值给<code>fwd</code>，也就是当前的<code>chunk</code>会插入到<code>bck</code>和<code>fwd</code>之间，作为<code>small bin</code>链表的第一个<code>chunk</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    victim_index = largebin_index(size);</span><br><span class="line">    bck = bin_at(av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>chunk</code>属于<code>large bins</code>，获得当前<code>chunk</code>所属<code>large bin</code>的<code>index</code>，并将该<code>large bin</code>的链表表头赋值给<code>bck</code>，第一个<code>chunk</code>赋值给<code>fwd</code>，也就是当前的<code>chunk</code>会插入到<code>bck</code>和<code>fwd</code>之间，作为<code>large bin</code>链表的第一个<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line"><span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">    <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">    size |= PREV_INUSE;</span><br><span class="line">    <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">    assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如果<code>fwd</code>不等于<code>bck</code>，意味着<code>large bin</code>中有空闲<code>chunk</code>存在，由于<code>large bin</code>中的空闲<code>chunk</code>是按照大小顺序排序的，需要将当前从<code>unsorted bin</code>中取出的<code>chunk</code>插入到<code>large bin</code>中合适的位置。将当前<code>chunk</code>的<code>size</code>的<code>inuse</code>标志<code>bit</code>置位，相当于加1，便于加快<code>chunk</code>大小的比较，找到合适的地方插入当前<code>chunk</code>。这里还做了一次检查，断言在<code>large bin</code>双向循环链表中的最后一个<code>chunk</code>的<code>size</code>字段中的非主分配区的标志<code>bit</code>没有置位，因为所有在<code>large bin</code>中的<code>chunk</code>都处于空闲状态，该标志位一定是清零的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>chunk</code>比<code>large bin</code>的最后一个<code>chunk</code>的大小还小，那么当前<code>chunk</code>就插入到<code>large bin</code>的链表的最后，作为最后一个<code>chunk</code>。可以看出<code>large bin</code>中的<code>chunk</code>是按照从大到小的顺序排序的，同时一个<code>chunk</code>存在于两个双向循环链表中，一个链表包含了<code>large bin</code>中所有的<code>chunk</code>，另一个链表为<code>chunk size</code>链表，该链表从每个相同大小的<code>chunk</code>的取出第一个<code>chunk</code>按照大小顺序链接在一起，便于一次跨域多个相同大小的<code>chunk</code>遍历下一个不同大小的<code>chunk</code>，这样可以加快在<code>large bin</code>链表中的遍历速度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">        assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>正向遍历<code>chunk size</code>链表，直到找到第一个<code>chunk</code>大小小于等于当前<code>chunk</code>大小的<code>chunk</code>退出循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">    <span class="comment">/* Always insert in the second position. */</span></span><br><span class="line">    fwd = fwd-&gt;fd;</span><br></pre></td></tr></table></figure>
<p>如果从<code>large bin</code>链表中找到了与当前<code>chunk</code>大小相同的<code>chunk</code>，则同一大小的<code>chunk</code>已经存在，那么<code>chunk size</code>链表中一定包含了<code>fwd</code>所指向的<code>chunk</code>，为了不修改<code>chunk size</code>链表，当前<code>chunk</code>只能插入<code>fwd</code>之后。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd;<span class="number">92</span></span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>
<p>如果<code>chunk size</code>链表中还没有包含当前<code>chunk</code>大小的<code>chunk</code>，也就是说当前<code>chunk</code>的大小大于<code>fwd</code>的大小，则将当前<code>chunk</code>作为该<code>chunk size</code>的代表加入<code>chunk size</code>链表，<code>chunk size</code>链表也是按照由大到小的顺序排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        &#125;</span><br><span class="line">        bck = fwd-&gt;bk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br></pre></td></tr></table></figure>
<p>如果<code>large bin</code>链表中没有<code>chunk</code>，直接将当前<code>chunk</code>加入<code>chunk size</code>链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>
<p>上面的代码将当前<code>chunk</code>插入到<code>large bin</code>的空闲<code>chunk</code>链表中，并将<code>large bin</code>所对应<code>binmap</code>的相应<code>bit</code>置位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">            <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>如果<code>unsorted bin</code>中的<code>chunk</code>超过了10000个，最多遍历10000个就退出，避免长时间处理<code>unsorted bin</code>影响内存分配的效率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当将<code>unsorted bin</code>中的空闲<code>chunk</code>加入到相应的<code>small bins</code>和<code>large bins</code>后，将使用最佳匹配法分配<code>large bin chunk</code>。源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">sorted order to find smallest that fits. Use the skip list for this.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">        bin = bin_at(av, idx);</span><br><span class="line">        <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">        <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>)(victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br></pre></td></tr></table></figure>
<p>如果所需分配的<code>chunk</code>为<code>large bin chunk</code>，查询对应的<code>large bin</code>链表，如果<code>large bin</code>链表为空，或者链表中最大的<code>chunk</code>也不能满足要求，则不能从<code>large bin</code>中分配。否则，遍历<code>large bin</code>链表，找到合适的<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">victim = victim-&gt;bk_nextsize;</span><br><span class="line"><span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>)(size = chunksize(victim)) &lt;</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">long</span>)(nb)))</span><br><span class="line">    victim = victim-&gt;bk_nextsize;</span><br></pre></td></tr></table></figure>
<p>反向遍历<code>chunk size</code>链表，直到找到第一个大于等于所需<code>chunk</code>大小的<code>chunk</code>退出循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">list does not have to be rerouted. */</span></span><br><span class="line"><span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">    victim = victim-&gt;fd;</span><br></pre></td></tr></table></figure>
<p>如果从<code>large bin</code>链表中选取的<code>chunk victim</code>不是链表中的最后一个<code>chunk</code>，并且与<code>victim</code>大小相同的<code>chunk</code>不止一个，那么意味着<code>victim</code>为<code>chunk size</code>链表中的节点，为了不调整<code>chunk size</code>链表，需要避免将<code>chunk size</code>链表中的节点取出，所以取<code>victim-&gt;fd</code>节点对应的<code>chunk</code>作为候选<code>chunk</code>。由于<code>large bin</code>链表中的<code>chunk</code>也是按大小排序，同一大小的<code>chunk</code>有多个时，这些<code>chunk</code>必定排在一起，所以<code>victim-&gt;fd</code>节点对应的<code>chunk</code>的大小必定与<code>victim</code>的大小一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remainder_size = size - nb;</span><br><span class="line">unlink(victim, bck, fwd);</span><br></pre></td></tr></table></figure>
<p>计算将<code>victim</code>切分后剩余大小，并调用<code>unlink()</code>宏函数将<code>victim</code>从<code>large bin</code>链表中取出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Exhaust */</span></span><br><span class="line"><span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">    set_inuse_bit_at_offset(victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br></pre></td></tr></table></figure>
<p>如果将<code>victim</code>切分后剩余大小小于<code>MINSIZE</code>，则将这个<code>victim</code>分配给应用层，这种情况下，实际分配的<code>chunk</code>比所需的<code>chunk</code>要大一些。以64位系统为例，<code>remainder_size</code>的可能大小为0和16，如果为0，表示<code>victim</code>的大小刚好等于所需<code>chunk</code>的大小，设置<code>victim</code>的<code>inuse</code>标志，<code>inuse</code>标志位于下一个相邻的<code>chunk</code>的<code>size</code>字段中。如果<code>remainder_size</code>为16，则这16字节就浪费掉了。如果当前分配区不是主分配区，将<code>victim</code>的<code>size</code>字段中的非主分配区标志置位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Split */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">    have to perform a complete insert here. */</span></span><br><span class="line">    bck = unsorted_chunks(av);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (fwd-&gt;bk != bck, <span class="number">0</span>))<span class="number">94</span></span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    remainder-&gt;bk = bck;</span><br><span class="line">    remainder-&gt;fd = fwd;</span><br><span class="line">    bck-&gt;fd = remainder;</span><br><span class="line">    fwd-&gt;bk = remainder;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从<code>victim</code>中切分出所需的<code>chunk</code>，剩余部分作为一个新的<code>chunk</code>加入到<code>unsorted bin</code>中。如果剩余部分<code>chunk</code>属于<code>large bins</code>，将剩余部分<code>chunk</code>的<code>chunk size</code>链表指针设置为<code>NULL</code>，因为<code>unsorted bin</code>中的<code>chunk</code>是不排序的，这两个指针无用，必须清零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE |</span><br><span class="line">(av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">set_foot(remainder, remainder_size);</span><br></pre></td></tr></table></figure>
<p>设置<code>victim</code>和<code>remainder</code>的状态，由于<code>remainder</code>为空闲<code>chunk</code>，所以需要设置该<code>chunk</code>的<code>foot</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<p>从<code>large bin</code>中使用最佳匹配法找到了合适的<code>chunk</code>，调用<code>chunk2mem()</code>获得<code>chunk</code>中可用的内存指针，返回给应用层，退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果通过上面的方式从最合适的<code>small bin</code>或<code>large bin</code>中都没有分配到需要的<code>chunk</code>，则查看比当前<code>bin</code>的<code>index</code>大的<code>small bin</code>或<code>large bin</code>是否有空闲<code>chunk</code>可利用来分配所需的<code>chunk</code>。源代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">(with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">that fits is selected.95</span></span><br><span class="line"><span class="comment">The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    ++idx;</span><br><span class="line">    bin = bin_at(av,idx);</span><br><span class="line">    block = idx2block(idx);</span><br><span class="line">    <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">    bit = idx2bit(idx);</span><br></pre></td></tr></table></figure>
<p>获取下一个相邻<code>bin</code>的空闲<code>chunk</code>链表，并获取该<code>bin</code>对于<code>binmap</code>中的<code>bit</code>位的值。<code>binmap</code>中的标识了相应的<code>bin</code>中是否有空闲<code>chunk</code>存在。<code>binmap</code>按<code>block</code>管理，每个<code>block</code>为一个<code>int</code>，共32个<code>bit</code>，可以表示32个<code>bin</code>中是否有空闲<code>chunk</code>存在。使用<code>binmap</code>可以加快查找<code>bin</code>是否包含空闲<code>chunk</code>。这里只查询比所需<code>chunk</code>大的<code>bin</code>中是否有空闲<code>chunk</code>可用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block. */</span></span><br><span class="line">    <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( (<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line">        bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>idx2bit()</code>宏将<code>idx</code>指定的位设置为1，其它位清零，<code>map</code>表示一个<code>block</code>（unsigned int）值，如果<code>bit</code>大于<code>map</code>，意味着<code>map</code>为0，该<code>block</code>所对应的所有<code>bins</code>中都没有空闲<code>chunk</code>，于是遍历<code>binmap</code>的下一个<code>block</code>，直到找到一个不为0的<code>block</code>或者遍历完所有的<code>block</code>。</p>
<p>退出循环遍历后，设置<code>bin</code>指向<code>block</code>的第一个<code>bit</code>对应的<code>bin</code>，并将<code>bit</code>置为1，表示该<code>block</code>中<code>bit 1</code>对应的<code>bin</code>，这个<code>bin</code>中如果有空闲<code>chunk</code>，该<code>chunk</code>的大小一定满足要求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert(bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个<code>block</code>遍历对应的<code>bin</code>，直到找到一个<code>bit</code>不为0退出遍历，则该<code>bit</code>对于的<code>bin</code>中有空闲<code>chunk</code>存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">victim = last(bin);</span><br></pre></td></tr></table></figure>
<p>将<code>bin</code>链表中的最后一个<code>chunk</code>赋值为<code>victim</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">    av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果<code>victim</code>与<code>bin</code>链表头指针相同，表示该<code>bin</code>中没有空闲<code>chunk</code>，<code>binmap</code>中的相应位设置不准确，将<code>binmap</code>的相应<code>bit</code>位清零，获取当前<code>bin</code>下一个<code>bin</code>，将<code>bit</code>移到下一个<code>bit</code>位，即乘以2。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line">    <span class="comment">/* We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb));</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink(victim, bck, fwd);</span><br></pre></td></tr></table></figure>
<p>当前<code>bin</code>中的最后一个<code>chunk</code>满足要求，获取该<code>chunk</code>的大小，计算切分出所需<code>chunk</code>后剩余部分的大小，然后将<code>victim</code>从<code>bin</code>的链表中取出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Exhaust */</span></span><br><span class="line"><span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">    set_inuse_bit_at_offset(victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    victim-&gt;size |= NON_MAIN_ARENA;</span><br></pre></td></tr></table></figure>
<p>如果剩余部分的大小小于<code>MINSIZE</code>，将整个<code>chunk</code>分配给应用层，设置<code>victim</code>的状态为<code>inuse</code>，如果当前分配区为非主分配区，设置<code>victim</code>的非主分配区标志位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Split */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">    have to perform a complete insert here. */</span></span><br><span class="line">    bck = unsorted_chunks(av);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (fwd-&gt;bk != bck, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    remainder-&gt;bk = bck;</span><br><span class="line">    remainder-&gt;fd = fwd;</span><br><span class="line">    bck-&gt;fd = remainder;</span><br><span class="line">    fwd-&gt;bk = remainder;</span><br><span class="line">    <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">    av-&gt;last_remainder = remainder;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从<code>victim</code>中切分出所需的<code>chunk</code>，剩余部分作为一个新的<code>chunk</code>加入到<code>unsorted bin</code>中。如果剩余部分<code>chunk</code>属于<code>small bins</code>，将分配区的<code>last remainder chunk</code>设置为剩余部分构成的<code>chunk</code>；如果剩余部分<code>chunk</code>属于<code>large bins</code>，将剩余部分<code>chunk</code>的<code>chunk size</code>链表指针设置为<code>NULL</code>，因为<code>unsorted bin</code>中的<code>chunk</code>是不排序的，这两个指针无用，必须清零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE |</span><br><span class="line">(av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">set_foot(remainder, remainder_size);</span><br></pre></td></tr></table></figure>
<p>设置<code>victim</code>和<code>remainder</code>的状态，由于<code>remainder</code>为空闲<code>chunk</code>，所以需要设置该<code>chunk</code>的<code>foot</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<p>调用<code>chunk2mem()</code>获得<code>chunk</code>中可用的内存指针，返回给应用层，退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果从所有的<code>bins</code>中都没有获得所需的<code>chunk</code>，可能的情况为<code>bins</code>中没有空闲<code>chunk</code>，或者所需的<code>chunk</code>大小很大，下一步将尝试从<code>top chunk</code>中分配所需<code>chunk</code>。源代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">(held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">search rule. In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">limitations).98</span></span><br><span class="line"><span class="comment">We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize(victim);</span><br></pre></td></tr></table></figure>
<p>将当前分配区的<code>top chunk</code>赋值给<code>victim</code>，并获得<code>victim</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>top chunk</code>切分出所需<code>chunk</code>后，还需要<code>MINSIZE</code>的空间来作为<code>fencepost</code>，所需必须满足<code>top chunk</code>的大小大于所需<code>chunk</code>的大小加上<code>MINSIZE</code>这个条件，才能从<code>top chunk</code>中分配所需<code>chunk</code>。从<code>top chunk</code>切分出所需<code>chunk</code>的处理过程跟前面的<code>chunk</code>切分类似，不同的是，原<code>top chunk</code>切分后的剩余部分将作为新的<code>top chunk</code>，原<code>top chunk</code>的<code>fencepost</code>仍然作为新的<code>top chunk</code>的<code>fencepost</code>，所以切分之后剩余的<code>chunk</code>不用<code>set_foot</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">    here for all block sizes. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">        <span class="comment">/* restore original bin index */</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">            idx = smallbin_index(nb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index(nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>top chunk</code>也不能满足要求，查看<code>fast bins</code>中是否有空闲<code>chunk</code>存在，由于开启了<code>ATOMIC_FASTBINS</code>优化情况下，<code>free</code>属于<code>fast bins</code>的<code>chunk</code>时不需要获得分配区的锁，所以在调用<code>_int_malloc()</code>函数时，有可能有其它线程已经向<code>fast bins</code>中加入了新的空闲<code>chunk</code>，也有可能是所需的<code>chunk</code>属于<code>small bins</code>，但通过前面的步骤都没有分配到所需的<code>chunk</code>，由于分配<code>small bin chunk</code>时在前面的步骤都不会调用<code>malloc_consolidate()</code>函数将<code>fast bins</code>中的<code>chunk</code>合并加入到<code>unsorted bin</code>中。所在这里如果<code>fast bin</code>中有<code>chunk</code>存在，调用<code>malloc_consolidate()</code>函数，并重新设置当前<code>bin</code>的<code>index</code>。并转到最外层的循环，尝试重新分配<code>small bin chunk</code>或是<code>large bin chunk</code>。如果开启了<code>ATOMIC_FASTBINS</code>优化，有可能在由其它线程加入到<code>fast bins</code>中的<code>chunk</code>被合并后加入<code>unsorted bin</code>中，从<code>unsorted bin</code>中就可以分配出所需的<code>large bin chunk</code>了，所以对没有成功分配的<code>large bin chunk</code>也需要重试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If there is space available in fastbins, consolidate and retry,</span></span><br><span class="line"><span class="comment">    to possibly avoid expanding memory. This can occur only if nb is</span></span><br><span class="line"><span class="comment">    in smallbin range so we didn&#x27;t consolidate upon entry.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">        assert(in_smallbin_range(nb));</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">        idx = smallbin_index(nb); <span class="comment">/* restore original bin index */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>top chunk</code>也不能满足要求，查看<code>fast bins</code>中是否有空闲<code>chunk</code>存在，如果<code>fast bins</code>中有空闲<code>chunk</code>存在，在没有开启<code>ATOMIC_FASTBINS</code>优化的情况下，只有一种可能，那就是所需的<code>chunk</code>属于<code>small bins</code>，但通过前面的步骤都没有分配到所需的<code>small bin chunk</code>，由于分配<code>small bin chunk</code>时在前面的步骤都不会调用<code>malloc_consolidate()</code>函数将<code>fast bins</code>中的空闲<code>chunk</code>合并加入到<code>unsorted bin</code>中。所在这里如果<code>fast bins</code>中有空闲<code>chunk</code>存在，调用<code>malloc_consolidate()</code>函数，并重新设置当前<code>bin</code>的<code>index</code>。并转到最外层的循环，尝试重新分配<code>small bin chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">void</span> *p = sYSMALLOc(nb, av);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<p>山穷水尽了，只能向系统申请内存了。<code>sYSMALLOc()</code>函数可能分配的<code>chunk</code>包括<code>small bin chunk</code>，<code>large bin chunk</code>和<code>large chunk</code>。将在下一节中介绍该函数的实现。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，<code>_int_malloc()</code>函数的代码就罗列完了，当还有两个关键函数没有分析，一个为<code>malloc_consolidate()</code>，另一个为<code>sYSMALLOc()</code>，将在下面的章节介绍其实现。</p>
<h4 id="sYSMALLOc"><a href="#sYSMALLOc" class="headerlink" title="sYSMALLOc()"></a>sYSMALLOc()</h4><p>当<code>_int_malloc()</code>函数尝试从<code>fast bins</code>，<code>last remainder chunk</code>，<code>small bins</code>，<code>large bins</code>和<code>top chunk</code>都失败之后，就会使用<code>sYSMALLOc()</code>函数直接向系统申请内存用于分配所需的<code>chunk</code>。其实现源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sysmalloc handles malloc cases requiring more memory from the system.</span></span><br><span class="line"><span class="comment">On entry, it is assumed that av-&gt;top does not have enough</span></span><br><span class="line"><span class="comment">space to service request for nb bytes, thus requiring that av-&gt;top</span></span><br><span class="line"><span class="comment">be extended or replaced.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> <span class="type">void_t</span>* <span class="title function_">sYSMALLOc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void_t</span>* <span class="title function_">sYSMALLOc</span><span class="params">(nb, av)</span> INTERNAL_SIZE_T nb; mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mchunkptr old_top; <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">    INTERNAL_SIZE_T old_size; <span class="comment">/* its size */</span></span><br><span class="line">    <span class="type">char</span>* old_end; <span class="comment">/* its end address */</span></span><br><span class="line">    <span class="type">long</span> size; <span class="comment">/* arg to first MORECORE or`mmap`call */</span></span><br><span class="line">    <span class="type">char</span>* brk; <span class="comment">/* return value from MORECORE */</span></span><br><span class="line">    <span class="type">long</span> correction; <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">    <span class="type">char</span>* snd_brk; <span class="comment">/* 2nd return val */</span></span><br><span class="line">    INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">    INTERNAL_SIZE_T end_misalign; <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">    <span class="type">char</span>* aligned_brk; <span class="comment">/* aligned offset into brk */</span></span><br><span class="line">    mchunkptr p; <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">    mchunkptr remainder; <span class="comment">/* remainder from allocation */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* its size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sum; <span class="comment">/* for updating stats */</span></span><br><span class="line">    <span class="type">size_t</span> pagemask = mp_.pagesize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If have mmap, and the request size meets the`mmap`threshold, and101</span></span><br><span class="line"><span class="comment">    the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">    allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">    rather than expanding top.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmap_threshold) &amp;&amp;</span><br><span class="line">    (mp_.n_mmaps &lt; mp_.n_mmaps_max)) &#123;</span><br><span class="line">        <span class="type">char</span>* mm; <span class="comment">/* return value from mmap call*/</span></span><br></pre></td></tr></table></figure>
<p>如果所需分配的<code>chunk</code>大小大于<code>mmap</code>分配阈值，默认为128K<code>，并且当前进程使用</code>mmap()<code>分配的内存块小于设定的最大值，将使用</code>mmap()`系统调用直接向操作系统申请内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try_mmap:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Round up size to nearest page. For mmapped chunks, the overhead</span></span><br><span class="line"><span class="comment">        is one SIZE_SZ unit larger than for normal chunks, because there</span></span><br><span class="line"><span class="comment">        is no following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">        <span class="comment">/* See the front_misalign handling below, for glibc there is no</span></span><br><span class="line"><span class="comment">        need for further alignments. */</span></span><br><span class="line">        size = (nb + SIZE_SZ + pagemask) &amp; ~pagemask;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        size = (nb + SIZE_SZ + MALLOC_ALIGN_MASK + pagemask) &amp; ~pagemask;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        tried_mmap = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>由于<code>nb</code>为所需<code>chunk</code>的大小，在<code>_int_malloc()</code>函数中已经将用户需要分配的大小转化为<code>chunk</code>大小，当如果这个<code>chunk</code>直接使用<code>mmap()</code>分配的话，该<code>chunk</code>不存在下一个相邻的<code>chunk</code>，也就没有<code>prev_size</code>的内存空间可以复用，所以还需要额外<code>SIZE_SZ</code>大小的内存。由于<code>mmap()</code>分配的内存块必须页对齐。如果使用<code>mmap()</code>分配内存，需要重新计算分配的内存大小<code>size</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">            mm = (<span class="type">char</span>*)(MMAP(<span class="number">0</span>, size, PROT_READ|PROT_WRITE, MAP_PRIVATE));</span><br><span class="line">            <span class="keyword">if</span> (mm != MAP_FAILED) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                The offset to the start of the mmapped region is stored</span></span><br><span class="line"><span class="comment">                in the prev_size field of the chunk. This allows us to adjust</span></span><br><span class="line"><span class="comment">                returned start address to meet alignment requirements here</span></span><br><span class="line"><span class="comment">                and in memalign(), and still be able to compute proper</span></span><br><span class="line"><span class="comment">                address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">                <span class="comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span></span><br><span class="line"><span class="comment">                MALLOC_ALIGN_MASK is 2*SIZE_SZ-1. Each mmap&#x27;ed area is page102</span></span><br><span class="line"><span class="comment">                aligned and therefore definitely MALLOC_ALIGN_MASK-aligned. */</span></span><br><span class="line">                assert (((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                    p = (mchunkptr)(mm + correction);</span><br><span class="line">                    p-&gt;prev_size = correction;</span><br><span class="line">                    set_head(p, (size - correction) |IS_MMAPPED);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#123;</span><br><span class="line">                    p = (mchunkptr)mm;</span><br><span class="line">                    set_head(p, size|IS_MMAPPED);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>如果重新计算所需分配的<code>size</code>小于<code>nb</code>，表示溢出了，不分配内存，否则，调用<code>mmap()</code>分配所需大小的内存。如果<code>mmap()</code>分配内存成功，将<code>mmap()</code>返回的内存指针强制转换为<code>chunk</code>指针，并设置该<code>chunk</code>的大小为<code>size</code>，同时设置该<code>chunk</code>的<code>IS_MMAPPED</code>标志位，表示本<code>chunk</code>是通过<code>mmap()</code>函数直接从系统分配的。由于<code>mmap()</code>返回的内存地址是按照页对齐的，也一定是按照<code>2*SIZE_SZ</code>对齐的，满足<code>chunk</code>的边界对齐规则，使用<code>chunk2mem()</code>获取<code>chunk</code>中实际可用的内存也没有问题，所以这里不需要做额外的对齐操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                <span class="comment">/* update statistics */</span></span><br><span class="line">                <span class="keyword">if</span> (++mp_.n_mmaps &gt; mp_.max_n_mmaps)</span><br><span class="line">                    mp_.max_n_mmaps = mp_.n_mmaps;</span><br><span class="line">                sum = mp_.mmapped_mem += size;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.max_mmapped_mem))</span><br><span class="line">                    mp_.max_mmapped_mem = sum;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_THREADS</span></span><br><span class="line">                sum += av-&gt;system_mem;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.max_total_mem))</span><br><span class="line">                    mp_.max_total_mem = sum;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>更新相关统计值，首先将当前进程<code>mmap</code>分配内存块的计数加一，如果使用<code>mmap()</code>分配的内存块数量大于设置的最大值，将最大值设置为最新值，这个判断不会成功，因为使用<code>mmap</code>分配内存的条件中包括了<code>mp_.n_mmaps &lt; mp_.n_mmaps_max</code>，所以<code>++mp_.n_mmaps &gt; mp_.max_n_mmaps</code>不会成立。然后更新<code>mmap</code>分配的内存总量，如果该值大于设置的最大值，将当前值赋值给<code>mp_.max_mmapped_mem</code>。如果只支持单线程，还需要计数当前进程所分配的内存总数，如果总数大于设置的最大值<code>mp_.max_total_mem</code>，修改<code>mp_.max_total_mem</code>为当前值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                check_chunk(av, p);</span><br><span class="line">                <span class="keyword">return</span> chunk2mem(p);<span class="number">103</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line">    old_top = av-&gt;top;</span><br><span class="line">    old_size = chunksize(old_top);</span><br><span class="line">    old_end = (<span class="type">char</span>*)(chunk_at_offset(old_top, old_size));</span><br><span class="line">    brk = snd_brk = (<span class="type">char</span>*)(MORECORE_FAILURE);</span><br></pre></td></tr></table></figure>
<p>保存当前<code>top chunk</code>的指针，大小和结束地址到临时变量中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">    at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">    prev_inuse(old_top) &amp;&amp;</span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">long</span>)old_end &amp; pagemask) == <span class="number">0</span>));</span><br><span class="line">    <span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">    assert((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE));</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    <span class="comment">/* Precondition: all fastbins are consolidated */</span></span><br><span class="line">    assert(!have_fastchunks(av));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>检查<code>top chunk</code>的合法性，如果第一次调用本函数，<code>top chunk</code>可能没有初始化，可能<code>old_size</code>为0，如果<code>top chunk</code>已经初始化，则<code>top chunk</code>的大小必须大于等于<code>MINSIZE</code>，因为<code>top chunk</code>中包含了<code>fencepost</code>，<code>fencepost</code>需要<code>MINSIZE</code>大小的内存。<code>top chunk</code>必须标识前一个<code>chunk</code>处于<code>inuse</code>状态，这是规定，并且<code>top chunk</code>的结束地址必定是页对齐的。另外<code>top chunk</code>的除去<code>fencepost</code>的大小必定小于所需<code>chunk</code>的大小，不然在<code>_int_malloc()</code>函数中就应该使用<code>top chunk</code>获得所需的<code>chunk</code>。最后检查如果没有开启<code>ATOMIC_FASTBINS</code>优化，在使用<code>_int_malloc()</code>分配内存时，获得了分配区的锁，<code>free</code>时也要获得分配区的锁才能向<code>fast bins</code>中加入新的<code>chunk</code>，由于<code>_int_malloc()</code>在调用本函数前，已经将<code>fast bins</code>中的所有<code>chunk</code>都合并加入到<code>unsorted bin</code>中了，所以，本函数中<code>fast bins</code>中一定不会有空闲<code>chunk</code>存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena) &#123;</span><br><span class="line">        heap_info *old_heap, *heap;</span><br><span class="line">        <span class="type">size_t</span> old_heap_size;</span><br><span class="line">        <span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">        old_heap = heap_for_ptr(old_top);</span><br><span class="line">        old_heap_size = old_heap-&gt;size;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0104</span></span><br><span class="line">        &amp;&amp; grow_heap(old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>) &#123;</span><br><span class="line">            av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">            arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span>(mmapped_mem + arena_mem + sbrked_mem &gt; max_total_mem)</span><br><span class="line">                max_total_mem = mmapped_mem + arena_mem + sbrked_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            set_head(old_top, (((<span class="type">char</span> *)old_heap + old_heap-&gt;size) - (<span class="type">char</span> *)old_top)</span><br><span class="line">            | PREV_INUSE);</span><br></pre></td></tr></table></figure>
<p>如果当前分配区为非主分配区，根据<code>top chunk</code>的指针获得当前<code>sub_heap</code>的<code>heap_info</code>实例，如果<code>top chunk</code>的剩余有效空间不足以分配出所需的<code>chunk</code>（前面已经断言，这个肯定成立），尝试增长<code>sub_heap</code>的可读可写区域大小，如果成功，修改过内存分配的统计信息，并更新新的<code>top chunk</code>的<code>size</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap(nb + (MINSIZE + <span class="keyword">sizeof</span>(*heap)), mp_.top_pad))) &#123;</span><br></pre></td></tr></table></figure>
<p>调用<code>new_heap()</code>函数创建一个新的<code>sub_heap</code>，由于这个<code>sub_heap</code>中至少需要容下大小为<code>nb</code>的<code>chunk</code>，大小为<code>MINSIZE</code>的<code>fencepost</code>和大小为<code>sizeof(*heap)</code>的<code>heap_info</code>实例，所以传入<code>new_heap()</code>函数的分配大小为<code>nb + (MINSIZE + sizeof(*heap))</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* Use a newly allocated heap. */</span></span><br><span class="line">            heap-&gt;ar_ptr = av;</span><br><span class="line">            heap-&gt;prev = old_heap;</span><br><span class="line">            av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">            arena_mem += heap-&gt;size;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)(mmapped_mem + arena_mem + sbrked_mem) &gt; max_total_mem)</span><br><span class="line">                max_total_mem = mmapped_mem + arena_mem + sbrked_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">/* Set up the new top. */</span></span><br><span class="line">            top(av) = chunk_at_offset(heap, <span class="keyword">sizeof</span>(*heap));</span><br><span class="line">            set_head(top(av), (heap-&gt;size - <span class="keyword">sizeof</span>(*heap)) | PREV_INUSE);</span><br></pre></td></tr></table></figure>
<p>使新创建的<code>sub_heap</code>保存当前的分配区指针，将该<code>sub_heap</code>加入当前分配区的<code>sub_heap</code>链表中，更新当前分配区内存分配统计，将新创建的<code>sub_heap</code>仅有的一个空闲<code>chunk</code>作为当前分配区的<code>top chunk</code>，并设置<code>top chunk</code>的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* Setup fencepost and free the old top chunk. */</span></span><br><span class="line">            <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">            become the top chunk again later. Note that a footer is set</span></span><br><span class="line"><span class="comment">            up, too, although the chunk is marked in use. */</span></span><br><span class="line">            old_size -= MINSIZE;</span><br><span class="line">            set_head(chunk_at_offset(old_top, old_size + <span class="number">2</span>*SIZE_SZ), <span class="number">0</span>|PREV_INUSE);</span><br><span class="line">            <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line">                set_head(chunk_at_offset(old_top, old_size), (<span class="number">2</span>*SIZE_SZ)|PREV_INUSE);<span class="number">105</span></span><br><span class="line">                set_foot(chunk_at_offset(old_top, old_size), (<span class="number">2</span>*SIZE_SZ));</span><br><span class="line">                set_head(old_top, old_size|PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">                _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                _int_free(av, old_top);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set_head(old_top, (old_size + <span class="number">2</span>*SIZE_SZ)|PREV_INUSE);</span><br><span class="line">                set_foot(old_top, (old_size + <span class="number">2</span>*SIZE_SZ));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>设置原<code>top chunk</code>的<code>fencepost</code>，<code>fencepost</code>需要<code>MINSIZE</code>大小的内存空间，将该<code>old_size</code>减去<code>MINSIZE</code>得到原<code>top chunk</code>的有效内存空间，首先设置<code>fencepost</code>的第二个<code>chunk</code>的<code>size</code>为0，并标识前一个<code>chunk</code>处于<code>inuse</code>状态。接着判断原<code>top chunk</code>的有效内存空间上是否大于等于<code>MINSIZE</code>，如果是，表示原<code>top chunk</code>可以分配出大于等于<code>MINSIZE</code>大小的<code>chunk</code>，于是将原<code>top chunk</code>切分成空闲<code>chunk</code>和<code>fencepost</code>两部分，先设置<code>fencepost</code>的第一个<code>chunk</code>的大小为<code>2*SIZE_SZ</code>，并标识前一个<code>chunk</code>处于<code>inuse</code>状态，<code>fencepost</code>的第一个<code>chunk</code>还需要设置<code>foot</code>，表示该<code>chunk</code>处于空闲状态，而<code>fencepost</code>的第二个<code>chunk</code>却标识第一个<code>chunk</code>处于<code>inuse</code>状态，因为不能有两个空闲<code>chunk</code>相邻，才会出现这么奇怪的<code>fencepost</code>。另外其实<code>top chunk</code>切分出来的<code>chunk</code>也是处于空闲状态，但<code>fencepost</code>的第一个<code>chunk</code>却标识前一个<code>chunk</code>为<code>inuse</code>状态，然后强制将该处于<code>inuse</code>状态的<code>chunk</code>调用<code>_int_free()</code>函数释放掉。这样做完全是要遵循不能有两个空闲<code>chunk</code>相邻的约定。</p>
<p>如果原<code>top chunk</code>中有效空间不足<code>MINSIZE</code>，则将整个原<code>top chunk</code>作为<code>fencepost</code>，并设置<code>fencepost</code>的第一个<code>chunk</code>的相关状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">    <span class="comment">/* We can at least try to use to`mmap`memory. */</span></span><br><span class="line">    <span class="keyword">goto</span> try_mmap;</span><br></pre></td></tr></table></figure>
<p>如果增长<code>sub_heap</code>的可读可写区域大小和创建新<code>sub_heap</code>都失败了，尝试使用<code>mmap()</code>函数直接从系统分配所需<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">/* av == main_arena */</span></span><br><span class="line">    <span class="comment">/* Request enough space for nb + pad + overhead */</span></span><br><span class="line">    size = nb + mp_.top_pad + MINSIZE;</span><br></pre></td></tr></table></figure>
<p>如果为当前分配区为主分配区，重新计算需要分配的<code>size</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If contiguous, we can subtract out existing space that we hope to</span></span><br><span class="line"><span class="comment">combine with new space. We add it back later only if</span></span><br><span class="line"><span class="comment">we don&#x27;t actually get contiguous space.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (contiguous(av))</span><br><span class="line">    size -= old_size;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下，主分配区使用<code>sbrk()</code>从<code>heap</code>中分配内存，<code>sbrk()</code>返回连续的虚拟内存，这里调整需要分配的<code>size</code>，减掉<code>top chunk</code>中已有空闲内存大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">with whole-page arguments. And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">size = (size + pagemask) &amp; ~pagemask;</span><br></pre></td></tr></table></figure>
<p>将<code>size</code>按照页对齐，<code>sbrk()</code>必须以页为单位分配连续虚拟内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Don&#x27;t try to call MORECORE if argument is so big as to appear</span></span><br><span class="line"><span class="comment">negative. Note that since`mmap`takes size_t arg, it may succeed</span></span><br><span class="line"><span class="comment">below even if we cannot call MORECORE.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">    brk = (<span class="type">char</span>*)(MORECORE(size));</span><br></pre></td></tr></table></figure>
<p>使用<code>sbrk()</code>从<code>heap</code>中分配<code>size</code>大小的虚拟内存块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk != (<span class="type">char</span>*)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    <span class="comment">/* Call the `morecore&#x27; hook if necessary. */</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">void</span>) = force_reg (__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        (*hook) ();</span><br></pre></td></tr></table></figure>
<p>如果<code>sbrk()</code>分配成功，并且<code>morecore</code>的<code>hook</code>函数存在，调用<code>morecore</code>的<code>hook</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            If have mmap, try using it as a backup when MORECORE fails or</span></span><br><span class="line"><span class="comment">            cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span></span><br><span class="line"><span class="comment">            address space, so sbrk cannot extend to give contiguous space, but</span></span><br><span class="line"><span class="comment">            space is available elsewhere. Note that we ignore mmap max count</span></span><br><span class="line"><span class="comment">            and threshold limits, since the space will not be used as a</span></span><br><span class="line"><span class="comment">            segregated mmap region.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">            <span class="comment">/* Cannot merge with old top, so add its size back in */</span></span><br><span class="line">            <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">                size = (size + old_size + pagemask) &amp; ~pagemask;</span><br><span class="line">            <span class="comment">/* If we are relying on`mmap`as backup, then use larger units */</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(MMAP_AS_MORECORE_SIZE))</span><br><span class="line">                size = MMAP_AS_MORECORE_SIZE;</span><br></pre></td></tr></table></figure>
<p>如果<code>sbrk()</code>返回失败，或是<code>sbrk()</code>不可用，使用<code>mmap()</code>代替，重新计算所需分配的内存大小并按页对齐，如果重新计算的<code>size</code>小于1M<code>，将</code>size<code>设为1M</code>，也就是说使用<code>mmap()</code>作为<code>morecore</code>函数分配的最小内存块大小为1M。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">                <span class="type">char</span> *mbrk = (<span class="type">char</span>*)(MMAP(<span class="number">0</span>, size, PROT_READ|PROT_WRITE, MAP_PRIVATE));</span><br><span class="line">                <span class="keyword">if</span> (mbrk != MAP_FAILED) &#123;</span><br><span class="line">                    <span class="comment">/* We do not need, and cannot use, another sbrk call to find end */</span></span><br><span class="line">                    brk = mbrk;</span><br><span class="line">                    snd_brk = brk + size;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    Record that we no longer have a contiguous sbrk region.</span></span><br><span class="line"><span class="comment">                    After the first time`mmap`is used as backup, we do not</span></span><br><span class="line"><span class="comment">                    ever rely on contiguous space since this could incorrectly</span></span><br><span class="line"><span class="comment">                    bridge regions.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    set_noncontiguous(av);</span><br><span class="line">                &#125;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">如果所需分配的内存大小合法，使用`mmap()`函数分配内存。如果分配成功，更新`brk`和`snd_brk`，并将当前分配区属性设置为可分配不连续虚拟内存块。</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (brk != (<span class="type">char</span>*)(MORECORE_FAILURE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">                mp_.sbrk_base = brk;</span><br><span class="line">            av-&gt;system_mem += size;</span><br></pre></td></tr></table></figure>
<p>如果<code>brk</code>合法，即<code>sbrk()</code>或<code>mmap()</code>分配成功，如果<code>sbrk_base</code>还没有初始化，更新<code>sbrk_base</code>和当前分配区的内存分配总量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If MORECORE extends previous space, we can likewise extend top size.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="type">char</span>*)(MORECORE_FAILURE))</span><br><span class="line">    set_head(old_top, (size + old_size) | PREV_INUSE);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (contiguous(av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123;</span><br><span class="line">    <span class="comment">/* Oops! Someone else killed our space.. Can&#x27;t touch anything. */</span></span><br><span class="line">    malloc_printerr (<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>sbrk()</code>分配成功，更新<code>top chunk</code>的大小，并设定<code>top chunk</code>的前一个<code>chunk</code>处于<code>inuse</code>状态。如果当前分配区可分配连续虚拟内存，原<code>top chunk</code>的大小大于0，但新的<code>brk</code>值小于原<code>top chunk</code>的结束地址，出错了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Otherwise, make adjustments:</span></span><br><span class="line"><span class="comment">* If the first time through or noncontiguous, we need to call sbrk</span></span><br><span class="line"><span class="comment">just to find out where the end of memory lies.</span></span><br><span class="line"><span class="comment">* We need to ensure that all returned chunks from malloc will meet</span></span><br><span class="line"><span class="comment">MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment">* If there was an intervening foreign sbrk, we need to adjust sbrk</span></span><br><span class="line"><span class="comment">request size to account for fact that we will not be able to</span></span><br><span class="line"><span class="comment">combine new space with existing space in old_top.</span></span><br><span class="line"><span class="comment">* Almost all systems internally allocate whole pages at a time, in</span></span><br><span class="line"><span class="comment">which case we might as well use the whole last page of request.</span></span><br><span class="line"><span class="comment">So we allocate enough more memory to hit a page boundary now,</span></span><br><span class="line"><span class="comment">which in turn causes future contiguous calls to page-align.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    front_misalign = <span class="number">0</span>;</span><br><span class="line">    end_misalign = <span class="number">0</span>;</span><br><span class="line">    correction = <span class="number">0</span>;</span><br><span class="line">    aligned_brk = brk;</span><br></pre></td></tr></table></figure>
<p>执行到这个分支，意味着<code>sbrk()</code>返回的<code>brk</code>值大于原<code>top chunk</code>的结束地址，那么新的地址与原<code>top chunk</code>的地址不连续，可能是由于外部其它地方调用`sbrk()函数，这里需要处理地址的重新对齐问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* handle contiguous cases */</span></span><br><span class="line"><span class="keyword">if</span> (contiguous(av)) &#123;</span><br><span class="line">    <span class="comment">/* Count foreign sbrk as system_mem. */</span></span><br><span class="line">    <span class="keyword">if</span> (old_size)</span><br><span class="line">        av-&gt;system_mem += brk - old_end;</span><br></pre></td></tr></table></figure>
<p>如果本分配区可分配连续虚拟内存，并且有外部调用了<code>sbrk()</code>函数，将外部调用<code>sbrk()</code>分配的内存计入当前分配区所分配内存统计中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Guarantee alignment of first new chunk made from this space */</span></span><br><span class="line">front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line"><span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">    We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">    They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">    prev_inuse of av-&gt;top (and any chunk created from its start)109</span></span><br><span class="line"><span class="comment">    is always true after initialization.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">    aligned_brk += correction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算当前的<code>brk</code>要矫正的字节数据，保证<code>brk</code>地址按<code>MALLOC_ALIGNMENT</code>对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If this isn&#x27;t adjacent to existing space, then we will not</span></span><br><span class="line"><span class="comment">be able to merge with old_top space, so must add to 2nd request.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">correction += old_size;</span><br><span class="line"><span class="comment">/* Extend the end address to hit a page boundary */</span></span><br><span class="line">end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);</span><br><span class="line">correction += ((end_misalign + pagemask) &amp; ~pagemask) - end_misalign;</span><br><span class="line">assert(correction &gt;= <span class="number">0</span>);</span><br><span class="line">snd_brk = (<span class="type">char</span>*)(MORECORE(correction));</span><br></pre></td></tr></table></figure>
<p>由于原<code>top chunk</code>的地址与当前<code>brk</code>不相邻，也就不能再使用原<code>top chunk</code>的内存了，需要重新为所需<code>chunk</code>分配足够的内存，将原<code>top chunk</code>的大小加到矫正值中，从当前<code>brk</code>中分配所需<code>chunk</code>，计算出未对齐的<code>chunk</code>结束地址<code>end_misalign</code>，然后将<code>end_misalign</code>按照页对齐计算出需要矫正的字节数加到矫正值上。然后再调用<code>sbrk()</code>分配矫正值大小的内存，如果<code>sbrk()</code>分配成功，则当前的<code>top chunk</code>中可以分配出所需的连续内存的<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If can&#x27;t allocate correction, try to at least find out current</span></span><br><span class="line"><span class="comment">brk. It might be enough to proceed without failing.</span></span><br><span class="line"><span class="comment">Note that if second sbrk did NOT fail, we assume that space</span></span><br><span class="line"><span class="comment">is contiguous with first sbrk. This is a safe assumption unless</span></span><br><span class="line"><span class="comment">program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span></span><br><span class="line"><span class="comment">occurred between our first and second calls.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (snd_brk == (<span class="type">char</span>*)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    correction = <span class="number">0</span>;</span><br><span class="line">    snd_brk = (<span class="type">char</span>*)(MORECORE(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>如果<code>sbrk()</code>执行失败，更新当前<code>brk</code>的结束地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Call the `morecore&#x27; hook if necessary. */</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">void</span>) = force_reg (__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        (*hook) ();</span><br></pre></td></tr></table></figure>
<p>如果<code>sbrk()</code>执行成功，并且有<code>morecore hook</code>函数存在，执行该<code>hook</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* handle non-contiguous cases */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* MORECORE/mmap must correctly align */</span></span><br><span class="line">    assert(((<span class="type">unsigned</span> <span class="type">long</span>)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Find out current end of memory */</span></span><br><span class="line">    <span class="keyword">if</span> (snd_brk == (<span class="type">char</span>*)(MORECORE_FAILURE)) &#123;</span><br><span class="line">        snd_brk = (<span class="type">char</span>*)(MORECORE(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行到这里，意味着<code>brk</code>是用<code>mmap()</code>分配的，断言<code>brk</code>一定是按<code>MALLOC_ALIGNMENT</code>对齐的，因为<code>mmap()</code>返回的地址按页对齐。如果<code>brk</code>的结束地址非法，使用<code>morecore</code>获得当前<code>brk</code>的结束地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Adjust top based on results of second sbrk */</span></span><br><span class="line"><span class="keyword">if</span> (snd_brk != (<span class="type">char</span>*)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    av-&gt;top = (mchunkptr)aligned_brk;</span><br><span class="line">    set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">    av-&gt;system_mem += correction;</span><br></pre></td></tr></table></figure>
<p>如果<code>brk</code>的结束地址合法，设置当前分配区的<code>top chunk</code>为<code>brk</code>，设置<code>top chunk</code>的大小，并更新分配区的总分配内存量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    If not the first time through, we either have a</span></span><br><span class="line"><span class="comment">                    gap due to foreign sbrk or a non-contiguous region. Insert a</span></span><br><span class="line"><span class="comment">                    double fencepost at old_top to prevent consolidation with space</span></span><br><span class="line"><span class="comment">                    we don&#x27;t own. These fenceposts are artificial chunks that are</span></span><br><span class="line"><span class="comment">                    marked as inuse and are in any case too small to use. We need</span></span><br><span class="line"><span class="comment">                    two to make sizes and alignments work out.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (old_size != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        shrink old_top to insert fenceposts, keeping size a</span></span><br><span class="line"><span class="comment">                        multiple of MALLOC_ALIGNMENT. We know there is at least</span></span><br><span class="line"><span class="comment">                        enough space in old_top to do this.</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        old_size = (old_size - <span class="number">4</span>*SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">                        set_head(old_top, old_size | PREV_INUSE);</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        Note that the following assignments completely overwrite</span></span><br><span class="line"><span class="comment">                        old_top when old_size was previously MINSIZE. This is</span></span><br><span class="line"><span class="comment">                        intentional. We need the fencepost, even if old_top otherwise gets</span></span><br><span class="line"><span class="comment">                        lost.</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        chunk_at_offset(old_top, old_size )-&gt;size =</span><br><span class="line">                        (<span class="number">2</span>*SIZE_SZ)|PREV_INUSE;</span><br><span class="line">                        chunk_at_offset(old_top, old_size + <span class="number">2</span>*SIZE_SZ)-&gt;size =</span><br><span class="line">                        (<span class="number">2</span>*SIZE_SZ)|PREV_INUSE;</span><br><span class="line">                        <span class="comment">/* If possible, release the rest. */</span></span><br><span class="line">                        <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">                            _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                            _int_free(av, old_top);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>
<p>设置原<code>top chunk</code>的<code>fencepost</code>，<code>fencepost</code>需要<code>MINSIZE</code>大小的内存空间，将该<code>old_size</code>减去<code>MINSIZE</code>得到原<code>top chunk</code>的有效内存空间，我们可以确信原<code>top chunk</code>的有效内存空间一定大于<code>MINSIZE</code>，将原<code>top chunk</code>切分成空闲<code>chunk</code>和<code>fencepost</code>两部分，首先设置切分出来的<code>chunk</code>的大小为<code>old_size</code>，并标识前一个<code>chunk</code>处于<code>inuse</code>状态，原<code>top chunk</code>切分出来的<code>chunk</code>本应处于空闲状态，但<code>fencepost</code>的第一个<code>chunk</code>却标识前一个<code>chunk</code>为<code>inuse</code>状态，然后强制将该处于<code>inuse</code>状态的<code>chunk</code>调用<code>_int_free()</code>函数释放掉。然后设置<code>fencepost</code>的第一个<code>chunk</code>的大小为<code>2*SIZE_SZ</code>，并标识前一个<code>chunk</code>处于<code>inuse</code>状态，然后设置<code>fencepost</code>的第二个<code>chunk</code>的<code>size</code>为<code>2*SIZE_SZ</code>，并标识前一个<code>chunk</code>处于<code>inuse</code>状态。这里的主分配区的<code>fencepost</code>与非主分配区的<code>fencepost</code>不同，主分配区<code>fencepost</code>的第二个<code>chunk</code>的大小设置为<code>2*SIZE_SZ</code>，而非主分配区的<code>fencepost</code>的第二个<code>chunk</code>的大小设置为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Update statistics */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_THREADS</span></span><br><span class="line">            sum = av-&gt;system_mem + mp_.mmapped_mem;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.max_total_mem))</span><br><span class="line">            mp_.max_total_mem = sum;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，对主分配区的分配出来完毕。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="comment">/* if (av != &amp;main_arena) */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)av-&gt;system_mem &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(av-&gt;max_system_mem))</span><br><span class="line">    av-&gt;max_system_mem = av-&gt;system_mem;</span><br></pre></td></tr></table></figure>
<p>如果当前分配区所分配的内存量大于设置的最大值，更新当前分配区最大分配的内存量，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">check_malloc_state(av);</span><br><span class="line"><span class="comment">/* finally, do the allocation */</span></span><br><span class="line">p = av-&gt;top;</span><br><span class="line">size = chunksize(p);</span><br><span class="line"><span class="comment">/* check that one of the above allocation paths succeeded */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(p, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    check_malloced_chunk(av, p, nb);</span><br><span class="line">    <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>top chunk</code>中已经有足够的内存来分配所需的<code>chunk</code>，从当前的<code>top chunk</code>中分配所需的<code>chunk</code>并返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* catch all failure paths */</span></span><br><span class="line">    MALLOC_FAILURE_ACTION;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate()"></a>malloc_consolidate()</h4><p><code>malloc_consolidate()</code>函数用于将<code>fast bins</code>中的<code>chunk</code>合并，并加入<code>unsorted bin</code>中，其实现源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment">malloc_consolidate is a specialized version of free() that tears</span></span><br><span class="line"><span class="comment">down chunks held in fastbins. Free itself cannot be used for this</span></span><br><span class="line"><span class="comment">purpose since, among other things, it might place chunks back onto</span></span><br><span class="line"><span class="comment">fastbins. So, instead, we need to use a minor variant of the same</span></span><br><span class="line"><span class="comment">code.113</span></span><br><span class="line"><span class="comment">Also, because this routine needs to be called the first time through</span></span><br><span class="line"><span class="comment">malloc anyway, it turns out to be the perfect place to trigger</span></span><br><span class="line"><span class="comment">initialization code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(av)</span> mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mfastbinptr* fb; <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">    mfastbinptr* maxfb; <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">    mchunkptr p; <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">    mchunkptr nextp; <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">    mchunkptr unsorted_bin; <span class="comment">/* bin header */</span></span><br><span class="line">    mchunkptr first_unsorted; <span class="comment">/* chunk to link to */</span></span><br><span class="line">    <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">    mchunkptr nextchunk;</span><br><span class="line">    INTERNAL_SIZE_T size;</span><br><span class="line">    INTERNAL_SIZE_T nextsize;</span><br><span class="line">    INTERNAL_SIZE_T prevsize;</span><br><span class="line">    <span class="type">int</span> nextinuse;</span><br><span class="line">    mchunkptr bck;</span><br><span class="line">    mchunkptr fwd;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">        clear_fastchunks(av);</span><br><span class="line">        unsorted_bin = unsorted_chunks(av);</span><br></pre></td></tr></table></figure>
<p>如果全局变量<code>global_max_fast</code>不为零，表示<code>ptmalloc</code>已经初始化，清除分配区<code>flag</code>中<code>fast bin</code>的标志位，该标志位表示分配区的<code>fast bins</code>中包含空闲<code>chunk</code>。然后获得分配区的<code>unsorted bin</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">        then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">        placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">        until malloc is sure that chunks aren&#x27;t immediately going to be114</span></span><br><span class="line"><span class="comment">        reused anyway.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">        <span class="comment">/* It is wrong to limit the fast bins to search using get_max_fast</span></span><br><span class="line"><span class="comment">        because, except for the main arena, all the others might have</span></span><br><span class="line"><span class="comment">        blocks in the high fast bins. It&#x27;s not worth it anyway, just</span></span><br><span class="line"><span class="comment">        search all bins all the time. */</span></span><br><span class="line">        maxfb = &amp;fastbin (av, fastbin_index(get_max_fast ()));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        fb = &amp;fastbin (av, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>将分配区最大的一个<code>fast bin</code>赋值给<code>maxfb</code>，第一个<code>fast bin</code>赋值给<code>fb</code>，然后遍历<code>fast bins</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">            p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            p = *fb;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ATOMIC_FASTBINS</span></span><br><span class="line">                *fb = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>获取当前遍历的<code>fast bin</code>中空闲<code>chunk</code>单向链表的头指针赋值给<code>p</code>，如果<code>p</code>不为0，将当前<code>fast bin</code>链表的头指针赋值为0，即删除了该<code>fast bin</code>中的空闲<code>chunk</code>链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    check_inuse_chunk(av, p);</span><br><span class="line">    nextp = p-&gt;fd;</span><br></pre></td></tr></table></figure>
<p>将空闲<code>chunk</code>链表的下一个<code>chunk</code>赋值给<code>nextp</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br></pre></td></tr></table></figure>
<p>获得当前<code>chunk</code>的<code>size</code>，需要去除<code>size</code>中的<code>PREV_INUSE</code>和<code>NON_MAIN_ARENA</code>标志，并获取相邻的下一个<code>chunk</code>和下一个<code>chunk</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));<span class="number">115</span></span><br><span class="line">    unlink(p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>chunk</code>的前一个<code>chunk</code>空闲，则将当前<code>chunk</code>与前一个<code>chunk</code>合并成一个空闲<code>chunk</code>，由于前一个<code>chunk</code>空闲，则当前<code>chunk</code>的<code>prev_size</code>保存了前一个<code>chunk</code>的大小，计算出合并后的<code>chunk</code>大小，并获取前一个<code>chunk</code>的指针，将前一个<code>chunk</code>从空闲链表中删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br></pre></td></tr></table></figure>
<p>如果与当前<code>chunk</code>相邻的下一个<code>chunk</code>不是分配区的<code>top chunk</code>，查看与当前<code>chunk</code>相邻的下一个<code>chunk</code>是否处于<code>inuse</code>状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink(nextchunk, bck, fwd);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如果与当前<code>chunk</code>相邻的下一个<code>chunk</code>处于<code>inuse</code>状态，清除当前<code>chunk</code>的<code>inuse</code>状态，则当前<code>chunk</code>空闲了。否则，将相邻的下一个空闲<code>chunk</code>从空闲链表中删除，并计算当前<code>chunk</code>与下一个<code>chunk</code>合并后的<code>chunk</code>大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">unsorted_bin-&gt;fd = p;</span><br><span class="line">first_unsorted-&gt;bk = p;</span><br></pre></td></tr></table></figure>
<p>将合并后的<code>chunk</code>加入<code>unsorted bin</code>的双向循环链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果合并后的<code>chunk</code>属于<code>large bin</code>，将<code>chunk</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>设置为<code>NULL</code>，因为在<code>unsorted bin</code>中这两个字段无用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_head(p, size | PREV_INUSE);</span><br><span class="line">p-&gt;bk = unsorted_bin;</span><br><span class="line">p-&gt;fd = first_unsorted;</span><br><span class="line">set_foot(p, size);</span><br></pre></td></tr></table></figure>
<p>设置合并后的空闲<code>chunk</code>大小，并标识前一个<code>chunk</code>处于<code>inuse</code>状态，因为必须保证不能有两个相邻的<code>chunk</code>都处于空闲状态。然后将合并后的<code>chunk</code>加入<code>unsorted bin</code>的双向循环链表中。最后设置合并后的空闲<code>chunk</code>的<code>foot</code>，<code>chunk</code>空闲时必须设置<code>foot</code>，该<code>foot</code>处于下一个<code>chunk</code>的<code>prev_size</code>中，只有<code>chunk</code>空闲是<code>foot</code>才是有效的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);<span class="number">116</span></span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>chunk</code>的下一个<code>chunk</code>为<code>top chunk</code>，则将当前<code>chunk</code>合并入<code>top chunk</code>，修改<code>top chunk</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>直到遍历完当前<code>fast bin</code>中的所有空闲<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br></pre></td></tr></table></figure>
<p>直到遍历完所有的<code>fast bins</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">malloc_init_state(av);</span><br><span class="line">check_malloc_state(av);</span><br></pre></td></tr></table></figure></p>
<p>如果<code>ptmalloc</code>没有初始化，初始化<code>ptmalloc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存释放-free"><a href="#内存释放-free" class="headerlink" title="内存释放 free"></a>内存释放 free</h2><h3 id="public-fREe"><a href="#public-fREe" class="headerlink" title="public_fREe()"></a>public_fREe()</h3><p><code>public_fREe()</code>函数的源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">public_fREe</span><span class="params">(<span class="type">void_t</span>* mem)</span></span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">__malloc_ptr_t</span>, __const <span class="type">__malloc_ptr_t</span>)</span><br><span class="line">    = force_reg (__free_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果存在<code>free</code>的<code>hook</code>函数，执行该<code>hook</code>函数返回，<code>free</code>的<code>hook</code>函数主要用于创建新线程使用或使用用户提供的<code>free</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">p = mem2chunk(mem);</span><br></pre></td></tr></table></figure>
<p><code>free NULL</code>指针直接返回，然后根据内存指针获得<code>chunk</code>的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">        <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">        &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">        &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            mp_.mmap_threshold = chunksize (p);</span><br><span class="line">            mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        munmap_chunk(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果当前<code>free</code>的<code>chunk</code>是通过<code>mmap()</code>分配的，调用<code>munmap_chunk()</code>函数<code>unmap</code>本<code>chunk</code>。<code>munmap_chunk()</code>函数调用<code>munmap()</code>函数释放<code>mmap()</code>分配的内存块。同时查看是否开启了<code>mmap</code>分配阈值动态调整机制，默认是开启的，如果当前<code>free</code>的<code>chunk</code>的大小大于设置的<code>mmap</code>分配阈值，小于<code>mmap</code>分配阈值的最大值，将当前<code>chunk</code>的大小赋值给<code>mmap</code>分配阈值，并修改<code>mmap</code>收缩阈值为<code>mmap</code>分配阈值的2倍。默认情况下<code>mmap</code>分配阈值与<code>mmap</code>收缩阈值相等，都为128KB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar_ptr = arena_for_chunk(p);</span><br></pre></td></tr></table></figure>
<p>根据<code>chunk</code>指针获得分配区的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    _int_free(ar_ptr, p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如果开启了<code>ATOMIC_FASTBINS</code>优化，不需要对分配区加锁，调用<code>_int_free()</code>函数执行实际的释放工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> THREAD_STATS</span></span><br><span class="line">    <span class="keyword">if</span>(!mutex_trylock(&amp;ar_ptr-&gt;mutex))</span><br><span class="line">        ++(ar_ptr-&gt;stat_lock_direct);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        ++(ar_ptr-&gt;stat_lock_wait);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    _int_free(ar_ptr, p);</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果没有开启了<code>ATOMIC_FASTBINS</code>优化，或去分配区的锁，调用<code>_int_free()</code>函数执行实际的释放工作，然后对分配区解锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free()"></a>_int_free()</h3><p><code>_int_free()</code>函数的实现源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">_int_free(mstate av, mchunkptr p)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size; <span class="comment">/* its size */</span></span><br><span class="line">    mfastbinptr* fb; <span class="comment">/* associated fastbin */</span></span><br><span class="line">    mchunkptr nextchunk; <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">    INTERNAL_SIZE_T nextsize; <span class="comment">/* its size */</span></span><br><span class="line">    <span class="type">int</span> nextinuse; <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">    INTERNAL_SIZE_T prevsize; <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">    mchunkptr bck; <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    mchunkptr fwd; <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    <span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    size = chunksize(p);</span><br></pre></td></tr></table></figure>
<p>获取需要释放的<code>chunk</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">    allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">    Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">    here by accident or by &quot;design&quot; from some intruder. */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">        errout:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">        <span class="keyword">if</span> (! have_lock &amp;&amp; locked)</span><br><span class="line">            (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        malloc_printerr (check_action, errstr, chunk2mem(p));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size. */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (size &lt; MINSIZE, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure>
<p>上面的代码用于安全检查，<code>chunk</code>的指针地址不能溢出，<code>chunk</code>的大小必须大于等于<code>MINSIZE</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">    bordering top into fastbins</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">        || __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">        &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">            <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">            of system_mem might have let to a false positive. Redo the test</span></span><br><span class="line"><span class="comment">            after getting the lock. */</span></span><br><span class="line">            <span class="keyword">if</span> (have_lock</span><br><span class="line">            || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">            mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">1</span>;</span><br><span class="line">            chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">            || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">            &#125;))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">            <span class="keyword">if</span> (! have_lock)</span><br><span class="line">            &#123;</span><br><span class="line">                (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">                locked = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>free</code>的<code>chunk</code>属于<code>fast bins</code>，查看下一个相邻的<code>chunk</code>的大小是否小于等于<code>2*SIZE_SZ</code>，下一个相邻<code>chunk</code>的大小是否大于分配区所分配的内存总量，如果是，报错。这里计算下一个相邻<code>chunk</code>的大小似乎有点问题，因为<code>chunk</code>的<code>size</code>字段中包含了一些标志位，正常情况下下一个相邻<code>chunk</code>的<code>size</code>中的<code>PREV_INUSE</code>标志位会置位，但这里就是要检出错的情况，也就是下一个相邻<code>chunk</code>的<code>size</code>中标志位都没有置位，并且该<code>chunk</code>大小为<code>2*SIZE_SZ</code>的错误情况。如果开启了<code>ATOMIC_FASTBINS</code>优化，并且调用本函数前没有对分配区加锁，所以读取分配区所分配的内存总量需要对分配区加锁，检查完以后，释放分配区的锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">    free_perturb (chunk2mem(p), size - SIZE_SZ);</span><br><span class="line">set_fastchunks(av);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">fb = &amp;fastbin (av, idx);</span><br></pre></td></tr></table></figure>
<p>设置当前分配区的<code>fast bin flag</code>，表示当前分配区的<code>fast bins</code>中已有空闲<code>chunk</code>。然后根据当前<code>free</code>的<code>chunk</code>大小获取所属的<code>fast bin</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">        mchunkptr fd;</span><br><span class="line">        mchunkptr old = *fb;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Another simple check: make sure the top of the bin is not the</span></span><br><span class="line"><span class="comment">            record we are going to add (i.e., double free). */</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (old != <span class="literal">NULL</span>)</span><br><span class="line">                old_idx = fastbin_index(chunksize(old));</span><br><span class="line">            p-&gt;fd = fd = old;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, fd)) != fd);</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了<code>ATOMIC_FASTBINS</code>优化，使用<code>lock-free</code>技术实现<code>fast bin</code>的单向链表插入操作。这里也没有<code>ABA</code>问题，比如当前线程获取<code>*fb</code>并保存到<code>old</code>中，在调用<code>cas</code>原子操作前，<code>b</code>线程将<code>*fb</code>修改为<code>x</code>，如果<code>B</code>线程加入了新的<code>chunk</code>，则<code>x-&gt;fb</code>指向<code>old</code>，如果<code>B</code>线程删除了<code>old</code>，则<code>x</code>为<code>old-&gt;fb</code>。如果<code>C</code>线程将<code>*fb</code>修改为<code>old</code>，则可能将<code>B</code>线程加入的<code>chunk x</code>删除，或者<code>C</code>将<code>B</code>删除的<code>old</code>又重新加入。这两种情况，都不会导致链表出错，所以不会有<code>ABA</code>问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">/* Another simple check: make sure the top of the bin is not the</span></span><br><span class="line"><span class="comment">        record we are going to add (i.e., double free). */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (*fb == p, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*fb != <span class="literal">NULL</span></span><br><span class="line">        &amp;&amp; __builtin_expect (fastbin_index(chunksize(*fb)) != idx, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;fd = *fb;</span><br><span class="line">        *fb = p;</span><br></pre></td></tr></table></figure>
<p>如果没有开启了<code>ATOMIC_FASTBINS</code>优化，将<code>free</code>的<code>chunk</code>加入<code>fast bin</code>的单向链表中，修改过链表表头为当前<code>free</code>的<code>chunk</code>。同时需要校验是否为<code>double free</code>错误，校验表头不为<code>NULL</code>情况下，保证表头<code>chunk</code>的所属的<code>fast bin</code>与当前<code>free</code>的<code>chunk</code>所属的<code>fast bin</code>相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS122</span></span><br><span class="line">        <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> THREAD_STATS</span></span><br><span class="line">            <span class="keyword">if</span>(!mutex_trylock(&amp;av-&gt;mutex))</span><br><span class="line">                ++(av-&gt;stat_lock_direct);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">                ++(av-&gt;stat_lock_wait);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            locked = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果当前<code>free</code>的<code>chunk</code>不是通过<code>mmap()</code>分配的，并且当前还没有获得分配区的锁，获取分配区的锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextchunk = chunk_at_offset(p, size);</span><br></pre></td></tr></table></figure>
<p>获取当前<code>free</code>的<code>chunk</code>的下一个相邻的<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">top block. */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (p == av-&gt;top, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena. */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">&amp;&amp; (<span class="type">char</span> *) nextchunk &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used. */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (!prev_inuse(nextchunk), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安全检查，当前<code>free</code>的<code>chunk</code>不能为<code>top chunk</code>，因为<code>top chunk</code>为空闲<code>chunk</code>，如果再次<code>free</code>就可能为<code>double free</code>错误了。如果当前<code>free</code>的<code>chunk</code>是通过<code>sbrk()</code>分配的，并且下一个相邻的<code>chunk</code>的地址已经超过了<code>top chunk</code>的结束地址，超过了当前分配区的结束地址，报错。如果当前<code>free</code>的<code>chunk</code>的下一个相邻<code>chunk</code>的<code>size</code>中标志位没有标识当前<code>free chunk</code>为<code>inuse</code>状态，可能为<code>double free</code>错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">    free_perturb (chunk2mem(p), size - SIZE_SZ);</span><br></pre></td></tr></table></figure>
<p>计算当前<code>free</code>的<code>chunk</code>的下一个相邻<code>chunk</code>的大小，该大小如果小于等于<code>2*SIZE_SZ</code>或是大于了分配区所分配区的内存总量，报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>free</code>的<code>chunk</code>的前一个相邻<code>chunk</code>为空闲状态，与前一个空闲<code>chunk</code>合并。计算合并后的<code>chunk</code>大小，并将前一个相邻空闲<code>chunk</code>从空闲<code>chunk</code>链表中删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br></pre></td></tr></table></figure>
<p>如果与当前<code>free</code>的<code>chunk</code>相邻的下一个<code>chunk</code>不是分配区的<code>top chunk</code>，查看与当前<code>chunk</code>相邻的下一个<code>chunk</code>是否处于<code>inuse</code>状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate forward */</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    unlink(nextchunk, bck, fwd);</span><br><span class="line">    size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如果与当前<code>free</code>的<code>chunk</code>相邻的下一个<code>chunk</code>处于<code>inuse</code>状态，清除当前<code>chunk</code>的<code>inuse</code>状态，则当前<code>chunk</code>空闲了。否则，将相邻的下一个空闲<code>chunk</code>从空闲链表中删除，并计算当前<code>chunk</code>与下一个<code>chunk</code>合并后的<code>chunk</code>大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are124</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">bck = unsorted_chunks(av);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (fwd-&gt;bk != bck, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;fd = fwd;</span><br><span class="line">p-&gt;bk = bck;</span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">bck-&gt;fd = p;</span><br><span class="line">fwd-&gt;bk = p;</span><br></pre></td></tr></table></figure>
<p>将合并后的<code>chunk</code>加入<code>unsorted bin</code>的双向循环链表中。如果合并后的<code>chunk</code>属于<code>large bins</code>，将<code>chunk</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>设置为<code>NULL</code>，因为在<code>unsorted bin</code>中这两个字段无用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_head(p, size | PREV_INUSE);</span><br><span class="line">set_foot(p, size);</span><br></pre></td></tr></table></figure>
<p>设置合并后的空闲<code>chunk</code>大小，并标识前一个<code>chunk</code>处于<code>inuse</code>状态，因为必须保证不能有两个相邻的<code>chunk</code>都处于空闲状态。然后将合并后的<code>chunk</code>加入<code>unsorted bin</code>的双向循环链表中。最后设置合并后的空闲<code>chunk</code>的<code>foot</code>，<code>chunk</code>空闲时必须设置<code>foot</code>，该<code>foot</code>处于下一个<code>chunk</code>的<code>prev_size</code>中，只有<code>chunk</code>空闲是<code>foot</code>才是有效的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    check_free_chunk(av, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">consolidate into top</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">    check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>free</code>的<code>chunk</code>下一个相邻的<code>chunk</code>为<code>top chunk</code>，则将当前<code>chunk</code>合并入<code>top chunk</code>，修改<code>top chunk</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment">Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">has been reached unless fastbins are consolidated. But we</span></span><br><span class="line"><span class="comment">don&#x27;t want to consolidate on each free. As a compromise,</span></span><br><span class="line"><span class="comment">consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">is reached.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);</span><br></pre></td></tr></table></figure>
<p>如果合并后的<code>chunk</code>大小大于<code>64KB</code>，并且<code>fast bins</code>中存在空闲<code>chunk</code>，调用<code>malloc_consolidate()</code>函数合并<code>fast bins</code>中的空闲<code>chunk</code>到<code>unsorted bin</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">                (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">                    sYSTRIm(mp_.top_pad, av);</span><br></pre></td></tr></table></figure>
<p>如果当前分配区为主分配区，并且<code>top chunk</code>的大小大于<code>heap</code>的收缩阈值，调用<code>sYSTRIm()</code>函数首先<code>heap</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">                large, because the corresponding heap might go away. */</span></span><br><span class="line">                heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line">                assert(heap-&gt;ar_ptr == av);</span><br><span class="line">                heap_trim(heap, mp_.top_pad);</span><br></pre></td></tr></table></figure>
<p>如果为非主分配区，调用<code>heap_trim()函数收缩非主分配区的</code>sub_heap`。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">        <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">            assert (locked);</span><br><span class="line">            (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果开启了<code>ATOMIC_FASTBINS</code>优化并获得分配区的锁，则对分配区解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap(). Note</span></span><br><span class="line"><span class="comment">    that if HAVE_MMAP is false but chunk_is_mmapped is true, then</span></span><br><span class="line"><span class="comment">    user must have overwritten memory. There&#x27;s nothing we can do to</span></span><br><span class="line"><span class="comment">    catch this error unless MALLOC_DEBUG is set, in which case</span></span><br><span class="line"><span class="comment">    check_inuse_chunk (above) will have triggered error.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">        munmap_chunk (p);</span><br></pre></td></tr></table></figure>
<p>如果当前<code>free</code>的<code>chunk</code>是通过<code>mmap()</code>分配的，调用<code>munma_chunk()</code>释放内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sYSTRIm-和munmap-chunk"><a href="#sYSTRIm-和munmap-chunk" class="headerlink" title="sYSTRIm()和munmap_chunk()"></a>sYSTRIm()和munmap_chunk()</h3><p><code>sYSTRIm()</code>函数源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sYSTRIm is an inverse of sorts to sYSMALLOc. It gives memory back</span></span><br><span class="line"><span class="comment">to the system (via negative arguments to sbrk) if there is unused</span></span><br><span class="line"><span class="comment">memory at the `high&#x27; end of the malloc pool. It is called</span></span><br><span class="line"><span class="comment">automatically by free() when top space exceeds the trim</span></span><br><span class="line"><span class="comment">threshold. It is also called by the public malloc_trim routine. It</span></span><br><span class="line"><span class="comment">returns 1 if it actually released any memory, else 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sYSTRIm</span><span class="params">(<span class="type">size_t</span> pad, mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sYSTRIm</span><span class="params">(pad, av)</span> <span class="type">size_t</span> pad; mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> top_size; <span class="comment">/* Amount of top-most memory */</span></span><br><span class="line">    <span class="type">long</span> extra; <span class="comment">/* Amount to release */</span></span><br><span class="line">    <span class="type">long</span> released; <span class="comment">/* Amount actually released */</span></span><br><span class="line">    <span class="type">char</span>* current_brk; <span class="comment">/* address returned by pre-check sbrk call */</span></span><br><span class="line">    <span class="type">char</span>* new_brk; <span class="comment">/* address returned by post-check sbrk call */</span></span><br><span class="line">    <span class="type">size_t</span> pagesz;</span><br><span class="line">    pagesz = mp_.pagesize;</span><br><span class="line">    top_size = chunksize(av-&gt;top);</span><br></pre></td></tr></table></figure>
<p>获取页大小和<code>top chunk</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Release in pagesize units, keeping at least one page */</span></span><br><span class="line">extra = ((top_size - pad - MINSIZE + (pagesz<span class="number">-1</span>)) / pagesz - <span class="number">1</span>) * pagesz;</span><br></pre></td></tr></table></figure>
<p>计算<code>top chunk</code>中最大可释放的整数页大小，<code>top chunk</code>中至少需要<code>MINSIZE</code>的内存保存<code>fencepost</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (extra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Only proceed if end of memory is where we last set it.</span></span><br><span class="line"><span class="comment">    This avoids problems if there were foreign sbrk calls.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    current_brk = (<span class="type">char</span>*)(MORECORE(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (current_brk == (<span class="type">char</span>*)(av-&gt;top) + top_size) &#123;</span><br></pre></td></tr></table></figure>
<p>获取当前<code>brk</code>值，如果当前<code>top chunk</code>的结束地址与当前的<code>brk</code>值相等，执行<code>heap</code>收缩。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Attempt to release memory. We ignore MORECORE return value,</span></span><br><span class="line"><span class="comment">and instead call again to find out where new end of memory is.</span></span><br><span class="line"><span class="comment">This avoids problems if first call releases less than we asked,</span></span><br><span class="line"><span class="comment">of if failure somehow altered brk value. (We could still</span></span><br><span class="line"><span class="comment">encounter problems if it altered brk in some very bad way,</span></span><br><span class="line"><span class="comment">but the only thing we can do is adjust anyway, which will cause</span></span><br><span class="line"><span class="comment">some downstream failure.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MORECORE(-extra);</span><br></pre></td></tr></table></figure>
<p>调用<code>sbrk()</code>释放指定大小的内存到<code>heap</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Call the `morecore&#x27; hook if necessary. */</span></span><br><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span>) = force_reg (__after_morecore_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    (*hook) ();</span><br><span class="line">new_brk = (<span class="type">char</span>*)(MORECORE(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>如果<code>morecore hook</code>存在，执行<code>hook</code>函数，然后获得当前新的<code>brk</code>值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_brk != (<span class="type">char</span>*)MORECORE_FAILURE) &#123;</span><br><span class="line">    released = (<span class="type">long</span>)(current_brk - new_brk);</span><br><span class="line">    <span class="keyword">if</span> (released != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Success. Adjust top. */</span></span><br><span class="line">        av-&gt;system_mem -= released;</span><br><span class="line">        set_head(av-&gt;top, (top_size - released) | PREV_INUSE);</span><br><span class="line">        check_malloc_state(av);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果获取新的<code>brk</code>值成功，计算释放的内存大小，更新当前分配区所分配的内存总量，更新<code>top chunk</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>unmap_chunk()</code>函数源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">internal_function</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">munmap_chunk(mchunkptr p)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">munmap_chunk(p) mchunkptr p;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size = chunksize(p);</span><br><span class="line">    assert (chunk_is_mmapped(p));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    assert(! ((<span class="type">char</span>*)p &gt;= mp_.sbrk_base &amp;&amp; (<span class="type">char</span>*)p &lt; mp_.sbrk_base + mp_.sbrked_mem));</span><br><span class="line">    assert((mp_.n_mmaps &gt; <span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">uintptr_t</span> block = (<span class="type">uintptr_t</span>) p - p-&gt;prev_size;</span><br><span class="line">    <span class="type">size_t</span> total_size = p-&gt;prev_size + size;</span><br><span class="line">    <span class="comment">/* Unfortunately we have to do the compilers job by hand here. Normally</span></span><br><span class="line"><span class="comment">    we would test BLOCK and TOTAL-SIZE separately for compliance with the</span></span><br><span class="line"><span class="comment">    page size. But gcc does not recognize the optimization possibility</span></span><br><span class="line"><span class="comment">    (in the moment at least) so we combine the two values into one before</span></span><br><span class="line"><span class="comment">    the bit test. */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (((block | total_size) &amp; (mp_.pagesize - <span class="number">1</span>)) != <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        malloc_printerr (check_action, <span class="string">&quot;munmap_chunk(): invalid pointer&quot;</span>, chunk2mem (p));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mp_.n_mmaps--;</span><br><span class="line">    mp_.mmapped_mem -= total_size;<span class="number">129</span></span><br><span class="line">    <span class="type">int</span> ret __attribute__ ((unused)) = munmap((<span class="type">char</span> *)block, total_size);</span><br><span class="line">    <span class="comment">/* munmap returns non-zero on failure */</span></span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>munmap_chunk()</code>函数实现相当简单，首先获取当前<code>free</code>的<code>chunk</code>的大小，断言当前<code>free</code>的<code>chunk</code>是通过<code>mmap()</code>分配的，由于使用<code>mmap()</code>分配的<code>chunk</code>的<code>prev_size</code>中记录的前一个相邻空闲<code>chunk</code>的大小，<code>mmap()</code>分配的内存是页对齐的，所以一般情况下<code>prev_size</code>为0。</p>
<p>然后计算当前<code>free</code>的<code>chunk</code>占用的总内存大小<code>total_size</code>，再次校验内存块的起始地址是否是对齐的，更新分配区的<code>mmap</code>统计信息，最后调用<code>munmap()</code>函数释放<code>chunk</code>的内存。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B03/" class="post-title-link" itemprop="url">深入分析Linux内核源码笔记3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-09 16:00:00" itemprop="dateCreated datePublished" datetime="2021-10-09T16:00:00+08:00">2021-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-13 16:14:37" itemprop="dateModified" datetime="2021-10-13T16:14:37+08:00">2021-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>所谓管道，是指用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称<code>pipe</code>文件。向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将大量的数据送入管道；而接收管道输出的接收进程(即读进程)，可从管道中接收数据。由于发送进程和接收进程是利用管道进行通信的，故又称管道通信。这种方式首创于<code>UNIX</code>系统，因它能传送大量的数据，且很有效，故很多操作系统都引入了这种通信方式，<code>Linux</code>也不例外。</p>
<p>为了协调双方的通信，管道通信机制必须提供以下 3 方面的协调能力。</p>
<ul>
<li>互斥。当一个进程正在对<code>pipe</code>进行读/写操作时，另一个进程必须等待。 </li>
<li>同步。当写(输入)进程把一定数量(如 4KB)数据写入<code>pipe</code>后，便去睡眠等待，直到读(输出)进程取走数据后，再把它唤醒。当读进程读到一空<code>pipe</code>时，也应睡眠等待，直至写进程将数据写入管道后，才将它唤醒。</li>
<li>对方是否存在。只有确定对方已存在时，才能进行通信。</li>
</ul>
<h3 id="Linux管道的实现机制"><a href="#Linux管道的实现机制" class="headerlink" title="Linux管道的实现机制"></a>Linux管道的实现机制</h3><p>从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下所述。</p>
<ul>
<li>限制管道的大小。实际上，管道是一个固定大小的缓冲区。在<code>Linux</code>中，该缓冲区的大小为 1 页，即 4KB，使得它的大小不像文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的<code>write()</code>调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供<code>write()</code>调用写。</li>
<li>读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的<code>read()</code>调用将默认地被阻塞，等待某些数据被写入，这解决了<code>read()</code>调用返回文件结束的问题。</li>
</ul>
<p>注意，从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据。</p>
<h4 id="管道的结构"><a href="#管道的结构" class="headerlink" title="管道的结构"></a>管道的结构</h4><p>在<code>Linux</code>中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的<code>file</code>结构和<code>VFS</code>的索引节点<code>inode</code>。通过将两个<code>file</code>结构指向同一个临时的<code>VFS</code>索引节点，而这个<code>VFS</code>索引节点又指向一个物理页面而实现的。如图 7.1 所示。<br><img src="/img/1633935241.jpg" alt=""></p>
<p>两个<code>file</code>数据结构定义文件操作例程地址是不同的，其中一个是向管道中写入数据的例程地址，而另一个是从管道中读出数据的例程地址。</p>
<h4 id="管道的读写"><a href="#管道的读写" class="headerlink" title="管道的读写"></a>管道的读写</h4><p>管道实现的源代码在<code>fs/pipe.c</code>中，在<code>pipe.c</code>中有很多函数，其中有两个函数比较重要，即管道读函数<code>pipe_read()</code>和管道写函数<code>pipe_wrtie()</code>。管道写函数通过将字节复制到<code>VFS</code>索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。</p>
<p>当写进程向管道中写入时，它利用标准的库函数<code>write()</code>，系统根据库函数传递的文件描述符，可找到该文件的<code>file</code>结构。<code>file</code>结构中指定了用来进行写操作的函数(即写入函数)地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查<code>VFS</code>索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：</p>
<ul>
<li>内存中有足够的空间可容纳所有要写入的数据；</li>
<li>内存没有被读程序锁定。</li>
</ul>
<p>如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在<code>VFS</code>索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。</p>
<p>管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。</p>
<h3 id="管道的应用"><a href="#管道的应用" class="headerlink" title="管道的应用"></a>管道的应用</h3><p>管道是利用<code>pipe()</code>系统调用而不是利用<code>open()</code>系统调用建立的。<code>pipe()</code>调用的原型是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span><br></pre></td></tr></table></figure></p>
<p>我们看到，有两个文件描述符与管道结合在一起，一个文件描述符用于管道的<code>read()</code>端，一个文件描述符用于管道的<code>write()</code>端。由于一个函数调用不能返回两个值，<code>pipe()</code>的参数是指向两个元素的整型数组的指针，它将由调用两个所要求的文件描述符填入。</p>
<p><code>fd[0]</code>元素将含有管道<code>read()</code>端的文件描述符，而<code>fd[1]</code>含有管道<code>write()</code>端的文件描述符。系统可根据<code>fd[0]</code>和<code>fd[1]</code>分别找到对应的<code>file</code>结构。</p>
<p>注意，在<code>pipe</code>的参数中，没有路径名，这表明，创建管道并不像创建文件一样，要为它创建一个目录连接。这样做的好处是，其他现存的进程无法得到该管道的文件描述符，从而不能访问它。那么，两个进程如何使用一个管道来通信呢？</p>
<p>我们知道，<code>fork()</code>和<code>exec()</code>系统调用可以保证文件描述符的复制品既可供双亲进程使用，也可供它的子女进程使用。也就是说，一个进程用<code>pipe()</code>系统调用创建管道，然后用<code>fork()</code>调用创建一个或多个进程，那么，管道的文件描述符将可供所有这些进程使用。</p>
<p>这里更明确的含义是：一个普通的管道仅可供具有共同祖先的两个进程之间共享，并且这个祖先必须已经建立了供它们使用的管道。注意，在管道中的数据始终以和写数据相同的次序来进行读，这表示<code>lseek()</code>系统调用<br>对管道不起作用。</p>
<h3 id="命名管道CFIFOC"><a href="#命名管道CFIFOC" class="headerlink" title="命名管道CFIFOC"></a>命名管道CFIFOC</h3><p><code>Linux</code>还支持另外一种管道形式，称为命名管道，或<code>FIFO</code>，这是因为这种管道的操作方式基于“先进先出”原理。上面讲述的管道类型也被称为“匿名管道”。命名管道中，首先写入管道的数据是首先被读出的数据。匿名管道是临时对象，而<code>FIFO</code>则是文件系统的真正实体，如果进程有足够的权限就可以使用<code>FIFO</code>。<code>FIFO</code>和匿名管道的数据结构以及操作极其类似，二者的主要区别在于，<code>FIFO</code>在使用之前就已经存在，用户可打开或关闭<code>FIFO</code>；而匿名管道只在操作时存在，因而是临时对象。</p>
<p>为了创建先进先出文件，可以从<code>shell</code>提示符使用<code>mknod</code>命令或可以在程序中使用<code>mknod()</code>系统调用。</p>
<p><code>mknod()</code>系统调用的原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/type.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="string">&lt;sys/state.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">char</span> *pathname,<span class="type">node_t</span> mode, <span class="type">dev_t</span> dev)</span>;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>pathname</code>是被创建的文件名称，<code>mode</code>表示将在该文件上设置的权限位和将被创建的文件类型(在此情况下为<code>S_IFIFO</code>)，<code>dev</code>是当创建设备特殊文件时使用的一个值。因此，对于先进先出文件它的值为 0。</p>
<p>一旦先进先出文件已经被创建，它可以由任何具有适当权限的进程利用标准的<code>open()</code>系统调用加以访问。当用<code>open()</code>调用打开时，一个先进先出文件和一个匿名管道具有同样的基本功能。即当管道是空的时候，<code>read()</code>调用被阻塞。当管道是满的时候，<code>write()</code>等待被阻塞，并且当用<code>fcntl()</code>设置<code>O_NONBLOCK</code>标志时，将引起<code>read()</code>调用和<code>write()</code>调用立即返回。</p>
<p>在它们已被阻塞的情况下，带有一个<code>EAGAIN</code>错误信息。由于命名管道可以被很多无关系的进程同时访问，那么，在有多个读进程和/或多个写进程的应用中使用<code>FIFO</code>是非常有用的。</p>
<p>多个进程写一个管道会出现这样的问题，即多个进程所写的数据混在一起怎么办？幸好系统有这样的规则：一个<code>write()</code>调用可以写管道能容纳(<code>Linux</code>为 4KB)的任意个字节，系统将保证这些数据是分开的。这表示多个写操作的数据在<code>FIFO</code>文件中并不混合而将被维持分离的信息。 </p>
<h2 id="信号-signal"><a href="#信号-signal" class="headerlink" title="信号(signal)"></a>信号(signal)</h2><h3 id="信号种类"><a href="#信号种类" class="headerlink" title="信号种类"></a>信号种类</h3><p>每一种信号都给予一个符号名。<code>Linux</code>定义了<code>i386</code>的 32 个信号，在<code>include/asm/signal.h</code>中定义。表给出常用的符号名、描述和它们的信号值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号名</th>
<th>描述</th>
<th>信号值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SIGHUP</code></td>
<td>在控制终端上发生的结束信号</td>
<td>1</td>
</tr>
<tr>
<td><code>SIGINT</code></td>
<td>中断，用户键入<code>CTRL–C</code>时发送</td>
<td>2</td>
</tr>
<tr>
<td><code>SIGQUIT</code></td>
<td>从键盘来的中断(ctrl_c)信号</td>
<td>3</td>
</tr>
<tr>
<td><code>SIGILL</code></td>
<td>非法指令</td>
<td>4</td>
</tr>
<tr>
<td><code>SIGTRAP</code></td>
<td>跟踪陷入</td>
<td>5</td>
</tr>
<tr>
<td><code>SIGABRT</code></td>
<td>非正常结束，程序调用<code>abort</code>时发送</td>
<td>6</td>
</tr>
<tr>
<td><code>SIGIOT</code></td>
<td>IOT指令</td>
<td>6</td>
</tr>
<tr>
<td><code>SIGBUS</code></td>
<td>总线超时</td>
<td>7</td>
</tr>
<tr>
<td><code>SIGFPE</code></td>
<td>浮点异常</td>
<td>8</td>
</tr>
<tr>
<td><code>SIGKILL</code></td>
<td>杀死进程(不能被捕或忽略)</td>
<td>9</td>
</tr>
<tr>
<td><code>SIGUSR1</code></td>
<td>用户定义信号#1</td>
<td>10</td>
</tr>
<tr>
<td><code>SIGSEGV</code></td>
<td>段违法</td>
<td>11</td>
</tr>
<tr>
<td><code>SIGUSR2</code></td>
<td>用户定义信号#2</td>
<td>12</td>
</tr>
<tr>
<td><code>SIGPIPE</code></td>
<td>向无人读到的管道写</td>
<td>13</td>
</tr>
<tr>
<td><code>SIGALRM</code></td>
<td>定时器告警，时间到</td>
<td>14</td>
</tr>
<tr>
<td><code>SIGTERM</code></td>
<td>Kill发出的软件结束信号</td>
<td>15</td>
</tr>
<tr>
<td><code>SIGCHLD</code></td>
<td>子程序结束或停止</td>
<td>17</td>
</tr>
<tr>
<td><code>SIGCONT</code></td>
<td>如果已停止则续继</td>
<td>18</td>
</tr>
<tr>
<td><code>SIGSTOP</code></td>
<td>停止信号</td>
<td>19</td>
</tr>
<tr>
<td><code>SIGTSTP</code></td>
<td>交互停止信号</td>
<td>20</td>
</tr>
<tr>
<td><code>SIGTTIN</code></td>
<td>后台进程想读</td>
<td>21</td>
</tr>
<tr>
<td><code>SIGTTOU</code></td>
<td>后台进程想写</td>
<td>22</td>
</tr>
<tr>
<td><code>SIGPWR</code></td>
<td>电源失效</td>
<td>30</td>
</tr>
</tbody>
</table>
</div>
<p>每种信号类型都有对应的信号处理程序(也叫信号的操作)，就好像每个中断都有一个中断服务例程一样。大多数信号的默认操作是结束接收信号的进程。然而，一个进程通常可以请求系统采取某些代替的操作，各种代替操作如下所述。</p>
<ol>
<li>忽略信号。随着这一选项的设置，进程将忽略信号的出现。有两个信号不可以被忽略：<code>SIGKILL</code>，它将结束进程；<code>SIGSTOP</code>，它是作业控制机制的一部分，将挂起作业的执行。</li>
<li>恢复信号的默认操作。</li>
<li>执行一个预先安排的信号处理函数。进程可以登记特殊的信号处理函数。当进程收到信号时，信号处理函数将像中断服务例程一样被调用，当从该信号处理函数返回时，控制被返回给主程序，并且继续正常执行。</li>
</ol>
<p>但是，信号和中断有所不同。中断的响应和处理都发生在内核空间，而信号的响应发生在内核空间，信号处理程序的执行却发生在用户空间。那么，什么时候检测和响应信号呢？通常发生在以下两种情况下：</p>
<ol>
<li>当前进程由于系统调用、中断或异常而进入内核空间以后，从内核空间返回到用户空间前夕；</li>
<li>当前进程在内核中进入睡眠以后刚被唤醒的时候，由于检测到信号的存在而提前返回到用户空间。</li>
</ol>
<p>当有信号要响应时，当前进程在用户态执行的过程中，陷入系统调用或中断服务例程，于是，当前进程从用户态切换到内核态；当处理完系统调用要返回到用户态前夕，发现有信号处理程序需要执行，于是，又从内核态切换到用户态；当执行完信号处理程序后，并不是接着就在用户态执行应用程序，而是还要返回到内核态。为什么还要返回到内核态呢？这是因为此时还没有真正从系统调用返回到用户态，于是从信号处理程序返回到内核态就是为了处理从系统调用到用户态的返回。</p>
<h3 id="信号掩码"><a href="#信号掩码" class="headerlink" title="信号掩码"></a>信号掩码</h3><p>在<code>POSIX</code>下，每个进程有一个信号掩码(Signal Mask)。简单地说，信号掩码是一个“位图”，其中每一位都对应着一种信号。如果位图中的某一位为 1，就表示在执行当前信号的处理程序期间相应的信号暂时被“屏蔽”，使得在执行的过程中不会嵌套地响应那种信号。</p>
<p>当一个程序正在运行时，在键盘上按一下<code>CTRL+C</code>，内核就会向相应的进程发出一个<code>SIGINT</code>信号，而对这个信号的默认操作就是通过<code>do_exit()</code>结束该进程的运行。在实践中却发现，两次<code>CTRL+C</code>事件往往过于密集，有时候刚刚进入第 1 个信号的处理程序，第 2 个<code>SIGINT</code>信号就到达了，而第 2 个信号的默认操作是杀死进程，这样，第 1 个信号的处理程序根本没有执行完。为了避免这种情况的出现，就在执行一个信号处理程序的过程中将该种信号自动屏蔽掉。所谓“屏蔽”，与将信号忽略是不同的，它只是将信号暂时“遮盖”一下，一旦屏蔽去掉，已到达的信号又继续得到处理。</p>
<p><code>Linux</code>内核中有一个专门的函数集合来执行设置和修改信号掩码，它们放在<code>kernel/signal.c</code>中，其函数形式和功能如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数形式</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int sigemptyset(sigset_t *mask)</code></td>
<td>清所有信号掩码的阻塞标志</td>
</tr>
<tr>
<td><code>int sigfillset(sigset_t *mask, int signum)</code></td>
<td>设置所有信号掩码的阻塞标志</td>
</tr>
<tr>
<td><code>int sigdelset(sigset_t *mask, int signum)</code></td>
<td>删除个别信号阻塞</td>
</tr>
<tr>
<td><code>int sigaddset(sigset_t *mask, int signum)</code></td>
<td>增加个别信号阻塞</td>
</tr>
<tr>
<td><code>int sigisnumber(sigset_t *mask, int signum)</code></td>
<td>确定特定的信号是否在掩码中被标志为阻塞</td>
</tr>
</tbody>
</table>
</div>
<p>另外，进程也可以利用<code>sigprocmask()</code>系统调用改变和检查自己的信号掩码的值，其实现代码在<code>kernel/signal.c</code>中，原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oset)</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>set</code>是指向信号掩码的指针，进程的信号掩码是根据参数<code>how</code>的取值设置成<code>set</code>。参数<code>how</code>的取值及含义如下：</p>
<ul>
<li><code>SIG_BOLCK</code>：<code>set</code>规定附加的阻塞信号</li>
<li><code>SIG_UNBOCK</code>：<code>set</code>规定一组不予阻塞的信号</li>
<li><code>SIG_SETBLOCK</code>：<code>set</code>变成新进程的信号掩码 </li>
</ul>
<p>用一段代码来说明这个问题：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (how) &#123;</span><br><span class="line">	<span class="keyword">case</span> SIG_BLOCK:</span><br><span class="line">		current-&gt;blocked |= new_set;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SIG_UNBLOCK:</span><br><span class="line">		current-&gt;blocked &amp;= ~new_set;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SIG_SETMASK:</span><br><span class="line">		current-&gt;blocked = new_set;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>current</code>为指向当前进程<code>task_struc</code>结构的指针。第 3 个参数<code>oset</code>也是指向信号掩码的指针，它将包含以前的信号掩码值，使得在必要的时候，可以恢复它。</p>
<p>进程可以用<code>sigpending()</code>系统调用来检查是否有挂起的阻塞信号。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>除了<code>signal()</code>系统调用，<code>Linux</code>还提供关于信号的系统调用如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>调用原型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int sigaction(sig,&amp;handler,&amp;oldhandler)</code></td>
<td>定义对信号的处理操作</td>
</tr>
<tr>
<td><code>int sigreturn(&amp;context)</code></td>
<td>从信号返回</td>
</tr>
<tr>
<td><code>int sigprocmask(int how, sigset_t *mask, sigset_t *old)</code></td>
<td>检查或修改信号屏蔽</td>
</tr>
<tr>
<td><code>int sigpending(sigset_t mask)</code></td>
<td>替换信号掩码并使进程挂起</td>
</tr>
<tr>
<td><code>int kill(pid_t pid, int sig)</code></td>
<td>发送信号到进程</td>
</tr>
<tr>
<td><code>long alarm(long secs)</code></td>
<td>设置事件闹钟</td>
</tr>
<tr>
<td><code>int pause(void)</code></td>
<td>将调用进程挂起直到下一个进程</td>
</tr>
</tbody>
</table>
</div>
<p>其中<code>sigset_t</code>定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">sigset_t</span>; <span class="comment">/* 至少 32 位*/</span></span><br></pre></td></tr></table></figure></p>
<p>下面介绍几个典型的系统调用。</p>
<h4 id="kill系统调用"><a href="#kill系统调用" class="headerlink" title="kill系统调用"></a>kill系统调用</h4><p>从前面的叙述可以看到，一个进程接收到的信号，或者是由异常的错误产生(如浮点异常)，或者是用户在键盘上用中断和退出信号干涉而产生，那么，一个进程能否给另一个进程发送信号？回答是肯定的，但发送者进程必须有适当的权限。<code>Kill()</code>系统调用可以完成此任务：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>sig</code>规定发送哪一个信号，参数<code>pid</code>(进程标识号)规定把信号发送到何处，<code>pid</code>各种不同值具有下列意义：</p>
<ul>
<li><code>pid&gt;0</code>：信号<code>sig</code>发送给进程标识号为<code>pid</code>的进程；</li>
<li><code>pid=0</code>：设调用<code>kill()</code>的进程其组标识号为<code>p</code>，则把信号<code>sig</code>发送给与<code>p</code>相等的其他所有进程；</li>
<li><code>pid=-1</code>：<code>Linux</code>规定把信号<code>sig</code>发送给系统中除去<code>init</code>进程和调用者以外的所有进程；</li>
<li><code>pid&lt;-1</code>：信号发送给进程组<code>-pid</code>中的所有进程。</li>
</ul>
<p>为了用<code>kill()</code>发送信号，调用进程的有效用户<code>ID</code>必须是<code>root</code>，或者必须和接收进程的实际或有效用户<code>ID</code>相同。</p>
<h4 id="pause-和alarm-系统调用"><a href="#pause-和alarm-系统调用" class="headerlink" title="pause()和alarm()系统调用"></a>pause()和alarm()系统调用</h4><p>当一个进程需要等待另一个进程完成某项操作时，它将执行<code>pause()</code>调用，当这项操作已完成时，另一个进程可以发送一个预约的信号给这一暂停的进程，它将强迫<code>pause()</code>返回，并且允许收到信号的进程恢复执行，知道它正在等待的事件现在已经出现。</p>
<p>对于许多实际应用，需要在一段指定时间后，中断进程的原有操作，以进行某种其他的处理，系统提供了<code>alarm()</code>系统调用。每个进程都有一个闹钟计时器与之相联，在经过预先设置的时间后，进程可以用它来给自己发送<code>SIGALARM</code>信号。<code>alarm()</code>调用只取一个参数<code>secs</code>，它是在闹钟关闭之前所经过的秒数。如果传递一个 0 值给<code>alarm()</code>，这将关闭任何当前正在运行的闹钟计时器。</p>
<p><code>alarm()</code>返回值是以前的闹钟计时器值，如果当前没有设置任何闹钟计时器，这将是零，或者是当作出该调用时，闹钟的剩余时间。</p>
<h3 id="典型系统调用的实现"><a href="#典型系统调用的实现" class="headerlink" title="典型系统调用的实现"></a>典型系统调用的实现</h3><p><code>sigaction()</code>系统调用的实现较具代表性，它的主要功能为设置信号处理程序，其原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction * action,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> sigaction * oldaction)</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>sigaction</code>数据结构在<code>include/asm/signal.h</code>中定义，其格式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="type">__sighandler_t</span> sa_handler;</span><br><span class="line">	<span class="type">sigset_t</span> sa_mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sa_flags;</span><br><span class="line">	<span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>其中<code>__sighandler_t</code>定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">__sighandler_t</span>)</span> <span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>在这个结构中，<code>sa_handler</code>为指向处理函数的指针，<code>sa_mask</code>是信号掩码，当该信号<code>signum</code>出现时，这个掩码就被逻辑或到接收进程的信号掩码中。当信号处理程序执行时，这个掩码保持有效。<code>sa_flags</code>域是几个位标志的逻辑或(OR)组合，其中两个主要的标志是：</p>
<ul>
<li><code>SA_ONESHOT</code>信号出现时，将信号操作置为默认操作；</li>
<li><code>SA_NOMASK</code>忽略<code>sigaction</code>结构的<code>sa_mask</code>域。</li>
</ul>
<p><code>Linux</code>中定义的信号处理的 3 种类型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_DFL ((__sighandler_t)0) <span class="comment">/* 缺省的信号处理*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_IGN ((__sighandler_t)1) <span class="comment">/*忽略这个信号 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_ERR ((__sighandler_t)-1) <span class="comment">/*从信号返回错误 */</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面是<code>sigaction()</code>系统调用在内核中实现的代码及解释。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction * action,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> sigaction * oldaction)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">new_sa</span>, *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (signum&lt;<span class="number">1</span> || signum&gt;<span class="number">32</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">/* 信号的值不在 1～32 之间，则出错 */</span></span><br><span class="line">	<span class="keyword">if</span> (signum==SIGKILL || signum==SIGSTOP)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">/* SIGKILL和SIGSTOP不能设置信号处理程序 */</span></span><br><span class="line">	p = signum - <span class="number">1</span> + current-&gt;sig-&gt;action;</span><br><span class="line">	<span class="comment">/*在当前进程中，指向信号`signum`的`action`的指针 */</span></span><br><span class="line">	<span class="keyword">if</span> (action) &#123;</span><br><span class="line">		<span class="type">int</span> err = verify_area(VERIFY_READ, action, <span class="keyword">sizeof</span>(*action));</span><br><span class="line">		<span class="comment">/* 验证给action在用户空间分配的地址的有效性 */</span></span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		memcpy_fromfs(&amp;new_sa, action, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sigaction));</span><br><span class="line">		<span class="comment">/* 把actoin的内容从用户空间拷贝到内核空间*/</span></span><br><span class="line">		new_sa.sa_mask |= _S(signum);</span><br><span class="line">		<span class="comment">/* 把信号signum加到掩码中 */</span></span><br><span class="line">		<span class="keyword">if</span> (new_sa.sa_flags &amp; SA_NOMASK)</span><br><span class="line">			new_sa.sa_mask &amp;= ~_S(signum);</span><br><span class="line">		<span class="comment">/* 如果标志为SA_NOMASK，当信号signum出现时，将它的操作置为默认操作 */</span></span><br><span class="line">		new_sa.sa_mask &amp;= _BLOCKABLE;</span><br><span class="line">		<span class="comment">/* 不能阻塞`SIGKILL`和`SIGSTOP */</span></span><br><span class="line">		<span class="keyword">if</span> (new_sa.sa_handler != SIG_DFL &amp;&amp; new_sa.sa_handler !=SIG_IGN) &#123;</span><br><span class="line">			err = verify_area(VERIFY_READ, new_sa.sa_handler, <span class="number">1</span>);</span><br><span class="line">			<span class="comment">/* 当处理程序不是信号默认的处理操作，并且`signum`信号不能被忽略时，验证给信号处理程序分配空间的有效性 */</span></span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (oldaction) &#123; </span><br><span class="line">		<span class="type">int</span> err = verify_area(VERIFY_WRITE, oldaction, <span class="keyword">sizeof</span>(*oldaction));</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		memcpy_tofs(oldaction, p, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sigaction));</span><br><span class="line">		<span class="comment">/* 恢复原来的信号处理程序 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (action) &#123;</span><br><span class="line">		*p = new_sa;</span><br><span class="line">		check_pending(signum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Linux</code>可以将各种信号发送给程序，以表示程序故障、用户请求的中断、其他各种情况等。通过对<code>sigaction()</code>系统调用源代码的分析，有助于灵活应用信号的系统调用。</p>
<h3 id="进程与信号的关系"><a href="#进程与信号的关系" class="headerlink" title="进程与信号的关系"></a>进程与信号的关系</h3><p>系统在<code>task_struct</code>结构中利用两个域分别记录当前挂起的信号(Signal)以及当前阻塞的信号(Blocked)。挂起的信号指尚未进行处理的信号。阻塞的信号指进程当前不处理的信号，如果产生了某个当前被阻塞的信号，则该信号会一直保持挂起，直到该信号不再被阻塞为止。除了<code>SIGKILL</code>和<code>SIGSTOP</code>信号外，所有的信号均可以被阻塞，信号的阻塞可通过系统调用<code>sigprocmask()</code>实现。每个进程的<code>task_struct</code>结构中还包含了一个指向<code>sigaction</code>结构数组的指针，该结构数组中的信息实际指定了进程处理所有信号的方式。</p>
<p>如果某个<code>sigaction</code>结构中包含有处理信号的例程地址，则由该处理例程处理该信号；反之，则根据结构中的一个标志或者由内核进行默认处理，或者只是忽略该信号。通过系统调用<code>sigaction()</code>，进程可以修改<code>sigaction</code>结构数组的信息，从而指定进程处理信号的方式。</p>
<p>进程不能向系统中所有的进程发送信号，一般而言，除系统和超级用户外，普通进程只能向具有相同<code>uid</code>和<code>gid</code>的进程，或者处于同一进程组的进程发送信号。当有信号产生时，内核将进程<code>task_struct</code>的<code>signal</code>字中的相应位设置为 1。系统不对置位之前该位已经为1 的情况进行处理，因而进程无法接收到前一次信号。如果进程当前没有阻塞该信号，并且进程正处于可中断的等待状态(INTERRUPTIBLE)，则内核将该进程的状态改变为运行(RUNNING)，并放置在运行队列中。这样，调度程序在进行调度时，就有可能选择该进程运行，从而可以让进程处理该信号。</p>
<p>发送给某个进程的信号并不会立即得到处理，相反，只有该进程再次运行时，才有机会处理该信号。每次进程从系统调用中退出时，内核会检查它的<code>signal</code>和<code>block</code>字段，如果有任何一个未被阻塞的信号发出，内核就根据<code>sigaction</code>结构数组中的信息进行处理。处理过程如下。 </p>
<ol>
<li>检查对应的<code>sigaction</code>结构，如果该信号不是<code>SIGKILL</code>或<code>SIGSTOP</code>信号，且被忽略，则不处理该信号。</li>
<li>如果该信号利用默认的处理程序处理，则由内核处理该信号，否则转向第(3)步。</li>
<li>该信号由进程自己的处理程序处理，内核将修改当前进程的调用堆栈，并将进程的程序计数寄存器修改为信号处理程序的入口地址。此后，指令将跳转到信号处理程序，当从信号处理程序中返回时，实际就返回了进程的用户模式部分。</li>
</ol>
<p><code>Linux</code>是与<code>POSIX</code>兼容的，因此，进程在处理某个信号时，还可以修改进程的<code>blocked</code>掩码。但是，当信号处理程序返回时，<code>blocked</code>值必须恢复为原有的掩码值，这一任务由内核的<code>sigaction()</code>函数完成。</p>
<p><code>Linux</code>在进程的调用堆栈帧中添加了对清理程序的调用，该清理程序可以恢复原有的<code>blocked</code>掩码值。当内核在处理信号时，可能同时有多个信号需要由用户处理程序处理，这时，<code>Linux</code>内核可以将所有的信号处理程序地址推入堆栈中，而当所有的信号处理完毕后，调用清理程序恢复原先的<code>blocked</code>值。</p>
<h3 id="信号举例"><a href="#信号举例" class="headerlink" title="信号举例"></a>信号举例</h3><p>下面通过<code>Linux</code>提供的系统调用<code>signal()</code>，来说明如何执行一个预先安排好的信号处理函数。<code>signal()</code>调用的原型是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (* signal(<span class="type">int</span> signum, <span class="type">void</span>(*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>signal()</code>的返回值是指向一个函数的指针，该函数的参数为一个整数，无返回值，下面是用户级程序的一段代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> ctrl_c_count=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> (* old_handler)(INT);</span><br><span class="line"><span class="type">void</span> <span class="title function_">ctrl_c</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">	old_handler = signal(SIGINT,ctrl_c);</span><br><span class="line">	<span class="keyword">while</span> ((c=getchar())! = <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ctrl-c count = %d\n&quot;</span>,ctrl_c_count);</span><br><span class="line">	(<span class="type">void</span>) signal(SIGINT,old_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ctrl_c</span><span class="params">(<span class="type">int</span> signum)</span> </span><br><span class="line">&#123;</span><br><span class="line">	(<span class="type">void</span>)signal(SIGINT,ctrl_c)</span><br><span class="line">	++ctrl_c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序说明：这个程序是从键盘获得字符，直到换行符为止，然后进入无限循环。这里，程序安排了捕获<code>ctrl_c</code>信号(SIGINT)，并且利用<code>SIGINT</code>来执行一个<code>ctrl_c</code>的处理函数。当在键盘上敲入一个换行符时，<code>SIGINT</code>原来的操作(很可能是默认操作)才被恢复。<code>main()</code>函数中的第一个语句完成设置信号处理程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">old_handler = signal(SIGINT,ctrl_c);</span><br></pre></td></tr></table></figure></p>
<p><code>signal()</code>的两个参数是：信号值，这里是键盘中断信号<code>SIGINT</code>，以及一个指向函数的指针，这里是<code>ctrl_c</code>，当这个中断信号出现时，将调用该函数。<code>signal()</code>调用返回旧的信号处理程序的地址，在此它被赋给变量<code>older_handler</code>，使得原来的信号处理程序稍后可以被恢复。</p>
<p>一旦信号处理程序放在应放的位置，进程收到任何中断(SIGINT)信号将引起信号处理函数的执行。这个函数增加<code>ctrl_c_count</code>变量的值以保持对<code>SIGINT</code>事件出现次数的计数。注意信号处理函数也执行另一个<code>signal()</code>调用，它重新建立<code>SIGINT</code>信号和<code>ctrl_c</code>函数之间的联系。这是必需的，因为当信号出现时，用<code>signal()</code>调用设置的信号处理程序被自动恢复为默认操作，使得随后的同一信号将只执行信号的默认操作。</p>
<h2 id="System-V的IPC机制"><a href="#System-V的IPC机制" class="headerlink" title="System V的IPC机制"></a>System V的IPC机制</h2><p>为了提供与其他系统的兼容性，<code>Linux</code>也支持 3 种<code>system V</code>的进程间通信机制：消息、信号量(semaphores)和共享内存，<code>Linux</code>对这些机制的实施大同小异。我们把信号量、消息和共享内存统称<code>System V IPC</code>的对象，每一个对象都具有同样类型的接口，即系统调用。</p>
<p>就像每个文件都有一个打开文件号一样，每个对象也都有唯一的识别号，进程可以通过系统调用传递的识别号来存取这些对象，与文件的存取一样，对这些对象的存取也要验证存取权限，<code>System V IPC</code>可以通过系统调用对对象的创建者设置这些对象的存取权限。</p>
<p>在<code>Linux</code>内核中，<code>System V IPC</code>的所有对象有一个公共的数据结构<code>pc_perm</code>结构，它是<code>IPC</code>对象的权限描述，在<code>linux/ipc.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">key_t</span> key; <span class="comment">/* 键 */</span></span><br><span class="line">	ushort uid; <span class="comment">/* 对象拥有者对应进程的有效用户识别号和有效组识别号 */</span></span><br><span class="line">	ushort gid;</span><br><span class="line">	ushort cuid; <span class="comment">/* 对象创建者对应进程的有效用户识别号和有效组识别号 */</span></span><br><span class="line">	ushort cgid;</span><br><span class="line">	ushort mode; <span class="comment">/* 存取模式 */</span></span><br><span class="line">	ushort seq; <span class="comment">/* 序列号 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个结构中，要进一步说明的是键(key)。键和识别号指的是不同的东西。系统支持两种键：公有和私有。如果键是公有的，则系统中所有的进程通过权限检查后，均可以找到<code>System V IPC</code>对象的识别号。如果键是公有的，则键值为 0，说明每个进程都可以用键值 0 建立一个专供其私用的对象。注意，对<code>System V IPC</code>对象的引用是通过识别号而不是通过键，从后面的系统调用中可了解这一点。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量(semaphore )实际是一个整数，它的值由多个进程进行测试(test)和设置(set)。就每个进程所关心的测试和设置操作而言，这两个操作是不可中断的，或称“原子”操作，即一旦开始直到两个操作全部完成。测试和设置操作的结果是：信号量的当前值和设置值相加，其和或者是正或者为负。根据测试和设置操作的结果，一个进程可能必须睡眠，直到有另一个进程改变信号量的值。</p>
<p>信号量作为资源计数器，它的初值可以是任何正整数，其初值不一定为 0 或 1。另外，如果一个进程要先获得两个或多个的共享资源后才能执行的话，那么，相应地也需要多个信号量，而多个进程要分别获得多个临界资源后方能运行，这就是信号量集合机制。</p>
<h4 id="信号量的数据结构"><a href="#信号量的数据结构" class="headerlink" title="信号量的数据结构"></a>信号量的数据结构</h4><p><code>Linux</code>中信号量是通过内核提供的一系列数据结构实现的，这些数据结构存在于内核空间，对它们的分析是充分理解信号量及利用信号量实现进程间通信的基础，下面先给出信号量的数据结构(存在于<code>include/linux/sem.h</code>中)，其他一些数据结构将在相关的系统调用中介绍。</p>
<p>(1)系统中每个信号量的数据结构(sem)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> semval; <span class="comment">/* 信号量的当前值 */</span></span><br><span class="line">	<span class="type">int</span> sempid; <span class="comment">/*在信号量上最后一次操作的进程识别号 *</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>(2)系统中表示信号量集合(set)的数据结构(semid_ds)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span> <span class="comment">/* IPC`权限 */</span></span><br><span class="line">	<span class="type">long</span> sem_otime; <span class="comment">/* 最后一次对信号量操作(semop)的时间 */</span></span><br><span class="line">	<span class="type">long</span> sem_ctime; <span class="comment">/* 对这个结构最后一次修改的时间 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span> <span class="comment">/* 在信号量数组中指向第一个信号量的指针 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">sem_pending</span>;</span> <span class="comment">/* 待处理的挂起操作*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> **<span class="title">sem_pending_last</span>;</span> <span class="comment">/* 最后一个挂起操作 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">undo</span>;</span> <span class="comment">/* 在这个数组上的`undo`请求 */</span></span><br><span class="line">	ushort sem_nsems; <span class="comment">/* 在信号量数组上的信号量号 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>(3)系统中每一信号量集合的队列结构(sem_queue)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> * <span class="title">next</span>;</span> <span class="comment">/* 队列中下一个节点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> ** <span class="title">prev</span>;</span> <span class="comment">/* 队列中前一个节点, *(q-&gt;prev) == q */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wait_queue</span> * <span class="title">sleeper</span>;</span> <span class="comment">/* 正在睡眠的进程 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> * <span class="title">undo</span>;</span> <span class="comment">/* undo`结构*/</span></span><br><span class="line">	<span class="type">int</span> pid; <span class="comment">/* 请求进程的进程识别号 */</span></span><br><span class="line">	<span class="type">int</span> status; <span class="comment">/* 操作的完成状态 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> * <span class="title">sma</span>;</span> <span class="comment">/*有操作的信号量集合数组 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> * <span class="title">sops</span>;</span> <span class="comment">/* 挂起操作的数组 */</span></span><br><span class="line">	<span class="type">int</span> nsops; <span class="comment">/* 操作的个数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>(4)几个主要数据结构之间的关系：<br><img src="/img/1633944372.jpg" alt=""></p>
<p>从图 7.3 可以看出，<code>semid_ds</code>结构的<code>sem_base</code>指向一个信号量数组，允许操作这些信号量集合的进程可以利用系统调用执行操作 。注意，信号量与信号量集合的区别，从上面可以看出，信号量用<code>sem</code>结构描述，而信号量集合用<code>semid_ds</code>结构描述。</p>
<h4 id="系统调用：semget"><a href="#系统调用：semget" class="headerlink" title="系统调用：semget()"></a>系统调用：semget()</h4><p>为了创建一个新的信号量集合，或者存取一个已存在的集合，要使用<code>segget()</code>系统调用，其描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semget</span> <span class="params">( <span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg )</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果成功，则返回信号量集合的<code>IPC</code>识别号；如果为-1，则出现错误。</p>
<p><code>semget()</code>中的第 1 个参数是键值，这个键值要与已有的键值进行比较，已有的键值指在内核中已存在的其他信号量集合的键值。对信号量集合的打开或存取操作依赖于<code>semflg</code>参数的取值。</p>
<ul>
<li><code>IPC_CREAT</code>：如果内核中没有新创建的信号量集合，则创建它。</li>
<li><code>IPC_EXCL</code>：当与<code>IPC_CREAT</code>一起使用时，如果信号量集合已经存在，则创建失败。</li>
</ul>
<p>如果<code>IPC_CREAT</code>单独使用，<code>semget()</code>为一个新创建的集合返回标识号，或者返回具有相同键值的已存在集合的标识号。如果<code>IPC_EXCL</code>与<code>IPC_CREAT</code>一起使用，要么创建一个新的集合，要么对已存在的集合返回-1。<code>IPC_EXCL</code>单独是没有用的，当与<code>IPC_CREAT</code>结合起来使用时，可以保证新创建集合的打开和存取。</p>
<p>作为<code>System V IPC</code>的其他形式，一种可选项是把一个八进制与掩码或，形成信号量集合的存取权限。</p>
<p>第 3 个参数<code>nsems</code>指的是在新创建的集合中信号量的个数。其最大值在<code>linux/sem.h</code>中定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SEMMSL 250 <span class="comment">/* &lt;= 8 000 max num of semaphores per id */</span> </span></span><br></pre></td></tr></table></figure></p>
<p>注意，如果你是显式地打开一个现有的集合，则<code>nsems</code>参数可以忽略。</p>
<p>下面举例说明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_semaphore_set</span><span class="params">( <span class="type">key_t</span> keyval, <span class="type">int</span> numsems )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sid;</span><br><span class="line">	<span class="keyword">if</span> ( ! numsems )</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((sid = semget( keyval, numsems, IPC_CREAT | <span class="number">0660</span> )) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(sid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这个例子显式地用了 0660 权限。这个函数要么返回一个集合的标识号，要么返回-1 而出错。键值必须传递给它，信号量的个数也传递给它，这是因为如果创建成功则要分配空间。</p>
<h4 id="系统调用-semop"><a href="#系统调用-semop" class="headerlink" title="系统调用: semop()"></a>系统调用: semop()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semop</span> <span class="params">( <span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">unsigned</span> nsops)</span>;</span><br></pre></td></tr></table></figure>
<p>如果所有的操作都执行，则成功返回 0。如果为-1，则出错。</p>
<p><code>semop()</code>中的第 1 个参数(semid)是集合的识别号(可以由<code>semget()</code>系统调用得到)。第 2 个参数(sops)是一个指针，它指向在集合上执行操作的数组。而第 3 个参数(nsops)是在那个数组上操作的个数。</p>
<p><code>sops</code>参数指向类型为<code>sembuf</code>的一个数组，这个结构在<code>/inclide/linux/sem.h</code>中声明，是内核中的一个数据结构，描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">	ushort sem_num; <span class="comment">/* 在数组中信号量的索引值 */</span></span><br><span class="line">	<span class="type">short</span> sem_op; <span class="comment">/* 信号量操作值(正数、负数或 0) */</span></span><br><span class="line">	<span class="type">short</span> sem_flg; <span class="comment">/* 操作标志，为IPC_NOWAIT或SEM_UNDO*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果<code>sem_op</code>为负数，那么就从信号量的值中减去<code>sem_op</code>的绝对值，这意味着进程要获取资源，这些资源是由信号量控制或监控来存取的。如果没有指定<code>IPC_NOWAIT</code>，那么调用进程睡眠到请求的资源数得到满足(其他的进程可能释放一些资源)。</li>
<li>如果<code>sem_op</code>是正数，把它的值加到信号量，这意味着把资源归还给应用程序的集合。</li>
<li>最后，如果<code>sem_op</code>为 0，那么调用进程将睡眠到信号量的值也为 0，这相当于一个信号量到达了 100%的利用。</li>
</ul>
<p>综上所述，<code>Linux</code>按如下的规则判断是否所有的操作都可以成功：操作值和信号量的当前值相加大于 0，或操作值和当前值均为 0，则操作成功。如果系统调用中指定的所有操作中有一个操作不能成功时，则<code>Linux</code>会挂起这一进程。但是，如果操作标志指定这种情况下不能挂起进程的话，系统调用返回并指明信号量上的操作没有成功，而进程可以继续执行。如果进程被挂起，<code>Linux</code>必须保存信号量的操作状态并将当前进程放入等待队列。</p>
<p>为此，<code>Linux</code>内核在堆栈中建立一个<code>sem_queue</code>结构并填充该结构。新的<code>sem_queue</code>结构添加到集合的等待队列中(利用<code>sem_pending</code>和<code>sem_pending_last</code>指针)。当前进程放入<code>sem_queue</code>结构的等待队列中<code>sleeper</code>后调用调度程序选择其他的进程运行。</p>
<h4 id="系统调用：semctl"><a href="#系统调用：semctl" class="headerlink" title="系统调用：semctl()"></a>系统调用：semctl()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semctl</span> <span class="params">( <span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, <span class="keyword">union</span> semun arg )</span>;</span><br></pre></td></tr></table></figure>
<p>成功返回正数，出错返回-1。</p>
<p>注意，<code>semctl()</code>是在集合上执行控制操作。</p>
<p><code>semctl()</code>的第 1 个参数(semid)是集合的标识号，第 2 个参数(semnum)是将要操作的信号量个数，从本质上说，它是集合的一个索引，对于集合上的第一个信号量，则该值为0。</p>
<ul>
<li><code>cmd</code>参数表示在集合上执行的命令，这些命令及解释如表所示。</li>
<li><code>arg</code>参数的类型为<code>semun</code>，这个特殊的联合体在<code>include/linux/sem.h</code>中声明，对它的描述如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arg for semctl system calls. */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> val; <span class="comment">/* value for SETVAL */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span> <span class="comment">/* buffer for IPC_STAT &amp; IPC_SET */</span></span><br><span class="line">	ushort *<span class="built_in">array</span>; <span class="comment">/* array for GETALL &amp; SETALL */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span> <span class="comment">/* buffer for IPC_INFO */</span></span><br><span class="line">	<span class="type">void</span> *__pad;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个联合体中，有 3 个成员已经在表 7.1 中提到，剩下的两个成员<code>_buf</code>和<code>_pad</code>用在内核中信号量的实现代码，开发者很少用到。事实上，这两个成员是<code>Linux</code>操作系统所特有的，在<code>UINX</code>中没有。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IPC_STAT</code></td>
<td>从信号量集合上检索<code>semid_ds</code>结构，并存到<code>semun</code>联合体参数的成员<code>buf</code>的地址中</td>
</tr>
<tr>
<td><code>IPC_SET</code></td>
<td>设置一个信号量集合的<code>semid_ds</code>结构中<code>ipc_perm</code>域的值，并从<code>semun</code>的<code>buf</code>中取出值</td>
</tr>
<tr>
<td><code>IPC_RMID</code></td>
<td>从内核中删除信号量集合</td>
</tr>
<tr>
<td><code>GETALL</code></td>
<td>从信号量集合中获得所有信号量的值，并把其整数值存到<code>semun</code>联合体成员的一个指针数组中</td>
</tr>
<tr>
<td><code>GETNCNT</code></td>
<td>返回当前等待资源的进程个数</td>
</tr>
<tr>
<td><code>GETPID</code></td>
<td>返回最后一个执行系统调用<code>semop()</code>进程的<code>PID</code></td>
</tr>
<tr>
<td><code>GETVAL</code></td>
<td>返回信号量集合内单个信号量的值</td>
</tr>
<tr>
<td><code>GETZCNT</code></td>
<td>返回当前等待 100%资源利用的进程个数</td>
</tr>
<tr>
<td><code>SETALL</code></td>
<td>与<code>GETALL</code>正好相反</td>
</tr>
<tr>
<td><code>SETVAL</code></td>
<td>用联合体中<code>val</code>成员的值设置信号量集合中单个信号量的值</td>
</tr>
</tbody>
</table>
</div>
<p>这个系统调用比较复杂，我们举例说明。下面这个程序段返回集合上索引为<code>semnum</code>对应信号量的值。当用<code>GETVAL</code>命令时，最后的参数(semnum)被忽略。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_sem_val</span><span class="params">( <span class="type">int</span> sid, <span class="type">int</span> semnum )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>( semctl(sid, semnum, GETVAL, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>和信号量操作相关的概念还有“死锁”。当某个进程修改了信号量而进入临界区之后，却因为崩溃或被“杀死(kill)”而没有退出临界区，这时，其他被挂起在信号量上的进程永远得不到运行机会，这就是所谓的死锁。<code>Linux</code>通过维护一个信号量数组的调整列表(semadj)来避免这一问题。其基本思想是，当应用这些“调整”时，让信号量的状态退回到操作实施前的状态。</p>
<p>关于调整的描述是在<code>sem_undo</code>数据结构中，在<code>include/linux/sem.h</code>描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*每一个任务都有一系列的恢复(undo)请求，当进程退出时，自动执行`undo`请求*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> * <span class="title">proc_next</span>;</span> <span class="comment">/*在这个进程上的下一个sem_undo节点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> * <span class="title">id_next</span>;</span> <span class="comment">/* 在这个信号量集和上的下一个sem_undo节点*/</span></span><br><span class="line">	<span class="type">int</span> semid; <span class="comment">/* 信号量集的标识号*/</span> </span><br><span class="line">	<span class="type">short</span> * semadj; <span class="comment">/* 信号量数组的调整，每个进程一个*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>sem_undo</code>结构也出现在<code>task_struct</code>数据结构中。</p>
<p>每一个单独的信号量操作也许要请求得到一次“调整”，<code>Linux</code>将为每一个信号量数组的每一个进程维护至少一个<code>sem_undo</code>结构。如果请求的进程没有这个结构，当必要时则创建它，新创建的<code>sem_undo</code>数据结构既在这个进程的<code>task_struct</code>数据结构中排队，也在信号量数组的<code>semid_ds</code>结构中排队。当对信号量数组上的一个信号量施加操作时，这个操作值的负数与这个信号量的“调整”相加，因此，如果操作值为 2，则把-2 加到这个信号量的“调整”域。</p>
<p>当进程被删除时，<code>Linux</code>完成了对<code>sem_undo</code>数据结构的设置及对信号量数组的调整。如果一个信号量集合被删除，<code>sem_undo</code>结构依然留在这个进程的<code>task_struct</code>结构中，但信号量集合的识别号变为无效。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>一个或多个进程可向消息队列写入消息，而一个或多个进程可从消息队列中读取消息。在许多微内核结构的操作系统中，内核和各组件之间的基本通信方式就是消息队列。例如，在<code>Minlx</code>操作系统中，内核、I/O任务、服务器进程和用户进程之间就是通过消息队列实现通信的。</p>
<p><code>Linux</code>中的消息可以被描述成在内核地址空间的一个内部链表，每一个消息队列由一个<code>IPC</code>的标识号唯一地标识。<code>Linux</code>为系统中所有的消息队列维护一个<code>msgque</code>链表，该链表中的每个指针指向一个<code>msgid_ds</code>结构，该结构完整描述一个消息队列。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>(1)消息缓冲区(<code>msgbuf</code>)，可以把这个特殊的数据结构看成一个存放消息数据的模板，它在<code>include/linux/msg.h</code>中声明，描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* msgsnd`和`msgrcv`系统调用使用的消息缓冲区*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> mtype; <span class="comment">/* 消息的类型，必须为正数 */</span></span><br><span class="line">	<span class="type">char</span> mtext[<span class="number">1</span>]; <span class="comment">/* 消息正文 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，对于消息数据元素(mtext)，不要受其描述的限制。实际上，这个域(mtext)不仅能保存字符数组，而且能保存任何形式的任何数据。这个域本身是任意的，因为这个结构本身可以由应用程序员重新定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_msgbuf</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> mtype; <span class="comment">/* 消息类型 */</span></span><br><span class="line">	<span class="type">long</span> request_id; <span class="comment">/* 请求识别号 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">client</span> <span class="title">info</span>;</span> <span class="comment">/* 客户消息结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们看到，消息的类型还是和前面一样，但是结构的剩余部分由两个其他的元素代替，而且有一个是结构。这就是消息队列的优美之处，内核根本不管传送的是什么样的数据，任何信息都可以传送。</p>
<p>但是，消息的长度还是有限制的，在<code>Linux</code>中，给定消息的最大长度在<code>include/linux/msg.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MSGMAX 8192 <span class="comment">/* max size of message (bytes) */</span></span></span><br></pre></td></tr></table></figure></p>
<p>消息总的长度不能超过 8192 字节，包括<code>mtype</code>域，它是 4 字节长。</p>
<p>(2)消息结构(msg)：内核把每一条消息存储在以<code>msg</code>结构为框架的队列中，它在<code>include/ linux/msg.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_next</span>;</span> <span class="comment">/* 队列上的下一条消息 */</span></span><br><span class="line">	<span class="type">long</span> msg_type; <span class="comment">/*消息类型*/</span></span><br><span class="line">	<span class="type">char</span> *msg_spot; <span class="comment">/* 消息正文的地址 */</span></span><br><span class="line">	<span class="type">short</span> msg_ts; <span class="comment">/* 消息正文的大小 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>msg_next</code>是指向下一条消息的指针，它们在内核地址空间形成一个单链表。</p>
<p>(3)消息队列结构(msgid_ds)：当在系统中创建每一个消息队列时，内核创建、存储及维护这个结构的一个实例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在系统中的每一个消息队列对应一个msqid_ds结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_first</span>;</span> <span class="comment">/* 队列上第一条消息，即链表头*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_last</span>;</span> <span class="comment">/* 队列中的最后一条消息，即链表尾 */</span></span><br><span class="line">	<span class="type">time_t</span> msg_stime; <span class="comment">/* 发送给队列的最后一条消息的时间 */</span></span><br><span class="line">	<span class="type">time_t</span> msg_rtime; <span class="comment">/* 从消息队列接收到的最后一条消息的时间 */</span></span><br><span class="line">	<span class="type">time_t</span> msg_ctime; <span class="comment">/* 最后修改队列的时间*/</span></span><br><span class="line">	ushort msg_cbytes; <span class="comment">/*队列上所有消息总的字节数 */</span></span><br><span class="line">	ushort msg_qnum; <span class="comment">/*在当前队列上消息的个数 */</span></span><br><span class="line">	ushort msg_qbytes; <span class="comment">/* 队列最大的字节数 */</span></span><br><span class="line">	ushort msg_lspid; <span class="comment">/* 发送最后一条消息的进程的`pid */</span></span><br><span class="line">	ushort msg_lrpid; <span class="comment">/* 接收最后一条消息的进程的`pid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="系统调用-msgget"><a href="#系统调用-msgget" class="headerlink" title="系统调用: msgget()"></a>系统调用: msgget()</h4><p>为了创建一个新的消息队列，或存取一个已经存在的队列，要使用<code>msgget()</code>系统调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgget</span> <span class="params">( <span class="type">key_t</span> key, <span class="type">int</span> msgflg )</span>;</span><br></pre></td></tr></table></figure></p>
<p>成功，则返回消息队列识别号，失败，则返回-1。</p>
<p><code>semget()</code>中的第一个参数是键值，这个键值要与现有的键值进行比较，现有的键值指在内核中已存在的其他消息队列的键值。对消息队列的打开或存取操作依赖于<code>msgflg</code>参数的取值。</p>
<ul>
<li><code>IPC_CREAT</code>：如果这个队列在内核中不存在，则创建它。</li>
<li><code>IPC_EXCL</code>：当与<code>IPC_CREAT</code>一起使用时，如果这个队列已存在，则创建失败。</li>
</ul>
<p>如果<code>IPC_CREAT</code>单独使用，<code>semget()</code>为一个新创建的消息队列返回标识号，或者返回具有相同键值的已存在队列的标识号。如果<code>IPC_EXCL</code>与<code>IPC_CREAT</code>一起使用，要么创建一个新的队列，要么对已存在的队列返回-1。<code>IPC_EXCL</code>不能单独使用，当与<code>IPC_CREAT</code>结合起来使用时，可以保证新创建队列的打开和存取。</p>
<p>与文件系统的存取权限一样，每一个<code>IPC</code>对象也具有存取权限，因此，可以把一个 8 进制与掩码或，形成对消息队列的存取权限。</p>
<p>下面我们来创建一个打开或创建消息队列的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_queue</span><span class="params">( <span class="type">key_t</span> keyval )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> qid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((qid = msgget( keyval, IPC_CREAT | <span class="number">0660</span> )) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(qid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这个例子显式地用了 0660 权限。这个函数要么返回一个消息队列的标识号，要么返回-1 而出错。键值作为唯一的参数必须传递给它。</p>
<h4 id="系统调用：msgsnd"><a href="#系统调用：msgsnd" class="headerlink" title="系统调用：msgsnd()"></a>系统调用：msgsnd()</h4><p>一旦我们有了队列识别号，我们就可以在这个队列上执行操作。要把一条消息传递给一个队列，必须用<code>msgsnd()</code>系统调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span> <span class="params">( <span class="type">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="type">int</span> msgsz, <span class="type">int</span> msgflg )</span>;</span><br></pre></td></tr></table></figure></p>
<p>返回：成功为 0， 失败为-1。</p>
<p><code>msgsnd()</code>的第 1 个参数是队列识别号，由<code>msgget()</code>调用返回。第 2 个参数<code>msgp</code>是一个指针，指向我们重新声明和装载的消息缓冲区。<code>msgsz</code>参数包含了消息以字节为单位的长度，其中包括了消息类型的 4 个字节。<code>msgflg</code>参数可以设置成 0(忽略)，或者设置或<code>IPC_NOWAIT</code>：如果消息队列满，消息不写到队列中，并且控制权返回给调用进程(继续执行)；如果不指定<code>IPC_NOWAIT</code>，调用进程将挂起(阻塞)直到消息被写到队列中。</p>
<p>下面我们来看一个发送消息的简单函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">send_message</span><span class="params">( <span class="type">int</span> qid, <span class="keyword">struct</span> mymsgbuf *qbuf )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result, length;</span><br><span class="line">	<span class="comment">/* mymsgbuf结构的实际长度 */</span></span><br><span class="line">	length = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ) - <span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">	<span class="keyword">if</span>((result = msgsnd( qid, qbuf, length, <span class="number">0</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个小函数试图把缓冲区<code>qbuf</code>中的消息，发送给队列识别号为<code>qid</code>的消息队列。 </p>
<p>现在，我们在消息队列里有了一条消息，可以用<code>ipcs</code>命令来看队列的状态。如何从消息队列检索消息，可以用<code>msgrcv()</code>系统调用。</p>
<h4 id="系统调用：msgrcv"><a href="#系统调用：msgrcv" class="headerlink" title="系统调用：msgrcv()"></a>系统调用：msgrcv()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgrcv</span> <span class="params">( <span class="type">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="type">int</span> msgsz, <span class="type">long</span> mtype, <span class="type">int</span> msgflg )</span>;</span><br></pre></td></tr></table></figure>
<p>成功，则返回拷贝到消息缓冲区的字节数，失败为-1。</p>
<p>很明显，第 1 个参数用来指定要检索的队列(必须由<code>msgget()</code>调用返回)，第 2 个参数(msgp)是存放检索到消息的缓冲区的地址，第 3 个参数(msgsz)是消息缓冲区的大小，包括消息类型的长度(4 字节)。第 4 个参数(mtype)指定了消息的类型。内核将搜索队列中相匹配类型的最早的消息，并且返回这个消息的一个拷贝，返回的消息放在由<code>msgp</code>参数指向的地址。这里存在一个特殊的情况，如果传递给<code>mytype</code>参数的值为 0，就可以不管类型，只返回队列中最早的消息。</p>
<p>如果传递给参数<code>msgflg</code>的值为<code>IPC_NOWAIT</code>，并且没有可取的消息，那么给调用进程返回<code>ENOMSG</code>错误消息，否则，调用进程阻塞，直到一条消息到达队列并且满足<code>msgrcv()</code>的参数。如果一个客户正在等待消息，而队列被删除，则返回<code>EIDRM</code>。如果当进程正在阻塞，并且等待一条消息到达但捕获到了一个信号，则返回<code>EINTR</code>。</p>
<p>下面我们来看一个从我们已建的消息队列中检索消息的例子<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read_message</span><span class="params">( <span class="type">int</span> qid, <span class="type">long</span> type, <span class="keyword">struct</span> mymsgbuf *qbuf )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result, length;</span><br><span class="line">	<span class="comment">/* 计算mymsgbuf结构的实际大小*/</span></span><br><span class="line">	length = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mymsgbuf) - <span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">	<span class="keyword">if</span>((result = msgrcv( qid, qbuf, length, type, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当从队列中成功地检索到消息后，这个消息将从队列中删除。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存可以被描述成内存一个区域(段)的映射，这个区域可以被更多的进程所共享。一旦内存被共享之后，对共享内存的访问同步需要由其他<code>IPC</code>机制，例如信号量来实现。像所有的<code>System V IPC</code>对象一样，<code>Linux</code>对共享内存的存取是通过对访问键和访问权限的检查来控制的。 </p>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>与消息队列和信号量集合类似，内核为每一个共享内存段(存在于它的地址空间)维护着一个特殊的数据结构<code>shmid_ds</code>，这个结构在<code>include/linux/shm.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在系统中每一个共享内存段都有一个shmid_ds数据结构. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span> <span class="comment">/* 操作权限 */</span></span><br><span class="line">	<span class="type">int</span> shm_segsz; <span class="comment">/* 段的大小(以字节为单位) */</span></span><br><span class="line">	<span class="type">time_t</span> shm_atime; <span class="comment">/* 最后一个进程附加到该段的时间 */</span></span><br><span class="line">	<span class="type">time_t</span> shm_dtime; <span class="comment">/* 最后一个进程离开该段的时间 */</span></span><br><span class="line">	<span class="type">time_t</span> shm_ctime; <span class="comment">/* 最后一次修改这个结构的时间 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> shm_cpid; <span class="comment">/*创建该段进程的pid */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> shm_lpid; <span class="comment">/* 在该段上操作的最后一个进程的`pid */</span></span><br><span class="line">	<span class="type">short</span> shm_nattch; <span class="comment">/*当前附加到该段的进程的个数 */</span></span><br><span class="line">	<span class="comment">/* 下面是私有的 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> shm_npages; <span class="comment">/*段的大小(以页为单位) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *shm_pages; <span class="comment">/* 指向frames -&gt; SHMMAX的指针数组 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">attaches</span>;</span> <span class="comment">/* 对共享段的描述 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们用图 7.4 来表示共享内存的数据结构<code>shmid_ds</code>与其他相关数据结构的关系。<br><img src="/img/1634004097.jpg" alt=""></p>
<h4 id="共享内存的处理过程"><a href="#共享内存的处理过程" class="headerlink" title="共享内存的处理过程"></a>共享内存的处理过程</h4><p>某个进程第 1 次访问共享虚拟内存时将产生缺页异常。这时，<code>Linux</code>找出描述该内存的<code>vm_area_struct</code>结构，该结构中包含用来处理这种共享虚拟内存段的处理函数地址。共享内存缺页异常处理代码对<code>shmid_ds</code>的页表项表进行搜索，以便查看是否存在该共享虚拟内存的页表项。如果没有，系统将分配一个物理页并建立页表项，该页表项加入<code>shmid_ds</code>结构的同时也添加到进程的页表中。这就意味着当下一个进程试图访问这页内存时出现缺页异常，共享内存的缺页异常处理代码则把新创建的物理页给这个进程。因此说，第 1 个进程对共享内存的存取引起创建新的物理页面，而其他进程对共享内存的存取引起把那个页添加到它们的地址空间。</p>
<p>当某个进程不再共享其虚拟内存时，利用系统调用将共享段从自己的虚拟地址区域中移去，并更新进程页表。当最后一个进程释放了共享段之后，系统将释放给共享段所分配的物理页。当共享的虚拟内存没有被锁定到物理内存时，共享内存也可能会被交换到交换区中。</p>
<h4 id="系统调用：shmget"><a href="#系统调用：shmget" class="headerlink" title="系统调用：shmget()"></a>系统调用：shmget()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span> <span class="params">( <span class="type">key_t</span> key, <span class="type">int</span> size, <span class="type">int</span> shmflg )</span>；</span><br></pre></td></tr></table></figure>
<p>成功，则返回共享内存段的识别号, 失败返回-1。</p>
<p><code>shmget()</code>系统调用类似于信号量和消息队列的系统调用，在此不进一步赘述。</p>
<h4 id="系统调用：shmat"><a href="#系统调用：shmat" class="headerlink" title="系统调用：shmat()"></a>系统调用：shmat()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> *shmaddr, <span class="type">int</span> shmflg)</span>；</span><br></pre></td></tr></table></figure>
<p>成功，则返回附加到进程的那个段的地址，失败返回-1。</p>
<p>其中<code>shmid</code>是由<code>shmget()</code>调用返回的共享内存段识别号，<code>shmaddr</code>是你希望共享段附加的地址，<code>shmflag</code>允许你规定希望所附加的段为只读(利用<code>SHM_RDONLY)</code>以代替读写。通常，并不需要规定你自己的<code>shmaddr</code>，可以用传递参数值零使得系统为你取得一个地址。</p>
<p>这个调用可能是最简单的，下面看一个例子，把一个有效的识别号传递给一个段，然后返回这个段被附加到内存的内存地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">attach_segment</span><span class="params">( <span class="type">int</span> shmid )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(shmat(shmid, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦一个段适当地被附加，并且一个进程有指向那个段起始地址的一个指针，那么，对那个段的读写就变得相当容易。</p>
<h4 id="系统调用：shmctl"><a href="#系统调用：shmctl" class="headerlink" title="系统调用：shmctl()"></a>系统调用：shmctl()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span> <span class="params">( <span class="type">int</span> shmqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf )</span>;</span><br></pre></td></tr></table></figure>
<p>成功返回 0 ，失败返回-1。</p>
<p>这个特殊的调用和<code>semctl()</code>调用几乎相同，因此，这里不进行详细的讨论。有效命令的值如下所述。</p>
<ul>
<li><code>IPC_STAT</code>：检索一个共享段的<code>shmid_ds</code>结构，把它存到<code>buf</code>参数的地址中。</li>
<li><code>IPC_SET</code>：对一个共享段来说，从<code>buf</code>参数中取值设置<code>shmid_ds</code>结构的<code>ipc_perm</code>域的值。</li>
<li><code>IPC_RMID</code>：把一个段标记为删除。</li>
<li><code>IPC_RMID</code>：命令实际上不从内核删除一个段，而是仅仅把这个段标记为删除，实际的删除发生在最后一个进程离开这个共享段时。</li>
</ul>
<p>当一个进程不再需要共享内存段时，它将调用<code>shmdt()</code>系统调用取消这个段，但是，这并不是从内核真正地删除这个段，而是把相关<code>shmid_ds</code>结构的<code>shm_nattch</code>域的值减 1，当这个值为 0 时，内核才从物理上删除这个共享段。 </p>
<h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟文件系统又称虚拟文件系统转换(Virual Filesystem Switch ，简称<code>VFS</code>)。说它虚拟，是因为它所有的数据结构都是在运行以后才建立，并在卸载时删除，而在磁盘上并没有存储这些数据结构。如果只有<code>VFS</code>，系统是无法工作的，因为它的这些数据结构不能凭空而来，只有与实际的文件系统，如<code>Ext2</code>、<code>Minix</code>、<code>MSDOS</code>、<code>VFAT</code>等相结合，才能开始工作，所以<code>VFS</code>并不是一个真正的文件系统。与<code>VFS</code>相对应，我们称<code>Ext2、Minix、MSDOS</code>等为具体文件系统。</p>
<h3 id="虚拟文件系统的作用"><a href="#虚拟文件系统的作用" class="headerlink" title="虚拟文件系统的作用"></a>虚拟文件系统的作用</h3><p>对具体文件系统来说，<code>VFS</code>是一个管理者，而对内核的其他子系统来说，<code>VFS</code>是它们与具体文件系统的一个接口。</p>
<p><code>VFS</code>提供一个统一的接口(实际上就是<code>file_operatoin</code>数据结构)，一个具体文件系统要想被<code>Linux</code>支持，就必须按照这个接口编写自己的操作函数，而将自己的细节对内核其他子系统隐藏起来。因而，对内核其他子系统以及运行在操作系统之上的用户程序而言，所有的文件系统都是一样的。实际上，要支持一个新的文件系统，主要任务就是编写这些接口函数。</p>
<p>概括说来，<code>VFS</code>主要有以下几个作用。</p>
<ol>
<li>对具体文件系统的数据结构进行抽象，以一种统一的数据结构进行管理。</li>
<li>接受用户层的系统调用，例如<code>write、open、stat、link</code>等。</li>
<li>支持多种具体文件系统之间相互访问。</li>
<li>接受内核其他子系统的操作请求，特别是内存管理子系统。 </li>
</ol>
<p>通过<code>VFS</code>，<code>Linux</code>可以支持很多种具体文件系统，表是<code>Linux</code>支持的部分具体文件系统。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件系统</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Minix Linux</code></td>
<td>最早支持的文件系统。主要缺点是最大<code>64MB</code>的磁盘分区和最长 14 个字符的文件名称的限制</td>
</tr>
<tr>
<td><code>Ext</code></td>
<td>第 1 个<code>Linux</code>专用的文件系统，支持<code>2GB</code>磁盘分区，255 字符的文件名称，但性能有问题</td>
</tr>
<tr>
<td><code>Xiafs</code></td>
<td>在<code>Minix</code>基础上发展起来，克服了<code>Minix</code>的主要缺点。但很快被更完善的文件系统取代</td>
</tr>
<tr>
<td><code>Ext2</code></td>
<td>当前实际上的<code>Linux</code>标准文件系统。性能强大，易扩充，可移植</td>
</tr>
<tr>
<td><code>Ext3</code></td>
<td>日志文件系统。Ext3 文件系统是对稳定的<code>Ext2</code>文件系统的改进</td>
</tr>
<tr>
<td><code>System V UNIX</code></td>
<td>早期支持的文件系统，也有与<code>Minix</code>同样的限制</td>
</tr>
<tr>
<td><code>NFS</code></td>
<td>网络文件系统。使得用户可以像访问本地文件一样访问远程主机上的文件</td>
</tr>
<tr>
<td><code>ISO 9660</code></td>
<td>光盘使用的文件系统</td>
</tr>
<tr>
<td><code>/proc</code></td>
<td>一个反映内核运行情况的虚的文件系统，并不实际存在于磁盘上</td>
</tr>
<tr>
<td><code>Msdos DOS</code></td>
<td>的文件系统，系统力图使它表现得像`UNIX</td>
</tr>
<tr>
<td><code>UMSDOS</code></td>
<td>该文件系统允许<code>MSDOS</code>文件系统可以当作<code>Linux</code>固有的文件系统一样使用</td>
</tr>
<tr>
<td><code>Vfat fat</code></td>
<td>文件系统的扩展，支持长文件名</td>
</tr>
<tr>
<td><code>Ntfs</code>Windows NT`</td>
<td>的文件系统</td>
</tr>
<tr>
<td><code>Hpfs</code></td>
<td><code>OS/2</code>的文件系统</td>
</tr>
</tbody>
</table>
</div>
<h3 id="VFS所处理的系统调用"><a href="#VFS所处理的系统调用" class="headerlink" title="VFS所处理的系统调用"></a>VFS所处理的系统调用</h3><p>表列出<code>VFS</code>的系统调用，这些系统调用涉及文件系统、常规文件、目录及符号链接。另外还有少数几个由<code>VFS</code>处理的其他系统调用：诸如<code>ioperm()</code>、<code>ioctl()</code>、<code>pipe()</code>和<code>mknod()</code>，涉及设备文件和管道文件。由<code>VFS</code>处理的最后一组系统调用，诸如<code>socket()</code>、<code>connect()</code>、<code>bind()</code>和<code>protocols()</code>，属于套接字系统调用并用于实现网络功能。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统调用名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mount()</code>/<code>umount()</code></td>
<td>安装/卸载文件系统</td>
</tr>
<tr>
<td><code>sysfs()</code></td>
<td>获取文件系统信息</td>
</tr>
<tr>
<td><code>statfs()</code>/<code>fstatfs()</code>/<code>ustat()</code></td>
<td>获取文件系统统计信息</td>
</tr>
<tr>
<td><code>chroot()</code></td>
<td>更改根目录</td>
</tr>
<tr>
<td><code>chdir()</code>/<code>fchdir()</code>/<code>getcwd()</code></td>
<td>更改当前目录</td>
</tr>
<tr>
<td><code>mkdir()</code>/<code>rmdir()</code></td>
<td>创建/删除目录</td>
</tr>
<tr>
<td><code>getdents()</code>/<code>readdir()</code>/<code>link()unlink()</code>/<code>rename()</code></td>
<td>对目录项进行操作</td>
</tr>
<tr>
<td><code>readlink()</code>/<code>symlink()</code></td>
<td>对软链接进行操作</td>
</tr>
<tr>
<td><code>chown()</code>/<code>fchown()</code>/<code>lchown()</code></td>
<td>更改文件所有者</td>
</tr>
<tr>
<td><code>chmod()</code>/<code>fchmod()</code>/<code>utime()</code></td>
<td>更改文件属性</td>
</tr>
<tr>
<td><code>stat()</code>/<code>fstat()</code>/<code>lstat()</code>/<code>access()</code></td>
<td>读取文件状态</td>
</tr>
<tr>
<td><code>open()</code>/<code>close()</code>/<code>creat()</code>/<code>umask()</code></td>
<td>打开/关闭文件</td>
</tr>
<tr>
<td><code>dup()</code>/<code>dup2()</code>/<code>fcntl()</code></td>
<td>对文件描述符进行操作</td>
</tr>
<tr>
<td><code>select()</code>/<code>poll()</code></td>
<td>异步<code>I/O</code>通信</td>
</tr>
<tr>
<td><code>truncate()</code>/<code>ftruncate()</code></td>
<td>更改文件长度</td>
</tr>
<tr>
<td><code>lseek()</code>/<code>_llseek()</code></td>
<td>更改文件指针</td>
</tr>
<tr>
<td><code>read()</code>/<code>write()</code>/<code>readv()</code>/<code>writev()</code>/<code>sendfile()</code></td>
<td>文件<code>I/O</code>操作</td>
</tr>
<tr>
<td><code>pread()</code>/<code>pwrite()</code></td>
<td>搜索并访问文件</td>
</tr>
<tr>
<td><code>mmap()</code>/<code>munmap()</code></td>
<td>文件内存映射</td>
</tr>
<tr>
<td><code>fdatasync()</code>/<code>fsync()</code>/<code>sync()</code>/<code>msync()</code></td>
<td>同步访问文件数据</td>
</tr>
<tr>
<td><code>flock()</code></td>
<td>处理文件锁</td>
</tr>
</tbody>
</table>
</div>
<h2 id="VFS中的数据结构"><a href="#VFS中的数据结构" class="headerlink" title="VFS中的数据结构"></a>VFS中的数据结构</h2><p>你可以把通用文件模型看作是面向对象的，在这里，对象是一个软件结构，其中既定义了数据结构也定义了其上的操作方法。出于效率的考虑，<code>Linux</code>的编码并未采用面向对象的程序设计语言(比如C++)。因此对象作为数据结构来实现：数据结构中指向函数的域就对应于对象的方法。</p>
<p>通用文件模型由下列对象类型组成。</p>
<ul>
<li>超级块(superblock)对象：存放系统中已安装文件系统的有关信息。每个文件系统都有一个超级块对象。</li>
<li>索引节点(inode)对象：存放关于具体文件的一般信息。对于基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的文件控制块(FCB)，也就是说，每个文件都有一个索引节点对象。每个索引节点对象都有一个索引节点号，这个号唯一地标识某个文件系统中的指定文件。</li>
<li>目录项(dentry)对象：存放目录项与对应文件进行链接的信息。<code>VFS</code>把每个目录看作一个由若干子目录和文件组成的常规文件。例如，在查找路径名<code>/tmp/test</code>时，内核为根目录<code>/</code>创建一个目录项对象，为根目录下的<code>tmp</code>项创建一个第 2 级目录项对象，为<code>/tmp</code>目录下的<code>test</code>项创建一个第 3 级目录项对象。</li>
<li>文件(file)对象：存放打开文件与进程之间进行交互的有关信息。这类信息仅当进程访问文件期间存在于内存中。</li>
</ul>
<p>下面我们讨论超级块、索引节点、目录项及文件的数据结构，它们的共同特点有两个：</p>
<ul>
<li>充分考虑到对多种具体文件系统的兼容性；</li>
<li>是“虚”的，也就是说只能存在于内存。</li>
</ul>
<p>这正体现了<code>VFS</code>的特点，在下面的描述中，读者也许能体会到以上特点。</p>
<h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><p><code>VFS</code>超级块是各种具体文件系统在安装时建立的，并在这些文件系统卸载时自动删除，可见，<code>VFS</code>超级块确实只存在于内存中，同时提到<code>VFS</code>超级块也应该说成是哪个具体文件系统的<code>VFS</code>超级块。<code>VFS</code>超级块在<code>inculde/fs/fs.h</code>中定义，即数据结构<code>super_block</code>，该结构及其主要域的含义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/************描述具体文件系统的整体信息的域*****************</span></span><br><span class="line"><span class="comment">	kdev_t s_dev; /* 包含该具体文件系统的块设备标识符。例如，对于 /dev/hda1，其设备标识符为 0x301 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_blocksize; <span class="comment">/*该具体文件系统中数据块的大小，以字节为单位 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_blocksize_bits; <span class="comment">/*块大小的值占用的位数，例如，如果块大小为 1024 字节，则该值为 10*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> s_maxbytes; <span class="comment">/* 文件的最大长度 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_flags; <span class="comment">/* 安装标志*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_magic; <span class="comment">/*魔数，即该具体文件系统区别于其他文件系统的一个标志*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**************用于管理超级块的域******************/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_list</span>;</span> <span class="comment">/*指向超级块链表的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">s_lock</span> /*锁标志位，若置该位，则其他进程不能对该超级块操作*/</span></span><br><span class="line"><span class="class">	<span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">s_umount</span> /*对超级块读写时进行同步*/</span></span><br><span class="line"><span class="class">	<span class="title">unsigned</span> <span class="title">char</span> <span class="title">s_dirt</span>;</span> <span class="comment">/*脏位，若置该位，表明该超级块已被修改*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">s_root</span>;</span> <span class="comment">/*指向该具体文件系统安装目录的目录项*/</span></span><br><span class="line">	<span class="type">int</span> s_count; <span class="comment">/*对超级块的使用计数*/</span></span><br><span class="line">	<span class="type">atomic_t</span> s_active;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_dirty</span>;</span> <span class="comment">/*已修改的索引节点形成的链表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_locked_inodes</span>;</span><span class="comment">/* 要进行同步的索引节点形成的链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_files</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">	/***********和具体文件系统相联系的域*************************/</span></span><br><span class="line"><span class="class">	<span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">s_type</span>;</span> <span class="comment">/*指向文件系统的file_system_type数据结构的指针 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> *<span class="title">s_op</span>;</span> <span class="comment">/*指向某个特定的具体文件系统的用于超级块操作的函数集合 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span> *<span class="title">dq_op</span>;</span> <span class="comment">/* 指向某个特定的具体文件系统用于限额操作的函数集合 */</span></span><br><span class="line">	u; <span class="comment">/*一个共用体，其成员是各种文件系统的fsname_sb_info数据结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>所有超级块对象(每个已安装的文件系统都有一个超级块)以双向环形链表的形式链接在一起。链表中第一个元素和最后一个元素的地址分别存放在<code>super_blocks</code>变量的<code>s_list</code>域的<code>next</code>和<code>prev</code>域中。<code>s_list</code>域的数据类型为<code>struct list_head</code>，在超级块的<code>s_dirty</code>域以及内核的其他很多地方都可以找到这样的数据类型；这种数据类型仅仅包括指向链表中的前一个元素和后一个元素的指针。因此，超级块对象的<code>s_list</code>域包含指向链表中两个相邻超级块对象的指针。图 8.2 说明了<code>list_head</code>元素、<code>next</code>和<code>prev</code>是如何嵌入到超级块对象中的。<br><img src="/img/1634005281.jpg" alt=""></p>
<p>超级块最后一个<code>u</code>联合体域包括属于具体文件系统的超级块信息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Minix_sb_info</span> <span class="title">Minix_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Ext2_sb_info</span> <span class="title">Ext2_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext3_sb_info</span> <span class="title">ext3_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hpfs_sb_info</span> <span class="title">hpfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ntfs_sb_info</span> <span class="title">ntfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msdos_sb_info</span> <span class="title">msdos_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isofs_sb_info</span> <span class="title">isofs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nfs_sb_info</span> <span class="title">nfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_sb_info</span> <span class="title">sysv_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">affs_sb_info</span> <span class="title">affs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ufs_sb_info</span> <span class="title">ufs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">efs_sb_info</span> <span class="title">efs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">shmem_sb_info</span> <span class="title">shmem_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">romfs_sb_info</span> <span class="title">romfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">smb_sb_info</span> <span class="title">smbfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hfs_sb_info</span> <span class="title">hfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">adfs_sb_info</span> <span class="title">adfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qnx4_sb_info</span> <span class="title">qnx4_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reiserfs_sb_info</span> <span class="title">reiserfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bfs_sb_info</span> <span class="title">bfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">udf_sb_info</span> <span class="title">udf_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ncp_sb_info</span> <span class="title">ncpfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usbdev_sb_info</span> <span class="title">usbdevfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">jffs2_sb_info</span> <span class="title">jffs2_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cramfs_sb_info</span> <span class="title">cramfs_sb</span>;</span></span><br><span class="line">	<span class="type">void</span> *generic_sbp;</span><br><span class="line">&#125; u;</span><br></pre></td></tr></table></figure></p>
<p>通常，为了效率起见<code>u</code>域的数据被复制到内存。任何基于磁盘的文件系统都需要访问和更改自己的磁盘分配位示图，以便分配和释放磁盘块。<code>VFS</code>允许这些文件系统直接对内存超级块的<code>u</code>联合体域进行操作，无需访问磁盘。</p>
<p>但是，这种方法带来一个新问题：有可能<code>VFS</code>超级块最终不再与磁盘上相应的超级块同步。因此，有必要引入一个<code>s_dirt</code>标志，来表示该超级块是否是脏的。<code>Linux</code>是通过周期性地将所有“脏”的超级块写回磁盘来减少该问题带来的危害。</p>
<p>与超级块关联的方法就是所谓的超级块操作。这些操作是由数据结构<code>super_operations</code>来描述的，该结构的起始地址存放在超级块的<code>s_op</code>域中。</p>
<h3 id="VFS的索引节点"><a href="#VFS的索引节点" class="headerlink" title="VFS的索引节点"></a>VFS的索引节点</h3><p>具体文件系统的索引节点是存储在磁盘上的，是一种静态结构，要使用它，必须调入内存，填写<code>VFS</code>的索引节点，因此，也称<code>VFS</code>索引节点为动态节点。<code>VFS</code>索引节点的数据结构<code>inode</code>在<code>/includ/fs/fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/**********描述索引节点高速缓存管理的域****************/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_hash</span>;</span> <span class="comment">/*指向哈希链表的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_list</span>;</span> <span class="comment">/*指向索引节点链表的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_dentry</span>;</span><span class="comment">/*指向目录项链表的指针*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_dirty_buffers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_dirty_data_buffers</span>;</span></span><br><span class="line">	<span class="comment">/**********描述文件信息的域****************/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_ino; <span class="comment">/*索引节点号*/</span></span><br><span class="line">	<span class="type">kdev_t</span> i_dev; <span class="comment">/*设备标识号 */</span></span><br><span class="line">	<span class="type">umode_t</span> i_mode; <span class="comment">/*文件的类型与访问权限 */</span></span><br><span class="line">	<span class="type">nlink_t</span> i_nlink; <span class="comment">/*与该节点建立链接的文件数 */</span></span><br><span class="line">	<span class="type">uid_t</span> i_uid; <span class="comment">/*文件拥有者标识号*/</span></span><br><span class="line">	<span class="type">gid_t</span> i_gid; <span class="comment">/*文件拥有者所在组的标识号*/</span></span><br><span class="line">	<span class="type">kdev_t</span> i_rdev; <span class="comment">/*实际设备标识号*/</span></span><br><span class="line">	<span class="type">off_t</span> i_size; <span class="comment">/*文件的大小(以字节为单位)*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_blksize; <span class="comment">/*块大小*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_blocks; <span class="comment">/*该文件所占块数*/</span></span><br><span class="line">	<span class="type">time_t</span> i_atime; <span class="comment">/*文件的最后访问时间*/</span></span><br><span class="line">	<span class="type">time_t</span> i_mtime; <span class="comment">/*文件的最后修改时间*/</span></span><br><span class="line">	<span class="type">time_t</span> i_ctime; <span class="comment">/*节点的修改时间*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_version; <span class="comment">/*版本号*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">i_zombie</span>;</span> <span class="comment">/*僵死索引节点的信号量*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/***********用于索引节点操作的域*****************/</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">i_op</span>;</span> <span class="comment">/*索引节点的操作*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">i_sb</span>;</span> <span class="comment">/*指向该文件系统超级块的指针 */</span></span><br><span class="line">	<span class="type">atomic_t</span> i_count; <span class="comment">/*当前使用该节点的进程数。计数为 0，表明该节点可丢弃或被重新使用 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">i_fop</span>;</span> <span class="comment">/*指向文件操作的指针 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_lock; <span class="comment">/*该节点是否被锁定，用于同步操作中*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">i_sem</span>;</span> <span class="comment">/*指向用于同步操作的信号量结构*/</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> *i_wait; <span class="comment">/*指向索引节点等待队列的指针*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_dirt; <span class="comment">/*表明该节点是否被修改过，若已被修改，则应当将该节点写回磁盘*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_lock</span> *<span class="title">i_flock</span>;</span> <span class="comment">/*指向文件加锁链表的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dquot</span> *<span class="title">i_dquot</span>[<span class="title">MAXQUOTAS</span>];</span> <span class="comment">/*索引节点的磁盘限额*/</span></span><br><span class="line">	<span class="comment">/************用于分页机制的域**********************************/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">i_mapping</span>;</span> <span class="comment">/* 把所有可交换的页面管理起来*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> <span class="title">i_data</span>;</span></span><br><span class="line">	<span class="comment">/**********以下几个域应当是联合体****************************************/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_devices</span>;</span> <span class="comment">/*设备文件形成的链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> <span class="title">i_pipe</span>;</span> <span class="comment">/*指向管道文件*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span> <span class="comment">/*指向块设备文件的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">char_device</span> *<span class="title">i_cdev</span>;</span> <span class="comment">/*指向字符设备文件的指针*/</span></span><br><span class="line">	<span class="comment">/*************************其他域***************************************/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_dnotify_mask; <span class="comment">/* Directory notify events */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dnotify_struct</span> *<span class="title">i_dnotify</span>;</span> <span class="comment">/* for directory notifications */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_state; <span class="comment">/*索引节点的状态标志*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i_flags; <span class="comment">/*文件系统的安装标志*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_sock; <span class="comment">/*如果是套接字文件则为真*/</span></span><br><span class="line">	<span class="type">atomic_t</span> i_writecount; <span class="comment">/*写进程的引用计数*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i_attr_flags; <span class="comment">/*文件创建标志*/</span></span><br><span class="line">	__u32 i_generation <span class="comment">/*为以后的开发保留*/</span></span><br><span class="line">	<span class="comment">/*************************各个具体文件系统的索引节点********************/</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span>;</span> <span class="comment">/*类似于超级块的一个共用体，其成员是各种具体文件系统的fsname_inode_info数据结构 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对<code>inode</code>数据结构的进一步说明。</p>
<ul>
<li>每个文件都有一个<code>inode</code>，每个<code>inode</code>有一个索引节点号<code>i_ino</code>。在同一个文件系统中，每个索引节点号都是唯一的，内核有时根据索引节点号的哈希值查找其<code>inode</code>结构。</li>
<li>每个文件都有个文件主，其最初的文件主是创建了这个文件的用户，但以后可以改变。</li>
<li>每个用户都有一个用户组，且属于某个用户组，因此，<code>inode</code>结构中就有相应的<code>i_uid</code>、<code>i_gid</code>以指明文件主的身份。</li>
<li><code>inode</code>中有两个设备号，<code>i_dev</code>和<code>i_rdev</code>。首先，除特殊文件外，每个节点都存储在某个设备上，这就是<code>i_dev</code>。其次，如果索引节点所代表的并不是常规文件，而是某个设备，那就还得有个设备号，这就是<code>i_rdev</code>。</li>
<li>每当一个文件被访问时，系统都要在这个文件的<code>inode</code>中记下时间标记，这就是<code>inode</code>中与时间相关的几个域。</li>
<li>每个索引节点都会复制磁盘索引节点包含的一些数据，比如文件占用的磁盘块数。如果<code>i_state</code>域的值等于<code>I_DIRTY</code>，该索引节点就是“脏”的，也就是说，对应的磁盘索引节点必须被更新。<code>i_state</code>域的其他值有<code>I_LOCK</code>(这意味着该索引节点对象已加锁)，<code>I_FREEING</code>(这意味着该索引节点对象正在被释放)。每个索引节点对象总是出现在下列循环双向链表的某个链表中。<ul>
<li>未用索引节点链表。变量<code>inode_unused</code>的<code>next</code>域和<code>prev</code>域分别指向该链表中的首元素和尾元素。这个链表用做内存高速缓存。</li>
<li>正在使用索引节点链表。变量<code>inode_in_use</code>指向该链表中的首元素和尾元素。</li>
<li>脏索引节点链表。由相应超级块的<code>s_dirty</code>域指向该链表中的首元素和尾元素。</li>
<li>这 3 个链表都是通过索引节点的<code>i_list</code>域链接在一起的。</li>
</ul>
</li>
<li>属于“正在使用”或“脏”链表的索引节点对象也同时存放在一个称为<code>inode_hashtable</code>链表中。哈希表加快了对索引节点对象的搜索，前提是系统内核要知道索引节点号及对应文件所在文件系统的超级块对象的地址。由于散列技术可能引发冲突，所以，索引节点对象设置一个<code>i_hash</code>域，其中包含向前和向后的两个指针，分别指向散列到同一地址的前一个索引节点和后一个索引节点；该域由此创建了由这些索引节点组成的一个双向链<br>表。</li>
</ul>
<p>与索引节点关联的方法也叫索引节点操作，由<code>inode_operations</code>结构来描述，该结构的地址存放在<code>i_op</code>域中，该结构也包括一个指向文件操作方法的指针。</p>
<h3 id="目录项对象"><a href="#目录项对象" class="headerlink" title="目录项对象"></a>目录项对象</h3><p>每个文件除了有一个索引节点<code>inode</code>数据结构外，还有一个目录项<code>dentry</code>(directory enrty)数据结构。<code>dentry</code>结构中有个<code>d_inode</code>指针指向相应的<code>inode</code>结构。二者所描述的目标不同，<code>dentry</code>结构代表的是逻辑意义上的文件，所描述的是文件逻辑上的属性，因此，目录项对象在磁盘上并没有对应的映像；而<code>inode</code>结构代表的是物理意义上的文件，记录的是物理上的属性，对于一个具体的文件系统(如<code>Ext2</code>)，<code>Ext2_inode</code>结构在磁盘上就有对应的映像。所以说，一个索引节点对象可能对应多个目录项对象。</p>
<p><code>dentry</code>的定义在<code>include/linux/dcache.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> d_count; <span class="comment">/* 目录项引用计数器 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> d_flags; <span class="comment">/* 目录项标志 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">d_inode</span>;</span> <span class="comment">/* 与文件名关联的索引节点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * <span class="title">d_parent</span>;</span> <span class="comment">/* 父目录的目录项 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_hash</span>;</span> <span class="comment">/* 目录项形成的哈希表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span> <span class="comment">/*未使用的LRU链表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span> <span class="comment">/*父目录的子目录项所形成的链表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span> <span class="comment">/* 该目录项的子目录所形成的链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_alias</span>;</span> <span class="comment">/* 索引节点别名的链表*/</span> </span><br><span class="line">	<span class="type">int</span> d_mounted; <span class="comment">/* 目录项的安装点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span> <span class="comment">/* 目录项名(可快速查找) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> d_time; <span class="comment">/* 由d_revalidate函数使用 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span> <span class="comment">/* 目录项的函数集*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">d_sb</span>;</span> <span class="comment">/* 目录项树的根 (即文件的超级块)*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> d_vfs_flags;</span><br><span class="line">	<span class="type">void</span> * d_fsdata; <span class="comment">/* 具体文件系统的数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> d_iname[DNAME_INLINE_LEN]; <span class="comment">/* 短文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一个有效的<code>dentry</code>结构必定有一个<code>inode</code>结构，这是因为一个目录项要么代表着一个文件，要么代表着一个目录，而目录实际上也是文件。所以，只要<code>dentry</code>结构是有效的，则其指针<code>d_inode</code>必定指向一个<code>inode</code>结构。可是，反过来则不然，一个<code>inode</code>却可能对应着不止一个<code>dentry</code>结构；也就是说，一个文件可以有不止一个文件名或路径名。这是因为一个已经建立的文件可以被连接(link)到其他文件名。所以在<code>inode</code>结构中有一个队列<code>i_dentry</code>，凡是代表着同一个文件的所有目录项都通过其<code>dentry</code>结构中的<code>d_alias</code>域挂入相应<code>inode</code>结构中的<code>i_dentry</code>队列。</p>
<p>在内核中有一个哈希表<code>dentry_hashtable</code>，是一个<code>list_head</code>的指针数组。一旦在内存中建立起一个目录节点的<code>dentry</code>结构，该<code>dentry</code>结构就通过其<code>d_hash</code>域链入哈希表中的某个队列中。</p>
<p>内核中还有一个队列<code>dentry_unused</code>，凡是已经没有用户(<code>count</code>域为 0)使用的<code>dentry</code>结构就通过其<code>d_lru</code>域挂入这个队列。<code>dentry</code>结构中除了<code>d_alias</code>、<code>d_hash</code>、<code>d_lru</code>三个队列外，还有<code>d_vfsmnt</code>、<code>d_child</code>及<code>d_subdir</code>三个队列。其中<code>d_vfsmnt</code>仅在该<code>dentry</code>为一个安装点时才使用。另外，当该目录节点有父目录时，则其<code>dentry</code>结构就通过<code>d_child</code>挂入其父节点的<code>d_subdirs</code>队列中，同时又通过指针<code>d_parent</code>指向其父目录的<code>dentry</code>结构，而它自己各个子目录的<code>dentry</code>结构则挂在其<code>d_subdirs</code>域指向的队列中。</p>
<p>从上面的叙述可以看出，一个文件系统中所有目录项结构或组织为一个哈希表，或组织为一颗树，或按照某种需要组织为一个链表，这将为文件访问和文件路径搜索奠定下良好的基础。</p>
<h3 id="与进程相关的文件结构"><a href="#与进程相关的文件结构" class="headerlink" title="与进程相关的文件结构"></a>与进程相关的文件结构</h3><h4 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h4><p>在<code>Linux</code>中，进程是通过文件描述符(file descriptors，简称<code>fd</code>)而不是文件名来访问文件的，文件描述符实际上是一个整数。<code>Linux</code>中规定每个进程最多能同时使用<code>NR_OPEN</code>个文件描述符，这个值在<code>fs.h</code>中定义，为 1024×1024(2.0 版中仅定义为 256)。每个文件都有一个 32 位的数字来表示下一个读写的字节位置，这个数字叫做文件位置。</p>
<p>每次打开一个文件，除非明确要求，否则文件位置都被置为 0，即文件的开始处，此后的读或写操作都将从文件的开始处执行，但你可以通过执行系统调用<code>LSEEK</code>(随机存储)对这个文件位置进行修改。<code>Linux</code>中专门用了一个数据结构<code>file</code>来保存打开文件的文件位置，这个结构称为打开的文件描述(open file description)。</p>
<p>我们知道，<code>Linux</code>中的文件是能够共享的，假如把文件位置存放在索引节点中，则如果有两个或更多个进程同时打开同一个文件时，它们将去访问同一个索引节点，于是一个进程的<code>LSEEK</code>操作将影响到另一个进程的读操作，这显然是不允许也是不可想象的。</p>
<p>另一个想法是既然进程是通过文件描述符访问文件的，为什么不用一个与文件描述符数组相平行的数组来保存每个打开文件的文件位置？这个想法也是不能实现的，原因就在于在生成一个新进程时，子进程要共享父进程的所有信息，包括文件描述符数组。</p>
<p><code>file</code>结构中主要保存了文件位置，此外，还把指向该文件索引节点的指针也放在其中。<code>file</code>结构形成一个双链表，称为系统打开文件表，其最大长度是<code>NR_FILE</code>，在<code>fs.h</code>中定义为8192。</p>
<p><code>file</code>结构在<code>include\linux\fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">f_list</span>;</span> <span class="comment">/*所有打开的文件形成一个链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">f_dentry</span>;</span> <span class="comment">/*指向相关目录项的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">f_vfsmnt</span>;</span> <span class="comment">/*指向VFS安装点的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span> <span class="comment">/*指向文件操作表的指针*/</span></span><br><span class="line">	<span class="type">mode_t</span> f_mode; <span class="comment">/*文件的打开模式*/</span></span><br><span class="line">	<span class="type">loff_t</span> f_pos; <span class="comment">/*文件的当前位置*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_flags; <span class="comment">/*打开文件时所指定的标志*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_count; <span class="comment">/*使用该结构的进程数*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> f_reada, f_ramax, f_raend, f_ralen, f_rawin;</span><br><span class="line">	<span class="comment">/*预读标志、要预读的最多页面数、上次预读后的文件指针、预读的字节数以及预读的页面数*/</span></span><br><span class="line">	<span class="type">int</span> f_owner; <span class="comment">/* 通过信号进行异步I/O数据的传送*/</span> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> f_uid, f_gid; <span class="comment">/*用户的UID和GID*/</span></span><br><span class="line">	<span class="type">int</span> f_error; <span class="comment">/*网络写操作的错误码*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> f_version; <span class="comment">/*版本号*/</span></span><br><span class="line">	<span class="type">void</span> *private_data; <span class="comment">/* tty`驱动程序所需 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每个文件对象总是包含在下列的一个双向循环链表之中。</p>
<ul>
<li>“未使用”文件对象的链表。该链表既可以用做文件对象的内存高速缓存，又可以当作超级用户的备用存储器，也就是说，即使系统的动态内存用完，也允许超级用户打开文件。由于这些对象是未使用的，它们的<code>f_count</code>域是<code>NULL</code>，该链表首元素的地址存放在变量<code>free_list</code>中，内核必须确认该链表总是至少包含<code>NR_RESERVED_FILES</code>个对象，通常该值设为 10。</li>
<li>“正在使用”文件对象的链表。该链表中的每个元素至少由一个进程使用，因此，各个元素的<code>f_count</code>域不会为<code>NULL</code>，该链表中第一个元素的地址存放在变量<code>anon_list</code>中。</li>
</ul>
<p>如果<code>VFS</code>需要分配一个新的文件对象，就调用函数<code>get_empty_filp()</code>。该函数检测“未使用”文件对象链表的元素个数是否多于<code>NR_RESERVED_FILES</code>，如果是，可以为新打开的文件使用其中的一个元素；如果没有，则退回到正常的内存分配。</p>
<h4 id="用户打开文件表"><a href="#用户打开文件表" class="headerlink" title="用户打开文件表"></a>用户打开文件表</h4><p>每个进程用一个<code>files_struct</code>结构来记录文件描述符的使用情况，这个<code>files_struct</code>结构称为用户打开文件表，它是进程的私有数据。<code>files_struct</code>结构在<code>include/linux/sched.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> count; <span class="comment">/* 共享该表的进程数 */</span></span><br><span class="line">	<span class="type">rwlock_t</span> file_lock; <span class="comment">/* 保护以下的所有域,以免在tsk-&gt;alloc_lock中的嵌套*/</span></span><br><span class="line">	<span class="type">int</span> max_fds; <span class="comment">/* 当前文件对象的最大数 */</span></span><br><span class="line">	<span class="type">int</span> max_fdset; <span class="comment">/* 当前文件描述符的最大数 */</span></span><br><span class="line">	<span class="type">int</span> next_fd; <span class="comment">/* 已分配的文件描述符加 1 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> ** <span class="title">fd</span>;</span> <span class="comment">/* 指向文件对象指针数组的指针 */</span></span><br><span class="line">	fd_set *close_on_exec; <span class="comment">/*指向执行`exec()`时需要关闭的文件描述符*/</span></span><br><span class="line">	fd_set *open_fds; <span class="comment">/*指向打开文件描述符的指针*/</span></span><br><span class="line">	fd_set close_on_exec_init;<span class="comment">/* 执行`exec()`时需要关闭的文件描述符的初值集合*/</span></span><br><span class="line">	fd_set open_fds_init; <span class="comment">/*文件描述符的初值集合*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">fd_array</span>[32];</span><span class="comment">/* 文件对象指针的初始化数组*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>fd</code>域指向文件对象的指针数组。该数组的长度存放在<code>max_fds</code>域中。通常，<code>fd</code>域指向<code>files_struct</code>结构的<code>fd_array</code>域，该域包括 32 个文件对象指针。如果进程打开的文件数目多于 32，内核就分配一个新的、更大的文件指针数组，并将其地址存放在<code>fd</code>域中；内核同时也更新<code>max_fds</code>域的值。</p>
<p>对于在<code>fd</code>数组中有入口地址的每个文件来说，数组的索引就是文件描述符(file descriptor)。通常，数组的第 1 个元素(索引为 0)是进程的标准输入文件，数组的第 2 个元素(索引为 1)是进程的标准输出文件，数组的第 3 个元素(索引为 2)是进程的标准错误文件。请注意，借助于<code>dup()、dup2()</code>和<code>fcntl()</code>系统调用，两个文件描述符就可以指向同一个打开的文件，也就是说，数组的两个元素可能指向同一个文件对象。</p>
<p><code>open_fds</code>域包含<code>open_fds_init</code>域的地址，<code>open_fds_init</code>域表示当前已打开文件的文件描述符的位图。<code>max_fdset</code>域存放位图中的位数。由于数据结构<code>fd_set</code>有 1024 位，通常不需要扩大位图的大小。不过，如果确实需要，内核仍能动态增加位图的大小，这非常类似文件对象的数组的情形。</p>
<p>当开始使用一个文件对象时调用内核提供的<code>fget()</code>函数。这个函数接收文件描述符<code>fd</code>作为参数，返回在<code>current-&gt;files-&gt;fd[fd]</code>中的地址，即对应文件对象的地址，如果没有任何文件与<code>fd</code>对应，则返回<code>NULL</code>。在第 1 种情况下，<code>fget()</code>使文件对象引用计数器<code>f_count</code>的值增 1。</p>
<p>当内核完成对文件对象的使用时，调用内核提供的<code>fput()</code>函数。该函数将文件对象的地址作为参数，并递减文件对象引用计数器<code>f_count</code>的值，另外，如果这个域变为<code>NULL</code>，该函数就调用文件操作的“释放”方法(如果已定义)，释放相应的目录项对象，并递减对应索引节点对象的<code>i_writeaccess</code>域的值(如果该文件是写打开)，最后，将该文件对象从“正在使用”链表移到“未使用”链表。</p>
<h4 id="关于文件系统信息的fs-struct结构"><a href="#关于文件系统信息的fs-struct结构" class="headerlink" title="关于文件系统信息的fs_struct结构"></a>关于文件系统信息的fs_struct结构</h4><p><code>fs_struct</code>结构在 2.4 以前的版本中在<code>include/linux/sched.h</code>中定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="type">int</span> umask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * <span class="title">root</span>, * <span class="title">pwd</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在 2.4 版本中，单独定义在<code>include/linux/fs_struct.h</code>中:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="type">rwlock_t</span> lock;</span><br><span class="line">	<span class="type">int</span> umask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * <span class="title">root</span>, * <span class="title">pwd</span>, * <span class="title">altroot</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> * <span class="title">rootmnt</span>, * <span class="title">pwdmnt</span>, * <span class="title">altrootmnt</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>count</code>域表示共享同一<code>fs_struct</code>表的进程数目。<code>umask</code>域由<code>umask()</code>系统调用使用，用于为新创建的文件设置初始文件许可权。</p>
<p><code>fs_struct</code>中的<code>dentry</code>结构是对一个目录项的描述，<code>root</code>、<code>pwd</code>及<code>altroot</code>三个指针都指向这个结构。其中，<code>root</code>所指向的<code>dentry</code>结构代表着本进程所在的根目录，也就是在用户登录进入系统时所看到的根目录；<code>pwd</code>指向进程当前所在的目录；而<code>altroot</code>则是为用户设置的替换根目录。实际运行时，这 3 个目录不一定都在同一个文件系统中。例如，进程的根目录通常是安装于<code>/</code>节点上的<code>Ext2</code>文件系统，而当前工作目录可能是安装于<code>/msdos</code>的一个<code>DOS</code>文件系统。因此，<code>fs_struct</code>结构中的<code>rootmnt</code>、<code>pwdmnt</code>及<code>altrootmnt</code>就是对那 3 个目录的安装点的描述，安装点的数据结构为<code>vfsmount</code>。</p>
<h3 id="主要数据结构间的关系"><a href="#主要数据结构间的关系" class="headerlink" title="主要数据结构间的关系"></a>主要数据结构间的关系</h3><p>超级块是对一个文件系统的描述；索引节点是对一个文件物理属性的描述；而目录项是对一个文件逻辑属性的描述。除此之外，文件与进程之间的关系是由另外的数据结构来描述的。一个进程所处的位置是由<code>fs_struct</code>来描述的，而一个进程(或用户)打开的文件是由<code>files_struct</code>来描述的，而整个系统所打开的文件是由<code>file</code>结构来描述。如图 8.4 给出了这些数据结构之间的关系。<br><img src="/img/1634010838.jpg" alt=""></p>
<h3 id="有关操作的数据结构"><a href="#有关操作的数据结构" class="headerlink" title="有关操作的数据结构"></a>有关操作的数据结构</h3><p>各种<code>Linux</code>支持的具体文件系统都有一套自己的操作函数，在安装时，这些结构体的成员指针将被初始化，指向对应的函数。如果说<code>VFS</code>体现了<code>Linux</code>的优越性，那么这些数据结构的设计就体现了<code>VFS</code>的优越性所在。</p>
<h4 id="超级块操作"><a href="#超级块操作" class="headerlink" title="超级块操作"></a>超级块操作</h4><p>超级块操作是由<code>super_operations</code>数据结构来描述的，该结构的起始地址存放在超级块的<code>s_op</code>域中。该结构定义于<code>fs.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* <span class="doctag">NOTE:</span> write_inode, delete_inode, clear_inode, put_inode can be called</span></span><br><span class="line"><span class="comment">* without the big kernel lock held in all filesystems.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*read_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">void</span> (*read_inode2) (<span class="keyword">struct</span> inode *, <span class="type">void</span> *) ;</span><br><span class="line">	<span class="type">void</span> (*dirty_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">void</span> (*write_inode) (<span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">void</span> (*put_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">void</span> (*delete_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">void</span> (*put_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="type">void</span> (*write_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="type">void</span> (*write_super_lockfs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="type">void</span> (*unlockfs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="type">int</span> (*statfs) (<span class="keyword">struct</span> super_block *, <span class="keyword">struct</span> statfs *);</span><br><span class="line">	<span class="type">int</span> (*remount_fs) (<span class="keyword">struct</span> super_block *, <span class="type">int</span> *, <span class="type">char</span> *);</span><br><span class="line">	<span class="type">void</span> (*clear_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">void</span> (*umount_begin) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的每个函数就叫做超级块的一个方法，表给予描述。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数形式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Read_inode(inode)</code></td>
<td><code>inode</code>的地址是该函数的参数，<code>inode</code>中的<code>i_no</code>域表示从磁盘要读取的具体文件系统的<code>inode</code>，用磁盘上的数据填充参数<code>inode</code>的域</td>
</tr>
<tr>
<td><code>Dirty_inode(inode)</code></td>
<td>把<code>inode</code>标记为“脏”</td>
</tr>
<tr>
<td><code>Write_inode(inode)</code></td>
<td>用参数指定的<code>inode</code>更新某个文件系统的<code>inode。inode</code>的<code>i_ino</code>域标识指定磁盘上文件系统的索引节点</td>
</tr>
<tr>
<td><code>Put_inode(inode)</code></td>
<td>释放参数指定的索引节点对象。释放一个对象并不意味着释放内存，因为其他进程可能仍然在使用这个对象。该方法是可选的</td>
</tr>
<tr>
<td><code>Delete_inode(inode)</code></td>
<td>删除那些包含文件、磁盘索引节点及<code>VFS</code>索引节点的数据块</td>
</tr>
<tr>
<td><code>Notify_change(dentry, iattr)</code></td>
<td>依照参数<code>iattr</code>的值修改索引节点的一些属性。如果没有定义该函数，<code>VFS</code>转去执行<code>write_inode()</code>方法</td>
</tr>
<tr>
<td><code>Put_super(super)</code></td>
<td>释放超级块对象</td>
</tr>
<tr>
<td><code>Write_super(super)</code></td>
<td>将超级块的信息写回磁盘，该方法是可选的</td>
</tr>
<tr>
<td><code>Statfs(super, buf, bufsize)</code></td>
<td>将文件系统的统计信息填写在<code>buf</code>缓冲区中</td>
</tr>
<tr>
<td><code>Remount_fs(super, flags, data)</code></td>
<td>用新的选项重新安装文件系统(当某个安装选项必须被修改时进行调用)</td>
</tr>
<tr>
<td><code>Clear_inode(inode)</code></td>
<td>与<code>put_inode</code>类似，但同时也把索引节点对应文件中的数据占用的所有页释放</td>
</tr>
<tr>
<td><code>Umount_begin(super)</code></td>
<td>中断一个安装操作(只在网络文件系统中使用)</td>
</tr>
</tbody>
</table>
</div>
<p>上面这些方法对所有的文件系统都是适用的，但对于一个具体的文件系统来说，可能只用到其中的几个方法。如果那些方法没有定义，则对应的域为空。</p>
<h4 id="索引节点操作inode-operations"><a href="#索引节点操作inode-operations" class="headerlink" title="索引节点操作inode_operations"></a>索引节点操作inode_operations</h4><p>索引节点操作是由<code>inode_operations</code>结构来描述的，主要是用来将<code>VFS</code>对索引节点的操作转化为具体文件系统处理相应操作的函数，在<code>fs.h</code>中描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*create) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">int</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *,<span class="keyword">struct</span> <span class="title">dentry</span> *);</span></span><br><span class="line">	<span class="type">int</span> (*link) (<span class="keyword">struct</span> dentry *,<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*unlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*symlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">	<span class="type">int</span> (*mkdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*rmdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*mknod) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*rename) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line">	<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*readlink) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> *,<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*follow_link) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> nameidata *);</span><br><span class="line">	<span class="type">void</span> (*truncate) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">int</span> (*permission) (<span class="keyword">struct</span> inode *, <span class="type">int</span>); </span><br><span class="line">	<span class="type">int</span> (*revalidate) (<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*setattr) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> iattr *);</span><br><span class="line">	<span class="type">int</span> (*getattr) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> iattr *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>表所示为对索引节点的每个方法给予描述。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数形式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Create(dir, dentry, mode)</code></td>
<td>在某个目录下，为与<code>dentry</code>目录项相关的常规文件创建一个新的磁盘索引节点</td>
</tr>
<tr>
<td><code>Lookup(dir, dentry)</code></td>
<td>查找索引节点所在的目录，这个索引节点所对应的文件名就包含在<code>dentry</code>目录项中</td>
</tr>
<tr>
<td><code>Link(old_dentry, dir, new_dentry)</code></td>
<td>创建一个新的名为<code>new_dentry</code>硬链接，这个新的硬连接指向<code>dir</code>目录下名为<code>old_dentry</code>的文件</td>
</tr>
<tr>
<td><code>unlink(dir, dentry)</code></td>
<td>从<code>dir</code>目录删除<code>dentry</code>目录项所指文件的硬链接</td>
</tr>
<tr>
<td><code>symlink(dir, dentry, symname)</code></td>
<td>在某个目录下，为与目录项相关的符号链创建一个新的索引节点</td>
</tr>
<tr>
<td><code>mkdir(dir, dentry, mode)</code></td>
<td>在某个目录下，为与目录项对应的目录创建一个新的索引节点</td>
</tr>
<tr>
<td><code>mknod(dir, dentry, mode, rdev)</code></td>
<td>在<code>dir</code>目录下，为与目录项对象相关的特殊文件创建一个新的磁盘索引节点。其中参数<code>mode</code>和<code>rdev</code>分别表示文件的类型和该设备的主码</td>
</tr>
<tr>
<td><code>rename(old_dir, old_dentry, new_dir, new_dentry)</code></td>
<td>将<code>old_dir</code>目录下的文件<code>old_dentry</code>移到<code>new_dir</code>目录下，新文件名包含在<code>new_dentry</code>指向的目录项中</td>
</tr>
<tr>
<td><code>readlink(dentry, buffer, buflen)</code></td>
<td>将<code>dentry</code>所指定的符号链中对应的文件路径名拷贝到<code>buffer</code>所指定的内存区</td>
</tr>
<tr>
<td><code>follow_link(inode, dir)</code></td>
<td>解释<code>inode</code>索引节点所指定的符号链；如果该符号链是相对路径名，从指定的<code>dir</code>目录开始进行查找</td>
</tr>
<tr>
<td><code>truncate(inode)</code></td>
<td>修改索引节点<code>inode</code>所指文件的长度。在调用该方法之前，必须将<code>inode</code>对象的<code>i_size</code>域设置为需要的新长度值</td>
</tr>
<tr>
<td><code>permission(inode, mask)</code></td>
<td>确认是否允许对<code>inode</code>索引节点所指的文件进行指定模式的访问</td>
</tr>
<tr>
<td><code>revalidate(dentry)</code></td>
<td>更新由目录项所指定文件的已缓存的属性(通常由网络文件系统调用)</td>
</tr>
<tr>
<td><code>setattr(dentry, attr)</code></td>
<td>设置目录项的属性</td>
</tr>
<tr>
<td><code>getattr(dentry, attr)</code></td>
<td>获得目录项的属性</td>
</tr>
</tbody>
</table>
</div>
<p>以上这些方法均适用于所有的文件系统，但对某一个具体文件系统来说，可能只用到其中的一部分方法。例如，<code>msdos</code>文件系统其公用索引节点的操作在<code>fs/msdos/namei.c</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">msdos_dir_inode_operations</span> =</span> &#123;</span><br><span class="line">	create: msdos_create,</span><br><span class="line">	lookup: msdos_lookup,</span><br><span class="line">	unlink: msdos_unlink,</span><br><span class="line">	mkdir: msdos_mkdir, </span><br><span class="line">	rmdir: msdos_rmdir,</span><br><span class="line">	rename: msdos_rename,</span><br><span class="line">	setattr: fat_notify_change,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="目录项操作"><a href="#目录项操作" class="headerlink" title="目录项操作"></a>目录项操作</h4><p>目录项操作是由<code>dentry_operations</code>数据结构来描述的，定义于<code>include/linux/dcache.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*d_revalidate)(<span class="keyword">struct</span> dentry *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*d_hash) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> qstr *);</span><br><span class="line">	<span class="type">int</span> (*d_compare) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> qstr *, <span class="keyword">struct</span> qstr *);</span><br><span class="line">	<span class="type">int</span> (*d_delete)(<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">void</span> (*d_release)(<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">void</span> (*d_iput)(<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>表给出目录项对象的方法及其描述。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数形成</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d_revalidate(dentry)</code></td>
<td>判定目录项是否有效。默认情况下，<code>VFS</code>函数什么也不做，而网络文件系统可以指定自己的函数</td>
</tr>
<tr>
<td><code>d_hash(dentry, hash)</code></td>
<td>生成一个哈希值。对目录项哈希表而言，这是一个具体文件系统的哈希函数。参数<code>dentry</code>标识包含该路径分量的目录。参数<code>hash</code>指向一个结构，该结构包含要查找的路径名分量以及由<code>hash</code>函数生成的哈希值</td>
</tr>
<tr>
<td><code>d_compare(dir, name1,  name2)</code></td>
<td>比较两个文件名。name1 应该属于<code>dir</code>所指目录。默认情况下，<code>VFS</code>的这个函数就是常用的字符串匹配。</td>
</tr>
<tr>
<td><code>d_delete(dentry)</code></td>
<td>如果对目录项的最后一个引用被删除(<code>d_count</code>变为“0”)，就调用该方法。默认情况下，<code>VFS</code>的这个函数什么也不做</td>
</tr>
<tr>
<td><code>d_release(dentry)</code></td>
<td>当要释放一个目录项时(放入<code>slab</code>分配器)，就调用该方法。默认情况下，VFS`的这个函数什么也不做</td>
</tr>
<tr>
<td><code>d_iput(dentry, ino)</code></td>
<td>当要丢弃目录项对应的索引节点时，就调用该方法。默认情况下，<code>VFS</code>的这个函数调用<code>iput()</code>释放索引节点</td>
</tr>
</tbody>
</table>
</div>
<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>文件操作是由<code>file_operations</code>结构来描述的，定义在<code>fs.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment"> * read, write, poll, fsync, readv, writev can be called</span></span><br><span class="line"><span class="comment"> * without the big kernel lock held in all filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *); </span><br><span class="line">	<span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">	<span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dentry *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*readv) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*writev) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">( *get_unmapped_area)</span><span class="params">( <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个数据结构就是连接<code>VFS</code>文件操作与具体文件系统的文件操作之间的枢纽，也是编写设备驱动程序的重要接口，后面还会给出进一步的说明。对每个函数的描述如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数形式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Owner()</code></td>
<td>指向模块的指针。只有驱动程序才把这个域置为<code>THIS_MODULE</code>，文件系统一般忽略这个域</td>
</tr>
<tr>
<td><code>llseek(file, offset, whence)</code></td>
<td>修改文件指针</td>
</tr>
<tr>
<td><code>read(file, buf, count, offset)</code></td>
<td>从文件的<code>offset</code>处开始读出<code>count</code>个字节，然后增加<code>*offset</code>的值</td>
</tr>
<tr>
<td><code>write(file, buf, count, offset)</code></td>
<td>从文件的<code>*offset</code>处开始写入<code>count</code>个字节，然后增加<code>*offset</code>的值</td>
</tr>
<tr>
<td><code>readdir(dir, dirent, filldir)</code></td>
<td>返回<code>dir</code>所指目录的下一个目录项，这个值存入参数<code>dirent</code>；参数<code>filldir</code>存放一个辅助函数的地址，该函数可以提取目录项的各个域</td>
</tr>
<tr>
<td><code>poll(file, poll_table)</code></td>
<td>检查是否存在关于某文件的操作事件，如果没有则睡眠，直到发生该类操作事件为止</td>
</tr>
<tr>
<td><code>ioctl(inode, file, cmd, arg)</code></td>
<td>向一个基本硬件设备发送命令。该方法只适用于设备文件</td>
</tr>
<tr>
<td><code>mmap(file, vma)</code></td>
<td>执行文件的内存映射，并将这个映射放入进程的地址空间</td>
</tr>
<tr>
<td><code>open(inode, file)</code></td>
<td>通过创建一个新的文件而打开一个文件，并把它链接到相应的索引节点</td>
</tr>
<tr>
<td><code>flush(file)</code></td>
<td>当关闭对一个打开文件的引用时，就调用该方法。也就是说，减少该文件对象<code>f_count</code>域的值。该方法的实际用途依赖于具体文件系统</td>
</tr>
<tr>
<td><code>release(inode, file)</code></td>
<td>释放文件对象。当关闭对打开文件的最后一个引用时，也就是说，该文件对象<code>f_count</code>域的值变为 0 时，调用该方法</td>
</tr>
<tr>
<td><code>fsync(file, dentry)</code></td>
<td>将<code>file</code>文件在高速缓存中的全部数据写入磁盘</td>
</tr>
<tr>
<td><code>fasync(file, on)</code></td>
<td>通过信号来启用或禁用异步<code>I/O</code>通告</td>
</tr>
<tr>
<td><code>check_media_change(dev)</code></td>
<td>检测自上次对设备文件操作以来是否存在介质的改变(可以对块设备使用这一方法，因为它支持可移动介质)</td>
</tr>
<tr>
<td><code>revalidate(dev)</code></td>
<td>恢复设备的一致性(由网络文件系统使用，这是在确认某个远程设备上的介质已被改变之后才使用)</td>
</tr>
<tr>
<td><code>lock(file, cmd, file_lock)</code></td>
<td>对<code>file</code>文件申请一个锁</td>
</tr>
<tr>
<td><code>readv(file, iovec, count, offset)</code></td>
<td>与<code>read()</code>类似，所不同的是，<code>readv()</code>把读入的数据放在多个缓冲区中(叫缓冲区向量)</td>
</tr>
<tr>
<td><code>writev(file, buf, iovec, offset)</code></td>
<td>与<code>write()</code>类似。所不同的是，<code>writev()</code>把数据写入多个缓冲区中(叫缓冲区向量)</td>
</tr>
</tbody>
</table>
</div>
<p><code>VFS</code>中定义的这个<code>file_operations</code>数据结构相当于一个标准模板，对于一个具体的文件系统来说，可能只用到其中的一些函数。注意，2.2 和 2.4 版在对<code>file_operations</code>进行初始化时有所不同，在 2.2 版中，如果某个函数没有定义，则将其置为<code>NULL</code>，如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">device_fops</span> =</span> &#123;</span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">/* seek */</span></span><br><span class="line">	device_read, <span class="comment">/* read */</span></span><br><span class="line">	device_write, <span class="comment">/* write */</span></span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">/* readdir */</span></span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">/* poll */</span></span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">/* ioctl */</span></span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">/* mmap */</span></span><br><span class="line">	device_open, <span class="comment">/* open */</span></span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">/* flush */</span></span><br><span class="line">	device_release <span class="comment">/* release */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是标准<code>C</code>的用法，在 2.4 版中，采用了<code>gcc</code>的扩展用法，如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">device_fops</span> =</span> &#123;</span><br><span class="line">	read : device_read, <span class="comment">/* read */</span></span><br><span class="line">	write : device_write, <span class="comment">/* write */</span></span><br><span class="line">	open : device_open, <span class="comment">/* open */</span></span><br><span class="line">	release : device_release <span class="comment">/* release */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种方式显然简单明了，在设备驱动程序的开发中，经常会用到这种形式。</p>
<h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><h3 id="块高速缓存"><a href="#块高速缓存" class="headerlink" title="块高速缓存"></a>块高速缓存</h3><p><code>Linux</code>支持的文件系统大多以块的形式组织文件，为了减少对物理块设备的访问，在文件以块的形式调入内存后，使用块高速缓存(buffer_cache)对它们进行管理。每个缓冲区由两部分组成，第 1 部分称为缓冲区首部，用数据结构<code>buffer_head</code>表示，第 2 部分是真正的缓冲区内容(即所存储的数据)。由于缓冲区首部不与数据区域相连，数据区域独立存储。因而在缓冲区首部中，有一个指向数据的指针和一个缓冲区长度的字段。图 8.6 给出了一个缓冲区的格式。<br><img src="/img/1634017201.jpg" alt=""></p>
<p>缓冲区首部包含如下内容。</p>
<ul>
<li>用于描述缓冲区内容的信息，包括：所在设备号、起始物理块号、包含在缓冲区中的字节数。</li>
<li>缓冲区状态的域：是否有有用数据、是否正在使用、重新利用之前是否要写回磁盘等。</li>
<li>用于管理的域。</li>
</ul>
<p><code>buffer-head</code>数据结构在<code>include\linux\fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Try to keep the most commonly used fields in single cache lines (16</span></span><br><span class="line"><span class="comment"> * bytes) to improve performance. This ordering should be</span></span><br><span class="line"><span class="comment"> * particularly beneficial on 32-bit processors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We use the first 16 bytes for the data which is used in searches</span></span><br><span class="line"><span class="comment"> * over the block hash lists (ie. getblk() and friends).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The second 16 bytes we use for lru buffer scans, as used by</span></span><br><span class="line"><span class="comment"> * sync_buffers() and refill_freelist(). -- sct</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">	<span class="comment">/* First cache line: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_next</span>;</span> <span class="comment">/* 哈希队列链表*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> b_blocknr; <span class="comment">/* 逻辑块号 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> b_size; <span class="comment">/* 块大小 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> b_list; <span class="comment">/* 本缓冲区所出现的链表 */</span></span><br><span class="line">	<span class="type">kdev_t</span> b_dev; <span class="comment">/* 虚拟设备标示符(B_FREE = free) */</span></span><br><span class="line">	<span class="type">atomic_t</span> b_count; <span class="comment">/* 块引用计数器 */</span></span><br><span class="line">	<span class="type">kdev_t</span> b_rdev; <span class="comment">/* 实际设备标识符*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> b_state; <span class="comment">/* 缓冲区状态位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> b_flushtime; <span class="comment">/* 对脏缓冲区进行刷新的时间*/</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_next_free</span>;</span><span class="comment">/* 指向`lru/free`链表中的下一个元素 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_prev_free</span>;</span><span class="comment">/* 指向链表中的上一个元素*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span><span class="comment">/* 每个页面中的缓冲区链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_reqnext</span>;</span> <span class="comment">/*请求队列 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> **<span class="title">b_pprev</span>;</span> <span class="comment">/* 哈希队列的双向链表 */</span></span><br><span class="line">	<span class="type">char</span> * b_data; <span class="comment">/* 指向数据块 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span> <span class="comment">/* 这个`bh`所映射的页面*/</span></span><br><span class="line">	<span class="type">void</span> (*b_end_io)(<span class="keyword">struct</span> buffer_head *bh, <span class="type">int</span> uptodate); <span class="comment">/* I/O`结束方法*/</span></span><br><span class="line">	<span class="type">void</span> *b_private; <span class="comment">/* 给`b_end_io`保留 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> b_rsector; <span class="comment">/* 缓冲区在磁盘上的实际位置*/</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> b_wait; <span class="comment">/* 缓冲区等待队列 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">b_inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_inode_buffers</span>;</span> <span class="comment">/* inode`脏缓冲区的循环链表*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中缓冲区状态在<code>fs.h</code>中定义为枚举类型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bh state bits */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bh_state_bits</span> &#123;</span></span><br><span class="line">	BH_Uptodate, <span class="comment">/* 如果缓冲区包含有效数据则置 1 */</span></span><br><span class="line">	BH_Dirty, <span class="comment">/* 如果缓冲区数据被改变则置 1 */</span></span><br><span class="line">	BH_Lock, <span class="comment">/* 如果缓冲区被锁定则置 1*/</span></span><br><span class="line">	BH_Req, <span class="comment">/* 如果缓冲区数据无效则置 0 */</span></span><br><span class="line">	BH_Mapped, <span class="comment">/* 如果缓冲区有一个磁盘映射则置 1 */</span></span><br><span class="line">	BH_New, <span class="comment">/* 如果缓冲区为新且还没有被写出则置 1 */</span></span><br><span class="line">	BH_Async, <span class="comment">/* 如果缓冲区是进行end_buffer_io_async I/O同步则置 1 */</span></span><br><span class="line">	BH_Wait_IO, <span class="comment">/* 如果我们应该把这个缓冲区写出则置 1 */</span></span><br><span class="line">	BH_launder, <span class="comment">/* 如果我们应该“清洗”这个缓冲区则置 1 */</span></span><br><span class="line">	BH_JBD, <span class="comment">/* 如果与journal_head相连接则置 1 */</span></span><br><span class="line">	BH_PrivateStart,<span class="comment">/* 这不是一个状态位，但是，第 1 位由其他实体用于私有分配*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显然一个缓冲区可以同时具有上述状态的几种。</p>
<p>块高速缓存的管理很复杂，下面先对空缓冲区、空闲缓冲区、正使用的缓冲区、缓冲区的大小以及缓冲区的类型作一个简短的介绍。</p>
<p>缓冲区可以分为两种，一种是包含了有效数据的，另一种是没有被使用的，即空缓冲区。具有有效数据并不能表明某个缓冲区正在被使用，毕竟，在同一时间内，被进程访问的缓冲区(即处于使用状态)只有少数几个。当前没有被进程访问的有效缓冲区和空缓冲区称为空闲缓冲区。其实，<code>buffer_head</code>结构中的<code>b_count</code>就可以反映出缓冲区是否处于使用状态。如果它为 0，则缓冲区是空闲的。大于 0，则缓冲区正被进程访问。</p>
<p>缓冲区的大小不是固定的，当前<code>Linux</code>支持 5 种大小的缓冲区，分别是 512、1024、2048、4096、8192 字节。<code>Linux</code>所支持的文件系统都使用共同的块高速缓存，在同一时刻，块高速缓存中存在着来自不同物理设备的数据块，为了支持这些不同大小的数据块，<code>Linux</code>使用了几种不同大小的缓冲区。当前的<code>Linux</code>缓冲区有 3 种类型，在<code>include/linux/fs.h</code>中有如下的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_CLEAN 0 <span class="comment">/*未使用的、干净的缓冲区*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LOCKED 1 <span class="comment">/*被锁定的缓冲区，正等待写入*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_DIRTY 2 <span class="comment">/*脏的缓冲区，其中有有效数据，需要写回磁盘*/</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>VFS</code>使用了多个链表来管理块高速缓存中的缓冲区。</p>
<p>首先，对于包含了有效数据的缓冲区，用一个哈希表来管理，用<code>hash_table</code>来指向这个哈希表。哈希索引值由数据块号以及其所在的设备标识号计算(散列)得到。所以在<code>buffer_head</code>这个结构中有一些用于哈希表管理的域。使用哈希表可以迅速地查找到所要寻找的数据块所在的缓冲区。</p>
<p>对于每一种类型的未使用的有效缓冲区，系统还使用一个<code>LRU</code>(最近最少使用)双链表管理，即<code>lru-list</code>链。由于共有 3 种类型的缓冲区，所以有 3 个这样的<code>LRU</code>链表。当需要访问某个数据块时，系统采取如下算法。</p>
<p>首先，根据数据块号和所在设备号在块高速缓存中查找，如果找到，则将它的<code>b_count</code>域加 1，因为这个域正是反映了当前使用这个缓冲区的进程数。如果这个缓冲区同时又处于某个<code>LRU</code>链中，则将它从<code>LRU</code>链中解开。如果数据块还没有调入缓冲区，则系统必须进行磁盘<code>I/O</code>操作，将数据块调入块高速缓存，同时将空缓冲区分配一个给它。如果块高速缓存已满(即没有空缓冲区可供分配)，则从某个<code>LRU</code>链首取下一个，先看是否置了“脏”位，如已置，则将它的内容写回磁盘。然后清空内容，将它分配给新的数据块。</p>
<p>在缓冲区使用完了后，将它的<code>b_count</code>域减 1，如果<code>b_count</code>变为 0，则将它放在某个<code>LRU</code>链尾，表示该缓冲区已可以重新利用。为了配合以上这些操作，以及其他一些多块高速缓存的操作，系统另外使用了几个链表，主要是：</p>
<ul>
<li>对于每一种大小的空闲缓冲区，系统使用一个链表管理，即<code>free_list</code>链。</li>
<li>对于空缓冲区，系统使用一个<code>unused_list</code>链管理。</li>
</ul>
<p>以上几种链表都在<code>fs/buffer.c</code>定义。</p>
<p><code>Linux</code>中，用<code>bdflush</code>守护进程完成对块高速缓存的一般管理。<code>bdflush</code>守护进程是一个简单的内核线程，在系统启动时运行，它在系统中注册的进程名称为<code>kflushd</code>，你可以使用<code>ps</code>命令看到此系统进程。它的一个作用是监视块高速缓存中的“脏”缓冲区，在分配或丢弃缓冲区时，将对“脏”缓冲区数目作一个统计。通常情况下，该进程处于休眠状态，当块高速缓存中“脏”缓冲区的数目达到一定的比例，默认是 60%，该进程将被唤醒。但是，如果系统急需，则在任何时刻都可以唤醒这个进程。使用<code>update</code>命令可以看到和改变这个数值。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># update -d</span></span><br></pre></td></tr></table></figure></p>
<p>当有数据写入缓冲区使之变成“脏”时，所有的“脏”缓冲区被连接到一个<code>BUF_DIRTY_LRU</code>链表中，<code>bdflush</code>会将适当数目的缓冲区中的数据块写到磁盘上。这个数值的缺省值为 500，可以用<code>update</code>命令改变这个值。</p>
<p>另一个与块高速缓存管理相关的是<code>update</code>命令，它不仅仅是一个命令，还是一个后台进程。当以超级用户的身份运行时(在系统初始化时)，它将周期性调用系统服务例程将老的“脏”缓冲区中内容“冲刷”到磁盘上去。它所完成的这个工作与<code>bdflush</code>类似，不同之处在于，当一个“脏”缓冲区完成这个操作后, 它将把写入到磁盘上的时间标记到<code>buffer_head</code>结构中。<code>update</code>每次运行时它将在系统的所有“脏”缓冲区中查找那些“冲刷”时间已经超过一定期限的，这些过期缓冲区都要被写回磁盘。</p>
<h3 id="索引节点高速缓存"><a href="#索引节点高速缓存" class="headerlink" title="索引节点高速缓存"></a>索引节点高速缓存</h3><p><code>VFS</code>也用了一个高速缓存来加快对索引节点的访问，和块高速缓存不同的一点是每个缓冲区不用再分为两个部分了，因为<code>inode</code>结构中已经有了类似于块高速缓存中缓冲区首部的域。索引节点高速缓存的实现代码全部在<code>fs/inode.c</code>。</p>
<h4 id="索引节点链表"><a href="#索引节点链表" class="headerlink" title="索引节点链表"></a>索引节点链表</h4><p>每个索引节点可能处于哈希表中，也可能同时处于下列“类型”链表的一种中：</p>
<ul>
<li><code>in_use</code>有效的索引节点，即<code>i_count &gt; 0</code> 且<code>i_nlink &gt; 0</code>(参看前面的<code>inode</code>结构)</li>
<li><code>dirty</code>类似于<code>in_use</code> ，但还“脏”；</li>
<li><code>unused</code>有效的索引节点但还没使用，即<code>i_count = 0</code>。</li>
</ul>
<p>这几个链表定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(inode_in_use)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(inode_unused)</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">inode_hashtable</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(anon_hash_chain)</span>; <span class="comment">/* for inodes with NULL i_sb */</span></span><br></pre></td></tr></table></figure></p>
<p>因此，索引节点高速缓存的结构概述如下。</p>
<ul>
<li>全局哈希表<code>inode_hashtable</code>，其中哈希值是根据每个超级块指针的值和 32 位索引节点号而得。对没有超级块的索引节点<code>inode-&gt;i_sb == NULL</code>，则将其加入到<code>anon_hash_chain</code>链表的首部。例如，<code>net/socket.c</code>中<code>sock_alloc()</code>函数，通过调用<code>fs/inode.c</code>中<code>get_empty_inode()</code>创建的套接字是一个匿名索引节点，这个节点就加入到了<code>anon_hash_chain</code>链表。</li>
<li>正在使用的索引节点链表。全局变量<code>inode_in_use</code>指向该链表中的首元素和尾元素。函数<code>get_empty_inode()</code>获得一个空节点，<code>get_new_inode()</code>获得一个新节点，通过这两个函数新分配的索引节点就加入到这个链表中。</li>
<li>未用索引节点链表。全局变量<code>inode_unused</code>的<code>next</code>域和<code>prev</code>域分别指向该链表中的首元素和尾元素。</li>
<li>脏索引节点链表。由相应超级块的<code>s_dirty</code>域指向该链表中的首元素和尾元素。</li>
<li>对<code>inode</code>对象的缓存，定义如下：<code>static kmem_cache_t * inode_cachep</code>，这是一个<code>Slab</code>缓存，用于分配和释放索引节点对象。</li>
</ul>
<p>索引节点的<code>i_hash</code>域指向哈希表，<code>i_list</code>指向<code>in_use</code>、<code>unused</code>或<code>dirty</code>某个链表。所有这些链表都受单个自旋锁<code>inode_lock</code>的保护，其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* A simple spinlock to protect the list manipulations.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* NOTE! You also have to own the lock if you change</span></span><br><span class="line"><span class="comment">* the i_state of an inode while it is in use..</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> inode_lock = SPIN_LOCK_UNLOCKED;</span><br></pre></td></tr></table></figure></p>
<p>索引节点高速缓存的初始化是由<code>inode_init()</code>实现的，而这个函数是在系统启动时由<code>init/main.c</code>中的<code>start_kernel()</code>函数调用的。<code>inode_init()</code>只有一个参数，表示索引节点高速缓存所使用的物理页面数。因此，索引节点高速缓存可以根据可用物理内存的大小来进行配置，例如，如果物理内存足够大，就可以创建一个大的哈希表。</p>
<p>索引节点状态的信息存放在数据结构<code>inodes_stat_t</code>中，在<code>fs/fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inodes_stat_t</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> nr_inodes;</span><br><span class="line">	<span class="type">int</span> nr_unused;</span><br><span class="line">	<span class="type">int</span> dummy[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">inodes_stat_t</span> <span class="title">inodes_stat</span></span></span><br></pre></td></tr></table></figure></p>
<p>用户程序可以通过<code>/proc/sys/fs/inode-nr</code>和<code>/proc/sys/fs/inode-state</code>获得索引节点高速缓存中索引节点总数及未用索引节点数。</p>
<h4 id="索引节点高速缓存的工作过程"><a href="#索引节点高速缓存的工作过程" class="headerlink" title="索引节点高速缓存的工作过程"></a>索引节点高速缓存的工作过程</h4><p>为了帮助大家理解索引节点高速缓存如何工作，我们来跟踪一下在打开<code>Ext2</code>文件系统的一个常规文件时，相应索引节点的作用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;file&quot;</span>, O_RDONLY);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure></p>
<p><code>open()</code>系统调用是由<code>fs/open.c</code>中的<code>sys_open</code>函数实现的，而真正的工作是由<code>fs/open.c</code>中的<code>filp_open()</code>函数完成的，<code>filp_open()</code>函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> file *<span class="title function_">filp_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename, <span class="type">int</span> flags, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> namei_flags, error;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span></span><br><span class="line">	namei_flags = flags;</span><br><span class="line">	<span class="keyword">if</span> ((namei_flags+<span class="number">1</span>) &amp; O_ACCMODE)</span><br><span class="line">		namei_flags++;</span><br><span class="line">	<span class="keyword">if</span> (namei_flags &amp; O_TRUNC)</span><br><span class="line">		namei_flags |= <span class="number">2</span>;</span><br><span class="line">	error = open_namei(filename, namei_flags, mode, &amp;nd);</span><br><span class="line">	<span class="keyword">if</span> (!error)</span><br><span class="line">		<span class="keyword">return</span> dentry_open(nd.dentry, nd.mnt, flags);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>nameidata</code>结构在<code>fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">last</span>;</span> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">int</span> last_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个数据结构是临时性的，其中，我们主要关注<code>dentry</code>和<code>mnt</code>域。<code>dentry</code>结构我们已经在前面介绍过，而<code>vfsmount</code>结构记录着所属文件系统的安装信息，例如文件系统的安装点、文件系统的根节点等。<code>filp_open()</code>主要调用以下两个函数。</p>
<ul>
<li><code>open_namei()</code>：填充目标文件所在目录的<code>dentry</code>结构和所在文件系统的<code>vfsmount</code>结构。在<code>dentry</code>结构中<code>dentry-&gt;d_inode</code>就指向目标文件的索引节点。</li>
<li><code>dentry_open()</code>：建立目标文件的一个“上下文”，即<code>file</code>数据结构，并让它与当前进程的<code>task_strrct</code>结构挂上钩。同时，在这个函数中，调用了具体文件系统的打开函数，即<code>f_op-&gt;open()</code>。该函数返回指向新建立的<code>file</code>结构的指针。</li>
</ul>
<p><code>open_namei()</code>函数通过<code>path_walk()</code>与目录项高速缓存(即目录项哈希表)打交道，而<code>path_walk()</code>又调用具体文件系统的<code>inode_operations-&gt;lookup()</code>方法；该方法从磁盘找到并读入当前节点的目录项，然后通过<code>iget(sb, ino)</code>，根据索引节点号从磁盘读入相应索引节点并在内存建立起相应的<code>inode</code>结构，这就到了我们讨论的索引节点高速缓存。</p>
<p>当索引节点读入内存后，通过调用<code>d_add(dentry, inode)</code>，就将<code>dentry</code>结构和<code>inode</code>结构之间的链接关系建立起来。两个数据结构之间的联系是双向的。一方面，<code>dentry</code>结构中的指针<code>d_inode</code>指向<code>inode</code>结构，这是一对一的关系，因为一个目录项只对应着一个文件。反之则不然，同一个文件可以有多个不同的文件名或路径(通过系统调用<code>link()</code>建立，注意与符号连接的区别，那是由<code>symlink()</code>建立的)，所以从<code>inode</code>结构到<code>dentry</code>结构的方向是一对多的关系。因此，<code>inode</code>结构的<code>i_ dentry</code>是个队列，<code>dentry</code>结构通过其队列头部<code>d_alias</code>挂入相应<code>inode</code>结构的队列中。</p>
<p>为了进一步说明索引节点高速缓存，我们来进一步考察<code>iget()</code>。当我们打开一个文件时，就调用了<code>iget()</code>函数，而<code>iget</code>真正调用的是<code>iget4(sb, ino, NULL, NULL)</code>函数，该函数代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode *<span class="title function_">iget4</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="type">unsigned</span> <span class="type">long</span> ino, <span class="type">find_inode_t</span> find_actor, <span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> * <span class="title">head</span> =</span> inode_hashtable + hash(sb,ino);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	spin_lock(&amp;inode_lock);</span><br><span class="line">	inode = find_inode(sb, ino, head, find_actor, opaque);</span><br><span class="line">	<span class="keyword">if</span> (inode) &#123;</span><br><span class="line">		__iget(inode);</span><br><span class="line">		spin_unlock(&amp;inode_lock);</span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">		<span class="keyword">return</span> inode;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;inode_lock);</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	* get_new_inode() will do the right thing, re-trying the search</span></span><br><span class="line"><span class="comment">	* in case it had to block at any point.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> get_new_inode(sb, ino, head, find_actor, opaque);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面对以上代码给出进一步的解释。</p>
<ul>
<li><code>inode</code>结构中有个哈希表<code>inode_hashtable</code>，首先在<code>inode_lock</code>锁的保护下，通过<code>find_ inode</code>函数在哈希表中查找目标节点的<code>inode</code>结构，由于索引节点号只有在同一设备上时才是唯一的，因此，在哈希计算时要把索引节点所在设备的<code>super_block</code>结构的地址也结合进去。如果在哈希表中找到该节点，则其引用计数<code>i_count</code>加 1；如果<code>i_count</code>在增加之前为 0，说明该节点不“脏”，则该节点当前肯定处于<code>inode_unused list</code>队列中，于是，就把该节点从这个队列删除而插入<code>inode_in_use</code>队列；最后，把<code>inodes_stat.nr_unused</code>减 1。</li>
<li>如果该节点当前被加锁，则必须等待，直到解锁，以便确保<code>iget4()</code>返回一个未加锁的节点。</li>
<li>如果在哈希表中没有找到该节点，说明目标节点的<code>inode</code>结构还不在内存，因此，调用<code>get_new_inode()</code>从磁盘上读入相应的索引节点并建立起一个<code>inode</code>结构，并把该结构插入到哈希表中。</li>
<li>对<code>get_new_inode()</code>给出进一步的说明，该函数从<code>slab</code>缓存区中分配一个新的<code>inode</code>结构，但是这个分配操作有可能出现阻塞，于是，就应当解除保护哈希表的<code>inode_lock</code>自旋锁，以便在哈希表中再次进行搜索。如果这次在哈希表中找到这个索引节点，就通过<code>__iget</code>把该节点的引用计数加 1，并撤销新分配的节点；如果在哈希表中还没有找到，就使用新分配的索引节点。因此，把该索引节点的一些域先初始化为必须的值，然后调用具体文件系统的<code>sb-&gt;s_op-&gt;read_inode()</code>域填充该节点的其他域。这就把我们从索引节点高速缓存带到了某个具体文件系统的代码中。当<code>s_op-&gt;read_inode()</code>方法正在从磁盘读索引节点时，该节点被加锁(<code>i_state = I_LOCK</code>)；当<code>read_inode()</code>返回时，该节点的锁被解除，并且唤醒所有等待者。</li>
</ul>
<h3 id="目录高速缓存"><a href="#目录高速缓存" class="headerlink" title="目录高速缓存"></a>目录高速缓存</h3><p>每个目录项对象属于以下 4 种状态之一。</p>
<ul>
<li>空闲状态：处于该状态的目录项对象不包含有效的信息，还没有被<code>VFS</code>使用。它对应的内存区由<code>slab</code>分配器进行管理。</li>
<li>未使用状态：处于该状态的目录项对象当前还没有被内核使用。该对象的引用计数器<code>d_count</code>的值为<code>NULL</code>。但其<code>d_inode</code>域仍然指向相关的索引节点。该目录项对象包含有效的信息，但为了在必要时回收内存，它的内容可能被丢弃。 </li>
<li>正在使用状态：处于该状态的目录项对象当前正在被内核使用。该对象的引用计数器<code>d_count</code>的值为正数，而其<code>d_inode</code>域指向相关的索引节点对象。该目录项对象包含有效的信息，并且不能被丢弃。</li>
<li>负状态：与目录项相关的索引节点不复存在，那是因为相应的磁盘索引节点已被删除。该目录项对象的<code>d_inode</code>域置为<code>NULL</code>，但该对象仍然被保存在目录项高速缓存中，以便后续对同一文件目录名的查找操作能够快速完成，术语“负的”容易使人误解，因为根本不涉及任何负值。</li>
</ul>
<p>为了最大限度地提高处理这些目录项对象的效率，<code>Linux</code>使用目录项高速缓存，它由以下两种类型的数据结构组成。</p>
<ul>
<li>处于正在使用、未使用或负状态的目录项对象的集合。</li>
<li>一个哈希表，从中能够快速获取与给定的文件名和目录名对应的目录项对象。如果访问的对象不在目录项高速缓存中，哈希函数返回一个空值。</li>
</ul>
<p>目录项高速缓存的作用也相当于索引节点高速缓存的控制器。内核内存中，目录项可能已经不使用，但与其相关的索引节点并不被丢弃，这是由于目录项高速缓存仍在使用它们，因此，索引节点的<code>i_count</code>域不为空。于是，这些索引节点对象还保存在<code>RAM</code>中，并能够借助相应的目录项快速引用它们。</p>
<p>所有“未使用”目录项对象都存放在一个“最近最少使用”的双向链表中，该链表按照插入的时间排序。一旦目录项高速缓存的空间开始变小，内核就从链表的尾部删除元素，使得多数最近经常使用的对象得以保留。<code>LRU</code>链表的首元素和尾元素的地址存放在变量<code>dentry_unused</code>中的<code>next</code>域和<code>prev</code>域中。目录项对象的<code>d_lru</code>域包含的指针指向该链表中相邻目录的对象。</p>
<p>每个“正在使用”的目录项对象都被插入一个双向链表中，该链表由相应索引节点对象的<code>i_dentry</code>域所指向。目录项对象的<code>d_alias</code>域存放链表中相邻元素的地址。当指向相应文件的最后一个硬链接被删除后，一个“正在使用”的目录项对象可能变成“负”状态。在这种情况下，该目录项对象被移到“未使用” 目录项对象组成的<code>LRU</code>链表中。每当内核缩减目录项高速缓存时，“负”状态目录项对象就朝着<code>LRU</code>链表的尾部移动，这样一来，这些对象就逐渐被释放。</p>
<p>哈希表是由<code>dentry_hashtable</code>数组实现的。数组中的每个元素是一个指向链表的指针，这种链表就是把具有相同哈希表值的目录项进行散列而形成的。该数组的长度取决于系统已安装<code>RAM</code>的数量。目录项对象的<code>d_hash</code>域包含指向具有相同<code>hash</code>值的链表中的相邻元素。哈希函数产生的值是由目录及文件名的目录项对象的地址计算出的。 </p>
<h2 id="文件系统的注册、安装与卸载"><a href="#文件系统的注册、安装与卸载" class="headerlink" title="文件系统的注册、安装与卸载"></a>文件系统的注册、安装与卸载</h2><h3 id="文件系统的注册"><a href="#文件系统的注册" class="headerlink" title="文件系统的注册"></a>文件系统的注册</h3><p>每个文件系统都有一个初始化例程，它的作用就是在<code>VFS</code>中进行注册，即填写一个叫做<code>file_system_type</code>的数据结构，该结构包含了文件系统的名称以及一个指向对应的<code>VFS</code>超级块读取例程的地址，所有已注册的文件系统的<code>file_system_type</code>结构形成一个链表，为区别后面将要说到的已安装的文件系统形成的另一个链表，我们把这个链表称为注册链表。</p>
<p><code>file_system_type</code>的数据结构在<code>fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">int</span> fs_flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *(*<span class="title">read_super</span>) (<span class="keyword">struct</span> <span class="title">super_block</span> *, <span class="title">void</span> *, <span class="title">int</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对其中几个域的说明如下。</p>
<ul>
<li><code>name</code>：文件系统的类型名，以字符串的形式出现。</li>
<li><code>fs_flags</code>：指明具体文件系统的一些特性，有关标志定义于<code>fs.h</code>中：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* public flags for file_system_type */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_REQUIRES_DEV 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_NO_DCACHE 2 <span class="comment">/* Only dcache the necessary things. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_NO_PRELIM 4 <span class="comment">/* prevent preloading of dentries, even if</span></span></span><br><span class="line"><span class="comment"><span class="meta"> 						* FS_NO_DCACHE is not set.</span></span></span><br><span class="line"><span class="comment"><span class="meta"> 						*/</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_SINGLE 8 <span class="comment">/* Filesystem that can have only one superblock */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_NOMOUNT 16 <span class="comment">/* Never mount from userland */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_LITTER 32 <span class="comment">/* Keeps the tree in dcache */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_ODD_RENAME 32768 <span class="comment">/* Temporary stuff; will go away as soon</span></span></span><br><span class="line"><span class="comment"><span class="meta">							* as nfs_rename() will be cleaned up</span></span></span><br><span class="line"><span class="comment"><span class="meta">							*/</span></span></span><br></pre></td></tr></table></figure>
<p>对某些常用标志的说明如下。</p>
<ol>
<li>有些虚拟的文件系统，如<code>pipe</code>、共享内存等，根本不允许由用户进程通过系统调用<code>mount()</code>来安装。这样的文件系统其<code>fs_flags</code>中的<code>FS_NOMOUNT</code>标志位为 1。</li>
<li>一般的文件系统类型要求有物理的设备作为其物质基础，其<code>fs_flags</code>中的<code>FS_REQUIRES_DEV</code>标志位为 1，这些文件系统如<code>Ext2</code>、<code>Minix</code>、<code>ufs</code>等。</li>
<li>有些虚拟文件系统在安装了同类型中的第 1 个“设备”，从而创建了其超级块的<code>super_block</code>数据结构，在安装同一类型中的其他设备时就共享已存在的<code>super_block</code>结构，而不再有自己的超级块结构。此时<code>fs_flags</code>中的<code>FS_SINGLE</code>标志位为 1，表示整个文件系统只有一个超级块，而不像一般的文件系统类型那样，每个具体的设备上都有一个超级块。</li>
</ol>
<ul>
<li><code>read_super</code>：这是各种文件系统读入其超级块的函数指针。因为不同的文件系统其超级块不同，因此其读入函数也不同。</li>
<li><code>owner</code>：如果<code>file_system_type</code>所代表的文件系统是通过可安装模块实现的，则该指针指向代表着具体模块的<code>module</code>结构。如果文件系统是静态地链接到内核，则这个域为<code>NULL</code>。<ul>
<li>实际上，你只需要把这个域置为<code>THIS_MODLUE</code>(这是个一个宏)，它就能自动地完成上述工作。</li>
</ul>
</li>
<li><code>next</code>：把所有的<code>file_system_type</code>结构链接成单项链表的链接指针，变量<code>file_systems</code>指向这个链表。这个链表是一个临界资源，受<code>file_systems_lock</code>自旋读写锁的保护。</li>
<li><code>fs_supers</code>：这个域是一个双向链表。链表中的元素是超级块结构。如前说述，每个文件系统都有一个超级块，但有些文件系统可能被安装在不同的设备上，而且每个具体的设备都有一个超级块，这些超级块就形成一个双向链表。</li>
</ul>
<p>搞清楚这个数据结构的各个域以后，就很容易理解注册函数<code>register_filesystem()</code>，该函数定义于<code>fs/super.c</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * register_filesystem - register a new filesystem</span></span><br><span class="line"><span class="comment"> * @fs: the file system structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Adds the file system passed to the list of file systems the kernel</span></span><br><span class="line"><span class="comment"> * is aware of for mount and other syscalls. Returns 0 on success,</span></span><br><span class="line"><span class="comment"> * or a negative errno code on an error.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The &amp;struct file_system_type that is passed is linked into the kernel</span></span><br><span class="line"><span class="comment"> * structures and must not be freed until the file system has been</span></span><br><span class="line"><span class="comment"> * unregistered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_filesystem</span><span class="params">(<span class="keyword">struct</span> file_system_type * fs)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> ** <span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (!fs)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (fs-&gt;next)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	INIT_LIST_HEAD(&amp;fs-&gt;fs_supers);</span><br><span class="line">	write_lock(&amp;file_systems_lock);</span><br><span class="line">	p = find_filesystem(fs-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (*p)</span><br><span class="line">		res = -EBUSY;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*p = fs;</span><br><span class="line">	write_unlock(&amp;file_systems_lock);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>find_filesystem()</code>函数在同一个文件中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> file_system_type **<span class="title function_">find_filesystem</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> **<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">for</span> (p=&amp;file_systems; *p; p=&amp;(*p)-&gt;next)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>((*p)-&gt;name,name) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，对注册链表的操作必须互斥地进行，因此，对该链表的查找加了写锁<code>write_lock</code>。文件系统注册后，还可以撤消这个注册，即从注册链表中删除一个<code>file_system_type</code>结构，此后系统不再支持该种文件系统。<code>fs/super.c</code>中的<code>unregister_filesystem()</code>函数就是起这个作用的，它在执行成功后返回 0，如果注册链表中本来就没有指定的要删除的结构，则返回-1，其代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* unregister_filesystem - unregister a file system</span></span><br><span class="line"><span class="comment">* @fs: filesystem to unregister</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Remove a file system that was previously successfully registered</span></span><br><span class="line"><span class="comment">* with the kernel. An error is returned if the file system is not found.</span></span><br><span class="line"><span class="comment">* Zero is returned on a success.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Once this function has returned the &amp;struct file_system_type structure</span></span><br><span class="line"><span class="comment">* may be freed or reused.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unregister_filesystem</span><span class="params">(<span class="keyword">struct</span> file_system_type * fs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> ** <span class="title">tmp</span>;</span></span><br><span class="line">	write_lock(&amp;file_systems_lock);</span><br><span class="line">	tmp = &amp;file_systems; </span><br><span class="line">	<span class="keyword">while</span> (*tmp) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fs == *tmp) &#123;</span><br><span class="line">			*tmp = fs-&gt;next;</span><br><span class="line">			fs-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">			write_unlock(&amp;file_systems_lock);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = &amp;(*tmp)-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	write_unlock(&amp;file_systems_lock);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件系统的安装"><a href="#文件系统的安装" class="headerlink" title="文件系统的安装"></a>文件系统的安装</h3><p>要使用一个文件系统，仅仅注册是不行的，还必须安装这个文件系统。在安装<code>Linux</code>时，硬盘上已经有一个分区安装了<code>Ext2</code>文件系统，它是作为根文件系统的，根文件系统在启动时自动安装。其实，在系统启动后你所看到的文件系统，都是在启动时安装的。如果需要自己(一般是超级用户)安装文件系统，则需要指定 3 种信息：文件系统的名称、包含文件系统的物理块设备、文件系统在已有文件系统中的安装点。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -t iso9660 /dev/hdc /mnt/cdrom</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>iso9660</code>就是文件系统的名称，<code>/dev/hdc</code>是包含文件系统的物理块设备，<code>/mnt/cdrom</code>是将要安装到的目录，即安装点。从这个例子可以看出，安装一个文件系统实际上是安装一个物理设备。</p>
<p>把一个文件系统(或设备)安装到一个目录点时要用到的主要数据结构为<code>vfsmount</code>，定义于<code>include/linux/mount.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_hash</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt_parent</span>;</span> <span class="comment">/* fs we are mounted on */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_mountpoint</span>;</span> <span class="comment">/* dentry of mountpoint */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span> <span class="comment">/* root of the mounted tree */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span> <span class="comment">/* pointer to superblock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_mounts</span>;</span> <span class="comment">/* list of children, anchored here */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_child</span>;</span> <span class="comment">/* and going through their mnt_child */</span></span><br><span class="line">	<span class="type">atomic_t</span> mnt_count;</span><br><span class="line">	<span class="type">int</span> mnt_flags;</span><br><span class="line">	<span class="type">char</span> *mnt_devname; <span class="comment">/* Name of device e.g. /dev/dsk/hda1 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面对结构中的主要域给予进一步说明。</p>
<ul>
<li>为了对系统中的所有安装点进行快速查找，内核把它们按哈希表来组织，<code>mnt_hash</code>就是形成哈希表的队列指针。</li>
<li><code>mnt_mountpoint</code>是指向安装点<code>dentry</code>结构的指针。而<code>dentry</code>指针指向安装点所在目录树中根目录的<code>dentry</code>结构。 </li>
<li><code>mnt_parent</code>是指向上一层安装点的指针。如果当前的安装点没有上一层安装点(如根设备)，则这个指针为<code>NULL</code>。同时，<code>vfsmount</code>结构中还有<code>mnt_mounts</code>和<code>mnt_child</code>两个队列头，只要上一层<code>vfsmount</code>结构存在，就把当前<code>vfsmount</code>结构中<code>mnt_child</code>链入上一层<code>vfsmount</code>结构的<code>mnt_mounts</code>队列中。这样就形成一个设备安装的树结构，从一个<code>vfsmount</code>结构的<code>mnt_mounts</code>队列开始，可以找到所有直接或间接安装在这个安装点上的其他设备。</li>
<li><code>mnt_sb</code>指向所安装设备的超级块结构<code>super_blaock</code>。</li>
<li><code>mnt_list</code>是指向<code>vfsmount</code>结构所形成链表的头指针。</li>
</ul>
<p>另外，系统还定义了<code>vfsmntlist</code>变量，指向<code>mnt_list</code>队列。对这个数据结构的进一步理解请看后面文件系统安装的具体实现过程。</p>
<p>文件系统的安装选项，也就是<code>vfsmount</code>结构中的安装标志<code>mnt_flags</code>在<code>linux/fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* These are the fs-independent mount-flags: up to 32 flags are supported</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_RDONLY 1 <span class="comment">/* Mount read-only */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_NOSUID 2 <span class="comment">/* Ignore suid and sgid bits */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_NODEV 4 <span class="comment">/* Disallow access to device special files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_NOEXEC 8 <span class="comment">/* Disallow program execution */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_SYNCHRONOUS 16 <span class="comment">/* Writes are synced at once */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_REMOUNT 32 <span class="comment">/* Alter flags of a mounted FS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_MANDLOCK 64 <span class="comment">/* Allow mandatory locks on an FS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_NOATIME 1024 <span class="comment">/* Do not update access times. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_NODIRATIME 2048 <span class="comment">/* Do not update directory access times */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_BIND 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_MOVE 8192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_REC 16384</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_VERBOSE 32768</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_ACTIVE (1&lt;&lt;30)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_NOUSER (1&lt;&lt;31)</span></span><br></pre></td></tr></table></figure></p>
<p>从定义可以看出，每个标志对应 32 位中的一位。安装标志是针对整个文件系统中的所有文件的。例如，如果<code>MS_NOSUID</code>标志为 1，则整个文件系统中所有可执行文件的<code>suid</code>标志位都不起作用了。</p>
<h4 id="安装根文件系统"><a href="#安装根文件系统" class="headerlink" title="安装根文件系统"></a>安装根文件系统</h4><p>当系统启动时，就要在变量<code>ROOT_DEV</code>中寻找包含根文件系统的磁盘主码。当编译内核或向最初的启动装入程序传递一个合适的选项时，根文件系统可以被指定为<code>/dev</code>目录下的一个设备文件。类似地，根文件系统的安装标志存放在<code>root_mountflags</code>变量中。用户可以指定这些标志，这是通过对已编译的内核映像执行<code>/sbin/rdev</code>外部程序，或者向最初的启动装入程序传递一个合适的选项来达到的。根文件系统的安装函数为<code>mount_root()</code>。 </p>
<h4 id="安装一个常规文件系统"><a href="#安装一个常规文件系统" class="headerlink" title="安装一个常规文件系统"></a>安装一个常规文件系统</h4><p>一旦在系统中安装了根文件系统，就可以安装其他的文件系统。每个文件系统都可以安装在系统目录树中的一个目录上。</p>
<p>前面我们介绍了以命令方式来安装文件系统，在用户程序中要安装一个文件系统则可以调用<code>mount()</code>系统调用。<code>mount()</code>系统调用在内核的实现函数为<code>sys_mount()</code>，其代码在<code>fs/namespace.c</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_mount</span><span class="params">(<span class="type">char</span> * dev_name, <span class="type">char</span> * dir_name, <span class="type">char</span> * type,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">void</span> * data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data_page;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> type_page;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> dev_page;</span><br><span class="line">	<span class="type">char</span> *dir_page;</span><br><span class="line">	retval = copy_mount_options (type, &amp;type_page);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	dir_page = getname(dir_name);</span><br><span class="line">	retval = PTR_ERR(dir_page);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dir_page))</span><br><span class="line">		<span class="keyword">goto</span> out1;</span><br><span class="line">	retval = copy_mount_options (dev_name, &amp;dev_page);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out2;</span><br><span class="line">	retval = copy_mount_options (data, &amp;data_page);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out3;</span><br><span class="line">	lock_kernel();</span><br><span class="line">	retval = do_mount((<span class="type">char</span>*)dev_page, dir_page, (<span class="type">char</span>*)type_page, flags, (<span class="type">void</span>*)data_page);</span><br><span class="line">	unlock_kernel();</span><br><span class="line">	free_page(data_page);</span><br><span class="line">out3:</span><br><span class="line">	free_page(dev_page);</span><br><span class="line">out2:</span><br><span class="line">	putname(dir_page);</span><br><span class="line">out1:</span><br><span class="line">	free_page(type_page);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出进一步的解释。</p>
<ul>
<li>参数<code>dev_name</code>为待安装文件系统所在设备的路径名，如果不需要就为空(例如，当待安装的是基于网络的文件系统时)；<code>dir_name</code>则是安装点(空闲目录)的路径名；<code>type</code>是文件系统的类型，必须是已注册文件系统的字符串名(如“Ext2”，“MSDOS”等)；<code>flags</code>是安装模式，如前面所述。<code>data</code>指向一个与文件系统相关的数据结构(可以为<code>NULL</code>)。</li>
<li><code>copy_mount_options()</code>和<code>getname()</code>函数将结构形式或字符串形式的参数值从用户空间拷贝到内核空间。这些参数值的长度均以一个页面为限，但是<code>getname()</code>在复制时遇到字符串结尾符“\0”就停止，并返回指向该字符串的指针；而<code>copy_mount_options()</code>则拷贝整个页面，并返回该页面的起始地址。</li>
</ul>
<p>该函数调用的主要函数为<code>do_mount()</code>，<code>do_mount()</code>执行期间要加内核锁，不过这个锁是针对<code>SMP</code>，我们暂不考虑。<code>do_mount()</code>的实现代码在<code>fs/namespace.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_mount</span><span class="params">(<span class="type">char</span> * dev_name, <span class="type">char</span> * dir_name, <span class="type">char</span> *type_page,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">void</span> *data_page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span></span><br><span class="line">	<span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mnt_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* Discard magic */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL)</span><br><span class="line">		flags &amp;= ~MS_MGC_MSK;</span><br><span class="line">	<span class="comment">/* Basic sanity checks */</span></span><br><span class="line">	<span class="keyword">if</span> (!dir_name || !*dir_name || !<span class="built_in">memchr</span>(dir_name, <span class="number">0</span>, PAGE_SIZE))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (dev_name &amp;&amp; !<span class="built_in">memchr</span>(dev_name, <span class="number">0</span>, PAGE_SIZE))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">/* Separate the per-mountpoint flags */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MS_NOSUID)</span><br><span class="line">		mnt_flags |= MNT_NOSUID;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MS_NODEV)</span><br><span class="line">		mnt_flags |= MNT_NODEV;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MS_NOEXEC)</span><br><span class="line">		mnt_flags |= MNT_NOEXEC;</span><br><span class="line">	flags &amp;= ~(MS_NOSUID|MS_NOEXEC|MS_NODEV);</span><br><span class="line">	<span class="comment">/* ... and get the mountpoint */</span></span><br><span class="line">	<span class="keyword">if</span> (path_init(dir_name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, &amp;nd))</span><br><span class="line">		retval = path_walk(dir_name, &amp;nd);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MS_REMOUNT)</span><br><span class="line">		retval = do_remount(&amp;nd, flags &amp; ~MS_REMOUNT, mnt_flags, data_page);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MS_BIND)</span><br><span class="line">		retval = do_loopback(&amp;nd, dev_name, flags &amp; MS_REC);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MS_MOVE)</span><br><span class="line">		retval = do_move_mount(&amp;nd, dev_name); </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		retval = do_add_mount(&amp;nd, type_page, flags, mnt_flags, dev_name, data_page);</span><br><span class="line">	path_release(&amp;nd);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面对函数中的主要代码给予解释。</p>
<ul>
<li><code>MS_MGC_VAL</code>和<code>MS_MGC_MSK</code>是在以前的版本中定义的安装标志和掩码，现在的安装标志中已经不使用这些魔数了，因此，当还有这个魔数时，则丢弃它。</li>
<li>对参数<code>dir_name</code>和<code>dev_name</code>进行基本检查，注意<code>!dir_name</code>和<code>!*dir_name</code>的不同，前者指指向字符串的指针为不为空，而后者指字符串不为空。<code>memchr()</code>函数在指定长度的字符串中寻找指定的字符，如果字符串中没有结尾符“\0”，也是一种错误。前面已说过，对于基于网络的文件系统<code>dev_name</code>可以为空。</li>
<li>把安装标志为<code>MS_NOSUID、MS_NOEXEC</code>和<code>MS_NODEV</code>的 3 个标志位从<code>flags</code>分离出来，放在局部安装标志变量<code>mnt_flags</code>中。</li>
<li>函数<code>path_init()</code>和<code>path_walk()</code>寻找安装点的<code>dentry</code>数据结构，找到的<code>dentry</code>结构存放在局部变量<code>nd</code>的<code>dentry</code>域中。</li>
<li>如果<code>flags</code>中的<code>MS_REMOUNT</code>标志位为 1，就表示所要求的只是改变一个原已安装设备的安装方式，例如从“只读“安装方式改为“可写”安装方式，这是通过调用<code>do_remount()</code>函数完成的。</li>
<li>如果<code>flags</code>中的<code>MS_BIND</code>标志位为 1，就表示把一个“回接”设备捆绑到另一个对象上。回接设备是一种特殊的设备(虚拟设备)，而实际上并不是一种真正设备，而是一种机制，这种机制提供了把回接设备回接到某个可访问的常规文件或块设备的手段。通常在<code>/dev</code>目录中有<code>/dev/loop0</code>和<code>/dev/loop1</code>两个回接设备文件。调用<code>do_loopback()</code>来实现回接设备的安装。</li>
<li>如果<code>flags</code>中的<code>MS_MOVE</code>标志位为 1，就表示把一个已安装的设备可以移到另一个安装点，这是通过调用<code>do_move_mount()</code>函数来实现的。</li>
<li>如果不是以上 3 种情况，那就是一般的安装请求，于是把安装点加入到目录树中，这是通过调用<code>do_add_mount()</code>函数来实现的，而<code>do_add_mount()</code>首先调用<code>do_kern_mount()</code>函数形成一个安装点，该函数的代码在<code>fs/super.c</code>中：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vfsmount *<span class="title function_">do_kern_mount</span><span class="params">(<span class="type">char</span> *type, <span class="type">int</span> flags, <span class="type">char</span> *name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">fstype</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!type || !<span class="built_in">memchr</span>(type, <span class="number">0</span>, PAGE_SIZE))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we need capabilities... */</span></span><br><span class="line">	<span class="keyword">if</span> (!capable(CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EPERM);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ... filesystem driver... */</span> </span><br><span class="line"></span><br><span class="line">	fstype = get_fs_type(type);</span><br><span class="line">	<span class="keyword">if</span> (!fstype)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">	<span class="comment">/* ... allocated vfsmount... */</span></span><br><span class="line">	mnt = alloc_vfsmnt();</span><br><span class="line">	<span class="keyword">if</span> (!mnt) &#123;</span><br><span class="line">		mnt = ERR_PTR(-ENOMEM);</span><br><span class="line">		<span class="keyword">goto</span> fs_out;</span><br><span class="line">	&#125;</span><br><span class="line">	set_devname(mnt, name);</span><br><span class="line">	<span class="comment">/* get locked superblock */</span></span><br><span class="line">	<span class="keyword">if</span> (fstype-&gt;fs_flags &amp; FS_REQUIRES_DEV)</span><br><span class="line">		sb = get_sb_bdev(fstype, name, flags, data);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (fstype-&gt;fs_flags &amp; FS_SINGLE)</span><br><span class="line">		sb = get_sb_single(fstype, flags, data);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sb = get_sb_nodev(fstype, flags, data);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(sb)) &#123;</span><br><span class="line">		free_vfsmnt(mnt);</span><br><span class="line">		mnt = (<span class="keyword">struct</span> vfsmount *)sb;</span><br><span class="line">		<span class="keyword">goto</span> fs_out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fstype-&gt;fs_flags &amp; FS_NOMOUNT)</span><br><span class="line">		sb-&gt;s_flags |= MS_NOUSER;</span><br><span class="line"></span><br><span class="line">	mnt-&gt;mnt_sb = sb;</span><br><span class="line">	mnt-&gt;mnt_root = dget(sb-&gt;s_root);</span><br><span class="line">	mnt-&gt;mnt_mountpoint = mnt-&gt;mnt_root;</span><br><span class="line">	mnt-&gt;mnt_parent = mnt;</span><br><span class="line">	up_write(&amp;sb-&gt;s_umount);</span><br><span class="line">fs_out:</span><br><span class="line">	put_filesystem(fstype);</span><br><span class="line">	<span class="keyword">return</span> mnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对该函数的解释如下。</p>
<ul>
<li>只有系统管理员才具有安装一个设备的权力，因此首先要检查当前进程是否具有这种权限。</li>
<li><code>get_fs_type()</code>函数根据具体文件系统的类型名在<code>file_system_file</code>链表中找到相应的结构。</li>
<li><code>alloc_vfsmnt()</code>函数调用<code>slab</code>分配器给类型为<code>vfsmount</code>结构的局部变量<code>mnt</code>分配空间，并进行相应的初始化。</li>
<li><code>set_devname()</code>函数设置设备名。</li>
<li>一般的文件系统类型要求有物理的设备作为其物质基础，如果<code>fs_flags</code>中的<code>FS_REQUIRES_DEV</code>标志位为 1，说明这就是正常的文件系统类型，如<code>Ext2、mnix</code>等。对于这种文件系统类型，通过调用<code>get_sb_bdev()</code>从待安装设备上读其超级块。</li>
<li>如果<code>fs_flags</code>中的<code>FS_SINGLE</code>标志位为 1，说明整个文件系统只有一个类型，也就是说，这是一种虚拟的文件系统类型。这种文件类型在安装了同类型的第 1 个“设备”，通过调用<code>get_sb_single()</code>创建了超级块<code>super_block</code>结构后，再安装的同类型设备就共享这个数据结构。但是像<code>Ext2</code>这样的文件系统类型在每个具体设备上都有一个超级块。</li>
<li>还有些文件系统类型的<code>fs_flags</code>中的<code>FS_NOMOUNT、FS_REUIRE_DEV</code>以及<code>FS_SINGLE</code>标志位全都为 0，那么这些所谓的文件系统其实是“虚拟的”，通常只是用来实现某种机制或者规程，所以根本就没有对应的物理设备。对于这样的文件系统类型都是通过<code>get_sb_nodev()</code>来生成一个<code>super_block</code>结构的。</li>
<li>如果文件类型<code>fs_flags</code>的<code>FS_NOMOUNT</code>标志位为 1，说明根本就没有用户进行安装，因此，把超级块中的<code>MS_NOUSER</code>标志位置 1。</li>
<li><code>mnt-&gt;mnt_sb</code>指向所安装设备的超级块<code>sb</code>；<code>mnt-&gt;mnt_root</code>指向其超级块的根<code>b-&gt;s_root</code>，<code>dget()</code>函数把<code>dentry</code>的引用计数<code>count</code>加 1；<code>mnt-&gt;mnt_mountpoint</code>也指向超级块的根，而<code>mnt-&gt;mnt_parent</code>指向自己。到此为止，仅仅形成了一个安装点，但还没有把这个安装点挂接在目录树上。</li>
</ul>
<p>下面我们来看<code>do_add_mount()</code>的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_add_mount</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">char</span> *type, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params"> <span class="type">int</span> mnt_flags, <span class="type">char</span> *name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span> =</span> do_kern_mount(type, flags, name, data);</span><br><span class="line">	<span class="type">int</span> err = PTR_ERR(mnt);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(mnt))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	down(&amp;mount_sem);</span><br><span class="line">	<span class="comment">/* Something was mounted here while we slept */</span></span><br><span class="line">	<span class="keyword">while</span>(d_mountpoint(nd-&gt;dentry) &amp;&amp; follow_down(&amp;nd-&gt;mnt, &amp;nd-&gt;dentry)) ;</span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (!check_mnt(nd-&gt;mnt))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	<span class="comment">/* Refuse the same filesystem on the same mount point */</span></span><br><span class="line">	err = -EBUSY;</span><br><span class="line">	<span class="keyword">if</span> (nd-&gt;mnt-&gt;mnt_sb == mnt-&gt;mnt_sb &amp;&amp; nd-&gt;mnt-&gt;mnt_root == nd-&gt;dentry)</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	mnt-&gt;mnt_flags = mnt_flags;</span><br><span class="line">	err = graft_tree(mnt, nd);</span><br><span class="line">nlock:</span><br><span class="line">	up(&amp;mount_sem);</span><br><span class="line">	mntput(mnt);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是对以上代码的解释。</p>
<ul>
<li>首先检查<code>do_kern_mount()</code>所形成的安装点是否有效。</li>
<li>在<code>do_mount()</code>函数中，<code>path_init()</code>和<code>path_walk()</code>函数已经找到了安装点的<code>dentry</code>结构、<code>inode</code>结构以及<code>vfsmount</code>结构，并存放在类型为<code>nameidata</code>的局部变量<code>nd</code>中，在<code>do_add_mount()</code>中通过参数传递了过来。</li>
<li>但是，在<code>do_kern_mount()</code>函数中从设备上读入超级块的过程是个较为漫长的过程，当前进程在等待从设备上读入超级块的过程中几乎可肯定要睡眠，这样就有可能另一个进程捷足先登抢先将另一个设备安装到了同一个安装点上。<code>d_mountpoint()</code>函数就是检查是否发生了这种情况。如果确实发生了这种情况，其对策就是调用<code>follow_down()</code>前进到已安装设备的根节点，并且通过<code>while</code>循环进一步检测新的安装点，直到找到一个空安装点为止。</li>
<li>如果在同一个安装点上要安装两个同样的文件系统，则出错。</li>
<li>调用<code>graft_tree()</code>把<code>mnt</code>与安装树挂接起来，完成最终的安装。</li>
<li>至此，设备的安装就完成了。</li>
</ul>
<h3 id="文件系统的卸载"><a href="#文件系统的卸载" class="headerlink" title="文件系统的卸载"></a>文件系统的卸载</h3><p>如果文件系统中的文件当前正在使用，该文件系统是不能被卸载的。如果文件系统中的文件或目录正在使用，则<code>VFS</code>索引节点高速缓存中可能包含相应的<code>VFS</code>索引节点。根据文件系统所在设备的标识符，检查在索引节点高速缓存中是否有来自该文件系统的<code>VFS</code>索引节点，如果有且使用计数大于 0，则说明该文件系统正在被使用，因此，该文件系统不能被卸载。否则，查看对应的<code>VFS</code>超级块，如果该文件系统的<code>VFS</code>超级块标志为“脏”，则必须将超级块信息写回磁盘。上述过程结束之后，对应的<code>VFS</code>超级块被释放，<code>vfsmount</code>数据结构将从<code>vfsmntlist</code>链表中断开并被释放。具体的实现代码为<code>fs/super.c</code>中的<code>sysy_umount()</code>函数，在此不再进行详细的讨论。</p>
<h2 id="限额机制"><a href="#限额机制" class="headerlink" title="限额机制"></a>限额机制</h2><p>限额机制对一个用户可分配的文件数目和可使用的磁盘空间设置了限制。限制有软限制和硬限制之分，硬限制是绝对不允许超过的，而软限制则由系统管理员来确定。当用户占用的资源超过软限制时，系统开始启动定时机制，并在用户的终端上显示警告信息，但并不终止用户进程的运行，在<code>include/linux/quota.h</code>中有如下宏定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_IQ_TIME 604800 <span class="comment">/* (7*24*60*60) =1 周 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_DQ_TIME 604800 <span class="comment">/* (7*24*60*60) =1 周 */</span></span></span><br></pre></td></tr></table></figure></p>
<p>分别是超过索引节点软限制的最长允许时间和超过块的软限制的最长允许时间。</p>
<p>首先，在编译内核时，要选择“支持限额机制”一项，默认情况下，<code>Linux</code>不使用限额机制。如果使用了限额机制，每一个安装的文件系统都与一个限额文件相联系，限额文件通常驻留在文件系统的根目录里，它实际是一组以用户标识号来索引的限额记录，每个限额记录可称为一个限额块，其数据结构如下(在<code>inclue/linux/quota.h</code>中定义)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dqblk</span> &#123;</span></span><br><span class="line">	__u32 dqb_bhardlimit; <span class="comment">/* 块的硬限制*/</span></span><br><span class="line">	__u32 dqb_bsoftlimit; <span class="comment">/* 块的软限制 */</span></span><br><span class="line">	__u32 dqb_curblocks; <span class="comment">/* 当前占有的块数 */</span></span><br><span class="line">	__u32 dqb_ihardlimit; <span class="comment">/* 索引节点的硬限制 */</span></span><br><span class="line">	__u32 dqb_isoftlimit; <span class="comment">/* 索引节点的软限制 */</span></span><br><span class="line">	__u32 dqb_curinodes; <span class="comment">/* 当前占用的索引节点数 */</span></span><br><span class="line">	<span class="type">time_t</span> dqb_btime; <span class="comment">/* 块的软限制变为硬限制前，剩余的警告次数*/</span></span><br><span class="line">	<span class="type">time_t</span> dqb_itime; <span class="comment">/* 索引节点的软限制变为硬限制前，剩余的警告次数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>限额块调入内存后，用哈希表来管理，这就要用到另一个结构<code>dquot</code>(也在<code>inclue/linux/quota.h</code>中定义)，其数据结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dquot</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dq_hash</span>;</span> <span class="comment">/*在内存的哈希表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dq_inuse</span>;</span> <span class="comment">/*正在使用的限额块组成的链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dq_free</span>;</span> <span class="comment">/* 空闲限额块组成的链表 */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> dq_wait_lock; <span class="comment">/* 指向加锁限额块的等待队列*/</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> dq_wait_free; <span class="comment">/* 指向未用限额块的等待队列*/</span></span><br><span class="line">	<span class="type">int</span> dq_count; <span class="comment">/* 引用计数 */</span></span><br><span class="line">	<span class="comment">/* fields after this point are cleared when invalidating */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">dq_sb</span>;</span> <span class="comment">/* superblock this applies to */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> dq_id; <span class="comment">/* ID this applies to (uid, gid) */</span></span><br><span class="line">	<span class="type">kdev_t</span> dq_dev; <span class="comment">/* Device this applies to */</span></span><br><span class="line">	<span class="type">short</span> dq_type; <span class="comment">/* Type of quota */</span></span><br><span class="line">	<span class="type">short</span> dq_flags; <span class="comment">/* See DQ_* */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> dq_referenced; <span class="comment">/* Number of times this dquot was</span></span><br><span class="line"><span class="comment">	referenced during its lifetime */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dqblk</span> <span class="title">dq_dqb</span>;</span> <span class="comment">/* Diskquota usage */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>哈希表是用文件系统所在的设备号和用户标识号为散列关键值的。<code>vfs</code>的索引节点结构中有一个指向<code>dquot</code>结构的指针。也就是说，调入内存的索引节点都要与相应的<code>dquot</code>结构联系，<code>dquot</code>结构中，引用计数就是反映了当前有几个索引节点与之联系，只有在引用计数为 0 时，才将该结构放入空闲链表中。</p>
<p>如果使用了限额机制，则当有新的块分配请求，系统要以文件拥有者的标识号为索引去查找限额文件中相应的限额块，如果限额并没有满，则接受请求，并把它加入使用计数中。如果已达到或超过限额，则拒绝请求，并返回错误信息。</p>
<h2 id="文件系统的系统调用"><a href="#文件系统的系统调用" class="headerlink" title="文件系统的系统调用"></a>文件系统的系统调用</h2><h3 id="open系统调用"><a href="#open系统调用" class="headerlink" title="open系统调用"></a>open系统调用</h3><p>进程要访问一个文件，必须首先获得一个文件描述符，这是通过<code>open</code>系统调用来完成的。该系统调用是用来获得欲访问文件的文件描述符，如果文件并不存在，则还可以用它来创建一个新文件。其函数为<code>sys_open()</code>，在<code>fs/open.c</code>中定义，函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename, <span class="type">int</span> flags, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> * tmp;</span><br><span class="line">	<span class="type">int</span> fd, error;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BITS_PER_LONG != 32</span></span><br><span class="line">	flags |= O_LARGEFILE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	tmp = getname(filename);</span><br><span class="line">	fd = PTR_ERR(tmp);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(tmp)) &#123;</span><br><span class="line">		fd = get_unused_fd();</span><br><span class="line">		<span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> filp_open(tmp, flags, mode);</span><br><span class="line">			error = PTR_ERR(f);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(f))</span><br><span class="line">				<span class="keyword">goto</span> out_error;</span><br><span class="line">			fd_install(fd, f);</span><br><span class="line">		&#125;</span><br><span class="line">out:</span><br><span class="line">		putname(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fd; </span><br><span class="line"></span><br><span class="line">out_error:</span><br><span class="line">	put_unused_fd(fd);</span><br><span class="line">	fd = error;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1．入口参数</p>
<ul>
<li><code>filename</code>：欲打开文件的路径。</li>
<li><code>flags</code>：规定如何打开该文件，它必须取下列 3 个值之一。<ul>
<li><code>O_RDONLY</code>以只读方式打开文件</li>
<li><code>O_WRONLY</code>以只写方式打开文件</li>
<li><code>O_RDWR</code>以读和写的方式打开文件</li>
<li>此外，还可以用或运算对下列标志值任意组合。<ul>
<li><code>O_CREAT</code>打开文件，如果文件不存在则建立文件</li>
<li><code>O_EXCL</code>如果已经置<code>O_CREAT</code>且文件存在，则强制<code>open()</code>失败</li>
<li><code>O_TRUNC</code>将文件的长度截为 0</li>
<li><code>O_APPEND</code>强制<code>write()</code>从文件尾开始</li>
</ul>
</li>
<li>对于终端文件，这 4 个标志是没有任何意义的，另提供了两个新的标志。<ul>
<li><code>O_NOCTTY</code>停止这个终端作为控制终端</li>
<li><code>O_NONBLOCK</code>使<code>open()</code>、<code>read()</code>、<code>write()</code>不被阻塞。</li>
</ul>
</li>
<li>这些标志的符号名称在<code>/include/asmi386/fcntl.h</code>中定义。</li>
</ul>
</li>
<li><code>mode</code>：这个参数实际上是可选的，如果用<code>open()</code>创建一个新文件，则要用到该参数，它用来规定对该文件的所有者、文件的用户组和系统中其他用户的访问权限位。它用或运算对下列符号常量建立所需的组合。<ul>
<li><code>S_IRUSR</code>文件所有者的读权限位</li>
<li><code>S_IWUSR</code>文件所有者的写权限位</li>
<li><code>S_IXUSR</code>文件所有者的执行权限位</li>
<li><code>S_IRGRP</code>文件用户组的读权限位</li>
<li><code>S_IWGRP</code>文件用户组的写权限位</li>
<li><code>S_IXGRP</code>文件用户组的执行权限位</li>
<li><code>S_IROTH</code>文件其他用户的读权限位</li>
<li><code>S_IWOTH</code>文件其他用户的写权限位</li>
<li><code>S_IXOTH</code>文件其他用户的执行权限位</li>
<li>这些标志的符号名称在<code>/include/linux/stat.h</code>中定义。</li>
</ul>
</li>
</ul>
<h4 id="出口参数"><a href="#出口参数" class="headerlink" title="出口参数"></a>出口参数</h4><p>返回一个文件描述符。 </p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p><code>sys_open()</code>主要是调用<code>filp_open()</code>，这个函数也在<code>fs/open.c</code>中，这已在前面做过介绍。</p>
<p>从当前进程的<code>files_struct</code>结构的<code>fd</code>数组中找到第 1 个未使用项，使其指向<code>file</code>结构，将该项的下标作为文件描述符返回，结束。</p>
<p>在以上过程中，如果出错，则将分配的文件描述符、<code>file</code>结构收回，<code>inode</code>也被释放，函数返回一个负数以示出错，其中<code>PTR_ERR()</code>和<code>IS_ERR()</code>是出错处理函数。</p>
<h3 id="read系统调用"><a href="#read系统调用" class="headerlink" title="read系统调用"></a>read系统调用</h3><p>如果通过<code>open</code>调用获得一个文件描述符，而且是用<code>O_RDONLY</code>或<code>O_RDWR</code>标志打开的，就可以用<code>read</code>系统调用从该文件中读取字节。其内核函数在<code>fs/read_write.c</code>中定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">ssize_t</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">char</span> * buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line">	ret = -EBADF;</span><br><span class="line">	file = fget(fd);</span><br><span class="line">	<span class="keyword">if</span> (file) &#123;</span><br><span class="line">		<span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_READ) &#123;</span><br><span class="line">			ret = locks_verify_area ( FLOCK_VERIFY_READ,</span><br><span class="line">			file-&gt;f_dentry-&gt;d_inode,</span><br><span class="line">			file, file-&gt;f_pos, count);</span><br><span class="line">			<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">				<span class="type">ssize_t</span> (*read)(<span class="keyword">struct</span> file *, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">				ret = -EINVAL;</span><br><span class="line">				<span class="keyword">if</span> (file-&gt;f_op &amp;&amp; (read = file-&gt;f_op-&gt;read) != <span class="literal">NULL</span>)</span><br><span class="line">					ret = read(file, buf, count, &amp;file-&gt;f_pos);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">			dnotify_parent(file-&gt;f_dentry, DN_ACCESS);</span><br><span class="line">		fput(file);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="入口参数"><a href="#入口参数" class="headerlink" title="入口参数"></a>入口参数</h4><ul>
<li><code>fd</code>：要读的文件的文件描述符。</li>
<li><code>buf</code>：指向用户内存区中用来存储将读取字节的区域的指针。</li>
<li><code>count</code>：欲读的字节数。 </li>
</ul>
<h4 id="出口参数-1"><a href="#出口参数-1" class="headerlink" title="出口参数"></a>出口参数</h4><p>返回一个整数。在出错时返回-1；否则返回所读的字节数，通常这个数就是<code>count</code>值，但如果请求的字节数超过剩余的字节数，则返回实际读的字节数，例如文件的当前位置在文件尾，则返回值为 0。</p>
<h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><ol>
<li>函数<code>fget()</code>根据打开文件号<code>fd</code>找到该文件已打开文件的<code>file</code>结构。</li>
<li>取得了目标文件的<code>file</code>结构指针，并确认文件是以只读方式打开后，还要检查文件从当前位置<code>f_pos</code>开始的<code>count</code>个字节是否对读操作加上了“强制锁”，这是通过调用<code>locks_verify_area()</code>函数完成的，其代码在<code>fs.h</code>中。</li>
<li>通过了对强制锁的检查后，就是读操作本身了。</li>
<li>如果读操作的返回值大于 0，说明出错，则调用<code>dnotify_parent()</code>报告错误，并释放文件描述符、<code>file</code>结构、<code>inode</code>结构。</li>
</ol>
<h3 id="fcntl系统调用"><a href="#fcntl系统调用" class="headerlink" title="fcntl系统调用"></a>fcntl系统调用</h3><p>这个系统调用功能比较多，可以执行多种操作，其内核函数在<code>fs/fcntl.c</code>中定义。</p>
<h4 id="入口参数-1"><a href="#入口参数-1" class="headerlink" title="入口参数"></a>入口参数</h4><ol>
<li><code>fd</code>：欲访问文件的文件描述符。</li>
<li><code>cmd</code>：要执行的操作的命令，这个参数定义了 10 个标志，下面介绍其中的 5 个，<code>F_DUPFD</code>、<code>F_GETFD</code>、<code>F_SETFD</code>、<code>F_GETFL</code>和<code>F_SETFL</code></li>
<li><code>arg</code>：可选，主要根据<code>cmd</code>来决定是否需要。</li>
</ol>
<h4 id="出口参数-2"><a href="#出口参数-2" class="headerlink" title="出口参数"></a>出口参数</h4><p>根据第二个参数(cmd)的不同，这个返回值也不一样</p>
<h4 id="函数功能"><a href="#函数功能" class="headerlink" title="函数功能"></a>函数功能</h4><ul>
<li>如果第二个参数(cmd)取值是<code>F_DUPFD</code>，则进行复制文件描述符的操作。它需要用到第三个参数<code>arg</code>，这时<code>arg</code>是一个文件描述符，<code>fcntl(fd, F_DUPFD, arg)</code>在<code>files_struct</code>结构中从指定的<code>arg</code>开始搜索空闲的文件描述符，找到第一个后，将<code>fd</code>的内容复制进来，然后将新找到的文件描述符返回。</li>
<li>第二个参数(cmd)取值是<code>F_GETFD</code>，则返回<code>files_struct</code>结构中<code>close_on_exec</code>的值。无需第三个参数。</li>
<li>第二个参数(cmd)取值是<code>F_SETFD</code>，则需要第三个参数，若<code>arg</code>最低位为 1，则对<code>close_on_exec</code>置位，否则清除<code>close_on_exec</code>。</li>
<li>第二个参数(cmd)取值是<code>F_GETFL</code>，则用来读取<code>open</code>系统调用第二个参数设置的标志，即文件的打开方式(<code>O_RDONLY</code>，<code>O_WRONLY</code>，<code>O_APPEND</code>等)，它不需要第三个参数。实际上这时函数返回的是<code>file</code>结构中的<code>flags</code>域。</li>
<li>第二个参数(cmd)取值是<code>F_SETFL</code>，则用来对<code>open</code>系统调用第二个参数设置的标志进行改变，但是它只能对<code>O_APPEND</code>和<code>O_NONBLOCK</code>标志进行改变，这时需要第三个参数<code>arg</code>，用来确定如何改变。函数返回 0 表示操作成功，否则返回-1，并置一个错</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
