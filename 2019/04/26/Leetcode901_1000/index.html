<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Leetcode901. Online Stock SpanWrite a class StockSpanner which collects daily price quotes for some stock, and returns the  span  of that stock’s price for the current day. The span of the stock’s pri">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode901 - 1000">
<meta property="og:url" content="http://yoursite.com/2019/04/26/Leetcode901_1000/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode901. Online Stock SpanWrite a class StockSpanner which collects daily price quotes for some stock, and returns the  span  of that stock’s price for the current day. The span of the stock’s pri">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1632645545.jpg">
<meta property="og:image" content="http://yoursite.com/img/20190827800.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105401.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105402.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105403.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105404.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105405.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105406.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105407.png">
<meta property="og:image" content="http://yoursite.com/img/20190524001.png">
<meta property="og:image" content="http://yoursite.com/img/20190524002.png">
<meta property="og:image" content="http://yoursite.com/img/20190824002.png">
<meta property="og:image" content="http://yoursite.com/img/20190824003.png">
<meta property="og:image" content="http://yoursite.com/img/20190824004.png">
<meta property="og:image" content="http://yoursite.com/img/20190824005.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105408.png">
<meta property="og:image" content="http://yoursite.com/img/1636992467.png">
<meta property="og:image" content="http://yoursite.com/img/1636992495.jpg">
<meta property="og:image" content="http://yoursite.com/img/20190825101.png">
<meta property="og:image" content="http://yoursite.com/img/20190825102.png">
<meta property="og:image" content="http://yoursite.com/img/20190825103.png">
<meta property="article:published_time" content="2019-04-26T12:41:39.000Z">
<meta property="article:modified_time" content="2022-12-26T08:02:39.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1632645545.jpg">

<link rel="canonical" href="http://yoursite.com/2019/04/26/Leetcode901_1000/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>Leetcode901 - 1000 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/26/Leetcode901_1000/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode901 - 1000
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-26 20:41:39" itemprop="dateCreated datePublished" datetime="2019-04-26T20:41:39+08:00">2019-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 16:02:39" itemprop="dateModified" datetime="2022-12-26T16:02:39+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Leetcode901-Online-Stock-Span"><a href="#Leetcode901-Online-Stock-Span" class="headerlink" title="Leetcode901. Online Stock Span"></a>Leetcode901. Online Stock Span</h1><p>Write a class StockSpanner which collects daily price quotes for some stock, and returns the  span  of that stock’s price for the current day.</p>
<p>The span of the stock’s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today’s price.</p>
<p>For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class="line">Output: [null,1,1,1,2,1,4,6]</span><br><span class="line">Explanation:</span><br><span class="line">First, S = StockSpanner() is initialized.  Then:</span><br><span class="line">S.next(100) is called and returns 1,</span><br><span class="line">S.next(80) is called and returns 1,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(70) is called and returns 2,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(75) is called and returns 4,</span><br><span class="line">S.next(85) is called and returns 6.</span><br></pre></td></tr></table></figure></p>
<p>Note that (for example) S.next(75) returned 4, because the last 4 prices (including today’s price of 75) were less than or equal to today’s price.</p>
<p>Note:</p>
<ul>
<li>Calls to StockSpanner.next(int price)will have 1 &lt;= price &lt;= 10^5.</li>
<li>There will be at most 10000 calls to StockSpanner.next per test case.</li>
<li>There will be at most 150000 calls to StockSpanner.next across all test cases.</li>
<li>The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.</li>
</ul>
<p>这道题定义了一个 StockSpanner 的类，有一个 next 函数，每次给当天的股价，让我们返回之前连续多少天都是小于等于当前股价。</p>
<p>可以找连续递增的子数组的长度么，其实也是不行的，就拿题目中的例子来说吧 [100, 80, 60, 70, 60, 75, 85]，数字 75 前面有三天是比它小的，但是这三天不是有序的，是先增后减的，那怎么办呢？我们先从简单的情况分析，假如当前的股价要小于前一天的，那么连续性直接被打破了，所以此时直接返回1就行了。但是假如大于等于前一天股价的话，情况就比较 tricky 了，因为此时所有小于等于前一天股价的天数肯定也是小于等于当前的，那么我们就需要知道是哪一天的股价刚好大于前一天的股价，然后用这一天的股价跟当前的股价进行比较，若大于当前股价，说明当前的连续天数就是前一天的连续天数加1，而若小于当前股价，我们又要重复这个过程，去比较刚好大于之前那个的股价。所以我们需要知道对于每一天，往前推刚好大于当前股价的是哪一天，用一个数组 pre，其中 pre[i] 表示从第i天往前推刚好大于第i天的股价的是第 pre[i] 天。接下来看如何实现 next 函数，首先将当前股价加入 nums 数组，然后前一天在数组中的位置就是 (int)nums.size()-2。再来想想 corner case 的情况，假如当前是数组中的第0天，前面没有任何股价了，我们的 pre[0] 就赋值为 -1 就行了，怎么知道当前是否是第0天，就看 pre 数组是否为空。再有就是由于i要不断去 pre 数组中找到之前的天数，所以最终i是有可能到达 pre[0] 的，那么就要判断当i为 -1 时，也要停止循环。循环的最后一个条件就是当之前的股价小于等当前的估计 price 时，才进行循环，这个前面讲过了，循环内部就是将 pre[i] 赋值给i，这样就完成了跳到之前天的操作。while 循环结束后要将i加入到 pre 数组，因为这个i就是从当前天往前推，一个大于当前股价的那一天，有了这个i，就可以计算出连续天数了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StockSpanner</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> price)</span> </span>&#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(price);</span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pre.<span class="built_in">empty</span>() &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &lt;= price) &#123;</span><br><span class="line">            i = pre[i];</span><br><span class="line">        &#125;</span><br><span class="line">        pre.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)pre.<span class="built_in">size</span>() - <span class="number">1</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums, pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们还可以使用栈来做，里面放一个 pair 对儿，分别是当前的股价和之前比其小的连续天数。在 next 函数中，使用一个 cnt 变量，初始化为1。还是要个 while 循环，其实核心的本质都是一样的，循环的条件首先是栈不能为空，并且栈顶元素的股价小于等于当前股价，那么 cnt 就加上栈顶元素的连续天数，可以感受到跟上面解法在这里的些许不同之处了吧，之前是一直找到第一个大于当前股价的天数在数组中的位置，然后相减得到连续天数，这里是在找的过程中直接累加连续天数，最终都可以得到正确的结果，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StockSpanner</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>().first &lt;= price) &#123;</span><br><span class="line">            cnt += st.<span class="built_in">top</span>().second; st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(&#123;price, cnt&#125;);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode904-Fruit-Into-Baskets"><a href="#Leetcode904-Fruit-Into-Baskets" class="headerlink" title="Leetcode904. Fruit Into Baskets"></a>Leetcode904. Fruit Into Baskets</h1><p>In a row of trees, the i-th tree produces fruit with type tree[i].</p>
<p>You start at any tree of your choice, then repeatedly perform the following steps:</p>
<p>Add one piece of fruit from this tree to your baskets.  If you cannot, stop.<br>Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.<br>Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.</p>
<p>You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.</p>
<p>What is the total amount of fruit you can collect with this procedure?</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can collect [1,2,1].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,2,2]</span><br><span class="line">Output: 3 Explanation: We can collect [1,2,2].</span><br><span class="line">If we started at the first tree, we would only collect [0, 1].</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,2,2]</span><br><span class="line">Output: 4 Explanation: We can collect [2,3,2,2].</span><br><span class="line">If we started at the first tree, we would only collect [1, 2].</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">Output: 5  Explanation: We can collect [1,2,1,1,2].</span><br><span class="line">If we started at the first tree or the eighth tree, we would only collect 4 fruits.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= tree.length &lt;= 40000</li>
<li>0 &lt;= tree[i] &lt; tree.length</li>
</ul>
<p>这道题说是给了我们一排树，每棵树产的水果种类是 tree[i]，说是现在有两种操作，第一种是将当前树的水果加入果篮中，若不能加则停止；第二种是移动到下一个树，若没有下一棵树，则停止。现在我们有两个果篮，可以从任意一个树的位置开始，但是必须按顺序执行操作一和二，问我们最多能收集多少个水果。说实话这道题的题目描述确实不太清晰，博主看了很多遍才明白意思，论坛上也有很多吐槽的帖子，但实际上这道题的本质就是从任意位置开始，若最多只能收集两种水果，问最多能收集多少个水果。那么再进一步提取，其实就是最多有两个不同字符的最长子串的长度，跟之前那道 Longest Substring with At Most Two Distinct Characters 一模一样，只不过换了一个背景，代码基本都可以直接使用的，博主感觉这样出题有点不太好吧，完全重复了。之前那题的四种解法这里完全都可以使用，先来看第一种，使用一个 HashMap 来记录每个水果出现次数，当 HashMap 中当映射数量超过两个的时候，我们需要删掉一个映射，做法是滑动窗口的左边界 start 的水果映射值减1，若此时减到0了，则删除这个映射，否则左边界右移一位。当映射数量回到两个的时候，用当前窗口的大小来更新结果 res 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&amp; tree)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, start = <span class="number">0</span>, n = tree.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; fruitCnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++fruitCnt[tree[i]];</span><br><span class="line">            <span class="keyword">while</span> (fruitCnt.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--fruitCnt[tree[start]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    fruitCnt.<span class="built_in">erase</span>(tree[start]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++start;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们除了用 HashMap 来映射字符出现的个数，我们还可以映射每个数字最新的坐标，比如题目中的例子 [0,1,2,2]，遇到第一个0，映射其坐标0，遇到1，映射其坐标1，当遇到2时，映射其坐标2，每次我们都判断当前 HashMap 中的映射数，如果大于2的时候，那么需要删掉一个映射，我们还是从 start=0 时开始向右找，看每个字符在 HashMap 中的映射值是否等于当前坐标 start，比如0，HashMap 此时映射值为0，等于 left 的0，那么我们把0删掉，start 自增1，再更新结果，以此类推直至遍历完整个数组，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&amp; tree)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, start = <span class="number">0</span>, n = tree.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; fruitPos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            fruitPos[tree[i]] = i;</span><br><span class="line">            <span class="keyword">while</span> (fruitPos.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fruitPos[tree[start]] == start) &#123;</span><br><span class="line">                    fruitPos.<span class="built_in">erase</span>(tree[start]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++start;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后来又在网上看到了一种解法，这种解法是维护一个滑动窗口 sliding window，指针 left 指向起始位置，right 指向 window 的最后一个位置，用于定位 left 的下一个跳转位置，思路如下：</p>
<ul>
<li>若当前字符和前一个字符相同，继续循环。</li>
<li>若不同，看当前字符和 right 指的字符是否相同：</li>
<li>若相同，left 不变，右边跳到 i - 1。</li>
<li>若不同，更新结果，left 变为 right+1，right 变为 i - 1。</li>
</ul>
<p>最后需要注意在循环结束后，我们还要比较结果 res 和 n - left 的大小，返回大的，这是由于如果数组是 [5,3,5,2,1,1,1]，那么当 left=3 时，i=5,6 的时候，都是继续循环，当i加到7时，跳出了循环，而此时正确答案应为 [2,1,1,1] 这4个数字，而我们的结果 res 只更新到了 [5,3,5] 这3个数字，所以我们最后要判断 n - left 和结果 res 的大小。</p>
<p>另外需要说明的是这种解法仅适用于于不同字符数为2个的情况，如果为k个的话，还是需要用上面两种解法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">-1</span>, n = tree.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[i] == tree[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; tree[right] != tree[i]) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, i - left);</span><br><span class="line">                left = right + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(n - left, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>还有一种不使用 HashMap 的解法，这里我们使用若干个变量，其中 cur 为当前最长子数组的长度，a和b为当前候选的两个不同的水果种类，cntB 为水果b的连续个数。我们遍历所有数字，假如遇到的水果种类是a和b中的任意一个，那么 cur 可以自增1，否则 cntB 自增1，因为若是新水果种类的话，默认已经将a种类淘汰了，此时候选水果由类型b和这个新类型水果构成，所以当前长度是 cntB+1。然后再来更新 cntB，假如当前水果种类是b的话，cntB 自增1，否则重置为1，因为 cntB 统计的就是水果种类b的连续个数。然后再来判断，若当前种类不是b，则此时a赋值为b， b赋值为新种类。最后不要忘了用 cur 来更新结果 res，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cur = <span class="number">0</span>, cntB = <span class="number">0</span>, a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fruit : tree) &#123;</span><br><span class="line">            cur = (fruit == a || fruit == b) ? cur + <span class="number">1</span> : cntB + <span class="number">1</span>;</span><br><span class="line">            cntB = (fruit == b) ? cntB + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (b != fruit) &#123;</span><br><span class="line">                a = b; b = fruit;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode905-Sort-Array-By-Parity"><a href="#Leetcode905-Sort-Array-By-Parity" class="headerlink" title="Leetcode905. Sort Array By Parity"></a>Leetcode905. Sort Array By Parity</h1><p>Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.</p>
<p>You may return any answer array that satisfies this condition.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,2,4]</span><br><span class="line">Output: [2,4,3,1]</span><br><span class="line">The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 5000<br>0 &lt;= A[i] &lt;= 5000</p>
<p>将奇数和偶数分类。。。简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArrayByParity</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] % <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; A.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(A[j] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="type">int</span> temp = A[j];</span><br><span class="line">                        A[j] = A[i];</span><br><span class="line">                        A[i] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode907-Sum-of-Subarray-Minimums"><a href="#Leetcode907-Sum-of-Subarray-Minimums" class="headerlink" title="Leetcode907. Sum of Subarray Minimums"></a>Leetcode907. Sum of Subarray Minimums</h1><p>Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.</p>
<p>Since the answer may be large, return the answer modulo 10^9 + 7.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,2,4]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].</span><br><span class="line">Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 30000</li>
<li>1 &lt;= A[i] &lt;= 30000</li>
</ul>
<p>这道题给了一个数组，对于所有的子数组，找到最小值，并返回累加结果，并对一个超大数取余。由于我们只关心子数组中的最小值，所以对于数组中的任意一个数字，需要知道其是多少个子数组的最小值。就拿题目中的例子 [3,1,2,4] 来分析，开始遍历到3的时候，其本身就是一个子数组，最小值也是其本身，累加到结果 res 中，此时 res=3，然后看下个数1，是小于3的，此时新产生了两个子数组 [1] 和 [3,1]，且最小值都是1，此时在结果中就累加了 2，此时 res=5。接下来的数字是2，大于之前的1，此时会新产生三个子数组，其本身单独会产生一个子数组 [2]，可以先把这个2累加到结果 res 中，然后就是 [1,2] 和 [3,1,2]，可以发现新产生的这两个子数组的最小值还是1，跟之前计算数字1的时候一样，可以直接将以1结尾的子数组最小值之和加起来，那么以2结尾的子数组最小值之和就是 2+2=4，此时 res=9。对于最后一个数字4，其单独产生一个子数组 [4]，还会再产生三个子数组 [3,1,2,4], [1,2,4], [2,4]，其并不会对子数组的最小值产生影响，所以直接加上以2结尾的子数组最小值之和，总共就是 4+4=8，最终 res=17。</p>
<p>分析到这里，就知道我们其实关心的是以某个数字结尾时的子数组最小值之和，可以用一个一维数组 dp，其中<code>dp[i]</code>表示以数字<code>A[i]</code>结尾的所有子数组最小值之和，将<code>dp[0]</code>初始化为<code>A[0]</code>，结果<code>res</code>也初始化为<code>A[0]</code>。然后从第二个数字开始遍历，若大于等于前一个数字，则当前<code>dp[i]</code>赋值为<code>dp[i-1]+A[i]</code>，前面的分析已经解释了，当前数字<code>A[i]</code>组成了新的子数组，同时由于<code>A[i]</code>不会影响最小值，所以要把之前的最小值之和再加一遍。假如小于前一个数字，就需要向前遍历，去找到第一个小于<code>A[i]</code>的位置<code>j</code>，假如<code>j</code>小于0，表示前面所有的数字都是小于<code>A[i]</code>的，那么<code>A[i]</code>是前面<code>i+1</code>个以<code>A[i]</code>结尾的子数组的最小值，累加和为<code>(i+1) x A[i]</code>，若j大于等于0，则需要分成两部分累加，<code>dp[j] + (i-j)xA[i]</code>，这个也不难理解，前面有<code>i-j</code>个以<code>A[i]</code>为结尾的子数组的最小值是<code>A[i]</code>，而再前面的子数组的最小值就不是<code>A[i]</code>了，但是还是需要加上一遍其本身的最小值之和，因为每个子数组末尾都加上<code>A[i]</code>均可以组成一个新的子数组，最终的结果<code>res</code>就是将<code>dp</code>数组累加起来即可，别忘了对超大数取余，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = A[<span class="number">0</span>], n = A.<span class="built_in">size</span>(), M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt;= A[i - <span class="number">1</span>]) dp[i] = dp[i - <span class="number">1</span>] + A[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[i] &lt; A[j]) --j;</span><br><span class="line">                dp[i] = (j &lt; <span class="number">0</span>) ? (i + <span class="number">1</span>) * A[i] : (dp[j] + (i - j) * A[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res = (res + dp[i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的方法虽然 work，但不是很高效，原因是在向前找第一个小于当前的数字，每次都要线性遍历一遍，造成了平方级的时间复杂度。而找每个数字的前小数字或是后小数字，正是单调栈擅长的，可以参考博主之前的总结贴 LeetCode Monotonous Stack Summary 单调栈小结。这里我们用一个单调栈来保存之前一个小的数字的位置，栈里先提前放一个 -1，作用会在之后讲解。还是需要一个 dp 数组，跟上面的定义基本一样，但是为了避免数组越界，将长度初始化为 n+1，其中 dp[i] 表示以数字 A[i-1] 结尾的所有子数组最小值之和。对数组进行遍历，当栈顶元素不是 -1 且 A[i] 小于等于栈顶元素，则将栈顶元素移除。这样栈顶元素就是前面第一个比 A[i] 小的数字，此时 dp[i+1] 更新还是跟之前一样，分为两个部分，由于知道了前面第一个小于 A[i] 的数字位置，用当前位置减去栈顶元素位置再乘以 A[i]，就是以 A[i] 为结尾且最小值为 A[i] 的子数组的最小值之和，而栈顶元素之前的子数组就不受 A[i] 影响了，直接将其 dp 值加上即可。将当前位置压入栈，并将 dp[i+1] 累加到结果 res，同时对超大值取余，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = A.<span class="built_in">size</span>(), M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st&#123;&#123;<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">top</span>() != <span class="number">-1</span> &amp;&amp; A[i] &lt;= A[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i + <span class="number">1</span>] = (dp[st.<span class="built_in">top</span>() + <span class="number">1</span>] + (i - st.<span class="built_in">top</span>()) * A[i]) % M;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">            res = (res + dp[i + <span class="number">1</span>]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再来看一种解法，由于对于每个数字，只要知道了其前面第一个小于其的数字位置，和后面第一个小于其的数字位置，就能知道当前数字是多少个子数组的最小值，直接相乘累加到结果 res 中即可。这里我们用两个单调栈 st_pre 和 st_next，栈里放一个数对儿，由数字和其在原数组的坐标组成。还需要两个一维数组 left 和 right，其中 left[i] 表示以 A[i] 为结束为止且 A[i] 是最小值的子数组的个数，right[i] 表示以 A[i] 为起点且 A[i] 是最小值的子数组的个数。对数组进行遍历，当 st_pre 不空，且栈顶元素大于 A[i]，移除栈顶元素，这样剩下的栈顶元素就是 A[i] 左边第一个小于其的数字的位置，假如栈为空，说明左边的所有数字都小于 A[i]，则 left[i] 赋值为 i+1，否则赋值为用i减去栈顶元素在原数组中的位置的值，然后将 A[i] 和i组成数对儿压入栈 st_pre。对于 right[i] 的处理也很类似，先将其初始化为 n-i，然后看若 st_next 不为空且栈顶元素大于 A[i]，然后取出栈顶元素t，由于栈顶元素t是大于 A[i]的，所以 right[t.second] 就可以更新为 i-t.second，然后将 A[i] 和i组成数对儿压入栈 st_next，最后再遍历一遍原数组，将每个 A[i] x left[i] x right[i] 算出来累加起来即可，别忘了对超大数取余，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = A.<span class="built_in">size</span>(), M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st_pre, st_next;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st_pre.<span class="built_in">empty</span>() &amp;&amp; st_pre.<span class="built_in">top</span>().first &gt; A[i]) &#123;</span><br><span class="line">                st_pre.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = st_pre.<span class="built_in">empty</span>() ? (i + <span class="number">1</span>) : (i - st_pre.<span class="built_in">top</span>().second);</span><br><span class="line">            st_pre.<span class="built_in">push</span>(&#123;A[i], i&#125;);</span><br><span class="line">            right[i] = n - i;</span><br><span class="line">            <span class="keyword">while</span> (!st_next.<span class="built_in">empty</span>() &amp;&amp; st_next.<span class="built_in">top</span>().first &gt; A[i]) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = st_next.<span class="built_in">top</span>(); st_next.<span class="built_in">pop</span>();</span><br><span class="line">                right[t.second] = i - t.second;</span><br><span class="line">            &#125;</span><br><span class="line">            st_next.<span class="built_in">push</span>(&#123;A[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res = (res + A[i] * left[i] * right[i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以对上面的解法进行空间上的优化，只用一个单调栈，用来记录当前数字之前的第一个小的数字的位置，然后遍历每个数字，但是要多遍历一个数字，i从0遍历到n，当 i=n 时，cur 赋值为0，否则赋值为 A[i]。然后判断若栈不为空，且 cur 小于栈顶元素，则取出栈顶元素位置 idx，由于是单调栈，那么新的栈顶元素就是 A[idx] 前面第一个较小数的位置，由于此时栈可能为空，所以再去之前要判断一下，若为空，则返回 -1，否则返回栈顶元素，用 idx 减去栈顶元素就是以 A[idx] 为结尾且最小值为 A[idx] 的子数组的个数，然后用i减去 idx 就是以 A[idx] 为起始且最小值为 A[idx] 的子数组的个数，然后 A[idx] x left x right 就是 A[idx] 这个数字当子数组的最小值之和，累加到结果 res 中并对超大数取余即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = A.<span class="built_in">size</span>(), M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur = (i == n) ? <span class="number">0</span> : A[i];</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; cur &lt; A[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> idx = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left = idx - (st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">top</span>());</span><br><span class="line">                <span class="type">int</span> right = i - idx;</span><br><span class="line">                res = (res + A[idx] * left * right) % M;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode908-Smallest-Range-I"><a href="#Leetcode908-Smallest-Range-I" class="headerlink" title="Leetcode908. Smallest Range I"></a>Leetcode908. Smallest Range I</h1><p>Given an array A of integers, for each integer A[i] we may choose any x with -K &lt;= x &lt;= K, and add x to A[i]. After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1], K = 0</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: B = [1]</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,10], K = 2</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: B = [2,8]</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,3,6], K = 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: B = [3,3,3] or B = [4,4,4]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 10000</li>
<li>0 &lt;= A[i] &lt;= 10000</li>
<li>0 &lt;= K &lt;= 10000</li>
</ul>
<p>给了一个非负数的数组，和一个非负数K，说是数组中的每一个数字都可以加上 [-K, K] 范围内的任意一个数字，问新数组的最大值最小值之间的差值最小是多少。这道题的难度是 Easy，理论上应该是可以无脑写代码的，但其实很容易想的特别复杂。本题的解题标签是 Math，这种类型的题目基本上就是一种脑筋急转弯的题目，有时候一根筋转不过来就怎么也做不出来。首先来想，既然是要求新数组的最大值和最小值之间的关系，那么肯定是跟原数组的最大值最小值有着某种联系，原数组的最大值最小值我们可以很容易的得到，只要找出了跟新数组之间的联系，问题就能迎刃而解了。题目中说了每个数字都可以加上 [-K, K] 范围内的数字，当然最大值最小值也可以，如何让二者之间的差值最小呢？当然是让最大值尽可能变小，最小值尽可能变大了，所以最大值 mx 要加上 -K，而最小值 mn 要加上K，然后再做减法，即 (mx-K)-(mn+K) = mx-mn+2K，这就是要求的答案啦。</p>
<p>只要找到数组A 最大值和最小值的差，然后和2k比较即可得到结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestRangeI</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find max and min</span></span><br><span class="line">        <span class="type">int</span> maxx = INT_MIN;</span><br><span class="line">        <span class="type">int</span> minn = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;maxx)</span><br><span class="line">                maxx = A[i];</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;minn)</span><br><span class="line">                minn = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minn+K &gt;= maxx-K)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> maxx - minn - <span class="number">2</span> * K;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode909-Snakes-and-Ladders"><a href="#Leetcode909-Snakes-and-Ladders" class="headerlink" title="Leetcode909. Snakes and Ladders"></a>Leetcode909. Snakes and Ladders</h1><p>On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row.  For example, for a 6 x 6 board, the numbers are written as follows:</p>
<p>You start on square 1 of the board (which is always in the last row and first column).  Each move, starting from square x, consists of the following:</p>
<ul>
<li>You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is &lt;= N*N.<br>(This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.)</li>
<li>If S has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to S.</li>
</ul>
<p>A board square on row r and column c has a “snake or ladder” if board[r][c] != -1.  The destination of that snake or ladder is board[r][c].</p>
<p>Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving.  (For example, if the board is [[4,-1],[-1,3]], and on the first move your destination square is 2, then you finish your first move at 3, because you do notcontinue moving to 4.)</p>
<p>Return the least number of moves required to reach square N*N.  If it is not possible, return -1.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,35,-1,-1,13,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,15,-1,-1,-1,-1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">At the beginning, you start at square 1 [at row 5, column 0].</span><br><span class="line">You decide to move to square 2, and must take the ladder to square 15.</span><br><span class="line">You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13.</span><br><span class="line">You then decide to move to square 14, and must take the ladder to square 35.</span><br><span class="line">You then decide to move to square 36, ending the game.</span><br><span class="line">It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.</span><br></pre></td></tr></table></figure></p>
<p>这道题给了一个 NxN 大小的二维数组，从左下角从1开始，蛇形游走，到左上角或者右上角到数字为 NxN，中间某些位置会有梯子，就如同传送门一样，直接可以到达另外一个位置。现在就如同玩大富翁 Big Rich Man 一样，有一个骰子，可以走1到6内的任意一个数字，现在奢侈一把，有无限个遥控骰子，每次都可以走1到6以内指定的步数，问最小能用几步快速到达终点 NxN 位置。博主刚开始做这道题的时候，看是求极值，以为是一道动态规划 Dynamic Programming 的题，结果发现木有办法重现子问题，没法写出状态转移方程，只得作罢。但其实博主忽略了一点，求最小值还有一大神器，广度优先搜索 BFS，最直接的应用就是在迷宫遍历的问题中，求从起点到终点的最少步数，也可以用在更 general 的场景，只要是存在确定的状态转移的方式，可能也可以使用。这道题基本就是类似迷宫遍历的问题，可以走的1到6步可以当作六个方向，这样就可以看作是一个迷宫了，唯一要特殊处理的就是遇见梯子的情况，要跳到另一个位置。这道题还有另一个难点，就是数字标号和数组的二维坐标的转换，这里起始点是在二维数组的左下角，且是1，而代码中定义的二维数组的 (0, 0) 点是在左上角，需要转换一下，还有就是这道题的数字是蛇形环绕的，即当行号是奇数的时候，是从右往左遍历的，转换的时候要注意一下。</p>
<p>初始时将数字1放入，然后还需要一个 visited 数组，大小为 nxn+1。在 while 循环中进行层序遍历，取出队首数字，判断若等于 nxn 直接返回结果 res。否则就要遍历1到6内的所有数字i，则 num+i 就是下一步要走的距离，需要将其转为数组的二维坐标位置，这个操作放到一个单独的子函数中，后边再讲。有了数组的坐标，就可以看该位置上是否有梯子，有的话，需要换成梯子能到达的位置，没有的话还是用 num+i。有了下一个位置，再看 visited 中的值，若已经访问过了直接跳过，否则标记为 true，并且加入队列 queue 中即可，若 while 循环退出了，表示无法到达终点，返回 -1。将数字标号转为二维坐标位置的子函数也不算难，首先应将数字标号减1，因为这里是从1开始的，而代码中的二维坐标是从0开始的，然后除以n得到横坐标，对n取余得到纵坐标。但这里得到的横纵坐标都还不是正确的，因为前面说了数字标记是蛇形环绕的，当行号是奇数的时候，列数需要翻转一下，即用 n-1 减去当前列数。又因为代码中的二维数组起点位置在左上角，同样需要翻转一样，这样得到的才是正确的横纵坐标，返回即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">snakesAndLadders</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = board.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        len = len*len;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q&#123;&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(len + <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; i ++) &#123;</span><br><span class="line">                <span class="type">int</span> num = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (num == len)</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span> &amp;&amp; num + i &lt;= len; ++i) &#123;</span><br><span class="line">                    <span class="type">int</span> next = <span class="built_in">getBoardValue</span>(board, num + i);</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="number">-1</span>) next = num + i;</span><br><span class="line">                    <span class="keyword">if</span> (visited[next]) <span class="keyword">continue</span>;</span><br><span class="line">                    visited[next] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBoardValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = board.<span class="built_in">size</span>(), x = (i - <span class="number">1</span>) / len, y = (i - <span class="number">1</span>) % len;</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">1</span>) y = len - <span class="number">1</span> - y;</span><br><span class="line">        x = len - <span class="number">1</span> - x;</span><br><span class="line">        <span class="keyword">return</span> board[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode911-Online-Election"><a href="#Leetcode911-Online-Election" class="headerlink" title="Leetcode911. Online Election"></a>Leetcode911. Online Election</h1><p>In an election, the i-th vote was cast for <code>persons[i]</code> at time <code>times[i]</code>.</p>
<p>Now, we would like to implement the following query function: <code>TopVotedCandidate.q(int t)</code> will return the number of the person that was leading the election at time t.</p>
<p>Votes cast at time t will count towards our query.  In the case of a tie, the most recent vote (among tied candidates) wins.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;TopVotedCandidate&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]</span><br><span class="line">Output: [null,0,1,1,0,0,1]</span><br><span class="line">Explanation:</span><br><span class="line">At time 3, the votes are [0], and 0 is leading.</span><br><span class="line">At time 12, the votes are [0,1,1], and 1 is leading.</span><br><span class="line">At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)</span><br><span class="line">This continues for 3 more queries at time 15, 24, and 8.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= persons.length = times.length &lt;= 5000</li>
<li>0 &lt;= persons[i] &lt;= persons.length</li>
<li>times is a strictly increasing array with all elements in [0, 10^9].</li>
<li><code>TopVotedCandidate.q</code> is called at most 10000 times per test case.</li>
<li><code>TopVotedCandidate.q(int t)</code> is always called with t &gt;= times[0].</li>
</ul>
<p>这道题是关于线上选举的问题，这里给了两个数组 persons 和 times，表示在某个时间点<code>times[i]</code>，i这个人把选票投给了 <code>persons[i]</code>，现在有一个q函数，输入时间点t，让返回在时间点t时得票最多的人，当得票数相等时，返回最近得票的人。因为查询需求的时间点是任意的，在某个查询时间点可能并没有投票发生，但需要知道当前的票王，当然最傻的办法就是每次都从开头统计到当前时间点，找出票王，但这种方法大概率会超时，正确的方法实际上是要在某个投票的时间点，都统计出当前的票王，然后在查询的时候，查找刚好大于查询时间点的下一个投票时间点，返回前一个时间点的票王即可，所以这里可以使用一个 TreeMap 来建立投票时间点和当前票王之间的映射。如何统计每个投票时间点的票王呢，可以使用一个 count 数组，其中<code>count[i]</code>就表示当前i获得的票数，还需要一个变量 lead，表示当前的票王。现在就可以开始遍历所有的投票了，对于每个投票，将票数加到 count 中对应的人身上，然后跟 lead 比较，若当前人的票数大于等于 lead 的票数，则 lead 更换为当前人，同时建立当前时间点和票王之间的映射。在查询的时候，由于时间点是有序的，所以可以使用二分搜索法，由于使用的是 TreeMap，具有自动排序的功能，可以直接用<code>upper_bound</code>来查找第一个比t大的投票时间，然后再返回上一个投票时间点的票王即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TopVotedCandidate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TopVotedCandidate</span>(vector&amp; persons, vector&amp; times) &#123;</span><br><span class="line">        <span class="type">int</span> n = persons.<span class="built_in">size</span>(), lead = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++count[persons[i]] &gt;= count[lead]) &#123;</span><br><span class="line">                lead = persons[i];</span><br><span class="line">            &#125;</span><br><span class="line">            m[times[i]] = lead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">q</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (--m.<span class="built_in">upper_bound</span>(t))-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以用 HashMap 来取代 TreeMap，但因为 HashMap 无法进行时间点的排序，不好使用二分搜索法了，所以就需要记录投票时间数组 times，保存在一个私有变量中。在查询函数中自己来写二分搜索法，查找第一个大于目标值的数。由于要返回上一个投票时间点，所以要记得减1，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TopVotedCandidate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TopVotedCandidate</span>(vector&amp; persons, vector&amp; times) &#123;</span><br><span class="line">        <span class="type">int</span> n = persons.<span class="built_in">size</span>(), lead = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;times = times;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++count[persons[i]] &gt;= count[lead]) &#123;</span><br><span class="line">                lead = persons[i];</span><br><span class="line">            &#125;</span><br><span class="line">            m[times[i]] = lead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">q</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = times.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (times[mid] &lt;= t) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[times[right - <span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">    vector times;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode912-Sort-an-Array"><a href="#Leetcode912-Sort-an-Array" class="headerlink" title="Leetcode912. Sort an Array"></a>Leetcode912. Sort an Array</h1><p>Given an array of integers nums, sort the array in ascending order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,2,3,1]</span><br><span class="line">Output: [1,2,3,5]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,1,1,2,0,0]</span><br><span class="line">Output: [0,0,1,1,2,5]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 10000</li>
<li>-50000 &lt;= A[i] &lt;= 50000</li>
</ul>
<p>这道题让我们给数组排序，常见排序方法有很多，插入排序，选择排序，堆排序，快速排序，冒泡排序，归并排序，桶排序等等。它们的时间复杂度不尽相同，这道题貌似对于平方级复杂度的排序方法会超时，所以只能使用那些速度比较快的排序方法啦。题目给定了每个数字的范围是 [-50000, 50000]，并不是特别大，这里可以使用记数排序 Count Sort，建立一个大小为 100001 的数组 count，然后统计 nums 中每个数字出现的个数，然后再从0遍历到 100000，对于每个遍历到的数字i，若个数不为0，则加入 count 数组中对应个数的 i-50000 到结果数组中，这里的 50000 是 offset，因为数组下标不能为负数，在开始统计个数的时候，每个数字都加上了 50000，那么最后组成有序数组的时候就要减去，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">sortArray</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), j = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span>, <span class="title">count</span><span class="params">(<span class="number">100001</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) ++count[num + <span class="number">50000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res[j++] = i - <span class="number">50000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面是快速排序。快排的精髓在于选一个 pivot，然后将所有小于 pivot 的数字都放在左边，大于 pivot 的数字都放在右边，等于的话放哪边都行。但是此时左右两边的数组各自都不一定是有序的，需要再各自调用相同的递归，直到细分到只有1个数字的时候，再返回的时候就都是有序的了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quick</span>(nums, <span class="number">0</span>, (<span class="type">int</span>)nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> pivot = nums[(start+end)/<span class="number">2</span>], i = start, j = end;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[i] &lt; pivot)</span><br><span class="line">                i ++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[j] &gt; pivot)</span><br><span class="line">                j --;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">                i ++;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">quick</span>(nums, start, j);</span><br><span class="line">        <span class="built_in">quick</span>(nums, i, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode914-X-of-a-Kind-in-a-Deck-of-Cards"><a href="#Leetcode914-X-of-a-Kind-in-a-Deck-of-Cards" class="headerlink" title="Leetcode914. X of a Kind in a Deck of Cards"></a>Leetcode914. X of a Kind in a Deck of Cards</h1><p>In a deck of cards, each card has an integer written on it.</p>
<p>Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:</p>
<p>Each group has exactly X cards.<br>All the cards in each group have the same integer.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: deck = [1,2,3,4,4,3,2,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Possible partition [1,1],[2,2],[3,3],[4,4].</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: deck = [1,1,1,2,2,2,3,3]</span><br><span class="line">Output: false´</span><br><span class="line">Explanation: No possible partition.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: deck = [1]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: No possible partition.</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: deck = [1,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Possible partition [1,1].</span><br></pre></td></tr></table></figure><br>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: deck = [1,1,2,2,2,2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Possible partition [1,1],[2,2],[2,2].</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= deck.length &lt;= 10^4</li>
<li>0 &lt;= deck[i] &lt; 10^4 </li>
</ul>
<p>1、这道题给定一个vector，vector中存放着卡牌的数字，比如1、2、3、4这样子，你需要把这些卡牌分成多组。要求同一组中的卡牌数字一致，并且每一组中的卡牌张数一样。比如123321，你就可以分成[1,1]，[2,2]，[3,3]。如果可以这样分组，并且组中卡牌张数大于等于2，那么返回true，否则返回false。限制卡牌数字在[0,10000)，vector中的卡牌张数在[1,10000]。</p>
<p>2、我们最开始可以用vector也可以用map，来存放各个数字的卡牌各有多少张。（笔者一开始的错误想法：这里用先排序后遍历的做法，有点傻，因为排序O(nlogn)的时间复杂度太高了，还不如直接遍历。）得到各个数字卡牌的张数之后，我们需要看一下是否可以分组。这里有个地方要注意下，比如卡牌1有4张，卡牌2有6张，是否可以分组呢？可以的，每组2张就可以了，卡牌1有2组，卡牌2有3组。也就是说，我们要求各种数字卡牌的张数的最大公约数，看一下最大公约数是否大于等于2。而不能简单地看各种数字卡牌的张数是否一致。</p>
<p>但是求集体的最大公约数太麻烦了，还不如直接从2开始，判断所有数字可不可以整除2。如果可以，那么返回true。如果不行，看一下是否可以整除3……继续判断，一直到最小的张数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mapp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; deck.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            mapp[deck[i]] ++;</span><br><span class="line">        <span class="type">int</span> minn = <span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = mapp.<span class="built_in">begin</span>(); it != mapp.<span class="built_in">end</span>(); it ++)</span><br><span class="line">            minn = <span class="built_in">min</span>(minn, it-&gt;second);</span><br><span class="line">        <span class="type">int</span> flag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= minn; i ++) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it = mapp.<span class="built_in">begin</span>(); it != mapp.<span class="built_in">end</span>(); it ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(it-&gt;second % i != <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode915-Partition-Array-into-Disjoint-Intervals"><a href="#Leetcode915-Partition-Array-into-Disjoint-Intervals" class="headerlink" title="Leetcode915. Partition Array into Disjoint Intervals"></a>Leetcode915. Partition Array into Disjoint Intervals</h1><p>Given an array A, partition it into two (contiguous) subarrays left and right so that:</p>
<ul>
<li>Every element in left is less than or equal to every element in right.</li>
<li>left and right are non-empty.</li>
<li>left has the smallest possible size.</li>
</ul>
<p>Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,0,3,8,6]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: left = [5,0,3], right = [8,6]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,0,6,12]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: left = [1,1,1,0], right = [6,12]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>2 &lt;= A.length &lt;= 30000</li>
<li>0 &lt;= A[i] &lt;= 10^6</li>
<li>It is guaranteed there is at least one way to partition A as described.</li>
</ul>
<p>这道题说是给了一个数组A，让我们分成两个相邻的子数组 left 和 right，使得 left 中的所有数字小于等于 right 中的，并限定了每个输入数组必定会有这么一个分割点，让返回数组 left 的长度。这道题并不算一道难题，当然最简单并暴力的方法就是遍历所有的分割点，然后去验证左边的数组是否都小于等于右边的数，这种写法估计会超时，这里就不去实现了。直接来想优化解法吧，由于分割成的 left 和 right 数组本身不一定是有序的，只是要求 left 中的最大值要小于等于 right 中的最小值，只要这个条件满足了，一定就是符合题意的分割。left 数组的最大值很好求，在遍历数组的过程中就可以得到，而 right 数组的最小值怎么求呢？其实可以反向遍历数组，并且使用一个数组 backMin，其中 backMin[i] 表示在范围 [i, n-1] 范围内的最小值，有了这个数组后，再正向遍历一次数组，每次更新当前最大值 curMax，这就是范围 [0, i] 内的最大值，通过 backMin 数组快速得到范围 [i+1, n-1] 内的最小值，假如 left 的最大值小于等于 right 的最小值，则 i+1 就是 left 的长度，直接返回即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partitionDisjoint</span><span class="params">(vector&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>(), curMax = INT_MIN;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">backMin</span><span class="params">(n, A.back())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            backMin[i] = <span class="built_in">min</span>(backMin[i + <span class="number">1</span>], A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            curMax = <span class="built_in">max</span>(curMax, A[i]);</span><br><span class="line">            <span class="keyword">if</span> (curMax &lt;= backMin[i + <span class="number">1</span>]) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面来看论坛上的主流解法，只需要一次遍历即可，并且不需要额外的空间，这里使用三个变量，partitionIdx 表示分割点的位置，preMax 表示 left 中的最大值，curMax 表示当前的最大值。思路是遍历每个数字，更新当前最大值 curMax，并且判断若当前数字 A[i] 小于 preMax，说明这个数字也一定是属于 left 数组的，此时整个遍历到的区域应该都是属于 left 的，所以 preMax 要更新为 curMax，并且当前位置也就是潜在的分割点，所以 partitionIdx 更新为i。由于题目中限定了一定会有分割点，所以这种方法是可以得到正确结果的，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partitionDisjoint</span><span class="params">(vector&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> partitionIdx = <span class="number">0</span>, preMax = A[<span class="number">0</span>], curMax = preMax;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            curMax = <span class="built_in">max</span>(curMax, A[i]);</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; preMax) &#123;</span><br><span class="line">                preMax = curMax;</span><br><span class="line">                partitionIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> partitionIdx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode916-Word-Subsets"><a href="#Leetcode916-Word-Subsets" class="headerlink" title="Leetcode916. Word Subsets"></a>Leetcode916. Word Subsets</h1><p>We are given two arrays A and B of words.  Each word is a string of lowercase letters.</p>
<p>Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  For example, “wrr” is a subset of “warrior”, but is not a subset of “world”.</p>
<p>Now say a word a from A is  universal  if for every b in B, b is a subset of a.</p>
<p>Return a list of all universal words in A.  You can return the words in any order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;e&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;l&quot;,&quot;e&quot;]</span><br><span class="line">Output: [&quot;apple&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;e&quot;,&quot;oo&quot;]</span><br><span class="line">Output: [&quot;facebook&quot;,&quot;google&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;lo&quot;,&quot;eo&quot;]</span><br><span class="line">Output: [&quot;google&quot;,&quot;leetcode&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;ec&quot;,&quot;oc&quot;,&quot;ceo&quot;]</span><br><span class="line">Output: [&quot;facebook&quot;,&quot;leetcode&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length, B.length &lt;= 10000</li>
<li>1 &lt;= A[i].length, B[i].length &lt;= 10</li>
<li>A[i] and B[i] consist only of lowercase letters.</li>
<li>All words in A[i] are unique: there isn’t i != j with A[i] == A[j].</li>
</ul>
<p>这道题定义了两个单词之间的一种子集合关系，就是说假如单词b中的每个字母都在单词a中出现了（包括重复字母），就说单词b是单词a的子集合。现在给了两个单词集合A和B，让找出集合A中的所有满足要求的单词，使得集合B中的所有单词都是其子集合。配合上题目中给的一堆例子，意思并不难理解，根据子集合的定义关系，其实就是说若单词a中的每个字母的出现次数都大于等于单词b中每个字母的出现次数，单词b就一定是a的子集合。现在由于集合B中的所有单词都必须是A中某个单词的子集合，那么其实只要对于每个字母，都统计出集合B中某个单词中出现的最大次数，比如对于这个例子，<code>B=[“eo”,”oo”]</code>，其中e最多出现1次，而o最多出现2次，那么只要集合A中有单词的e出现不少1次，o出现不少于2次，则集合B中的所有单词一定都是其子集合。这就是本题的解题思路，这里使用一个大小为 26 的一维数组 charCnt 来统计集合B中每个字母的最大出现次数，而将统计每个单词的字母次数的操作放到一个子函数 helper 中，当 charCnt 数组更新完毕后，下面就开始检验集合A中的所有单词了。对于每个遍历到的单词，还是要先统计其每个字母的出现次数，然后跟 charCnt 中每个位置上的数字比较，只要均大于等于 charCnt 中的数字，就可以加入到结果 res 中了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordSubsets</span><span class="params">(vector&lt;string&gt;&amp; words1, vector&lt;string&gt;&amp; words2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">char_num</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words<span class="number">2.</span><span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; t = <span class="built_in">helper</span>(words2[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j ++)</span><br><span class="line">                char_num[j] = <span class="built_in">max</span>(char_num[j], t[j]);   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words<span class="number">1.</span><span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; t = <span class="built_in">helper</span>(words1[i]);</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j ++)</span><br><span class="line">                <span class="keyword">if</span> (t[j] &lt; char_num[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">26</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(words1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">helper</span><span class="params">(string a)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            res[a[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode917-Reverse-Only-Letters"><a href="#Leetcode917-Reverse-Only-Letters" class="headerlink" title="Leetcode917. Reverse Only Letters"></a>Leetcode917. Reverse Only Letters</h1><p>Given a string S, return the “reversed” string where all characters that are not a letter stay in the same place, and all letters reverse their positions.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ab-cd&quot;</span><br><span class="line">Output: &quot;dc-ba&quot;</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;a-bC-dEf-ghIj&quot;</span><br><span class="line">Output: &quot;j-Ih-gfE-dCba&quot;</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;Test1ng-Leet=code-Q!&quot;</span><br><span class="line">Output: &quot;Qedo1ct-eeLg=ntse-T!&quot;</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>S.length &lt;= 100</li>
<li>33 &lt;= S[i].ASCIIcode &lt;= 122 </li>
<li>S doesn’t contain \ or “</li>
</ul>
<p>给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isletter</span><span class="params">(<span class="type">char</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((b &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; b &lt;= <span class="string">&#x27;z&#x27;</span>) || (b &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; b &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">reverseOnlyLetters</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = S.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isletter</span>(S[i]))</span><br><span class="line">                i ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">isletter</span>(S[j]))</span><br><span class="line">                j --;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">char</span> c = S[i];</span><br><span class="line">                S[i] = S[j];</span><br><span class="line">                S[j] = c;</span><br><span class="line">                i ++;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode918-Maximum-Sum-Circular-Subarray"><a href="#Leetcode918-Maximum-Sum-Circular-Subarray" class="headerlink" title="Leetcode918. Maximum Sum Circular Subarray"></a>Leetcode918. Maximum Sum Circular Subarray</h1><p>Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.</p>
<p>Here, a  circular array  means the end of the array connects to the beginning of the array.  (Formally, <code>C[i] = A[i]</code>when <code>0 &lt;= i &lt; A.length</code>, and <code>C[i+A.length] = C[i]</code> when <code>i &gt;= 0</code>.)</p>
<p>Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray <code>C[i], C[i+1], ..., C[j]</code>, there does not exist <code>i &lt;= k1, k2 &lt;= j</code> with <code>k1 % A.length = k2 % A.length</code>.)</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,-2,3,-2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] has maximum sum 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,-3,5]</span><br><span class="line">Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,-1,2,-1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,-2,2,-3]</span><br><span class="line">Output: 3 Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,-3,-1]</span><br><span class="line">Output: -1 Explanation: Subarray [-1] has maximum sum -1</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>-30000 &lt;= A[i] &lt;= 30000</li>
<li>1 &lt;= A.length &lt;= 30000</li>
</ul>
<p>这道题让求环形子数组的最大和，既然是子数组，则意味着必须是相连的数字，而由于环形数组的存在，说明可以首尾相连，这样的话，最长子数组的范围可以有两种情况，一种是正常的，数组中的某一段子数组，另一种是分为两段的，即首尾相连的。对于第一种情况，其实就是之前那道题 Maximum Subarray 的做法，对于第二种情况，需要转换一下思路，除去两段的部分，中间剩的那段子数组其实是和最小的子数组，只要用之前的方法求出子数组的最小和，用数组总数字和一减，同样可以得到最大和。两种情况的最大和都要计算出来，取二者之间的较大值才是真正的和最大的子数组。但是这里有个 corner case 需要注意一下，假如数组中全是负数，那么和最小的子数组就是原数组本身，则求出的差值是0，而第一种情况求出的和最大的子数组也应该是负数，那么二者一比较，返回0就不对了，所以这种特殊情况需要单独处理一下，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, mn = INT_MAX, mx = INT_MIN, curMax = <span class="number">0</span>, curMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">            curMin = <span class="built_in">min</span>(curMin + num, num);</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, curMin);</span><br><span class="line">            curMax = <span class="built_in">max</span>(curMax + num, num);</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, curMax);</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum - mn == <span class="number">0</span>) ? mx : <span class="built_in">max</span>(mx, sum - mn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode921-Minimum-Add-to-Make-Parentheses-Valid"><a href="#Leetcode921-Minimum-Add-to-Make-Parentheses-Valid" class="headerlink" title="Leetcode921. Minimum Add to Make Parentheses Valid"></a>Leetcode921. Minimum Add to Make Parentheses Valid</h1><p>Given a string S of ‘(‘ and ‘)’ parentheses, we add the minimum number of parentheses ( ‘(‘ or ‘)’, and in any positions ) so that the resulting parentheses string is valid.</p>
<p>Formally, a parentheses string is valid if and only if:</p>
<p>It is the empty string, or<br>It can be written as AB (A concatenated with B), where A and B are valid strings, or<br>It can be written as (A), where A is a valid string.<br>Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;())&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(((&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()))((&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>S.length &lt;= 1000<br>S only consists of ‘(‘ and ‘)’ characters.</p>
<p>一道变形的括号匹配，这里注意如果res为负数的话，要及时纠正成正的且也要在最终结果加一，如上边的Example4的样子，如果只是按照栈的做法，结果是0，是错的，其实要加4个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minAddToMakeValid</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>,result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(S[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                res++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res--;</span><br><span class="line">                <span class="keyword">if</span>(res&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    res=<span class="number">0</span>;</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> result+res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode922-Sort-Array-By-Parity-II"><a href="#Leetcode922-Sort-Array-By-Parity-II" class="headerlink" title="Leetcode922. Sort Array By Parity II"></a>Leetcode922. Sort Array By Parity II</h1><p>Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even.</p>
<p>Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.</p>
<p>You may return any answer array that satisfies this condition.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,2,5,7]</span><br><span class="line">Output: [4,5,2,7]</span><br></pre></td></tr></table></figure><br>Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.</p>
<p>Note:</p>
<p>2 &lt;= A.length &lt;= 20000<br>A.length % 2 == 0<br>0 &lt;= A[i] &lt;= 1000</p>
<p>首先，将所有偶数元素放在正确的位置就足够了，因为所有奇数元素也都在正确的位置。 所以我们只关注A [0]，A [2]，A [4]，……</p>
<p>理想情况下，我们希望有一些分区，左边的所有内容都已经正确，右边的所有内容都是未定的。<br>实际上，如果我们把它分成两个切片，即偶数= A [0]，A [2]，A [4]，……和奇数= A [1]，A [3]，A [5]，这个想法是有效的， ….我们的不变量将是偶数切片中的所有小于i的位置都是正确的，并且奇数切片中小于j的所有位置都是正确的。</p>
<p>对于每个偶数，让我们使A[i]也为偶数。 为此，我们将从奇数切片中提取一个元素。 我们将j传递到奇数切片，直到找到偶数元素，然后交换。 我们的不变量得以维持，因此算法是正确的。</p>
<p>就是说对每一个偶数位置的奇数，在奇数位置找一个偶数，然后交换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArrayByParityII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(A[j] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                    j += <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> temp = A[i];</span><br><span class="line">                A[i] = A[j];</span><br><span class="line">                A[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode925-Long-Pressed-Name"><a href="#Leetcode925-Long-Pressed-Name" class="headerlink" title="Leetcode925. Long Pressed Name"></a>Leetcode925. Long Pressed Name</h1><p>Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.</p>
<p>You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: name = &quot;alex&quot;, typed = &quot;aaleex&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#x27;a&#x27; and &#x27;e&#x27; in &#x27;alex&#x27; were long pressed.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: name = &quot;saeed&quot;, typed = &quot;ssaaedd&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &#x27;e&#x27; must have been pressed twice, but it wasn&#x27;t in the typed output.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: name = &quot;leelee&quot;, typed = &quot;lleeelee&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: name = &quot;laiden&quot;, typed = &quot;laiden&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: It&#x27;s not necessary to long press any character.</span><br></pre></td></tr></table></figure><br>Constraints:</p>
<ul>
<li>1 &lt;= name.length &lt;= 1000</li>
<li>1 &lt;= typed.length &lt;= 1000</li>
<li>The characters of name and typed are lowercase letters.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLongPressedName</span><span class="params">(string name, string typed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name[<span class="number">0</span>] != typed[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> count1, count2, i, j;</span><br><span class="line">        <span class="type">int</span> length1 = name.<span class="built_in">length</span>(), length2 = typed.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt; length1 || j &lt; length2; i ++, j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name[i<span class="number">-1</span>] != typed[j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            count1 = <span class="number">1</span>;</span><br><span class="line">            count2 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(name[i] == name[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                count1 ++;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(typed[j] == typed[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                count2 ++;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">             cout&lt;&lt; count1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; count2 &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span>(count2 &lt; count1)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(name[length1<span class="number">-1</span>] != typed[length2<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不简单……边界条件很多，而且很麻烦。</p>
<h1 id="Leetcode926-Flip-String-to-Monotone-Increasing"><a href="#Leetcode926-Flip-String-to-Monotone-Increasing" class="headerlink" title="Leetcode926. Flip String to Monotone Increasing"></a>Leetcode926. Flip String to Monotone Increasing</h1><p>A string of ‘0’s and ‘1’s is monotone increasing if it consists of some number of ‘0’s (possibly 0), followed by some number of ‘1’s (also possibly 0.)</p>
<p>We are given a string S of ‘0’s and ‘1’s, and we may flip any ‘0’ to a ‘1’ or a ‘1’ to a ‘0’.</p>
<p>Return the minimum number of flips to make S monotone increasing.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;00110&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We flip the last digit to get 00111.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;010110&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We flip to get 011111, or alternatively 000111.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;00011000&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We flip to get 00000000.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= S.length &lt;= 20000</li>
<li>S only consists of ‘0’ and ‘1’ characters.</li>
</ul>
<p>这道题给了我们一个只有0和1的字符串，现在说是可以将任意位置的数翻转，即0变为1，或者1变为0，让组成一个单调递增的序列，即0必须都在1的前面，博主刚开始想的策略比较直接，就是使用双指针分别指向开头和结尾，开头的指针先跳过连续的0，末尾的指针向前跳过连续的1，然后在中间的位置分别记录0和1的个数，返回其中较小的那个。这种思路乍看上去没什么问题，但是实际上是有问题的，比如对于这个例子 “10011111110010111011”，如果按这种思路的话，就应该将所有的0变为1，从而返回6，但实际上更优的解法是将第一个1变为0，将后4个0变为1即可，最终可以返回5，这说明了之前的解法是不正确的。这道题可以用动态规划 Dynamic Programming 来做，需要使用两个 dp 数组，其中 cnt1[i] 表示将范围是 [0, i-1] 的子串内最小的将1转为0的个数，从而形成单调字符串。同理，cnt0[j] 表示将范围是 [j, n-1] 的子串内最小的将0转为1的个数，从而形成单调字符串。这样最终在某个位置使得 cnt0[i]+cnt1[i] 最小的时候，就是变为单调串的最优解，这样就可以完美的解决上面的例子，子串 “100” 的最优解是将1变为0，而后面的 “11111110010111011” 的最优解是将4个0变为1，总共加起来就是5，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFlipsMonoIncr</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = S.<span class="built_in">size</span>(), res = INT_MAX;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt1</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">cnt0</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; ++i, --j) &#123;</span><br><span class="line">            cnt1[i] += cnt1[i - <span class="number">1</span>] + (S[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">            cnt0[j] += cnt0[j + <span class="number">1</span>] + (S[j] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) res = <span class="built_in">min</span>(res, cnt1[i] + cnt0[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以进一步优化一下空间复杂度，用一个变量 cnt1 来记录当前位置时1出现的次数，同时 res 表示使到当前位置的子串变为单调串的翻转次数，用来记录0的个数，因为遇到0就翻1一定可以组成单调串，但不一定是最优解，每次都要和 cnt1 比较以下，若 cnt1 较小，就将 res 更新为 cnt1，此时保证了到当前位置的子串变为单调串的翻转次数最少，并不关心到底是把0变为1，还是1变为0了，其实核心思想跟上面的解法很相近，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFlipsMonoIncr</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = S.<span class="built_in">size</span>(), res = <span class="number">0</span>, cnt1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            (S[i] == <span class="string">&#x27;0&#x27;</span>) ? ++res : ++cnt1;</span><br><span class="line">            res = <span class="built_in">min</span>(res, cnt1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode929-Unique-Email-Addresses"><a href="#Leetcode929-Unique-Email-Addresses" class="headerlink" title="Leetcode929. Unique Email Addresses"></a>Leetcode929. Unique Email Addresses</h1><p>Every email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain ‘.’s or ‘+’s.</p>
<p>If you add periods (‘.’) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, “alice.z@leetcode.com” and “alicez@leetcode.com” forward to the same email address.  (Note that this rule does not apply for domain names.)</p>
<p>If you add a plus (‘+’) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.)</p>
<p>It is possible to use both of these rules at the same time.</p>
<p>Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails? </p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= emails[i].length &lt;= 100</li>
<li>1 &lt;= emails.length &lt;= 100</li>
<li>Each emails[i] contains exactly one ‘@’ character.</li>
<li>All local and domain names are non-empty.</li>
<li>Local names do not start with a ‘+’ character.</li>
</ul>
<p>字符串处理，如果一个email地址里有点(‘.’)的话，就忽略这个点，如果有加号(‘+’)，忽略这个加号到(‘@’)之间的字符。判断一共有几个一样的email地址。不难，但是涉及字符串处理的话总归有些麻烦的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numUniqueEmails</span><span class="params">(vector&lt;string&gt;&amp; emails)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> result[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(result,<span class="string">&#x27;\0&#x27;</span>,<span class="built_in">sizeof</span>(result));</span><br><span class="line">        <span class="type">int</span> result_len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i&lt;emails.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> temp[<span class="number">100</span>];</span><br><span class="line">            <span class="built_in">memset</span>(temp,<span class="string">&#x27;\0&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">            <span class="type">int</span> temp_len = <span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;emails[i].<span class="built_in">length</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(emails[i][j]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(emails[i][j]==<span class="string">&#x27;+&#x27;</span> || emails[i][j]==<span class="string">&#x27;@&#x27;</span> )</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    temp[temp_len++]=emails[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=emails[i].<span class="built_in">find</span>(<span class="string">&#x27;@&#x27;</span>); j&lt;emails[i].<span class="built_in">length</span>(); j++)</span><br><span class="line">                temp[temp_len++]=emails[i][j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;result_len; k++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(result[k],temp)==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k==result_len)</span><br><span class="line">                <span class="built_in">memcpy</span>(result[result_len++], temp, <span class="built_in">sizeof</span>(temp));</span><br><span class="line">            <span class="built_in">memset</span>(temp,<span class="string">&#x27;\0&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我的另一种做法，用set去重<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numUniqueEmails</span><span class="params">(vector&lt;string&gt;&amp; emails)</span> </span>&#123;</span><br><span class="line">        set&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; emails.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            string temp;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; emails[i].<span class="built_in">size</span>(); j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(emails[i][j] == <span class="string">&#x27;+&#x27;</span> || emails[i][j] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(emails[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                temp += emails[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(emails[i][j] != <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">                j ++;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; emails[i].<span class="built_in">size</span>(); j ++) &#123;</span><br><span class="line">                temp += emails[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">insert</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>解析：<br>For each email address, convert it to the canonical address that actually receives the mail. This involves a few steps:</p>
<ul>
<li>Separate the email address into a local part and the rest of the address.</li>
<li>If the local part has a ‘+’ character, remove it and everything beyond it from the local part.</li>
<li>Remove all the zeros from the local part.</li>
<li>The canonical address is local + rest.</li>
</ul>
<p>After, we can count the number of unique canonical addresses with a Set structure.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">numUniqueEmails</span><span class="params">(String[] emails)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> <span class="built_in">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span> (String email: emails) &#123;</span><br><span class="line">            <span class="type">int</span> i = email.<span class="built_in">indexOf</span>(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">            String local = email.<span class="built_in">substring</span>(<span class="number">0</span>, i);</span><br><span class="line">            String rest = email.<span class="built_in">substring</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (local.<span class="built_in">contains</span>(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                local = local.<span class="built_in">substring</span>(<span class="number">0</span>, local.<span class="built_in">indexOf</span>(<span class="string">&#x27;+&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            local = local.<span class="built_in">replaceAll</span>(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            seen.<span class="built_in">add</span>(local + rest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seen.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode930-Binary-Subarrays-With-Sum"><a href="#Leetcode930-Binary-Subarrays-With-Sum" class="headerlink" title="Leetcode930. Binary Subarrays With Sum"></a>Leetcode930. Binary Subarrays With Sum</h1><p>In an array A of 0s and 1s, how many non-empty subarrays have sum S?</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,0,1,0,1], S = 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">The 4 subarrays are bolded below:</span><br><span class="line">[1,0,1]</span><br><span class="line">[1,0,1,0]</span><br><span class="line">[0,1,0,1]</span><br><span class="line">[1,0,1]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>A.length &lt;= 30000</li>
<li>0 &lt;= S &lt;= A.length</li>
<li>A[i] is either 0 or 1.</li>
</ul>
<p>这道题给了我们一个只由0和1组成的数组A，还有一个整数S，问数组A中有多少个子数组使得其和正好为S。博主最先没看清题意，以为是按二进制数算的，但是看了例子之后才发现，其实只是单纯的求和而已。那么马上就想着应该是要建立累加和数组的，然后遍历所有的子数组之和，但是这个遍历的过程还是平方级的复杂度，这道题的 OJ 卡的比较严格，只放行线性的时间复杂度。所以这种遍历方式是不行的，但仍需要利用累加和的思路，具体的方法是在遍历的过程中使用一个变量 curSum 来记录当前的累加和，同时使用一个 HashMap，用来映射某个累加出现的次数，初始化需要放入 {0,1} 这个映射对儿，后面会讲解原因。在遍历数组的A的时候，对于每个遇到的数字 num，都加入累加和 curSum 中，然后看若 curSum-S 这个数有映射值的话，那么说明就存在 m[curSum-S] 个符合题意的子数组，应该加入到结果 res 中，假如 curSum 正好等于S，即 curSum-S=0 的时候，此时说明从开头到当前位置正好是符合题目要求的子数组，现在明白刚开始为啥要加入 {0,1} 这个映射对儿了吧，就是为了处理这种情况。然后此时 curSum 的映射值自增1即可。其实这道题的解法思路跟之前那道 Contiguous Array 是一样的，那道题是让找0和1个数相同的子数组，这里让找和为S的子数组，都可以用一个套路来解题，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, curSum = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">            curSum += num;</span><br><span class="line">            res += m[curSum - S];</span><br><span class="line">            ++m[curSum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以使用滑动窗口 Sliding Window 来做，也是线性的时间复杂度，其实还是利用到了累计和的思想，不过这个累加和不是从开头到当前位置之和，而是这个滑动窗口内数字之和，这 make sense 吧，因为只要这个滑动窗口内数字之和正好等于S了，即是符合题意的一个子数组。遍历数组A，将当前数字加入 sum 中，然后看假如此时 sum 大于S了，则要进行收缩窗口操作，左边界 left 右移，并且 sum 要减去这个移出窗口的数字，当循环退出后，假如此时 sum 小于S了，说明当前没有子数组之和正好等于S，若 sum 等于S了，则结果 res 自增1。此时还需要考虑一种情况，就是当窗口左边有连续0的时候，因为0并不影响 sum，但是却要算作不同的子数组，所以要统计左起连续0的个数，并且加到结果 res 中即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, sum = <span class="number">0</span>, left = <span class="number">0</span>, n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; i &amp;&amp; sum &gt; S) sum -= A[left++];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; S) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum == S) ++res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; i &amp;&amp; A[j] == <span class="number">0</span>; ++j) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode931-Minimum-Falling-Path-Sum"><a href="#Leetcode931-Minimum-Falling-Path-Sum" class="headerlink" title="Leetcode931. Minimum Falling Path Sum"></a>Leetcode931. Minimum Falling Path Sum</h1><p>Given a square array of integers A, we want the minimum sum of a  falling path  through A.</p>
<p>A falling path starts at any element in the first row, and chooses one element from each row.  The next row’s choice must be in a column that is different from the previous row’s column by at most one.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation:</span><br><span class="line">The possible falling paths are:</span><br><span class="line"></span><br><span class="line">-   `[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]`</span><br><span class="line">-   `[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]`</span><br><span class="line">-   `[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]`</span><br><span class="line">The falling path with the smallest sum is [1,4,7], so the answer is 12.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length == A[0].length &lt;= 100</li>
<li>-100 &lt;= A[i][j] &lt;= 100</li>
</ul>
<p>这道题给了一个长宽相等的二维数组，说是让找一个列路径，使得相邻两个位置的数的距离不超过1，可以通过观察题目中给的例子来理解题意。由于每个位置上的累加值是由上一行的三个位置中较小的那个决定的，所以这就是一道典型的动态规划 Dynamic Programming 的题，为了节省空间，直接用数组A本身当作 dp 数组，其中 A[i][j] 就表示最后一个位置在 (i, j) 的最小的下降路径，则最终只要在最后一行中找最小值就是所求。由于要看上一行的值，所以要从第二行开始遍历，那么首先判断一下数组是否只有一行，是的话直接返回那个唯一的数字即可。否则从第二行开始遍历，一定存在的是 A[i-1][j] 这个数字，而它周围的两个数字需要判断一下，存在的话才进行比较取较小值，将最终的最小值加到当前的 A[i][j] 上即可。为了避免重新开一个 for 循环，判断一下，若当前是最后一行，则更新结果 res，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFallingPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> A[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>(), res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> pre = A[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) pre = <span class="built_in">min</span>(pre, A[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n - <span class="number">1</span>) pre = <span class="built_in">min</span>(pre, A[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">                A[i][j] += pre;</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span>) res = <span class="built_in">min</span>(res, A[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode932-Beautiful-Array"><a href="#Leetcode932-Beautiful-Array" class="headerlink" title="Leetcode932. Beautiful Array"></a>Leetcode932. Beautiful Array</h1><p>For some fixed N, an array A is beautiful if it is a permutation of the integers 1, 2, …, N, such that:</p>
<p>For every i &lt; j, there is no k with i &lt; k &lt; j such that A[k] * 2 = A[i] + A[j].</p>
<p>Given N, return any beautiful array A.  (It is guaranteed that one exists.)</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [2,1,4,3]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: [3,1,2,5,4]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 1000</li>
</ul>
<p>这道题定义了一种漂亮数组，说的是在任意两个数字之间，不存在一个正好是这两个数之和的一半的数字，现在让返回长度是N的一个漂亮数组，注意这里长度是N的漂亮数组一定是由1到N之间的数字组成的，每个数字都会出现，而且一定存在这样的漂亮数组。博主刚开始时是没什么头绪的，想着总不会是要遍历所有的排列情况，然后对每个情况去验证是否是漂亮数组的吧，想想都觉得很不高效，于是就放弃挣扎，直接逛论坛了。不出意外，最高票的还是你李哥，居然提出了逆天的线性时间的解法，献上膝盖，怪不得有网友直接要 Venmo 号立马打钱，LOL～ 这道题给了提示说是要用分治法来做，但是怎么分是这道题的精髓，若只是普通的对半分，那么在 merge 的时候还是要验证是否是漂亮数组，麻烦！但若按奇偶来分的话，那就非常的叼了，因为奇数加偶数等于奇数，就不会是任何一个数字的2倍了。这就是奇偶分堆的好处，这时任意两个数字肯定不能分别从奇偶堆里取了，那可能你会问，奇数堆会不会有三个奇数打破这个规则呢？只要这个奇数堆是从一个漂亮数组按固定的规则变化而来的，就能保证一定也是漂亮数组，因为对于任意一个漂亮数组，若对每个数字都加上一个相同的数字，或者都乘上一个相同的数字，则一定还是漂亮数组，因为数字的之间的内在关系并没有改变。明白了上面这些，基本就可以解题了，假设此时已经有了一个长度为n的漂亮数组，如何将其扩大呢？可以将其中每个数字都乘以2并加1，就都会变成奇数，并且这个奇数数组还是漂亮的，然后再将每个数字都乘以2，那么都会变成偶数，并且这个偶数数组还是漂亮的，两个数组拼接起来，就会得到一个长度为 2n 的漂亮数组。就是这种思路，可以从1开始，1本身就是一个漂亮数组，然后将其扩大，注意这里要卡一个N，不能让扩大的数组长度超过N，只要在变为奇数和偶数时加个判定就行了，将不大于N的数组加入到新的数组中，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">beautifulArray</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">size</span>() &lt; N) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : res) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num * <span class="number">2</span> - <span class="number">1</span> &lt;= N) t.<span class="built_in">push_back</span>(num * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : res) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num * <span class="number">2</span> &lt;= N) t.<span class="built_in">push_back</span>(num * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode933-Number-of-Recent-Calls"><a href="#Leetcode933-Number-of-Recent-Calls" class="headerlink" title="Leetcode933. Number of Recent Calls"></a>Leetcode933. Number of Recent Calls</h1><p>Write a class RecentCounter to count recent requests. It has only one method: ping(int t), where t represents some time in milliseconds. Return the number of pings that have been made from 3000 milliseconds ago until now. Any ping with time in [t - 3000, t] will count, including the current ping. It is guaranteed that every call to ping uses a strictly larger value of t than before.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: inputs = [&quot;RecentCounter&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;], inputs = [[],[1],[100],[3001],[3002]]</span><br><span class="line">Output: [null,1,2,3,3]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>Each test case will have at most 10000 calls to ping.</li>
<li>Each test case will call ping with strictly increasing values of t.</li>
<li>Each call to ping will have 1 &lt;= t &lt;= 10^9.</li>
</ul>
<p>行吧，我是没看懂这个题是什么意思。。。只是判断t和3000的关系。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">RecentCounter</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ping</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(t);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">front</span>()&lt;t<span class="number">-3000</span>)</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode934-Shortest-Bridge"><a href="#Leetcode934-Shortest-Bridge" class="headerlink" title="Leetcode934. Shortest Bridge"></a>Leetcode934. Shortest Bridge</h1><p>In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)</p>
<p>Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.</p>
<p>Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1],[1,0]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1,0],[0,0,0],[0,0,1]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length = A[0].length &lt;= 100</li>
<li>A[i][j] == 0 or A[i][j] == 1</li>
</ul>
<p>这道题说是有一个只有0和1的二维数组，其中连在一起的1表示岛屿，现在假定给定的数组中一定有两个岛屿，问最少需要把多少个0变成1才能使得两个岛屿相连。在 LeetCode 中关于岛屿的题目还不少，但是万变不离其宗，核心都是用 DFS 或者 BFS 来解，有些还可以用联合查找 Union Find 来做。这里要求的是最小值，首先预定了一个 BFS，这就相当于洪水扩散一样，一圈一圈的，用的就是 BFS 的层序遍历。好，现在确定了这点后，再来想，这里并不是从某个点开始扩散，而是要从一个岛屿开始扩散，那么这个岛屿的所有的点都是 BFS 的起点，都是要放入到 queue 中的，所以要先来找出一个岛屿的所有点。找的方法就是遍历数组，找到第一个1的位置，然后对其调用 DFS 或者 BFS 来找出所有相连的1，先来用 DFS 的方法，对第一个为1的点调用递归函数，将所有相连的1都放入到一个队列 queue 中，并且将该点的值改为2，然后使用 BFS 进行层序遍历，每遍历一层，结果 res 都增加1，当遇到1时，直接返回 res 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = A.<span class="built_in">size</span>(), startX = <span class="number">-1</span>, startY = <span class="number">-1</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dirX&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dirY = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                startX = i; startY = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (startX != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">helper</span>(A, startX, startY, q);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> x = t / n + dirX[k], y = t % n + dirY[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= n || A[x][y] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (A[x][y] == <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">                    A[x][y] = <span class="number">2</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(x * n + y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;vector&gt;&amp; A, <span class="type">int</span> x, <span class="type">int</span> y, queue&amp; q)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= n || A[x][y] == <span class="number">0</span> || A[x][y] == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        A[x][y] = <span class="number">2</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(x * n + y);</span><br><span class="line">        <span class="built_in">helper</span>(A, x + <span class="number">1</span>, y, q);</span><br><span class="line">        <span class="built_in">helper</span>(A, x, y + <span class="number">1</span>, q);</span><br><span class="line">        <span class="built_in">helper</span>(A, x - <span class="number">1</span>, y, q);</span><br><span class="line">        <span class="built_in">helper</span>(A, x, y - <span class="number">1</span>, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">我们也可以使用 BFS 来找出所有相邻的<span class="number">1</span>，再加上后面的层序遍历的 BFS，总共需要两个 BFS，注意这里第一个 BFS 不需要是层序遍历的，而第二个 BFS 是必须层序遍历，可以对比一下看一下这两种写法有何不同，参见代码如下：</span><br><span class="line"></span><br><span class="line">``C++</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = A.<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q, que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dirX&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dirY = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                A[i][j] = <span class="number">2</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(i * n + j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!que.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> t = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(t);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="type">int</span> x = t / n + dirX[k], y = t % n + dirY[k];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= n || A[x][y] == <span class="number">0</span> || A[x][y] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                A[x][y] = <span class="number">2</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(x * n + y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> x = t / n + dirX[k], y = t % n + dirY[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= n || A[x][y] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (A[x][y] == <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">                    A[x][y] = <span class="number">2</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(x * n + y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="LeetCode-935-Knight-Dialer-骑士拨号器"><a href="#LeetCode-935-Knight-Dialer-骑士拨号器" class="headerlink" title="LeetCode] 935. Knight Dialer 骑士拨号器"></a>LeetCode] 935. Knight Dialer 骑士拨号器</h1><p>The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:</p>
<p>A chess knight can move as indicated in the chess diagram below:<br><img src="/img/1632645545.jpg" alt=""></p>
<p>We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).</p>
<p>Given an integer n, return how many distinct phone numbers of length n we can dial.</p>
<p>You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.</p>
<p>As the answer may be very large, return the answer modulo 109 + 7.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 20</span><br><span class="line">Explanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: 46</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4</span><br><span class="line">Output: 104</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3131</span><br><span class="line">Output: 136006598</span><br><span class="line">Explanation: Please take care of the mod.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= n &lt;= 5000</li>
</ul>
<p>这道题说是有一种骑士拨号器，在一个电话拨号盘上跳跃，其跳跃方式是跟国际象棋中的一样，不会国际象棋的童鞋可以将其当作中国象棋中的马，马走日象飞田。这个骑士可以放在 10 个数字键上的任意一个，但其跳到的下一个位置却要符合其在国际象棋中的规则，也就是走日。现在给了一个整数N，说是该骑士可以跳N次，问能拨出多个不同的号码，并且提示了结果要对一个超大数字取余。这里使用一个二维数组 dp，其中 dp[i][j] 表示骑士第i次跳到数字j时组成的不同号码的个数，那么最终所求的就是将 dp[N-1][j] 累加起来，j的范围是0到9。接下来看状态转移方程怎么写，当骑士在第i次跳到数字j时，考虑其第 i-1 次是在哪个位置，可能有多种情况，先来分析拨号键盘的结构，找出从每个数字能到达的下一个位置，可得如下关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0 -&gt; 4, 6</span><br><span class="line">1 -&gt; 6, 8</span><br><span class="line">2 -&gt; 7, 9</span><br><span class="line">3 -&gt; 4, 8</span><br><span class="line">4 -&gt; 3, 9, 0</span><br><span class="line">5 -&gt;</span><br><span class="line">6 -&gt; 1, 7, 0</span><br><span class="line">7 -&gt; 2, 6</span><br><span class="line">8 -&gt; 1, 3</span><br><span class="line">9 -&gt; 4, 2</span><br></pre></td></tr></table></figure><br>可以发现，除了数字5之外，每个数字都可以跳到其他位置，其中4和6可以跳到三个不同位置，其他都只能取两个位置。反过来想，可以去的位置，就表示也可能从该位置回来，所以根据当前的位置j，就可以在数组中找到上一次骑士所在的位置，并将其的 dp 值累加上即可，这就是状态转移的方法，由于第一步是把骑士放到任意一个数字上，就要初始化 dp[0][j] 为1，然后进行状态转移就行了，记得每次累加之后要对超大数取余，最后将 dp[N-1][j] 累加起来的时候，也要对超大数取余，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">knightDialer</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; path&#123;&#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">8</span>&#125;, &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>&#125;, &#123;&#125;, &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">1</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> idx : path[j]) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][idx]) % M;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) res = (res + dp.<span class="built_in">back</span>()[i]) % M;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以用递归+记忆数组的方式来写，整体思路和迭代的方法并没有什么区别，之前类似的题目也不少，就不多解释了，可以对照上面的讲解和代码来理解，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">knightDialer</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; path&#123;&#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">8</span>&#125;, &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>&#125;, &#123;&#125;, &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">1</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        	res = (res + <span class="built_in">helper</span>(N - <span class="number">1</span>, i, path, memo)) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span> (memo[n][cur] != <span class="number">0</span>) <span class="keyword">return</span> memo[n][cur];</span><br><span class="line">    	<span class="type">int</span> res = <span class="number">0</span>, M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> idx : path[cur]) &#123;</span><br><span class="line">    		res = (res + <span class="built_in">helper</span>(n - <span class="number">1</span>, idx, path, memo)) % M;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> memo[n][cur] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode937-Reorder-Data-in-Log-Files"><a href="#Leetcode937-Reorder-Data-in-Log-Files" class="headerlink" title="Leetcode937. Reorder Data in Log Files"></a>Leetcode937. Reorder Data in Log Files</h1><p>You have an array of logs.  Each log is a space delimited string of words.</p>
<p>For each log, the first word in each log is an alphanumeric identifier.  Then, either:</p>
<ul>
<li>Each word after the identifier will consist only of lowercase letters, or;</li>
<li>Each word after the identifier will consist only of digits.<br>We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier.</li>
</ul>
<p>Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order.</p>
<p>Return the final order of the logs.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: logs = [&quot;dig1 8 1 5 1&quot;,&quot;let1 art can&quot;,&quot;dig2 3 6&quot;,&quot;let2 own kit dig&quot;,&quot;let3 art zero&quot;]</span><br><span class="line">Output: [&quot;let1 art can&quot;,&quot;let3 art zero&quot;,&quot;let2 own kit dig&quot;,&quot;dig1 8 1 5 1&quot;,&quot;dig2 3 6&quot;]</span><br></pre></td></tr></table></figure><br>对于每条日志，其第一个字为字母数字标识符。然后，要么：标识符后面的每个字将仅由小写字母组成，或标识符后面的每个字将仅由数字组成。</p>
<p>将这两种日志分别称为字母日志和数字日志。保证每个日志在其标识符后面至少有一个字。将日志重新排序，使得所有字母日志都排在数字日志之前。字母日志按字母顺序排序，忽略标识符，标识符仅用于表示关系。数字日志应该按原来的顺序排列。返回日志的最终顺序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a,string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ii = <span class="number">0</span>, jj = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[ii ++] != <span class="string">&#x27; &#x27;</span>) ;</span><br><span class="line">        <span class="keyword">while</span>(b[jj ++] != <span class="string">&#x27; &#x27;</span>) ;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">substr</span>(ii, a.<span class="built_in">length</span>() - ii + <span class="number">1</span>) &lt;= b.<span class="built_in">substr</span>(jj, b.<span class="built_in">length</span>() - jj + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 这里要比较后边所有的，不能比较一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">reorderLogFiles</span><span class="params">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="type">int</span> len = logs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> ii = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(logs[i][ii ++] != <span class="string">&#x27; &#x27;</span>) ;</span><br><span class="line">            cout &lt;&lt; logs[i][ii] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span> &lt;= logs[i][ii] &amp;&amp; logs[i][ii] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(logs[i]);</span><br><span class="line">                flag[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span>(string t : res)</span><br><span class="line">            cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])</span><br><span class="line">                res.<span class="built_in">push_back</span>(logs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode938-Range-Sum-of-BST"><a href="#Leetcode938-Range-Sum-of-BST" class="headerlink" title="Leetcode938. Range Sum of BST"></a>Leetcode938. Range Sum of BST</h1><p>Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).</p>
<p>The binary search tree is guaranteed to have unique values.<br>一棵树，给定了根节点，再给一个范围（L，R），求这棵二叉树中在这个范围内的数的和，太简单了。。。直接递归查找，没难度，还奇怪呢这么简单的题还标着个medium。。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: root = [10,5,15,3,7,null,18], L = 7, R = 15</span><br><span class="line">Output: 32</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode* root, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt;= L &amp;&amp; root-&gt;val &lt;= R)</span><br><span class="line">                <span class="keyword">return</span> root-&gt;val + <span class="built_in">rangeSumBST</span>(root-&gt;left,L,R)+<span class="built_in">rangeSumBST</span>(root-&gt;right,L,R);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">rangeSumBST</span>(root-&gt;left,L,R)+<span class="built_in">rangeSumBST</span>(root-&gt;right,L,R);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode939-Minimum-Area-Rectangle"><a href="#Leetcode939-Minimum-Area-Rectangle" class="headerlink" title="Leetcode939. Minimum Area Rectangle"></a>Leetcode939. Minimum Area Rectangle</h1><p>Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.</p>
<p>If there isn’t any rectangle, return 0.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[1,3],[3,1],[3,3],[2,2]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= points.length &lt;= 500</li>
<li>0 &lt;= points[i][0] &lt;= 40000</li>
<li>0 &lt;= points[i][1] &lt;= 40000</li>
<li>All points are distinct.</li>
</ul>
<p>这道题给了我们一堆点的坐标，问能组成的最小的矩形面积是多少，题目中限定了矩形的边一定是平行于主轴的，不会出现旋转矩形的形状。如果知道了矩形的两个对角顶点坐标，求面积就非常的简单了，但是随便取四个点并不能保证一定是矩形，不过这四个点坐标之间是有联系的，相邻的两个顶点要么横坐标，要么纵坐标，一定有一个是相等的，这个特点先记下。策略是，先找出两个对角线的顶点，一但两个对角顶点确定了，其实这个矩形的大小也就确定了，另外的两个点其实就是分别在跟这两个点具有相同的横坐标或纵坐标的点中寻找即可，为了优化查找的时间，可以事先把所有具有相同横坐标的点的纵坐标放入到一个 HashSet 中，使用一个 HashMap，建立横坐标和所有具有该横坐标的点的纵坐标的集合之间的映射。然后开始遍历任意两个点的组合，由于这两个点必须是对角顶点，所以其横纵坐标均不能相等，若有一个相等了，则跳过该组合。否则看其中任意一个点的横坐标对应的集合中是否均包含另一个点的纵坐标，均包含的话，说明另两个顶点也是存在的，就可以计算矩形的面积了，更新结果 res，若最终 res 还是初始值，说明并没有能组成矩形，返回0即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minAreaRect</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX, n = points.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, unordered_set&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> point : points) &#123;</span><br><span class="line">            m[point[<span class="number">0</span>]].<span class="built_in">insert</span>(point[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>] || points[i][<span class="number">1</span>] == points[j][<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (m[points[i][<span class="number">0</span>]].<span class="built_in">count</span>(points[j][<span class="number">1</span>]) &amp;&amp; m[points[j][<span class="number">0</span>]].<span class="built_in">count</span>(points[i][<span class="number">1</span>])) &#123;</span><br><span class="line">                    res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) * <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]));</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode941-Valid-Mountain-Array"><a href="#Leetcode941-Valid-Mountain-Array" class="headerlink" title="Leetcode941. Valid Mountain Array"></a>Leetcode941. Valid Mountain Array</h1><p>Given an array A of integers, return true if and only if it is a valid mountain array.</p>
<p>Recall that A is a mountain array if and only if:</p>
<ul>
<li>A.length &gt;= 3</li>
<li>There exists some i with 0 &lt; i &lt; A.length - 1 such that:<ul>
<li>A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]</li>
<li>A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</li>
</ul>
</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,5,5]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,3,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validMountainArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A.<span class="built_in">size</span>() &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; A.<span class="built_in">size</span>()<span class="number">-1</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt;= A[i<span class="number">+1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == A.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; A.<span class="built_in">size</span>()<span class="number">-1</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt;= A[i<span class="number">+1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != A.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode942-DI-String-Match"><a href="#Leetcode942-DI-String-Match" class="headerlink" title="Leetcode942. DI String Match"></a>Leetcode942. DI String Match</h1><p>Given a string S that only contains “I” (increase) or “D” (decrease), let<code>N = S.length</code>.</p>
<p>Return any permutation A of [0, 1, …, N] such that for all<code>i = 0, ..., N-1</code>:</p>
<p>If S[i] == “I”, then A[i] &lt; A[i+1]<br>If S[i] == “D”, then A[i] &gt; A[i+1]</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IDID&quot;</span><br><span class="line">Output: [0,4,1,3,2]</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: [0,1,2,3]</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;DDI&quot;</span><br><span class="line">Output: [3,2,0,1]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= S.length &lt;= 10000<br>S only contains characters “I” or “D”.</p>
<p>题目的意思是，将字符串与数组一一对应，因为数组多一位，不考虑这一位。剩下的位置，如果字符串写的是‘I’，那么该位置上的数应该比右边所有的数都小。而如果是‘D’，则是比右边的都大。现在需要找到其中任意一组。</p>
<p>其实这个题是一个贪心，并且有点dp的感觉。感觉这个题解不唯一，其实还是比较简单能够证明反例。评论有人提出了解法证明，可以看一下：</p>
<p>只需要证明，对于任何 &gt; 或者 &lt; , 算法的规则都能满足。<br>△N = max-min; 由于每次遇到一个符号，△N-1。<br>当符号为“ &lt;   &lt;   &lt;”: max—可以保证符号的正确性。<br>当符号为“ &gt;   &gt;   &gt;”: min++可以保住符号的正确性。<br>当符号为“ ……&lt;   &gt;   &lt; “:  任意时刻max和min开始比较，是否满足 min &lt; max?<br>答案是：YES! 由于符号的数量为N，最开始△N = N。由于至少出现一对大于号和小于号 , min(△N)= 1，仍然满足min &lt; max;<br>综上，得证。</p>
<p>因为每一位对应的数字只有两种情况：比右边所有数都大，或者都小。那么我们可以设定两个值，初始的话：low = 0，high = N。这样，从左开始遍历字符串，碰见一个字符，如果是‘I’，那么就直接赋值low，同时low++。这样，‘I’右边所有的数，一定是都比这个位置大的。因为此时low&gt;a[i]，同时high &gt; low。</p>
<p>反而言之，碰见‘D’，直接赋值hight，同时high—。这样所有的数就一定比这个小了。大概就是这样，在O(n)的时间复杂度下就能构造出答案数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diStringMatch</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(S.<span class="built_in">size</span>()<span class="number">+1</span>);</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>,high=S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">                res[i]=low++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[i]=high--;</span><br><span class="line">        &#125;</span><br><span class="line">        res[S.<span class="built_in">size</span>()]=low;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode944-Delete-Columns-to-Make-Sorted"><a href="#Leetcode944-Delete-Columns-to-Make-Sorted" class="headerlink" title="Leetcode944. Delete Columns to Make Sorted"></a>Leetcode944. Delete Columns to Make Sorted</h1><p>We are given an array A of N lowercase letter strings, all of the same length.</p>
<p>Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.</p>
<p>For example, if we have an array A = [“abcdef”,”uvwxyz”] and deletion indices {0, 2, 3}, then the final array after deletions is [“bef”, “vyz”], and the remaining columns of A are [“b”,”v”], [“e”,”y”], and [“f”,”z”].  (Formally, the c-th column is [A[0][c], A[1][c], …, A[A.length-1][c]].)</p>
<p>Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order.</p>
<p>Return the minimum possible value of D.length.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;cba&quot;,&quot;daf&quot;,&quot;ghi&quot;]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><br>Explanation:<br>After choosing D = {1}, each column [“c”,”d”,”g”] and [“a”,”f”,”i”] are in non-decreasing sorted order.<br>If we chose D = {}, then a column [“b”,”a”,”h”] would not be in non-decreasing sorted order.<br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><br>Explanation: D = {}<br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><br>Explanation: D = {0, 1, 2}</p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 100<br>1 &lt;= A[i].length &lt;= 1000</p>
<p>字符串数组 A 中的每个字符串元素的长度相同，统计index个数，这个index 的要求是 A[i].charAt(index)，i=0,1,2,3,4 组成的 字符序列 不是严格递增。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDeletionSize</span><span class="params">(vector&lt;string&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> isize=A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> jsize=A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;jsize;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;isize<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][j]&gt;A[i<span class="number">+1</span>][j])&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode945-Minimum-Increment-to-Make-Array-Unique"><a href="#Leetcode945-Minimum-Increment-to-Make-Array-Unique" class="headerlink" title="Leetcode945. Minimum Increment to Make Array Unique"></a>Leetcode945. Minimum Increment to Make Array Unique</h1><p>Given an array of integers A, a  move  consists of choosing any A[i], and incrementing it by 1.</p>
<p>Return the least number of moves to make every value in A unique.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:  After 1 move, the array could be [1, 2, 3].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,2,1,7]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7].</span><br><span class="line">It can be shown with 5 or less moves that it is impossible for the array to have all unique values.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= A.length &lt;= 40000</li>
<li>0 &lt;= A[i] &lt; 40000</li>
</ul>
<p>这道题给了一个数组，说是每次可以将其中一个数字增加1，问最少增加多少次可以使得数组中没有重复数字。给的两个例子可以帮助我们很好的理解题意，这里主要参考了 lee215 大神的帖子，假如数组中没有重复数字的话，则不需要增加，只有当重复数字存在的时候才需要增加。比如例子1中，有两个2，需要将其中一个2增加到3，才能各不相同。但有时候只增加一次可能并不能解决问题，比如例子2中，假如要处理两个1，增加其中一个到2并不能解决问题，因此2也是有重复的，甚至增加到3还是有重复，所以一直得增加到4才行，但此时如何知道后面是否还有1，所以需要一个统一的方法来增加，最好是能从小到大处理数据，则先给数组排个序，然后用一个变量 need 表示此时需要增加到的数字，初始化为0，由于是从小到大处理，这个 need 会一直变大，而且任何小于 need 的数要么是数组中的数，要么是某个数字增后的数，反正都是出现过了。然后开始遍历数组，对于遍历到的数字 num，假如 need 大于 num，说明此时的 num 是重复数字，必须要提高到 need，则将 need-num 加入结果 res 中，反之若 need 小于 num，说明 num 并未出现过，不用增加。然后此时更新 need 为其和 num 之间的较大值并加1，因为 need 不能有重复，所以要加1，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minIncrementForUnique</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, need = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">        	res += <span class="built_in">max</span>(need - num, <span class="number">0</span>);</span><br><span class="line">        	need = <span class="built_in">max</span>(num, need) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假如数组中有大量的重复数字的话，那么上面的方法还是需要一个一个的来处理，来看一种能同时处理大量的重复数字的方法。这里使用了一个 TreeMap 来统计每个数字和其出现的次数之间的映射。由于 TreeMap 可以对 key 自动排序，所以就没有必要对原数组进行排序了，这里还是要用变量 need，整体思路和上面的解法很类似。建立好了 TreeMap 后开始遍历，此时单个数字的增长还是 max(need - num, 0)，这个已经在上面解释过了，由于可能由多个，所以还是要乘以个数 a.second，到这里还没有结束，因为 a.second 这多么多个数字都被增加到了同一个数字，而这些数字应该彼此再分开，好在现在没有比它们更大的数字，那么问题就变成了将k个相同的数字变为不同，最少的增加次数，答案是 k*(k-1)/2，这里就不详细推导了，其实就是个等差数列求和，这样就可以知道将 a.second 个数字变为不同总共需要增加的次数，下面更新 need，在 max(need, num) 的基础上，还要增加个数 a.second，从而到达一个最小的新数字，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minIncrementForUnique</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, need = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; numCnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : A) ++numCnt[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : numCnt) &#123;</span><br><span class="line">        	res += a.second * <span class="built_in">max</span>(need - a.first, <span class="number">0</span>) + a.second * (a.second - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        	need = <span class="built_in">max</span>(need, a.first) + a.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再来看一种联合查找 Union Find 的方法，这是一种并查集的方法，在岛屿群组类的问题上很常见，可以搜搜博主之前关于岛屿类题目的讲解，很多都使用了这种方法。但是这道题乍一看好像跟群组并没有明显的关系，但其实是有些很微妙的联系的。这里的 root 使用一个 HashMap，而不是用数组，因为数字不一定是连续的，而且可能跨度很大，使用 HashMap 会更加省空间一些。遍历原数组，对于每个遍历到的数字 num，调用 find 函数，这里实际上就是查找上面的方法中的 need，即最小的那个不重复的新数字，而 find 函数中会不停的更新 root[x]，而只要x存在，则不停的自增1，直到不存在时候，则返回其本身，那么实际上从 num 到 need 中所有的数字的 root 值都标记成了 need，就跟它们是属于一个群组一样，这样做的好处在以后的查询过程中可以更快的找到 need 值，这也是为啥这种方法不用给数组排序的原因，若还是不理解的童鞋可以将例子2代入算法一步一步执行，看每一步的 root 数组的值是多少，应该不难理解，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minIncrementForUnique</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">        	res += <span class="built_in">find</span>(root, num) - num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; root, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> root[x] = root.<span class="built_in">count</span>(x) ? <span class="built_in">find</span>(root, root[x] + <span class="number">1</span>) : x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="LeetCode946-Validate-Stack-Sequences"><a href="#LeetCode946-Validate-Stack-Sequences" class="headerlink" title="LeetCode946. Validate Stack Sequences"></a>LeetCode946. Validate Stack Sequences</h1><p>Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We might do the following sequence:</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: 1 cannot be popped before 2.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= pushed.length == popped.length &lt;= 1000</li>
<li>0 &lt;= pushed[i], popped[i] &lt; 1000</li>
<li>pushed is a permutation of popped.</li>
<li>pushed and popped have distinct values.</li>
</ul>
<p>这道题给了两个序列 pushed 和 popped，让判断这两个序列是否能表示同一个栈的压入和弹出操作，由于栈是后入先出的顺序，所以并不是任意的两个序列都是满足要求的。比如例子2中，先将 1，2，3，4 按顺序压入栈，此时4和3出栈，接下来压入5，再让5出栈，接下来出栈的是2而不是1，所以例子2会返回 false。而这道题主要就是模拟这个过程，使用一个栈，和一个变量i用来记录弹出序列的当前位置，此时遍历压入序列，对遍历到的数字都压入栈，此时要看弹出序列当前的数字是否和栈顶元素相同，相同的话就需要移除栈顶元素，并且i自增1，若下一个栈顶元素还跟新位置上的数字相同，还要进行相同的操作，所以用一个 while 循环来处理。直到最终遍历完压入序列后，若此时栈为空，则说明是符合题意的，否则就是 false，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : pushed) &#123;</span><br><span class="line">        	st.<span class="built_in">push</span>(num);</span><br><span class="line">        	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == popped[i]) &#123;</span><br><span class="line">        		st.<span class="built_in">pop</span>();</span><br><span class="line">        		++i;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode947-Most-Stones-Removed-with-Same-Row-or-Column"><a href="#Leetcode947-Most-Stones-Removed-with-Same-Row-or-Column" class="headerlink" title="Leetcode947. Most Stones Removed with Same Row or Column"></a>Leetcode947. Most Stones Removed with Same Row or Column</h1><p>On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.</p>
<p>A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.</p>
<p>Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: One way to remove 5 stones is as follows:</span><br><span class="line">Remove stone [2,2] because it shares the same row as [2,1].</span><br><span class="line">Remove stone [2,1] because it shares the same column as [0,1].</span><br><span class="line">Remove stone [1,2] because it shares the same row as [1,0].</span><br><span class="line">Remove stone [1,0] because it shares the same column as [0,0].</span><br><span class="line">Remove stone [0,1] because it shares the same row as [0,0].</span><br><span class="line">Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= stones.length &lt;= 1000</li>
<li>0 &lt;= xi, yi &lt;= 104</li>
<li>No two stones are at the same coordinate point.</li>
</ul>
<p>给一个2D数组，其中的元素代表2D的位置，同一位置只会有一个石头，同行或同列的石头能被移走（前提是存在与它同行或同列的石头，如果只有它自己就不能移走），问最多可移走多少个石头。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>问题转换：同行同列的石头阵可以被移走直到只剩下一个石头。那么把同行同列的石头全都归到一个group，这个group的个数就是最后剩下的石头数量。则被移走的石头数量=石头总数量 - group个数</p>
<p>任务就变成了把同行同列的石头归到一个group里，两种方法，DFS和Union-Find</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>可把 (row, col) 看作一条边，建立无向图。但是注意一个问题，就是(1,2) 和 (2,1)是两个位置，但会被认为是同一条边，这时需要把这两种边区分开，题中有这样一个限制条件0 &lt;= xi, yi &lt;= 104 ，所以可定义0～10000是row的区间，10001～20001是col的范围。也就是把col + 10001，但是实际上col+10000也通过了。</p>
<p>这样做就可以访问一个位置（row，col）时，把row行和col列的位置全都标记为访问过，再递归标记它们关联的行和列，为一个组。下一次再从未访问过的位置重新标记新的一组。这样就可找出一共有多少个组。</p>
<p>可能行和列的概念容易混淆，可以认为列也是要遍历的“行”，只不过列的index是从10000开始的。</p>
<p>这里标记访问过不是一个位置一个位置地标，而是标整行整列，表示这一行或列已经访问过（可把列理解为index从10000开始的“行”）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//19ms</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeStones</span><span class="params">(<span class="type">int</span>[][] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">groups</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">20001</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] stone : stones) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> stone[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> stone[<span class="number">1</span>] + <span class="number">10000</span>;</span><br><span class="line">            <span class="keyword">if</span>(!graph.containsKey(row)) &#123;</span><br><span class="line">                graph.put(row, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            graph.get(row).add(col);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!graph.containsKey(col)) &#123;</span><br><span class="line">                graph.put(col, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            graph.get(col).add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Integer key : graph.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[key]) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(key, graph, visited);</span><br><span class="line">            groups ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones.length - groups;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> rowCol, HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[rowCol]) <span class="keyword">return</span>;</span><br><span class="line">        visited[rowCol] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//行的话找同一列，列的话找同一行的stone，把同行或同列的标记为访问，为同一group</span></span><br><span class="line">        <span class="keyword">for</span>(Integer next : graph.get(rowCol)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[next]) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(next, graph, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果DFS深度过深，担心StackOverflowError，可用stack版DFS，和BFS差不多，只不过BFS用的queue储存节点，先进先访问。DFS用stack储存节点，后进的先访问，直到到达尽头。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeStones</span><span class="params">(<span class="type">int</span>[][] stones)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">groups</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">20001</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] stone : stones) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> stone[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> stone[<span class="number">1</span>] + <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">if</span>(!graph.containsKey(row)) &#123;</span><br><span class="line">            graph.put(row, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        graph.get(row).add(col);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!graph.containsKey(col)) &#123;</span><br><span class="line">            graph.put(col, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        graph.get(col).add(row);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Integer key : graph.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[key]) <span class="keyword">continue</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(key);</span><br><span class="line">        visited[key] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowCol</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">for</span>(Integer next : graph.get(rowCol)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[next]) <span class="keyword">continue</span>;</span><br><span class="line">                visited[next] = <span class="literal">true</span>;</span><br><span class="line">                stack.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        groups ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stones.length - groups;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Union-Find"><a href="#Union-Find" class="headerlink" title="Union-Find"></a>Union-Find</h2><p>思路和上面一样，也是把同行同列的归为一个group，最后用石头总数-group个数。</p>
<p>还是把(row, col）看成一条边，也可理解为它们是关联的数字。还是row是0～10000区间，col是10001～20001区间。但是这里加了一个情况，就是一个点还没有被访问的时候，它的parent是0，访问过的点要么parent是它自己，要么是其他点。所以为了和0区别开，row的范围移到1～10001，col移到10002～20002。所以row要加1，col要加10002。</p>
<ul>
<li>parent：上面还有其他parent。</li>
<li>root：parent是它自己（最上层parent）。</li>
</ul>
<p>统一把col的root设为row的root。这样做有什么用处？row和col有同一个root，当同一列的位置来的时候，可通过col找到这个root，当同一行的位置来的时候，可通过row找到同一root，这样就可达到把同行和同列的石头都归为一个group的效果。</p>
<p>当row和col未访问过，即parent==0时，把row的parent标记为它自己，col的parent标记为row。一个访问过一个没访问过时，标记root为访问过的root。</p>
<p>当有不同的root时，把col的root，重点强调是root，而不是简单的parent，标记为row的root<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeStones</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(<span class="number">20003</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> stone : stones)</span><br><span class="line">            <span class="built_in">uni</span>(parent, stone[<span class="number">0</span>]<span class="number">+1</span>, stone[<span class="number">1</span>]<span class="number">+10002</span>, res);</span><br><span class="line">        <span class="keyword">return</span> stones.<span class="built_in">size</span>() - res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> st1, <span class="type">int</span> st2, <span class="type">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pr = <span class="built_in">find</span>(parent, st1);</span><br><span class="line">        <span class="type">int</span> pc = <span class="built_in">find</span>(parent, st2);</span><br><span class="line">        <span class="keyword">if</span> (pr == pc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pr == <span class="number">0</span>) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">                parent[st1] = st1;</span><br><span class="line">                parent[st2] = st1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pr == <span class="number">0</span>)</span><br><span class="line">                parent[st1] = pc;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pc == <span class="number">0</span>)</span><br><span class="line">                parent[st2] = pr;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res --;</span><br><span class="line">                parent[pc] = pr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> st)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sp = parent[st];</span><br><span class="line">        <span class="keyword">while</span>(sp != parent[sp])</span><br><span class="line">            sp = parent[st] = <span class="built_in">find</span>(parent, sp);</span><br><span class="line">        <span class="keyword">return</span> sp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode948-Bag-of-Tokens"><a href="#Leetcode948-Bag-of-Tokens" class="headerlink" title="Leetcode948. Bag of Tokens"></a>Leetcode948. Bag of Tokens</h1><p>You have an initial power P, an initial score of 0 points, and a bag of tokens.</p>
<p>Each token can be used at most once, has a value token[i], and has potentially two ways to use it.</p>
<ul>
<li>If we have at least token[i] power, we may play the token face up, losing token[i] power, and gaining 1 point.</li>
<li>If we have at least 1 point, we may play the token face down, gaining token[i] power, and losing 1 point.</li>
</ul>
<p>Return the largest number of points we can have after playing any number of tokens.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens = [100], P = 50</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens = [100,200], P = 150</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens = [100,200,300,400], P = 200</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>tokens.length &lt;= 1000</li>
<li>0 &lt;= tokens[i] &lt; 10000</li>
<li>0 &lt;= P &lt; 10000</li>
</ul>
<p>这道题说是给了一个初始力量值P，然后有一个 tokens 数组，有两种操作可以选择，一种是减去 tokens[i] 的力量，得到一分，但是前提是减去后剩余的力量不能为负。另一种是减去一分，得到 tokens[i] 的力量，前提是减去后的分数不能为负，问一顿操作猛如虎后可以得到的最高分数是多少。这道题其实题意不是太容易理解，而且例子也没给解释，博主也是读了好几遍题目才明白的。比如例子3，开始有 200 的力量，可以先花 100，得到1个积分，此时还剩 100 的力量，但由于剩下的 token 值都太大，没法换积分了，只能用积分来换力量，既然都是花一个1个积分，肯定是要换最多的力量，于是换来 400 力量，此时总共有 500 的力量，积分还是0，但是一顿操作后，白嫖了 400 的力量，岂不美哉？！这 500 的力量刚好可以换两个积分，所以最后返回的就是2。通过上述分析，基本上可以知道策略了，从最小的 token 开始，用力量换积分，当力量不够时，就用基本换最大的力量，如果没有积分可以换力量，就结束，或者所有的 token 都使用过了，也结束，这就是典型的贪婪算法 Greedy Algorithm，也算对得起其 Medium 的身价。这里先给 tokens 数组排个序，然后使用双指针i和j，分别指向开头和末尾，当 i&lt;=j 进行循环，从小的 token 开始查找，只要力量够，就换成积分，不能换的时候，假如 i&gt;j 或者此时积分为0，则退出；否则用一个积分换最大的力量，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bagOfTokensScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; tokens, <span class="type">int</span> P)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cur = <span class="number">0</span>, n = tokens.<span class="built_in">size</span>(), i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(tokens.<span class="built_in">begin</span>(), tokens.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; tokens[i] &lt;= P) &#123;</span><br><span class="line">                P -= tokens[i++];</span><br><span class="line">                res = <span class="built_in">max</span>(res, ++cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j || cur == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            --cur;</span><br><span class="line">            P += tokens[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以换一种写法，不用 while 套 while，而是换成赏心悦目的 if … else 语句，其实也没差啦，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bagOfTokensScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; tokens, <span class="type">int</span> P)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cur = <span class="number">0</span>, n = tokens.<span class="built_in">size</span>(), i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(tokens.<span class="built_in">begin</span>(), tokens.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (P &gt;= tokens[i]) &#123;</span><br><span class="line">                P -= tokens[i++];</span><br><span class="line">                res = <span class="built_in">max</span>(res, ++cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --cur;</span><br><span class="line">                P += tokens[j--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以使用递归来做，使用一个子函数 helper，将i和j当作参数输入，其实原理跟上的方法一摸一样，不难理解，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bagOfTokensScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; tokens, <span class="type">int</span> P)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(tokens.<span class="built_in">begin</span>(), tokens.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(tokens, P, <span class="number">0</span>, (<span class="type">int</span>)tokens.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; tokens, <span class="type">int</span> P, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="type">int</span> res = cur;</span><br><span class="line">        <span class="keyword">if</span> (tokens[i] &lt;= P) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">helper</span>(tokens, P - tokens[i], i + <span class="number">1</span>, j, cur + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">helper</span>(tokens, P + tokens[j], i, j - <span class="number">1</span>, cur - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode949-Largest-Time-for-Given-Digits"><a href="#Leetcode949-Largest-Time-for-Given-Digits" class="headerlink" title="Leetcode949. Largest Time for Given Digits"></a>Leetcode949. Largest Time for Given Digits</h1><p>Given an array of 4 digits, return the largest 24 hour time that can be made. The smallest 24 hour time is 00:00, and the largest is 23:59.  Starting from 00:00, a time is larger if more time has elapsed since midnight. Return the answer as a string of length 5.  If no valid time can be made, return an empty string.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4]</span><br><span class="line">Output: &quot;23:41&quot;</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,5,5]</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure><br>使用STL中的全排列生成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestTimeFromDigits</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>( (A[<span class="number">0</span>] &lt;= <span class="number">1</span> || (A[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; A[<span class="number">1</span>] &lt; <span class="number">4</span>)) &amp;&amp; A[<span class="number">2</span>] &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                stringstream ss;</span><br><span class="line">                ss &lt;&lt; A[<span class="number">0</span>] &lt;&lt; A[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; A[<span class="number">2</span>] &lt;&lt; A[<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="built_in">prev_permutation</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode950-Reveal-Cards-In-Increasing-Order"><a href="#Leetcode950-Reveal-Cards-In-Increasing-Order" class="headerlink" title="Leetcode950. Reveal Cards In Increasing Order"></a>Leetcode950. Reveal Cards In Increasing Order</h1><p>In a deck of cards, every card has a unique integer.  You can order the deck in any order you want.</p>
<p>Initially, all the cards start face down (unrevealed) in one deck.</p>
<p>Now, you do the following steps repeatedly, until all cards are revealed:</p>
<p>Take the top card of the deck, reveal it, and take it out of the deck.<br>If there are still cards in the deck, put the next top card of the deck at the bottom of the deck.<br>If there are still unrevealed cards, go back to step 1.  Otherwise, stop.<br>Return an ordering of the deck that would reveal the cards in increasing order.</p>
<p>The first entry in the answer is considered to be the top of the deck.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: [17,13,11,2,3,5,7]</span><br><span class="line">Output: [2,13,3,11,5,17,7]</span><br><span class="line">Explanation: </span><br><span class="line">We get the deck in the order [17,13,11,2,3,5,7] (this order doesn&#x27;t matter), and reorder it.</span><br><span class="line">After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.</span><br><span class="line">We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].</span><br><span class="line">We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].</span><br><span class="line">We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].</span><br><span class="line">We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].</span><br><span class="line">We reveal 11, and move 17 to the bottom.  The deck is now [13,17].</span><br><span class="line">We reveal 13, and move 17 to the bottom.  The deck is now [17].</span><br><span class="line">We reveal 17.</span><br><span class="line">Since all the cards revealed are in increasing order, the answer is correct.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 1000<br>1 &lt;= A[i] &lt;= 10^6<br>A[i] != A[j] for all i != j</p>
<p>woc什么乱七八糟的题，这个确实没懂。</p>
<p>从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。<br>如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。<br>如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。<br>得到的序列要求是递增序列。</p>
<p>例如 1 3 2 通过上述变换，可以得到1 2 3，满足题目要求。</p>
<p>解法是：1 2 3 通过上述变换，可以得到 1 3 2，即这道题的解。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">deckRevealedIncreasing</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(deck.size())</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(deck.<span class="built_in">begin</span>(),deck.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;deck.<span class="built_in">size</span>();i++)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;deck.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">            res[temp]=deck[i];</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(temp);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode951-Flip-Equivalent-Binary-Trees"><a href="#Leetcode951-Flip-Equivalent-Binary-Trees" class="headerlink" title="Leetcode951. Flip Equivalent Binary Trees"></a>Leetcode951. Flip Equivalent Binary Trees</h1><p>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p>
<p>A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p>
<p>Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes root1 and root2.</p>
<p>Example 1:</p>
<p>Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]<br>Output: true<br>Explanation: We flipped at nodes with values 1, 3, and 5.<br><img src="/img/20190827800.png" alt=""></p>
<p>这种做法好复杂啊。。。有太多情况需要考虑了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* root1, TreeNode* root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root1-&gt;left == <span class="literal">NULL</span> &amp;&amp; root1-&gt;right == <span class="literal">NULL</span> &amp;&amp; root2-&gt;left == <span class="literal">NULL</span> &amp;&amp; root2-&gt;right == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( root1-&gt;left != <span class="literal">NULL</span> &amp;&amp; root1-&gt;right != <span class="literal">NULL</span> &amp;&amp; root2-&gt;left != <span class="literal">NULL</span> &amp;&amp; root2-&gt;right != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">             <span class="keyword">if</span>(root1-&gt;left-&gt;val == root2-&gt;left-&gt;val &amp;&amp; root1-&gt;right-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root1-&gt;right-&gt;val == root2-&gt;left-&gt;val &amp;&amp; root1-&gt;left-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                TreeNode* temp = root1-&gt;right;</span><br><span class="line">                root1-&gt;right = root1-&gt;left;</span><br><span class="line">                root1-&gt;left = temp;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( root1-&gt;left == <span class="literal">NULL</span> &amp;&amp; root1-&gt;right != <span class="literal">NULL</span> &amp;&amp; root2-&gt;left == <span class="literal">NULL</span> &amp;&amp; root2-&gt;right != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>(root1-&gt;right-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( root1-&gt;left != <span class="literal">NULL</span> &amp;&amp; root1-&gt;right == <span class="literal">NULL</span> &amp;&amp; root2-&gt;left != <span class="literal">NULL</span> &amp;&amp; root2-&gt;right == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root1-&gt;left-&gt;val == root2-&gt;left-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( root1-&gt;left == <span class="literal">NULL</span> &amp;&amp; root1-&gt;right != <span class="literal">NULL</span> &amp;&amp; root2-&gt;left != <span class="literal">NULL</span> &amp;&amp; root2-&gt;right == <span class="literal">NULL</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>(root1-&gt;right-&gt;val == root2-&gt;left-&gt;val) &#123;</span><br><span class="line">                root1-&gt;left = root1-&gt;right;</span><br><span class="line">                root1-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( root1-&gt;left != <span class="literal">NULL</span> &amp;&amp; root1-&gt;right == <span class="literal">NULL</span> &amp;&amp; root2-&gt;left == <span class="literal">NULL</span> &amp;&amp; root2-&gt;right != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root1-&gt;left-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                root1-&gt;right = root1-&gt;left;</span><br><span class="line">                root1-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">order</span><span class="params">(TreeNode* root1, TreeNode* root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">NULL</span> &amp;&amp; root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">NULL</span> || root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( root1 != <span class="literal">NULL</span> &amp;&amp; root2 != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root1-&gt;val == root2-&gt;val)</span><br><span class="line">                <span class="built_in">compare</span>(root1, root2);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">order</span>(root1-&gt;left, root2-&gt;left) &amp;&amp; <span class="built_in">order</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">flipEquiv</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">order</span>(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>另一种做法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">flipEquiv</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Two null trees are flip equivalent</span></span><br><span class="line">        <span class="comment">// A non-null and null tree are NOT flip equivalent</span></span><br><span class="line">        <span class="comment">// Two non-null trees with different root values are NOT flip equivalent</span></span><br><span class="line">        <span class="comment">// Two non-null trees are flip equivalent if</span></span><br><span class="line">        <span class="comment">//      The left subtree of tree1 is flip equivalent with the left subtree of tree2 and the right subtree of tree1 is   </span></span><br><span class="line">        <span class="comment">//      flipequivalent with the right subtree of tree2 (no flip case)</span></span><br><span class="line">        <span class="comment">//      OR</span></span><br><span class="line">        <span class="comment">//      The right subtree of tree1 is flip equivalent with the left subtree of tree2 and the left subtree of tree1 is</span></span><br><span class="line">        <span class="comment">//      flipequivalent with the right subtree of tree2 (flip case)</span></span><br><span class="line">        <span class="keyword">if</span> ( !root1 &amp;&amp; !root2 ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !root1 &amp;&amp; root2 || root1 &amp;&amp;!root2 || root1-&gt;val != root2-&gt;val ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">flipEquiv</span>( root1-&gt;left, root2-&gt;left ) &amp;&amp; <span class="built_in">flipEquiv</span>( root1-&gt;right, root2-&gt;right )</span><br><span class="line">            || <span class="built_in">flipEquiv</span>( root1-&gt;right, root2-&gt;left ) &amp;&amp; <span class="built_in">flipEquiv</span>( root1-&gt;left, root2-&gt;right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode953-Verifying-an-Alien-Dictionary"><a href="#Leetcode953-Verifying-an-Alien-Dictionary" class="headerlink" title="Leetcode953. Verifying an Alien Dictionary"></a>Leetcode953. Verifying an Alien Dictionary</h1><p>In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.</p>
<p>Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: As &#x27;h&#x27; comes before &#x27;l&#x27; in this language, then the sequence is sorted.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: As &#x27;d&#x27; comes after &#x27;l&#x27; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &#x27;l&#x27; &gt; &#x27;∅&#x27;, where &#x27;∅&#x27; is defined as the blank character which is less than any other character (More info).</span><br></pre></td></tr></table></figure><br>从一个新的字母序判断是不是有序的字符串数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAlienSorted</span><span class="params">(vector&lt;string&gt;&amp; words, string order)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; order.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            mp[order[i]] = i;</span><br><span class="line">        <span class="type">int</span> size = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size<span class="number">-1</span>; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> min_size = <span class="built_in">min</span>(words[i].<span class="built_in">length</span>(), words[j].<span class="built_in">length</span>());</span><br><span class="line">            <span class="type">int</span> k;</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; min_size; k ++)</span><br><span class="line">                <span class="keyword">if</span>(mp[words[i][k]] &gt; mp[words[j][k]])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (mp[words[i][k]] &lt; mp[words[j][k]])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">if</span>(k == min_size &amp;&amp; words[i].<span class="built_in">length</span>() &gt; words[j].<span class="built_in">length</span>())</span><br><span class="line">	                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode955-Delete-Columns-to-Make-Sorted-II"><a href="#Leetcode955-Delete-Columns-to-Make-Sorted-II" class="headerlink" title="Leetcode955. Delete Columns to Make Sorted II"></a>Leetcode955. Delete Columns to Make Sorted II</h1><p>We are given an array A of N lowercase letter strings, all of the same length.</p>
<p>Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.</p>
<p>For example, if we have an array A = [“abcdef”,”uvwxyz”] and deletion indices {0, 2, 3}, then the final array after deletions is [“bef”,”vyz”].</p>
<p>Suppose we chose a set of deletion indices D such that after deletions, the final array has its elements in lexicographic order (A[0] &lt;= A[1] &lt;= A[2] … &lt;= A[A.length - 1]).</p>
<p>Return the minimum possible value of D.length.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;ca&quot;,&quot;bb&quot;,&quot;ac&quot;]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">After deleting the first column, A = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].</span><br><span class="line">Now A is in lexicographic order (ie. A[0] &lt;= A[1] &lt;= A[2]).</span><br><span class="line">We require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;xc&quot;,&quot;yb&quot;,&quot;za&quot;]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">A is already in lexicographic order, so we don&#x27;t need to delete anything.</span><br><span class="line">Note that the rows of A are not necessarily in lexicographic order:</span><br><span class="line">ie. it is NOT necessarily true that (A[0][0] &lt;= A[0][1] &lt;= ...)</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">We have to delete every column.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 100</li>
<li>1 &lt;= A[i].length &lt;= 100</li>
</ul>
<p>这道题说是给了一个字符串数组，里面的字符串长度均相同，这样如果将每个字符串看作一个字符数组的话，于是就可以看作的一个二维数组，题目要求数组中的字符串是按照字母顺序的，问最少需要删掉多少列。我们知道比较两个长度相等的字符串的字母顺序时，就是从开头起按照两两对应的位置比较，只要前面的字符顺序已经比出来了，后面的字符的顺序就不用管了，比如 “bx” 和 “ea”，因为 b 比 e 小，所以 “bx” 比 “ea” 小，后面的 x 和 a 的顺序无关紧要。如果看成二维数组的话，在比较<code>A[i][j]</code>和<code>A[i+1][j]</code>时，假如 [0, j-1] 中的某个位置k，已经满足了<code>A[i][k] &lt; A[i+1][k]</code>的话，这里就不用再比了，所以用一个数组 sorted 来标记某相邻的两个字符串之间是否已经按照字母顺序排列了。然后用两个 for 循环，外层是遍历列，内层是遍历行，然后看若<code>sorted[i]</code>为 false，且<code>A[i][j] &gt; A[i + 1][j]</code>的话，说明当前列需要被删除，结果 res 自增1，且 break 掉内层 for 循环。当内层 for 循环 break 掉或者自己结束后，此时看 i 是否小于 m-1，是的话说明是 break 掉的，直接 continue 外层循环。若是自己退出的，则在遍历一遍所有行，更新一下 sorted 数组即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDeletionSize</span><span class="params">(vector&lt;string&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, m = A.<span class="built_in">size</span>(), n = A[<span class="number">0</span>].<span class="built_in">size</span>(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sorted</span><span class="params">(m - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sorted[i] &amp;&amp; A[i][j] &gt; A[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                sorted[i] |= A[i][j] &lt; A[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode957-Prison-Cells-After-N-Days"><a href="#Leetcode957-Prison-Cells-After-N-Days" class="headerlink" title="Leetcode957. Prison Cells After N Days"></a>Leetcode957. Prison Cells After N Days</h1><p>There are 8 prison cells in a row, and each cell is either occupied or vacant.</p>
<p>Each day, whether the cell is occupied or vacant changes according to the following rules:</p>
<p>If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.<br>Otherwise, it becomes vacant.<br>(Note that because the prison is a row, the first and the last cells in the row can’t have two adjacent neighbors.)</p>
<p>We describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.</p>
<p>Given the initial state of the prison, return the state of the prison after N days (and N such changes described above.)</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: cells = [0,1,0,1,1,0,0,1], N = 7</span><br><span class="line">Output: [0,0,1,1,0,0,0,0]</span><br><span class="line">Explanation: The following table summarizes the state of the prison on each day:</span><br><span class="line">Day 0: [0, 1, 0, 1, 1, 0, 0, 1]</span><br><span class="line">Day 1: [0, 1, 1, 0, 0, 0, 0, 0]</span><br><span class="line">Day 2: [0, 0, 0, 0, 1, 1, 1, 0]</span><br><span class="line">Day 3: [0, 1, 1, 0, 0, 1, 0, 0]</span><br><span class="line">Day 4: [0, 0, 0, 0, 0, 1, 0, 0]</span><br><span class="line">Day 5: [0, 1, 1, 1, 0, 1, 0, 0]</span><br><span class="line">Day 6: [0, 0, 1, 0, 1, 1, 0, 0]</span><br><span class="line">Day 7: [0, 0, 1, 1, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: cells = [1,0,0,1,0,0,1,0], N = 1000000000</span><br><span class="line">Output: [0,0,1,1,1,1,1,0]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>cells.length == 8</li>
<li>cells[i] is in {0, 1}</li>
<li>1 &lt;= N &lt;= 10^9</li>
</ul>
<p>这道题给了一个只由0和1构成的数组，数组长度固定为8，现在要进行N步变换，变换的规则是若一个位置的左右两边的数字相同，则该位置的数字变为1，反之则变为0，让求N步变换后的数组的状态。需要注意的数组的开头和结尾的两个位置，由于一个没有左边，一个没有右边，默认其左右两边的数字不相等，所以不管首尾数字初始的时候是啥，在第一次变换之后一定会是0，而且一直会保持0的状态。可能是有一个周期循环的，这样就完全没有必要每次都算一遍。正确的做法的应该是建立状态和当前N值的映射，一旦当前计算出的状态在 HashMap 中出现了，说明周期找到了，这样就可以通过取余来快速的缩小N值。为了使用 HashMap 而不是 TreeMap，这里首先将数组变为字符串，然后开始循环N，将当前状态映射为 N-1，然后新建了一个长度为8，且都是0的字符串。更新的时候不用考虑首尾两个位置，因为前面说了，首尾两个位置一定会变为0。更新完成了后，便在 HashMap 查找这个状态是否出现过，是的话算出周期，然后N对周期取余。最后再把状态字符串转为数组即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prisonAfterNDays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cells, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : cells) str += <span class="built_in">to_string</span>(num);</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            m[str] = N--;</span><br><span class="line">            <span class="function">string <span class="title">cur</span><span class="params">(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">                cur[i] = (str[i - <span class="number">1</span>] == str[i + <span class="number">1</span>]) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            str = cur;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(str)) &#123;</span><br><span class="line">                N %= m[str] - N;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str) res.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode958-Check-Completeness-of-a-Binary-Tree"><a href="#Leetcode958-Check-Completeness-of-a-Binary-Tree" class="headerlink" title="Leetcode958. Check Completeness of a Binary Tree"></a>Leetcode958. Check Completeness of a Binary Tree</h1><p>Given a binary tree, determine if it is a complete binary tree.</p>
<p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Every level before the last is full (ie. levels with node-values &#123;1&#125; and &#123;2, 3&#125;), and all nodes in the last level (&#123;4, 5, 6&#125;) are as far left as possible.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,null,7]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The node with value 7 isn&#x27;t as far left as possible.</span><br></pre></td></tr></table></figure></p>
<p>用BFS遍历二叉树，当遇到空节点时，如果队列中还有未遍历的节点则该二叉树不完整。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        <span class="type">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="literal">NULL</span>)</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!res)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode959-Regions-Cut-By-Slashes"><a href="#Leetcode959-Regions-Cut-By-Slashes" class="headerlink" title="Leetcode959. Regions Cut By Slashes"></a>Leetcode959. Regions Cut By Slashes</h1><p>In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \, or blank space.  These characters divide the square into contiguous regions.</p>
<p>(Note that backslash characters are escaped, so a \ is represented as “\\”.)</p>
<p>Return the number of regions.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">  &quot; /&quot;,</span><br><span class="line">  &quot;/ &quot;</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><br>Explanation: The 2x2 grid is as follows:<br><img src="/img/20211115105401.png" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">  &quot; /&quot;,</span><br><span class="line">  &quot;  &quot;</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><br>Explanation: The 2x2 grid is as follows:<br><img src="/img/20211115105402.png" alt=""></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">  &quot;\\/&quot;,</span><br><span class="line">  &quot;/\\&quot;</span><br><span class="line">]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: (Recall that because \ characters are escaped, &quot;\\/&quot; refers to \/, and &quot;/\\&quot; refers to /\.)</span><br></pre></td></tr></table></figure><br>The 2x2 grid is as follows:<br><img src="/img/20211115105403.png" alt=""></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">  &quot;/\\&quot;,</span><br><span class="line">  &quot;\\/&quot;</span><br><span class="line">]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: (Recall that because \ characters are escaped, &quot;/\\&quot; refers to /\, and &quot;\\/&quot; refers to \/.)</span><br></pre></td></tr></table></figure></p>
<p>The 2x2 grid is as follows:<br><img src="/img/20211115105404.png" alt=""></p>
<p>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">  &quot;//&quot;,</span><br><span class="line">  &quot;/ &quot;</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The 2x2 grid is as follows:</span><br></pre></td></tr></table></figure><br><img src="/img/20211115105405.png" alt=""></p>
<p>Note:</p>
<ul>
<li>1 &lt;= grid.length == grid[0].length &lt;= 30</li>
<li>grid[i][j] is either ‘/‘, ‘\’, or ‘ ‘.</li>
</ul>
<p>这道题说是有个 NxN 个小方块，每个小方块里可能是斜杠，反斜杠，或者是空格。然后问这些斜杠能将整个区域划分成多少个小区域。这的确是一道很有意思的题目，虽然只是 Medium 的难度，但是博主拿到题目的时候是懵逼的，这尼玛怎么做？无奈只好去论坛上看大神们的解法，结果发现大神们果然牛b，巧妙的将这道题转化为了岛屿个数问题 Number of Islands，具体的做法将每个小区间化为九个小格子，这样斜杠或者反斜杠就是对角线或者逆对角线了，是不是有点图像像素化的感觉，就是当你把某个图片尽可能的放大后，到最后你看到也就是一个个不同颜色的小格子组成了这幅图片。这样只要把斜杠的位置都标记为1，而空白的位置都标记为0，这样只要找出分隔开的0的群组的个数就可以了，就是岛屿个数的问题啦。使用一个 DFS 来遍历即可，这个并不难，这道题难就难在需要想出来这种像素化得转化，确实需要灵光一现啊，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">regionsBySlashes</span><span class="params">(vector&lt;string&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(<span class="number">3</span> * n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span> * n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    nums[i * <span class="number">3</span>][j * <span class="number">3</span> + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                    nums[i * <span class="number">3</span> + <span class="number">1</span>][j * <span class="number">3</span> + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    nums[i * <span class="number">3</span> + <span class="number">2</span>][j * <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;\\&#x27;</span>) &#123;</span><br><span class="line">                    nums[i * <span class="number">3</span>][j * <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                    nums[i * <span class="number">3</span> + <span class="number">1</span>][j * <span class="number">3</span> + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    nums[i * <span class="number">3</span> + <span class="number">2</span>][j * <span class="number">3</span> + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">helper</span>(nums, i, j);</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; nums.<span class="built_in">size</span>() &amp;&amp; j &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">helper</span>(nums, i - <span class="number">1</span>, j);</span><br><span class="line">            <span class="built_in">helper</span>(nums, i, j + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">helper</span>(nums, i + <span class="number">1</span>, j);</span><br><span class="line">            <span class="built_in">helper</span>(nums, i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode961-N-Repeated-Element-in-Size-2N-Array"><a href="#Leetcode961-N-Repeated-Element-in-Size-2N-Array" class="headerlink" title="Leetcode961. N-Repeated Element in Size 2N Array"></a>Leetcode961. N-Repeated Element in Size 2N Array</h1><p>In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.</p>
<p>Return the element repeated N times.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2,5,3,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,1,5,2,5,3,5,4]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><br>Note:</p>
<p>4 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt; 10000<br>A.length is even</p>
<p>一个桶排序搞定<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">repeatedNTimes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> counter[<span class="number">10000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(counter, <span class="number">0</span>, <span class="built_in">sizeof</span>(counter));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            counter[A[i]] ++;</span><br><span class="line">            <span class="keyword">if</span>(counter[A[i]] &gt;= A.<span class="built_in">size</span>() / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>看到了大佬的解法，跪了，如果有两个连续一样的元素，直接返回</p>
<p>The intuition here is that the repeated numbers have to appear either next to each other (A[i] == A[i + 1]), or alternated (A[i] == A[i + 2]).</p>
<p>The only exception is sequences like [2, 1, 3, 2]. In this case, the result is the last number, so we just return it in the end. This solution has O(n) runtime.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int repeatedNTimes(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">  for (auto i = 0; i &lt; A.size() - 2; ++i)</span><br><span class="line">    if (A[i] == A[i + 1] || A[i] == A[i + 2]) return A[i];</span><br><span class="line">  return A[A.size() - 1]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Another interesting approach is to use randomization (courtesy of @lee215 ). If you pick two numbers randomly, there is a 25% chance you bump into the repeated number. So, in average, we will find the answer in 4 attempts, thus O(4) runtime.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int repeatedNTimes(vector&lt;int&gt;&amp; A, int i = 0, int j = 0) &#123;</span><br><span class="line">  while (A[i = rand() % A.size()] != A[j = rand() % A.size()] || i == j);</span><br><span class="line">  return A[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode962-Maximum-Width-Ramp"><a href="#Leetcode962-Maximum-Width-Ramp" class="headerlink" title="Leetcode962. Maximum Width Ramp"></a>Leetcode962. Maximum Width Ramp</h1><p>A ramp in an integer array nums is a pair (i, j) for which i &lt; j and nums[i] &lt;= nums[j]. The width of such a ramp is j - i.</p>
<p>Given an integer array nums, return the maximum width of a ramp in nums. If there is no ramp in nums, return 0.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [6,0,8,2,1,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The maximum width ramp is achieved at (i, j) = (1, 5): nums[1] = 0 and nums[5] = 5.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [9,8,1,0,1,9,4,0,4,1]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: The maximum width ramp is achieved at (i, j) = (2, 9): nums[2] = 1 and nums[9] = 1.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>2 &lt;= nums.length &lt;= 5 * 104</li>
<li>0 &lt;= nums[i] &lt;= 5 * 104</li>
</ul>
<p>这道题说给了一个数组A，这里定义了一种叫做 Ramp 的范围 (i, j)，满足 i &lt; j 且 A[i] &lt;= A[j]，而 ramp 就是 j - i，这里让求最宽的 ramp，若没有，则返回0。其实就是让在数组中找一前一后的两个数字，前面的数字小于等于后面的数字，且两个数字需要相距最远，让求这个最远的距离。先想一下，什么时侯不存在这个 ramp，就是当数组是严格递减的时候，那么不存在前面的数字小于等于后面的数字的情况，于是 ramp 是0。这道题的优化解法应该是使用单调栈。这里用一个数组 idx，来记录一个单调递减数组中数字的下标，遍历原数组A，对于每个遍历到的数字 A[i]，判断若此时下标数组为空，或者当前数字 A[i] 小于该下标数组中最后一个坐标在A中表示的数字时，将当前坐标i加入 idx，继续保持单调递减的顺序。反之，若 A[i] 比较大，则可以用二分搜索法来找出单调递减数组中第一个小于 A[i] 的数字的坐标，这样就可以快速得到 ramp 的大小，并用来更新结果 res 即可，这样整体的复杂度就降到了 O(nlgn)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxWidthRamp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span> || nums[i] &lt;= nums[s.<span class="built_in">back</span>()])</span><br><span class="line">                s.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &gt; nums[i])</span><br><span class="line">                        left = mid<span class="number">+1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, i - s[right]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxWidthRamp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(s.<span class="built_in">empty</span>() || A[s.<span class="built_in">top</span>()] &gt; A[i])<span class="comment">//单调递减栈</span></span><br><span class="line">                s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = A.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; A[i] &gt;= A[s.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                maxlen = <span class="built_in">max</span>(maxlen, i-s.<span class="built_in">top</span>());</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode963-Minimum-Area-Rectangle-II"><a href="#Leetcode963-Minimum-Area-Rectangle-II" class="headerlink" title="Leetcode963. Minimum Area Rectangle II"></a>Leetcode963. Minimum Area Rectangle II</h1><p>Given a set of points in the xy-plane, determine the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the x and y axes.</p>
<p>If there isn’t any rectangle, return 0.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[2,1],[1,0],[0,1]]</span><br><span class="line">Output: 2.00000</span><br><span class="line">Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.</span><br></pre></td></tr></table></figure><br><img src="/img/20211115105406.png" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1],[2,1],[1,1],[1,0],[2,0]]</span><br><span class="line">Output: 1.00000 </span><br><span class="line">Explanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.</span><br></pre></td></tr></table></figure><br><img src="/img/20211115105407.png" alt=""></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,3],[1,2],[3,1],[1,3],[2,1]]</span><br><span class="line">Output: 0 </span><br><span class="line">Explanation: There is no possible rectangle to form from these points.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]</span><br><span class="line">Output: 2.00000 </span><br><span class="line">Explanation: The minimum area rectangle occurs at [2,1],[2,3],[3,3],[3,1], with an area of 2.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= points.length &lt;= 50</li>
<li>0 &lt;= points[i][0] &lt;= 40000</li>
<li>0 &lt;= points[i][1] &lt;= 40000</li>
<li>All points are distinct.</li>
<li>Answers within 10^-5 of the actual value will be accepted as correct.</li>
</ul>
<p>这道题是之前那道 Minimum Area Rectangle 的拓展，虽说是拓展，但是解题思想完全不同。那道题由于矩形不能随意翻转，所以任意两个相邻的顶点一定是相同的横坐标或者纵坐标，而这道题就不一样了，矩形可以任意翻转，就不能利用之前的特点了。那该怎么办呢，这里就要利用到矩形的对角线的特点了，我们都知道矩形的两条对角线长度是相等的，而且相交于矩形的中心，这个中心可以通过两个对顶点的坐标求出来。只要找到了两组对顶点，它们的中心重合，并且表示的对角线长度相等，则一定可以组成矩形。基于这种思想，可以遍历任意两个顶点，求出它们之间的距离，和中心点的坐标，将这两个信息组成一个字符串，建立和顶点在数组中位置之间的映射，这样能组成矩形的点就被归类到一起了。接下来就是遍历这个 HashMap 了，只能取出两组顶点及更多的地方，开始遍历，分别通过顶点的坐标算出两条边的长度，然后相乘用来更新结果 res 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">minAreaFreeRect</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">double</span> res = DBL_MAX;</span><br><span class="line">        unordered_map&lt;string, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">long</span> dist = <span class="built_in">getLength</span>(points[i], points[j]);</span><br><span class="line">                <span class="type">double</span> centerX = (points[i][<span class="number">0</span>] + points[j][<span class="number">0</span>]) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="type">double</span> centerY = (points[i][<span class="number">1</span>] + points[j][<span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">                string key = <span class="built_in">to_string</span>(dist) + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(centerX) + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(centerY);</span><br><span class="line">                m[key].<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : m) &#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec = a.second;</span><br><span class="line">            <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; vec.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    <span class="type">int</span> p1 = vec[i][<span class="number">0</span>], p2 = vec[j][<span class="number">0</span>], p3 = vec[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">double</span> len1 = <span class="built_in">sqrt</span>(<span class="built_in">getLength</span>(points[p1], points[p2]));</span><br><span class="line">                    <span class="type">double</span> len2 = <span class="built_in">sqrt</span>(<span class="built_in">getLength</span>(points[p1], points[p3]));</span><br><span class="line">                    res = <span class="built_in">min</span>(res, len1 * len2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == DBL_MAX ? <span class="number">0.0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">getLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pt1, vector&lt;<span class="type">int</span>&gt;&amp; pt2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (pt1[<span class="number">0</span>] - pt2[<span class="number">0</span>]) * (pt1[<span class="number">0</span>] - pt2[<span class="number">0</span>]) + (pt1[<span class="number">1</span>] - pt2[<span class="number">1</span>]) * (pt1[<span class="number">1</span>] - pt2[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode965-Univalued-Binary-Tree"><a href="#Leetcode965-Univalued-Binary-Tree" class="headerlink" title="Leetcode965. Univalued Binary Tree"></a>Leetcode965. Univalued Binary Tree</h1><p>A binary tree is univalued if every node in the tree has the same value.</p>
<p>Return true if and only if the given tree is univalued.</p>
<p>Example 1:<br><img src="/img/20190524001.png" alt=""><br>Input: [1,1,1,1,1,null,1]<br>Output: true</p>
<p>Example 2:<br><img src="/img/20190524002.png" alt=""><br>Input: [2,2,2,5,2]<br>Output: false</p>
<p>Note:</p>
<p>The number of nodes in the given tree will be in the range [1, 100].<br>Each node’s value will be an integer in the range [0, 99].<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">des</span><span class="params">(TreeNode* root,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val != val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">des</span>(root-&gt;left,val)&amp;&amp;<span class="built_in">des</span>(root-&gt;right,val);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">des</span>(root,root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode966-Vowel-Spellchecker"><a href="#Leetcode966-Vowel-Spellchecker" class="headerlink" title="Leetcode966. Vowel Spellchecker"></a>Leetcode966. Vowel Spellchecker</h1><p>Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word.</p>
<p>For a given query word, the spell checker handles two categories of spelling mistakes:</p>
<ul>
<li>Capitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist.<ul>
<li>Example: wordlist = [“yellow”], query = “YellOw”: correct = “yellow”</li>
<li>Example: wordlist = [“Yellow”], query = “yellow”: correct = “Yellow”</li>
<li>Example: wordlist = [“yellow”], query = “yellow”: correct = “yellow”</li>
</ul>
</li>
<li>Vowel Errors: If after replacing the vowels (‘a’, ‘e’, ‘i’, ‘o’, ‘u’) of the query word with any vowel individually, it matches a word in the wordlist - (case-insensitive), then the query word is returned with the same case as the match in the wordlist.<ul>
<li>Example: wordlist = [“YellOw”], query = “yollow”: correct = “YellOw”</li>
<li>Example: wordlist = [“YellOw”], query = “yeellow”: correct = “” (no match)</li>
<li>Example: wordlist = [“YellOw”], query = “yllw”: correct = “” (no match)</li>
</ul>
</li>
</ul>
<p>In addition, the spell checker operates under the following precedence rules:</p>
<ul>
<li>When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.</li>
<li>When the query matches a word up to capitlization, you should return the first such match in the wordlist.</li>
<li>When the query matches a word up to vowel errors, you should return the first such match in the wordlist.</li>
<li>If the query has no matches in the wordlist, you should return the empty string.</li>
</ul>
<p>Given some queries, return a list of words answer, where answer[i] is the correct word for query = queries[i].</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: wordlist = [&quot;KiTe&quot;,&quot;kite&quot;,&quot;hare&quot;,&quot;Hare&quot;], queries = [&quot;kite&quot;,&quot;Kite&quot;,&quot;KiTe&quot;,&quot;Hare&quot;,&quot;HARE&quot;,&quot;Hear&quot;,&quot;hear&quot;,&quot;keti&quot;,&quot;keet&quot;,&quot;keto&quot;]</span><br><span class="line">Output: [&quot;kite&quot;,&quot;KiTe&quot;,&quot;KiTe&quot;,&quot;Hare&quot;,&quot;hare&quot;,&quot;&quot;,&quot;&quot;,&quot;KiTe&quot;,&quot;&quot;,&quot;KiTe&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= wordlist.length &lt;= 5000</li>
<li>1 &lt;= queries.length &lt;= 5000</li>
<li>1 &lt;= wordlist[i].length &lt;= 7</li>
<li>1 &lt;= queries[i].length &lt;= 7</li>
<li>All strings in wordlist and queries consist only of english letters.</li>
</ul>
<p>这道题给了一组单词，让实现一个拼写检查器，把查询单词转换成一个正确的单词。这个拼写检查器主要有两种功能，一种是可以忽略大小写，另一种是忽略元音的错误，所谓元音是 a，e，i，o，u，这五个字母。另外题目中还制定了一些其他规则：假如有和查询单词一模一样的单词，考虑大小写，此时应该优先返回。第二个优先级是字母及顺序都一样，但大小写可能不同的，第三个优先级是有元音错误的单词也可以返回，最后都不满足的话返回空串。首先对于第一种情况，返回和查询单词一模一样的单词，很简单，将所有单词放入一个 HashSet 中，这样就可以快速确定一个查询单词是否在原单词数组中出现过。对于第二种情况，做法是将每个单词都转为小写，然后建立小写单词和原单词之间都映射，注意对于转为小写后相同都单词，我们只映射第一个出现该小写状态的单词，后面的不用管。对于第三种情况，对于每个单词，转为小写之后，然后把所有的元音字母用特殊字符替代，比如下划线，然后也是建立这种特殊处理后的状态和原单词之间的映射。当映射都建立好了之后，就可以遍历所有的查询单词了，首先是去 HashSet 中找，若有跟该查询单词一模一样的，直接加入结果 res 中。若没有，则先将查询单词变为小写，然后去第一个 HashMap 中查找，若存在，直接加入结果 res 中。若没有，再把所有的元音变为下划线，去第二个 HashMap 中查找，存在则直接加入结果 res 中。若没有，则将空串加入结果 res 中，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">tolower</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span>)(c + <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">spellchecker</span><span class="params">(vector&lt;string&gt;&amp; wordlist, vector&lt;string&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        unordered_set&lt;string&gt; st;</span><br><span class="line">        unordered_map&lt;string, string&gt; map;</span><br><span class="line">        unordered_map&lt;string, string&gt; map_v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wordlist.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            string word = wordlist[i];</span><br><span class="line">            st.<span class="built_in">insert</span>(word);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; word.<span class="built_in">length</span>(); j ++)</span><br><span class="line">                word[j] = <span class="built_in">tolower</span>(word[j]);</span><br><span class="line">            <span class="keyword">if</span> (!map.<span class="built_in">count</span>(word))</span><br><span class="line">                map[word] = wordlist[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; word.<span class="built_in">length</span>(); j ++)</span><br><span class="line">                <span class="keyword">if</span> (word[j] == <span class="string">&#x27;a&#x27;</span> || word[j] == <span class="string">&#x27;e&#x27;</span> || word[j] == <span class="string">&#x27;i&#x27;</span> || word[j] == <span class="string">&#x27;o&#x27;</span> || word[j] == <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">                    word[j] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!map_v.<span class="built_in">count</span>(word))</span><br><span class="line">                map_v[word] = wordlist[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (string&amp; query : queries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">count</span>(query)) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(query);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; query.<span class="built_in">length</span>(); j ++)</span><br><span class="line">                query[j] = <span class="built_in">tolower</span>(query[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (map.<span class="built_in">count</span>(query)) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(map[query]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; query.<span class="built_in">length</span>(); j ++)</span><br><span class="line">                <span class="keyword">if</span> (query[j] == <span class="string">&#x27;a&#x27;</span> || query[j] == <span class="string">&#x27;e&#x27;</span> || query[j] == <span class="string">&#x27;i&#x27;</span> || query[j] == <span class="string">&#x27;o&#x27;</span> || query[j] == <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">                    query[j] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (map_v.<span class="built_in">count</span>(query)) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(map_v[query]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode969-Pancake-Sorting"><a href="#Leetcode969-Pancake-Sorting" class="headerlink" title="Leetcode969. Pancake Sorting"></a>Leetcode969. Pancake Sorting</h1><p>Given an array of integers arr, sort the array by performing a series of pancake flips.</p>
<p>In one pancake flip we do the following steps:</p>
<ul>
<li>Choose an integer k where 1 &lt;= k &lt;= arr.length.</li>
<li>Reverse the sub-array arr[1…k].</li>
</ul>
<p>For example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3.</p>
<p>Return the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,2,4,1]</span><br><span class="line">Output: [4,2,4,3]</span><br><span class="line">Explanation:</span><br><span class="line">We perform 4 pancake flips, with k values 4, 2, 4, and 3.</span><br><span class="line">Starting state: arr = [3, 2, 4, 1]</span><br><span class="line">After 1st flip (k = 4): arr = [1, 4, 2, 3]</span><br><span class="line">After 2nd flip (k = 2): arr = [4, 1, 2, 3]</span><br><span class="line">After 3rd flip (k = 4): arr = [3, 2, 1, 4]</span><br><span class="line">After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted.</span><br></pre></td></tr></table></figure><br>Notice that we return an array of the chosen k values of the pancake flips.</p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,2,3]</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The input is already sorted, so there is no need to flip anything.</span><br></pre></td></tr></table></figure></p>
<p>Note that other answers, such as [3, 3], would also be accepted.</p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= arr.length &lt;= 100</li>
<li>1 &lt;= arr[i] &lt;= arr.length</li>
<li>All integers in arr are unique (i.e. arr is a permutation of the integers from 1 to arr.length).</li>
</ul>
<p>这道题给了长度为n的数组，由1到n的组成，顺序是打乱的。现在说我们可以任意翻转前k个数字，k的范围是1到n，问怎么个翻转法能将数组翻成有序的。题目说并不限定具体的翻法，只要在 10*n 的次数内翻成有序的都是可以的，任你随意翻，就算有无效的步骤也无所谓。题目中给的例子1其实挺迷惑的，因为并不知道为啥要那样翻，也没有一个固定的翻法，所以可能会误导大家。必须要自己想出一个固定的翻法，这样才能应对所有的情况。每次先将数组中最大数字找出来，然后将最大数字翻转到首位置，然后翻转整个数组，这样最大数字就跑到最后去了。然后将最后面的最大数字去掉，这样又重现一样的情况，重复同样的步骤，直到数组只剩一个数字1为止，在过程中就把每次要翻转的位置都记录到结果 res 中就可以了，注意这里 C++ 的翻转函数 reverse 的结束位置是开区间，很容易出错，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pancakeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">size</span>(), j; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; arr[j] != i; ++j);</span><br><span class="line">            <span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>() + j + <span class="number">1</span>);</span><br><span class="line">            res.<span class="built_in">push_back</span>(j + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>() + i);</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode970-Powerful-Integers"><a href="#Leetcode970-Powerful-Integers" class="headerlink" title="Leetcode970. Powerful Integers"></a>Leetcode970. Powerful Integers</h1><p>Given two positive integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i &gt;= 0 and j &gt;= 0. Return a list of all powerful integers that have value less than or equal to bound.</p>
<p>You may return the answer in any order.  In your answer, each value should occur at most once.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 2, y = 3, bound = 10</span><br><span class="line">Output: [2,3,4,5,7,9,10]</span><br><span class="line">Explanation: </span><br><span class="line">2 = 2^0 + 3^0</span><br><span class="line">3 = 2^1 + 3^0</span><br><span class="line">4 = 2^0 + 3^1</span><br><span class="line">5 = 2^1 + 3^1</span><br><span class="line">7 = 2^2 + 3^1</span><br><span class="line">9 = 2^3 + 3^0</span><br><span class="line">10 = 2^0 + 3^2</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 3, y = 5, bound = 15</span><br><span class="line">Output: [2,4,6,8,10,14]</span><br></pre></td></tr></table></figure></p>
<p>方法很简单，如果x/y等于1，那么幂值只会是1；如果x/y 大于1，由于 bound &lt;= 10^6，幂的最大值是20(pow(2,20) &gt; 10^6)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">powerfulIntegers</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> bound)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">long</span> temp;</span><br><span class="line">        <span class="type">int</span> x_max = x &gt; <span class="number">1</span> ? <span class="number">20</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> y_max = y &gt; <span class="number">1</span> ? <span class="number">20</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; x_max &amp;&amp; <span class="built_in">pow</span>(x, i) &lt;= bound; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; y_max &amp;&amp; <span class="built_in">pow</span>(y, j) &lt;= bound; j ++) &#123;</span><br><span class="line">                temp = <span class="built_in">pow</span>(x, i) + <span class="built_in">pow</span>(y, j);</span><br><span class="line">                <span class="keyword">if</span>(temp &lt;= bound) </span><br><span class="line">                    res.<span class="built_in">insert</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode971-Flip-Binary-Tree-To-Match-Preorder-Traversal"><a href="#Leetcode971-Flip-Binary-Tree-To-Match-Preorder-Traversal" class="headerlink" title="Leetcode971. Flip Binary Tree To Match Preorder Traversal"></a>Leetcode971. Flip Binary Tree To Match Preorder Traversal</h1><p>Given a binary tree with N nodes, each node has a different value from {1, …, N}.</p>
<p>A node in this binary tree can be flipped by swapping the left child and the right child of that node.</p>
<p>Consider the sequence of N values reported by a preorder traversal starting from the root.  Call such a sequence of N values the voyage of the tree.</p>
<p>(Recall that a preorder traversal of a node means we report the current node’s value, then preorder-traverse the left child, then preorder-traverse the right child.)</p>
<p>Our goal is to flip the least number of nodes in the tree so that the voyage of the tree matches the voyage we are given.</p>
<p>If we can do so, then return a list of the values of all nodes flipped.  You may return the answer in any order.</p>
<p>If we cannot do so, then return the list [-1].</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2], voyage = [2,1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3], voyage = [1,3,2]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3], voyage = [1,2,3]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p>
<p>最少翻转哪些节点，能使得二叉树的前序遍历变成voyage.</p>
<p>其实这个题不难，因为题目就说了是前序遍历，所以做法肯定还是前序遍历。我刚开始一直想不通的地方在于，题目又是返回[-1]，又是正常返回，没想好怎么做区分。其实做法就是递归函数不仅要修改res数组，还要返回表示能不能构成题目条件的bool变量。</p>
<p>看到二叉树的题，很大可能就需要递归，所以直接先写出dfs函数，然后再慢慢向里面填东西。</p>
<p>我们定义的dfs函数意义是，我们能不能通过翻转（或者不翻转）该root节点的左右子树，得到对应v。如果能，返回true，否则返回false。</p>
<p>首先在递归函数中，我们对root节点进行判断，如果root不存在，这种情况不应该认为是题目输入错误，而是应该认为已经遍历到最底部了，这个时候相当于<code>root = []</code>, <code>voyage = []</code>，所以返回true；在先序遍历的时候，root节点是第一个要被遍历到的节点，如果不和voyage[0]相等，直接返回false;</p>
<p>这个题目的难点在于是否需要翻转一个节点的左右孩子。判断的方法其实是简单的：如果voyage第二个元素等于root的左孩子，那么说明不用翻转，直接递归调用左右孩子；否则如果voyage的第二个元素等于root的右孩子，那么还要注意一下，在左孩子存在的情况下，我们需要翻转当前的节点左右孩子。</p>
<p>翻转是什么概念呢？这里并没有直接交换，而是把当前遍历到的位置使用遍历i保存起来，这样voyage[i]就表示当前遍历到哪个位置了。所以dfs调用两个孩子的顺序很讲究，它体现了先序遍历先解决哪个树的问题，也就是完成了逻辑上的交换左右孩子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; voyage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val != voyage[i++])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val == voyage[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left, voyage) &amp;&amp; <span class="built_in">dfs</span>(root-&gt;right, voyage);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val == voyage[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;right, voyage) &amp;&amp; <span class="built_in">dfs</span>(root-&gt;left, voyage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !root-&gt;left &amp;&amp; !root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">flipMatchVoyage</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; voyage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(root, voyage))</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode973-K-Closest-Points-to-Origin"><a href="#Leetcode973-K-Closest-Points-to-Origin" class="headerlink" title="Leetcode973. K Closest Points to Origin"></a>Leetcode973. K Closest Points to Origin</h1><p>We have a list of points on the plane.  Find the K closest points to the origin (0, 0).</p>
<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>
<p>You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[1,3],[-2,2]], K = 1</span><br><span class="line">Output: [[-2,2]]</span><br><span class="line">Explanation:</span><br><span class="line">The distance between (1, 3) and the origin is sqrt(10).</span><br><span class="line">The distance between (-2, 2) and the origin is sqrt(8).</span><br><span class="line">Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.</span><br><span class="line">We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[3,3],[5,-1],[-2,4]], K = 2</span><br><span class="line">Output: [[3,3],[-2,4]]</span><br><span class="line">(The answer [[-2,4],[3,3]] would also be accepted.)</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= K &lt;= points.length &lt;= 10000</li>
<li>-10000 &lt; points[i][0] &lt; 10000</li>
<li>-10000 &lt; points[i][1] &lt; 10000</li>
</ul>
<p>这道题给了平面上的一系列的点，让求最接近原点的K个点。基本上没有什么难度，无非就是要知道点与点之间的距离该如何求。一种比较直接的方法就是给这个二维数组排序，自定义排序方法，按照离原点的距离从小到大排序，注意这里我们并不需要求出具体的距离值，只要知道互相的大小关系即可，所以并不需要开方。排好序之后，返回前k个点即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> K) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">1</span>] * a[<span class="number">1</span>] &lt; b[<span class="number">0</span>] * b[<span class="number">0</span>] + b[<span class="number">1</span>] * b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(points.<span class="built_in">begin</span>(), points.<span class="built_in">begin</span>() + K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种解法是使用最大堆 Max Heap 来做的，在 C++ 中就是用优先队列来做，这里维护一个大小为k的最大堆，里面放一个 pair 对儿，由距离原点的距离，和该点在原数组中的下标组成，这样优先队列就可以按照到原点的距离排队了，距离大的就在队首。这样每当个数超过k个了之后，就将队首的元素移除即可，最后把剩下的k个点存入结果 res 中即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> K) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> t = points[i][<span class="number">0</span>] * points[i][<span class="number">0</span>] + points[i][<span class="number">1</span>] * points[i][<span class="number">1</span>];</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;t, i&#125;);</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; K) pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(points[t.second]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>借鉴快速排序的思想：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">comp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; p1, vector&lt;<span class="type">int</span>&gt; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1[<span class="number">0</span>] * p1[<span class="number">0</span>] + p1[<span class="number">1</span>] * p1[<span class="number">1</span>] - p2[<span class="number">0</span>] * p2[<span class="number">0</span>] - p2[<span class="number">1</span>] * p2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; priot = points[l];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; <span class="built_in">comp</span>(points[r], priot) &gt;= <span class="number">0</span>) r --;</span><br><span class="line">            points[l] = points[r];</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; <span class="built_in">comp</span>(points[l], priot) &lt;= <span class="number">0</span>) l ++;</span><br><span class="line">            points[r] = points[l];</span><br><span class="line">        &#125;</span><br><span class="line">        points[l] = priot;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = points.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = <span class="built_in">helper</span>(points, l, r);</span><br><span class="line">            <span class="keyword">if</span> (mid == k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; k)</span><br><span class="line">                r = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++)</span><br><span class="line">            res.<span class="built_in">push_back</span>(points[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode976-Largest-Perimeter-Triangle"><a href="#Leetcode976-Largest-Perimeter-Triangle" class="headerlink" title="Leetcode976. Largest Perimeter Triangle"></a>Leetcode976. Largest Perimeter Triangle</h1><p>Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.</p>
<p>If it is impossible to form any triangle of non-zero area, return 0.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3,4]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,6,2,3]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure><br>三角形的条件：两边之和&gt;第三边。</p>
<p>若要构成最大的三角形周长，只需要对数组排序，一直取出最大的三个值作为三角形的边，符合条件即可返回。</p>
<p>证明：若数组A为自然顺序，A[N]&gt;=A[N-1]+A[N-2]，则A[N]&gt;=A[N-1]+A[N-3]，A[N]与后面的数字更不可能构成三角形，可以直接排除。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestPerimeter</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i - <span class="number">2</span>] + A[i - <span class="number">1</span>] &gt; A[i])</span><br><span class="line">                <span class="keyword">return</span> A[i - <span class="number">2</span>] + A[i - <span class="number">1</span>] + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode977-Squares-of-a-Sorted-Array"><a href="#Leetcode977-Squares-of-a-Sorted-Array" class="headerlink" title="Leetcode977. Squares of a Sorted Array"></a>Leetcode977. Squares of a Sorted Array</h1><p>Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-4,-1,0,3,10]</span><br><span class="line">Output: [0,1,9,16,100]</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-7,-3,2,3,11]</span><br><span class="line">Output: [4,9,9,49,121]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 10000</li>
<li>-10000 &lt;= A[i] &lt;= 10000</li>
<li>A is sorted in non-decreasing order.</li>
</ul>
<p>给一个vector，有正有负，输出排序之后的平方数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(A.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = A.<span class="built_in">size</span>()<span class="number">-1</span>, p = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            res[p--] = <span class="built_in">pow</span>(A[<span class="built_in">abs</span>(A[l]) &gt; <span class="built_in">abs</span>(A[r]) ? l++ : r--],<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另一种方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(A.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; A.<span class="built_in">size</span>() &amp;&amp; A[i] &lt; <span class="number">0</span>)</span><br><span class="line">            i ++;</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; i &lt; A.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res[k++] = <span class="built_in">pow</span>(A[<span class="built_in">abs</span>(A[i]) &lt; <span class="built_in">abs</span>(A[j]) ? i ++ : j --], <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">            res[k++]=<span class="built_in">pow</span>(A[j--],<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;A.<span class="built_in">size</span>())</span><br><span class="line">            res[k++]=<span class="built_in">pow</span>(A[i++],<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode978-Longest-Turbulent-Subarray"><a href="#Leetcode978-Longest-Turbulent-Subarray" class="headerlink" title="Leetcode978. Longest Turbulent Subarray"></a>Leetcode978. Longest Turbulent Subarray</h1><p>A subarray A[i], A[i+1], …, A[j] of A is said to be turbulent if and only if:</p>
<ul>
<li>For i &lt;= k &lt; j, A[k] &gt; A[k+1] when k is odd, and A[k] &lt; A[k+1] when k is even;</li>
<li>OR, for i &lt;= k &lt; j, A[k] &gt; A[k+1] when k is even, and A[k] &lt; A[k+1] when k is odd.</li>
</ul>
<p>That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.</p>
<p>Return the length of a maximum size turbulent subarray of A.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [9,4,2,10,7,8,8,1,9]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: (A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5])</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,8,12,16]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [100]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>隐藏很深的dp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sizee = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">up</span><span class="params">(sizee, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">down</span><span class="params">(sizee, <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sizee; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i - <span class="number">1</span>])</span><br><span class="line">                up[i] = down[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; A[i - <span class="number">1</span>])</span><br><span class="line">                down[i] = up[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(up[i], down[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>首先预处理一下，记录数组中数字变化趋势，1增加-1减少0不变，然后得到一个新的数组，为了省空间我直接在原来数组进行操作的，也可以开辟个新的数组。然后比较相邻数变化即可，若相邻数字乘积为负，则说明满足湍流数组性质，累加记录其长度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sizee = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sizee; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i - <span class="number">1</span>])</span><br><span class="line">                A[i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[i] &lt; A[i + <span class="number">1</span>])</span><br><span class="line">                A[i<span class="number">-1</span>] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                A[i<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sizee - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; sizee - <span class="number">1</span> &amp;&amp; A[i] * A[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, count);</span><br><span class="line">            count = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode979-Distribute-Coins-in-Binary-Tree"><a href="#Leetcode979-Distribute-Coins-in-Binary-Tree" class="headerlink" title="Leetcode979. Distribute Coins in Binary Tree"></a>Leetcode979. Distribute Coins in Binary Tree</h1><p>Given the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total.</p>
<p>In one move, we may choose two adjacent nodes and move one coin from one node to another.  (The move may be from parent to child, or from child to parent.)</p>
<p>Return the number of moves required to make every node have exactly one coin.</p>
<p>Example 1:<br><img src="/img/20190824002.png" alt=""></p>
<p>Input: [3,0,0]<br>Output: 2<br>Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.</p>
<p>Example 2:<br><img src="/img/20190824003.png" alt=""></p>
<p>Input: [0,3,0]<br>Output: 3<br>Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.</p>
<p>Example 3:<br><img src="/img/20190824004.png" alt=""></p>
<p>Input: [1,0,2]<br>Output: 2</p>
<p>Example 4:<br><img src="/img/20190824005.png" alt=""></p>
<p>Input: [1,0,0,null,3]<br>Output: 4</p>
<p>Note:</p>
<p>1&lt;= N &lt;= 100<br>0 &lt;= node.val &lt;= N</p>
<p>给你一个二叉树，对于每个节点的val，每次只能往父亲或者儿子移动1，最后使得所有节点值都为1，求最小的移动次数。</p>
<p>思路：从叶子到根寻找，对于每个节点，只能剩下一个。多了的值肯定要全给父亲，少的值全问父亲要，统计一下就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCoins</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        ans += <span class="built_in">abs</span>(left) + <span class="built_in">abs</span>(right);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val <span class="number">-1</span> + left + right ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode980-Unique-Paths-III"><a href="#Leetcode980-Unique-Paths-III" class="headerlink" title="Leetcode980. Unique Paths III"></a>Leetcode980. Unique Paths III</h1><p>On a 2-dimensional grid, there are 4 types of squares:</p>
<p><code>1</code> represents the starting square.  There is exactly one starting square.<br><code>2</code> represents the ending square.  There is exactly one ending square.<br><code>0</code> represents empty squares we can walk over.<br><code>-1</code> represents obstacles that we cannot walk over.<br>Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We have the following two paths: </span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</span><br><span class="line">2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: We have the following four paths: </span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)</span><br><span class="line">2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)</span><br><span class="line">3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)</span><br><span class="line">4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1],[2,0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">There is no path that walks over every empty square exactly once.</span><br><span class="line">Note that the starting and ending square can be anywhere in the grid.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= grid.length * grid[0].length &lt;= 20</p>
<p>给了一个二维矩阵，1代表起点，2代表终点，0代表可以走的格子，-1代表障碍物。求从起点到终点，把所有的可以走的格子都遍历一遍，所有可能的不同路径数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsIII</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> M=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> zerosize=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> N=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)</span><br><span class="line">                    zerosize++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">dfs</span>(grid,i,j,<span class="number">0</span>,zerosize,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> pathcount, <span class="type">int</span> zerocount, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[x][y]==<span class="number">2</span> &amp;&amp; zerocount == pathcount )&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> M=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> N=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pre=grid[x][y];</span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="number">0</span>)</span><br><span class="line">            pathcount++;</span><br><span class="line">        grid[x][y]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> d : dirs) &#123;</span><br><span class="line">            <span class="type">int</span> nx = x + d.first;</span><br><span class="line">            <span class="type">int</span> ny = y + d.second;</span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= M || ny &lt; <span class="number">0</span> || ny &gt;= N || grid[nx][ny] == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, nx, ny, pathcount, zerocount, res);</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y]=pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode981-Time-Based-Key-Value-Store"><a href="#Leetcode981-Time-Based-Key-Value-Store" class="headerlink" title="Leetcode981. Time Based Key-Value Store"></a>Leetcode981. Time Based Key-Value Store</h1><p>Create a timebased key-value store class TimeMap, that supports two operations.</p>
<ul>
<li>set(string key, string value, int timestamp):Stores the key and value, along with the given timestamp.</li>
<li>get(string key, int timestamp)<ul>
<li>Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev &lt;= timestamp.</li>
<li>If there are multiple such values, it returns the one with the largest timestamp_prev.</li>
<li>If there are no values, it returns the empty string (“”).</li>
</ul>
</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;foo&quot;,&quot;bar&quot;,1],[&quot;foo&quot;,1],[&quot;foo&quot;,3],[&quot;foo&quot;,&quot;bar2&quot;,4],[&quot;foo&quot;,4],[&quot;foo&quot;,5]]</span><br><span class="line">Output: [null,null,&quot;bar&quot;,&quot;bar&quot;,null,&quot;bar2&quot;,&quot;bar2&quot;]</span><br><span class="line">Explanation:   </span><br><span class="line">TimeMap kv;   </span><br><span class="line">kv.set(&quot;foo&quot;, &quot;bar&quot;, 1); // store the key &quot;foo&quot; and value &quot;bar&quot; along with timestamp = 1   </span><br><span class="line">kv.get(&quot;foo&quot;, 1);  // output &quot;bar&quot;   </span><br><span class="line">kv.get(&quot;foo&quot;, 3); // output &quot;bar&quot; since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie &quot;bar&quot;   </span><br><span class="line">kv.set(&quot;foo&quot;, &quot;bar2&quot;, 4);   </span><br><span class="line">kv.get(&quot;foo&quot;, 4); // output &quot;bar2&quot;   </span><br><span class="line">kv.get(&quot;foo&quot;, 5); //output &quot;bar2&quot;   </span><br></pre></td></tr></table></figure></p>
<p>这个题太麻烦了，没有耐心做了，只看了看，本来想用很好的方法，比如二分实现一下，但是发现这种简单粗暴的方法竟然也能过，就算了……<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeMap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unordered_map&lt;string, map&lt;<span class="type">int</span>, string&gt;&gt; mp;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; tvec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">  <span class="built_in">TimeMap</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(string key, string value, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">      mp[key][timestamp] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">get</span><span class="params">(string key, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!mp.<span class="built_in">count</span>(key)) </span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(mp[key].<span class="built_in">count</span>(timestamp)) </span><br><span class="line">			<span class="keyword">return</span> mp[key][timestamp];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">auto</span> it = mp[key].<span class="built_in">rbegin</span>(); it != mp[key].<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(it-&gt;first &gt; timestamp) </span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">        	<span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> it-&gt;second;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode983-Minimum-Cost-For-Tickets"><a href="#Leetcode983-Minimum-Cost-For-Tickets" class="headerlink" title="Leetcode983. Minimum Cost For Tickets"></a>Leetcode983. Minimum Cost For Tickets</h1><p>In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array days.  Each day is an integer from 1 to 365.</p>
<p>Train tickets are sold in 3 different ways:</p>
<ul>
<li>a 1-day pass is sold for costs[0] dollars;</li>
<li>a 7-day pass is sold for costs[1] dollars;</li>
<li>a 30-day pass is sold for costs[2] dollars.</li>
</ul>
<p>The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.</p>
<p>Return the minimum number of dollars you need to travel every day in the given list of days. </p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: days = [1,4,6,7,8,20], costs = [2,7,15]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: </span><br><span class="line">For example, here is one way to buy passes that lets you travel your travel plan:</span><br><span class="line">On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.</span><br><span class="line">On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.</span><br><span class="line">On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.</span><br><span class="line">In total you spent $11 and covered all the days of your travel.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation: </span><br><span class="line">For example, here is one way to buy passes that lets you travel your travel plan:</span><br><span class="line">On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.</span><br><span class="line">On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.</span><br><span class="line">In total you spent $17 and covered all the days of your travel.</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>1 &lt;= days.length &lt;= 365</li>
<li>1 &lt;= days[i] &lt;= 365</li>
<li>days is in strictly increasing order.</li>
<li>costs.length == 3</li>
<li>1 &lt;= costs[i] &lt;= 1000</li>
</ul>
<p>days数组中存储的是该年中去旅游的日期（范围为1到365之间的数字），costs数组大小为3，存储的是1天，7天和30天火车票的价格。我们需要做一个方案选择合适的购票方案达到旅游days天最省钱的目的。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>采用动态规划进行解决，假设现在是第days[i]天，我们在该天出行旅游需要选择买票方案，现在我们有三种方案：第一，购买一天的通行票，当天出行，花费就是第days[i-1]天的花费加上一天的通行票价；第二，购买七天的通行票，而七天的通行票可以在连续的七天之内使用，所以花费是第days[i-7]天的花费加上七天的通行票价（即从第days[i-8]天到days[i]天的花费都包含在这七天的通行票中）；第三，购买三十天的通行票，同理，花费是days[i-30]天加上三十天的通行票价。然后我们在这三种方案中选择最实惠的。最后，在实现代码中注意数组越界的问题。</p>
<p>使用dp[j]代表着我们旅行到i天为止需要的最少旅行价格，递推公式为：</p>
<ul>
<li>dp[j] = dp[j-1] （第j天不用旅行）</li>
<li>dp[j] = min(dp[j-1] + costs[0], dp[j-7] + costs[1], dp[j-30] + costs[2]) （第j天需要旅行）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mincostTickets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; days, vector&lt;<span class="type">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(days.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">366</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">366</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(days.<span class="built_in">begin</span>(), days.<span class="built_in">end</span>(), i) == days.<span class="built_in">end</span>() )</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>] + costs[<span class="number">0</span>], <span class="built_in">min</span>(dp[<span class="built_in">max</span>(<span class="number">0</span>, i<span class="number">-7</span>)]+costs[<span class="number">1</span>], dp[<span class="built_in">max</span>(<span class="number">0</span>, i<span class="number">-30</span>)]+costs[<span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">365</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode984-String-Without-AAA-or-BBB"><a href="#Leetcode984-String-Without-AAA-or-BBB" class="headerlink" title="Leetcode984. String Without AAA or BBB"></a>Leetcode984. String Without AAA or BBB</h1><p>Given two integers A and B, return any string S such that:</p>
<ul>
<li>S has length A + B and contains exactly A ‘a’ letters, and exactly B ‘b’ letters;</li>
<li>The substring ‘aaa’ does not occur in S;</li>
<li>The substring ‘bbb’ does not occur in S.</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = 1, B = 2</span><br><span class="line">Output: &quot;abb&quot;</span><br><span class="line">Explanation: &quot;abb&quot;, &quot;bab&quot; and &quot;bba&quot; are all correct answers.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = 4, B = 1</span><br><span class="line">Output: &quot;aabaa&quot;</span><br></pre></td></tr></table></figure><br>使用贪心，先选较多的然后再选较少的字母。主要是看两个字母哪个比较多，较多的哪个放到A上，然后判断A和B是否大于0，或者A是否大于B。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">strWithout3a3b</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>, b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> temp2;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(A &lt; B) &#123;</span><br><span class="line">            a = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            b = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            temp2 = A;</span><br><span class="line">            A = B;</span><br><span class="line">            B = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(A&gt;<span class="number">0</span> || B&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res += a;</span><br><span class="line">                A --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(A &gt; B) &#123;</span><br><span class="line">                res += a;</span><br><span class="line">                A --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(B &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res += b;</span><br><span class="line">                B --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode985-Sum-of-Even-Numbers-After-Queries"><a href="#Leetcode985-Sum-of-Even-Numbers-After-Queries" class="headerlink" title="Leetcode985. Sum of Even Numbers After Queries"></a>Leetcode985. Sum of Even Numbers After Queries</h1><p>We have an array A of integers, and an array queries of queries.</p>
<p>For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index].  Then, the answer to the i-th query is the sum of the even values of A.</p>
<p>(Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.)</p>
<p>Return the answer to all queries.  Your answer array should have answer[i] as the answer to the i-th query.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]</span><br><span class="line">Output: [8,6,2,4]</span><br><span class="line">Explanation: </span><br><span class="line">	At the beginning, the array is [1,2,3,4].</span><br><span class="line">	After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.</span><br><span class="line">	After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.</span><br><span class="line">	After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.</span><br><span class="line">	After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.</span><br></pre></td></tr></table></figure><br>题意比较曲折，就是在queries中的每个pair，某个位置加上一个数，在计算A数组中所有偶数的和。下边的代码会超时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sumEvenAfterQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> size = queries.<span class="built_in">size</span>(), val, index, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            val = queries[i][<span class="number">0</span>];</span><br><span class="line">            index = queries[i][<span class="number">1</span>];</span><br><span class="line">            A[index] += val;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; A.<span class="built_in">size</span>(); j ++)</span><br><span class="line">                sum += (A[j]%<span class="number">2</span> ? <span class="number">0</span> : A[j]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>应首先计算出所有的偶数和，再根据运算之后的结果进行计算。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sumEvenAfterQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> size = queries.<span class="built_in">size</span>(), val, index, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            sum += (A[i]%<span class="number">2</span> ? <span class="number">0</span> : A[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            val = queries[i][<span class="number">0</span>];</span><br><span class="line">            index = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(A[index]%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                sum -= A[index];</span><br><span class="line">            A[index] += val;</span><br><span class="line">            <span class="keyword">if</span>(A[index]%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                sum += A[index];</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode986-Interval-List-Intersections"><a href="#Leetcode986-Interval-List-Intersections" class="headerlink" title="Leetcode986. Interval List Intersections"></a>Leetcode986. Interval List Intersections</h1><p>Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.</p>
<p>Return the intersection of these two interval lists.</p>
<p>(Formally, a closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">intervalIntersection</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; A, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.<span class="built_in">size</span>() == <span class="number">0</span> || B.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> sizea = A.<span class="built_in">size</span>(), sizeb = B.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; sizea &amp;&amp; j &lt; sizeb;) &#123;</span><br><span class="line">            l = <span class="built_in">max</span>(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>]);</span><br><span class="line">            r = <span class="built_in">min</span>(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(l &lt;= r) </span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">            <span class="keyword">if</span>(r == A[i][<span class="number">1</span>])</span><br><span class="line">                i ++;</span><br><span class="line">            <span class="keyword">else</span> j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>贪心，由于排好序了，直接双指针扫，思路和归并排序合并比较类似，注意往后移动的条件是尾部，因为一个矩形的结束条件是尾部比完了，不能写成是头部</p>
<h1 id="Leetcode987-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#Leetcode987-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="Leetcode987. Vertical Order Traversal of a Binary Tree"></a>Leetcode987. Vertical Order Traversal of a Binary Tree</h1><p>Given a binary tree, return the vertical order traversal of its nodes values.</p>
<p>For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).</p>
<p>Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).</p>
<p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p>
<p>Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[9],[3,15],[20],[7]]</span><br><span class="line">Explanation: </span><br><span class="line">Without loss of generality, we can assume the root node is at position (0, 0):</span><br><span class="line">Then, the node with value 9 occurs at position (-1, -1);</span><br><span class="line">The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);</span><br><span class="line">The node with value 20 occurs at position (1, -1);</span><br><span class="line">The node with value 7 occurs at position (2, -2).</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation: </span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>The tree will have between 1 and 1000 nodes.</li>
<li>Each node s value will be between 0 and 1000.</li>
</ul>
<p>要求把相同X的节点位置放在一起，并且要求结果中节点的存放是从上到下的。如果两个节点的坐标相同，那么value小的节点排列在前面。通过维护一个队列，我们从上到下依次遍历每个节点，给每个节点设置好了坐标。这个队列存储的是个三元组（TreeNode*,int x,int y）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dat</span>&#123;</span><br><span class="line">        TreeNode* root;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">verticalTraversal</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;<span class="keyword">struct</span> dat&gt; q;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">dat</span> te = &#123;root, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        q.<span class="built_in">push</span>(te);</span><br><span class="line">        map&lt;<span class="type">int</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; node;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">dat</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            node[temp.x].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(-temp.y, temp.root-&gt;val));</span><br><span class="line">            <span class="keyword">if</span>(temp.root-&gt;left)</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;temp.root-&gt;left, temp.x - <span class="number">1</span>, temp.y - <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span>(temp.root-&gt;right)</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;temp.root-&gt;right, temp.x + <span class="number">1</span>, temp.y - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : node) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(it.second.<span class="built_in">begin</span>(), it.second.<span class="built_in">end</span>());</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : it.second)</span><br><span class="line">                tempp.<span class="built_in">push_back</span>(i.second);</span><br><span class="line">            res.<span class="built_in">push_back</span>(tempp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode988-Smallest-String-Starting-From-Leaf"><a href="#Leetcode988-Smallest-String-Starting-From-Leaf" class="headerlink" title="Leetcode988. Smallest String Starting From Leaf"></a>Leetcode988. Smallest String Starting From Leaf</h1><p>Given the root of a binary tree, each node has a value from 0 to 25 representing the letters ‘a’ to ‘z’: a value of 0 represents ‘a’, a value of 1 represents ‘b’, and so on.</p>
<p>Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root.</p>
<p>(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, “ab” is lexicographically smaller than “aba”.  A leaf of a node is a node that has no children.)</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,2,3,4,3,4]</span><br><span class="line">Output: &quot;dba&quot;</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [25,1,3,1,3,0,2]</span><br><span class="line">Output: &quot;adz&quot;</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1,null,1,0,null,0]</span><br><span class="line">Output: &quot;abc&quot;</span><br></pre></td></tr></table></figure></p>
<p>这个数组代表一个树，图就不上了，从叶子节点开始找到一个最小的字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    string result = <span class="string">&quot;zzzzzzzzzz&quot;</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bianli</span><span class="params">(TreeNode* root, string cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cur = (<span class="type">char</span>)((root-&gt;val) + <span class="string">&#x27;a&#x27;</span>)+cur;</span><br><span class="line">            result = result &lt; cur ? result : cur;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">bianli</span>(root-&gt;left, (<span class="type">char</span>)(root-&gt;val+<span class="string">&#x27;a&#x27;</span>)+cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">bianli</span>(root-&gt;right, (<span class="type">char</span>)(root-&gt;val+<span class="string">&#x27;a&#x27;</span>)+cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">smallestFromLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">bianli</span>(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode989-Add-to-Array-Form-of-Integer"><a href="#Leetcode989-Add-to-Array-Form-of-Integer" class="headerlink" title="Leetcode989. Add to Array-Form of Integer"></a>Leetcode989. Add to Array-Form of Integer</h1><p>For a non-negative integer X, the array-form of X is an array of its digits in left to right order.  For example, if X = 1231, then the array form is [1,2,3,1].</p>
<p>Given the array-form A of a non-negative integer X, return the array-form of the integer X+K.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,0,0], K = 34</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line">Explanation: 1200 + 34 = 1234</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,7,4], K = 181</span><br><span class="line">Output: [4,5,5]</span><br><span class="line">Explanation: 274 + 181 = 455</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,1,5], K = 806</span><br><span class="line">Output: [1,0,2,1]</span><br><span class="line">Explanation: 215 + 806 = 1021</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1</span><br><span class="line">Output: [1,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">Explanation: 9999999999 + 1 = 10000000000</span><br></pre></td></tr></table></figure><br>Note：</p>
<ul>
<li>1 &lt;= A.length &lt;= 10000</li>
<li>0 &lt;= A[i] &lt;= 9</li>
<li>0 &lt;= K &lt;= 10000</li>
<li>If A.length &gt; 1, then A[0] != 0</li>
</ul>
<p>大概意思是一个数组代表一个数，再给一个整数K，返回结果的各位数组成的数组，注意进位，我的做法很麻烦，需要两次反转。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">addToArrayForm</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="type">int</span> L=K;</span><br><span class="line">        <span class="built_in">reverse</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            A[i] = A[i] + L;</span><br><span class="line">            L = A[i]/<span class="number">10</span>;</span><br><span class="line">            A[i]=A[i]%<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(L&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            A.<span class="built_in">push_back</span>(L%<span class="number">10</span>);</span><br><span class="line">            L = L/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从数组最右边开始，逐位相加，用carry记录进位，每一次取和的最右一位存入链表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">addToArrayForm</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> A.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry + A[i] + K % <span class="number">10</span>;</span><br><span class="line">            list.add(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            K /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        carry += K;</span><br><span class="line">        <span class="keyword">while</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">            list.add(carry % <span class="number">10</span>);</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode990-Satisfiability-of-Equality-Equations"><a href="#Leetcode990-Satisfiability-of-Equality-Equations" class="headerlink" title="Leetcode990. Satisfiability of Equality Equations"></a>Leetcode990. Satisfiability of Equality Equations</h1><p>Given an array equations of strings that represent relationships between variables, each string equations[i] has length 4 and takes one of two different forms: “a==b” or “a!=b”.  Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.</p>
<p>Return true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b!=a&quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;b==a&quot;,&quot;a==b&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We could assign a = 1 and b = 1 to satisfy both equations.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>1 &lt;= equations.length &lt;= 500</li>
<li>equations[i].length == 4</li>
<li>equations[i][0] and equations[i][3] are lowercase letters</li>
<li>equations[i][1] is either ‘=’ or ‘!’</li>
<li>equations[i][2] is ‘=’</li>
</ul>
<p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a==b”或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。</p>
<p>这个问题一看就是并查集问题，所以直接使用并查集就过了。将所有相等的元素构成一个集合中，然后判断不相等的元素是不是相同根即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[x]==x?x:<span class="built_in">find</span>(arr[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        arr[<span class="built_in">find</span>(y)]=<span class="built_in">find</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">equationsPossible</span><span class="params">(vector&lt;string&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            arr[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;equations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">uni</span>(equations[i][<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>, equations[i][<span class="number">3</span>]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;equations.<span class="built_in">size</span>();i++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">&#x27;!&#x27;</span> &amp;&amp; <span class="built_in">find</span>(equations[i][<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)==<span class="built_in">find</span>(equations[i][<span class="number">3</span>]-<span class="string">&#x27;a&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode991-Broken-Calculator"><a href="#Leetcode991-Broken-Calculator" class="headerlink" title="Leetcode991. Broken Calculator"></a>Leetcode991. Broken Calculator</h1><p>On a broken calculator that has a number showing on its display, we can perform two operations:</p>
<ul>
<li>Double: Multiply the number on the display by 2, or;</li>
<li>Decrement: Subtract 1 from the number on the display.</li>
</ul>
<p>Initially, the calculator is displaying the number X.</p>
<p>Return the minimum number of operations needed to display the number Y.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: X = 2, Y = 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Use double operation and then decrement operation &#123;2 -&gt; 4 -&gt; 3&#125;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: X = 5, Y = 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Use decrement and then double &#123;5 -&gt; 4 -&gt; 8&#125;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: X = 3, Y = 10</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:  Use double, decrement and double &#123;3 -&gt; 6 -&gt; 5 -&gt; 10&#125;.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: X = 1024, Y = 1</span><br><span class="line">Output: 1023</span><br><span class="line">Explanation: Use decrement operations 1023 times.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= X &lt;= 10^9</li>
<li>1 &lt;= Y &lt;= 10^9</li>
</ul>
<p>这道题说是有一个坏了的计算器，其实就显示一个数字X，现在我们有两种操作，一种乘以2操作，一种是减1操作，问最少需要多少次操作才能得到目标数字Y。好，现在来分析，由于X和Y的大小关系并不确定，最简单的当然是X和Y相等，就不需要另外的操作了。当X大于Y时，由于都是正数，肯定就不能再乘2了，所以此时直接就可以返回 X-Y。比较复杂的情况就是Y大于X的情况，此时X既可以减1，又可以乘以2，但是仔细想想，我们的最终目的应该是要减小Y，直至其小于等于X，就可以直接得到结果。这里X乘以2的效果就相当于Y除以2，操作数都一样，但是Y除以2时还要看Y的奇偶性，如果Y是偶数，那么 OK，可以直接除以2，若是奇数，需要将其变为偶数，由于X可以减1，等价过来就是Y加1，所以思路就有了，当Y大于X时进行循环，然后判断Y的奇偶性，若是偶数，直接除以2，若是奇数，则加1，当然此时结果 res 也要对应增加。循环退出后，还要加上 X-Y 的值即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">brokenCalc</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(target &gt; start) &#123;</span><br><span class="line">            target = (target % <span class="number">2</span>) ? (target + <span class="number">1</span>) : target / <span class="number">2</span>;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + start - target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>若用递归来写就相当的简洁了，可以两行搞定，当然若你够 geek 的话，也可以压缩到一行，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">brokenCalc</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (X &gt;= Y) <span class="keyword">return</span> X - Y;</span><br><span class="line">        <span class="keyword">return</span> (Y % <span class="number">2</span> == <span class="number">0</span>) ? (<span class="number">1</span> + <span class="built_in">brokenCalc</span>(X, Y / <span class="number">2</span>)) : (<span class="number">1</span> + <span class="built_in">brokenCalc</span>(X, Y + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode993-Cousins-in-Binary-Tree"><a href="#Leetcode993-Cousins-in-Binary-Tree" class="headerlink" title="Leetcode993. Cousins in Binary Tree"></a>Leetcode993. Cousins in Binary Tree</h1><p>In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.</p>
<p>Two nodes of a binary tree are cousins if they have the same depth, but have different parents. We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4], x = 4, y = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,4,null,5], x = 5, y = 4</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,4], x = 2, y = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>求解x，y的深度和父亲结点，如果深度一样，父亲结点不同，就是true；否则，就是false。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> x, <span class="type">int</span> depth, <span class="type">int</span> &amp;level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>((root-&gt;left &amp;&amp; root-&gt;left-&gt;val == x) || (root-&gt;right &amp;&amp; root-&gt;right-&gt;val == x)) &#123;</span><br><span class="line">            level = depth;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *left = <span class="built_in">dfs</span>(root-&gt;left, x, depth + <span class="number">1</span>, level);</span><br><span class="line">        <span class="keyword">if</span> (left) </span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        TreeNode *right = <span class="built_in">dfs</span>(root-&gt;right, x, depth + <span class="number">1</span>, level);</span><br><span class="line">        <span class="keyword">if</span> (right) </span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> level_a, level_b;</span><br><span class="line">        TreeNode *xx = <span class="built_in">dfs</span>(root, x, <span class="number">0</span>, level_a);</span><br><span class="line">        TreeNode *yy = <span class="built_in">dfs</span>(root, y, <span class="number">0</span>, level_b);</span><br><span class="line">        <span class="keyword">if</span>(xx != yy &amp;&amp; level_a == level_b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode994-Rotting-Oranges"><a href="#Leetcode994-Rotting-Oranges" class="headerlink" title="Leetcode994. Rotting Oranges"></a>Leetcode994. Rotting Oranges</h1><p>You are given an m x n grid where each cell can have one of three values:</p>
<ul>
<li>0 representing an empty cell,</li>
<li>1 representing a fresh orange, or</li>
<li>2 representing a rotten orange.</li>
</ul>
<p>Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.</p>
<p>Return  the minimum number of minutes that must elapse until no cell has a fresh orange. If  this is impossible, return  -1.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20211115105408.png" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[0,2]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>m == grid.length</li>
<li>n == grid[i].length</li>
<li>1 &lt;= m, n &lt;= 10</li>
<li>grid[i][j] is 0, 1, or 2.</li>
</ul>
<p>这道题说给的一个 mxn 大小的格子上有些新鲜和腐烂的橘子，每一分钟腐烂的橘子都会传染给其周围四个中的新鲜橘子，使得其也变得腐烂。现在问需要多少分钟可以使得所有的新鲜橘子都变腐烂，无法做到时返回 -1。由于这里新鲜的橘子自己不会变腐烂，只有被周围的腐烂橘子传染才会，所以当新鲜橘子周围不会出现腐烂橘子的时候，那么这个新鲜橘子就不会腐烂，这才会有返回 -1 的情况。这道题就是个典型的广度优先遍历 Breadth First Search，并没有什么太大的难度，先遍历一遍整个二维数组，统计出所有新鲜橘子的个数，并把腐烂的橘子坐标放入一个队列 queue，之后进行 while 循环，循环条件是队列不会空，且 freshLeft 大于0，使用层序遍历的方法，用个 for 循环在内部。每次取出队首元素，遍历其周围四个位置，越界或者不是新鲜橘子都跳过，否则将新鲜橘子标记为腐烂，加入队列中，并且 freshLeft 自减1。每层遍历完成之后，结果 res 自增1，最后返回的时候，若还有新鲜橘子，即 freshLeft 大于0时，返回 -1，否则返回 res 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>(), freshLeft = <span class="number">0</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    freshLeft ++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; freshLeft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                <span class="type">int</span> x = q.<span class="built_in">front</span>().first, y = q.<span class="built_in">front</span>().second;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;</span><br><span class="line">                    <span class="type">int</span> xx = x + dirs[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> yy = y + dirs[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &gt; xx || xx &gt;= m || <span class="number">0</span> &gt; yy || yy &gt;= n || grid[xx][yy] != <span class="number">1</span>) </span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    grid[xx][yy] = <span class="number">2</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(xx, yy));</span><br><span class="line">                    freshLeft --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> freshLeft &gt; <span class="number">0</span> ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode997-Find-the-Town-Judge"><a href="#Leetcode997-Find-the-Town-Judge" class="headerlink" title="Leetcode997. Find the Town Judge"></a>Leetcode997. Find the Town Judge</h1><p>In a town, there are N people labelled from 1 to N.  There is a rumor that one of these people is secretly the town judge.</p>
<p>If the town judge exists, then:</p>
<p>The town judge trusts nobody.<br>Everybody (except for the town judge) trusts the town judge.<br>There is exactly one person that satisfies properties 1 and 2.<br>You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.</p>
<p>If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return -1.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 2, trust = [[1,2]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,3],[2,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,3],[2,3],[3,1]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,2],[2,3]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><br>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><br>在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。如果小镇的法官真的存在，那么：小镇的法官不相信任何人。每个人（除了小镇法官外）都信任小镇的法官。只有一个人同时满足属性 1 和属性 2 。给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findJudge</span><span class="params">(<span class="type">int</span> N, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> in[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;, out[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; trust.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            in[trust[i][<span class="number">1</span>]] ++;</span><br><span class="line">            out[trust[i][<span class="number">0</span>]] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(out[i] == <span class="number">0</span> &amp;&amp; in[i] == N - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode998-Maximum-Binary-Tree-II"><a href="#Leetcode998-Maximum-Binary-Tree-II" class="headerlink" title="Leetcode998. Maximum Binary Tree II"></a>Leetcode998. Maximum Binary Tree II</h1><p>We are given the root node of a maximum tree: a tree where every node has a value greater than any other value in its subtree.<br>Just as in the previous problem, the given tree was constructed from an list A (root = Construct(A)) recursively with the following Construct(A) routine:</p>
<ul>
<li>If A is empty, return null.</li>
<li>Otherwise, let A[i] be the largest element of A. Create a root node with value A[i].</li>
<li>The left child of root will be Construct([A[0], A[1], …, A[i-1]])</li>
<li>The right child of root will be Construct([A[i+1], A[i+2], …, A[A.length - 1]])</li>
<li>Return root.</li>
</ul>
<p>Note that we were not given A directly, only a root node root = Construct(A).</p>
<p>Suppose B is a copy of A with the value val appended to it. It is guaranteed that B has unique values.</p>
<p>Return Construct(B).</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,1,3,null,null,2], val = 5</span><br><span class="line">Output: [5,4,null,1,3,null,null,2]</span><br><span class="line">Explanation: A = [1,4,2,3], B = [1,4,2,3,5]</span><br></pre></td></tr></table></figure><br><img src="/img/1636992467.png" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,2,4,null,1], val = 3</span><br><span class="line">Output: [5,2,4,null,1,null,3]</span><br><span class="line">Explanation: A = [2,1,5,4], B = [2,1,5,4,3]</span><br></pre></td></tr></table></figure><br><img src="/img/1636992495.jpg" alt=""></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,2,3,null,1], val = 4</span><br><span class="line">Output: [5,2,4,null,1,3]</span><br><span class="line">Explanation: A = [2,1,5,3], B = [2,1,5,3,4]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= B.length &lt;= 100</li>
</ul>
<p>和上一题654相比，这道题没有给max binary tree的原始数组nums，而是已经从654建好的tree root。那么已知新的数组是nums后面再加一个val，要返回modify过的新max binary tree。那么分为三种情况讨论，也就是example给出的三种：</p>
<ol>
<li>val &gt; root -&gt;val，新数字将成为新的根节点，root被连接到左边；</li>
<li>val &lt; root -&gt; val，那么要遍历寻找该插入的位置，因为顺序问题，我们不考虑向左子树插入，只向右子树方向递归寻找这个再一次使val &gt; root -&gt; val满足的位置。如果没有找到，需要将新节点连成最后一个max的右子树；</li>
<li>如果找到了这样一个节点parent，那么它的右子树将被连接到新节点的左子树，而新节点被连到parent的右子树。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoMaxTree</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (!root || root -&gt; val &lt; val)  &#123;</span><br><span class="line">            node -&gt; left = root;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        root -&gt; right = <span class="built_in">insertIntoMaxTree</span>(root -&gt; right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode999-Available-Captures-for-Rook"><a href="#Leetcode999-Available-Captures-for-Rook" class="headerlink" title="Leetcode999. Available Captures for Rook"></a>Leetcode999. Available Captures for Rook</h1><p>On an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white bishops, and black pawns.  These are given as characters ‘R’, ‘.’, ‘B’, and ‘p’ respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.</p>
<p>The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.  Also, rooks cannot move into the same square as other friendly bishops.</p>
<p>Return the number of pawns the rook can capture in one move.</p>
<p>Example 1:<br><img src="/img/20190825101.png" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">In this example the rook is able to capture all the pawns.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><img src="/img/20190825102.png" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">Bishops are blocking the rook to capture any pawn.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><img src="/img/20190825103.png" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">The rook can capture the pawns at positions b5, d6 and f5.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>board.length == board[i].length == 8</li>
<li>board[i][j] is either ‘R’, ‘.’, ‘B’, or ‘p’</li>
<li>There is exactly one cell with board[i][j] == ‘R’</li>
</ol>
<p>非常无聊，数格子就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numRookCaptures</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> bBlack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; row++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">8</span>; col++) </span><br><span class="line">                <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;R&#x27;</span> ||</span><br><span class="line">                    board[row][col] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">                    x = row;</span><br><span class="line">                    y = col;</span><br><span class="line">                    <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                        bBlack = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        bBlack = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=x<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[j][y]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[j][y]==<span class="string">&#x27;P&#x27;</span> &amp;&amp; bBlack==<span class="literal">true</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[j][y]==<span class="string">&#x27;p&#x27;</span> &amp;&amp; bBlack==<span class="literal">false</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=x<span class="number">+1</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[j][y]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[j][y]==<span class="string">&#x27;P&#x27;</span> &amp;&amp; bBlack==<span class="literal">true</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[j][y]==<span class="string">&#x27;p&#x27;</span> &amp;&amp; bBlack==<span class="literal">false</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=y<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[x][j]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[x][j]==<span class="string">&#x27;P&#x27;</span> &amp;&amp; bBlack==<span class="literal">true</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[x][j]==<span class="string">&#x27;p&#x27;</span> &amp;&amp; bBlack==<span class="literal">false</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=y<span class="number">+1</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[x][j]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[x][j]==<span class="string">&#x27;P&#x27;</span> &amp;&amp; bBlack==<span class="literal">true</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[x][j]==<span class="string">&#x27;p&#x27;</span> &amp;&amp; bBlack==<span class="literal">false</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/04/24/%E7%90%86%E8%A7%A3glibc_malloc_%E4%B8%BB%E6%B5%81%E7%94%A8%E6%88%B7%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="prev" title="理解 glibc malloc：主流用户态内存分配器实现原理">
      <i class="fa fa-chevron-left"></i> 理解 glibc malloc：主流用户态内存分配器实现原理
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/05/06/Leetcode601_700/" rel="next" title="Leetcode601 - 700">
      Leetcode601 - 700 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode901-Online-Stock-Span"><span class="nav-number">1.</span> <span class="nav-text">Leetcode901. Online Stock Span</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode904-Fruit-Into-Baskets"><span class="nav-number">2.</span> <span class="nav-text">Leetcode904. Fruit Into Baskets</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode905-Sort-Array-By-Parity"><span class="nav-number">3.</span> <span class="nav-text">Leetcode905. Sort Array By Parity</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode907-Sum-of-Subarray-Minimums"><span class="nav-number">4.</span> <span class="nav-text">Leetcode907. Sum of Subarray Minimums</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode908-Smallest-Range-I"><span class="nav-number">5.</span> <span class="nav-text">Leetcode908. Smallest Range I</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode909-Snakes-and-Ladders"><span class="nav-number">6.</span> <span class="nav-text">Leetcode909. Snakes and Ladders</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode911-Online-Election"><span class="nav-number">7.</span> <span class="nav-text">Leetcode911. Online Election</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode912-Sort-an-Array"><span class="nav-number">8.</span> <span class="nav-text">Leetcode912. Sort an Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode914-X-of-a-Kind-in-a-Deck-of-Cards"><span class="nav-number">9.</span> <span class="nav-text">Leetcode914. X of a Kind in a Deck of Cards</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode915-Partition-Array-into-Disjoint-Intervals"><span class="nav-number">10.</span> <span class="nav-text">Leetcode915. Partition Array into Disjoint Intervals</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode916-Word-Subsets"><span class="nav-number">11.</span> <span class="nav-text">Leetcode916. Word Subsets</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode917-Reverse-Only-Letters"><span class="nav-number">12.</span> <span class="nav-text">Leetcode917. Reverse Only Letters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode918-Maximum-Sum-Circular-Subarray"><span class="nav-number">13.</span> <span class="nav-text">Leetcode918. Maximum Sum Circular Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode921-Minimum-Add-to-Make-Parentheses-Valid"><span class="nav-number">14.</span> <span class="nav-text">Leetcode921. Minimum Add to Make Parentheses Valid</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode922-Sort-Array-By-Parity-II"><span class="nav-number">15.</span> <span class="nav-text">Leetcode922. Sort Array By Parity II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode925-Long-Pressed-Name"><span class="nav-number">16.</span> <span class="nav-text">Leetcode925. Long Pressed Name</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode926-Flip-String-to-Monotone-Increasing"><span class="nav-number">17.</span> <span class="nav-text">Leetcode926. Flip String to Monotone Increasing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode929-Unique-Email-Addresses"><span class="nav-number">18.</span> <span class="nav-text">Leetcode929. Unique Email Addresses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode930-Binary-Subarrays-With-Sum"><span class="nav-number">19.</span> <span class="nav-text">Leetcode930. Binary Subarrays With Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode931-Minimum-Falling-Path-Sum"><span class="nav-number">20.</span> <span class="nav-text">Leetcode931. Minimum Falling Path Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode932-Beautiful-Array"><span class="nav-number">21.</span> <span class="nav-text">Leetcode932. Beautiful Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode933-Number-of-Recent-Calls"><span class="nav-number">22.</span> <span class="nav-text">Leetcode933. Number of Recent Calls</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode934-Shortest-Bridge"><span class="nav-number">23.</span> <span class="nav-text">Leetcode934. Shortest Bridge</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode-935-Knight-Dialer-%E9%AA%91%E5%A3%AB%E6%8B%A8%E5%8F%B7%E5%99%A8"><span class="nav-number">24.</span> <span class="nav-text">LeetCode] 935. Knight Dialer 骑士拨号器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode937-Reorder-Data-in-Log-Files"><span class="nav-number">25.</span> <span class="nav-text">Leetcode937. Reorder Data in Log Files</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode938-Range-Sum-of-BST"><span class="nav-number">26.</span> <span class="nav-text">Leetcode938. Range Sum of BST</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode939-Minimum-Area-Rectangle"><span class="nav-number">27.</span> <span class="nav-text">Leetcode939. Minimum Area Rectangle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode941-Valid-Mountain-Array"><span class="nav-number">28.</span> <span class="nav-text">Leetcode941. Valid Mountain Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode942-DI-String-Match"><span class="nav-number">29.</span> <span class="nav-text">Leetcode942. DI String Match</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode944-Delete-Columns-to-Make-Sorted"><span class="nav-number">30.</span> <span class="nav-text">Leetcode944. Delete Columns to Make Sorted</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode945-Minimum-Increment-to-Make-Array-Unique"><span class="nav-number">31.</span> <span class="nav-text">Leetcode945. Minimum Increment to Make Array Unique</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode946-Validate-Stack-Sequences"><span class="nav-number">32.</span> <span class="nav-text">LeetCode946. Validate Stack Sequences</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode947-Most-Stones-Removed-with-Same-Row-or-Column"><span class="nav-number">33.</span> <span class="nav-text">Leetcode947. Most Stones Removed with Same Row or Column</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">33.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS"><span class="nav-number">33.2.</span> <span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Union-Find"><span class="nav-number">33.3.</span> <span class="nav-text">Union-Find</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode948-Bag-of-Tokens"><span class="nav-number">34.</span> <span class="nav-text">Leetcode948. Bag of Tokens</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode949-Largest-Time-for-Given-Digits"><span class="nav-number">35.</span> <span class="nav-text">Leetcode949. Largest Time for Given Digits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode950-Reveal-Cards-In-Increasing-Order"><span class="nav-number">36.</span> <span class="nav-text">Leetcode950. Reveal Cards In Increasing Order</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode951-Flip-Equivalent-Binary-Trees"><span class="nav-number">37.</span> <span class="nav-text">Leetcode951. Flip Equivalent Binary Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode953-Verifying-an-Alien-Dictionary"><span class="nav-number">38.</span> <span class="nav-text">Leetcode953. Verifying an Alien Dictionary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode955-Delete-Columns-to-Make-Sorted-II"><span class="nav-number">39.</span> <span class="nav-text">Leetcode955. Delete Columns to Make Sorted II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode957-Prison-Cells-After-N-Days"><span class="nav-number">40.</span> <span class="nav-text">Leetcode957. Prison Cells After N Days</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode958-Check-Completeness-of-a-Binary-Tree"><span class="nav-number">41.</span> <span class="nav-text">Leetcode958. Check Completeness of a Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode959-Regions-Cut-By-Slashes"><span class="nav-number">42.</span> <span class="nav-text">Leetcode959. Regions Cut By Slashes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode961-N-Repeated-Element-in-Size-2N-Array"><span class="nav-number">43.</span> <span class="nav-text">Leetcode961. N-Repeated Element in Size 2N Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode962-Maximum-Width-Ramp"><span class="nav-number">44.</span> <span class="nav-text">Leetcode962. Maximum Width Ramp</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode963-Minimum-Area-Rectangle-II"><span class="nav-number">45.</span> <span class="nav-text">Leetcode963. Minimum Area Rectangle II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode965-Univalued-Binary-Tree"><span class="nav-number">46.</span> <span class="nav-text">Leetcode965. Univalued Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode966-Vowel-Spellchecker"><span class="nav-number">47.</span> <span class="nav-text">Leetcode966. Vowel Spellchecker</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode969-Pancake-Sorting"><span class="nav-number">48.</span> <span class="nav-text">Leetcode969. Pancake Sorting</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode970-Powerful-Integers"><span class="nav-number">49.</span> <span class="nav-text">Leetcode970. Powerful Integers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode971-Flip-Binary-Tree-To-Match-Preorder-Traversal"><span class="nav-number">50.</span> <span class="nav-text">Leetcode971. Flip Binary Tree To Match Preorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode973-K-Closest-Points-to-Origin"><span class="nav-number">51.</span> <span class="nav-text">Leetcode973. K Closest Points to Origin</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode976-Largest-Perimeter-Triangle"><span class="nav-number">52.</span> <span class="nav-text">Leetcode976. Largest Perimeter Triangle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode977-Squares-of-a-Sorted-Array"><span class="nav-number">53.</span> <span class="nav-text">Leetcode977. Squares of a Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode978-Longest-Turbulent-Subarray"><span class="nav-number">54.</span> <span class="nav-text">Leetcode978. Longest Turbulent Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode979-Distribute-Coins-in-Binary-Tree"><span class="nav-number">55.</span> <span class="nav-text">Leetcode979. Distribute Coins in Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode980-Unique-Paths-III"><span class="nav-number">56.</span> <span class="nav-text">Leetcode980. Unique Paths III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode981-Time-Based-Key-Value-Store"><span class="nav-number">57.</span> <span class="nav-text">Leetcode981. Time Based Key-Value Store</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode983-Minimum-Cost-For-Tickets"><span class="nav-number">58.</span> <span class="nav-text">Leetcode983. Minimum Cost For Tickets</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="nav-number">58.1.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode984-String-Without-AAA-or-BBB"><span class="nav-number">59.</span> <span class="nav-text">Leetcode984. String Without AAA or BBB</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode985-Sum-of-Even-Numbers-After-Queries"><span class="nav-number">60.</span> <span class="nav-text">Leetcode985. Sum of Even Numbers After Queries</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode986-Interval-List-Intersections"><span class="nav-number">61.</span> <span class="nav-text">Leetcode986. Interval List Intersections</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode987-Vertical-Order-Traversal-of-a-Binary-Tree"><span class="nav-number">62.</span> <span class="nav-text">Leetcode987. Vertical Order Traversal of a Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode988-Smallest-String-Starting-From-Leaf"><span class="nav-number">63.</span> <span class="nav-text">Leetcode988. Smallest String Starting From Leaf</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode989-Add-to-Array-Form-of-Integer"><span class="nav-number">64.</span> <span class="nav-text">Leetcode989. Add to Array-Form of Integer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode990-Satisfiability-of-Equality-Equations"><span class="nav-number">65.</span> <span class="nav-text">Leetcode990. Satisfiability of Equality Equations</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode991-Broken-Calculator"><span class="nav-number">66.</span> <span class="nav-text">Leetcode991. Broken Calculator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode993-Cousins-in-Binary-Tree"><span class="nav-number">67.</span> <span class="nav-text">Leetcode993. Cousins in Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode994-Rotting-Oranges"><span class="nav-number">68.</span> <span class="nav-text">Leetcode994. Rotting Oranges</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode997-Find-the-Town-Judge"><span class="nav-number">69.</span> <span class="nav-text">Leetcode997. Find the Town Judge</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode998-Maximum-Binary-Tree-II"><span class="nav-number">70.</span> <span class="nav-text">Leetcode998. Maximum Binary Tree II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode999-Available-Captures-for-Rook"><span class="nav-number">71.</span> <span class="nav-text">Leetcode999. Available Captures for Rook</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
