<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="使用C++11让程序更简洁类型推导引入auto和decltype。 auto1234auto i &#x3D; 10; &#x2F;&#x2F; i是intauto pu &#x3D; new auto(1); &#x2F;&#x2F; pu是int*const auto *v &#x3D; &amp;i, u &#x3D; 6; &#x2F;&#x2F; v是const int*，u是const intauto s; &#x2F;&#x2F;错误，无法推断 初始化不能使编译器推导产生二义性，如把u写成u&#x3D;6.0则">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11特性笔记">
<meta property="og:url" content="http://yoursite.com/2020/01/28/cpp11%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="使用C++11让程序更简洁类型推导引入auto和decltype。 auto1234auto i &#x3D; 10; &#x2F;&#x2F; i是intauto pu &#x3D; new auto(1); &#x2F;&#x2F; pu是int*const auto *v &#x3D; &amp;i, u &#x3D; 6; &#x2F;&#x2F; v是const int*，u是const intauto s; &#x2F;&#x2F;错误，无法推断 初始化不能使编译器推导产生二义性，如把u写成u&#x3D;6.0则">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/468725-20150831100452169-1977975177.png">
<meta property="article:published_time" content="2020-01-28T12:13:00.000Z">
<meta property="article:modified_time" content="2022-10-01T03:30:29.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/468725-20150831100452169-1977975177.png">

<link rel="canonical" href="http://yoursite.com/2020/01/28/cpp11%E7%89%B9%E6%80%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>C++11特性笔记 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">128</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/28/cpp11%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++11特性笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-28 20:13:00" itemprop="dateCreated datePublished" datetime="2020-01-28T20:13:00+08:00">2020-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-01 11:30:29" itemprop="dateModified" datetime="2022-10-01T11:30:29+08:00">2022-10-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="使用C-11让程序更简洁"><a href="#使用C-11让程序更简洁" class="headerlink" title="使用C++11让程序更简洁"></a>使用C++11让程序更简洁</h1><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>引入auto和decltype。</p>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto i = 10; // i是int</span><br><span class="line">auto pu = new auto(1); // pu是int*</span><br><span class="line">const auto *v = &amp;i, u = 6; // v是const int*，u是const int</span><br><span class="line">auto s; //错误，无法推断</span><br></pre></td></tr></table></figure>
<p>初始化不能使编译器推导产生二义性，如把u写成<code>u=6.0</code>则不予通过。<br>使用auto声明的变量必须马上初始化，以让编译器推断出类型并在编译时将auto替换为真正的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int x = 0;  //</span><br><span class="line">auto * a = &amp;x;  // a是int*，auto被推导为int</span><br><span class="line">auto b = &amp;x;  // b是int*，auto被推导为int*</span><br><span class="line">auto &amp; c = x;  // c是int&amp;，auto被推导为int</span><br><span class="line">auto d = c;  // d是int，auto被推导为int</span><br><span class="line"></span><br><span class="line">const auto e = x;  // e是const int</span><br><span class="line">auto f = e;  // f是int</span><br><span class="line">cosnt auto &amp; g = x;  // g是const int&amp;</span><br><span class="line">auto &amp; h = g;  // h是const int&amp;</span><br></pre></td></tr></table></figure>
<p>a和c的类型推导结果很明显，auto在编译时被替换为int，b的推导结果表明auto不声明为指针，也可以推导出指针类型；d的推导结果表明当表达式是一个引用类型时，auto会把引用类型抛弃，直接推导成原始类型int。f的推导结果表明表达式带有const时，auto会把const属性抛弃掉，推导成non-const的int。规则如下：</p>
<ul>
<li>当不声明为指针或引用时，auto的推导结果和初始化表达式抛弃引用和cv限定符（const和volatile）后类型一致</li>
<li>当声明为指针或引用时，auto的推导结果将保留初始化表达式的cv属性。</li>
<li>auto不能用为函数参数。</li>
<li>auto无法定义数组！</li>
</ul>
<p>auto的推导和函数模板参数的自动推导有相似之处。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; void func(T x) &#123;&#125; // T -&gt; auto</span><br><span class="line">template &lt;typename T&gt; void func(T *x)&#123;&#125; // T -&gt; auto*</span><br><span class="line">template &lt;typename T&gt; void func(T&amp; x)&#123;&#125; // T&amp;-&gt; auto&amp;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; void func(const T x) &#123;&#125; // const T -&gt; const auto</span><br><span class="line">template &lt;typename T&gt; void func(const T* x)&#123;&#125; // const T*-&gt; const auto *</span><br><span class="line">template &lt;typename T&gt; void func(const T&amp; x)&#123;&#125; // const T&amp;-&gt; const auto &amp;</span><br><span class="line">注意:auto是不能用于函数参数的。</span><br></pre></td></tr></table></figure></p>
<p>何时使用auto？看一个例子，在一个unordered_multimap中查找一个范围,代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	std::unordered_multimap&lt;int, int&gt; resultMap;</span><br><span class="line">	std::pair&lt;std::unordered_multimap&lt;int, int&gt;::iterator, std::unordered_multimap&lt;int, int&gt;::iterator&gt; range = resultMap.equal_range(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个 equal_ange返回的类型声明显得烦琐而冗长,而且实际上并不关心这里的具体类型（大概知道是一个std::pair就够了）。这时,通过auto就能极大的简化书写,省去推导具体类型的过程<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	std::unordered_multimap&lt;int, int&gt; map;</span><br><span class="line">	auto range_map.equal_range(key);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>auto所修饰的变量必须被初始化，C++11新增了decltype关键字，用来在编译时推导出一个表达式的类型。<code>decltype(exp)</code>，exp是一个表达式。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int x = 0;</span><br><span class="line">decltype(x) y = 1; // y -&gt; int</span><br><span class="line">decltype(x + y) z = 0; // z -&gt; int</span><br><span class="line"></span><br><span class="line">const int&amp; i = x;</span><br><span class="line">decltype(i) j = y; // j -&gt; const int &amp;</span><br><span class="line"></span><br><span class="line">const decltype(z) * p = &amp;z; // *p -&gt; const int, p -&gt; const int *</span><br><span class="line">decltype(z) * pi = &amp;z; // * pi -&gt; int, pi -&gt; int*</span><br><span class="line">decltype(pi) * pp = &amp;pi; // *pp -&gt; int *, pp -&gt; int **</span><br></pre></td></tr></table></figure></p>
<p>y和z的结果表明，decltype可以根据表达式直接推导出它的类型本身。这个功能和上节的auto很像,但又有所不同。auto只能根据变量的初始化表达式推导出变量应该具有的类型。若想要通过某个表达式得到类型,但不希望新变量和这个表达式具有同样的值,此时auto就显得不适用了。<br>j的结果表明decltype通过表达式得到的类型,可以保留住表达式的引用及const限定符。实际上，对于一般的标记符表达式(id-expression)，decltype将精确地推导出表达式定义本身的类型，不会像auto那样在某些情况下舍弃掉引用和cv限定符。p、pi的结果表明decltype可以像auto一样，加上引用和指针，以及cv限定符。</p>
<p>pp的推导则表明,当表达式是一个指针的时候，decltype仍然推导出表达式的实际类型（指针类型），之后结合pp定义时的指针标记，得到的pp是一个二维指针类型。这也是和auto推导不同的一点。</p>
<p>推导规则：</p>
<ul>
<li>exp是标识符、类访问表达式，decltype(type)和exp的类型一致；</li>
<li>exp是函数调用，decltype(type)和函数返回值类型一致；</li>
<li>若exp是一个左值，则decltype(type)是exp类型的左值引用，否则和exp类型一致。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Foo &#123;int x;&#125;;</span><br><span class="line">const Foo foo = Foo();</span><br><span class="line"></span><br><span class="line">decltype(foo.x) a = 0;   // a -&gt; int</span><br><span class="line">decltype((foo.x)) b = a; // b -&gt; const int &amp;</span><br></pre></td></tr></table></figure>
<p>a的类型就是foo.x的类型，foo.x是一个左值，可知括号表达式也是一个左值，decltype的类型是一个左值引用。</p>
<p>在泛型编程中，可能需要通过参数运算获得返回值类型：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename R, typename T, typename U&gt;</span><br><span class="line">R add(T t, U u) &#123;</span><br><span class="line">	return t+u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a = 1;</span><br><span class="line">float b = 2.0;</span><br><span class="line">auto c = add&lt;decltype(a+b)&gt;(a, b);</span><br></pre></td></tr></table></figure><br>改成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">decltype(T()+U()) add(T t, U u) &#123;</span><br><span class="line">	return t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>考虑到T、U可能是没有无参构造函数的类，可以如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">decltype((*(T*)0) + (*(U*)0)) add(T t, U u) &#123;</span><br><span class="line">	return t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回类型后置语法通过auto和decltype结合使用，可以写成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">auto add(T t, U u) -&gt; decltype(t + u) &#123;</span><br><span class="line">	return t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>返回类型后置语法解决了返回值类型依赖于参数而导致难以确定返回值类型的问题。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int&amp; foo(int&amp; i);</span><br><span class="line">float foo(float&amp; f);</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">auto func(T&amp; val) -&gt; decltype(foo(val)) &#123;</span><br><span class="line">	return foo(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="模板的细节改进"><a href="#模板的细节改进" class="headerlink" title="模板的细节改进"></a>模板的细节改进</h2><h3 id="模板的右尖括号"><a href="#模板的右尖括号" class="headerlink" title="模板的右尖括号"></a>模板的右尖括号</h3><p>尽可能将多个右尖括号解析成模板参数结束符。</p>
<h3 id="模板的别名"><a href="#模板的别名" class="headerlink" title="模板的别名"></a>模板的别名</h3><p>重定义一个模板<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Val&gt;</span><br><span class="line">using str_map_t = std::map&lt;std::string, Val&gt;;</span><br><span class="line"></span><br><span class="line">str_map_t&lt;int&gt; map1;</span><br></pre></td></tr></table></figure><br>使用新的using别名语法定义了std::map的模板别名str_map_t。<br>实际上，using的别名语法覆盖了typedef的全部功能，两种使用方法等效。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned int uint_t;</span><br><span class="line">using uint_t = unsigned int;</span><br><span class="line"></span><br><span class="line">typedef std::map&lt;std::string, int&gt; map_int_t;</span><br><span class="line">using map_int_t = std::map&lt;std::string, int&gt;;</span><br></pre></td></tr></table></figure></p>
<p>using定义模板别名：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">using func_t = void(*)(T, T);</span><br><span class="line">func_t&lt;int&gt; xx_2;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数模板的默认模板参数"><a href="#函数模板的默认模板参数" class="headerlink" title="函数模板的默认模板参数"></a>函数模板的默认模板参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T = int&gt;</span><br><span class="line">void func(void) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>当所有模板参数都有默认参数时，函数模板的调用如同一个普通参数，对于类模板而言，哪怕所有参数都有默认参数，在使用时也要在模板名后跟一个“&lt;&gt;”实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename R = int, typename U&gt;</span><br><span class="line">R func(U val) &#123;</span><br><span class="line">	val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	func(123);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用函数模板时，若显式指定模板参数，由于参数填充顺序是从左往右的，因此，像下面这个调用，<code>func&lt;long&gt;(123)</code>，func的返回值是long，而不是int。</p>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>在C++98/03中的对象初始化方法有多种。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int i_arr[3] = &#123;1, 2, 3&#125;;</span><br><span class="line"></span><br><span class="line">struct A &#123;</span><br><span class="line">	int x;</span><br><span class="line">	struct B &#123;</span><br><span class="line">		int i;</span><br><span class="line">		int j;</span><br><span class="line">	&#125; b;</span><br><span class="line">&#125; a = &#123; 1, &#123;2, 3&#125; &#125;;</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo(int) &#123;&#125;</span><br><span class="line">&#125; foo = 123;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>C++11中提出了列表初始化的概念。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo a3 = &#123;123&#125;;</span><br><span class="line">Foo a4 &#123;123&#125;;</span><br><span class="line"></span><br><span class="line">int a5 = &#123;3&#125;;</span><br><span class="line">int s6 &#123;3&#125;;</span><br></pre></td></tr></table></figure><br>a3虽然使用了等于号，但是仍然是列表初始化，因此，私有的拷贝构造不会影响到它。<br>a4和a6的写法是C++98/03不具备的，可以直接在变量名后跟上初始化列表，来进行对象的初始化。</p>
<p>new操作符等可以用圆括号初始化的地方可以使用初始化列表：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* a = new int &#123;123&#125;;</span><br><span class="line">double b = double &#123;123&#125;;</span><br><span class="line">int* arr = new int[3] &#123;1, 2, 3&#125;;</span><br></pre></td></tr></table></figure></p>
<p>聚合类型：</p>
<ul>
<li>类型是一个普通数组</li>
<li>类型是一个类，且<ul>
<li>无用户定义的构造函数</li>
<li>无私有或保护的非静态数据成员</li>
<li>无基类</li>
<li>无虚函数</li>
<li>不能有{}和=直接初始化的非静态数据成员</li>
</ul>
</li>
</ul>
<p>对数组而言，只要该类型是一个普通数组，哪怕数组的元素并非聚合类型，这个数组本身也是一个聚合类型：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x[] = &#123;1, 3, 5&#125;;</span><br><span class="line">float y[4][3] = &#123;</span><br><span class="line">	&#123;1, 3, 5&#125;,</span><br><span class="line">	&#123;2, 4, 6&#125;,</span><br><span class="line">	&#123;3, 5, 7&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当类型是一个类时，首先是存在用户自定义构造函数时，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Foo &#123;</span><br><span class="line">	int x;</span><br><span class="line">	double y;</span><br><span class="line">	int z;</span><br><span class="line">	Foo(int, int) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Foo foo&#123;1, 2.5, 1&#125;;  // ERROR!</span><br></pre></td></tr></table></figure><br>这时无法将Foo看成一个聚合类型，必须以自定义构造函数构造对象。<br>如果受保护（protected）成员是一个static的，则可以不放在初始化列表里。<br>如果类定义里的成员变量已经有了赋值，则不可以使用初始化列表。</p>
<p><strong>上述不可使用初始化列表的情况可以通过自定义构造函数实现使用初始化列表</strong></p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><h4 id="任意长度初始化列表"><a href="#任意长度初始化列表" class="headerlink" title="任意长度初始化列表"></a>任意长度初始化列表</h4><p>C++11中的stl容器拥有和未显示指定长度的数组一样的初始化能力：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int arr[] = &#123;1, 2, 3&#125;;</span><br><span class="line">std::map&lt;std::string, int&gt; mm = &#123; &#123;&quot;1&quot;, 1&#125;, &#123;&quot;2&quot;, 2&#125;, &#123;&quot;3&quot;, 3&#125; &#125;;</span><br><span class="line">std::set&lt;int&gt; ss = &#123;1, 2, 3&#125;;</span><br><span class="line">std::vector&lt;int&gt; arr = &#123;1, 2, 3, 4, 5&#125;;</span><br></pre></td></tr></table></figure><br>这里arr未显式指定长度，因此它的初始化列表可以是任意长度。<br>实际上stl中的容器是通过使用<code>std::initializer_list</code>这个类模板完成上述功能的，如果在类Foo中添加一个<code>std::initializer_list</code>构造函数，它也将拥有这种能力。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">	std::vector&lt;int&gt; content;</span><br><span class="line">public:</span><br><span class="line">	Foo(std::initializer_list&lt;int&gt; list) &#123;</span><br><span class="line">		for(auto it = list.begin(); it != list.end(); it ++)&#123;</span><br><span class="line">			content.push_back(*it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Foo1 &#123;</span><br><span class="line">	std::map&lt;int, int&gt; content;</span><br><span class="line">	using pair_t = std::map&lt;int, int&gt;::value_type;</span><br><span class="line">public:</span><br><span class="line">	Foo1(std::initializer_list&lt;int&gt; list) &#123;</span><br><span class="line">		for(auto it = list.begin(); it != list.end(); it ++)&#123;</span><br><span class="line">			content.insert(*it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo foo = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">Foo1 foo1 = &#123; &#123;1, 2&#125;, &#123;2, 3&#125;, &#123;3, 4&#125; &#125;;</span><br></pre></td></tr></table></figure><br>用来传递同类型的数据集合：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func(std::initializer_list&lt;int&gt; list) &#123;</span><br><span class="line">	for(auto it = list.begin(); it != list.end(); it ++)&#123;</span><br><span class="line">		std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>std::initializer_list</code>的一些特点：</p>
<ul>
<li>轻量级容器类型，内部定义了iterator等；</li>
<li>对于<code>std::initializer_list&lt;T&gt;</code>，可以接受任意长度的初始化列表，但要求必须时同种类型；</li>
<li>有三个成员接口：<code>size()</code>、<code>begin()</code>、<code>end()</code>；</li>
<li>只能被整体初始化或赋值。</li>
<li>只能通过begin和end循环遍历，遍历时取得的迭代器是只读的，因此无法修改其中一个值。</li>
<li>实际上，<code>std::initializer_list</code>非常高效，内部并不负责保存初始化列表中元素的拷贝，而是只储存列表中元素的引用而已。</li>
</ul>
<h3 id="防止类型收窄"><a href="#防止类型收窄" class="headerlink" title="防止类型收窄"></a>防止类型收窄</h3><p>类型收窄指导致数据内容发生变化或精度损失的隐式类型转换，包含以下几种：</p>
<ul>
<li>从浮点数隐式转换为整型；</li>
<li>从高精度浮点数转换为低精度浮点数，如从long double转换为double或float；</li>
<li>从整型数隐式转换为浮点数，并超过了浮点数表示范围；</li>
<li>从整型数隐式转换为长度较短的整型数。</li>
</ul>
<p>初始化列表不会允许类型收窄的转换发生。</p>
<h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><h3 id="for循环的新用法"><a href="#for循环的新用法" class="headerlink" title="for循环的新用法"></a>for循环的新用法</h3><p>在<code>&lt;algorithm&gt;</code>中有<code>for_each</code>可以用于遍历：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void do_cout(int n) &#123;</span><br><span class="line">	std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	std::vector&lt;int&gt; arr;</span><br><span class="line">	std::for_each(arr.begin(), arr.end(), do_cout);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以改成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	std::vector&lt;int&gt; arr;</span><br><span class="line">	for(auto n : arr) &#123;</span><br><span class="line">		std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>n表示arr中的一个个元素，auto则是让编译器自动推导n的类型，在这里n的类型被自动推导为vector中的元素类型int。<br>基于范围的for循环对于冒号前边的局部变量声明只要求能支持容器类型的隐式转换。<br>如果需要在遍历时修改容器中的值，则需要使用引用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(auto&amp; n : arr) &#123;</span><br><span class="line">	std::cout &lt;&lt; n++ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="基于范围的for循环的细节"><a href="#基于范围的for循环的细节" class="headerlink" title="基于范围的for循环的细节"></a>基于范围的for循环的细节</h3><p>auto自动推导出的类型是容器中的value_type，而不是迭代器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, int&gt; mm = &#123; &#123;&quot;1&quot;, 1&#125;, &#123;&quot;2&quot;, 2&#125;, &#123;&quot;3&quot;, 3&#125; &#125;;</span><br><span class="line">for(auto ite = mm.begin(); ite != mm.end(); ite ++)</span><br><span class="line">	std::cout &lt;&lt; ite-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; ite-&gt;second &lt;&lt; std::endl;</span><br><span class="line">for(auto&amp; val : mm) </span><br><span class="line">	std::cout &lt;&lt; ite.first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; ite.second &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><br>从这里就可以看出，在基于范围的for循环中每次迭代时使用的类型和普通for循环有何不同。</p>
<p><strong>对基于范围的for循环而言，冒号后边的表达式只会被执行一次</strong></p>
<p><strong>基于范围的for循环倾向于在循环开始之前确定好迭代的范围，而不是在每次迭代之前都调用一次arr.end()</strong></p>
<h3 id="让基于范围的for循环支持自定义类型"><a href="#让基于范围的for循环支持自定义类型" class="headerlink" title="让基于范围的for循环支持自定义类型"></a>让基于范围的for循环支持自定义类型</h3><p>基于范围的for循环将以以下方式查找容器的begin和end：</p>
<ul>
<li>若容器是一个普通的array对象，那么begin将为array的首地址；</li>
<li>若容器是一个类对象，那么range-based for将试图通过查找类的begin()和end()方法来定位begin和end迭代器；</li>
<li>否则range-based for将试图使用全局的begin和end函数定位begin和end；</li>
</ul>
<p>对于自定义类型来说，实现begin和end方法即可，通过定义一个range对象看看具体的实现方法。<br>首先需要一个迭代器实现范围取值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class iterator &#123;</span><br><span class="line">public:</span><br><span class="line">	using value_type = T;</span><br><span class="line">	using size_type = size_t;</span><br><span class="line"></span><br><span class="line">	iterator(size_type cur_start, value_type begin_val, value_type step_val);</span><br><span class="line">	value_type operator*() const;</span><br><span class="line">	bool operator!=(const iterator&amp; rhs);</span><br><span class="line">	iterator&amp; operator++(void);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>构造函数传递三个参数初始化，分别是开始的迭代次数，初始值和迭代步长。<code>operator*</code>用于取得迭代器中的值；<code>operator!=</code>用于和另一个迭代器比较；<code>operator++</code>用于对迭代器做正向迭代。</p>
<p>迭代器类的实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class iterator &#123;</span><br><span class="line">private:</span><br><span class="line">	size_type cursor_;</span><br><span class="line">	const value_type step_;</span><br><span class="line">	value_type value_;</span><br><span class="line">public:</span><br><span class="line">	using value_type = T;</span><br><span class="line">	using size_type = size_t;</span><br><span class="line"></span><br><span class="line">	iterator(size_type cur_start, value_type begin_val, value_type step_val):</span><br><span class="line">	cursor_(cur_start), step_(step_val), value_(begin_val) &#123;</span><br><span class="line">		value_ += (step_ * cursor_);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	value_type operator*() const &#123; return value_; &#125;</span><br><span class="line">	bool operator!=(const iterator&amp; rhs) const &#123; return (cursor_ != rhs.cursor_); &#125;</span><br><span class="line">	iterator&amp; operator++(void) &#123; </span><br><span class="line">		value_ += step_;</span><br><span class="line">		++ cursor_;</span><br><span class="line">		return (*this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="std-function和bind绑定器"><a href="#std-function和bind绑定器" class="headerlink" title="std::function和bind绑定器"></a>std::function和bind绑定器</h2><h3 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h3><p>可调用对象有如下几种定义：</p>
<ul>
<li>是一个函数指针</li>
<li>是一个具有operator()成员函数的类对象</li>
<li>是一个可被转换为函数指针的类对象</li>
<li>是一个类成员指针</li>
</ul>
<p>应用如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void func(void) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">struct Foo &#123;</span><br><span class="line">	void operator()(void) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Bar &#123;</span><br><span class="line">	using fr_t = void(*)(void);</span><br><span class="line"></span><br><span class="line">	static void func(void) &#123; ... &#125;</span><br><span class="line">	operator fr_t(void) &#123; return func; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct A &#123;</span><br><span class="line">	int a_;</span><br><span class="line">	void mem_func(void) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	void(* func_ptr)(void) = &amp;func; // 1.函数指针</span><br><span class="line">	func_ptr();</span><br><span class="line"></span><br><span class="line">	Foo foo;</span><br><span class="line">	foo();	// 2. 仿函数</span><br><span class="line"></span><br><span class="line">	Bar bar;</span><br><span class="line">	bar();	// 3. 可被转换为函数指针的类对象</span><br><span class="line"></span><br><span class="line">	void (A::*mem_func_ptr)(void) = &amp;A::mem_func;	// 4. 类成员函数指针</span><br><span class="line">	int A::*mem_obj_ptr = &amp;A::a_;	// 或是类成员指针</span><br><span class="line"></span><br><span class="line">	A aa;</span><br><span class="line">	(aa.*mem_func_ptr)();</span><br><span class="line">	aa.*mem_obj_ptr = 123;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="可调用对象包装器-std-function"><a href="#可调用对象包装器-std-function" class="headerlink" title="可调用对象包装器-std::function"></a>可调用对象包装器-std::function</h3><p>std::function是可调用对象包装器。它是一个类模板，可以容纳除了类成员指针之外的所有可调用对象。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">void func(void) &#123;</span><br><span class="line">	std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	static int foo_func(int a) &#123;</span><br><span class="line">		std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;) -&gt;: &quot;;</span><br><span class="line">		return a; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Bar &#123;</span><br><span class="line">public:</span><br><span class="line">	int operator()(int a) &#123;</span><br><span class="line">		std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;) -&gt;: &quot;;</span><br><span class="line">		return a; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	std::function&lt;void(void)&gt; fr1 = func;</span><br><span class="line">	fr1();</span><br><span class="line"></span><br><span class="line">	std::function&lt;int(int)&gt; fr2 = Foo::foo_func;</span><br><span class="line">	std::cout &lt;&lt; fr2(123) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	Bar bar;</span><br><span class="line">	fr2 = bar;</span><br><span class="line">	std::cout &lt;&lt; fr2(123) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>结果是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func</span><br><span class="line">foo_func(123) -&gt;: 123</span><br><span class="line">operator()(123) -&gt;: 123</span><br></pre></td></tr></table></figure></p>
<p>给std::function填入合适的函数名，它就变成一个可以容纳所有这一类调用方式的函数包装器。</p>
<p>std::function作为函数入参：<code>void call(int x, std::function&lt;void(int)&gt;&amp; f)</code></p>
<h2 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h2><p>std::bind绑定器用来将可调用对象与其参数一起进行绑定，绑定后的结果使用std::function保存，并延迟调用到任何我们需要的时候，用途为：</p>
<ul>
<li>将可调用对象与其参数一起绑定成为一个仿函数；</li>
<li>将多元可调用对象转成一元或者(n-1)元可调用对象，即只绑定部分参数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	auto fr = std::bind(output, std::placeholders::_l);</span><br><span class="line">	for( int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">		call_when_even(i, fr);</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	auto fr2 = std::bind(output_2, std::placeholders::_l);</span><br><span class="line">	for( int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">		call_when_even(i, fr);</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用了std::bind，在函数外部通过绑定不同的函数，控制了最后的执行结果。我们使用<code>auto fr</code>保存<code>std::bind</code>的返回结果，是因为我们并不关心<code>std::bind</code>真正的返回类型（实际上<code>std::bind</code>的返回类型是一个stl内部定义的仿函数类型），只需要知道它是一个仿函数，可以直接赋值给一个std::function。当然，这里直接使用<code>std::function</code>类型来保存<code>std::bind</code>的返回值也是可以的。</p>
<p><code>std::placeholders::_1</code>是一个占位符，代表这个位置将在函数调用时，被传入的第一个参数所替代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">void output(int x, int y) &#123;</span><br><span class="line">	std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	std::bind(output, 1, 2)();</span><br><span class="line">	std::bind(output, std::placeholders::_1, 2)(1);</span><br><span class="line">	std::bind(output, 2, std::placeholders::_1)(1);</span><br><span class="line">	std::bind(output, 2, std::placeholders::_2)(1);</span><br><span class="line">	std::bind(output, 2, std::placeholders::_2)(1, 2);</span><br><span class="line">	std::bind(output, std::placeholders::_1, std::placeholders::_2)(1, 2);</span><br><span class="line">	std::bind(output, std::placeholders::_2, std::placeholders::_1)(1, 2);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式有如下优点：</p>
<ul>
<li>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，有更好的可读性和可维护性。</li>
<li>简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。</li>
<li>在需要的时间和地点实现功能闭包，使程序更灵活。</li>
</ul>
<h3 id="lambda表达式的概念和基本用法"><a href="#lambda表达式的概念和基本用法" class="headerlink" title="lambda表达式的概念和基本用法"></a>lambda表达式的概念和基本用法</h3><p>lambda表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。 lambda表达式的语法形式可简单归纳如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] (params) opt -&gt; ret &#123; body; &#125;</span><br></pre></td></tr></table></figure><br>其中：capture是捕获列表； params是参数表；opt是函数选项；ret是返回值类型；body是函数体。一个完整的lambda表达式看起来像这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto f = [](int a)-&gt; int &#123; return a + 1; &#125;;</span><br><span class="line">std::cout &lt;&lt; f(1) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><br>输出：<code>2</code>。可以看到，上面通过一行代码定义了一个小小的功能闭包，用来将输入加1并返回。</p>
<p>在C++11中，lambda表达式的返回值是通过前面介绍的返回值后置语法来定义的。其实很多时候，lambda表达式的返回值是非常明显的，比如上例。因此，C++中允许省略lambda表达式的返回值定义：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f= [] (int a) return a + 1; &#125;;</span><br></pre></td></tr></table></figure><br>这样编译器就会根据 return语句自动推导出返回值类型。</p>
<p>另外，lambda表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto fl =[]()&#123; return 1; &#125;;</span><br><span class="line">auto f2 = []&#123; return 1; &#125;;</span><br><span class="line">//省略空参数表</span><br></pre></td></tr></table></figure><br>lambda表达式可以通过捕获列表捕获一定范围内的变量：</p>
<ul>
<li>[]不捕获任何变量。</li>
<li>[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li>
<li>[=]捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li>
<li>[=, &amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。</li>
<li>[bar]按值捕获bar变量，同时不捕获其他变量。</li>
<li>[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&amp;或=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">	int i_ = 0;</span><br><span class="line"></span><br><span class="line">	void func(int x, int y) &#123;</span><br><span class="line">		auto x1 = []&#123; return i_; &#125;;          // error，没有捕获外部变量</span><br><span class="line">		auto x2 = [=]&#123; return i_ + x + y; &#125;; // ok，捕获所有外部变量</span><br><span class="line">		auto x3 = [&amp;]&#123; return i_ + x + y; &#125;; // ok，捕获所有外部变量</span><br><span class="line">		auto x4 = [this]&#123; return i_; &#125;;      // ok，捕获this指针</span><br><span class="line">		auto x5 = [this]&#123; return i_ + x + y; &#125;; // error，没有捕获x、y</span><br><span class="line">		auto x6 = [this, x, y]&#123; return i_ + x + y; &#125;; // ok，捕获this指针、x、y</span><br><span class="line">		auto x7 = [this]&#123; return i_ ++; &#125;; 	 // ok，捕获this指针，并修改成员变量。</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a =0, b=1;</span><br><span class="line">auto fl = [] &#123; return a; &#125;; // error，没有捕获外部变量</span><br><span class="line">auto f2 = [&amp;]&#123; return a++; &#125;; // OK，捕获所有外部变量，并对a执行自加运算</span><br><span class="line">auto f3 = [=]&#123; return a;&#125;; //OK，捕获所有外部变量，并返回a</span><br><span class="line">auto f4 = [=]&#123; return a++;&#125;; //error，a是以复制方式捕获的，无法修改</span><br><span class="line">auto f5 = [a]&#123; return a + b;&#125;; //error，没有捕获变量b</span><br><span class="line">auto f6=[a，&amp;b]&#123; return a+(b++);&#125;; //OK，捕获a和b的引用，并对b做自加运算</span><br><span class="line">auto f7=[=，&amp;b]&#123; return a+(b++);&#125;; //OK，捕获所有外部变量和b的引用，并对b做自加运算</span><br></pre></td></tr></table></figure>
<p>一个容易出错的细节是，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">auto f = [=] &#123;return a;&#125;;</span><br><span class="line"></span><br><span class="line">a += 1;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; f() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><br>在这个例子中，lambda表达式按值捕获了所有外部变量，在捕获的一瞬间a的值就被复制到f中了，之后a被修改，但此时f中存储的a的值仍然是捕获时候的值，因此，最终输出结果是0。希望修改这些变量的话，我们需使用引用方式捕获。</p>
<p>按值捕获得到的外部变量值是在lambda表达式定义时的值。此时所有外部变量均被复制了一份存储在lambda表达式变量中。此时虽然修改 lambda表达式中的这些外部变量并不会真正影响到外部，我们却仍然无法修改它们。那么如果希望去修改按值捕获的外部变量应当怎么办呢?这时，需要显式指明lambda表达式为 mutable：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">auto f1 = [=] &#123; return a++; &#125;; // error，修改按值捕获的外部变量</span><br><span class="line">auto f2 = [=]() mutable &#123; return a++; &#125;; // ok</span><br></pre></td></tr></table></figure><br>被mutable修饰的lambda表达式就算没有参数也要写明参数列表。</p>
<p>lambda表达式的类型在C++11中被称为“闭包类型”。它是一个特殊的匿名的非nunion的类类型。因此，我们可以认为它是一个带有 operator()的类，即仿函数。因此，我们可以使用std::function和std::bind来存储和操作lambda表达式。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;int(int)&gt; f1 = [](int a) &#123; return a; &#125;;</span><br><span class="line">std: function&lt;int(void)&gt;f2 = std::bind([](int a) &#123; return a;&#125;, 123);</span><br></pre></td></tr></table></figure><br>另外，对于没有捕获任何变量的lambda表达式，还可以被转换成一个普通的函数指针：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using func_t= int(*)(int);</span><br><span class="line">func_t f = [](int a)&#123; return a; &#125;;</span><br><span class="line">f(123);</span><br></pre></td></tr></table></figure><br>lambda表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终均会变为闭包类型的成员变量。而一个使用了成员变量的类的 operator()，如果能直接被转换为普通的函数指针，那么lambda表达式本身的this指针就丢失掉了。而没有捕获任何外部变量的 lambda表达式则不存在这个问题。</p>
<p>这里也可以很自然地解释为何按值捕获无法修改捕获的外部变量。因为按照C++标准，lambda表达式的operator默认是const的。一个const成员函数是无法修改成员变量的值的。而mutable的作用，就在于取消operator()的const。需要注意的是，没有捕获变量的lambda表达式可以直接转换为函数指针，而捕获变量的lambda表达式则不能转换为函数指针。看看下面的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*Ptr)(int*);</span><br><span class="line">//正确，没有捕获的lambda表达式可以直接转换为函数指针</span><br><span class="line">Ptr p = [](int* p) &#123;delete p;&#125;;</span><br><span class="line">Ptr pl = [&amp;](int* p) &#123;delete p;&#125;;</span><br><span class="line">∥错误，有状态的1 ambda不能直接转换为函数指针</span><br></pre></td></tr></table></figure><br>上面第二行代码能编译通过，而第三行代码不能编译通过，因为第三行的代码捕获了变量，不能直接转换为函数指针</p>
<h2 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组"></a>tuple元组</h2><p>tuple元组是一个固定大小的不同类型值的集合。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;const char*, int&gt; tp = make_tuple(sendPack, nSendSize);</span><br></pre></td></tr></table></figure><br>等价于一个结构体：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">	char* p;</span><br><span class="line">	int len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>还有一种方法也可创建元组：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">int y = 2;</span><br><span class="line">string s = &quot;aa&quot;;</span><br><span class="line">auto tp = std::tie(x, s, y);</span><br></pre></td></tr></table></figure><br>tp的类型是<code>std::tuple&lt;int&amp;, string&amp;, int&amp;&gt;</code></p>
<p>再看看如何获取元组的值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取第一个值</span><br><span class="line">const char* data = tp.get&lt;0&gt;();</span><br><span class="line">//获取第二个值</span><br><span class="line">int len = tp.get&lt;1&gt;();</span><br></pre></td></tr></table></figure><br>还有一种方法也可以获取元组的值，通过std::tie解包tuple<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x, y;</span><br><span class="line">string a;</span><br><span class="line">std::tie(x, a, y) = tp;</span><br></pre></td></tr></table></figure><br>通过tie解包后，tp中3个值会自动赋值给3个变量。解包时，如果只想解某个位置值时，可以用std::ignore占位符来表示不解某个位置的值。比如我们只想解第3个值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::tie(std::ignore, std::ignore, y) = tp;</span><br></pre></td></tr></table></figure><br>还有一个创建右值的引用元组方法： <code>forward_as_tuple</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;int, std::string&gt; m;</span><br><span class="line">m.emplace(std::piecewise_construct, std::forward_as_tuple(10), std::forward_as_tuple (20, &#x27;a));</span><br></pre></td></tr></table></figure><br>它实际上创建了一个类似于<code>std::tuple&lt;int&amp;&amp;，std::string&amp;&amp;&gt;</code>类型的tuple。</p>
<p>我们还可以通过tuple_cat连接多个tuple，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	std::tuple&lt;int, std::string, float&gt; t1(10, &quot;Test&quot;, 3.14);</span><br><span class="line">	int n = 7;</span><br><span class="line">	auto t2 = std::tuple_cat(t1, std::make_pair(&quot;Foo&quot;, &quot;bar&quot;), t1, std::tie(n));</span><br><span class="line">	n = 10;</span><br><span class="line">	print(t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(10, Test, 3.14, Foo, bar, 10, Test, 3.14, 10)</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章主要介绍了通过一些C++11的特性简化代码，使代码更方便、简洁和优雅。首先讨论了自动类型推断的两个关键字auto和decltype，通过这两个关键字可以化繁为简，使我们不仅能方便地声明变量，还能获取复杂表达式的类型，将二者和返回值后置组合起来能解决函数的返回值难以推断的难题。</p>
<p>模板别名和模板默认参数可以使我们更方便地定义模板，将复杂的模板定义用一个简短更可读的名称来表示，既减少了烦琐的编码又提高了代码的可读性。</p>
<p>range-based for循环可以用更简洁的方式去遍历数组和容器，它还可以支持自定义的类型，只要自定义类型满足3个条件即可。</p>
<p>初始化列表和统一的初始化使得初始化对象的方式变得更加简单、直接和统一。</p>
<p>std::function不仅是一个函数语义的包装器，还能绑定任意参数，可以更灵活地实现函数的延迟执行。</p>
<p>lambda表达式能更方便地使用STL算法，就地定义的匿名函数免除了维护一大堆函数对象的烦琐，也提高了程序的可读性。</p>
<p>tuple元组可以作为一个灵活的轻量级的小结构体，可以用来替代简单的结构体，它有一个很好的特点就是能容纳任意类型和任意数量的元素，比普通的容器更灵活，功能也更强大。但是它也有复杂的一面， tuple的解析和应用往往需要模板元的一些技巧，对使用者有一定的要求。</p>
<h1 id="使用C-11改进程序性能"><a href="#使用C-11改进程序性能" class="headerlink" title="使用C++11改进程序性能"></a>使用C++11改进程序性能</h1><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用标记为<code>T &amp;&amp;</code>。</p>
<p>左值是指表达式结束后仍然存在的持久对象，右值是指表达式结束后就不再存在的临时对象。所有的具名变量或对象都是左值，而右值不具名。在C++11中，右值由两个概念构成，一个是将亡值，另一个则是纯右值。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++1l新增的、与右值引用相关的表达式，如将要被移动的对象、T&amp;&amp;函数返回值，std::move返回值。</p>
<p>C+11中所有的值必属于左值、将亡值、纯右值三者之一，将亡值和纯右值都属于右值。区分表达式的左右值属性有一个简便方法：若可对表达式用<code>&amp;</code>符取址，则为左值，否则为右值。比如，简单的赋值语句<code>int i = 0</code>，在这条语句中，i是左值，0是字面量，就是右值。在上面的代码中，i可以被引用，0就不可以了。字面量都是右值。</p>
<h2 id="amp-amp-的特性"><a href="#amp-amp-的特性" class="headerlink" title="&amp;&amp;的特性"></a><code>&amp;&amp;</code>的特性</h2><p>右值引用就是对一个右值进行引用的类型。因为右值不具名，所以我们只能通过引用的方式找到它。<br>无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会直存活下去。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int g_constructCount = 0;</span><br><span class="line">int g_copyConstructCount = 0;</span><br><span class="line">int g_destructCount = 0;</span><br><span class="line">struct A &#123;</span><br><span class="line">	A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;construct: &quot; &lt;&lt; ++g_constructCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(const A&amp; a) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;copy construct: &quot; &lt;&lt; ++g_copyConstructCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;destruct: &quot; &lt;&lt; ++g_destructCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">A getA() &#123;</span><br><span class="line">	return A();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A a = getA();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g++ -fno-elide-constructors -std=c++0x -O0 1.cpp -o 1</span><br><span class="line"></span><br><span class="line">construct: 1</span><br><span class="line">copy construct: 1</span><br><span class="line">destruct: 1</span><br><span class="line">copy construct: 2</span><br><span class="line">destruct: 2</span><br><span class="line">destruct: 3</span><br></pre></td></tr></table></figure><br>在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是getA()函数内部创建的对象返回后构造一个临时对象产生的，一次是在main构造a对象产生的。得如此的destruct是因为临时对象在构造a对象之后就销毁了。修改程序：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A&amp;&amp; a = getA();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出为:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">construct: 1</span><br><span class="line">copy construct: 1</span><br><span class="line">destruct: 1</span><br><span class="line">destruct: 2</span><br></pre></td></tr></table></figure><br>通过右值引用，少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。避免临时对象的拷贝构造和析构，事实上，在C++98/03中，也通过常量左值引用来做性能优化。</p>
<p>实际上<code>T&amp;&amp;</code>并不是一定表示右值，它绑定的类型是未定的，既可能是左值又可能是右值。看看这个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(T&amp;&amp; param);</span><br><span class="line"></span><br><span class="line">f(10);</span><br><span class="line">// 10是右值</span><br><span class="line"></span><br><span class="line">int x = 10;</span><br><span class="line">f(x);</span><br><span class="line">//x是左值</span><br></pre></td></tr></table></figure><br>从这个例子可以看出， param有时是左值，有时是右值，因为在上面的例子中有&amp;&amp;，这表示param实际上是一个未定的引用类型。这个未定的引用类型称为 universal references（可以认为它是一种未定的引用类型），它必须被初始化，它是左值还是右值引用取决于它的初始化，如果&amp;&amp;被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是个右值。</p>
<p>需要注意的是，只有当发生自动类型推断时（如函数模板的类型自动推导，或auto关键字），&amp;&amp;才是一个<br>universal references。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void f(T&amp;&amp; param);</span><br><span class="line">//这里T的类型需要推导，所以&amp;&amp;是一个 universal references</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Test &#123;</span><br><span class="line">	Test(Test&amp;&amp; rhs); // 已经定义了一个特定的类型，没有类型推断</span><br><span class="line">					  // &amp;&amp;是一个右值引用</span><br><span class="line">&#125;;</span><br><span class="line">void f(Test&amp;&amp; param);</span><br><span class="line">// 已经定义了一个确定的类型，没有类型推断，&amp;&amp;是一个右值引用</span><br></pre></td></tr></table></figure></p>
<p>由于存在T&amp;&amp;这种未定的引用类型，当它作为参数时，有可能被一个左值引用或右值引用的参数初始化，这时经过类型推导的T&amp;&amp;类型，相比右值引用（&amp;&amp;）会发生类型的变化，这种变化被称为引用折叠：</p>
<ul>
<li>所有的右值引用叠加到右值引用上还是一个右值引用；</li>
<li>所有的其他引用类型之间的叠加都将变成左值引用。</li>
</ul>
<p>编译器会将已命名的右值引用视为左值，而将未命名的右值引用视作右值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void PrintValue(int&amp; i) &#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;lvalue: &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void PrintValue(int&amp;&amp; i) &#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;rvalue: &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Forward(int&amp;&amp; i) &#123;</span><br><span class="line">	PrintValue(i);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	PrintValue(i);</span><br><span class="line">	PrintValue(1);</span><br><span class="line">	Forward(2);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lvalue: 0</span><br><span class="line">rvalue: 1</span><br><span class="line">lvalue: 2</span><br></pre></td></tr></table></figure><br>Forward函数接收的是一个右值，但是在转发给PrintValue时，因为右值i变成一个命名对象，所以变成了左值。</p>
<p>&amp;&amp;的总结如下：</p>
<ul>
<li>左值和右值是独立于它们的类型的，右值引用类型可能是左值也可能是右值。</li>
<li>auto&amp;&amp;或函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，被称为universal references，它可能是左值引用也可能是右值引用类型，取决于初始化的值类型。</li>
<li>所有的右值引用叠加到右值引用上仍然是一个右值引用，其他引用折叠都为左值引用，当T&amp;&amp;为模板参数时，输入左值，它会变成左值引用；输入右值时变为具名的右值引用。</li>
<li>编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。</li>
</ul>
<p>在编写拷贝函数时，应该提供深拷贝的拷贝构造函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">	A() : m_ptr(new int(0)) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;construct&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(const A&amp; a) : m_ptr(new int(*a.m_ptr)) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;destruct&quot; &lt;&lt; endl;</span><br><span class="line">		delete m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line">A get(bool flag) &#123;</span><br><span class="line">	A a;</span><br><span class="line">	A b;</span><br><span class="line">	if (flag)</span><br><span class="line">		return a;</span><br><span class="line">	else</span><br><span class="line">		return b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A a = get(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct</span><br><span class="line">construct</span><br><span class="line">copy construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br></pre></td></tr></table></figure><br>这样可以保证拷贝的安全性。但这样的开销很大，get函数返回临时变量，然后通过这个临时变量拷贝构造了新的对象b，临时变量在拷贝完之后就销毁了，可以避免这种性能损耗：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">	A() : m_ptr(new int(0)) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;construct&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(const A&amp; a) : m_ptr(new int(*a.m_ptr)) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(A&amp;&amp; a) : : m_ptr(a.m_ptr) &#123;</span><br><span class="line">		a.m_ptr = nullptr;</span><br><span class="line">		cout &lt;&lt; &quot;move construct: &quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;destruct&quot; &lt;&lt; endl;</span><br><span class="line">		delete m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line">A get(bool flag) &#123;</span><br><span class="line">	A a;</span><br><span class="line">	A b;</span><br><span class="line">	if (flag)</span><br><span class="line">		return a;</span><br><span class="line">	else</span><br><span class="line">		return b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A a = get(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct</span><br><span class="line">construct</span><br><span class="line">move construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中没有了拷贝构造，取而代之的是移动构造（ Move Construct）。从移动构造函数的实现中可以看到，它的参数是一个右值引用类型的参数<code>A&amp;&amp;</code>，这里没有深拷贝，只有浅拷贝，这样就避免了对临时对象的深拷贝，提高了性能。这里的<code>A&amp;&amp;</code>用来根据参数是左值还是右值来建立分支，如果是临时值，则会选择移动构造函数。移动构造函数只是将临时对象的资源做了浅拷贝，不需要对其进行深拷贝，从而避免了额外的拷贝，提高性能。也就是所谓的移动语义（move语义），右值引用的一个重要目的是用来支持移动语义的。</p>
<p>移动语义可以将资源（堆、系统对象等）通过浅拷贝方式从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，可以大幅度提高C++应用程序的性能，消除临时对象的维护（创建和销毁）对性能的影响。<br>以代码清单22所示为示例，实现拷贝构造函数和拷贝赋值操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Element &#123;</span><br><span class="line">	Element() &#123;&#125;</span><br><span class="line">	Element(Element&amp;&amp; other) : m_children(std::move(other.m_children)) &#123;&#125;</span><br><span class="line">	Element(const Element&amp; other) : m_children(other.m_children) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">	vector&lt;ptree&gt; m_children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test() &#123;</span><br><span class="line">	Element t1 = Init();</span><br><span class="line">	vector&lt;Element&gt; v;</span><br><span class="line">	v.push_back(t1);</span><br><span class="line">	v.push_back(std::move(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先构造了一个临时对象t1，这个对象中存放了很多对象，数量可能很多，如果直接将这个t1用 push_back插入到vector中，没有右值版本的构造函数时，会引起大量的拷贝，这种拷贝会造成额外的严重的性能损耗。通过定义右值版本的构造函数以及std::move(t1)就可以避免这种额外的拷贝，从而大幅提高性能。</p>
<p>有了右值引用和移动语义，在设计和实现类时，对于需要动态申请大量资源的类，应该设计右值引用的拷贝构造函数和赋值函数，以提高应用程序的效率。需要注意的是，我们般在提供右值引用的构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造。</p>
<h3 id="关于左值和右值的定义"><a href="#关于左值和右值的定义" class="headerlink" title="关于左值和右值的定义"></a>关于左值和右值的定义</h3><p>左值和右值在C中就存在，不过存在感不高，在C++尤其是C++11中这两个概念比较重要，左值就是有名字的变量（对象），可以被赋值，可以在多条语句中使用，而右值呢，就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值。</p>
<p>在 C++11 之前，右值是不能被引用的，最大限度就是用常量引用绑定一个右值，如 :<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int&amp; i = 3;</span><br></pre></td></tr></table></figure><br>在这种情况下，右值不能被修改的。但是实际上右值是可以被修改的，如 :<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T().set().get();</span><br></pre></td></tr></table></figure><br>T 是一个类，set 是一个函数为 T 中的一个变量赋值，get 用来取出这个变量的值。在这句中，T() 生成一个临时对象，就是右值，set() 修改了变量的值，也就修改了这个右值。<br>既然右值可以被修改，那么就可以实现右值引用。右值引用能够方便地解决实际工程中的问题，实现非常有吸引力的解决方案。</p>
<h3 id="右值引用-1"><a href="#右值引用-1" class="headerlink" title="右值引用"></a>右值引用</h3><p>左值的声明符号为”&amp;”， 为了和左值区分，右值的声明符号为”&amp;&amp;”。</p>
<p>给出一个实例程序如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void process_value(int&amp; i) </span><br><span class="line">&#123; </span><br><span class="line">	std::cout &lt;&lt; &quot;LValue processed: &quot; &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void process_value(int&amp;&amp; i) </span><br><span class="line">&#123; </span><br><span class="line">	std::cout &lt;&lt; &quot;RValue processed: &quot; &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">	int a = 0; </span><br><span class="line">	process_value(a);</span><br><span class="line">	process_value(1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wxl@dev:~$ g++ -std=c++11  test.cpp</span><br><span class="line">wxl@dev:~$ ./a.out </span><br><span class="line">LValue processed: 0</span><br><span class="line">RValue processed: 1</span><br></pre></td></tr></table></figure><br>Process_value 函数被重载，分别接受左值和右值。由输出结果可以看出，临时对象是作为右值处理的。</p>
<p>下面涉及到一个问题：<br>x的类型是右值引用，指向一个右值，但x本身是左值还是右值呢？C++11对此做出了区分：</p>
<p>Things that are declared as rvalue reference can be lvalues or rvalues. The distinguishing criterion is: if it has a name, then it is an lvalue. Otherwise, it is an rvalue.</p>
<p>对上面的程序稍作修改就可以印证这个说法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void process_value(int&amp; i) </span><br><span class="line">&#123; </span><br><span class="line">	std::cout &lt;&lt; &quot;LValue processed: &quot; &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void process_value(int&amp;&amp; i) </span><br><span class="line">&#123; </span><br><span class="line">	std::cout &lt;&lt; &quot;RValue processed: &quot;  &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">	int a = 0; </span><br><span class="line">	process_value(a);</span><br><span class="line">	int&amp;&amp; x = 3;</span><br><span class="line">	process_value(x); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wxl@dev:~$ g++ -std=c++11  test.cpp</span><br><span class="line">wxl@dev:~$ ./a.out </span><br><span class="line">LValue processed: 0</span><br><span class="line">LValue processed: 3</span><br></pre></td></tr></table></figure><br>x 是一个右值引用，指向一个右值3，但是由于x是有名字的，所以x在这里被视为一个左值，所以在函数重载的时候选择为第一个函数。</p>
<h3 id="右值引用的意义"><a href="#右值引用的意义" class="headerlink" title="右值引用的意义"></a>右值引用的意义</h3><p>直观意义：为临时变量续命，也就是为右值续命，因为右值在表达式结束后就消亡了，如果想继续使用右值，那就会动用昂贵的拷贝构造函数。（关于这部分，推荐一本书《深入理解C++11》）<br>右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。<br>转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。<br>通过转移语义，临时对象中的资源能够转移其它的对象里。<br>在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。<br>普通的函数和操作符也可以利用右值引用操作符实现转移语义。</p>
<p>转移语义以及转移构造函数和转移复制运算符<br>以一个简单的 string 类为示例，实现拷贝构造函数和拷贝赋值操作符。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class MyString &#123; </span><br><span class="line">private: </span><br><span class="line">	char* _data; </span><br><span class="line">	size_t   _len; </span><br><span class="line">	void _init_data(const char *s) &#123; </span><br><span class="line">	  _data = new char[_len+1]; </span><br><span class="line">	  memcpy(_data, s, _len); </span><br><span class="line">	  _data[_len] = &#x27;\0&#x27;; </span><br><span class="line">	&#125; </span><br><span class="line">public: </span><br><span class="line">	MyString() &#123; </span><br><span class="line">		_data = NULL; </span><br><span class="line">		_len = 0; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	MyString(const char* p) &#123; </span><br><span class="line">		_len = strlen (p); </span><br><span class="line">		_init_data(p); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	MyString(const MyString&amp; str) &#123; </span><br><span class="line">		_len = str._len; </span><br><span class="line">		_init_data(str._data); </span><br><span class="line">		std::cout &lt;&lt; &quot;Copy Constructor is called! source: &quot; &lt;&lt; str._data &lt;&lt; std::endl; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	MyString&amp; operator=(const MyString&amp; str) &#123; </span><br><span class="line">		if (this != &amp;str) &#123; </span><br><span class="line">		 	_len = str._len; </span><br><span class="line">			_init_data(str._data); </span><br><span class="line">		&#125; </span><br><span class="line">		std::cout &lt;&lt; &quot;Copy Assignment is called! source: &quot; &lt;&lt; str._data &lt;&lt; std::endl; </span><br><span class="line">		return *this; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">virtual ~MyString() &#123; </span><br><span class="line">	if (_data) </span><br><span class="line">		free(_data); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int main() &#123; </span><br><span class="line">	MyString a; </span><br><span class="line">	a = MyString(&quot;Hello&quot;); </span><br><span class="line">	std::vector&lt;MyString&gt; vec; </span><br><span class="line">	vec.push_back(MyString(&quot;World&quot;)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy Assignment is called! source: Hello </span><br><span class="line">Copy Constructor is called! source: World</span><br></pre></td></tr></table></figure><br>这个 string 类已经基本满足我们演示的需要。在 main 函数中，实现了调用拷贝构造函数的操作和拷贝赋值操作符的操作。MyString(“Hello”) 和 MyString(“World”) 都是临时对象，也就是右值。虽然它们是临时的，但程序仍然调用了拷贝构造和拷贝赋值，造成了没有意义的资源申请和释放的操作。如果能够直接使用临时对象已经申请的资源，既能节省资源，有能节省资源申请和释放的时间。这正是定义转移语义的目的。</p>
<p>我们先定义转移构造函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> MyString(MyString&amp;&amp; str) &#123; </span><br><span class="line">   std::cout &lt;&lt; &quot;Move Constructor is called! source: &quot; &lt;&lt; str._data &lt;&lt; std::endl; </span><br><span class="line">   _len = str._len; </span><br><span class="line">   _data = str._data; </span><br><span class="line">   str._len = 0; </span><br><span class="line">   str._data = NULL; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有下面几点需要对照代码注意：</p>
<ol>
<li>参数（右值）的符号必须是右值引用符号，即“&amp;&amp;”。</li>
<li>参数（右值）不可以是常量，因为我们需要修改右值。</li>
<li>参数（右值）的资源链接和标记必须修改。否则，右值的析构函数就会释放资源。转移到新对象的资源也就无效了。</li>
</ol>
<p>现在我们定义转移赋值操作符。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> MyString&amp; operator=(MyString&amp;&amp; str) &#123; </span><br><span class="line">   std::cout &lt;&lt; &quot;Move Assignment is called! source: &quot; &lt;&lt; str._data &lt;&lt; std::endl; </span><br><span class="line">   if (this != &amp;str) &#123; </span><br><span class="line">     _len = str._len; </span><br><span class="line">     _data = str._data; </span><br><span class="line">     str._len = 0; </span><br><span class="line">     str._data = NULL; </span><br><span class="line">   &#125; </span><br><span class="line">   return *this; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里需要注意的问题和转移构造函数是一样的。<br>增加了转移构造函数和转移复制操作符后，我们的程序运行结果为 :</p>
<p>由此看出，编译器区分了左值和右值，对右值调用了转移构造函数和转移赋值操作符。节省了资源，提高了程序运行的效率。<br>有了右值引用和转移语义，我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率。</p>
<p>但是这几点总结的不错</p>
<ul>
<li>std::move执行一个无条件的转化到右值。它本身并不移动任何东西；</li>
<li>std::forward把其参数转换为右值，仅仅在那个参数被绑定到一个右值时；</li>
<li>std::move和std::forward在运行时（runtime）都不做任何事。</li>
</ul>
<h2 id="move语义"><a href="#move语义" class="headerlink" title="move语义"></a>move语义</h2><p>std::move将左值转换为右值，从而方便应用移动语义。move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移没有拷贝。</p>
<p>move实际上并不移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用，是我们可以通过右值引用使用该值，以用于移动语义。</p>
<p>仅仅转移资源的所有者，将资源的拥有者改为被赋值者。假设一个临时容器很大，赋值给另一个容器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;std::string&gt; tokens;</span><br><span class="line">std::list&lt;std::string&gt; t = tokens;</span><br><span class="line"></span><br><span class="line">std::list&lt;std::string&gt; tokens;</span><br><span class="line">std::list&lt;std::string&gt; t = std::move(tokens);</span><br></pre></td></tr></table></figure><br>如果不用std::move，拷贝的代价很大，性能较低，使用move几乎没有任何代价，只是转换了资源的所有权，实际上是将左值转换为右值引用，然后应用move语义调用构造函数，就避免了拷贝。</p>
<h2 id="forward和完美转发"><a href="#forward和完美转发" class="headerlink" title="forward和完美转发"></a>forward和完美转发</h2><p>需要一种方法能按照参数原来的类型转发到另一个函数，这种转发被称作<strong>完美转发</strong>，即在函数模板中，完全依照模板的参数的类型（保持参数的左右值特征），将参数传递给函数模板中调用的另一个函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void PrintT(int&amp; t) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrintT(int&amp;&amp; t) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void TestForward(T &amp;&amp; t) &#123;</span><br><span class="line">	PrintT(t);</span><br><span class="line">	PrintT(std::forward&lt;T&gt;(t));</span><br><span class="line">	PrintT(std::move(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	TestForward(1);</span><br><span class="line">	int x = 1;</span><br><span class="line">	TestForward(x);</span><br><span class="line">	TestForward(std::forward&lt;int&gt;(x));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lvalue</span><br><span class="line">rvalue</span><br><span class="line">rvalue</span><br><span class="line">lvalue</span><br><span class="line">lvalue</span><br><span class="line">rvalue</span><br><span class="line">lvalue</span><br><span class="line">rvalue</span><br><span class="line">rvalue</span><br></pre></td></tr></table></figure><br>TestForward(1)时，1是右值，所以未定义的引用类型<code>T&amp;&amp; t</code>被一个右值初始化后变成一个右值引用。但是在TestForward中调用PrintT(t)时，t变成一个左值。调用<code>PrintT(std::forward&lt;T&gt;(t))</code>时，<code>std::forward</code>会按照原来的参数类型转发，所以它还是一个右值。</p>
<p>TestForward(x)未定的引用类型<code>T&amp;&amp; t</code>被一个左值初始化后变成一个左值引用，因此，在调用<code>PrintT(std::forward&lt;T&gt;(t))</code>时它会被转发到<code>PrintT(T&amp; t)</code></p>
<h2 id="emplace-back减少内存拷贝和移动"><a href="#emplace-back减少内存拷贝和移动" class="headerlink" title="emplace_back减少内存拷贝和移动"></a>emplace_back减少内存拷贝和移动</h2><p>emplace_back能就地通过参数构造对象，不需要拷贝或者移动内存，相比push_back能更好地避免内存的拷贝与移动，使容器插入元素的性能得到进一步提升。在大多数情况下应该优先使用emplace_back来代替push_back。</p>
<p>所有的标准库容器（array除外，因为它的长度不可改变，不能插入元素）都增加了类似的方法： emplace、 emplace_hint、 emplace_front、emplace_after和emplace_back。</p>
<p>vector的emplace_back的基本用法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct A &#123;</span><br><span class="line">	int x;</span><br><span class="line">	double y;</span><br><span class="line">	A(int a, double b): x(a), y(b);</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	vector&lt;A&gt; v;</span><br><span class="line">	v.emplace_back(1, 2);</span><br><span class="line">	cout&lt;&lt;v.size()&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出， emplace_back的用法比较简单，直接通过构造函数的参数就可以构造对象。因此，也要求对象有对应的构造函数，如果没有对应的构造函数，编译器会报错。</p>
<p>其他容器相应的 emplace方法也是类似的。<br>相对 push_back而言， emplace_back更具性能优势。</p>
<p>在引入右值引用，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素（临时对象）的时候，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放。这样造成的问题是临时变量申请的资源就浪费。<br>引入了右值引用，转移构造函数（请看这里）后，push_back()右值时就会调用构造函数和转移构造函数。</p>
<h2 id="unordered-container无序容器"><a href="#unordered-container无序容器" class="headerlink" title="unordered container无序容器"></a>unordered container无序容器</h2><p>C++11增加了无序容器 unordered_map/unordered_multimap和unordered_set/unordered_multiset，由于这些容器中的元素是不排序的，因此，比有序容器 map/multimap和set/multiset效率更高。</p>
<p>map和set内部是红黑树，在插入元素时会自动排序，而无序容器内部是散列表（ Hash Table），通过哈希（Hash），而不是排序来快速操作元素，使得效率更高。由于无序容器内部是散列表，因此无序容器的key需要提供hash_value函数，其他用法和map/set的用法是一样的。不过对于自定义的key，需要提供Hash函数和比较函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line"></span><br><span class="line">struct Key &#123;</span><br><span class="line">	std::string first;</span><br><span class="line">	std::string second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct KeyHash &#123;</span><br><span class="line">	std::size_t operator()(const Key&amp; k) const &#123;</span><br><span class="line">		return std::hash&lt;std::string&gt;()(k.first)^(std::hash&lt;std::string&gt;()(k.second) &lt;&lt; 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct keyEqual &#123;</span><br><span class="line">	bool operator()(const Key&amp; lhs, const Key&amp; rhs) const &#123;</span><br><span class="line">		return lhs.first == rhs.first &amp;&amp; lhs.second == rhs.second;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	std::unordered_map&lt;std::string, std::string&gt; m1;</span><br><span class="line"></span><br><span class="line">	std::unordered_map&lt;int, std::string&gt; m2 = &#123;</span><br><span class="line">		&#123;1, &quot;foo&quot;&#125;,</span><br><span class="line">		&#123;2, &quot;bar&quot;&#125;,</span><br><span class="line">		&#123;3, &quot;baz&quot;&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	std::unordered_map&lt;int, std::string&gt; m3 = m2;</span><br><span class="line">	std::unordered_map&lt;int, std::string&gt; m4 = std::move(m2);</span><br><span class="line"></span><br><span class="line">	std::vector&lt;std::pair&lt;std::bitset&lt;8&gt;, int&gt;&gt; v = &#123; &#123;0x12, 1&#125;, &#123;0x01, -1&#125; &#125;;</span><br><span class="line">	std::unordered_map&lt;std::bitset&lt;8&gt;, double&gt; m5(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">	// constructor for a custom type</span><br><span class="line">	std::unordered_map&lt;Key, std::string, KeyHash, KeyEqual&gt; m6 = &#123;</span><br><span class="line">		&#123; &#123;&quot;john&quot;, &quot;doe&quot;&#125;, &quot;example&quot;&#125;,</span><br><span class="line">		&#123; &#123;&quot;mary&quot;, &quot;Sue&quot;&#125;, &quot;another&quot;&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="使用C-11消除重复，提高代码质量"><a href="#使用C-11消除重复，提高代码质量" class="headerlink" title="使用C++11消除重复，提高代码质量"></a>使用C++11消除重复，提高代码质量</h1><h2 id="type-traits——类型萃取"><a href="#type-traits——类型萃取" class="headerlink" title="type_traits——类型萃取"></a>type_traits——类型萃取</h2><p>type_traits的类型判断功能在编译期就可以检查出是否是正确的类型，以便能编写更安全的代码。</p>
<h3 id="基本的type-traits"><a href="#基本的type-traits" class="headerlink" title="基本的type_traits"></a>基本的type_traits</h3><p>在之前的C++中，在类中定义编译期常量的方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct GetLeftSize &#123;</span><br><span class="line">	static const int value = 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在C++11中定义编译期常量，无需自己定义<code>static const int</code>或<code>enum</code>类型，只需要从<code>std::integral_constant</code>派生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct GetLeftSize : std::integral_constant&lt;int, 1&gt; &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>将编译期常量包装为一个类型的type_trait——integral_constant：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, T v&gt;</span><br><span class="line">struct integral_constant &#123;</span><br><span class="line">	static const T value = v;</span><br><span class="line">	typedef T value_type;</span><br><span class="line">	typedef integral_constant&lt;T, v&gt; type;</span><br><span class="line">	operator value_type() &#123; return value;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见的用法是从integral_constant派生从而可以通过继承得到value</p>
<p>派生的type_traits可用于检查模板类型是否为某种类型，通过这些trait可以获取编译期检查的bool值结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">struct is_integral;</span><br></pre></td></tr></table></figure>
<p>这是用来检查T是否为bool、char、int、long、long long等整型类型的，派生于std::integral_constant，因此可以通过std::is_xxx::value是否为true判断模板类型是否为目标类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;int&quot; &lt;&lt; std::is_const&lt;int&gt;::value &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;const int&quot; &lt;&lt; std::is_const&lt;const int&gt;::value &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;const int*&quot; &lt;&lt; std::is_const&lt;const int*&gt;::value &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;const int&amp;&quot; &lt;&lt; std::is_const&lt;const int&amp;&gt;::value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++提供了判断类型之间的关系的traits：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class U&gt;</span><br><span class="line">struct is_same        // 判断两个类型是否相同 </span><br><span class="line">struct is_base_of     // 判断base类型是否是derived类型的积累</span><br><span class="line">struct is_convertible // 判断模板参数类型是否能转换</span><br></pre></td></tr></table></figure>
<p>C++提供了类型转换traits，包括对const的修改，引用的移除和添加，指针和数组的修改等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">struct remove_const</span><br><span class="line">strcut add_const</span><br></pre></td></tr></table></figure>
<p>有时需要添加引用类型，比如从智能指针中获取对象的引用时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; </span><br><span class="line">struct Construct &#123;</span><br><span class="line">	typedef typename std::remove_reference&lt;T&gt;::type U;</span><br><span class="line">	Construct() : m_ptr(new U) &#123; &#125;</span><br><span class="line"></span><br><span class="line">	typename std::add_lvalue_reference&lt;U&gt;:: type</span><br><span class="line">	Get() const &#123; return *m_ptr.get(); &#125;</span><br><span class="line">private:</span><br><span class="line">	std::unique_ptr&lt;U&gt; m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	Construct&lt;int&gt; c;</span><br><span class="line">	int a = c.Get();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移除引用和cv符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; </span><br><span class="line">typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type*</span><br><span class="line">Create() &#123;</span><br><span class="line">	typedef typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type U;</span><br><span class="line">	return new U();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先移除引用，再移除cv符，最终获得原始类型，这样可以解决问题，但是较为繁琐，用<code>decay</code>来简化代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; </span><br><span class="line">typename std::decay&lt;T&gt;::type* Create() &#123;</span><br><span class="line">	typedef typename std::decay&lt;T&gt;::type U;</span><br><span class="line">	return new U();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于普通类型来说，<code>std::decay</code>是移除引用和cv符，大大简化了我们的书写。除了普通类型之外，<code>std::decay</code>还可以用于数组和函数，具体的转换规则如下：</p>
<ul>
<li>先移除T类型的引用，得到类型U，U定义为<code>remove_reference&lt;T&gt;::type</code></li>
<li>如果<code>is_array&lt;U&gt;::value</code>为true，修改类型type为<code>remove_extent&lt;U&gt;::type*</code></li>
<li>否则，如果<code>is_function&lt;U&gt;::value</code>为true，修改类型type为<code>add_pointer&lt;U&gt;::type</code></li>
<li>否则，修改类型type为<code>remove_cv&lt;U&gt;::type</code></li>
</ul>
<p>根据上面的规则，再对照用法示例，就能清楚地理解<code>std::decay</code>的含义了。下面是<code>std::decay</code>的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef std::decay&lt;int&gt;::type A; // int</span><br><span class="line">typedef std::decay&lt;int&amp;&gt;::type B; // int</span><br><span class="line">typedef std::decay&lt;int&amp;&amp;&gt;::type C; // int</span><br><span class="line">typedef std::decay&lt;const int&amp;&gt;::type D; // int</span><br><span class="line">typedef std::decay&lt;int[2]&gt;::type E; //int*</span><br><span class="line">typedef std::decay&lt;int(int)&gt;::type F: //int(*)(int)</span><br></pre></td></tr></table></figure>
<p>由于std::decay对于函数来说是添加指针，利用这一点，我们可以将函数变成函数指针类型，从而将函数指针变量保存起来，以便在后面延迟执行。</p>
<p><code>std::conditional</code>在编译期根据一个判断式选择两个类型中的一个，和条件表达式的语义类似，类似一个三元表达式。它的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt; bool B, class T, class F&gt;</span><br><span class="line">struct conditional</span><br></pre></td></tr></table></figure>
<p><code>std::conditional</code>模板参数中，如果B为true，则conditional::type为T，否则为F。<br><code>std::conditional</code>测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef std::conditional&lt;true, int, float&gt;::type A; // int</span><br><span class="line">typedef std::conditional&lt;false, int, float&gt;::type B, // float</span><br><span class="line"></span><br><span class="line">typedef std::conditional&lt;std::is_integral&lt;A&gt;::value, long, int&gt;:: type C; // long</span><br><span class="line">typedef std::conditional&lt;std::is_integral&lt;B&gt;::value, long, int&gt;:: type D; // int</span><br></pre></td></tr></table></figure>
<p>比较两个类型，输出较大的那个类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef std::conditional&lt;(sizeof(long long) &gt; sizeof(long double)), long long, long double&gt;::type max_size_t;</span><br><span class="line">cout&lt;&lt;typeid(max_size_t).name()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>将会输出： <code>long double</code><br>我们可以通过编译期的判断式来选择类型，这给我们动态选择类型提供了很大的灵活性，在后面经常和其他的C++11特性配合起来使用，是比较常用的特性之一。</p>
<p>有时要获取函数的返回类型是一件比较困难的事情，C++提供了std::result_of，用来在编译期获取一个可调用对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::result_of&lt;A(int)&gt;::type i = 4;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(std::declval&lt;A&gt;()(std::declval&lt;int&gt;()));</span><br></pre></td></tr></table></figure>
<p><code>std::result_of</code>原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class F, class ... ArgTypes&gt;</span><br><span class="line">class result_of&lt;F(ArgTypes...)&gt;;</span><br></pre></td></tr></table></figure>
<p>第一个模板参数为可调用对象的类型，第二个模板参数为参数的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int fn(int) &#123; return int(); &#125;</span><br><span class="line">typedef int(&amp;fn_ref)(int);</span><br><span class="line">typedef int(*fn_ref)(int);</span><br><span class="line">struct fn_class &#123; int operator()(int i) &#123;return i;&#125; &#125;;</span><br><span class="line"></span><br><span class="line">int main &#123;</span><br><span class="line">	typedef std::result_of&lt;decltype(fn)&amp;(int)&gt;:: type A; // int</span><br><span class="line">	typedef std::result_of&lt;fn_ref(int)&gt;::type B;         // int</span><br><span class="line">	typedef std::result_of&lt;fn_ptr(int)&gt;::type C;         // int</span><br><span class="line">	typedef std::result_of&lt;fn_class(int)&gt;::type D;       // int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::result_of&lt;Fn(ArgTypes...)&gt;</code>要求Fn为一个可调用对象（不能是个函数类型，因为函数类型不是一个可调用对象，因此，下面这种方式是错误的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef std::result_of&lt;decltype(fn)(int)&gt;::type A;</span><br></pre></td></tr></table></figure>
<p>如果要对某个函数使用std::result_of，要先将函数转换为可调用对象。可以通过以下方式来获取函数返回类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef std::result_of&lt;decltype(fn)&amp;(int)&gt;::type A;</span><br><span class="line">typedef std::result_of&lt;decltype(fn)*(int)&gt;::type B;</span><br><span class="line">typedef std::result_of&lt;typename std::decay&lt;decltype(fn)&gt;::type(int)&gt;::type C;</span><br><span class="line">A B C 类型相同</span><br></pre></td></tr></table></figure>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>声明可变参数模板时需要在typename或class后边带上’…’。</p>
<ul>
<li>声明一个参数包，这个参数包中可以包含0到任意个模板参数</li>
<li>在模板定义的右边，可以把参数包展开成一个一个独立的参数</li>
</ul>
<h3 id="可变参数模板函数"><a href="#可变参数模板函数" class="headerlink" title="可变参数模板函数"></a>可变参数模板函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ... T&gt;</span><br><span class="line">void f(T... args) &#123;</span><br><span class="line">	cout &lt;&lt; sizeof...(args) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">f(); // 0</span><br><span class="line">f(1, 2); // 2</span><br><span class="line">f(1, 2.5, &quot;&quot;); // 3</span><br></pre></td></tr></table></figure>
<p>如果要用参数包中的参数，则一定要将参数包展开，有两种展开参数包的方法，一种是递归的模板函数展开，一种是通过逗号表达式和初始化列表方式展开。</p>
<p>通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//递归终止函数</span><br><span class="line">void print() &#123;</span><br><span class="line">	cout &lt;&lt; &quot;Empty&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//展开函数</span><br><span class="line">template &lt;class T, class... Args&gt;</span><br><span class="line">void print(T head, Args... rest) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;parameter &quot; &lt;&lt; head &lt;&lt; endl;</span><br><span class="line">	print(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	print(1,2,3,4);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parameter 1</span><br><span class="line">parameter 2</span><br><span class="line">parameter 3</span><br><span class="line">parameter 4</span><br><span class="line">Empty</span><br></pre></td></tr></table></figure>
<p>递归终止函数可以写成如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename T1, typename T2&gt;</span><br><span class="line">void print(T t, T1 t1) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; t1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T, typename T1, typename T2&gt;</span><br><span class="line">void print(T t, T1 t1, T2 t2) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; t1 &lt;&lt; &quot; &quot; &lt;&lt; t2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt; </span><br><span class="line">void printarg(T t) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;class ...Args&gt;</span><br><span class="line">void expand(Args... args) &#123;</span><br><span class="line">	int arr[] = &#123; (printarg(args), 0)...&#125;</span><br><span class="line">&#125;</span><br><span class="line">expand(1,2,3,4);</span><br></pre></td></tr></table></figure>
<p>这种就地展开参数包的方式关键是<strong>逗号表达式</strong>，它会按顺序执行逗号前边的表达式。<code>expand()</code>函数中的<code>(printarg(args), 0)</code>，先执行<code>printarg(args)</code>，再得到逗号表达式的结果0。同时用到了初始化列表，通过初始化列表来初始化一个变长数组。<code>&#123;(printargs(args), 0)...&#125;</code>将会展开成<code>((printargs(arg1), 0), (printargs(arg2), 0), (printargs(arg3), 0), etc...)</code>，最终会创建一个所有元素为0的数组<code>int arr[sizeof(Args)]</code>，会先执行表达式前面的printarg打印出参数。</p>
<h3 id="可变参数模板类"><a href="#可变参数模板类" class="headerlink" title="可变参数模板类"></a>可变参数模板类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class... Types&gt;</span><br><span class="line">class tuple;</span><br></pre></td></tr></table></figure>
<p>这个可变参数模板类可以携带任意类型任意个数的模板参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;int&gt; tp1 = std::make_tuple(1);</span><br><span class="line">std::tuple&lt;int, double&gt; tp2 = std::make_tuple(1, 2.5);</span><br><span class="line">std::tuple&lt;int, double, string&gt; tp3 = std::make_tuple(1, 2.5, &quot;hello&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="模板递归和特化方式展开参数包"><a href="#模板递归和特化方式展开参数包" class="headerlink" title="模板递归和特化方式展开参数包"></a>模板递归和特化方式展开参数包</h4><p>可变参数模板类的展开一般需要定义2 ~ 3个类，包含类声明和特化的模板类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename... nums&gt; struct Sum;// 变长模板的声明</span><br><span class="line"></span><br><span class="line">template &lt;typename First, typename... last&gt;</span><br><span class="line">struct Sum&lt;first, last...&gt; // 变长模板类</span><br><span class="line">&#123;</span><br><span class="line">    static const long val = first * Sum&lt;last...&gt;::val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct Sum&lt;&gt; // 边界条件</span><br><span class="line">&#123;</span><br><span class="line">    static const long val = 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个基本的可变参数模板应用类由三部分组成：</p>
<p>第一个是<code>template&lt;typename... Args&gt; struct Sum</code>，这是前向声明，声明这个类是可变参数模板类</p>
<p>第二个是类的定义，它定义了一个部分展开的可变参数模板类，告诉编译器如何递归展开参数包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename First, typename... last&gt; </span><br><span class="line">struct Sum&lt;first, last...&gt; // 变长模板类</span><br><span class="line">&#123;</span><br><span class="line">    static const long val = first * Sum&lt;last...&gt;::val;</span><br><span class="line">&#125;;`</span><br></pre></td></tr></table></figure>
<p>第三个是特化的递归终止类，这是在展开到0个参数时终止，也可以在展开到2个时终止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">struct Sum&lt;&gt; // 边界条件</span><br><span class="line">&#123;</span><br><span class="line">    static const long val = 1;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename First, typename Last&gt;</span><br><span class="line">struct sum&lt;First, Last&gt; &#123;</span><br><span class="line">	static const long val = First * Last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可变参数消除重复代码"><a href="#可变参数消除重复代码" class="headerlink" title="可变参数消除重复代码"></a>可变参数消除重复代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Print(T t) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T, typename ... Args&gt;</span><br><span class="line">void Print(T t) &#123;</span><br><span class="line">	cout &lt;&lt; t ;</span><br><span class="line">	Print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过可变模板参数可以消除重复，同时去掉参数个数限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename ... Args&gt;</span><br><span class="line">T* Instance(Args... args) &#123;</span><br><span class="line">	return new T(args...);</span><br><span class="line">&#125;</span><br><span class="line">A* pa = Instance&lt;A&gt;(1);</span><br><span class="line">B* pb = Instance&lt;B&gt;(1, 2);</span><br></pre></td></tr></table></figure>
<p>上边的代码<code>T* Instance(Args... args)</code>的Args是值拷贝的，存在性能损耗，可以通过完美转发来消除损耗：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename ... Args&gt;</span><br><span class="line">T* Instance(Args&amp;&amp;... args) &#123;</span><br><span class="line">	return new T(std::forward&lt;Args &gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可变参数模板和type-traits的综合应用"><a href="#可变参数模板和type-traits的综合应用" class="headerlink" title="可变参数模板和type_traits的综合应用"></a>可变参数模板和type_traits的综合应用</h2><h3 id="optional的实现"><a href="#optional的实现" class="headerlink" title="optional的实现"></a>optional的实现</h3><p>C+14中将包含一个<code>std::optional</code>类，它的功能及用法和boost的optional类似。<code>optional&lt;T&gt;</code>内部存储空间可能存储了T类型的值也可能没有存储T类型的值，只有当optional被T初始化之后，这个optional才是有效的，否则是无效的，它实现了未初始化的概念。</p>
<p>optional可以用于解决函数返回无效值的问题，有时根据某个条件去查找对象时，如果查找不到对象，就会返回一个无效值，这不表明函数执行失败，而是表明函数正确执行了，只是结果不是有用的值。这时就可以返回一个未初始化的optional对象，判断这个optional对象是否是有效对象需要判断它是否被初始化，如果没有被初始化就表明这个值是无效的。boost中的optional就实现了这种未初始化的概念。 boost.optional的基本用法很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">optional&lt;int&gt; op;</span><br><span class="line">if(op)</span><br><span class="line">	cout &lt;&lt; *op &lt;&lt; endl;</span><br><span class="line">optional&lt;int&gt; op1 = 1;</span><br><span class="line">if(op1)</span><br><span class="line">	cout &lt;&lt; *op1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>第一个op由于没有被初始化，所以它是一个无效值，将不会输出打印信息；第二个op被初始化为1，所以它是一个有效值，将会输出1。optional经常用于函数返回值。</p>
<p>由于optional<T>需要容纳T的值，所以需要一个缓冲区保存这个T，这个缓冲区不可用普通的char数组，需要使用内存对齐的缓冲区<code>std::aligned_storage</code>，原型如下，其中，Len表示所存储类型的size，Align表示该类型内存对齐的大小，通过sizeof(T)可以获取T的size，通过alignof(T)可以获取T内存对齐的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt; std::size_t Len, std::size_t Align = /* default-alignment */ &gt;</span><br><span class="line">struct aligned_storage;</span><br><span class="line"></span><br><span class="line">std::aligned_storage&lt;sizeof(T), alignof(T)&gt; 或</span><br><span class="line">std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意拷贝和赋值时，内部状态和缓冲区销毁的问题。内部状态用来标示该optional是否被初始化，当已经初始化时需要先将缓冲区清理一下。需要增加右值版本优化效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Optional</span><br><span class="line">&#123;</span><br><span class="line">    using data_t = typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type;</span><br><span class="line">public:</span><br><span class="line">    Optional() : m_hasInit(false) &#123;&#125;</span><br><span class="line">    Optional(const T&amp; v)</span><br><span class="line">    &#123;</span><br><span class="line">        Create(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional(T&amp;&amp; v) : m_hasInit(false)</span><br><span class="line">    &#123;</span><br><span class="line">        Create(std::move(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Optional()</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional(const Optional&amp; other) : m_hasInit(false)</span><br><span class="line">    &#123;</span><br><span class="line">        if (other.IsInit())</span><br><span class="line">            Assign(other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional(Optional&amp;&amp; other) : m_hasInit(false)</span><br><span class="line">    &#123;</span><br><span class="line">        if (other.IsInit())</span><br><span class="line">        &#123;</span><br><span class="line">            Assign(std::move(other));</span><br><span class="line">            other.Destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional&amp; operator=(Optional &amp;&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        Assign(std::move(other));</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional&amp; operator=(const Optional &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        Assign(other);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;class... Args&gt;</span><br><span class="line">    void emplace(Args&amp;&amp;... args)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy();</span><br><span class="line">        Create(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool IsInit() const &#123; return m_hasInit; &#125;</span><br><span class="line"></span><br><span class="line">    explicit operator bool() const &#123; return IsInit(); &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; operator*()</span><br><span class="line">    &#123;</span><br><span class="line">        return *((T*) (&amp;m_data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T const&amp; operator*() const</span><br><span class="line">    &#123;</span><br><span class="line">        if (IsInit())</span><br><span class="line">        &#123;</span><br><span class="line">            return *((T*) (&amp;m_data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw std::exception(&quot;is not init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator == (const Optional&lt;T&gt;&amp; rhs) const</span><br><span class="line">    &#123;</span><br><span class="line">        return (!bool(*this)) != (!rhs) ? false : (!bool(*this) ? true : (*(*this)) == (*rhs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator &lt; (const Optional&lt;T&gt;&amp; rhs) const</span><br><span class="line">    &#123;</span><br><span class="line">        return !rhs ? false : (!bool(*this) ? true : (*(*this) &lt; (*rhs)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator != (const Optional&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        return !(*this == (rhs));</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    template&lt;class... Args&gt;</span><br><span class="line">    void Create(Args&amp;&amp;... args)</span><br><span class="line">    &#123;</span><br><span class="line">        new (&amp;m_data) T(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        m_hasInit = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Destroy()</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_hasInit)</span><br><span class="line">        &#123;</span><br><span class="line">            m_hasInit = false;</span><br><span class="line">            ((T*) (&amp;m_data))-&gt;~T();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Assign(const Optional&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        if (other.IsInit()) &#123;</span><br><span class="line">            Copy(other.m_data);</span><br><span class="line">            m_hasInit = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            Destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Assign(Optional&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        if (other.IsInit()) &#123;</span><br><span class="line">            Move(std::move(other.m_data));</span><br><span class="line">            m_hasInit = true;</span><br><span class="line">            other.Destroy();</span><br><span class="line">        &#125; </span><br><span class="line">        else &#123;</span><br><span class="line">            Destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Move(data_t&amp;&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy();</span><br><span class="line">        new (&amp;m_data) T(std::move(*((T*)(&amp;val))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Copy(const data_t&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy();</span><br><span class="line">        new (&amp;m_data) T(*((T*) (&amp;val)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    bool m_hasInit;</span><br><span class="line">    data_t m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="惰性求值类lazy的实现"><a href="#惰性求值类lazy的实现" class="headerlink" title="惰性求值类lazy的实现"></a>惰性求值类lazy的实现</h3><p>惰性求值（Lazy Evaluation）是相对常用的编程语言中的及早求值而言的另一种求值策略，也被称之为按需调用（call-by-need），或者叫延时求值。简单地讲，惰性求值是在谋求一种平衡，一种在节省开发与节约计算资源的一种平衡策略。一个庞大的类实例可能一次只有一小部分会发生更改，如果把其他的东西都盲目的添加进来，就会额外造成不少的计算资源的浪费。因此，在开发时，开发人员不仅要知道高级语言的语法糖，也需要一定的底层 AST 的实现原理，这样能够避免很多不必要的运行时开销。所以，这里的惰性，更多的是指等待的意思：一旦等到了明确的调用命令，自然会把运行结果正确送出。</p>
<p>借助lambda表达式，将函数封装到lambda表达式中，而不是马上求值，是在需要的时候再调用lambda表达式来求值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct Lazy &#123;</span><br><span class="line">	Lazy() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	template &lt;typename Func, typename ... Args&gt;</span><br><span class="line">	Lazy(Func&amp; f, Args &amp;&amp; ... args) &#123;</span><br><span class="line">		m_func = [&amp;f, &amp;args...]&#123; return f(args...); &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T&amp; value() &#123;</span><br><span class="line">		if (!m_value.IsInit()) &#123;</span><br><span class="line">			m_vlaue = m_func(); </span><br><span class="line">		&#125;</span><br><span class="line">		return *m_value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool IsValueCreated() const &#123;</span><br><span class="line">		return m_value.IsInit();</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	std::function&lt;T()&gt; m_func;</span><br><span class="line">	Optional&lt;T&gt; m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class Func, typename... Args&gt;</span><br><span class="line">Lazy&lt;typename std::result_of&lt;Func(Args...)&gt;::type&gt; lazy(Func &amp;&amp; fun, Args &amp;&amp; ... args) &#123;</span><br><span class="line">	return Lazy&lt;typename std::result_of&lt;Func(Args...)&gt;::type&gt;(std::forward&lt;Func&gt;(fun), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lazy类用到了std::function和optional，其中std::function用来保存传入的函数，不马上执行，而是延迟到后面需要使用值的时候才执行，函数的返回值被放到一个optional对象中，如果不用optional，则需要增加一个标识符来标识是否已经求值，而使用optional对象可以直接知道对象是否已经求值，用起来更简便。</p>
<p>通过optional对象我们就知道是否已经求值，当发现已经求值时直接返回之前计算的结果，起到缓存的作用。<br>代码清单后一部分定义了一个辅助函数，该辅助函数的作用是更方便地使用Lazy，因为Lazy类需要一个模板参数来表示返回值类型，而type_traits中的std::result_of可以推断出函数的返回值类型，所以这个辅助函数结合std::result_of就无须显式声明返回类型了，同时可变参数模板消除了重复的模板定义和模板参数的限制，可以满足所有的函数入参，在使用时只需要传入一个函数和其参数就能实现延迟计算。</p>
<p>Lazy内部的std::function<T()>用来保存传入的函数，以便在后面延迟执行，这个function定义是没有参数的，因为可以通过一个lambda表达式去初始化一个function，而lambda表达式可以捕获参数，所以无须定义function的参数，当然还可以通过std::bind绑定器来将N元的入参函数变为sdtd::function<T()>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct BigObject &#123;</span><br><span class="line">	BigObject() &#123; cout &lt;&lt; &quot;lazy load big object&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct MyStruct &#123;</span><br><span class="line">	MyStruct() &#123;</span><br><span class="line">		m_obj = lazy( [] &#123; return std::make_shared&lt;BigObject&gt;(); &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	void Load() &#123;</span><br><span class="line">		m_obj.Value();</span><br><span class="line">	&#125;</span><br><span class="line">	Lazy&lt; std::shared_ptr&lt;BigObject&gt; &gt; m_obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Foo(int x) &#123; return x * 2; &#125;</span><br><span class="line"></span><br><span class="line">void TestLazy() &#123;</span><br><span class="line">	int y = 4;</span><br><span class="line">	auto lazyer1 = lazy(Foo, y);</span><br><span class="line">	cout &lt;&lt; lazyer1.Value() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Lazy&lt;int&gt; lazyer2 = lazy([] &#123;return 12;&#125;);</span><br><span class="line">	cout &lt;&lt; lazyer2.Value() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	std::function &lt;int(int)&gt; f = [](int x) &#123; return x + 3; &#125;;</span><br><span class="line">	auto lazyer3 = lazy(f, 3);</span><br><span class="line">	cout &lt;&lt; lazyer3.Value() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	MyStruct t;</span><br><span class="line">	t.Load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">12</span><br><span class="line">6</span><br><span class="line">lazy load big object</span><br></pre></td></tr></table></figure>
<h3 id="dll帮助类"><a href="#dll帮助类" class="headerlink" title="dll帮助类"></a>dll帮助类</h3><p>如果要按照</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ret CallDllFunc(const string&amp; funName, T arg)</span><br></pre></td></tr></table></figure>
<p>这种方式调用，则首先要把函数指针转换成一种函数对象或泛型函数，这样可以用std::function做这件事。</p>
<p>封装GetProcAddress，将函数指针转换成std::function</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">std::function&lt;T&gt; GetFunction(const string&amp; funName) &#123;</span><br><span class="line">	FARPROC funAddress = GetProcAddress(m_hMod, funcName.c_str());</span><br><span class="line">	return std::function&lt;T&gt;((T*)funAddress)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T是std::function的模板参数，即函数类型的签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto fmax = GetFunction&lt;int(int, int)&gt;(&quot;Max&quot;);</span><br><span class="line">auto fget = GetFunction&lt;int(int)&gt;(&quot;Get&quot;);</span><br></pre></td></tr></table></figure>
<p>解决函数返回值与入参不一样的问题，通过result_of和可变参数模板解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename ... Args&gt;</span><br><span class="line">typename std::result_of&lt;std::function&lt;T&gt;(Args...)&gt;::type ExecuteFunc(const string&amp; funcName, Args&amp;&amp; ... args) &#123;</span><br><span class="line">	return GetFunction&lt;T&gt;(funcName)(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto max = ExecuteFunc&lt;int(int, int)&gt;(&quot;Max&quot;, 5, 8);</span><br><span class="line">auto ret = ExecuteFunc&lt;int(int)&gt;(&quot;Get&quot;, 5);</span><br></pre></td></tr></table></figure>
<h3 id="lambda链式调用"><a href="#lambda链式调用" class="headerlink" title="lambda链式调用"></a>lambda链式调用</h3><p>将多个函数按照前一个的输出作为下一个输入串起来再推迟到某个时刻计算。</p>
<p>首先创建一个task对象，然后连续调用then的函数，只需要保证前一个函数的输出为后一个的输入即可。最后在需要的时候调用计算结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Task;</span><br><span class="line"></span><br><span class="line">template&lt;typename R, typename...Args&gt;</span><br><span class="line">class Task&lt;R(Args...)&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Task(std::function&lt;R(Args...)&gt;&amp;&amp; f) : m_fn(std::move(f)) &#123;&#125;</span><br><span class="line">    Task(std::function&lt;R(Args...)&gt;&amp; f) : m_fn(f) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    R run(Args&amp;&amp;... args)</span><br><span class="line">    &#123;</span><br><span class="line">        return m_fn(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;typename F&gt;</span><br><span class="line">    auto Then(F&amp;&amp; f) -&gt; Task&lt;typename std::result_of&lt;F(R)&gt;::type(Args...)&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        using return_type = typename std::result_of&lt;F(R)&gt;::type;</span><br><span class="line"></span><br><span class="line">        auto func = std::move(m_fn);</span><br><span class="line">        return Task&lt;return_type(Args...)&gt;([func, &amp;f](Args&amp;&amp;...args) &#123;</span><br><span class="line">            return f(func(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::function&lt;R(Args...)&gt; m_fn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void tesk()</span><br><span class="line">&#123;</span><br><span class="line">    Task&lt;int(int)&gt; task([](int i) &#123;return i; &#125;);</span><br><span class="line"></span><br><span class="line">    auto f = task</span><br><span class="line">        .Then([](int i) &#123;return i + 1; &#125;)</span><br><span class="line">        .Then([](int i) &#123;return i + 2; &#125;)</span><br><span class="line">        .Then([](int i) &#123;return i + 3; &#125;);</span><br><span class="line"></span><br><span class="line">    auto result = f.run(0);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;run task result:&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run task result:6</span><br></pre></td></tr></table></figure>
<h3 id="any类的实现"><a href="#any类的实现" class="headerlink" title="any类的实现"></a>any类的实现</h3><p>boost库有一个Any类，是一个特殊的只能容纳一个元素的容器，他可以擦除类型，给任何类型赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boost::any a = 1;</span><br><span class="line">boost::any a = 1.1;</span><br><span class="line"></span><br><span class="line">std::vector&lt;boost::any&gt; v;</span><br><span class="line">v.push_back(a);</span><br><span class="line">v.push_back(b);</span><br><span class="line"></span><br><span class="line">int va = boost::any_cast&lt;int&gt;(a); // 1</span><br><span class="line">double vb = boost::any_cast&lt;double&gt;(b); // 2.5</span><br></pre></td></tr></table></figure>
<p>vector中可以存放int和double，因为any擦除了int和double的类型，当通过any_cast<T>取出实际类型时，如果T不是原来的类型，会报错。</p>
<p>any能容纳所有类型的数据，因此，当赋值给any时，需要将值的类型擦除，即以一种通用的方式保存所有类型的数据。这里可以通过继承去擦除类型，基类是不含模板参数的，派生类中才有模板参数，这个模板参数类型正是赋值的类型。在赋值时，将创建的派生类对象赋值给基类指针，基类的派生类携带了数据类型，基类只是原始数据的一个占位符，通过多态的隐式转换擦除了原始数据类型，因此，任何数据类型都可以赋值给它，从而实现能存放所有类型数据的目标。当取数据时需要向下转换成派生类型来获取原始数据，当转换失败时打印详情，并抛出异常。由于向any赋值时需要创建一个派生类对象，所以还需要管理该对象的生命周期，这里用unique_ptr智能指针去管理对象的生命周期。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">class Any</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //默认构造函数</span><br><span class="line">    Any() : m_tpIndex(std::type_index(typeid(void))) &#123;&#125;</span><br><span class="line">    Any(const Any&amp; other) : m_ptr(other.clone()), m_tpIndex(other.m_tpIndex) &#123;&#125;</span><br><span class="line">    Any(Any&amp;&amp; other) : m_ptr(std::move(other.m_ptr)), m_tpIndex(std::move(other.m_tpIndex)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //通用的右值构造</span><br><span class="line">    template&lt;typename T, class = typename std::enable_if&lt;!std::is_same&lt;typename std::decay&lt;T&gt;::type, Any&gt;::value, T&gt;::type&gt;</span><br><span class="line">    Any(T &amp;&amp; value) : m_ptr(new Derived&lt;typename std::decay&lt;T&gt;::type&gt;(std::forward&lt;T&gt;(value)))</span><br><span class="line">        , m_tpIndex(std::type_index(typeid(std::decay&lt;T&gt;::type))) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //判断是否为空</span><br><span class="line">    bool isNull() &#123;</span><br><span class="line">        return !bool(m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //是否可以类型转换</span><br><span class="line">    template&lt;class T&gt;</span><br><span class="line">    bool is() const &#123;</span><br><span class="line">        return m_tpIndex == std::type_index(typeid(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //类型转换</span><br><span class="line">    template&lt;class T&gt;</span><br><span class="line">    T&amp; cast()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!is&lt;T&gt;())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;can not cast &quot; &lt;&lt; typeid(T).name() &lt;&lt; &quot; to &quot;</span><br><span class="line">                &lt;&lt; m_tpIndex.name() &lt;&lt; endl;</span><br><span class="line">            throw bad_cast();</span><br><span class="line">        &#125;</span><br><span class="line">        auto ptr = dynamic_cast&lt;Derived&lt;T&gt;*&gt;(m_ptr.get());</span><br><span class="line">        return ptr-&gt;m_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Any&amp; operator=(const Any&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_ptr == other.m_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line">        m_ptr = other.clone();</span><br><span class="line">        m_tpIndex = other.m_tpIndex;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    struct Base;</span><br><span class="line">    using BasePtr = std::unique_ptr&lt;Base&gt;;</span><br><span class="line"></span><br><span class="line">    //非模板擦除类型</span><br><span class="line">    struct Base</span><br><span class="line">    &#123;</span><br><span class="line">        virtual BasePtr clone() const = 0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    struct Derived : public Base</span><br><span class="line">    &#123;</span><br><span class="line">        template&lt;typename...Args&gt;</span><br><span class="line">        Derived(Args&amp;&amp;...args) : m_value(std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        BasePtr clone() const</span><br><span class="line">        &#123;</span><br><span class="line">            return BasePtr(new Derived(m_value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T m_value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //拷贝使用</span><br><span class="line">    BasePtr clone() const</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return m_ptr-&gt;clone();</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BasePtr         m_ptr;      //具体数据</span><br><span class="line">    std::type_index m_tpIndex;  //数据类型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="function-traits"><a href="#function-traits" class="headerlink" title="function_traits"></a>function_traits</h3><p>可以获得普通函数、函数指针、std::function、函数对象和成员函数的函数类型、返回类型、参数个数和参数的具体类型。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int func(int a, string b);</span><br><span class="line"></span><br><span class="line">//获取函数类型</span><br><span class="line">function_traits&lt;decltype(func)&gt;::function_type; //int __cdecl(int, string)</span><br><span class="line"></span><br><span class="line">//获取函数返回值</span><br><span class="line">function_traits&lt;decltype(func)&gt;::return_type; //int</span><br><span class="line"></span><br><span class="line">//获取函数的参数个数</span><br><span class="line">function_traits&lt;decltype(func)&gt;::arity; //2</span><br><span class="line"></span><br><span class="line">//获取函数第一个入参类型</span><br><span class="line">function_traits&lt;decltype(func)&gt;::arg_type&lt;0&gt;; //int</span><br><span class="line"></span><br><span class="line">//获取函数第二个入参类型</span><br><span class="line">function_traits&lt;decltype(func)&gt;::arg_type&lt;1&gt;; //string</span><br></pre></td></tr></table></figure>
<p>通过function_traits可以很方便地获取所有函数语义类型丰富的信息，对于实际开发很有用。</p>
<h4 id="实现-function-traits的关键技术"><a href="#实现-function-traits的关键技术" class="headerlink" title="实现 function_traits的关键技术"></a>实现 function_traits的关键技术</h4><p>实现function_traits关键是要通过模板特化和可变参数模板来获取函数类型和返回类型。<br>先定义一个基本的function_traits的模板类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct function traits</span><br></pre></td></tr></table></figure>
<p>再通过特化，将返回类型和可变参数模板作为模板参数，就可以获取函数类型、函数返回值和参数的个数了。基本的特化版本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Ret, typename... Args&gt;</span><br><span class="line">struct function_traits&lt;Ret(Args...)&gt; </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	enum &#123; arity = sizeof...(Args) &#125;;</span><br><span class="line">	typedef Ret function_type(Args...);</span><br><span class="line">	typedef Ret return_type;</span><br><span class="line">	using stl_function_type = std::function&lt;function_type&gt;;</span><br><span class="line">	typedef Ret(*pointer)(Args...);</span><br><span class="line"></span><br><span class="line">	template&lt;size_t I&gt;</span><br><span class="line">	struct args &#123;</span><br><span class="line">		using type = typename std::tuple_element&lt;I, std::tuple&lt;Args...&gt;&gt;::type;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="variant的实现"><a href="#variant的实现" class="headerlink" title="variant的实现"></a>variant的实现</h3><p>variant类似于union，它能代表定义的多种类型，允许将不同类型的值赋给它。它的具体类型是在初始化赋值时确定。boost中的variant的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef variant&lt;int,char, double&gt; vt;</span><br><span class="line">vt v = 1;</span><br><span class="line">v = &#x27;2&#x27;;</span><br><span class="line">v = 12.32;</span><br></pre></td></tr></table></figure>
<p>用variant一个好处是可以擦除类型，不同类型的值都统一成一个variant，虽然这个variant只能存放已定义的类型，但这在很多时候已经够用了。 取值的时候，通过get<T>(v)来获取真实值。然而，当T类型与v的类型不匹配时，会抛出一个bad_cast的异常来。boost的variant抛出的异常往往没有更多的信息，不知道到底是哪个类型转换失败，导致发生异常调试时很不方便。因此，就考虑用c++11去实现一个vairiant, 这个variant可以很容易知道取值时，是什么类型转换失败了。</p>
<h4 id="打造variant需要解决的问题"><a href="#打造variant需要解决的问题" class="headerlink" title="打造variant需要解决的问题"></a>打造variant需要解决的问题</h4><p>第一，要在内部定义一个char缓冲区。缓冲区用来存放variant的值，这个值是variant定义的多种类型中的某种类型的值，因此，这个缓冲区要足够大，能够存放类型最大（sizeof(Type)）的值才可以，这个缓冲区的大小还必须在编译期计算出来。因此需要首先要解决的是variant值存放的缓冲区定义的问题。同时注意内存对齐，使用<code>std::aligned_storage</code>作为variant值存放的缓冲区。</p>
<p>第二，要解决赋值的问题。将值赋给vairiant时，需要将该值的类型ID记录下来，以便在后面根据类型取值。将值保存到内部缓冲区时，还需要用palcement new在缓冲区创建对象。另外，还要解决一个问题，就是赋值时需要检查variant中已定义的类型中是否含有该类型，如果没有则编译不通过，以保证赋值是合法的。</p>
<p>variant的赋值函数要做两件事：第一是从原来的variant中取出缓冲区中的对象；第二是通过缓冲区中取出的对象构造出当前variant中的对象。赋值函数的左值和右值的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Variant(Variant&lt;Types...&gt;&amp;&amp; old) : m_typeIndex(old.m_typeIndex) &#123;</span><br><span class="line">	Helper_t::move(old.m_typeIndex, &amp;old.m_data, &amp;m_data);</span><br><span class="line">&#125;</span><br><span class="line">Variant(const Variant&lt;Types...&gt;&amp; old) : m_typeIndex(old.m_typeIndex) &#123;</span><br><span class="line">	Helper_t::copy(old.m_typeIndex, &amp;old.m_data, &amp;m_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三，解决取值的问题，通过类型取值时，要判断类型是否匹配，如果不匹配，将详情打印出来，方便调试。</p>
<h4 id="打造variant的关键技术："><a href="#打造variant的关键技术：" class="headerlink" title="打造variant的关键技术："></a>打造variant的关键技术：</h4><p>找出最大的typesize。第一个问题中需要解决的问题是如何找出多种类型中，size最大的那个类型的size。看看如何从多种类型中找出最大类型的size。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename... Args&gt;</span><br><span class="line">struct MaxType : std::integral_constant&lt;int,</span><br><span class="line">(sizeof(T)&gt;MaxType&lt;Args...&gt;::value ? sizeof(T) : MaxType&lt;Args...&gt;::value) &gt; </span><br><span class="line"></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct MaxType&lt;T&gt; : std::integral_constant&lt;int, sizeof(T) &gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>通过这个MaxType就可以在编译期获取类型中最大的maxsize了：<code>MaxType&lt;Types...&gt;::value</code>。</p>
<p>这里通过继承和递归方式来展开参数包，在展开参数包的过程中将第一个参数的size和后面一个参数的size做比较，获取较大的那个size，直到比较完所有的参数，从而获得所有类型中最大的size，比较的过程和冒泡排序的过程类似。内存对齐的缓冲区aligned_storage需要两个模版参数，第一个是缓冲区大小，第二个是内存对齐的大小。 variant中的aligned_storage中的缓冲区大小就是最大类型的sice，我们已经找出，下一步是找出最大的内存对齐大小。我们可以在MaxType的基础上来获取MaxAligin。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... Args&gt;</span><br><span class="line">struct MaxAlign : std::integral_constant&lt;int, IntegreMax&lt;std::alignment_of&lt;Args&gt;::value...&gt;::value&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">	data_size = MaxType&lt;sizeof(Types)...&gt;::value;</span><br><span class="line">	align_size = MaxAlign&lt;Types...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line">using data_t = typename std::aligned_storage&lt;data_size, align_size&gt;::type;</span><br></pre></td></tr></table></figure>
<h4 id="类型检查和缓冲区中创建对象"><a href="#类型检查和缓冲区中创建对象" class="headerlink" title="类型检查和缓冲区中创建对象"></a>类型检查和缓冲区中创建对象</h4><p>第二个问题中需要解决两个问题，1.检查赋值的类型是否在已定义的类型中；2.在缓冲区中创建对象及析构；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt; typename T, typename... List &gt;</span><br><span class="line">struct Contains : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line">template &lt; typename T, typename Head, typename... Rest &gt;</span><br><span class="line">struct Contains&lt;T, Head, Rest...&gt;</span><br><span class="line">    : std::conditional&lt; std::is_same&lt;T, Head&gt;::value, std::true_type, Contains&lt;T, Rest...&gt;&gt;::type&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template &lt; typename T &gt;</span><br><span class="line">struct Contains&lt;T&gt; : std::false_type&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>通过bool值Contains<T, Types>::vaule就可以判断是否含有某种类型。</p>
<p>再看看如何在缓冲区中创建对象。</p>
<p>通过placement new在该缓冲区上创建对象，<code>new(data) T(value);</code>，其中data表示一个char缓冲区，T表示某种类型。在缓冲区上创建的对象还必须通过<code>~T</code>去析构，因此还需要一个析构vairiant的帮助类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename... Args&gt;</span><br><span class="line">struct VariantHelper&lt;T, Args...&gt; &#123;</span><br><span class="line">	inline static void Destroy(type_index id, void * data) &#123;</span><br><span class="line">		if (id == type_index(typeid(T)))</span><br><span class="line">			((T*) (data))-&gt;~T();</span><br><span class="line">		else</span><br><span class="line">			VariantHelper&lt;Args...&gt;::Destroy(id, data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt; struct VariantHelper&lt;&gt;  &#123;</span><br><span class="line">	inline static void Destroy(type_index id, void * data) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="取值问题"><a href="#取值问题" class="headerlink" title="取值问题"></a>取值问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename std::decay&lt;T&gt;::type&amp; Get() &#123;</span><br><span class="line">	using U = typename std::decay&lt;T&gt;::type;</span><br><span class="line">	if (!Is&lt;U&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; typeid(U).name() &lt;&lt; &quot; is not defined. &quot; &lt;&lt; &quot;current type is &quot; &lt;&lt; m_typeIndex.name() &lt;&lt; endl;</span><br><span class="line">		throw std::bad_cast();</span><br><span class="line">	&#125;</span><br><span class="line">	return *(U*) (&amp;m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">int GetIndexOf() &#123;</span><br><span class="line">    return Index&lt;T, Types...&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename F&gt;</span><br><span class="line">void Visit(F&amp;&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">　　using T = typename function_traits&lt;F&gt;::arg&lt;0&gt;::type;</span><br><span class="line">　　if (Is&lt;T&gt;())</span><br><span class="line">　　　　f(Get&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename F, typename... Rest&gt;</span><br><span class="line">void Visit(F&amp;&amp; f, Rest&amp;&amp;... rest)</span><br><span class="line">&#123;</span><br><span class="line">　　using T = typename function_traits&lt;F&gt;::arg&lt;0&gt;::type;</span><br><span class="line">　　if (Is&lt;T&gt;())</span><br><span class="line">　　　　Visit(std::forward&lt;F&gt;(f));</span><br><span class="line">　　else</span><br><span class="line">　　　　Visit(std::forward&lt;Rest&gt;(rest)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void TestVariant()</span><br><span class="line">&#123;</span><br><span class="line">    typedef Variant&lt;int, char, double&gt; cv;</span><br><span class="line">    int x = 10;</span><br><span class="line"></span><br><span class="line">    cv v =x;</span><br><span class="line">    v = 1;</span><br><span class="line">    v = 1.123;</span><br><span class="line">    v = &quot;&quot;;//compile error</span><br><span class="line">    v.Get&lt;int&gt;(); //1</span><br><span class="line">    v.Get&lt;double&gt;(); //1.23</span><br><span class="line">    v.Get&lt;short&gt;(); //exception: short is not defined. current type is int</span><br><span class="line">    v.Is&lt;int&gt;();//true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ScopeGuard"><a href="#ScopeGuard" class="headerlink" title="ScopeGuard"></a>ScopeGuard</h3><p>ScopeGuard的作用是确保资源面对异常时总能被成功释放，就算没有正常返回。惯用法让我们在构造函数里获取资源，当因为异常或者正常作用域结束，那么在析构函数里释放资源。总是能释放资源。如果没有异常抛出则正常结束，只是有异常发生或者没有正常退出时释放资源。</p>
<p>通过局部变量析构函数来管理资源，根据是否正常退出来确定是否需要清理资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename F&gt;</span><br><span class="line">class ScopeGuard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit ScopeGuard( F &amp;&amp; f) : m_func(std::move(f)), m_dismiss(false)&#123;&#125;</span><br><span class="line">    explicit ScopeGuard(const F&amp; f) : m_func(f), m_dismiss(false)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~ScopeGuard() &#123;</span><br><span class="line">        if (!m_dismiss &amp;&amp; m_func != nullptr)</span><br><span class="line">            m_func();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScopeGuard(ScopeGuard &amp;&amp; rhs) : m_func(std::move(rhs.m_func)), m_dismiss(rhs.m_dismiss) &#123;rhs.Dismiss();&#125;</span><br><span class="line"></span><br><span class="line">    void Dismiss() &#123;</span><br><span class="line">        m_dismiss = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    F m_func;</span><br><span class="line">    bool m_dismiss;</span><br><span class="line"></span><br><span class="line">    ScopeGuard();</span><br><span class="line">    ScopeGuard(const ScopeGuard&amp;);</span><br><span class="line">    ScopeGuard&amp; operator=(const ScopeGuard&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename F&gt;</span><br><span class="line">ScopeGuard&lt;typename std::decay&lt;F&gt;::type&gt; MakeGuard(F &amp;&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">　　return ScopeGuard&lt;typename std::decay&lt;F&gt;::type&gt;(std::forward&lt;F&gt;(f));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="tuple-helper"><a href="#tuple-helper" class="headerlink" title="tuple_helper"></a>tuple_helper</h3><p><code>std::tuple</code>作为一个泛化的<code>std::pair</code>，它的一个独特特性是能容纳任意个数任意类型的元素。</p>
<p>tuple还需要一些常用操作，比如打印、遍历、根据元素值获取索引位置、反转和应用于函数。</p>
<ul>
<li>打印：由于tuple中的元素是可变参数模板，外面并不知道内部到底是什么数据，有时调试需要知道其具体值，希望能打印出tuple中所有的元素值。</li>
<li>根据元素值获取索引位置： tuple接口中有根据索引位置获取元素的接口，根据元素值来获取索引位置是相反的做法。</li>
<li>获取索引：在运行期根据索引获取索引位置的元素。</li>
<li>遍历：类似于std::for_each算法，可以将函数对象应用于tuple的每个元素。</li>
<li>反转：将tuple中的元素逆序。</li>
<li>应用于函数：将tuple中的元素进行一定的转换，使之成为函数的入参。</li>
</ul>
<h4 id="打印tuple"><a href="#打印tuple" class="headerlink" title="打印tuple"></a>打印tuple</h4><p>tuple不同于数组和集合，不能通过for循环的方式枚举并打印元素值，需要借助可变参数模板的展开方式来打印出元素值。但是 tuple又不同于可变参数模板不能直接通过展开参数包的方式来展开，因为tuple中的元素需要用<code>std::get&lt;T&gt;(tuple)</code>来获取，展开tuple需要带索引参数。有两种方法可以展开并打印tuple，第一种方法是通过模板类的特化和递归调用结合来展开 tuple；另一种方法是通过一个索引序列来展开tuple。</p>
<p>（1）通过模板特化和递归来展开并打印tuple<br>因为tuple内部的元素个数和类型是不固定的，如果要打印tuple中的元素，需要在展开tuple时一一打印，展开并打印tuple的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class Tuple, std::size_t N&gt;</span><br><span class="line">struct TuplerPrinter &#123;</span><br><span class="line">	static void print (const Tuple&amp; t) &#123;</span><br><span class="line">		TuplerPrinter&lt;Tuple, N - 1 &gt;::print(t);</span><br><span class="line">		std::cout &lt;&lt; &quot;, &quot; &lt;&lt; std::get&lt;N - 1&gt;(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class Tuple&gt;</span><br><span class="line">struct TuplerPrinter&lt;Tuple, 1&gt; &#123;</span><br><span class="line">	static void print(const Tuple&amp; t) &#123;</span><br><span class="line">		std::cout &lt;&lt; std::get(0)&lt;t&gt;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class... Args&gt;</span><br><span class="line">void PrintTuple(const std::tuple&lt;Args...&gt;&amp; t) &#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;(&quot;;</span><br><span class="line">	TuplePrinter&lt;decltype(t), sizeof...(Args)&gt;::print(t);</span><br><span class="line">	std::cout &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板类TuplePrinter带有一个模板参数<code>std::size_t N</code>，这个N是用来控制递归调用的，每调用一次，这个N就减1，直到减为1为止。 PrintTuple是一个帮助函数，目的是为了更方便地调用TuplePrinter，因为Tupleprinter需要两个参数，一个是tuple，另一个是tuple的size。tuple的size是可以通过<code>sizeof</code>来获取的，在帮助函数中获取tuple的size并调用TuplePrinter，就可以减少外面调用的入参。测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void TestPrint() &#123;</span><br><span class="line">	std::tuple&lt;int, short, double, char&gt; tp = std: make tuple(1, 2, 3, &#x27;a&#x27;);</span><br><span class="line">	PrintTuple(tp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<code>(1, 2, 3, &#39;a&#39;)</code></p>
<p>调用过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tupleprinter&lt;std::tuplecint, short, double, char&gt;, 4&gt;:: print(tp);</span><br><span class="line">TuplePrinter&lt;std::tuple&lt;int, short, double, char&gt;, 3&gt;:: print(tp);</span><br><span class="line">TuplePrintersstd::tuple&lt;int, short, double, char&gt;, 2&gt;:: print(tp);</span><br><span class="line">TuplePrintersstd::tuple&lt;int, short, double, char&gt;, 1&gt;:: print(tp);</span><br></pre></td></tr></table></figure>
<p>当递归终止时，打印第一个元素的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::get&lt;0&gt;(t);</span><br></pre></td></tr></table></figure>
<p>接着返回上一层递归打印第二个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::get&lt;1&gt;(t);</span><br><span class="line">std::cout &lt;&lt; std::get&lt;2&gt;(t);</span><br><span class="line">std::cout &lt;&lt; std::get&lt;3&gt;(t);</span><br></pre></td></tr></table></figure>
<p>（2）根据索引序列展开并打印tuple<br>将tuple变为一个可变参数模板需要一个可变索引序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int...&gt;</span><br><span class="line">struct IndexTuple&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>再通过<code>std::get&lt;IndexTuple&gt;(tuple)...</code>来获取参数序列，从而将tuple转换为可变参数模板<code>Args...</code>。<br>先创建一个索引序列，通过这个索引序列来取tuple中对应位置的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int...&gt;</span><br><span class="line">struct IndexTuple&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int N, int... Indexes&gt;</span><br><span class="line">struct MakeIndexes : MakeIndexes&lt;N-1, N-1, Indexes...&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int... indexes&gt;</span><br><span class="line">struct MakeIndexes&lt;0, indexes...&gt; &#123;</span><br><span class="line">	typedef IndexTuple&lt;indexes...&gt; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在生成一个元素对应的索引位置序列之后，就可以通过<code>std::get</code>来获取tuple中的所有元素并将其变为可变参数模板。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Print(T t) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T, typename... Args&gt;</span><br><span class="line">void Print(T t, Args... args) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">	Print(args...);</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename Tuple, int... Indexes&gt;</span><br><span class="line">void Transform(IndexTuple&lt; Indexes... &gt;&amp; in, Tuple&amp; tp) &#123;</span><br><span class="line">	Print(get&lt;indexes&gt;(tp)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	using Tuple = std::tuple&lt;int, double&gt;;</span><br><span class="line">	Tuple tp = std::make_tuple&lt;1, 2&gt;;</span><br><span class="line">	Transform(MakeIndexes&lt;std::tuple_size&lt;Tuple&gt;::value&gt;::type(), tp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="反转Tuple"><a href="#反转Tuple" class="headerlink" title="反转Tuple"></a>反转Tuple</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int I, int... Indexes, typename T, typename... Types&gt;</span><br><span class="line">struct make_indexes_reverse_impl&lt;I, IndexTuple&lt;Indexes...&gt;, T, Types...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    using type = typename make_indexes_reverse_impl&lt;I-1, IndexTuple&lt;Indexes..., I-1&gt;, Types...&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//递归终止</span><br><span class="line">template&lt;int I, int... Indexes&gt;</span><br><span class="line">struct make_indexes_reverse_impl&lt;I, IndexTuple&lt;Indexes...&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    using type = IndexTuple&lt;Indexes...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//类型萃取</span><br><span class="line">//调用方法如：make_indexes&lt;double, char, int&gt;</span><br><span class="line">template&lt;typename... Types&gt; </span><br><span class="line">struct make_reverse_indexes : make_indexes_reverse_impl&lt;sizeof...(Types), IndexTuple&lt;&gt;, Types...&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class... Args, int... Indexes&gt;</span><br><span class="line">auto reverse_impl(std::tuple&lt;Args...&gt;&amp;&amp; tup, IndexTuple&lt;Indexes...&gt;&amp;&amp;) -&gt;</span><br><span class="line">decltype(std::make_tuple(std::get&lt;Indexes&gt;(std::forward&lt;std::tuple&lt;Args...&gt;&gt;(tup))...))</span><br><span class="line">&#123;</span><br><span class="line">    return std::make_tuple(std::get&lt;Indexes&gt;forward&lt;tuple&lt;Args...&gt;&gt;(tup))...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class... Args&gt;</span><br><span class="line">auto tuple_reverse(std::tuple&lt;Args...&gt;&amp;&amp; tup)-&gt;</span><br><span class="line">decltype(reverse_impl(std::forward&lt;std::tuple&lt;Args...&gt;&gt;(tup),typename make_reverse_indexes&lt;Args...&gt;::type()))</span><br><span class="line">&#123;</span><br><span class="line">    return reverse_impl(std::forward&lt;std::tuple&lt;Args...&gt;&gt;(tup), typename make_reverse_indexes&lt;Args...&gt;::type());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用于函数"><a href="#应用于函数" class="headerlink" title="应用于函数"></a>应用于函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int...&gt;</span><br><span class="line">struct IndexTuple&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int N, int... Indexes&gt;</span><br><span class="line">struct MakeIndexes : MakeIndexes&lt;N-1, N-1, Indexes...&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int... indexes&gt;</span><br><span class="line">struct MakeIndexes&lt;0, indexes...&gt; &#123;</span><br><span class="line">	typedef IndexTuple&lt;indexes...&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename F, typename Tuple, int... Indexes&gt;</span><br><span class="line">auto apply_helper(F&amp;&amp; f, IndexTuple&lt;Indexes...&gt;&amp;&amp; in, Tuple&amp;&amp; tup)-&gt;</span><br><span class="line">decltype(std::forward&lt;F&gt;(f)(std::get&lt;Indexes&gt;(tup)...))</span><br><span class="line">&#123;</span><br><span class="line">    return std::forward&lt;F&gt;(f)(std::get&lt;Indexes&gt;(tup)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestF(int a, double b) &#123;</span><br><span class="line">	cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test() &#123;</span><br><span class="line">	apply_helper(TestF, MakeIndexes&lt;2&gt;::type(), std::make_tuple(1, 2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：3</p>
<h1 id="使用C-11解决内存泄漏的问题"><a href="#使用C-11解决内存泄漏的问题" class="headerlink" title="使用C++11解决内存泄漏的问题"></a>使用C++11解决内存泄漏的问题</h1><p>智能指针可以自动删除分配的内存，是存储指向动态分配（堆）对象指针的累，用于生存期控制，能够确保在离开指针所在作用域时能够自动正确地销毁动态分配的对象，防止内存泄漏。它的一种通用实现技术是<strong>引用计数</strong>，每使用它一次内部的引用计数加一，每析构一次内部的引用计数减一，减为0时，删除所指向的堆内存。</p>
<h2 id="shared-ptr共享的智能指针"><a href="#shared-ptr共享的智能指针" class="headerlink" title="shared_ptr共享的智能指针"></a>shared_ptr共享的智能指针</h2><p><code>shared_ptr</code>使用引用计数，每一个<code>shared_ptr</code>的拷贝都指向同一个内存，在最后一个<code>shared_ptr</code>析构时，内存才被释放。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>通过构造函数、<code>std::make_shared&lt;T&gt;</code>辅助函数和reset方法来初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p(new int(1));</span><br><span class="line">std::shared_ptr&lt;int&gt; p2 = p;</span><br><span class="line">std::shared_ptr&lt;int&gt; ptr;</span><br><span class="line">ptr.reset(new int(1));</span><br></pre></td></tr></table></figure>
<p>优先使用<strong><code>make_shared</code></strong>来构造智能指针。<br>不能将一个原始指针直接赋值给一个智能指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr p ＝ new int(1) ;　　　// 编译报错，不允许直接赋值</span><br></pre></td></tr></table></figure>
<p>通过get方法来返回原始指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; ptr( new int(1) ) ;</span><br><span class="line">int* p = ptr.get() ;</span><br></pre></td></tr></table></figure>
<p>智能指针初始化可以指定删除器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void DeleteIntPtr ( int * p ) &#123;</span><br><span class="line">	delete p ;</span><br><span class="line">&#125;</span><br><span class="line">std::shared_ptr&lt;int&gt; p( new int , DeleteIntPtr ) ;</span><br></pre></td></tr></table></figure>
<p>当p的引用技术为０时，自动调用删除器来释放对象的内存。删除器也可以是一个lambda表达式，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p( new int , [](int * p)&#123;delete p&#125; ) ;</span><br></pre></td></tr></table></figure>
<p>当我们使用shared_ptr管理动态数组时，需要指定删除器，因为<code>std::shared_ptr</code>默认的删除器不能处理数组对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p(new int[10], [](int* p)&#123;delete[] p;&#125;);</span><br></pre></td></tr></table></figure>
<p>或者通过封装一个<code>make_shared_array</code>方法来让shared_ptr支持数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">shared_ptr&lt;T&gt; make_shared_array(size_t size) &#123;</span><br><span class="line">	return shared_ptr&lt;T&gt;(new T[size], default_delete&lt;T[]&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要用一个原始指针初始化多个shared_ptr，以下是错误的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* ptr = new int;</span><br><span class="line">shared_ptr&lt;int&gt; p1(ptr);</span><br><span class="line">shared_ptr&lt;int&gt; p2(ptr);</span><br></pre></td></tr></table></figure>
<p>不要在函数实参中创建shared_ptr，在调用函数之前先定义以及初始化它。</p>
<p>不要将this指针作为shared_ptr返回出来，因为this指针是一个裸指针，这样做可能会重复析构。正确返回this的shared_ptr的做法是：让目标类通过派生<code>std::enable_shared_from_this&lt;A&gt;</code>类，然后使用基类的成员函数<code>shared_from_this</code>来返回this的shared_ptr：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A : public std::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line">	std::shared_ptr&lt;A&gt; GetSelf() &#123;</span><br><span class="line">		return shared_from_this();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要避免循环引用，循环引用会导致内存泄漏。</p>
<h2 id="unique-ptr独占的智能指针"><a href="#unique-ptr独占的智能指针" class="headerlink" title="unique_ptr独占的智能指针"></a><code>unique_ptr</code>独占的智能指针</h2><p><code>unique_ptr</code>是一个独占的智能指针，他不允许其他的智能指针共享其内部的指针，不允许通过赋值将一个unique_ptr赋值给另外一个unique_ptr，虽然不允许复制，但可以通过函数返回给其他的unique_ptr，还可以通过std::move来转移到其他的unique_ptr，这样它本身就不再拥有原来指针的所有权了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;T&gt; my_ptr(new T);</span><br><span class="line">unique_ptr&lt;T&gt; my_other_ptr = std::move(my_ptr);</span><br><span class="line">unique_ptr&lt;T&gt; ptr = my_ptr; // ERROR</span><br></pre></td></tr></table></figure>
<p>可以自己实现一个make_unique，C++尚未提供这个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class... Args&gt; inline</span><br><span class="line">typename enable_if&lt;!is_array&lt;T&gt;::value, unique_ptr&lt;T&gt;&gt;::type</span><br><span class="line">make_unique(Args&amp;&amp; ... args) &#123;</span><br><span class="line">	return unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; inline</span><br><span class="line">typename enable_if&lt;is_array&lt;T&gt;::value &amp;&amp; extent&lt;T&gt;::value==0, unique_ptr&lt;T&gt;&gt;::type</span><br><span class="line">make_unique(size_t size) &#123;</span><br><span class="line">	typedef typename remove_extent&lt;T&gt;::type U;</span><br><span class="line">	return unique_ptr&lt;T&gt;(new U[size]());</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T, class... Args&gt;</span><br><span class="line">typename enable_if&lt;extent&lt;T&gt;::value!=0, void&gt;::type</span><br><span class="line">make_unique(Args&amp;&amp;&amp; ...) = delete;</span><br></pre></td></tr></table></figure>
<p>如果不是数组，则直接创建unique_ptr，如果是数组，则先判断是否为定长数组，如果是定长数组则编译不通过，若为非定常数组，则获取数组中的元素类型，再根据入参size创建动态数组的unique_ptr。</p>
<p>unique_ptr还可指向一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int []&gt; ptr(new int[10]);</span><br><span class="line">ptr[9] = 9;</span><br></pre></td></tr></table></figure>
<p>unique_ptr指定删除器需要确定删除器的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int(1), [](int* p)&#123; delete p; &#125;);</span><br></pre></td></tr></table></figure>
<p>如果lambda表达式没有捕获变量，这样写是对的，因为可以直接转换成函数指针。捕获了变量后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int, std::function&lt;void(int*)&gt;&gt; ptr(new int(1), [&amp;](int* p)&#123; delete p; &#125;);</span><br></pre></td></tr></table></figure>
<p>如果希望只有一个智能指针管理资源或管理数组就用unique_ptr，如果希望多个智能指针管理同一个资源就用shared_ptr。 </p>
<h2 id="weak-ptr弱引用的智能指针"><a href="#weak-ptr弱引用的智能指针" class="headerlink" title="weak_ptr弱引用的智能指针"></a><code>weak_ptr</code>弱引用的智能指针</h2><p>弱引用的智能指针<code>weak_ptr</code>是用来监视<code>shared_ptr</code>的，不会使引用计数加一，它不管理<code>shared_ptr</code>内部的指针，主要是为了监视<code>shared_ptr</code>的生命周期，更像是<code>shared_ptr</code>的一个助手。</p>
<p><code>weak_ptr</code>没有重载运算符<code>*</code>和<code>-&gt;</code>，因为它不共享指针，不能操作资源，主要是为了通过<code>shared_ptr</code>获得资源的监测权，它的构造不会增加引用计数，它的析构不会减少引用计数，纯粹只是作为一个旁观者来监视<code>shared_ptr</code>中管理的资源是否存在。weak_ptr还可以用来返回this指针和解决循环引用的问题。</p>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>通过<code>use_count()</code>获得当前观测资源的引用计数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; sp(new int(10));</span><br><span class="line">weak_ptr&lt;int&gt; wp(sp);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; wp.use_count() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>通过<code>expired()</code>方法判断观测的资源是否已经释放：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; sp(new int(10));</span><br><span class="line">weak_ptr&lt;int&gt; wp(sp);</span><br><span class="line">if (wp.expired())</span><br><span class="line">	cout &lt;&lt; &quot;weak_ptr useless&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>通过lock方法来获取所监视的<code>shared_ptr</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;int&gt; gw;</span><br><span class="line">void f() &#123;</span><br><span class="line">	if (gw.expired()) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;already expired&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		auto spt = gw.lock();</span><br><span class="line">		cout &lt;&lt; *spt &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		auto sp = std::make_shared&lt;int&gt;(43);</span><br><span class="line">		gw = sp;</span><br><span class="line">		f(); // 43</span><br><span class="line">	&#125;</span><br><span class="line">	f(); // already expired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前提到不能直接将this指针返回为<code>shared_ptr</code>，需要通过派生<code>std::enable_shared_from_this</code>类，并通过其方法<code>shared_from_this</code>来返回智能指针，原因是<code>std::enable_shared_from_this</code>类中有一个<code>weak_ptr</code>，这个<code>weak_ptr</code>用来观测this智能指针，调用<code>shared_from_this()</code>方法时，会调用内部这个<code>weak_ptr</code>的<code>lock()</code>方法，将所观测的<code>shared_ptr</code>返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A : public std::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line">	std::shared_ptr&lt;A&gt; Getself() &#123;</span><br><span class="line">		return shared_from_this();</span><br><span class="line">	&#125;</span><br><span class="line">	~A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;A is delete&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;A&gt; spy(newA);</span><br><span class="line">std::shared_ptr&lt;A&gt; p = spy-&gt;Getself();</span><br></pre></td></tr></table></figure>
<h3 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct A;</span><br><span class="line">struct B;</span><br><span class="line">struct A &#123;</span><br><span class="line">	std::shared_ptr&lt;B&gt; bptr;</span><br><span class="line">	~A() &#123; cout &lt;&lt; &quot;A is deleted!&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct B &#123;</span><br><span class="line">	std::shared_ptr&lt;A&gt; aptr;</span><br><span class="line">	~B() &#123; cout &lt;&lt; &quot;B is deleted!&quot; &lt;&lt; endl; &#125; </span><br><span class="line">&#125;</span><br><span class="line">void TestPtr() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::shared_ptr&lt;A&gt; ap(new A);</span><br><span class="line">		std::shared_ptr&lt;B&gt; bp(new B);</span><br><span class="line">		ap-&gt;bptr = bp;</span><br><span class="line">		bp-&gt;aptr = ap;</span><br><span class="line">	&#125; // Objects should be destroyed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，由于循环引用导致ap和bp的引用计数都是2，离开作用域后减为1，不会去删除指针，导致内存泄漏，通过weak_ptr解决这个问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct A;</span><br><span class="line">struct B;</span><br><span class="line">struct A &#123;</span><br><span class="line">	std::shared_ptr&lt;B&gt; bptr;</span><br><span class="line">	~A() &#123; cout &lt;&lt; &quot;A is deleted!&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct B &#123;</span><br><span class="line">	std::weak_ptr&lt;A&gt; aptr; // 改为weak_ptr</span><br><span class="line">	~B() &#123; cout &lt;&lt; &quot;B is deleted!&quot; &lt;&lt; endl; &#125; </span><br><span class="line">&#125;</span><br><span class="line">void TestPtr() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::shared_ptr&lt;A&gt; ap(new A);</span><br><span class="line">		std::shared_ptr&lt;B&gt; bp(new B);</span><br><span class="line">		ap-&gt;bptr = bp;</span><br><span class="line">		bp-&gt;aptr = ap;</span><br><span class="line">	&#125; // Objects should be destroyed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过智能指针管理第三方库分配的内存"><a href="#通过智能指针管理第三方库分配的内存" class="headerlink" title="通过智能指针管理第三方库分配的内存"></a>通过智能指针管理第三方库分配的内存</h2><p>第三方库分配的内存一般需要通过第三方库提供的释放接口才能释放，由于第三方库返回的指针一般都是原始指针，用完之后如果没有调用第三方库的释放接口，就很容易造成内存泄露。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *p = GetHandle()-&gt;Create();</span><br><span class="line">//do something</span><br><span class="line">GetHandle()-&gt;Realease(p);</span><br></pre></td></tr></table></figure>
<p>用智能指针来管理第三方库的内存就比较方便，不用担心中途返回或者发生异常导致无法调用释放接口的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *p = GetHandle()-&gt;Create();</span><br><span class="line">//do something</span><br><span class="line">std::shared_ptr&lt;void&gt; sp(p, [this](void* p) &#123;GetHandle()-&gt;Realease(p); &#125;);</span><br></pre></td></tr></table></figure>
<p>将其提炼成函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;void&gt; Guard(void*p)</span><br><span class="line">&#123;</span><br><span class="line">	 std::shared_ptr&lt;void&gt; sp(p, [this](void* p) &#123;GetHandle()-&gt;Realease(p); &#125;);</span><br><span class="line">	 return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在使用时</span><br><span class="line">void* p = GetHandle()-&gt;Create();</span><br><span class="line">Guard(p); //危险，这句结束后p就被释放了</span><br><span class="line">//do something</span><br></pre></td></tr></table></figure>
<p>执行<code>Guard();</code>这句后，函数返回的是一个右值，没有被存储，用完就把p释放了。</p>
<p>可以用宏的方式来解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define GUARD(p) std::shared_ptr&lt;void&gt; p##p(p, [](void *p)&#123;release(p);&#125;)</span><br><span class="line"></span><br><span class="line">//使用时</span><br><span class="line">void* p = GetHandle()-&gt;Create();</span><br><span class="line">GUARD(p);  //安全</span><br></pre></td></tr></table></figure>
<p>也可以用unique_ptr来管理第三方的内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define GUARD(p) std::unique_ptr&lt;void&gt; p##p(p, [](void *p)&#123;release(p);&#125;)</span><br></pre></td></tr></table></figure>
<p>对于宏中的##，其实也很好理解，就是将##前后的字符串连接起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define GUARD(p) std::shared_ptr&lt;void&gt; p##p(p, [](void *p)&#123;release(p);&#125;)</span><br><span class="line"></span><br><span class="line">//使用时</span><br><span class="line">void* p = GetHandle()-&gt;Create();</span><br><span class="line">GUARD(p);  //安全</span><br><span class="line">//会有一个std::shared_ptr&lt;void&gt; pp的智能指针，不信就进行测试。原因去找刚才的#define中有p##p</span><br><span class="line">std::cout &lt;&lt; pp.use_count() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>为了验证原作者的这些，写一些demo来帮助理解，也有利于更好掌握：<br>创建一个Base类：<br>Base.h文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Base();</span><br><span class="line">	~Base();</span><br><span class="line"></span><br><span class="line">	void print();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Base.cpp文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Base.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">Base::Base()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;Base constructor&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base::~Base()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;Base desctructor&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Base::print()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;print something&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main.cpp中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Base.h&quot;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define GUARD(p) std::shared_ptr&lt;Base&gt; p##p(p, [](Base*p)&#123;release(p);&#125;)</span><br><span class="line"></span><br><span class="line">Base* create()</span><br><span class="line">&#123;</span><br><span class="line">	return new Base();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void release(Base* base)</span><br><span class="line">&#123;</span><br><span class="line">	delete base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;Base&gt; Guard(Base *p)</span><br><span class="line">&#123;</span><br><span class="line">	 std::shared_ptr&lt;Base&gt; sp(p, [](Base*p) &#123;release(p); &#125;);</span><br><span class="line">	 return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		Base* p = create();</span><br><span class="line">		</span><br><span class="line">		std::shared_ptr&lt;Base&gt; sp(p, [](Base*p) &#123;release(p); &#125;);</span><br><span class="line">		//Guard(p);</span><br><span class="line"></span><br><span class="line">		//GUARD(p);</span><br><span class="line">		//std::cout &lt;&lt; &quot;sp.use_count():&quot; &lt;&lt; sp.use_count() &lt;&lt; std::endl;;</span><br><span class="line">		p-&gt;print();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">print something</span><br><span class="line">Base desctructor</span><br></pre></td></tr></table></figure>
<p>【修改一】 当我们对main()中修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		Base* p = create();</span><br><span class="line">		</span><br><span class="line">		//std::shared_ptr&lt;Base&gt; sp(p, [](Base*p) &#123;release(p); &#125;);</span><br><span class="line">		Guard(p);</span><br><span class="line"></span><br><span class="line">		//GUARD(p);</span><br><span class="line">		//std::cout &lt;&lt; &quot;sp.use_count():&quot; &lt;&lt; sp.use_count() &lt;&lt; std::endl;;</span><br><span class="line">		p-&gt;print();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Base desctructor</span><br><span class="line">print something</span><br></pre></td></tr></table></figure>
<p>发现这时候的p被提前释放了，print something已经是在Base类析构之后做的，此时已经出问题了。</p>
<p>【修改二】将main函数进行修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		Base* p = create();</span><br><span class="line">		</span><br><span class="line">		//std::shared_ptr&lt;Base&gt; sp(p, [](Base*p) &#123;release(p); &#125;);</span><br><span class="line">		//Guard(p);</span><br><span class="line"></span><br><span class="line">		GUARD(p);</span><br><span class="line">		std::cout &lt;&lt; &quot;pp.use_count(): &quot; &lt;&lt; pp.use_count() &lt;&lt; std::endl;;</span><br><span class="line">		p-&gt;print();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">pp.use_count(): 1</span><br><span class="line">print something</span><br><span class="line">Base desctructor</span><br></pre></td></tr></table></figure>
<p>果然如我们所想，一切正常。</p>
<h1 id="使用C-11让多线程开发变得简单"><a href="#使用C-11让多线程开发变得简单" class="headerlink" title="使用C++11让多线程开发变得简单"></a>使用C++11让多线程开发变得简单</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>用<code>std::thread</code>创建线程非常简单，只需要提供线程函数或者函数对象即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void func() &#123;</span><br><span class="line">	cout &lt;&lt; &quot;thread test&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	thread t(func);</span><br><span class="line">	t.join();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数func会运行于线程对象t中，join函数会阻塞线程，直到线程函数执行结束，如果线程函数有返回值，返回值被忽略。如果不希望线程被阻塞执行，调用detach将线程和线程对象分离,让线程作为后台线程去执行，当前线程也不会阻塞了。需要注意的是detach()之后就无法再和线程发生联系了，比如detach之后就不能通过join来等待线程执行完，线程何时执行完我们也无法控制了。</p>
<p>线程可以接受任意个数的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void func(int i, double d, const std::string&amp; s) &#123;</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; d &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	std::thread t(func, 1, 2.0, &quot;heoo&quot;);</span><br><span class="line">	t.join();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>std::thread出了作用域后会析构，保证线程函数的生命周期在线程变量的生命周期之内</strong></p>
<p>线程不能复制，但是可以移动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	std::thread t(func);</span><br><span class="line">	std::thread t1(std::move(t));</span><br><span class="line">	t.join(); // error</span><br><span class="line">	t1.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程被移动之后，线程对象t就不再代表任何线程。另外可以通过<code>std::bind</code>和lambda表达式来创建线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	std::thread t(std::bind(func));</span><br><span class="line">	std::thread t1([](int a, double b)&#123;&#125;, 1, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将线程存放到容器中，保证线程对象的生命周期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;thread&gt; g_list;</span><br><span class="line">vector&lt;shared_ptr&lt;thread&gt;&gt; g_list2;</span><br><span class="line"></span><br><span class="line">void CreateThread() &#123;</span><br><span class="line">	thread t(func);</span><br><span class="line">	g_list.push_back(move(t));</span><br><span class="line">	g_list2.push_back(make_shared&lt;thread&gt;(func));</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	CreateThread();</span><br><span class="line">	for (auto&amp; thread : g_list) &#123;</span><br><span class="line">		thread.join();</span><br><span class="line">	&#125;</span><br><span class="line">	for (auto&amp; thread : g_list2) &#123;</span><br><span class="line">		thread-&gt;join();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程可以获取当前线程的ID，还可以获取CPU核心数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	thread t1(func);</span><br><span class="line">    cout &lt;&lt; t1.get_id() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    cout &lt;&lt; t1.get_id() &lt;&lt; endl;//获取当前线程id,0，表示已经执行结束了.</span><br><span class="line">    cout &lt;&lt; std::thread::hardware_concurrency() &lt;&lt; endl;//8核</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>互斥量是一种同步原语，是一种线程同步的手段，用来保护多线程同时访问的共享数据。</p>
<ul>
<li>std::mutex: 独占的互斥量,不能递归使用.</li>
<li>std::timed_mutex: 带超时的独占互斥量,不能递归使用.</li>
<li>std::recursive_mutex: 递归互斥量,不带超时功能.</li>
<li>std::recursive_timed_mutex: 带超时的递归互斥量.</li>
</ul>
<p>这些互斥量的基本接口十分相近，都是通过lock()来阻塞线程，直到获得互斥量的所有权为止。在线程获得互斥量并完成任务后，就必须使用unlock()来解除对互斥量的占用，lock和unlock必须成对出现。try_lock()尝试锁定互斥量，成功返回true，失败返回false，他是非阻塞的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::mutex g_lock;</span><br><span class="line"></span><br><span class="line">void lock_unlock()</span><br><span class="line">&#123;</span><br><span class="line">    //上锁</span><br><span class="line">    g_lock.lock();</span><br><span class="line">    cout &lt;&lt; &quot;in id: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span><br><span class="line">    this_thread::sleep_for(chrono::seconds(1));</span><br><span class="line">    cout &lt;&lt; &quot;out id: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span><br><span class="line">    //解锁</span><br><span class="line">    g_lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用lock_guard可以简化lock/unlock的写法，因为lock_guard在构造时可以自动锁定互斥量，在退出作用域后进行析构时会自动解锁，从而保证了互斥量的正确操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void f_lock_guard()</span><br><span class="line">&#123;</span><br><span class="line">    //lock_guard在构造时会自动锁定互斥量,而在退出作用域后进行析构时就会自动解锁.</span><br><span class="line">    lock_guard&lt;std::mutex&gt; lock(g_lock);</span><br><span class="line">    cout &lt;&lt; &quot;in id: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span><br><span class="line">    this_thread::sleep_for(chrono::seconds(1));</span><br><span class="line">    cout &lt;&lt; &quot;out id: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的独占互斥量<code>std::recursive_mutex</code>允许同一线程多次获得该互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题，来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct Complex &#123;</span><br><span class="line">	std::recursive_mutex mutex;</span><br><span class="line">	int i;</span><br><span class="line">	Complex() : i(0) &#123;&#125;</span><br><span class="line">	void mul(int x) &#123;</span><br><span class="line">		std::lock_guard&lt;std::recursive_mutex&gt; lock(mutex);</span><br><span class="line">		i *= x;</span><br><span class="line">	&#125;</span><br><span class="line">	void div(int x) &#123;</span><br><span class="line">		std::lock_guard&lt;std::recursive_mutex&gt; lock(mutex);</span><br><span class="line">		i /= x;</span><br><span class="line">	&#125;</span><br><span class="line">	void both(int x, int y) &#123;</span><br><span class="line">		std::lock_guard&lt;std::recursive_mutex&gt; lock(mutex);</span><br><span class="line">		// 因为同一线程可以多次获取同一互斥量，不会发生死锁。</span><br><span class="line">		mul(x);</span><br><span class="line">		div(y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽量不要使用递归锁，因为：</p>
<ul>
<li>需要用到递归锁定的多线程互斥处理往往本身就是可以简化的，允许递归互斥很容易放纵复杂逻辑的产生，从而导致一些多线程同步引起的晦涩问题</li>
<li>递归锁比起非递归锁，效率会低一些。</li>
<li>递归锁虽然允许同一个线程多次获得同一个互斥量，可重复获得的最大次数并未具体说明，一旦超过一定次数，再对lock进行调用就会抛出<code>std::system</code>错误。</li>
</ul>
<p>带超时的互斥量<code>std::timed_mutex</code>和<code>std::recursive_timed_mutex</code>。<code>std::timed_mutex</code>是超时的独占锁，<code>std::recursive_timed_mutex</code>是超时的递归锁，主要用在获取锁时增加超时等待功能，因为有时不知道获取锁需要多久，为了不至于一直在等待获取互斥量，就设置一个等待超时时间，在超时后还可以做其他的事情。</p>
<p><code>std::timed_mutex</code>比<code>std::mutex</code>多了两个超时获取锁的接口：<code>try_lock_for</code>和<code>try_lock_until</code>，这两个接口是用来设置获取互斥量的超时时间，使用时可以用一个while循环去不断地获取互斥量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::timed_mutex mutex;</span><br><span class="line">void work() &#123;</span><br><span class="line">	std::chrono::milliseconds timeout(100);</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		if (mutex.try_lock_for(timeout)) &#123;</span><br><span class="line">			std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;: do work with the mutex&quot; &lt;&lt; endl;</span><br><span class="line">			std::chrono::milliseconds sleepDuration(250);</span><br><span class="line">			std::this_thread::sleep_for(sleepDuration);</span><br><span class="line">			mutex.unlock();</span><br><span class="line">			std::this_thread_sleep_for(sleepDuration);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;: do work without the mutex&quot; &lt;&lt; endl;</span><br><span class="line">			std::chrono::milliseconds sleepDuration(100);</span><br><span class="line">			std::this_thread::sleep_for(sleepDuration);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p><code>&lt;condition_variable&gt;</code>头文件主要包含了与条件变量相关的类和函数。相关的类包括<code>std::condition_variable</code>和<code>std::condition_variable_any</code>，还有枚举类型<code>std::cv_status</code>。另外还包括函数<code>std::notify_all_at_thread_exit()</code>。</p>
<p><code>condition_variable</code>配合<code>std::unique_lock&lt;std::mutex&gt;</code>进行wait操作。<code>condition_variable_any</code>，和任意带有lock、unlock语义的mutex搭配使用，比较灵活，但效率比<code>condition_variable</code>差一些。条件变量的使用过程如下：</p>
<ul>
<li>拥有条件变量的线程获取互斥量。</li>
<li>循环检查某个条件，如果条件不满足，则阻塞直到条件满足；如果条件满足，则向下执行。</li>
<li>某个线程满足条件执行完之后调用<code>notify_one</code>或<code>notify_all</code>唤醒一个或者所有的等待线程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; </span><br><span class="line">class SyncQueue &#123;</span><br><span class="line">	bool isFull() const &#123;</span><br><span class="line">		return m_queue.size() == m_maxSize;</span><br><span class="line">	&#125;</span><br><span class="line">	bool isEmpty() const &#123;</span><br><span class="line">		return m_queue.empty();</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	SyncQueue(int maxSize) : m_maxSize(maxSize) &#123;&#125;</span><br><span class="line">	void Put(const T&amp; x) &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">		while(isFull())&#123;</span><br><span class="line">			m_notFull.wait(m_mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		m_queue.push_back(x);</span><br><span class="line">		m_notEmpty.notify_one();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void Take(T&amp; x) &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">		while(isEmpty())&#123;</span><br><span class="line">			m_notEmpty.wait(m_mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		x = m_queue.front();</span><br><span class="line">		m_queue.pop_front();</span><br><span class="line">		m_notFull.notify_one();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool Empty() &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">		return m_queue.empty();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool Full() &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">		return m_queue.size() == m_maxSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size_t Size() &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">		return m_queue.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int Count() &#123;</span><br><span class="line">		return m_queue.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	std::list&lt;T&gt; m_queue;</span><br><span class="line">	std::mutex m_mutex;</span><br><span class="line">	std::condition_variable_any m_notEmpty;</span><br><span class="line">	std::condition_variable_any m_notFull;</span><br><span class="line">	int m_maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个同步队列在没有满的情况下可以插入数据，如果满了，则会调用m_notFull阻塞等待，待消费线程取出数据之后发一个未满的通知，然后前面阻塞的线程就会被唤醒继续往下执行；如果队列为空，就不能取数据，会调用m_notEmpty条件变量阻塞，等待插入数据的线程发出不为空的通知时，才能继续往下执行。以上过程是同步队列的工作过程。</p>
<p>当<code>std::condition_variable</code>对象的某个 wait 函数被调用的时候，它使用<code>std::unique_lock</code>(通过<code>std::mutex</code>) 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的<code>std::condition_variable</code>对象上调用了 notification 函数来唤醒当前线程。</p>
<p><code>std::condition_variable</code>对象通常使用<code>std::unique_lock&lt;std::mutex&gt;</code>来等待，如果需要使用另外的<code>lockable</code>类型，可以使用<code>std::condition_variable_any</code>类，本文后面会讲到<code>std::condition_variable_any</code>的用法。</p>
<p>首先我们来看一个简单的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                // std::cout</span><br><span class="line">#include &lt;thread&gt;                // std::thread</span><br><span class="line">#include &lt;mutex&gt;                // std::mutex, std::unique_lock</span><br><span class="line">#include &lt;condition_variable&gt;    // std::condition_variable</span><br><span class="line"></span><br><span class="line">std::mutex mtx; // 全局互斥锁.</span><br><span class="line">std::condition_variable cv; // 全局条件变量.</span><br><span class="line">bool ready = false; // 全局标志位.</span><br><span class="line"></span><br><span class="line">void do_print_id(int id)</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock &lt;std::mutex&gt; lck(mtx);</span><br><span class="line">    while (!ready) // 如果标志位不为 true, 则等待...</span><br><span class="line">        cv.wait(lck); // 当前线程被阻塞, 当全局标志位变为 true 之后,</span><br><span class="line">    // 线程被唤醒, 继续往下执行打印线程编号id.</span><br><span class="line">    std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void go()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock &lt;std::mutex&gt; lck(mtx);</span><br><span class="line">    ready = true; // 设置全局标志位为 true.</span><br><span class="line">    cv.notify_all(); // 唤醒所有线程.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::thread threads[10];</span><br><span class="line">    // spawn 10 threads:</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">        threads[i] = std::thread(do_print_id, i);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;10 threads ready to race...\n&quot;;</span><br><span class="line">    go(); // go!</span><br><span class="line"></span><br><span class="line">  for (auto &amp; th:threads)</span><br><span class="line">        th.join();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 threads ready to race...</span><br><span class="line">thread 1</span><br><span class="line">thread 0</span><br><span class="line">thread 2</span><br><span class="line">thread 3</span><br><span class="line">thread 4</span><br><span class="line">thread 5</span><br><span class="line">thread 6</span><br><span class="line">thread 7</span><br><span class="line">thread 8</span><br><span class="line">thread 9</span><br></pre></td></tr></table></figure>
<p>好了，对条件变量有了一个基本的了解之后，我们来看看<code>std::condition_variable</code>的各个成员函数。</p>
<p><code>std::condition_variable</code>提供了两种 wait() 函数。当前线程调用 wait() 后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁 lck)，直到另外某个线程调用<code>notify_*</code>唤醒了当前线程。</p>
<p>在线程被阻塞时，该函数会自动调用<code>lck.unlock()</code>释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知(notified，通常是另外某个线程调用<code>notify_*</code>唤醒了当前线程)，wait() 函数也是自动调用<code>lck.lock()</code>，使得 lck 的状态和 wait 函数被调用时相同。</p>
<p>在第二种情况下（即设置了 Predicate），只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞。因此第二种情况类似以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (!pred()) wait(lck);</span><br></pre></td></tr></table></figure>
<p>请看下面例子（参考）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                // std::cout</span><br><span class="line">#include &lt;thread&gt;                // std::thread, std::this_thread::yield</span><br><span class="line">#include &lt;mutex&gt;                // std::mutex, std::unique_lock</span><br><span class="line">#include &lt;condition_variable&gt;    // std::condition_variable</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line">int cargo = 0;</span><br><span class="line">bool shipment_available()</span><br><span class="line">&#123;</span><br><span class="line">    return cargo != 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者线程.</span><br><span class="line">void consume(int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        std::unique_lock &lt;std::mutex&gt; lck(mtx);</span><br><span class="line">        cv.wait(lck, shipment_available);</span><br><span class="line">        std::cout &lt;&lt; cargo &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">        cargo = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::thread consumer_thread(consume, 10); // 消费者线程.</span><br><span class="line"></span><br><span class="line">    // 主线程为生产者线程, 生产 10 个物品.</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        while (shipment_available())</span><br><span class="line">            std::this_thread::yield();</span><br><span class="line">        std::unique_lock &lt;std::mutex&gt; lck(mtx);</span><br><span class="line">        cargo = i + 1;</span><br><span class="line">        cv.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer_thread.join();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">concurrency ) ./ConditionVariable-wait </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>std::condition_variable::wait_for() 介绍</p>
<p>unconditional (1)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Rep, class Period&gt;</span><br><span class="line">  cv_status wait_for (unique_lock&lt;mutex&gt;&amp; lck,</span><br><span class="line">                      const chrono::duration&lt;Rep,Period&gt;&amp; rel_time);</span><br></pre></td></tr></table></figure>
<p>predicate (2)    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Rep, class Period, class Predicate&gt;</span><br><span class="line">       bool wait_for (unique_lock&lt;mutex&gt;&amp; lck,</span><br><span class="line">                      const chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred);</span><br></pre></td></tr></table></figure>
<p>与 std::condition_variable::wait() 类似，不过 wait_for 可以指定一个时间段，在当前线程收到通知或者指定的时间 rel_time 超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，wait_for 返回，剩下的处理步骤和 wait() 类似。</p>
<p>另外，wait_for 的重载版本（predicte(2)）的最后一个参数 pred 表示 wait_for 的预测条件，只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞，因此相当于如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return wait_until (lck, chrono::steady_clock::now() + rel_time, std::move(pred));</span><br></pre></td></tr></table></figure>
<p>请看下面的例子（参考），下面的例子中，主线程等待 th 线程输入一个值，然后将 th 线程从终端接收的值打印出来，在 th 线程接受到值之前，主线程一直等待，每个一秒超时一次，并打印一个 “.”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;           // std::cout</span><br><span class="line">#include &lt;thread&gt;             // std::thread</span><br><span class="line">#include &lt;chrono&gt;             // std::chrono::seconds</span><br><span class="line">#include &lt;mutex&gt;              // std::mutex, std::unique_lock</span><br><span class="line">#include &lt;condition_variable&gt; // std::condition_variable, std::cv_status</span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line">int value;</span><br><span class="line"></span><br><span class="line">void do_read_value()</span><br><span class="line">&#123;</span><br><span class="line">    std::cin &gt;&gt; value;</span><br><span class="line">    cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Please, enter an integer (I&#x27;ll be printing dots): \n&quot;;</span><br><span class="line">    std::thread th(do_read_value);</span><br><span class="line"></span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lck(mtx);</span><br><span class="line">    while (cv.wait_for(lck,std::chrono::seconds(1)) == std::cv_status::timeout) &#123;</span><br><span class="line">        std::cout &lt;&lt; &#x27;.&#x27;;</span><br><span class="line">        std::cout.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; value &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    th.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::condition_variable::wait_until 介绍</p>
<p>unconditional (1)    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Clock, class Duration&gt;</span><br><span class="line">  cv_status wait_until (unique_lock&lt;mutex&gt;&amp; lck,</span><br><span class="line">                        const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time);</span><br></pre></td></tr></table></figure>
<p>predicate (2)    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Clock, class Duration, class Predicate&gt;</span><br><span class="line">       bool wait_until (unique_lock&lt;mutex&gt;&amp; lck,</span><br><span class="line">                        const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time,</span><br><span class="line">                        Predicate pred);</span><br></pre></td></tr></table></figure>
<p>与<code>std::condition_variable::wait_for</code>类似，但是 wait_until 可以指定一个时间点，在当前线程收到通知或者指定的时间点 abs_time 超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，wait_until 返回，剩下的处理步骤和 wait_until() 类似。</p>
<p>另外，wait_until 的重载版本（predicte(2)）的最后一个参数 pred 表示 wait_until 的预测条件，只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞，因此相当于如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (!pred())</span><br><span class="line">  if ( wait_until(lck,abs_time) == cv_status::timeout)</span><br><span class="line">    return pred();</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>
<p>std::condition_variable::notify_one() 介绍<br>唤醒某个等待(wait)线程。如果当前没有等待线程，则该函数什么也不做，如果同时存在多个等待线程，则唤醒某个线程是不确定的(unspecified)。</p>
<p>请看下例（参考）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                // std::cout</span><br><span class="line">#include &lt;thread&gt;                // std::thread</span><br><span class="line">#include &lt;mutex&gt;                // std::mutex, std::unique_lock</span><br><span class="line">#include &lt;condition_variable&gt;    // std::condition_variable</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line">int cargo = 0; // shared value by producers and consumers</span><br><span class="line"></span><br><span class="line">void consumer()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock &lt; std::mutex &gt; lck(mtx);</span><br><span class="line">    while (cargo == 0)</span><br><span class="line">        cv.wait(lck);</span><br><span class="line">    std::cout &lt;&lt; cargo &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    cargo = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void producer(int id)</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock &lt; std::mutex &gt; lck(mtx);</span><br><span class="line">    cargo = id;</span><br><span class="line">    cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::thread consumers[10], producers[10];</span><br><span class="line"></span><br><span class="line">    // spawn 10 consumers and 10 producers:</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        consumers[i] = std::thread(consumer);</span><br><span class="line">        producers[i] = std::thread(producer, i + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // join them back:</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        producers[i].join();</span><br><span class="line">        consumers[i].join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::condition_variable::notify_all() 介绍<br>唤醒所有的等待(wait)线程。如果当前没有等待线程，则该函数什么也不做。请看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                // std::cout</span><br><span class="line">#include &lt;thread&gt;                // std::thread</span><br><span class="line">#include &lt;mutex&gt;                // std::mutex, std::unique_lock</span><br><span class="line">#include &lt;condition_variable&gt;    // std::condition_variable</span><br><span class="line"></span><br><span class="line">std::mutex mtx; // 全局互斥锁.</span><br><span class="line">std::condition_variable cv; // 全局条件变量.</span><br><span class="line">bool ready = false; // 全局标志位.</span><br><span class="line"></span><br><span class="line">void do_print_id(int id)</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock &lt;std::mutex&gt; lck(mtx);</span><br><span class="line">    while (!ready) // 如果标志位不为 true, 则等待...</span><br><span class="line">        cv.wait(lck); // 当前线程被阻塞, 当全局标志位变为 true 之后,</span><br><span class="line">    // 线程被唤醒, 继续往下执行打印线程编号id.</span><br><span class="line">    std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void go()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock &lt;std::mutex&gt; lck(mtx);</span><br><span class="line">    ready = true; // 设置全局标志位为 true.</span><br><span class="line">    cv.notify_all(); // 唤醒所有线程.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::thread threads[10];</span><br><span class="line">    // spawn 10 threads:</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">        threads[i] = std::thread(do_print_id, i);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;10 threads ready to race...\n&quot;;</span><br><span class="line">    go(); // go!</span><br><span class="line"></span><br><span class="line">  for (auto &amp; th:threads)</span><br><span class="line">        th.join();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> std::condition_variable_any 介绍<br>与<code>std::condition_variable</code>类似，只不过<code>std::condition_variable_any</code>的 wait 函数可以接受任何 lockable 参数，而<code>std::condition_variable</code>只能接受<code>std::unique_lock&lt;std::mutex&gt;</code>类型的参数，除此以外，和<code>std::condition_variable</code>几乎完全一样。</p>
<p>std::cv_status 枚举类型介绍</p>
<p><code>cv_status::no_timeout</code>：wait_for 或者 wait_until 没有超时，即在规定的时间段内线程收到了通知。<br><code>cv_status::timeout</code>：wait_for 或者 wait_until 超时。</p>
<p>std::notify_all_at_thread_exit<br>函数原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void notify_all_at_thread_exit (condition_variable&amp; cond, unique_lock&lt;mutex&gt; lck);</span><br></pre></td></tr></table></figure>
<p>当调用该函数的线程退出时，所有在 cond 条件变量上等待的线程都会收到通知。请看下例（参考）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;           // std::cout</span><br><span class="line">#include &lt;thread&gt;             // std::thread</span><br><span class="line">#include &lt;mutex&gt;              // std::mutex, std::unique_lock</span><br><span class="line">#include &lt;condition_variable&gt; // std::condition_variable</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">bool ready = false;</span><br><span class="line"></span><br><span class="line">void print_id (int id) &#123;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lck(mtx);</span><br><span class="line">  while (!ready) cv.wait(lck);</span><br><span class="line">  // ...</span><br><span class="line">  std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void go() &#123;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lck(mtx);</span><br><span class="line">  std::notify_all_at_thread_exit(cv,std::move(lck));</span><br><span class="line">  ready = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::thread threads[10];</span><br><span class="line">  // spawn 10 threads:</span><br><span class="line">  for (int i=0; i&lt;10; ++i)</span><br><span class="line">    threads[i] = std::thread(print_id,i);</span><br><span class="line">  std::cout &lt;&lt; &quot;10 threads ready to race...\n&quot;;</span><br><span class="line"></span><br><span class="line">  std::thread(go).detach();   // go!</span><br><span class="line"></span><br><span class="line">  for (auto&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p>C++11提供了一个原子类型std::atomic<T>，可以使用任意类型作为模板参数，C++11内置了整型的原子变量，可以更方便地使用原子变量，使用原子变量就不需要使用互斥量来保护该变量了，因为对该变量的操作保证其是原子的，是不可中断的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int value;</span><br><span class="line">std::mutex mutex;</span><br><span class="line">void increment() &#123;</span><br><span class="line">	std::lock_guard&lt;std::mutex&gt; lock(mutex);</span><br><span class="line">	++value;</span><br><span class="line">&#125;</span><br><span class="line">void decrement() &#123;</span><br><span class="line">	std::lock_guard&lt;std::mutex&gt; lock(mutex);</span><br><span class="line">	--value;</span><br><span class="line">&#125;</span><br><span class="line">void get() &#123;</span><br><span class="line">	return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以改成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::atmoic&lt;int&gt; value;</span><br><span class="line">void increment() &#123;</span><br><span class="line">	++value;</span><br><span class="line">&#125;</span><br><span class="line">void decrement() &#123;</span><br><span class="line">	--value;</span><br><span class="line">&#125;</span><br><span class="line">void get() &#123;</span><br><span class="line">	return value.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="call-once-once-flag的使用"><a href="#call-once-once-flag的使用" class="headerlink" title="call_once/once_flag的使用"></a>call_once/once_flag的使用</h2><p>为了保证在多线程环境中某个函数仅被调用一次，比如，需要初始化某个对象，而这个对象只能初始化一次时，就可以用std::call_once来保证函数在多线程环境中只被调用一次。使用std::call_once时，需要一个once_flag作为call_one的入参，它的用法比较简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;thread&gt;</span><br><span class="line">#include&lt;mutex&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">std::once_flag flag;</span><br><span class="line"></span><br><span class="line">void do_once()</span><br><span class="line">&#123;</span><br><span class="line">    std::call_once(flag,[]&#123;std::cout&lt;&lt;&quot;Called once&quot;&lt;&lt;endl;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::thread t1(do_once);</span><br><span class="line">    std::thread t2(do_once);</span><br><span class="line">    std::thread t3(do_once);</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Called once</span><br></pre></td></tr></table></figure>
<h2 id="异步操作类"><a href="#异步操作类" class="headerlink" title="异步操作类"></a>异步操作类</h2><p>C++11 提供了异步操作相关的类：</p>
<ul>
<li><code>std::future</code>作为异步结果的传输通道，用于获取线程函数的的返回值；</li>
<li><code>std::promise</code>用于包装一个值，将数据和future绑定起来，方便线程赋值；</li>
<li><code>std::package_task</code>将函数和future绑定起来，以便异步调用。</li>
</ul>
<h3 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a><code>std::future</code></h3><p>thread库提供了future用来访问异步操作的结果，因为一个异步操作的结果不能马上获取，只能在未来某个时候从某个地方获取，这个异步操作的结果是一个未来的期待值，所以被称为future，future提供了获取异步操作结果的通道。可以以同步等待的方式获取结果，可以通过查询future的状态（future_status)来获取异步操作的结果。future_status有如下3种状态：</p>
<ul>
<li>Deferred:异步操作还没开始</li>
<li>Ready:异步操作已经完成</li>
<li>Timeout:异步操作超时</li>
</ul>
<p>我们可以查询future状态，通过它内部的状态可以知道异步任务的执行情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::future_status status；</span><br><span class="line">do&#123;</span><br><span class="line">    status=future.wait_for(std::chrono::seconds(1));</span><br><span class="line">    if(status==std::future_status::deferred)&#123;&#125;</span><br><span class="line">    else if(status==std::future_status::timeout)&#123;&#125;</span><br><span class="line">    else if(status==std::future_status::ready)&#123;&#125;</span><br><span class="line">&#125;while(status!=std::future_status::ready);</span><br></pre></td></tr></table></figure>
<p>获取future结果有三种方式：</p>
<ul>
<li>get： 等待异步操作结束并返回结果</li>
<li>wait：只是等待异步操作完成，没有返回值</li>
<li>wait_for：是超时等待返回结果</li>
</ul>
<h3 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a><code>std::promise</code></h3><p><code>std::promise</code>将数据和future绑定起来，在线程函数中为外面传进来的promise赋值，在线程函数执行完之后就可以通过promise的future获取该值了。取值是间接地通过promise内部提供的future来获取的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;int&gt; pr;</span><br><span class="line">std::thread t([](std::promise&lt;int&gt; &amp;p)&#123;p.set_value_at_thread_exit(9);&#125;,std::ref(pr));</span><br><span class="line">std::future&lt;int&gt; f=pr.get_future();</span><br><span class="line">auto f=f.get();</span><br></pre></td></tr></table></figure>
<h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a><code>std::packaged_task</code></h3><p><code>std::packaged_task</code>包装了一个可调用对象的包装类（如function、lambda expression、bind expression和another function object)，将函数和future绑定起来，以便异步调用，它和std::promise在某种程度上有点像，promise保存了一个共享状态的值，而packaged_task保存的是一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::packaged_task&lt;int()&gt; task([]()&#123;return 7;&#125;);</span><br><span class="line">std::thread t1(std::ref(task));</span><br><span class="line">std::future&lt;int&gt; f1=task.get_future();</span><br><span class="line">auto r1=f1.get();</span><br></pre></td></tr></table></figure>
<h3 id="std-promise、std-packaged-task和std-future三者之间的关系"><a href="#std-promise、std-packaged-task和std-future三者之间的关系" class="headerlink" title="std::promise、std::packaged_task和std::future三者之间的关系"></a><code>std::promise</code>、<code>std::packaged_task</code>和<code>std::future</code>三者之间的关系</h3><p><code>std::future</code>提供了一个访问异步操作结果的机制，它和线程是一个级别的，属于低层次的对象。<code>std::promise</code>和<code>std::packaged_task</code>，它们内部都有future以便访问异步操作结果，<code>std::packaged_task</code>包装的是一个异步操作，而<code>std::promise</code>包装的是一个值，都是为了方便异步操作的返回值。</p>
<p><code>std::promise</code>:需要获取线程中的某个值<br><code>std::packaged_task</code>:需要获取一个异步操作的返回值</p>
<p>future被promise和packaged_task用来作为异步操作或者异步结果的连接通道，用<code>std::future</code>和<code>std::shared_future</code>来获取异步调用的结果。future是不可拷贝的，只能移动，shared_future是可以拷贝的，当需要将future放到容器中则需要用shared_future。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">#include &lt;random&gt;</span><br><span class="line"></span><br><span class="line">namespace parallel</span><br><span class="line">&#123;</span><br><span class="line">  template &lt;class InputIt, class T&gt;</span><br><span class="line">  InputIt find(InputIt first, InputIt last, const T&amp; value)</span><br><span class="line">  &#123;</span><br><span class="line">      /*</span><br><span class="line">      * 计算合适的线程数</span><br><span class="line">      * std::thread::hardware_concurrency()用于返回当前系统支持的并发数</span><br><span class="line">      */</span><br><span class="line">      auto count = std::distance(first, last);</span><br><span class="line">      auto avaThreadNums = std::thread::hardware_concurrency();</span><br><span class="line">      auto perThreadMinNums = 20;</span><br><span class="line">      auto maxThreadNums = ((count + (perThreadMinNums - 1)) &amp; (~(perThreadMinNums - 1))) / perThreadMinNums;</span><br><span class="line">      auto threadNums =</span><br><span class="line">          avaThreadNums == 0 ?</span><br><span class="line">          maxThreadNums :</span><br><span class="line">          std::min(static_cast&lt;int&gt;(maxThreadNums), static_cast&lt;int&gt;(avaThreadNums));</span><br><span class="line">      auto blockSize = count / threadNums;</span><br><span class="line"></span><br><span class="line">      /* 主线程创建std::promise实例，模板参数是返回值类型 */</span><br><span class="line">      std::promise&lt;InputIt&gt; result;</span><br><span class="line">      /* 因为不同线程会并发查找，当一个线程找到后其他线程就可以停止查找了，原子变量done用于标记是否找到 */</span><br><span class="line">      std::atomic&lt;bool&gt; done(false);</span><br><span class="line">      &#123;</span><br><span class="line">          std::vector&lt;std::thread&gt; threads;</span><br><span class="line">          auto front = first;</span><br><span class="line">          for (int i = 0; i &lt; threadNums; ++i)</span><br><span class="line">          &#123;</span><br><span class="line">              auto back = front;</span><br><span class="line">              if (i != threadNums - 1)</span><br><span class="line">                  std::advance(back, blockSize);</span><br><span class="line">              else</span><br><span class="line">                  back = last;</span><br><span class="line">              threads.emplace_back(</span><br><span class="line">                  [front, back, &amp;value, &amp;result, &amp;done]</span><br><span class="line">              &#123;</span><br><span class="line">                  /* 当一个线程找到后所有线程都会退出，通过done标记管理 */</span><br><span class="line">                  for (auto it = front; !done &amp;&amp; it != back; ++it)</span><br><span class="line">                  &#123;</span><br><span class="line">                      if (*it == value)</span><br><span class="line">                      &#123;</span><br><span class="line">                          done.store(true);</span><br><span class="line">                          /* 如果找到，记录找到的值 */</span><br><span class="line">                          result.set_value(it);</span><br><span class="line">                          return;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              );</span><br><span class="line">          &#125;</span><br><span class="line">          /* 回收线程资源 */</span><br><span class="line">          for (auto &amp;th : threads)</span><br><span class="line">              th.join();</span><br><span class="line">      &#125;</span><br><span class="line">      /* 通过std::promise::get_future获得std::future对象，然后调用get获取结果 */</span><br><span class="line">      return done ? result.get_future().get() : last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;int&gt; v(100000000);</span><br><span class="line">  int n = 0;</span><br><span class="line">  std::generate(v.begin(), v.end(), [&amp;n] &#123; return ++n; &#125;);</span><br><span class="line">  auto value = std::random_device()() % 65536;</span><br><span class="line">  auto it1 = parallel::find(v.begin(), v.end(), value);</span><br><span class="line">  auto it2 = std::find(v.begin(), v.end(), value);</span><br><span class="line">  assert(it1 == it2);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int func(int x) &#123; return x + 2; &#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	packaged_task&lt;int(int)&gt; tsk(func);</span><br><span class="line">	future&lt;int&gt; fut = tsk.get_future();</span><br><span class="line"></span><br><span class="line">	thread(move(tsk), 2).detach();</span><br><span class="line"></span><br><span class="line">	int value = fut.get();</span><br><span class="line">	cout &lt;&lt; &quot;The result is &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;shared_future&lt;int&gt;&gt; v;</span><br><span class="line">	auto f = async(launch::async, [](int a, int b)&#123;return a + b;&#125;, 2, 3);</span><br><span class="line">	v.push_back(f);</span><br><span class="line">	cout &lt;&lt; &quot;The shared_future result is &quot; &lt;&lt; v[0].get() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The result is 4</span><br><span class="line">The shared_future result is 5</span><br></pre></td></tr></table></figure>
<h2 id="线程异步操作函数async"><a href="#线程异步操作函数async" class="headerlink" title="线程异步操作函数async"></a>线程异步操作函数async</h2><p><code>std::async</code>比<code>std::promise</code>、<code>std::package_task</code>和<code>std::thread</code>更上层，它可以用来直接创建异步的task，异步任务返回的结果保存在future中，当需要获取线程执行的结果，可以通过future.get()来获取，如果不关注异步任务的结果，只是简单的等待任务执行完成，则调用future.wait()即可。</p>
<p><code>std::async</code>是更高层次的异步操作，使我们不关心线程创建的内部细节，就能方便的获取线程异步执行的结果，还可以指定线程创建策略，更多的时候应该使用 <code>std::async</code>来创建线程，成为异步操作的首选。</p>
<p><code>std::async</code>原型为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::async(std::launch::async | std::launch::deferred,f,args...)</span><br></pre></td></tr></table></figure>
<p>第一个参数为线程的创建策略，第二个为线程函数，其他的为线程函数的参数。</p>
<p>关于创建策略有两种：</p>
<ul>
<li><code>std::launch::async</code>：在调用async就开始创建线程；</li>
<li><code>std::launch::deferred</code>：延迟加载的方式创建线程，调用async的时候不创建线程，直到调用了future的get或者wait方法来创建线程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;    </span><br><span class="line">#include &lt;iostream&gt;   </span><br><span class="line">#include &lt;mutex&gt;  </span><br><span class="line">#include &lt;future&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::future&lt;int&gt; f1 = std::async(std::launch::async, []()&#123; return 8; &#125;);</span><br><span class="line">    std::cout &lt;&lt; f1.get() &lt;&lt; std::endl; //output 8</span><br><span class="line"></span><br><span class="line">    std::future&lt;void&gt; f2 = std::async(std::launch::async, []()&#123; std::cout &lt;&lt; 8 &lt;&lt; std::endl; &#125;);</span><br><span class="line">    f2.wait(); //output 8</span><br><span class="line"></span><br><span class="line">    std::future&lt;int&gt; f3 = std::async(std::launch::async, []()</span><br><span class="line">    &#123; </span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(3));</span><br><span class="line">        return 8;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Wating...&quot; &lt;&lt; std::endl;</span><br><span class="line">    std::future_status status;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        status = f3.wait_for(std::chrono::seconds(1));</span><br><span class="line">        if (status == std::future_status::deferred)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;deferred.&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (status == std::future_status::timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;timeout.&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;ready.&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (status != std::future_status::ready);</span><br><span class="line">    std::cout &lt;&lt; &quot;result:&quot; &lt;&lt; f3.get() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//执行结果：</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">Wating...</span><br><span class="line">timeout.</span><br><span class="line">timeout.</span><br><span class="line">ready.</span><br><span class="line">result:8</span><br></pre></td></tr></table></figure>
<ul>
<li>线程的创建和使用简单方便，可以通过多种方式创建，还可以根据需要获取线程的一些信息及休眠线程。</li>
<li>互斥量可以通过多种方式来保证线程安全，既可以用独占的互斥量保证线程安全，又可以通过递归的互斥量来保护共享资源以避免死锁，还可以设置获取互斥量的超时时间，避免一直阻塞等待。</li>
<li>条件变量提供了另外一种用于等待的同步机制，它能阻塞一个或多个线程，直到收到另外一个线程发出的通知或者超时，才会唤醒当前阻塞的线程。条件变量的使用需要配合互斥量。</li>
<li>原子变量可以更方便地实现线程保护。</li>
<li>call_once保证在多线程情况下函数只被调用一次，可以用在在某些只能初始化一次的场景中。</li>
<li>future、promise和std::package_task用于异步调用的包装和返回值。</li>
<li>async更方便地实现了异步调用，应该优先使用async取代线程的创建。</li>
</ul>
<h1 id="使用C-11中的便利工具"><a href="#使用C-11中的便利工具" class="headerlink" title="使用C++11中的便利工具"></a>使用C++11中的便利工具</h1><h2 id="处理日期和时间的chrono库"><a href="#处理日期和时间的chrono库" class="headerlink" title="处理日期和时间的chrono库"></a>处理日期和时间的chrono库</h2><p>chrono库主要包含了三种类型：时间间隔Duration、时钟Clocks和时间点Time point。</p>
<h3 id="记录时长的duration"><a href="#记录时长的duration" class="headerlink" title="记录时长的duration"></a>记录时长的duration</h3><p>duration表示一段时间间隔，用来记录时间长度，可以表示几秒钟、几分钟或者几个小时的时间间隔，duration的原型是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class Rep, class Period = std::ratio&lt;1&gt;&gt; class duration;</span><br></pre></td></tr></table></figure>
<p>第一个模板参数Rep是一个数值类型，表示时钟个数；第二个模板参数是一个默认模板参数std::ratio，它的原型是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;std::intmax_t Num, std::intmax_t Denom = 1&gt; class ratio;</span><br></pre></td></tr></table></figure>
<p>它表示每个时钟周期的秒数，其中第一个模板参数Num代表分子，Denom代表分母，分母默认为1，ratio代表的是一个分子除以分母的分数值，比如<code>ratio&lt;2&gt;</code>代表一个时钟周期是两秒，<code>ratio&lt;60&gt;</code>代表了一分钟，<code>ratio&lt;60*60&gt;</code>代表一个小时，<code>ratio&lt;60*60*24&gt;</code>代表一天。而<code>ratio&lt;1, 1000&gt;</code>代表的则是1/1000秒即一毫秒，<code>ratio&lt;1, 1000000&gt;</code>代表一微秒，<code>ratio&lt;1, 1000000000&gt;</code>代表一纳秒。标准库为了方便使用，就定义了一些常用的时间间隔，如时、分、秒、毫秒、微秒和纳秒，在chrono命名空间下，它们的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef duration &lt;Rep, ratio&lt;3600,1&gt;&gt; hours;</span><br><span class="line">typedef duration &lt;Rep, ratio&lt;60,1&gt;&gt; minutes;</span><br><span class="line">typedef duration &lt;Rep, ratio&lt;1,1&gt;&gt; seconds;</span><br><span class="line">typedef duration &lt;Rep, ratio&lt;1,1000&gt;&gt; milliseconds;</span><br><span class="line">typedef duration &lt;Rep, ratio&lt;1,1000000&gt;&gt; microseconds;</span><br><span class="line">typedef duration &lt;Rep, ratio&lt;1,1000000000&gt;&gt; nanoseconds;</span><br></pre></td></tr></table></figure>
<p>通过定义这些常用的时间间隔类型，我们能方便的使用它们，比如线程的休眠：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::this_thread::sleep_for(std::chrono::seconds(3)); //休眠三秒</span><br><span class="line">std::this_thread::sleep_for(std::chrono::milliseconds (100)); //休眠100毫秒</span><br></pre></td></tr></table></figure>
<p>chrono还提供了获取时间间隔的时钟周期个数的方法count()，它的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::chrono::milliseconds ms&#123;3&#125;; // 3 毫秒</span><br><span class="line">    // 6000 microseconds constructed from 3 milliseconds</span><br><span class="line">    std::chrono::microseconds us = 2*ms; //6000微秒</span><br><span class="line">    // 30Hz clock using fractional ticks</span><br><span class="line">    std::chrono::duration&lt;double, std::ratio&lt;1, 30&gt;&gt; hz30(3.5);</span><br><span class="line">    std::cout &lt;&lt;  &quot;3 ms duration has &quot; &lt;&lt; ms.count() &lt;&lt; &quot; ticks\n&quot;&lt;&lt;  &quot;6000 us duration has &quot; &lt;&lt; us.count() &lt;&lt; &quot; ticks\n&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 ms duration has 3 ticks</span><br><span class="line">6000 us duration has 6000 ticks</span><br></pre></td></tr></table></figure>
<p>时间间隔之间可以做运算，比如下面的例子中计算两端时间间隔的差值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::minutes t1( 10 );</span><br><span class="line">std::chrono::seconds t2( 60 );</span><br><span class="line">std::chrono::seconds t3 = t1 - t2;</span><br><span class="line">std::cout &lt;&lt; t3.count() &lt;&lt; &quot; second&quot; &lt;&lt; std::endl; // 540 second</span><br></pre></td></tr></table></figure>
<p>其中，t1 是代表 10 分钟、 t2 是代表 60 秒，t3 则是 t1 減去 t2，也就是 600 - 60 = 540 秒。通过t1-t2的count输出差值为540个时钟周期即540秒（因为每个时钟周期为一秒）。我们还可以通过duration_cast&lt;&gt;()来将当前的时钟周期转换为其它的时钟周期，比如我可以把秒的时钟周期转换为分钟的时钟周期，然后通过count来获取转换后的分钟时间间隔：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; chrono::duration_cast&lt;chrono::minutes&gt;( t3 ).count() &lt;&lt;” minutes”&lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>将会输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 minutes</span><br></pre></td></tr></table></figure>
<h3 id="Time-point"><a href="#Time-point" class="headerlink" title="Time point"></a>Time point</h3><p>time_point表示一个时间点，用来获取1970.1.1以来的秒数和当前的时间, 可以做一些时间的比较和算术运算，可以和ctime库结合起来显示时间。time_point必须要clock来计时，time_point有一个函数<code>time_since_epoch()</code>用来获得1970年1月1日到time_point时间经过的duration。下面的例子计算当前时间距离1970年1月一日有多少天：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;ratio&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  using namespace std::chrono;</span><br><span class="line">  typedef duration&lt;int,std::ratio&lt;60*60*24&gt;&gt; days_type;</span><br><span class="line">  time_point&lt;system_clock,days_type&gt; today = time_point_cast&lt;days_type&gt;(system_clock::now());</span><br><span class="line">  std::cout &lt;&lt; today.time_since_epoch().count() &lt;&lt; &quot; days since epoch&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time_point还支持一些算术元算，比如两个time_point的差值时钟周期数，还可以和duration相加减。下面的例子输出前一天和后一天的日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	using namespace std::chrono;</span><br><span class="line">	system_clock::time_point now = system_clock::now();</span><br><span class="line">	std::time_t last = system_clock::to_time_t(now - std::chrono::hours(24));</span><br><span class="line">	std::time_t next= system_clock::to_time_t(now - std::chrono::hours(24));</span><br><span class="line">	std::cout &lt;&lt; &quot;One day ago, the time was &quot;&lt;&lt; std::put_time(std::localtime(&amp;last), &quot;%F %T&quot;) &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">	std::cout &lt;&lt; &quot;Next day, the time was &quot;&lt;&lt; std::put_time(std::localtime(&amp;next), &quot;%F %T&quot;) &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">One day ago, the time was 2014-3-2622:38:27</span><br><span class="line">Next day, the time was 2014-3-2822:38:27</span><br></pre></td></tr></table></figure>
<h3 id="Clocks"><a href="#Clocks" class="headerlink" title="Clocks"></a>Clocks</h3><p>表示当前的系统时钟，内部有time_point, duration, Rep, Period等信息，它主要用来获取当前时间，以及实现time_t和time_point的相互转换。Clocks包含三种时钟：</p>
<ul>
<li>system_clock：从系统获取的时钟；</li>
<li>steady_clock：不能被修改的时钟；</li>
<li>high_resolution_clock：高精度时钟，实际上是system_clock或者steady_clock的别名。</li>
</ul>
<p>可以通过now()来获取当前时间点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	std::chrono::steady_clock::time_point t1 = std::chrono::system_clock::now();</span><br><span class="line">	std::cout &lt;&lt; &quot;Hello World\n&quot;;</span><br><span class="line">	std::chrono::steady_clock::time_point t2 = std::chrono:: system_clock::now();</span><br><span class="line">	std::cout &lt;&lt; (t2-t1).count()&lt;&lt;” tick count”&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">20801 tick count</span><br></pre></td></tr></table></figure>
<p>通过时钟获取两个时间点之相差多少个时钟周期，我们可以通过duration_cast将其转换为其它时钟周期的duration：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( t2-t1 ).count() &lt;&lt;” microseconds”&lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 microseconds</span><br></pre></td></tr></table></figure>
<p>system_clock的to_time_t方法可以将一个time_point转换为ctime：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::time_t now_c = std::chrono::system_clock::to_time_t(time_point);</span><br></pre></td></tr></table></figure>
<p>而from_time_t方法则是相反的，它将ctime转换为time_point。</p>
<p>steady_clock可以获取稳定可靠的时间间隔，后一次调用now()的值和前一次的差值是不因为修改了系统时间而改变，它保证了稳定的时间间隔。它的用法和system用法一样。</p>
<p>system_clock和std::put_time配合起来使用可以格式化日期的输出，std::put_time能将日期格式化输出。下面的例子是将当前时间格式化输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto t = chrono::system_clock::to_time_t(std::chrono::system_clock::now());</span><br><span class="line">	cout&lt;&lt; std::put_time(std::localtime(&amp;t), &quot;%Y-%m-%d %X&quot;)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt; std::put_time(std::localtime(&amp;t), &quot;%Y-%m-%d %H.%M.%S&quot;)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2014-3-27 22:11:49</span><br><span class="line">2014-3-27 22.11.49</span><br></pre></td></tr></table></figure>
<h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>可以利用high_resolution_clock来实现一个类似于boost.timer的定时器，这样的timer在测试性能时会经常用到，经常用它来测试函数耗时，它的基本用法是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;hello word&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">         timer t; //开始计时</span><br><span class="line">         fun()</span><br><span class="line">         cout&lt;&lt;t.elapsed()&lt;&lt;endl; //打印fun函数耗时多少毫秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c++11中增加了chrono库，现在用来实现一个定时器是很简单的事情，还可以移除对boost的依赖。它的实现比较简单，下面是具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;chrono&gt;</span><br><span class="line">usingnamespace std;</span><br><span class="line">usingnamespace std::chrono;</span><br><span class="line"></span><br><span class="line">classTimer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Timer() : m_begin(high_resolution_clock::now()) &#123;&#125;</span><br><span class="line">    void reset() &#123; m_begin = high_resolution_clock::now(); &#125;</span><br><span class="line"></span><br><span class="line">//默认输出秒</span><br><span class="line">　　double elapsed() const</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　return duration_cast&lt;duration&lt;double&gt;&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">//默认输出毫秒</span><br><span class="line">    int64_t elapsed() const</span><br><span class="line">    &#123;</span><br><span class="line">      //return duration_cast&lt;chrono::milliseconds&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //微秒</span><br><span class="line">    int64_t elapsed_micro() const</span><br><span class="line">    &#123;</span><br><span class="line">        return duration_cast&lt;chrono::microseconds&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //纳秒</span><br><span class="line">    int64_t elapsed_nano() const</span><br><span class="line">    &#123;</span><br><span class="line">        return duration_cast&lt;chrono::nanoseconds&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //秒</span><br><span class="line">    int64_t elapsed_seconds() const</span><br><span class="line">    &#123;</span><br><span class="line">        return duration_cast&lt;chrono::seconds&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //分</span><br><span class="line">    int64_t elapsed_minutes() const</span><br><span class="line">    &#123;</span><br><span class="line">        return duration_cast&lt;chrono::minutes&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //时</span><br><span class="line">    int64_t elapsed_hours() const</span><br><span class="line">    &#123;</span><br><span class="line">        return duration_cast&lt;chrono::hours&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    time_point&lt;high_resolution_clock&gt; m_begin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;”hello word”&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	timer t; //开始计时</span><br><span class="line">	fun()</span><br><span class="line">	cout&lt;&lt;t.elapsed()&lt;&lt;endl; //打印fun函数耗时多少毫秒</span><br><span class="line">	cout&lt;&lt;t.elapsed_micro ()&lt;&lt;endl; //打印微秒</span><br><span class="line">	cout&lt;&lt;t.elapsed_nano ()&lt;&lt;endl; //打印纳秒</span><br><span class="line">	cout&lt;&lt;t.elapsed_seconds()&lt;&lt;endl; //打印秒</span><br><span class="line">	cout&lt;&lt;t.elapsed_minutes()&lt;&lt;endl; //打印分钟</span><br><span class="line">	cout&lt;&lt;t.elapsed_hours()&lt;&lt;endl; //打印小时</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数值类型和字符串的相互转换"><a href="#数值类型和字符串的相互转换" class="headerlink" title="数值类型和字符串的相互转换"></a>数值类型和字符串的相互转换</h2><p>C++11提供了to_string方法，可以方便地将各种数值类型转换为字符串类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::string to_string(int value);</span><br><span class="line">std::string to_string(long int value);</span><br><span class="line">std::string to_string(long long int value);</span><br><span class="line">std::string to_string(unsigned int value);</span><br><span class="line">std::string to_string(unsigned long long int value);</span><br><span class="line">std::string to_string(float value);</span><br><span class="line">std::string to_string(double value);</span><br><span class="line"></span><br><span class="line">std::wstring to_wstring(int value);</span><br><span class="line">std::wstring to_wstring(long int value);</span><br><span class="line">std::wstring to_wstring(long long int value);</span><br><span class="line">std::wstring to_wstring(unsigned int value);</span><br><span class="line">std::wstring to_wstring(unsigned long int value);</span><br><span class="line">std::wstring to_wstring(unsigned long long int value);</span><br><span class="line">std::wstring to_wstring(float value);</span><br><span class="line">std::wstring to_wstring(double value);</span><br><span class="line">std::wstring to_wstring(long double value);</span><br></pre></td></tr></table></figure>
<p>还提供了stoxxx方法，将string转换为各种类型的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str = &quot;1000&quot;;</span><br><span class="line">int val = std::stoi(str);</span><br><span class="line">long val = std::stol(str);</span><br><span class="line">float val = std::stof(str);</span><br></pre></td></tr></table></figure>
<p>c++11还提供了字符串(<code>char*</code>)转换为整数和浮点类型的方法：</p>
<ul>
<li>atoi: 将字符串转换为 int</li>
<li>atol: 将字符串转换为long</li>
<li>atoll:将字符串转换为 long long</li>
<li>atof: 将字符串转换为浮点数</li>
</ul>
<h1 id="宽窄字符转换"><a href="#宽窄字符转换" class="headerlink" title="宽窄字符转换"></a>宽窄字符转换</h1><p>c++11增加了unicode字面量的支持，可以通过<strong><code>L</code></strong>来定义宽字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::wstring wide_str = L&quot;中国人&quot;; //定义了宽字符字符串 </span><br></pre></td></tr></table></figure>
<p>将宽字符转换为窄字符需要用到<code>condecvt</code>库中的<code>std::wstring_convert</code>，它需要如下几个转换器：</p>
<ul>
<li><code>std::codecvt_utf8</code>，封装了UTF-8与UCS2及UTF-8与UCS4的编码转换；</li>
<li><code>std::codecvt_utf16</code>，封装了UTF-16与UCS2及UTF-16与UCS4的编码转换；</li>
<li><code>std::codecvt_utf8_utf16</code>，封装了UTF-8与UTF-16的编码转换；</li>
</ul>
<p><code>std::wstring_convert</code>使<code>std::string</code>和<code>std::wstring</code>之间的相互转换变得很方便，如代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::wstring wide_str = L&quot;中国人&quot;;</span><br><span class="line">std::wstring_convert&lt;std::condecvt&lt;wchar_t, char, std::mbstate_t&gt;&gt; converter(new std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;(&quot;CHS&quot;);</span><br><span class="line"></span><br><span class="line">std::string narrow_str = converter.to_bytes(wide_str);</span><br><span class="line">std::wstring wstr = converter.from_bytes(narrow_str);</span><br><span class="line">std::cout &lt;&lt; narrow_str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">wcout.imbue(std::locale(&quot;chs&quot;));</span><br><span class="line">std::wcout &lt;&lt; wstr &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; wstr.size() &lt;&lt; &quot; &quot; &lt;&lt; wstr.length() &lt;&lt; endl;</span><br><span class="line">std::cout &lt;&lt; narrow_str.size() &lt;&lt; &quot; &quot; &lt;&lt; narrow_str.length() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中国人</span><br><span class="line">中国人</span><br></pre></td></tr></table></figure>
<h1 id="C-11的其他特性"><a href="#C-11的其他特性" class="headerlink" title="C++11的其他特性"></a>C++11的其他特性</h1><h2 id="委托构造函数和继承构造函数"><a href="#委托构造函数和继承构造函数" class="headerlink" title="委托构造函数和继承构造函数"></a>委托构造函数和继承构造函数</h2><p>委托构造函数允许在同一个类中一个构造函数可以调用另一个构造函数，从而可以在初始化时简化变量的初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class class_c &#123;</span><br><span class="line">public:</span><br><span class="line">	int max;</span><br><span class="line">	int min;</span><br><span class="line">	int middle;</span><br><span class="line"></span><br><span class="line">	class_c() &#123;&#125;</span><br><span class="line">	class_c(int my_max) &#123;</span><br><span class="line">		max = my_max &gt; 0 ? my_max : 10;</span><br><span class="line">	&#125;</span><br><span class="line">	class_c(int my_max, int my_min) &#123;</span><br><span class="line">		max = my_max &gt; 0 ? my_max : 10;</span><br><span class="line">		min = my_min &gt; 0 &amp;&amp; my_min &lt; my_max ? my_min : 1;</span><br><span class="line">	&#125;</span><br><span class="line">	class_c(int my_max, int my_min, int my_middle) &#123;</span><br><span class="line">		max = my_max &gt; 0 ? my_max : 10;</span><br><span class="line">		min = my_min &gt; 0 &amp;&amp; my_min &lt; my_max ? my_min : 1;</span><br><span class="line">		middle = my_middle &lt; max &amp;&amp; my_middle &gt; min ? my_middle : 5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过委托构造函数简化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class class_c &#123;</span><br><span class="line">public:</span><br><span class="line">	int max;</span><br><span class="line">	int min;</span><br><span class="line">	int middle;</span><br><span class="line"></span><br><span class="line">	class_c() &#123;&#125;</span><br><span class="line">	class_c(int my_max) &#123;</span><br><span class="line">		max = my_max &gt; 0 ? my_max : 10;</span><br><span class="line">	&#125;</span><br><span class="line">	class_c(int my_max, int my_min) : class_c(my_max) &#123;</span><br><span class="line">		min = my_min &gt; 0 &amp;&amp; my_min &lt; my_max ? my_min : 1;</span><br><span class="line">	&#125;</span><br><span class="line">	class_c(int my_max, int my_min, int my_middle) : class_c(my_max, my_min) &#123;</span><br><span class="line">		middle = my_middle &lt; max &amp;&amp; my_middle &gt; min ? my_middle : 5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意，<strong>如果使用了委托构造函数，则不能使用类成员初始化</strong>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A(int a):a_(a)&#123;&#125;; //单独使用类成员初始化，可以</span><br><span class="line">    A(int a, int b):A(a), b_(b)&#123;&#125;; //同时使用了委托构造函数和类成员初始化，错误！</span><br><span class="line">private:</span><br><span class="line">    int a_;</span><br><span class="line">    int b_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个派生类继承自一个基类，如果其构造函数想要使用和基类相同的构造函数，如果构造函数有多个，则在派生类中要写多个构造函数，每个都用基类构造， 在c++11中，可以使用继承构造函数来简化这一操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">    Base(int a);</span><br><span class="line">    Base(int a, int b);</span><br><span class="line">    Base(int a, int b, double c);</span><br><span class="line">    ~Base();</span><br><span class="line">&#125;;</span><br><span class="line">struct Derived : Base &#123;</span><br><span class="line">	using Base::Base; //声明使用基类构造函数</span><br><span class="line">&#125;；</span><br><span class="line">int main() &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原始的字面量"><a href="#原始的字面量" class="headerlink" title="原始的字面量"></a>原始的字面量</h2><p>原始字面量可以直接表示字符串的实际含义，因为有些字符串带一些特殊字符，比如在转义字符串中，我们往往要专门处理。如windows路径名：<code>D:\A\B\test.txt</code><br>在c++11中，使用<code>R&quot;xx(string)xx&quot;</code>来获得括号中的string部分的字符串形式，不需要使用转义字符等附加字符，比如： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string a = R&quot;(D:\A\B\test.txt)&quot; </span><br></pre></td></tr></table></figure>
<p>注意，<code>R&quot;xxx(raw string)xxx&quot;</code>，其中原始字符串必须用括号()括起来，括号前后可以加其他字符串，所加的字符串是会被忽略的，而且加的字符串必须在括号两边同时出现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = R&quot;test(D:A\B\test.test)test&quot;;</span><br><span class="line">// 实际上是“D:A\B\test.test”</span><br></pre></td></tr></table></figure>
<h2 id="final和override标识符"><a href="#final和override标识符" class="headerlink" title="final和override标识符"></a>final和override标识符</h2><p>c++11中增加了final关键字来限制某个类不能被继承（类似java）或者某个虚函数不能别重写（类似c#中的sealed）。如果修饰函数，final只能修饰虚函数，并且要放到类或者函数的后面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    virtual void foo() final; // foo 声明为final的虚函数，不能被重写</span><br><span class="line">    void test() final; // 错误，final只能修饰虚函数</span><br><span class="line">&#125;;</span><br><span class="line">struct B final : A&#123; //B声明为final，表示不能被继承</span><br><span class="line">	void foo(); // 错误，foo不可被重写</span><br><span class="line">&#125;;</span><br><span class="line">struct C : B&#123; //错误，B不能被继承</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>c++11中还增加了override关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，还可以防止因疏忽把原来想重写基类的虚函数声明为重载。override关键字要放到方法的后面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    virtual void func();</span><br><span class="line">&#125;;</span><br><span class="line">struct D:A&#123;</span><br><span class="line">    void func() override&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><h3 id="内存对齐介绍"><a href="#内存对齐介绍" class="headerlink" title="内存对齐介绍"></a>内存对齐介绍</h3><p>cpu访问内存的时候，起始地址并不是随意的，例如有些cpu访问内存起始地址要是4的倍数，因为内存总线的宽度为32位，每次读写操作都4个字节4个字节进行。如果某个数据在内存中不是字节对齐的，则会在访问的时候比较麻烦，比如4字节的int32类型，没有4字节对齐，则需要访问两次内存才能读到完整的数据。因此，内存对齐可以提高程序的效率。 </p>
<p>因为有了内存对齐，所以数据在内存中的存放就不是紧挨着的，而是会出现一些空隙。C++数据内存对齐的含义是，数据在内存中的起始地址是数据size的倍数。c++结构体内存对齐的原则是：结构体内的每个变量都自身对齐，按照字节对齐，中间加入padding，；整个结构体按照结构体内的最大size变量的对齐方式对齐，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char c;</span><br><span class="line">    double d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体按照最大size的变量对齐，即按照double的8字节对齐。</p>
<h3 id="堆内存的内存对齐"><a href="#堆内存的内存对齐" class="headerlink" title="堆内存的内存对齐"></a>堆内存的内存对齐</h3><p>malloc一般使用当前平台默认的最大内存对齐数对齐内存。当我们需要分配一块特定内存对齐的内存块时，使用<code>memalign</code>等函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">inline void* aligned_malloc(size_t size, size_t alignment) &#123;</span><br><span class="line">	// 检查alignment是否是2^N</span><br><span class="line">	assert(!alignment &amp; (alignment - 1));</span><br><span class="line">	// 计算最大offset</span><br><span class="line">	size_t offset = sizeof(void*) + (-- alignment);</span><br><span class="line"></span><br><span class="line">	// 分配一块带有offset的内存</span><br><span class="line">	char* p = static_cast&lt;char*&gt;(malloc(offset + size));</span><br><span class="line">	if (!p) return nullptr;</span><br><span class="line"></span><br><span class="line">	// 通过“&amp;(~alignment)”把多计算的offset减掉</span><br><span class="line">	void* r = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;size_t&gt;(p + offset) &amp; (~alignment));</span><br><span class="line"></span><br><span class="line">	// 将r作为一个指向void*的指针，在r当前地址前面放入原始地址</span><br><span class="line">	static_cast&lt;void**&gt;(r)[-1] = p;</span><br><span class="line">	return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用alignas指定内存对齐大小"><a href="#利用alignas指定内存对齐大小" class="headerlink" title="利用alignas指定内存对齐大小"></a>利用alignas指定内存对齐大小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alignas(32) long long a = 0; </span><br></pre></td></tr></table></figure>
<p>指定a为32字节对齐。 alignas可以将内存对齐改大，而不能改小，因此，可以有 alignas(32) long long a; 而不能有alignas(1) long long a;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define XX 1</span><br><span class="line">struct alignas(XX) MyStruct&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>指定为1字节对齐，因为MyStruct内部没有数据，自然为1字节对齐。如果内部含有int类型数据，则alignas只能将对齐方式改大不能改小，故不能为1字节对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alignas(int) char c;</span><br></pre></td></tr></table></figure>
<p>这个char就按照int的方式对齐了。</p>
<h3 id="利用alignof和std-alignment-of获取内存对齐大小"><a href="#利用alignof和std-alignment-of获取内存对齐大小" class="headerlink" title="利用alignof和std::alignment_of获取内存对齐大小"></a>利用alignof和std::alignment_of获取内存对齐大小</h3><p>alignof用来获取内存对齐大小，只能返回size_t。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyStruct xx;</span><br><span class="line">cout &lt;&lt; alignof(xx) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; alignof(MyStruct) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>alignment_of继承自<code>std::integral_constant</code>，因此拥有value_type、type和value成员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; std::alignment_of&lt;MyStruct&gt;::value &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h3 id="内存对齐的类型std-aligned-storage"><a href="#内存对齐的类型std-aligned-storage" class="headerlink" title="内存对齐的类型std::aligned_storage"></a>内存对齐的类型<code>std::aligned_storage</code></h3><p>aligned_storage可以看成一个内存对齐的缓冲区，原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;std::size_t Len, std::size_t Align = /*default-alignment*/&gt;</span><br><span class="line">struct aligned_storage;</span><br></pre></td></tr></table></figure>
<p>Len代表所存储类型的size，Align代表所存储类型的对齐大小，通过<code>sizeof(T)</code>获取T的size，通过<code>alignof(T)</code>获取T内存对齐的大小，所以<code>std::aligned_storage</code>的声明是这样的：<code>std::aligned_storage&lt;sizeof(T), align(T)&gt;</code>或者<code>std::aligned_storage&lt;sizeof(T), std::alignment_of(T)::value&gt;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    int a;</span><br><span class="line">    double c;</span><br><span class="line">    A(int aa, double cc):a(aa), c(cc)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">typedef std::aligned_storage&lt;sizeof&lt;A&gt;, alignof(A)&gt;::type Aligned_A;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Aligned_A a, b; //声明一块内存对齐的内存</span><br><span class="line">    new (&amp;a)A(10, 20.0); //原地构造函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要使用<code>std::aligned_storage</code>呢？很多时候需要分配一块单纯的内存块，之后再使用placement new在这块内存上构建对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char xx[32];</span><br><span class="line">::new xx MyStruct;</span><br></pre></td></tr></table></figure>
<p>但是char[32]是1字节对齐的，xx很有可能不在指定的对齐位置上，这是调用placement new构造内存块引起效率问题，所以应该使用<code>std::aligned_storage</code>构造内存块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef std::aligned_storage&lt;sizeof&lt;A&gt;, alignof(A)&gt;::type Aligned_A;</span><br><span class="line">::new (&amp;Aligned_A) A;</span><br></pre></td></tr></table></figure>
<h3 id="std-max-align-t和std-align操作符"><a href="#std-max-align-t和std-align操作符" class="headerlink" title="std::max_align_t和std::align操作符"></a><code>std::max_align_t</code>和<code>std::align</code>操作符</h3><p><code>std::max_align_t</code>返回当前平台的最大默认内存对齐类型。通过下面这个方式获得当前平台的默认最大内存对齐数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; alignof(std::max_align_t) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><code>std::align</code>用来在一大块内存中获取一个符合指定内存要求的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buffer[] = &quot;---------------&quot;;</span><br><span class="line">void* pt = buffer;</span><br><span class="line">std::size_t space = sizeof(buffer) - 1;</span><br><span class="line">std::align(alignof(int), sizeof(char), pt, space);</span><br></pre></td></tr></table></figure>
<p>在buffer这个大内存中，指定内存对齐为<code>align(int)</code>，找一块<code>sizeof(char)</code>大小的内存，并在找到这块内存后把地址放入pt中。</p>
<h2 id="新增的便利算法"><a href="#新增的便利算法" class="headerlink" title="新增的便利算法"></a>新增的便利算法</h2><h3 id="all-of、any-of、none-of"><a href="#all-of、any-of、none-of" class="headerlink" title="all_of、any_of、none_of"></a><code>all_of</code>、<code>any_of</code>、<code>none_of</code></h3><p>算法库新增了三个用于判断的算法all_of、any_of和none_of：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class InputIt, class UnaryPredicate &gt;</span><br><span class="line">bool all_of( InputIt first, InputIt last, UnaryPredicate p );</span><br><span class="line"></span><br><span class="line">template&lt; class InputIt, class UnaryPredicate &gt;</span><br><span class="line">bool any_of( InputIt first, InputIt last, UnaryPredicate p );</span><br><span class="line"></span><br><span class="line">template&lt; class InputIt, class UnaryPredicate &gt;</span><br><span class="line">bool none_of( InputIt first, InputIt last, UnaryPredicate p );</span><br></pre></td></tr></table></figure>
<ul>
<li>all_of:检查区间[first, last)中是否所有的元素都满足一元判断式p，所有的元素都满足条件返回true，否则返回false。</li>
<li>any_of：检查区间[first, last)中是否至少有一个元素都满足一元判断式p，只要有一个元素满足条件就返回true，否则返回true。</li>
<li>none_of：检查区间[first, last)中是否所有的元素都不满足一元判断式p，所有的元素都不满足条件返回true，否则返回false。</li>
</ul>
<p>下面是这几个算法的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v = &#123; 1, 3, 5, 7, 9 &#125;;</span><br><span class="line">	auto isEven = [](int i)&#123;return i % 2 != 0;&#125;;</span><br><span class="line">	bool isallOdd = std::all_of(v.begin(), v.end(), isEven);</span><br><span class="line">	if (isallOdd)</span><br><span class="line">		cout &lt;&lt; &quot;all is odd&quot; &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	bool isNoneEven = std::none_of(v.begin(), v.end(), isEven);</span><br><span class="line">	if (isNoneEven)</span><br><span class="line">		cout &lt;&lt; &quot;none is even&quot; &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	vector&lt;int&gt; v1 = &#123; 1, 3, 5, 7, 8, 9 &#125;;</span><br><span class="line">	bool anyof = std::any_of(v1.begin(), v1.end(), isEven);</span><br><span class="line">	if (anyof)</span><br><span class="line">		cout &lt;&lt; &quot;at least one is even&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all is odd</span><br><span class="line">none is odd</span><br><span class="line">at least one is even</span><br></pre></td></tr></table></figure>
<h3 id="find-if-not"><a href="#find-if-not" class="headerlink" title="find_if_not"></a>find_if_not</h3><p>算法库的查找算法新增了一个find_if_not，它的含义和find_if是相反的，即查找不符合某个条件的元素，find_if也可以实现find_if_not的功能，只需要将判断式改为否定的判断式即可，现在新增了find_if_not之后，就不需要再写否定的判断式了，可读性也变得更好。下面是它的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v = &#123; 1, 3, 5, 7, 9, 4 &#125;;</span><br><span class="line">	auto isEven = [](int i)&#123;return i % 2 == 0;&#125;;</span><br><span class="line">	auto firstEven = std::find_if(v.begin(), v.end(), isEven);</span><br><span class="line">	if (firstEven!=v.end())</span><br><span class="line">		cout &lt;&lt; &quot;the first even is &quot; &lt;&lt;* firstEven &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	//用find_if来查找奇数则需要重新写一个否定含义的判断式</span><br><span class="line">	auto isNotEven = [](int i)&#123;return i % 2 != 0;&#125;;</span><br><span class="line">	auto firstOdd = std::find_if(v.begin(), v.end(),isNotEven);</span><br><span class="line">	</span><br><span class="line">	if (firstOdd!=v.end())</span><br><span class="line">		cout &lt;&lt; &quot;the first odd is &quot; &lt;&lt;* firstOdd &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	//用find_if_not来查找奇数则无需新定义判断式</span><br><span class="line">	auto odd = std::find_if_not(v.begin(), v.end(), isEven);</span><br><span class="line">	if (odd!=v.end())</span><br><span class="line">		cout &lt;&lt; &quot;the first odd is &quot; &lt;&lt;* odd &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">the first even is 4</span><br><span class="line">the first odd is 1</span><br><span class="line">the first odd is 1</span><br></pre></td></tr></table></figure>
<p>可以看到使用find_if_not不需要再定义新的否定含义的判断式了，更简便了。</p>
<h3 id="copy-if"><a href="#copy-if" class="headerlink" title="copy_if"></a>copy_if</h3><p>算法库还增加了一个copy_if算法，它相比原来的copy算法多了一个判断式，用起来更方便了，下面是它的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v = &#123; 1, 3, 5, 7, 9, 4 &#125;;</span><br><span class="line">	std::vector&lt;int&gt; v1(v.size());</span><br><span class="line">	//根据条件拷贝</span><br><span class="line">	auto it = std::copy_if(v.begin(), v.end(), v1.begin(), [](int i)&#123;return i%2!=0;&#125;);</span><br><span class="line">	//缩减vector到合适大小</span><br><span class="line">	v1.resize(std::distance(v1.begin(),it));</span><br><span class="line">	for(int i : v1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>算法库新增了iota用来方便的生成有序序列，比如我们需要一个定长数组，这个数组中的元素都是在某一个数值的基础之上递增的，那么用iota可以很方便的生成这个数组了。下面是它的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;array&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v(4) ;</span><br><span class="line">//循环遍历赋值来初始化数组</span><br><span class="line">//for(int i=1; i&lt;=4; i++)</span><br><span class="line">//&#123;</span><br><span class="line">//    v.push_back(i);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//直接通过iota初始化数组，更简洁</span><br><span class="line">    std::iota(v.begin(), v.end(), 1);</span><br><span class="line">    for(auto n: v) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    std::array&lt;int, 4&gt; array;</span><br><span class="line">    std::iota(array.begin(), array.end(), 1);</span><br><span class="line">    for(auto n: array) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>
<p>可以看到使用iota比遍历赋值来初始化数组更简洁，需要注意的是iota初始化的序列需要指定大小，如果上面的代码中：vector<int> v(4) ;没有指定初始化大小为4的话，则输出为空。</p>
<h3 id="minmax-element"><a href="#minmax-element" class="headerlink" title="minmax_element"></a>minmax_element</h3><p>算法库还新增了一个同时获取最大值和最小值的算法minmax_element，这样我们如果想获取最大值和最小值的时候就不用分别调用max_element和max_element算法了，用起来会更方便，minmax_element会将最小值和最大值的迭代器放到一个pair中返回，下面是它的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // your code goes here</span><br><span class="line">    vector&lt;int&gt; v = &#123; 1, 2, 5, 7, 9, 4 &#125;;</span><br><span class="line">    auto result = minmax_element(v.begin(), v.end());</span><br><span class="line">   </span><br><span class="line">    cout&lt;&lt;*result.first&lt;&lt;&quot; &quot;&lt;&lt;*result.second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 9</span><br></pre></td></tr></table></figure>
<h3 id="is-sorted和is-sorted-until"><a href="#is-sorted和is-sorted-until" class="headerlink" title="is_sorted和is_sorted_until"></a>is_sorted和is_sorted_until</h3><p>算法库新增了is_sorted和is_sorted_until算法，is_sort用来判断某个序列是否是排好序的，is_sort_until则用来返回序列中前面已经排好序的部分序列。下面是它们的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; v = &#123; 1, 2, 5, 7, 9, 4 &#125;;</span><br><span class="line">    auto pos = is_sorted_until(v.begin(), v.end());</span><br><span class="line">   </span><br><span class="line">    for(auto it=v.begin(); it!=pos; ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    bool is_sort = is_sorted(v.begin(), v.end());</span><br><span class="line">    cout&lt;&lt; is_sort&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 5 7 9</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>总结：这些新增的算法让我们用起来更加简便，也增强了代码的可读性。</p>
<h1 id="C-11改进我们的模式"><a href="#C-11改进我们的模式" class="headerlink" title="C++11改进我们的模式"></a>C++11改进我们的模式</h1><h2 id="改进单例模式"><a href="#改进单例模式" class="headerlink" title="改进单例模式"></a>改进单例模式</h2><p>单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。在c++11之前，我们写单例模式的时候会遇到一个问题，就是多种类型的单例可能需要创建多个类型的单例，主要是因为创建单例对象的构造函数无法统一，各个类型的形参不尽相同，导致我们不容易做一个所有类型都通用的单例。现在c+11帮助我们解决了这个问题，解决这个问题靠的是c++11的可变模板参数。</p>
<p>将原有的多个构造函数合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T0, typename T1, typename T2, typename T3, typename T4, typename T5&gt;</span><br><span class="line">static T* Instance(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) &#123;</span><br><span class="line">	if (m_pInstance == nullptr)</span><br><span class="line">		m_pInstance = new T(arg0, arg1, arg2, arg3, arg4, arg5);</span><br><span class="line">	return m_pInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">　　static T* Instance(Args&amp;&amp;... args)</span><br><span class="line">　　&#123;</span><br><span class="line">		if(m_pInstance==nullptr)</span><br><span class="line">			m_pInstance = new T(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">		return m_pInstance;</span><br><span class="line">	&#125;</span><br><span class="line">　　static T* GetInstance() &#123;</span><br><span class="line">　　　　if (m_pInstance == nullptr)</span><br><span class="line">　　　　　　throw std::logic_error(&quot;the instance is not init, please initialize the instance first&quot;);</span><br><span class="line">　　　　return m_pInstance;</span><br><span class="line">　　&#125;</span><br><span class="line">	static void DestroyInstance()</span><br><span class="line">	&#123;</span><br><span class="line">		delete m_pInstance;</span><br><span class="line">		m_pInstance = nullptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">		Singleton(void);</span><br><span class="line">		virtual ~Singleton(void);</span><br><span class="line">		Singleton(const Singleton&amp;);</span><br><span class="line">		Singleton&amp; operator = (const Singleton&amp;);</span><br><span class="line">private:</span><br><span class="line">	static T* m_pInstance;</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line">template &lt;class T&gt; T*  Singleton&lt;T&gt;::m_pInstance = nullptr;</span><br></pre></td></tr></table></figure>
<p>/<strong><strong><em>*</em></strong></strong>更新说明<strong><strong><strong><em>**</em></strong></strong></strong>/</p>
<p>由于原来的接口中，单例对象的初始化和取值都是一个接口，可能会遭到误用，更新之后，初始化和取值分为两个接口，单例的用法为：先初始化，后面取值，如果中途销毁单例的话，需要重新取值。如果没有初始化就取值则会抛出一个异常。</p>
<p>增加Multiton的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt; typename T, typename K = string&gt;</span><br><span class="line">class Multiton</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	static std::shared_ptr&lt;T&gt; Instance(const K&amp; key, Args&amp;&amp;... args)</span><br><span class="line">	&#123;</span><br><span class="line">		return GetInstance(key, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	static std::shared_ptr&lt;T&gt; Instance(K&amp;&amp; key, Args&amp;&amp;... args)</span><br><span class="line">	&#123;</span><br><span class="line">		return GetInstance(key, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	template&lt;typename Key, typename... Args&gt;</span><br><span class="line">	static std::shared_ptr&lt;T&gt; GetInstance(Key&amp;&amp; key, Args&amp;&amp;...args)</span><br><span class="line">	&#123;</span><br><span class="line">		std::shared_ptr&lt;T&gt; instance = nullptr;</span><br><span class="line">		auto it = m_map.find(key);</span><br><span class="line">		if (it == m_map.end())</span><br><span class="line">		&#123;</span><br><span class="line">			instance = std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">			m_map.emplace(key, instance);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			instance = it-&gt;second;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	Multiton(void);</span><br><span class="line">	virtual ~Multiton(void);</span><br><span class="line">	Multiton(const Multiton&amp;);</span><br><span class="line">	Multiton&amp; operator = (const Multiton&amp;);</span><br><span class="line">private:</span><br><span class="line">	static map&lt;K, std::shared_ptr&lt;T&gt;&gt; m_map;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename K&gt;</span><br><span class="line">map&lt;K, std::shared_ptr&lt;T&gt;&gt; Multiton&lt;T, K&gt;::m_map;</span><br></pre></td></tr></table></figure>
<h2 id="改进观察者模式"><a href="#改进观察者模式" class="headerlink" title="改进观察者模式"></a>改进观察者模式</h2><p>观察者模式定义对象间一种一对多关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。和单例模式面临的是同样的问题，主题更新的接口难以统一，很难做出一个通用的观察者模式，还是用到可变模板参数解决这个问题，其次还用到了右值引用，避免多余的内存移动。c++11版本的观察者模式支持注册的观察者为函数、函数对象和lamda表达式，也避免了虚函数调用，更简洁更通用。</p>
<p>主要改进的地方有两个：通过被通知接口参数化和<code>std::function</code>来代替继承，通过可变参数模板和完美转发来消除接口变化产生的影响。直接看代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">class NonCopyable &#123;</span><br><span class="line">protected:</span><br><span class="line">	NonCopyable() = default;</span><br><span class="line">	~NonCopyable() = default;</span><br><span class="line">	NonCopyable(const NonCopyable&amp;) = delete;</span><br><span class="line">	NonCopyable&amp; operator = (const NonCopyable&amp;) = delete;</span><br><span class="line">	// 禁用复制构造和赋值构造</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">template&lt;typename Func&gt;</span><br><span class="line">class Events : NonCopyable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Events() &#123;&#125;</span><br><span class="line">	~Events()&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	int Connect(Func&amp;&amp; f) &#123;</span><br><span class="line">		return Assgin(std::forward&lt;Func&gt;(f));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int Connect(const Func&amp; f) &#123;</span><br><span class="line">		return Assgin(f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void Disconnect(int key) &#123;</span><br><span class="line">		m_connections.erase(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	void Notify(Args&amp;&amp;... args) &#123;</span><br><span class="line">		for (auto&amp; it : m_connections) &#123;</span><br><span class="line">			it.second(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int operator += (Func&amp;&amp; f) &#123;</span><br><span class="line">		return Connect(std::forward&lt;Func&gt;(f));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int operator += (Func&amp; f) &#123;</span><br><span class="line">		return Connect(f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	void operator()(Args&amp;&amp;... args) &#123;</span><br><span class="line">		Notify(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Events&amp; operator -= (int key) &#123;</span><br><span class="line">		Disconnect(key);</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void Clear() &#123;</span><br><span class="line">		m_connections.clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	template&lt;typename F&gt;</span><br><span class="line">	int Assgin(F&amp;&amp; f) &#123;</span><br><span class="line">		int index = m_nextKey++;</span><br><span class="line">		m_connections.emplace(index, std::forward&lt;F&gt;f);</span><br><span class="line">		return index;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int m_nextKey;</span><br><span class="line">	std::map&lt;int, Func&gt; m_connections;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>增加了+=和-=运算符，使用法更接近c#，这里+=会返回一个key，这个key用来-=删除委托时用到，这种做法不太好，只是一个简单的处理。如果内部用vector的话，-=时，根据function去删除指定的委托的话，用法就和c#完全一致了，不过，这里遇到的问题是function不支持比较操作，导致将function存入容器后，后面再根据function去删除时就找不到对应的function了。</p>
<h2 id="改进访问者模式"><a href="#改进访问者模式" class="headerlink" title="改进访问者模式"></a>改进访问者模式</h2><p>访问者表示一个作用于某对象结构中的各元素的操作，可用于不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<p>访问者模式需要注意定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。定义一个稳定的访问者接口层，即不会因为增加新的被访问者而修改接口层。通过可变参数模板实现一个稳定的接口层，利用可变参数模板可以支持任意个数的参数的特点，可以让访问者接口层访问任意个数的被访问者。</p>
<p>访问者模式是GOF23个设计模式中比较复杂的模式之一，但是它的功能也很强大，非常适合稳定的继承层次中对象的访问，可以在不修改被访问对象的情况下，动态添加职责，这正是访问者模式强大的地方，但是它的实现又造成了两个继承层次的强烈耦合，这也是被人诟病的地方，可以说是让人爱又让人恨的模式。c++11实现的访问者模式将会解决这个问题。我们将在c++11版本的访问者模式中看到，定义新的访问者是很容易的，扩展性很好，被访问者的继承层次也不用做任何修改。具体代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... Types&gt;</span><br><span class="line">struct Visitor;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T, typename... Types&gt;</span><br><span class="line">struct Visitor&lt;T, Types...&gt; : Visitor&lt;Types...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    using Visitor&lt;Types...&gt;::Visit;</span><br><span class="line">    virtual void Visit(const T&amp;) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct Visitor&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    virtual void Visit(const T&amp;) = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码为每个类型都定义了一个纯虚函数Visit。</p>
<p>下面看看被访问的继承体系如何使用Visitor访问该继承体系的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct stA;</span><br><span class="line">struct stB; </span><br><span class="line"> </span><br><span class="line">struct Base</span><br><span class="line">&#123;    </span><br><span class="line">    typedef Visitor&lt;stA, stB&gt; MytVisitor;     </span><br><span class="line">    virtual void Accept(MytVisitor&amp;) = 0;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">struct stA: Base</span><br><span class="line">&#123;    </span><br><span class="line">    double val;     </span><br><span class="line">    void Accept(Base::MytVisitor&amp; v)    </span><br><span class="line">    &#123;        </span><br><span class="line">        v.Visit(*this);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">struct stB: Base</span><br><span class="line">&#123;    </span><br><span class="line">    int val;    </span><br><span class="line">    void Accept(Base::MytVisitor&amp; v)    </span><br><span class="line">    &#123;        </span><br><span class="line">        v.Visit(*this);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">struct PrintVisitor: Base::MytVisitor</span><br><span class="line">&#123;    </span><br><span class="line">    void Visit(const stA&amp; a)    </span><br><span class="line">    &#123;        </span><br><span class="line">        std::cout &lt;&lt; &quot;from stA: &quot; &lt;&lt; a.val &lt;&lt; std::endl;    </span><br><span class="line">    &#125;     </span><br><span class="line">    void Visit(const stB&amp; b)    </span><br><span class="line">    &#123;        </span><br><span class="line">        std::cout &lt;&lt; &quot;from stB: &quot; &lt;&lt; b.val &lt;&lt; std::endl;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void TestVisitor()</span><br><span class="line">&#123;</span><br><span class="line">    PrintVisitor vis;    </span><br><span class="line">    stA a;    </span><br><span class="line">    a.val = 8.97;    </span><br><span class="line">    stB b;    </span><br><span class="line">    b.val = 8;     </span><br><span class="line">    Base* base = &amp;a;    </span><br><span class="line">    base-&gt;Accept(vis);    </span><br><span class="line">    base = &amp;b;    </span><br><span class="line">    base-&gt;Accept(vis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　测试结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from stA: 8.97</span><br><span class="line">from stB: 8</span><br></pre></td></tr></table></figure>
<p><code>typedef Visitor&lt;stA, stB&gt; MytVisitor;</code>会自动生成stA和stB的visit虚函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Visitor&lt;stA, stB&gt; &#123;</span><br><span class="line">	virtual void Visit(const stA &amp;) = 0;</span><br><span class="line">	virtual void Visit(const stB &amp;) = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当被访者需要增加stC、stD时，增加就行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`typedef Visitor&lt;stA, stB, stC, stD&gt; MytVisitor;</span><br></pre></td></tr></table></figure>
<p>类型自动生成接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Visitor&lt;stA, stB, stC, stD&gt; &#123;</span><br><span class="line">	virtual void Visit(const stA &amp;) = 0;</span><br><span class="line">	virtual void Visit(const stB &amp;) = 0;</span><br><span class="line">	virtual void Visit(const stC &amp;) = 0;</span><br><span class="line">	virtual void Visit(const stD &amp;) = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="改进命令模式"><a href="#改进命令模式" class="headerlink" title="改进命令模式"></a>改进命令模式</h2><p>命令模式的作用是将请求封装为一个对象，将请求的发起者和执行者解耦，支持对请求排队以及撤销和重做。将请求封装成一个个命令对象，使得我们可以集中处理或延迟处理这些命令请求，而且不同的客户对象可以共享命令，控制请求的优先级、排队、支持请求命令撤销和重做。</p>
<p>命令模式的这些好处是显而易见的，但是，在实际使用过程中它的问题也暴露出来了。随着请求的增多，请求的封装类—命令类也会越来越多，尤其是GUI应用中，请求是非常多的。越来越多的命令类会导致类爆炸，难以管理。关于类爆炸这个问题，GOF很早就意识到了，他们提出了一个解决方法：对于简单的不能取消和不需要参数的命令，可以用一个命令类模板来参数化该命令的接收者，用接收者类型来参数化命令类，并维护一个接收者对象和一个动作之间的绑定，而这一动作是用指向同一个成员函数的指针存储的。具体代码是这样的：<br>简单命令类的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Receiver&gt;</span><br><span class="line">class SimpleCommand: public Command &#123;</span><br><span class="line">public :</span><br><span class="line">	typedef void (Receiver:: *Action) ();</span><br><span class="line">	SimpleCormnand(Receiver* r, Action a) : _receiver (r) , _action (a) &#123; &#125;</span><br><span class="line">	virtual void Execute ();</span><br><span class="line">private :</span><br><span class="line">	Action _action;</span><br><span class="line">	Receiver* _receiver ;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;class Receiver&gt;</span><br><span class="line">void SimpleCommand&lt;Receiver&gt;::Execute() &#123;</span><br><span class="line">	(_receiver-&gt;*_action)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">	void Action();</span><br><span class="line">&#125;</span><br><span class="line">void dummy() &#123;</span><br><span class="line">	MyClass* receiver = new MyClass;</span><br><span class="line">	Command* aCommand = new SimpleCommand&lt;MyClass&gt;(receiver, &amp;MyClass::Action);</span><br><span class="line">	aCommand-&gt;Execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个泛型的简单命令类来避免不断创建新的命令类，是一个不错的办法，但是，这个办法不完美，即它只能是简单的命令类，不能对复杂的，甚至所有的命令类泛化，这是它的缺陷，所以，它只是部分的解决了问题。我想我可以改进这个办法缺陷，完美的解决类爆炸的问题。在c++11之前我不知道有没有人解决过这个问题，至少我没看到过。现在可以通过c++11来完美的解决这个问题了。</p>
<p>要完美的解决命令模式类爆炸问题的关键是如何定义个通用的泛化的命令类，这个命令类可以泛化所有的命令，而不是GOF提到的简单命令。我们再回过头来看看GOF中那个简单的命令类的定义，它只是泛化了没有参数和返回值的命令类，命令类内部引用了一个接收者和接收者的函数指针，如果接收者的行为函数指针有参数就不能通用了，所以我们要解决的关键问题是如何让命令类能接受所有的成员函数指针或者函数对象。</p>
<p>我们需要一个函数包装器，它可以接受所有的函数对象、fucntion和lamda表达式等。接受function、函数对象、lamda和普通函数的包装器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class F, class... Args, class = typename std::enable_if&lt;!std::is_member_function_pointer&lt;F&gt;::value&gt;::type&gt;</span><br><span class="line">void Wrap(F &amp;&amp; f, Args &amp;&amp; ... args)</span><br><span class="line">&#123;</span><br><span class="line">	return f(std::forward&lt;Args&gt;(args)...); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接受成员函数的包装器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class R, class C, class... DArgs, class P, class... Args&gt;</span><br><span class="line">void Wrap(R(C::*f)(DArgs...), P &amp;&amp; p, Args &amp;&amp; ... args)</span><br><span class="line">&#123;</span><br><span class="line">	return (*p.*f)(std::forward&lt;Args&gt;(args)...); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过重载的Wrap让它能接收成员函数。这样一个真正意义上的万能的函数包装器就完成了。现在再来看，它是如何应用到命令模式中，完美的解决类爆炸的问题。</p>
<p>一个通用的泛化的命令类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">template&lt;typename R=void&gt;</span><br><span class="line">struct CommCommand</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	std::function &lt; R()&gt; m_f;</span><br><span class="line">public:</span><br><span class="line">	template&lt; class F, class... Args, class = typename std::enable_if&lt;!std::is_member_function_pointer&lt;F&gt;::value&gt;::type&gt;</span><br><span class="line">	void Wrap(F &amp;&amp; f, Args &amp;&amp; ... args)</span><br><span class="line">	&#123;</span><br><span class="line">		m_f = [&amp;]&#123;return f(args...); &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template&lt;class C, class... DArgs, class P, class... Args&gt;</span><br><span class="line">	void Wrap(R(C::*f)(DArgs...) const, P &amp;&amp; p, Args &amp;&amp; ... args)</span><br><span class="line">	&#123;</span><br><span class="line">		m_f = [&amp;, f]&#123;return (*p.*f)( args...); &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// non-const member function </span><br><span class="line">	template&lt;class C, class... DArgs, class P, class... Args&gt;</span><br><span class="line">	void Wrap(R(C::*f)(DArgs...), P &amp;&amp; p, Args &amp;&amp; ... args)</span><br><span class="line">	&#123;</span><br><span class="line">		m_f = [&amp;, f]&#123;return (*p.*f)( args...); &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	R Excecute()</span><br><span class="line">	&#123;</span><br><span class="line">		return m_f();</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">struct STA</span><br><span class="line">&#123;</span><br><span class="line">	int m_a;</span><br><span class="line">	int operator()()&#123; return m_a; &#125;</span><br><span class="line">	int operator()(int n)&#123; return m_a + n; &#125;</span><br><span class="line">	int triple0()&#123; return m_a * 3; &#125;</span><br><span class="line">	int triple(int a)&#123; return m_a * 3 + a; &#125;</span><br><span class="line">	int triple1() const &#123; return m_a * 3; &#125;</span><br><span class="line">	const int triple2(int a) const &#123; return m_a * 3+a; &#125;</span><br><span class="line">	void triple3()&#123; cout &lt;&lt; &quot;&quot; &lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int add_one(int n) &#123;</span><br><span class="line">	return n + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestWrap() &#123;</span><br><span class="line"></span><br><span class="line">	CommCommand&lt;int&gt; cmd;</span><br><span class="line">	// free function </span><br><span class="line">	cmd.Wrap(add_one, 0);</span><br><span class="line">	</span><br><span class="line">	// lambda function</span><br><span class="line">	cmd.Wrap([](int n)&#123;return n + 1; &#125;, 1);</span><br><span class="line">	</span><br><span class="line">	// functor </span><br><span class="line">	cmd.Wrap(bloop);</span><br><span class="line">	cmd.Wrap(bloop, 4);</span><br><span class="line">	</span><br><span class="line">	STA t = &#123; 10 &#125;;</span><br><span class="line">	int x = 3;</span><br><span class="line">	// member function </span><br><span class="line">	cmd.Wrap(&amp;STA::triple0, &amp;t);</span><br><span class="line">	cmd.Wrap(&amp;STA::triple, &amp;t, x);</span><br><span class="line">	cmd.Wrap(&amp;STA::triple, &amp;t, 3);</span><br><span class="line">	</span><br><span class="line">	cmd.Wrap(&amp;STA::triple2, &amp;t, 3);</span><br><span class="line">	auto r = cmd.Excecute();</span><br><span class="line">	</span><br><span class="line">	CommCommand&lt;&gt; cmd1;</span><br><span class="line">	cmd1.Wrap(&amp;Bloop::triple3, &amp;t);</span><br><span class="line">	cmd1.Excecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在通用的命令类内部定义了一个万能的函数包装器，使得我们可以封装所有的命令，增加新的请求都不需要重新定义命令了，完美的解决了命令类爆炸的问题。</p>
<h2 id="改进对象池模式"><a href="#改进对象池模式" class="headerlink" title="改进对象池模式"></a>改进对象池模式</h2><p>对象池对于创建比较大的对象来说很有意义，为了避免重复创建开销比较大的对象，可以通过对象池来优化，实现创建好一批对象，放到一个集合里，每当程序需要新对象时，就从对象池中获取，程序用完该对象后会把对象归还给对象池。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MaxObjectNum = 10;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class ObjectPool : NonCopyable</span><br><span class="line">&#123;</span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	using Constructor = std::function&lt;std::shared_ptr&lt;T&gt;(Args...)&gt;;</span><br><span class="line">public:</span><br><span class="line">	//默认创建多少个对象</span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	void Init(size_t num, Args&amp;&amp;... args)</span><br><span class="line">	&#123;</span><br><span class="line">		if (num&lt;= 0 || num&gt; MaxObjectNum)</span><br><span class="line">			throw std::logic_error(&quot;object num out of range.&quot;);</span><br><span class="line"></span><br><span class="line">		auto constructName = typeid(Constructor&lt;Args...&gt;).name(); //不区分引用</span><br><span class="line">		for (size_t i = 0; i &lt;num; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			m_object_map.emplace(constructName, shared_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...), [this, constructName](T* p) //删除器中不直接删除对象，而是回收到对象池中，以供下次使用</span><br><span class="line">			&#123;</span><br><span class="line">				m_object_map.emplace(std::move(constructName), std::shared_ptr&lt;T&gt;(p));</span><br><span class="line">			&#125;));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//从对象池中获取一个对象</span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	std::shared_ptr&lt;T&gt; Get()</span><br><span class="line">	&#123;</span><br><span class="line">		string constructName = typeid(Constructor&lt;Args...&gt;).name();</span><br><span class="line"></span><br><span class="line">		auto range = m_object_map.equal_range(constructName);</span><br><span class="line">		for (auto it = range.first; it != range.second; ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			auto ptr = it-&gt;second;</span><br><span class="line">			m_object_map.erase(it);</span><br><span class="line">			return ptr;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return nullptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	multimap&lt;string, std::shared_ptr&lt;T&gt;&gt; m_object_map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="使用C-11实现一个半同步半异步线程池"><a href="#使用C-11实现一个半同步半异步线程池" class="headerlink" title="使用C++11实现一个半同步半异步线程池"></a>使用C++11实现一个半同步半异步线程池</h1><p>实际中，主要有两种方法处理大量的并发任务，一种是一个请求由系统产生一个相应的处理请求的线程（一对一）；另外一种是系统预先生成一些用于处理请求的进程，当请求的任务来临时，先放入同步队列中，分配一个处理请求的进程去处理任务，线程处理完任务后还可以重用，不会销毁，而是等待下次任务的到来。（一对多的线程池技术）线程池技术，能避免大量线程的创建和销毁动作，节省资源，对于多核处理器，由于线程被分派配到多个cpu，会提高并行处理的效率。线程池技术分为半同步半异步线程池和领导者追随者线程池。</p>
<p>一个半同步半异步线程池分为三层。</p>
<ul>
<li>同步服务层：它处理来自上层的任务请求,上层的请求可能是并发的,这些请求不是马上就会被处理的,而是将这些任务放到一个同步排队层中,等待处理。</li>
<li>同步排队层: 来自上层的任务请求都会加到排队层中等待处理，排队层实际就是一个std::queue。</li>
<li>异步服务层: 这一层中会有多个线程同时处理排队层中的任务,异步服务层从同步排队层中取出任务并行的处理。</li>
</ul>
<p>上层只需要将任务丢到同步队列中，主线程也不会阻塞，还能继续发起新的请求。排队曾居于核心地位，实现时，排队曾就是一个同步队列，允许多个线程同时去添加或取出任务。线程池有两个活动过程，一个是往同步队列中添加任务的过程，一个是从同步队列中取任务的过程。</p>
<p>一开始线程池会启动一定数量的线程，这些线程属于异步层，主要用来并行处理排队层中的任务，如果排队层中的任务数为空，则这些线程等待任务的到来，如果发现排队层中有任务了，线程池则会从等待的这些线程中唤醒一个来处理新任务。同步服务层则会不断地将新的任务添加到同步排队层中，这里有个问题值得注意，有可能上层的任务非常多，而任务又是非常耗时的，这时，异步层中的线程处理不过来，则同步排队层中的任务会不断增加，如果同步排队层不加上<br>限控制，则可能会导致排队层中的任务过多，内存暴涨的问题。因此，排队层需要加上限的控制，当排队层中的任务数达到上限时，就不让上层的任务添加进来，起到限制和保护的作用。</p>
<p>同步队列即为线程中三层结构中的中间那一层，它的主要作用是保证队列中共享数据线程安全，还为上一层同步服务层提供添加新任务的接口，以及为下一层异步服务层提供取任务的接口。同时，还要限制任务数的上限，避免任务过多导致内存暴涨的问题。同步队列的实现比较简单，我们会用到C++11的锁、条件变量、右值引用、std::move以及std::forwardo。move是为了实现移动语义，forward是为了实现完美转发。同步队列的锁是用来线程同步的，条件变量是用来实现线程通信的，即线程池空了就要等待，不为空就通知一个线程去处理；线程池满了就等待，直到没有满的时候才通知上层添加新任务。</p>
<p>这三个层次之间需要使用std::mutex、std::condition_variable来进行事件同步，线程池的实现代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class SyncQueue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    SyncQueue(int maxSize) : m_maxSize(maxSize),m_needStop(false)&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    void Put(const T&amp; x) &#123;</span><br><span class="line">		Add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Put(T&amp;&amp; x) &#123;</span><br><span class="line">    	Add(std::forward&lt;T&gt;(x));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void Take(std::list&lt;T&gt;&amp; list) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">        m_notEmpty.wait(locker,[this]&#123;return m_needStop || NotEmpty();&#125;);</span><br><span class="line">        if(m_needStop)</span><br><span class="line"> 			return;</span><br><span class="line">        list = std::move(m_queue);   //move semantics,avoid copy.</span><br><span class="line">        m_notFull.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Take(T&amp; x) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">        m_notEmpty.wait(locker,[this]&#123;return m_needStop || NotEmpty();&#125;);</span><br><span class="line">        if(m_needStop)</span><br><span class="line">            return;</span><br><span class="line">        x=m_queue.front();</span><br><span class="line">        m_queue.pop_front();</span><br><span class="line">        m_notFull.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void Stop() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">            m_needStop = true;</span><br><span class="line">        &#125;</span><br><span class="line">        m_notFull.notify_all();</span><br><span class="line">        m_notEmpty.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool Empty() &#123;</span><br><span class="line">    	std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">    	return m_queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool Full() &#123;</span><br><span class="line">    	std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">    	return m_queue.size() == m_maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    std::size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">        return m_queue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Count() &#123;</span><br><span class="line">    	return m_queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    bool NotFull() const &#123;</span><br><span class="line">        bool full = m_queue.size() &gt;= m_maxSize;</span><br><span class="line">        if(full)</span><br><span class="line">            std::cout &lt;&lt; &quot;the buffer is full,waiting...\n&quot;;</span><br><span class="line">        return !full;</span><br><span class="line">    &#125;</span><br><span class="line">    bool NotEmpty()</span><br><span class="line">    &#123;</span><br><span class="line">        bool empty = m_queue.empty();</span><br><span class="line">        if(empty)</span><br><span class="line">            std::cout &lt;&lt; &quot;the buffer is empty,waiting...\n&quot;;</span><br><span class="line">        return !empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename F&gt; </span><br><span class="line">    void Add(F&amp;&amp; x) &#123;</span><br><span class="line">    	std::unique_lock&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">    	m_notFull.wait(locker, [this]&#123; return m_needStop || NotFull(); &#125;);</span><br><span class="line">    	if (m_needStop) </span><br><span class="line">    		return ;</span><br><span class="line">    	m_queue.push_back(std::forward&lt;F&gt;(x));</span><br><span class="line">    	m_notEmpty.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::list&lt;T&gt; m_queue;</span><br><span class="line">    std::mutex m_mutex;</span><br><span class="line">    std::condition_variable m_notEmpty;</span><br><span class="line">    std::condition_variable m_notFull;</span><br><span class="line">    int m_maxSize;</span><br><span class="line">    bool m_needStop;   //stop flag</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Take函数先创建一个unique_lock获取，然后再通过条件变量m_notEmpty来等待判断式，判断式由两个条件组成，一个是停止的标志，另一个是不为空的条件，当不满足任何一个条件时，条件变量会释放mutex并将线程置于waiting状态，等待其他线程调用notify_one/notify-all将其唤醒；当满足任何一个条件时，则继续往下执行后面的逻辑，即将队列中的任务取出，并唤醒一个正处于等待状态的添加任务的线程去添加任务。当处于waiting状态的线程被或notify_all唤醒时，条件变量会先重新获取mutex，然后再检查条件是否满足，如果满足，则往下执行，如果不满足，则释放mutex继续等待。</p>
<p>Add函数的过程与Take类似，先获取mutex，不满足条件时，释放继续等待，如果满足条件，则将新的任务插人到队列中，并唤醒取任的线程去取数据。</p>
<p>Stop函数先获取mutex，然后将停止标志置为true。注意，为了保证线程安全，这里需要先获取mutex，在将其标志置为之后，再唤醒所有等待的线程，因为等待的条件是m_needStop，并且满足条件，所以线程会继续往下执行。由于线程在m_needStop为true时会退出，所以所有的等待线程会相继退出。另外一个值得注意的地方是，我们把m_notFull.notify_all()放到lock_guard保护范围之外了，这里也可以将m_notFull.notify_all()放到lock_guard保护范围之内，放到外面是为了做一点优化。因为notify-one或notify-all会唤醒一个在等待的线程，线程被唤醒后会先获取mutex再检查条件是否满足，如果这时被lock_guard保护，被唤醒的线程则需要lock_guard析构释放mutex才能获取。如果在lock_guard之外notify_one或notify_all，被唤醒的线程获取锁的时候不需要等待lock-guard释放锁，性能会<br>好一点，所以在执行notify-one或notify-all时不需要加锁保护。</p>
<p>线程池：<br>一个完整的线程池包括三层：同步服务层、排队层和异步服务层，其实这也是一种生产者一消费者模式，同步层是生产者，不断将新任务丢到排队层中，因此，线程池需要提供一个添加新任务的接口供生产者使用；消费者是异步层，具体是由线程池中预先创建的线程去处理排队层中的任务。排队层是一个同步队列，它内部保证了上下两层对共享数据的安全访问，同时还要保证队列不会被无限制地添加任务导致内存暴涨，这个同步队列将使用上一节中实现的线程池。另外，线程池还要提供一个停止的接口，让用户能够在需要的时候停止线程池的运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">const int MaxTaskCount = 100;</span><br><span class="line">class ThreadPool</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    using Task = std::function&lt;void()&gt;; </span><br><span class="line"> </span><br><span class="line">    ThreadPool(int numThreads = std::thread::hardware_concurrency()) :</span><br><span class="line">    		m_taskQueue(MaxTaskCount)</span><br><span class="line">    &#123;</span><br><span class="line">        Start(numThreads);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~ThreadPool()&#123; Stop();&#125;;</span><br><span class="line">    void Stop() &#123;</span><br><span class="line">        std::call_once(m_once_flag,[this]&#123;StopThreadGroup();&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void AddTask(Task&amp;&amp; task) &#123;</span><br><span class="line">    	m_queue.Put(std::forward&lt;Task&gt;(task));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void AddTask(const Task&amp; task) &#123;</span><br><span class="line">        m_taskQueue.Put(task);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    std::size_t SyncQueueSize() &#123;</span><br><span class="line">        return m_taskQueue.Size();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void Start(int numThreads) &#123;</span><br><span class="line">        m_running = true;</span><br><span class="line">        for( int i = 0;i &lt; numThreads; ++i) &#123;</span><br><span class="line">            m_threadGrop.push_back(std::make_shared&lt;std::thread&gt;(&amp;ThreadPool::RunInThread,this));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void RunInThread() &#123;</span><br><span class="line">        while(m_running) &#123;</span><br><span class="line">            std::list&lt;Task&gt; list;</span><br><span class="line">            m_taskQueue.Take(list);</span><br><span class="line"></span><br><span class="line">            for(auto&amp; task : list) &#123;</span><br><span class="line">                if(!m_running)</span><br><span class="line">                    return;</span><br><span class="line">                 task();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void StopThreadGroup() &#123;</span><br><span class="line">        m_taskQueue.Stop();</span><br><span class="line">        m_running = false;</span><br><span class="line">        for(auto thread : m_threadGrop) &#123;</span><br><span class="line">            if(thread)</span><br><span class="line">                thread-&gt;join();</span><br><span class="line">        &#125;</span><br><span class="line">        m_threadGrop.clear();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::list&lt;std::shared_ptr&lt;std::thread&gt;&gt; m_threadGrop;   //thread group</span><br><span class="line">    SyncQueue&lt;Task&gt; m_taskQueue;</span><br><span class="line">    std::atomic_bool m_running;</span><br><span class="line">    std::once_flag m_once_flag;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h1 id="C-11实现一个轻量级的AOP框架"><a href="#C-11实现一个轻量级的AOP框架" class="headerlink" title="C++11实现一个轻量级的AOP框架"></a>C++11实现一个轻量级的AOP框架</h1><p>AOP（Aspect-Oriented Programming，面向方面编程），可以解决面向对象编程中的一些问题，是OOP的一种有益补充。面向对象编程中的继承是一种从上而下的关系，不适合定义从左到右的横向关系，如果继承体系中的很多无关联的对象都有一些公共行为，这些公共行为可能分散在不同的组件、不同的对象之中，通过继承方式提取这些公共行为就不太合适了。使用AOP还有一种情况是为了提高程序的可维护性，AOP将程序的非核心逻辑都“横切”出来，将非核心逻辑和核心逻辑分离，使我们能集中精力在核心逻辑上，如图所示的这种情况。<br><img src="/img/468725-20150831100452169-1977975177.png" alt=""></p>
<p>在图中，每个业务流程都有日志和权限验证的功能，还有可能增加新的功能，实际上我们只关心核心逻辑，其他的一些附加逻辑，如日志和权限，我们不需要关注，这时，就可以将日志和权限等非核心逻辑“横切”出来，使核心逻辑尽可能保持简洁和清晰，方便维护。这样“横切”的另外一个好处是，这些公共的非核心逻辑被提取到多个切面中了，使它们可以被其他组件或对象复用，消除了重复代码。</p>
<p>AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，它们经常发生在核心关注点的多处，而各处都基本相似，比如权限认证、日志、事务处理。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<p>实现AOP的技术分为：静态织入和动态织入。静态织入一般采用抓们的语法创建“方面”，从而使编译器可以在编译期间织入有关“方面”的代码，AspectC++就是采用的这种方式。这种方式还需要专门的编译工具和语法，使用起来比较复杂。我将要介绍的AOP框架正是基于动态织入的轻量级AOP框架。动态织入一般采用动态代理的方式，在运行期对方法进行拦截，将切面动态织入到方法中，可以通过代理模式来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class IHello</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    IHello() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    virtual ~IHello() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    virtualvoid Output(const string&amp; str) &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">class Hello : public IHello &#123;</span><br><span class="line">public:</span><br><span class="line">    void Output(const string&amp; str) override &#123;</span><br><span class="line">        cout &lt;&lt;str&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HelloProxy : public IHello &#123;</span><br><span class="line">public:</span><br><span class="line">    HelloProxy(IHello* p) : m_ptr(p) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ~HelloProxy() &#123;</span><br><span class="line">        delete m_ptr;</span><br><span class="line">        m_ptr = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Output(const string&amp; str) final &#123;</span><br><span class="line">        cout &lt;&lt;&quot;Before real Output&quot;&lt;&lt; endl;</span><br><span class="line">        m_ptr-&gt;Output(str);</span><br><span class="line">        cout &lt;&lt;&quot;After real Output&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    IHello* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void TestProxy()</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;IHello&gt; hello = std::make_shared&lt;HelloProxy&gt;(newHello());</span><br><span class="line">    hello-&gt;Output(&quot;It is a test&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before real Output</span><br><span class="line">It is a test</span><br><span class="line">Before real Output</span><br></pre></td></tr></table></figure>
<p>可以看到我们通过HelloProxy代理对象实现了对Output方法的拦截，这里Hello::Output就是核心逻辑，HelloProxy实际上就是一个切面，我们可以把一些非核心逻辑放到里面，比如在核心逻辑之前的一些校验，在核心逻辑执行之后的一些日志等。</p>
<p>要实现灵活组合各种切面，一个比较好的方法是将切面作为模板的参数，这个参数是可变的，支持1到N（N&gt;0）切面，先执行核心逻辑之前的切面逻辑，执行完之后再执行核心逻辑，然后再执行核心逻辑之后的切面逻辑。这里，我们可以通过可变参数模板来支持切面的组合。AOP实现的关键是动态织入，实现技术就是拦截目标方法，只要拦截了目标方法，我们就可以在目标方法执行前后做一些非核心逻辑，通过继承方式来实现拦截，需要派生基类并实现基类接口，这使程序的耦合性增加了。为了降低耦合性，这里通过模板来做解耦，即每个切面对象需要提供Before(Args…)或After(Args…)方法，用来处理核心逻辑执行前后的非核心逻辑。</p>
<p>为了实现切面的充分解耦合，我们的切面不必通过继承方式实现，而且也不必要求切面必须具备Before和After方法，只要具备任意一个方法即可，给使用者提供最大的便利性和灵活性。实现这个功能稍微有点复杂，复杂的地方在于切面可能具有某个方法也可能不具有某个方法，具有就调用，不具有也不会出错。问题的本质上是需要检查类型是否具有某个方法，在C++中是无法在运行期做到这个事情的，因为C++像不托管语言c#或java那样具备反射功能，然而，我们可以在编译期检查类型是否具有某个方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#define HAS_MEMBER(member)\</span><br><span class="line">template&lt;typename T, typename... Args&gt;struct has_member_##member\</span><br><span class="line">&#123;\</span><br><span class="line">private:\</span><br><span class="line">        template&lt;typename U&gt; static auto Check(int) -&gt; decltype(std::declval&lt;U&gt;().member(std::declval&lt;Args&gt;()...), std::true_type()); \</span><br><span class="line">    template&lt;typename U&gt; static std::false_type Check(...);\</span><br><span class="line">public:\</span><br><span class="line">    enum&#123;value = std::is_same&lt;decltype(Check&lt;T&gt;(0)), std::true_type&gt;::value&#125;;\</span><br><span class="line">&#125;;\</span><br><span class="line"></span><br><span class="line">HAS_MEMBER(Foo)</span><br><span class="line">HAS_MEMBER(Before)</span><br><span class="line">HAS_MEMBER(After)</span><br><span class="line"></span><br><span class="line">#include &lt;NonCopyable.hpp&gt;</span><br><span class="line">template&lt;typename Func, typename... Args&gt;</span><br><span class="line">struct Aspect : NonCopyable</span><br><span class="line">&#123;</span><br><span class="line">    Aspect(Func&amp;&amp; f) : m_func(std::forward&lt;Func&gt;(f)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    typename std::enable_if&lt;has_member_Before&lt;T, Args...&gt;::value&amp;&amp;has_member_After&lt;T, Args...&gt;::value&gt;::type Invoke(Args&amp;&amp;... args, T&amp;&amp; aspect)</span><br><span class="line">    &#123;</span><br><span class="line">        aspect.Before(std::forward&lt;Args&gt;(args)...);//核心逻辑之前的切面逻辑</span><br><span class="line">        m_func(std::forward&lt;Args&gt;(args)...);//核心逻辑</span><br><span class="line">        aspect.After(std::forward&lt;Args&gt;(args)...);//核心逻辑之后的切面逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    typename std::enable_if&lt;has_member_Before&lt;T, Args...&gt;::value&amp;&amp;!has_member_After&lt;T, Args...&gt;::value&gt;::type Invoke(Args&amp;&amp;... args, T&amp;&amp; aspect)</span><br><span class="line">    &#123;</span><br><span class="line">        aspect.Before(std::forward&lt;Args&gt;(args)...);//核心逻辑之前的切面逻辑</span><br><span class="line">        m_func(std::forward&lt;Args&gt;(args)...);//核心逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    typename std::enable_if&lt;!has_member_Before&lt;T, Args...&gt;::value&amp;&amp;has_member_After&lt;T, Args...&gt;::value&gt;::type Invoke(Args&amp;&amp;... args, T&amp;&amp; aspect)</span><br><span class="line">    &#123;</span><br><span class="line">        m_func(std::forward&lt;Args&gt;(args)...);//核心逻辑</span><br><span class="line">        aspect.After(std::forward&lt;Args&gt;(args)...);//核心逻辑之后的切面逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename Head, typename... Tail&gt;</span><br><span class="line">    void Invoke(Args&amp;&amp;... args, Head&amp;&amp;headAspect, Tail&amp;&amp;... tailAspect)</span><br><span class="line">    &#123;</span><br><span class="line">        headAspect.Before(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        Invoke(std::forward&lt;Args&gt;(args)..., std::forward&lt;Tail&gt;(tailAspect)...);</span><br><span class="line">        headAspect.After(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Func m_func; //被织入的函数</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typenameT&gt; using identity_t = T;</span><br><span class="line"></span><br><span class="line">//AOP的辅助函数，简化调用</span><br><span class="line">template&lt;typename... AP, typename... Args, typename Func&gt;</span><br><span class="line">void Invoke(Func&amp;&amp;f, Args&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    Aspect&lt;Func, Args...&gt; asp(std::forward&lt;Func&gt;(f));</span><br><span class="line">    asp.Invoke(std::forward&lt;Args&gt;(args)..., identity_t&lt;AP&gt;()...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现思路很简单，将需要动态织入的函数保存起来，然后根据参数化的切面来执行Before(Args…)处理核心逻辑之前的一些非核心逻辑，在核心逻辑执行完之后，再执行After(Args…)来处理核心逻辑之后的一些非核心逻辑。上面的代码中的has_member_Before和has_member_After这两个traits是为了让使用者用起来更灵活，使用者可以自由的选择Before和After，可以仅仅有Before或After，也可以二者都有。</p>
<p>需要注意的是切面中的约束，因为通过模板参数化切面，要求切面必须有Before或After函数，这两个函数的入参必须和核心逻辑的函数入参保持一致，如果切面函数和核心逻辑函数入参不一致，则会报编译错误。从另外一个角度来说，也可以通过这个约束在编译期就检查到某个切面是否正确。</p>
<p>下面看一个简单的测试AOP的例子，这个例子中我们将记录目标函数的执行时间并输出日志，其中计时和日志都放到切面中。在执行函数之前输出日志，在执行完成之后也输出日志，并对执行的函数进行计时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct TimeElapsedAspect</span><br><span class="line">&#123;</span><br><span class="line">    void Before(int i) &#123;</span><br><span class="line">        m_lastTime = m_t.elapsed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void After(int i) &#123;</span><br><span class="line">        cout &lt;&lt;&quot;time elapsed: &quot;&lt;&lt; m_t.elapsed() - m_lastTime &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    double m_lastTime;</span><br><span class="line">    Timer m_t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct LoggingAspect</span><br><span class="line">&#123;</span><br><span class="line">    void Before(int i) &#123;</span><br><span class="line">        std::cout &lt;&lt;&quot;entering&quot;&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void After(int i) &#123;</span><br><span class="line">        std::cout &lt;&lt;&quot;leaving&quot;&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(int a) &#123;</span><br><span class="line">    cout &lt;&lt;&quot;real HT function: &quot;&lt;&lt;a&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Invoke&lt;LoggingAspect, TimeElapsedAspect&gt;(&amp;foo, 1); //织入方法</span><br><span class="line">	cout &lt;&lt;&quot;-----------------------&quot;&lt;&lt; endl;</span><br><span class="line">    Invoke&lt;TimeElapsedAspect, LoggingAspect&gt;(&amp;foo, 1);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用C-开发一个轻量级的IoC容器"><a href="#使用C-开发一个轻量级的IoC容器" class="headerlink" title="使用C++开发一个轻量级的IoC容器"></a>使用C++开发一个轻量级的IoC容器</h1><p>让对象不再直接依赖于外部对象的创建，而是依赖于某种机制，这种机制可以让对象之间的关系在外面组装，外界可以根据需求灵活地配置这种机制的对象创建策略，从而获得想要的目标对象，这种机制被称为控制反转。控制反转就是应用本身不负责依赖对象的创建和维护，而交给一个外部容器来负责。这样控制权就由应用转移到了外部容器，即实现了所谓的控制反转。IoC用来降低对象之间直接依赖产生的耦合性。</p>
<p>具体做法是将对象的依赖关系从代码中移出去，放到一个统一的配置文件中或者在IoC容器中配置这种依赖关系，由容器来管理对象的依赖关系。比如可以这样来初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void IocSample() &#123;</span><br><span class="line">	//通过IOC容器来配A和Base对象的关系</span><br><span class="line">	IocContainer ioc;</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedB&gt;(&quot;B&quot;);</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedC&gt;(&quot;C&quot;);</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedD&gt;(&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">	//由IoC容器去初始化A对象</span><br><span class="line">	A* a = ioc.Resolve&lt;A&gt;(&quot;B&quot;)；</span><br><span class="line">	a-&gt;Func();</span><br><span class="line">	delete a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们在外面通过IoC容器配置了A和Base对象的关系，然后由IoC容器去创建A对象，这里A对象的创建不再依赖于工厂或者Base对象，彻底解耦了二者之间的关系。</p>
<p>IoC使得我们在对象创建上获得了最大的灵活性，大大降低了依赖对象创建时的耦合性，即使需求变化了，也只需要修改配置文件就可以创建想要的对象，而不需要修改代码了。我们一般是通过依赖注人（Dependency Injection）来将对象创建的依赖关系注人到目标类型的构造函数中。</p>
<p>IoC容器实际上具备两种能力，一种是对象工厂的能力，不仅可以创建所有的对象，还能根据配置去创建对象；另一种能力是可以去创建依赖对象，应用不需要直接创建依赖对象，由IoC容器去创建，实现控制反转。</p>
<h2 id="IoC创建对象"><a href="#IoC创建对象" class="headerlink" title="IoC创建对象"></a>IoC创建对象</h2><p>因为IoC容器本质上是为了创建对象及依赖的对象，所以实现loc容器第一个要解决的问题是如何创建对象。IoC容器要创建所有类型对象的能力，并且还能根据配置来创建依赖对象。我们先看看如何实现一个可配置的对象工厂。</p>
<p>一个可配置的对象工厂实现思路如下：先注册可能需要创建的对象类型的构造函数，将其放到一个内部关联容器中，设置键为类型的名称或者某个唯一的标识，值为类型的构造函数，然后在创建的时候根据类型名称或某个唯一标识来查找对应的构造函数并最终创建出目标对象。对于外界来说，不需要关心对象具体是如何创建的，只需要告诉工厂要创建的类型名称即可，工厂获取了类型名称或唯一标识之后就可以创建需要的对象了。由于工厂是根据唯一标识来创建对象，所以这个唯一标识是可以写到配置文件中的，这样就可以根据配置动态生成所需要的对象了，我们一般是将类型的名称作为这个唯一标识。</p>
<p>类型擦除就是将原有类型消除或者隐藏。为什么要擦除类型？因为很多时候我们不关心只体类型是什么或者根本就不需要这个类型。类型擦除可以获取很多好处，比如使得程序有更好的扩展性，还能消除耦合以及消除一些重复行为，使程序更加简洁高效。下面是一些常用的类型擦除方式：</p>
<ul>
<li>通过多态来擦除类型。</li>
<li>通过模板来擦除类型。</li>
<li>通过某种类型容器来擦除类型。</li>
<li>通过某种通用类型来擦除类型。</li>
<li>通过闭包来擦除类型。</li>
</ul>
<p>第一种类型擦除方式是最简单的，也是经常用的，通过将派生类型隐式转换成基类型，再通过基类去调用虚函数。在这种情况下，我们不用关心派生类的具体类型，只需要以一种统一的方式去做不同的事情，所以就把派生类型转成基类型隐藏起来，这样不仅可以多态调用，还使程序具有良好的可扩展性。然而这种方式的类型擦除仅是将部分类型擦除，因为基类型仍然存在，而且这种类型擦除的方式还必须继承这种强耦合的方式。正是因为这些缺点，通过多态来擦除类型的方式有较多局限性，并且效果也不好。这时通过第二种方式来擦除类型，可以以解决第一种方式的一些问题。通过模板来擦除类型，本质上是把不同类型的共同行为进行了抽象，这时不同类型彼此之间不需要通过继承这种强耦合的方式去获得共同的行为，仅仅是通过模板就能获取共同行为，降低了不同类型之间的耦合，是一种很好的类型擦除方式。然而，第二种方式虽然降低了对象间的耦合，但是还有一个问题没解决，就是基本类型始终需要指定，并没有消除基本类型，例如，不可能把一个T本身作为容器元素，必须在容器初始化时指定T为某个具体类型。</p>
<p>有时，希望有一种通用的类型，可以让容器容纳所有的类型，作为所有类型的基类，可以当作一种通用的类型。之前实现的Variant类可以把不同的类型抱起来，获得一种统一的类型，而且不同类型之间没有耦合关系。比如，可以通过Variant这样来擦除类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义通用的类型，这个类型可能容纳多种类型</span><br><span class="line">typedef Variant&lt;double, int, uint32_t, char*&gt;Value;</span><br><span class="line">vt.pushback(l);</span><br><span class="line">vt.pushback(&quot;test&quot;);</span><br><span class="line">vt.pushback(1.22);</span><br></pre></td></tr></table></figure>
<p>上面的代码擦除了不同类型，使得不同的类型都可以放到一个容器中了，如果要取出来就很简单，通过Get<T>()就可以获取对应类型的值。这种方式是通过类型容器把类型包起来了，从而达到类型擦除的目的。这种方式的缺点是通用的类型必须事先定义好，它只能容<br>纳声明的那些类型，是有限的，超出定义的范围就不行了。</p>
<p>通过某种通用类型来擦除原有类型的方式可以消除这个缺点，这种通用类型就是Any类型，下面介绍怎么用Any来擦除类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Any&gt; v;</span><br><span class="line">v.pushback(1);</span><br><span class="line">v.pushback(&quot;test&quot;);</span><br><span class="line">v.pushback(2.35);</span><br><span class="line">auto r1 = v[0].AnyCast&lt;int&gt;();</span><br><span class="line">auto r2 = v[1].AnyCast&lt;const char*&gt;();</span><br><span class="line">auto r3 = v[2].AnyCast&lt;double&gt;();</span><br><span class="line"></span><br><span class="line">Any a = 1;</span><br><span class="line">if(a.Is&lt;int&gt;()) &#123;</span><br><span class="line">	int I = a.AnyCast&lt;int&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，不需要预先定义类型的范围，允许任何类型的对象都赋值给Any对象，消除了Variant类型只支持有限类型的问题，但是Any的缺点是：在取值的时候仍然需要具体的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;Any&gt;</span><br><span class="line">#include&lt;NonCopyable&gt;</span><br><span class="line"></span><br><span class="line">class IocContainer &#123;</span><br><span class="line">public:</span><br><span class="line">    IocContainer(void)&#123;&#125;</span><br><span class="line">    ~IocContainer(void)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class T, typename Depend&gt;</span><br><span class="line">    void RegisterType(const string&amp; strKey) &#123;</span><br><span class="line">        std::function&lt;T*()&gt; function = []&#123; return new T(new Depend());&#125;;</span><br><span class="line">        RegisterType(strKey, function);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class I&gt;</span><br><span class="line">    I* Resolve(string strKey)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_creatorMap.find(strKey) == m_creatorMap.end())</span><br><span class="line">            return nullptr;</span><br><span class="line"></span><br><span class="line">        Any resolver = m_creatorMap[strKey];</span><br><span class="line">        std::function&lt;I* ()&gt; function = resolver.AnyCast&lt;std::function&lt;I*()&gt;&gt;(); </span><br><span class="line">        return function();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class I&gt;</span><br><span class="line">    std::shared_ptr&lt;I&gt; ResolveShared(const string&amp; strKey)</span><br><span class="line">    &#123;</span><br><span class="line">        auto b = Resolve&lt;I&gt;(strKey);</span><br><span class="line">        return std::shared_ptr&lt;I&gt;(b);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">	void RegisterType(const string&amp; strKey, Any constructor)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_creatorMap.find(strKey) != m_creatorMap.end())</span><br><span class="line">            throw std::logic_exception(&quot;this key has already exist!&quot;);</span><br><span class="line"></span><br><span class="line">        m_creatorMap.insert(make_pair(strKey, constructor));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;string, Any&gt; m_creatorMap;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	IocContainer ioc;</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedB&gt;(&quot;B&quot;);</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedC&gt;(&quot;C&quot;);</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedD&gt;(&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">	auto pa = ioc.ResolveShared&lt;A&gt;(&quot;B&quot;);</span><br><span class="line">	pa-&gt;Func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样仍然不太方便，但是可以改进，可以借助闭包，将一些类型信息保存在闭包中，闭包将类型隐藏起来了，从而实现了类型擦除的目的。由于闭包本身的类型是确定的，所以能放到普通的容器中，在需要的时候从闭包中取出具体的类型。下面看看如何通过闭包来擦除类型，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Func(T t) &#123;</span><br><span class="line">	cout&lt;&lt;t&lt;&lt;endl；</span><br><span class="line">&#125;</span><br><span class="line">void TestErase() &#123;</span><br><span class="line">	int x = 1;</span><br><span class="line">	char y = &#x27;s&#x27;;</span><br><span class="line"></span><br><span class="line">	vector&lt;std::function&lt;void()&gt;&gt; v;</span><br><span class="line">	v.push_back([x]&#123;Func(x);&#125;);</span><br><span class="line">	v.push_back([y]&#123;Func(y);&#125;);</span><br><span class="line"></span><br><span class="line">	for(auto item : v) &#123;</span><br><span class="line">		item();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的可变参数模板改进IoC容器，支持带参数对象的创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;Any&gt;</span><br><span class="line">#include&lt;NonCopyable&gt;</span><br><span class="line"></span><br><span class="line">class IocContainer : NonCopyable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    IocContainer(void)&#123;&#125;</span><br><span class="line">    ~IocContainer(void)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class T, typename Depend, typename ... Args&gt;</span><br><span class="line">    void RegisterType(const string&amp; strKey)</span><br><span class="line">    &#123;</span><br><span class="line">        std::function&lt;T*(Args...)&gt; function = [](Args... args)&#123; return new T(new Depend(args...));&#125;;</span><br><span class="line">        RegisterType(strKey, function);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class T, typename ... Args&gt;</span><br><span class="line">    I* Resolve(const string&amp; strKey, Args ... args)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_creatorMap.find(strKey) == m_creatorMap.end())</span><br><span class="line">            return nullptr;</span><br><span class="line"></span><br><span class="line">        Any resolver = m_creatorMap[strKey];</span><br><span class="line">       std::function&lt;T*(Args...)&gt; function  = resolver.AnyCast&lt;std::function&lt;T*(Args...)&gt;&gt;(); </span><br><span class="line">        return function(args...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class I, typename... Args&gt;</span><br><span class="line">    std::shared_ptr&lt;I&gt; ResolveShared(const string&amp; strKey, Args... args)</span><br><span class="line">    &#123;</span><br><span class="line">        I* i = Resolve&lt;I&gt;(strKey, args...);</span><br><span class="line">        return std::shared_ptr&lt;I&gt;(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	void RegisterType(const string&amp; strKey, Any constructor)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_creatorMap.find(strKey) != m_creatorMap.end())</span><br><span class="line">            throw std::logic_exception(&quot;this key has already exist!&quot;);</span><br><span class="line"></span><br><span class="line">        m_creatorMap.emplace(strKey, constructor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;string, Any&gt; m_creatorMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	IocContainer ioc;</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedC&gt;(&quot;C&quot;);</span><br><span class="line">	auto c = ioc.ResolveShared&lt;A&gt;(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">	ioc.RegisterType&lt;A, DerivedB, int, double&gt;(&quot;C&quot;);</span><br><span class="line">	auto b = ioc.ResolveShared&lt;A&gt;(&quot;C&quot;, 1, 2.0);</span><br><span class="line">	b-&gt;Func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型注册分成三种方式注册，一种是简单方式注册，它只需要具体类型信息和key，类型的构造函数中没有参数，从容器中取也只需要类型和key；另外一种简单注册方式需要接口类型和具体类型，返回实例时，可以通过接口类型和key来得到具体对象；第三种是构造函数中带参数的类型注册，需要接口类型、key和参数类型，获取对象时需要接口类型、key和参数。返回的实例可以是普通的指针也可以是智能指针。需要注意的是key是唯一的，如果不唯一，会产生一个断言错误，推荐用类型的名称作为key，可以保证唯一性，std::string strKey = typeid(T).name()。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/13/effective_cpp/" rel="prev" title="Effective C++笔记">
      <i class="fa fa-chevron-left"></i> Effective C++笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/04/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AE%9E%E9%AA%8C%E8%AF%BE%E4%BB%B6-%E4%B8%B2%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="next" title="高性能计算实验课件-串行程序性能优化">
      高性能计算实验课件-串行程序性能优化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8C-11%E8%AE%A9%E7%A8%8B%E5%BA%8F%E6%9B%B4%E7%AE%80%E6%B4%81"><span class="nav-number">1.</span> <span class="nav-text">使用C++11让程序更简洁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">1.1.</span> <span class="nav-text">类型推导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#auto"><span class="nav-number">1.1.1.</span> <span class="nav-text">auto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype"><span class="nav-number">1.1.2.</span> <span class="nav-text">decltype</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%BB%86%E8%8A%82%E6%94%B9%E8%BF%9B"><span class="nav-number">1.2.</span> <span class="nav-text">模板的细节改进</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8F%B3%E5%B0%96%E6%8B%AC%E5%8F%B7"><span class="nav-number">1.2.1.</span> <span class="nav-text">模板的右尖括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%AB%E5%90%8D"><span class="nav-number">1.2.2.</span> <span class="nav-text">模板的别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text">函数模板的默认模板参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.</span> <span class="nav-text">列表初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">初始化列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E9%95%BF%E5%BA%A6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">任意长度初始化列表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">防止类型收窄</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.4.</span> <span class="nav-text">基于范围的for循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%96%B0%E7%94%A8%E6%B3%95"><span class="nav-number">1.4.1.</span> <span class="nav-text">for循环的新用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">1.4.2.</span> <span class="nav-text">基于范围的for循环的细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A9%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.3.</span> <span class="nav-text">让基于范围的for循环支持自定义类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-function%E5%92%8Cbind%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="nav-number">1.5.</span> <span class="nav-text">std::function和bind绑定器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.5.1.</span> <span class="nav-text">可调用对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8-std-function"><span class="nav-number">1.5.2.</span> <span class="nav-text">可调用对象包装器-std::function</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-bind%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="nav-number">1.6.</span> <span class="nav-text">std::bind绑定器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.7.</span> <span class="nav-text">lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">1.7.1.</span> <span class="nav-text">lambda表达式的概念和基本用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tuple%E5%85%83%E7%BB%84"><span class="nav-number">1.8.</span> <span class="nav-text">tuple元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.9.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8C-11%E6%94%B9%E8%BF%9B%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD"><span class="nav-number">2.</span> <span class="nav-text">使用C++11改进程序性能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#amp-amp-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">&amp;&amp;的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">关于左值和右值的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">2.2.3.</span> <span class="nav-text">右值引用的意义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#move%E8%AF%AD%E4%B9%89"><span class="nav-number">2.3.</span> <span class="nav-text">move语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#forward%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-number">2.4.</span> <span class="nav-text">forward和完美转发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emplace-back%E5%87%8F%E5%B0%91%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%92%8C%E7%A7%BB%E5%8A%A8"><span class="nav-number">2.5.</span> <span class="nav-text">emplace_back减少内存拷贝和移动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unordered-container%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">2.6.</span> <span class="nav-text">unordered container无序容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8C-11%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%EF%BC%8C%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">使用C++11消除重复，提高代码质量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#type-traits%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96"><span class="nav-number">3.1.</span> <span class="nav-text">type_traits——类型萃取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84type-traits"><span class="nav-number">3.1.1.</span> <span class="nav-text">基本的type_traits</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.2.</span> <span class="nav-text">可变参数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.1.</span> <span class="nav-text">可变参数模板函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">3.2.2.</span> <span class="nav-text">可变参数模板类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E9%80%92%E5%BD%92%E5%92%8C%E7%89%B9%E5%8C%96%E6%96%B9%E5%BC%8F%E5%B1%95%E5%BC%80%E5%8F%82%E6%95%B0%E5%8C%85"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">模板递归和特化方式展开参数包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81"><span class="nav-number">3.2.3.</span> <span class="nav-text">可变参数消除重复代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8Ctype-traits%E7%9A%84%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8"><span class="nav-number">3.3.</span> <span class="nav-text">可变参数模板和type_traits的综合应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#optional%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.1.</span> <span class="nav-text">optional的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E7%B1%BBlazy%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.2.</span> <span class="nav-text">惰性求值类lazy的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dll%E5%B8%AE%E5%8A%A9%E7%B1%BB"><span class="nav-number">3.3.3.</span> <span class="nav-text">dll帮助类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="nav-number">3.3.4.</span> <span class="nav-text">lambda链式调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#any%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.5.</span> <span class="nav-text">any类的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#function-traits"><span class="nav-number">3.3.6.</span> <span class="nav-text">function_traits</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-function-traits%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF"><span class="nav-number">3.3.6.1.</span> <span class="nav-text">实现 function_traits的关键技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#variant%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.7.</span> <span class="nav-text">variant的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E9%80%A0variant%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.7.1.</span> <span class="nav-text">打造variant需要解决的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E9%80%A0variant%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="nav-number">3.3.7.2.</span> <span class="nav-text">打造variant的关键技术：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.3.7.3.</span> <span class="nav-text">类型检查和缓冲区中创建对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E5%80%BC%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.7.4.</span> <span class="nav-text">取值问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScopeGuard"><span class="nav-number">3.3.8.</span> <span class="nav-text">ScopeGuard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tuple-helper"><span class="nav-number">3.3.9.</span> <span class="nav-text">tuple_helper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%8D%B0tuple"><span class="nav-number">3.3.9.1.</span> <span class="nav-text">打印tuple</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E8%BD%ACTuple"><span class="nav-number">3.3.9.2.</span> <span class="nav-text">反转Tuple</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.9.3.</span> <span class="nav-text">应用于函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8C-11%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">使用C++11解决内存泄漏的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#shared-ptr%E5%85%B1%E4%BA%AB%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">4.1.</span> <span class="nav-text">shared_ptr共享的智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">4.1.1.</span> <span class="nav-text">基本用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unique-ptr%E7%8B%AC%E5%8D%A0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">4.2.</span> <span class="nav-text">unique_ptr独占的智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#weak-ptr%E5%BC%B1%E5%BC%95%E7%94%A8%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">4.3.</span> <span class="nav-text">weak_ptr弱引用的智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="nav-number">4.3.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">解决循环引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-number">4.4.</span> <span class="nav-text">通过智能指针管理第三方库分配的内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8C-11%E8%AE%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95"><span class="nav-number">5.</span> <span class="nav-text">使用C++11让多线程开发变得简单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">5.2.</span> <span class="nav-text">互斥量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">5.3.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F"><span class="nav-number">5.4.</span> <span class="nav-text">原子变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call-once-once-flag%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.5.</span> <span class="nav-text">call_once&#x2F;once_flag的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%B1%BB"><span class="nav-number">5.6.</span> <span class="nav-text">异步操作类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#std-future"><span class="nav-number">5.6.1.</span> <span class="nav-text">std::future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-promise"><span class="nav-number">5.6.2.</span> <span class="nav-text">std::promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-packaged-task"><span class="nav-number">5.6.3.</span> <span class="nav-text">std::packaged_task</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-promise%E3%80%81std-packaged-task%E5%92%8Cstd-future%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.6.4.</span> <span class="nav-text">std::promise、std::packaged_task和std::future三者之间的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0async"><span class="nav-number">5.7.</span> <span class="nav-text">线程异步操作函数async</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8C-11%E4%B8%AD%E7%9A%84%E4%BE%BF%E5%88%A9%E5%B7%A5%E5%85%B7"><span class="nav-number">6.</span> <span class="nav-text">使用C++11中的便利工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84chrono%E5%BA%93"><span class="nav-number">6.1.</span> <span class="nav-text">处理日期和时间的chrono库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E6%97%B6%E9%95%BF%E7%9A%84duration"><span class="nav-number">6.1.1.</span> <span class="nav-text">记录时长的duration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Time-point"><span class="nav-number">6.1.2.</span> <span class="nav-text">Time point</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Clocks"><span class="nav-number">6.1.3.</span> <span class="nav-text">Clocks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timer"><span class="nav-number">6.1.4.</span> <span class="nav-text">timer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.2.</span> <span class="nav-text">数值类型和字符串的相互转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%BD%E7%AA%84%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2"><span class="nav-number">7.</span> <span class="nav-text">宽窄字符转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-11%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="nav-number">8.</span> <span class="nav-text">C++11的其他特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.1.</span> <span class="nav-text">委托构造函数和继承构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">8.2.</span> <span class="nav-text">原始的字面量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final%E5%92%8Coverride%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">8.3.</span> <span class="nav-text">final和override标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">8.4.</span> <span class="nav-text">内存对齐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E4%BB%8B%E7%BB%8D"><span class="nav-number">8.4.1.</span> <span class="nav-text">内存对齐介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">8.4.2.</span> <span class="nav-text">堆内存的内存对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8alignas%E6%8C%87%E5%AE%9A%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%A4%A7%E5%B0%8F"><span class="nav-number">8.4.3.</span> <span class="nav-text">利用alignas指定内存对齐大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8alignof%E5%92%8Cstd-alignment-of%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%A4%A7%E5%B0%8F"><span class="nav-number">8.4.4.</span> <span class="nav-text">利用alignof和std::alignment_of获取内存对齐大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E7%B1%BB%E5%9E%8Bstd-aligned-storage"><span class="nav-number">8.4.5.</span> <span class="nav-text">内存对齐的类型std::aligned_storage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-max-align-t%E5%92%8Cstd-align%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">8.4.6.</span> <span class="nav-text">std::max_align_t和std::align操作符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E4%BE%BF%E5%88%A9%E7%AE%97%E6%B3%95"><span class="nav-number">8.5.</span> <span class="nav-text">新增的便利算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#all-of%E3%80%81any-of%E3%80%81none-of"><span class="nav-number">8.5.1.</span> <span class="nav-text">all_of、any_of、none_of</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-if-not"><span class="nav-number">8.5.2.</span> <span class="nav-text">find_if_not</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy-if"><span class="nav-number">8.5.3.</span> <span class="nav-text">copy_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iota"><span class="nav-number">8.5.4.</span> <span class="nav-text">iota</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minmax-element"><span class="nav-number">8.5.5.</span> <span class="nav-text">minmax_element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#is-sorted%E5%92%8Cis-sorted-until"><span class="nav-number">8.5.6.</span> <span class="nav-text">is_sorted和is_sorted_until</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-11%E6%94%B9%E8%BF%9B%E6%88%91%E4%BB%AC%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">C++11改进我们的模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.1.</span> <span class="nav-text">改进单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.2.</span> <span class="nav-text">改进观察者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.3.</span> <span class="nav-text">改进访问者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.4.</span> <span class="nav-text">改进命令模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.5.</span> <span class="nav-text">改进对象池模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8C-11%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">10.</span> <span class="nav-text">使用C++11实现一个半同步半异步线程池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-11%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84AOP%E6%A1%86%E6%9E%B6"><span class="nav-number">11.</span> <span class="nav-text">C++11实现一个轻量级的AOP框架</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8C-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84IoC%E5%AE%B9%E5%99%A8"><span class="nav-number">12.</span> <span class="nav-text">使用C++开发一个轻量级的IoC容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">12.1.</span> <span class="nav-text">IoC创建对象</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuhao0102" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuhao0102" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuhhpc0203@gmail.com" title="E-Mail → mailto:yuhhpc0203@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
