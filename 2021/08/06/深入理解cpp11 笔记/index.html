<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="新标准的诞生C++11语言变化的领域C++11相对于C++98&#x2F;03有哪些显著的增强呢?事实上，这包括以下几点：  通过内存模型、线程、原子操作等来支持本地并行编程( Native Concurrency )。 通过统一.初始化表达式、auto、declytype、移动语义等来统一对泛型编程的支持。 通过constexpr、POD (概念)等更好地支持系统编程。 通过内联命名空间、继承构造函数和右">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解C++11：C++11新特性解析与应用 笔记">
<meta property="og:url" content="http://yoursite.com/2021/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3cpp11%20%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="新标准的诞生C++11语言变化的领域C++11相对于C++98&#x2F;03有哪些显著的增强呢?事实上，这包括以下几点：  通过内存模型、线程、原子操作等来支持本地并行编程( Native Concurrency )。 通过统一.初始化表达式、auto、declytype、移动语义等来统一对泛型编程的支持。 通过constexpr、POD (概念)等更好地支持系统编程。 通过内联命名空间、继承构造函数和右">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1628403398.jpg">
<meta property="og:image" content="http://yoursite.com/img/1628403417.jpg">
<meta property="og:image" content="http://yoursite.com/img/1628477156.jpg">
<meta property="og:image" content="http://yoursite.com/img/1628492956.jpg">
<meta property="og:image" content="http://yoursite.com/img/1628501072.jpg">
<meta property="og:image" content="http://yoursite.com/img/1628912842.jpg">
<meta property="article:published_time" content="2021-08-06T06:14:00.000Z">
<meta property="article:modified_time" content="2022-01-02T03:18:05.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1628403398.jpg">

<link rel="canonical" href="http://yoursite.com/2021/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3cpp11%20%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>深入理解C++11：C++11新特性解析与应用 笔记 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3cpp11%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解C++11：C++11新特性解析与应用 笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-06 14:14:00" itemprop="dateCreated datePublished" datetime="2021-08-06T14:14:00+08:00">2021-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-02 11:18:05" itemprop="dateModified" datetime="2022-01-02T11:18:05+08:00">2022-01-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="新标准的诞生"><a href="#新标准的诞生" class="headerlink" title="新标准的诞生"></a>新标准的诞生</h1><h2 id="C-11语言变化的领域"><a href="#C-11语言变化的领域" class="headerlink" title="C++11语言变化的领域"></a>C++11语言变化的领域</h2><p>C++11相对于C++98/03有哪些显著的增强呢?事实上，这包括以下几点：</p>
<ul>
<li>通过内存模型、线程、原子操作等来支持本地并行编程( Native Concurrency )。</li>
<li>通过统一.初始化表达式、auto、declytype、移动语义等来统一对泛型编程的支持。</li>
<li>通过constexpr、POD (概念)等更好地支持系统编程。</li>
<li>通过内联命名空间、继承构造函数和右值引用等，以更好地支持库的构建。</li>
</ul>
<p>表列出了C++11批准通过的，且本书将要涉及的语言特性。<br><img src="/img/1628403398.jpg" alt=""><br><img src="/img/1628403417.jpg" alt=""></p>
<h2 id="与硬件紧密合作"><a href="#与硬件紧密合作" class="headerlink" title="与硬件紧密合作"></a>与硬件紧密合作</h2><p>在C++11中，常量表达式以及原子操作都是可以用于支持嵌人式编程的重要特性。这些特性对于提高性能、降低存储空间都大有好处，比如ROM。C++98/03中也具备const类型，不过它对只读内存(ROM)支持得不够好。这是因为在C++中const类型只在初始化后才意味着它的值应该是常量表达式，从而在运行时不能被改变。不过由于初始化依旧是动态的，这对ROM设备来说并不适用。这就要求在动态初始化前就将常量计算出来。为此标准增加了constexpr，它让函数和变量可以被编译时的常量取代。</p>
<p>C++11 通过引入内存模型，为开发者和系统建立了一个高效的同步机制。作为开发者，通常需要保证线程程序能够正确同步，在程序中不会产生竞争。而相对地，系统(可能是编译器、内存系统，或是缓存一致性机制)则会保证程序员编写的程序(使用原子类型)不会引入数据竞争。而且为了同步，系统会自行禁止某些优化，又保证其他的一些优化有效。除非编写非常底层的并行程序，否则系统的优化对程序员来讲，基本上是透明的。这可能是C++11中最大、最华丽的进步。</p>
<p>就算程序员不乐意使用原子类型，而要使用线程，那么使用标准的互斥变量mutex来进行临界区的加锁和开锁也就够了。而如果读者还想要疯狂地挖掘并行的速度，或试图完全操控底层，或想找点麻烦，那么无锁( lock-free)的原子类型也可以满足你的各种“野心”。内存模型的机制会保证你不会犯错。只有在使用与系统内存单位不同的位域的时候，内存模型才无法成功地保证同步。比如说下面这个位域的例子，这样的位域常常会引发竞争(跨了一个内存单元)，因为这破坏了内存模型的假定，编译器不能保证这是没有竞争的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">int</span> a:<span class="number">9</span>; <span class="type">int</span> b:<span class="number">7</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过如果使用下面的字符位域则不会引发竞争，因为字符位域可以被视为是独立内存位置。而在C++98/03 中，多线程程序中该写法却通常会引发竞争。这是因为编译器可能将a和b连续存放，那么对b进行赋值(互斥地)的时候就有可能在a没有被上锁的情况下一起写掉了。原因是在单线程情况下常被视为普通的安全的优化，却没有考虑到多线程情况下的复杂性。C++11 则在这方面做出了较好的修正。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">char</span> a; <span class="type">char</span> b;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="融入编程现实"><a href="#融入编程现实" class="headerlink" title="融入编程现实"></a>融入编程现实</h2><p>如今GNU的属性( attribute)几乎无所不在，所有的编译器都在尝试支持它，以用于修饰类型、变量和函数等。不过<code>__attribute__((attribute-name))</code>这样的写法，除了不怎么好看外，每一个编译器可能还都有它自己的变体，比如微软的属性就是以<code>__declspec</code>打头的。因此在C++11中，我们看到了通用属性的出现。</p>
<p>不过C++11引入通用属性更大的原因在于，属性可以在不引入额外的关键字的情况下，为编译提供额外的信息。因此，一些可以实现为关键字的特性，也可以用属性来实现。C++11标准最终选择创建很少的几个通用属性，<code>noreturn</code>和<code>carrier_dependency</code>(其实final、override也一度是热门“人选” )。</p>
<h1 id="保证稳定性和兼容性"><a href="#保证稳定性和兼容性" class="headerlink" title="保证稳定性和兼容性"></a>保证稳定性和兼容性</h1><p>作为C语言的嫡亲，C++有一个众所周知的特性——对C语言的高度兼容。</p>
<h2 id="保持与C99兼容"><a href="#保持与C99兼容" class="headerlink" title="保持与C99兼容"></a>保持与C99兼容</h2><p>虽然C语言发展中的大多数改进都被引入了C++语言标准中，但还是存在着一些属于C99标准的“漏网之鱼”。所以C++11将对以下C99特性的支持也都纳入了新标准中：</p>
<ul>
<li>C99中的预定义宏</li>
<li><code>__func__</code>预定义标识符</li>
<li><code>_Pragma</code>操作符</li>
<li>不定参数宏定义以及<code>__VA_ARGS__</code></li>
<li>宽窄字符串连接</li>
</ul>
<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>相较于C89标准，C99语言标准增加一些预定义宏。C++11 同样增加了对这些宏的支持。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__STDC_HOSTED__</code></td>
<td>如果编译器的目标系统环境中包含完整的标准C库，那么这个宏就定义为1，否则宏的值为0</td>
</tr>
<tr>
<td><code>__STDC__</code></td>
<td>C编译器通常用这个宏的值来表示编译器的实现是否和C标准一致。 C++11标准中这个宏是否定义以及定成什么值由编译器来决定</td>
</tr>
<tr>
<td><code>__STDC_VERSION__</code></td>
<td>C编译器通常用这个宏来表示所支持的C标准的版本，比如1999mmL。C++11 标准中这个宏是否定义以及定成什么值将由编译器来决定</td>
</tr>
<tr>
<td><code>__STDC_ISO_10646__</code></td>
<td>这个宏通常定义为一个yyymmL格式的整数常量，例如199712L，用来表示C++编译环境符合某个版本的ISO/IEC 10646标准</td>
</tr>
</tbody>
</table>
</div>
<p>使用这些宏，我们可以查验机器环境对C标准和C库的支持状况，如代码所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Standard Clib:&quot;</span> &lt;&lt; __STDC_HOSTED__&lt;&lt; endl;</span><br><span class="line">    <span class="comment">// Standard Clib: 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ISO/IEC&quot;</span> &lt;&lt; __STDC_ISO_10646__&lt;&lt; endl ;</span><br><span class="line">    <span class="comment">// ISO/IEC 200009</span></span><br><span class="line">    <span class="comment">//编译选项：g++ -std=c++11 2-1-1.cpp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>预定义宏对于多目标平台代码的编写通常具有重大意义。通过以上的宏，程序员通过使用<code>#ifdef/#endif</code>等预处理指令，就可使得平台相关代码只在适合于当前平台的代码上编译，从而在同一套代码中完成对多平台的支持。从这个意义上讲，平台信息相关的宏越丰富，代码的多平台支持越准确。不过值得注意的是，与所有预定义宏相同的，如果用户重定义(<code>#define</code>)或<code>#undef</code>了预定义的宏，那么后果是“未定义”的。因此在代码编写中，程序员应该注意避免自定义宏与预定义宏同名的情况。</p>
<h3 id="func预定义标识符"><a href="#func预定义标识符" class="headerlink" title="func预定义标识符"></a><strong>func</strong>预定义标识符</h3><p>很多现实的编译器都支持C99标准中的<code>__func__</code>预定义标识符功能，其基本功能就是返回所在函数的名字。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __func__; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">world</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __func__; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">hello</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">world</span>() &lt;&lt; endl; <span class="comment">// hello, world</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-1-2.ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>按照标准定义，编译器会隐式地在函数的定义之后定义<code>__func__</code>标识符。比如上述例子中的hello函数，其实际的定义等同于如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* __func__= <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> __func__;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__func__</code>预定义标识符对于轻量级的调试代码具有十分重要的作用。而在C++11中，标准甚至允许其使用在类或者结构体中。我们可以看看下面这个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestStruct</span> &#123;</span><br><span class="line">    <span class="built_in">TestStruct</span> () : <span class="built_in">name</span>(__func__) &#123;&#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Teststruct ts;</span><br><span class="line">    cout &lt;&lt; ts.name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TestStruct</span></span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-1-3.ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>在结构体的构造函数中，初始化成员列表使用<code>__func__</code>预定义标识符是可行的，其效果跟在函数中使用一样。不过将<code>__fun__</code>标识符作为函数参数的默认值，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FuncFail</span><span class="params">(string func_name = __func__)</span> </span>&#123; &#125;; <span class="comment">// 无法通过编译</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Pragma-操作符"><a href="#Pragma-操作符" class="headerlink" title="_Pragma 操作符"></a>_Pragma 操作符</h3><p>在C/C++标准中，<code>#pragma</code>是预处理的指令(preprocessor directive)。简单地说，#pragma是用来向编译器传达语言标准以外的一些信息。举个简单的例子，如果我们在代码的头文件中定义了以下语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure></p>
<p>那么该指令会指示编译器(如果编译器支持)，该头文件应该只被编译一次。这与使用如下代码来定义头文件所达到的效果是一样的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THIS_HEADER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THIS_HEADER</span></span><br><span class="line"><span class="comment">//一些头文件的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>在C++11中，标准定义了与预处理指令<code>#pragma</code>功能相同的操作符<code>_Pragma</code>。<code>_Pragma</code>操作符的格式如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">_Pragma</span> ( 字符串字面量)</span><br></pre></td></tr></table></figure></p>
<p>其使用方法跟sizeof等操作符一样，将字符串字面量作为参数写在括号内即可。那么要达到与上例<code>#pragma</code>类似的效果，则只需要如下代码即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">_Pragma</span> (<span class="string">&quot;once&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>而相比预处理指令<code>#pragma</code>，由于<code>_Pragma</code>是一个操作符，因此可以用在一些宏中。我们可以看看下面这个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONCAT(x) PRAGMA (concat on #x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRAGMA(x) <span class="keyword">_Pragma</span> (#x)</span></span><br><span class="line"><span class="built_in">CONCAT</span>( ..\concat.dir )</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>CONCAT( ..\concat.dir )</code>最终会产生<code>_Pragma(concat on &quot;..\concat.dir&quot;)</code>这样的效果(这里只是显示语法效果，应该没有编译器支持这样的<code>_Pragma</code>语法)。而<code>#pragma</code>则不能在宏中展开，因此从灵活性上来讲，C++11的<code>_Pragma</code>具有更大的灵活性。</p>
<h3 id="变长参数的宏定义以及-VA-ARGS"><a href="#变长参数的宏定义以及-VA-ARGS" class="headerlink" title="变长参数的宏定义以及 VA_ARGS"></a>变长参数的宏定义以及 <strong>VA_ARGS</strong></h3><p>在C99标准中，程序员可以使用变长参数的宏定义。变长参数的宏定义是指在宏定义中参数列表的最后一个参数为省略号，而预定义宏<code>__VA_ARGS__</code>则可以在宏定义的实现部分替换省略号代表的字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PR(...) printf(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure></p>
<p>就可以定义一个printf的别名PR。事实上，变长参数宏与printf是好搭档：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(...) &#123;\</span></span><br><span class="line"><span class="meta">    fprintf (stderr, <span class="string">&quot;%s: Line %d:\t&quot;</span>，__FILE__, __LINE__); \</span></span><br><span class="line"><span class="meta">    fprintf (stderr, __VA_ARGS__); \</span></span><br><span class="line"><span class="meta">    fprintf (stderr, <span class="string">&quot;\n&quot;</span>); \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//一些代码</span></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;x = &amp;d&quot;</span>, x); <span class="comment">// 2-1-5.cpp: Line 12:    X=3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-1-5.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>定义LOG宏用于记录代码位置中一些信息。程序员可以根据stderr产生的日志追溯到代码中产生这些记录的位置。这样的特性对于轻量级调试，简单的错误输出都是具有积极意义的。</p>
<h2 id="long-long整型"><a href="#long-long整型" class="headerlink" title="long long整型"></a>long long整型</h2><p>相比于C++98标准，C++11整型的最大改变就是多了long long。long long整型有两种：long long和unsigned long long。在C++11中，标准要求long long整型可以在不同平台上有不同的长度，但至少有64位。我们在写常数字面量时，可以使用LL后缀(或是ll)标识一个long long类型的字面量，而ULL (或ull、Ull、uLL)表示一个unsigned long long类型的字面量。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> lli = <span class="number">-9000000000000000000LL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ulli = - <span class="number">900000000000000000ULL</span>;</span><br></pre></td></tr></table></figure></p>
<p>就定义了一个有符号的long long变量<code>lli</code>和无符号的unsigned long long变量<code>ulli</code>。事实上，在C++11中，还有很多与long long等价的类型。比如对于有符号的，下面的类型是等价的：<code>long long</code>、<code>signed long long</code>、<code>long long int</code>、<code>signed long long int</code>；而<code>unsigned long long</code>和<code>unsigned long long int</code>也是等价的。</p>
<p>同其他的整型一样，要了解平台上<code>long long</code>大小的方法就是查看<code>&lt;climits&gt;</code> (或<code>&lt;limits.h&gt;</code>中的宏)。与<code>long long</code>整型相关的一共有3个：<code>LLONG_MIN</code>、<code>LLONG_MAX</code>和<code>ULLONG_MIN</code>，它们分别代表了平台上最小的long long值、最大的long long值，以及最大的unsigned long long值。</p>
<h2 id="扩展的整型"><a href="#扩展的整型" class="headerlink" title="扩展的整型"></a>扩展的整型</h2><p>程序员常会在代码中发现一些整型的名字，比如<code>UINT</code>、<code>__int16</code>、<code>u64</code>、<code>int64_t</code>等等。这些类型有的源自编译器的自行扩展，有的则是来自某些编程环境(比如工作在Linux内核代码中)，不一而足。而事实上，在C++11中一共只定义了以下5种标准的有符号整型：</p>
<ul>
<li><code>signed char</code></li>
<li><code>short int</code></li>
<li><code>int</code></li>
<li><code>long int</code></li>
<li><code>long long int</code></li>
</ul>
<p>标准同时规定，每一种有符号整型都有一种对应的无符号整数版本，且有符号整型与其对应的无符号整型具有相同的存储空间大小。比如与signed int对应的无符号版本的整型是unsigned int。</p>
<p>在实际的编程中，由于这5种基本的整型适用性有限，所以有时编译器出于需要，也会自行扩展一些整型。在C++11中，标准对这样的扩展做出了一些规定。具体地讲，除了标准整型( standard integer type)之外，C++11 标准允许编译器扩展自有的所谓扩展整型(extended integer type)。这些扩展整型的长度(占用内存的位数)可以比最长的标准整型(long long int，通常是一个64位长度的数据)还长，也可以介于两个标准整数的位数之间。比如在128位的架构上，编译器可以定义一个扩展整型来对应128位的的整数。</p>
<p>简单地说，C++11 规定，扩展的整型必须和标准类型一样，有符号类型和无符号类型占用同样大小的内存空间。而由于C/C++是一种弱类型语言，当运算、传参等类型不匹配的时候，整型间会发生隐式的转换，这种过程通常被称为整型的提升( Integral promotion)。 比如如下表达式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>) a + (<span class="type">long</span> <span class="type">long</span>)b</span><br></pre></td></tr></table></figure></p>
<p>通常就会导致变量<code>(int)a</code>被提升为<code>long long</code>类型后才与<code>(long long)b</code>进行运算。而无论是扩展的整型还是标准的整型，其转化的规则会由它们的“等级”(rank)决定。而通常情况，我们认为有如下原则：</p>
<ul>
<li>长度越大的整型等级越高，比如long long int的等级会高于int。</li>
<li>长度相同的情况下，标准整型的等级高于扩展类型，比如long long int 和int64如果都是64位长度，则long long int类型的等级更高。</li>
<li>相同大小的有符号类型和无符号类型的等级相同，long long int和unsigned longlong int的等级就相同。</li>
</ul>
<p>而在进行隐式的整型转换的时候，一般是按照低等级整型转换为高等级整型，有符号的转换为无符号。这种规则其实跟C++98的整型转换规则是一致的。</p>
<p>在一个128位的构架上，编译器可以定义<code>__int128_t</code>为128位的有符号整型(对应的无符号类型为<code>_uint128_t</code>)。于是程序员可以使用<code>_int128_t</code>类型保存形如+92233720368547758070的超长整数(长于64位的自然数)。而不用查看编译器文档我们也会知道，一旦遇到整型提升，按照上面的规则，比如<code>_int128_t a</code>，与任何短于它的类型的数据b进行运算(比如加法)时，都会导致b被隐式地转换为<code>_int128_t</code>的整型，因为扩展的整型必须遵守C++11的规范。</p>
<h2 id="宏-cplusplus"><a href="#宏-cplusplus" class="headerlink" title="宏__cplusplus"></a>宏__cplusplus</h2><p>在C与C++混合编写的代码中，我们常常会在头文件里看到如下的声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//一些代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这种类型的头文件可以被<code>#include</code>到C文件中进行编译，也可以被<code>#include</code>到C++文件中进行编译。由于<code>extern &quot;C&quot;</code>可以抑制C++对函数名、变量名等符号( symbol)进行名称重整( name mangling)，因此编译出的C目标文件和C++目标文件中的变量、函数名称等符号都是相同的(否则不相同)，链接器可以可靠地对两种类型的目标文件进行链接。这样该做法成为了C与C++混用头文件的典型做法。</p>
<p>鉴于以上的做法，程序员可能认为<code>__cplusplus</code>这个宏只有“被定义了”和“未定义”两种状态。事实上却并非如此，<code>__cplusplus</code>这个宏通常被定义为一个整型值。而且随着标准变化，<code>_cplusplus</code>宏会是一个比以往标准中更大的值。比如在C++03标准中，<code>__cplusplus</code>的值被预定为199711L，而在C++11标准中，宏<code>__cplusplus</code>被预定义为201103L。这点变化可以为代码所用。比如程序员在想确定代码是使用支持C++11编译器进行编译时，那么可以按下面的方法进行检测：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &lt; 201103L</span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> <span class="string">&quot;should use C++11 implementat ion”</span></span></span><br><span class="line"><span class="string"><span class="meta">#endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里，使用了预处理指令<code>#error</code>，这使得不支持C++11的代码编译立即报错并终止编译。读者可以使用C++98编译器和C++11的编译器分别实验一下其效果。</p>
<h2 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h2><h3 id="断言：运行时与预处理时"><a href="#断言：运行时与预处理时" class="headerlink" title="断言：运行时与预处理时"></a>断言：运行时与预处理时</h3><p>断言(assertion)是一种编程中常用的手段。在通常情况下，断言就是将一个返回值总是需要为真的判别式放在语句中，用于排除在设计的逻辑上不应该产生的情况。比如一个函数总需要输入在一定的范围内的参数，那么程序员就可以对该参数使用断言，以迫使在该参数发生异常的时候程序退出，从而避免程序陷入逻辑的混乱。</p>
<p>从一些意义.上讲，断言并不是正常程序所必需的，不过对于程序调试来说，通常断言能够帮助程序开发者快速定位那些违反了某些前提条件的程序错误。在C++中，标准在<code>&lt;cassert&gt;</code>或<code>&lt;assert.h&gt;</code>头文件中为程序员提供了assert宏，用于在运行时进行断言。我们可以看看下面这个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//一个简单的堆内存数组分配函数</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">ArrayAlloc</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt; <span class="number">0</span>); <span class="comment">// 断言，n必须大于0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">char</span> [n] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* a = <span class="built_in">ArrayAlloc</span>(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-5-1. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中，我们定义了一个<code>ArrayAlloc</code>函数，该函数的唯一功能就是在堆上分配字节长度为n的数组并返回。为了避免意外发生，函数ArrayAlloc对参数n进行了断言，要求其大于0。而<code>main</code>函数中对<code>ArrayAlloc</code>的使用却没有满足这个条件，那么在运行时，我们可以看到如下结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.out: 2-5-1.cpp:6: char* ArrayAlloc(int): Assertion : <span class="string">&#x27;n &gt; 0&#x27;</span> failed.</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure></p>
<p>在C++中，程序员也可以定义宏NDEBUG来禁用assert宏。这对发布程序来说还是必要的。因为程序用户对程序退出总是敏感的，而且部分的程序错误也未必会导致程序全部功能失效。那么通过定义NDEBUG宏发布程序就可以尽量避免程序退出的状况。而当程序有问题时，通过没有定义宏NDEBUG的版本，程序员则可以比较容易地找到出问题的位置。</p>
<p>事实上，<code>assert</code>宏在<code>&lt;cassert&gt;</code>中的实现方式类似于下列形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> assert (expr) (static_cast<span class="string">&lt;void&gt;</span> (0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，一旦定义了NDBUG宏，<code>assert</code>宏将被展开为一条无意义的C语句(通常会被编译器优化掉)。</p>
<h3 id="静态断言与static-assert"><a href="#静态断言与static-assert" class="headerlink" title="静态断言与static_assert"></a>静态断言与static_assert</h3><p>断言<code>assert</code>宏只有在程序运行时才能起作用。而<code>#error</code>只在编译器预处理时才能起作用。有的时候，我们希望在编译时能做一些断言。 比如下面这个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//枚举编译器对各种特性的支持，每个枚举值占一位</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">FeatureSupports</span> &#123;</span><br><span class="line">    C99      = <span class="number">0x0001</span>,</span><br><span class="line">    ExtInt   = <span class="number">0x0002</span>,</span><br><span class="line">    SAssert  = <span class="number">0x0004</span>,</span><br><span class="line">    NoExcept = <span class="number">0x0008</span>,</span><br><span class="line">    SMAX     = <span class="number">0x0010</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个编译器类型，包括名称、特性支持等</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name ; </span><br><span class="line">    <span class="type">int</span> spp;  <span class="comment">// 使用FeatureSupports枚举</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查枚举值是否完备</span></span><br><span class="line">    <span class="built_in">assert</span>( (SMAX - <span class="number">1</span>) == (C99| ExtInt| SAssert| NoExcept)) ;</span><br><span class="line">    Compiler a = &#123;<span class="string">&quot;abc&quot;</span>, (C99| SAssert) &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (a.spp &amp; C99) &#123;</span><br><span class="line">        <span class="comment">//一些代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-5-2. cpp .</span></span><br></pre></td></tr></table></figure></p>
<p>在该例中，我们编写了一个枚举类型<code>FeatureSupports</code>，用于列举编译器对各种特性的支持。而结构体Compiler则包含了一个int类型成员spp。由于各种特性都具有“支持”和“不支持”两种状态，所以为了节省存储空间，我们让每个<code>FeatureSupports</code>的枚举值占据一个特定的比特位置，并在使用时通过“或”运算压缩地存储在Compiler的spp成员中( 即<code>bitset</code>的概念)。在使用时，则可以通过检查spp的某位来判断编译器对特性是否支持。</p>
<p>有的时候这样的枚举值会非常多，而且还会在代码维护中不断增加。那么代码编写者必须想出办法来对这些枚举进行校验，比如查验一下 是否有重位等。在本例中程序员的做法是使用一个“最大枚举”<code>SMAX</code>，并通过比较<code>SMAX - 1</code>与所有其他枚举的或运算值来验证是否有枚举值重位。可以想象，如果<code>SAssert</code>被误定义为<code>0x0001</code>，表达式<code>(SMAX- 1) == (C99 | ExtInt | SAssert | NoExcept)</code>将不再成立。</p>
<p>在本例中我们使用了断言assert。但assert是一个运行时的断言，这意味着不运行程序我们将无法得知是否有枚举重位。在一些情况下，这是不可接受的，因为可能单次运行代码并不会调用到assert相关的代码路径。因此这样的校验最好是在编译时期就能完成。在一些C++的模板的编写中，我们可能也会遇到相同的情况，比如下面这个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T，<span class="keyword">typename</span> U&gt; <span class="function"><span class="type">int</span> <span class="title">bit_copy</span><span class="params">(T&amp; a, U&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span> (<span class="built_in">sizeof</span>(b) == <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;a, &amp;b, <span class="built_in">sizeof</span> (b));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x2468</span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> b</span></span><br><span class="line"><span class="function">    <span class="title">bit_copy</span><span class="params">(a, b)</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-5-3. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>代码中的assert是要保证a和b两种类型的长度一致，这样<code>bit_copy</code>才能够保证复制操作不会遇到越界等问题。这里我们还是使用assert的这样的运行时断言，但如果<code>bit_copy</code>不被调用，我们将无法触发该断言。实际上，正确产生断言的时机应该在模板实例化时，即编译时期。</p>
<p>利用语言规则实现静态断言的讨论非常多，比较典型的实现是开源库Boost内置的<code>BOOST_STATIC_ASSERT</code>断言机制( 利用sizeof操作符)。我们可以利用“除0”会导致编译器报错这个特性来实现静态断言。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> assert_static(e) \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">    enum &#123; assert_static__= 1/(e) &#125;; \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure></p>
<p>在理解这段代码时，读者可以忽略do while循环以及enum这些语法上的技巧。真正起作用的只是<code>1/(e)</code>这个表达式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T，<span class="keyword">typename</span> U&gt; <span class="function"><span class="type">int</span> <span class="title">bit_copy</span><span class="params">(T&amp; a, U&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert_static</span>(<span class="built_in">sizeof</span>(b) == <span class="built_in">sizeof</span>(a)) ;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;a, &amp;b, <span class="built_in">sizeof</span>(b)) ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x2468</span>;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="built_in">bit_copy</span>(a, b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-5-4. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>结果如我们预期的，在模板实例化时我们会得到编译器的错误报告，读者可以实验一下在自己本机运行的结果。在我们的实验机上会输出比较长的错误信息，主要信息是除零错误。当然，读者也可以尝试一下Boost库内置的<code>BOOST_STATIC_ASSERT</code>，输出的主要信息是<code>sizeof</code>错误。但无论是哪种方式的静态断言，其缺陷都是很明显的：诊断信息不够充分，不熟悉该静态断言实现的程序员可能一时无法将错误对应到断言错误上，从而难以准确定位错误的根源。</p>
<p>在C++11标准中，引入了<code>static_assert</code>断言来解决这个问题。<code>static_assert</code>使用起来非常简单，它接收两个参数，一个是断言表达式，这个表达式通常需要返回一个bool值；一个则<br>是警告信息，它通常也就是一段字符串。我们可以用<code>static_assert</code>替换一下代码中<code>bit_copy</code>的声明。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> t, <span class="keyword">typename</span> u&gt; <span class="function"><span class="type">int</span> <span class="title">bit_copy</span><span class="params">(t&amp; a, u&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span> (<span class="built_in">sizeof</span>(b) == <span class="built_in">sizeof</span> (a) , <span class="string">&quot;the parameters of bit_copy must have same width.&quot;</span>) ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么再次编译代码清单2-9的时候，我们就会得到如下信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: static assertion failed: <span class="string">&quot;the parameters of bit_copy should have same width. &quot;</span></span><br></pre></td></tr></table></figure></p>
<p>这样的错误信息就非常清楚，也非常有利于程序员排错。而由于<code>static_assert</code>是编译时期的断言，其使用范围不像assert一样受到限制。在通常情况下，<code>static_assert</code>可以用于任何名字空间，如代码所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) == <span class="number">8</span>，<span class="string">&quot;This 64-bit machine should follow this!&quot;</span>) ;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=C++11 2-5-5.ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>而在C++中，函数则不可能像代码中的<code>static_assert</code>这样独立于任何调用之外运行。因此将<code>static_assert</code>写在函数体外通常是较好的选择，这让代码阅读者可以较容易发现<code>static_assert</code>为断言而非用户定义的函数。而反过来讲，必须注意的是，<code>static_assert</code>的断言表达式的结果必须是在编译时期可以计算的表达式，即必须是常量表达式。如果读者使用<br>了变量，则会导致错误，如代码所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">positive</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(n &gt; <span class="number">0</span>，<span class="string">&quot;value must &gt;0&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=C++11 -c 2-5-6. ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>代码使用了参数变量<code>n</code>(虽然是个const参数)，因而<code>static_assert</code>无法通过编译。对于此例，如果程序员需要的只是运行时的检查，那么还是应该使用assert宏。</p>
<h2 id="noexcept修饰符与noexcept操作符"><a href="#noexcept修饰符与noexcept操作符" class="headerlink" title="noexcept修饰符与noexcept操作符"></a>noexcept修饰符与noexcept操作符</h2><p>相比于断言适用于排除逻辑上不可能存在的状态，异常通常是用于逻辑上可能发生的错误。在C++98中，我们看到了一套完整的不同于C的异常处理系统。通过这套异常处理系统，C++拥有了远比C强大的异常处理功能。</p>
<p>在异常处理的代码中，程序员有可能看到过如下的异常声明表达形式：.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">excpt_func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>excpt_func</code>函数声明之后，我们定义了一个动态异常声明<code>throw(int, double)</code>，该声明指出了<code>excpt_func</code>可能抛出的异常的类型。事实上，该特性很少被使用，因此在C++11中被弃用了，而表示函数不会抛出异常的动态异常声明<code>throw()</code>也被新的<code>noexcept</code>异常声明所取代。</p>
<p><code>noexcept</code>表示其修饰的函数不会抛出异常。不过与<code>throw()</code>动态异常声明不同的是，在C++11中如果<code>noexcept</code>修饰的函数抛出了异常，编译器可以选择直接调用<code>std:terminate()</code>函数来终止程序的运行，这比基于异常机制的<code>throw()</code>在效率上会高一些。</p>
<p>从语法上讲，<code>noexcept</code>修饰符有两种形式，一种就是简单地在函数声明后加上<code>noexcept</code>关键字。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">excpt_func</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>; .</span><br></pre></td></tr></table></figure></p>
<p>另外一种则可以接受一个常量表达式作为参数，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">excpt_func</span><span class="params">()</span> <span class="title">noexcept</span> <span class="params">( 常量表达式)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>常量表达式的结果会被转换成一个bool类型的值。该值为true，表示函数不会抛出异常，反之，则有可能抛出异常。这里，不带常量表达式的<code>noexcept</code>相当于声明了<code>noexcept(true)</code>，即不会抛出异常。</p>
<p>在通常情况下，在C++11中使用<code>noexcept</code>可以有效地阻止异常的传播与扩散。我们可以看看下面这个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Throw</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NoBlockThrow</span><span class="params">()</span> </span>&#123; <span class="built_in">Throw</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockThrow</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">Throw</span>() ;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">Throw</span>() ;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found throw.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// Found throw.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">NoBlockThrow</span>() ;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Throw is not blocked.&quot;</span> &lt;&lt; endl ;</span><br><span class="line">        <span class="comment">// Throw is not blocked .</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">BlockThrow</span>(); <span class="comment">// terminate called after throwing an instance of &#x27; int &#x27;</span></span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found throw 1.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译选项：g++ -std=c++11 2-6-1. ccpp .</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中，我们定义了<code>Throw</code>函数，该函数的唯一作用是抛出一个异常。而<code>NoBlockThrow</code>是一个调用<code>Throw</code>的普通函数，<code>BlockThrow</code>则是一个<code>noexcept</code>修饰的函数。从main的运行中我们可以看到，<code>NoBlockThrow</code>会让<code>Throw</code>函数抛出的异常继续抛出，直到main中的catch语句将其捕捉。而<code>BlockThrow</code>则会直接调用<code>std::terminate</code>中断程序的执行，从而阻止了异常的继续传播。从使用效果上看，这与C++98中的<code>throw()</code>是一样的。</p>
<p>而<code>noexcept</code>作为一个操作符时，通常可以用于模板。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">noexcept</span> <span class="params">(<span class="keyword">noexcept</span> (T()))</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>fun</code>函数是否是一个<code>noexcept</code>的函数，将由<code>T()</code>表达式是否会抛出异常所决定。这里的第二个<code>noexcept</code>就是一个<code>noexcept</code>操作符。当其参数是一个有可能抛出异常的表达式的时候，其返回值为false，反之为true。这样一来，我们就可以使模板函数根据条件实现<code>noexcept</code>修饰的版本或无<code>noexcept</code>修饰的版本。从泛型编程的角度看来，这样的设计保证了关于“ 函数是否抛出异常”这样的问题可以通过表达式进行推导。因此这也可以视作C++11为了更好地支持泛型编程而引入的特性。</p>
<p>虽然<code>noexcept</code>修饰的函数通过<code>std::terminate</code>的调用来结束程序的执行的方式可能会带来很多问题，比如无法保证对象的析构函数的正常调用，无法保证栈的自动释放等，但很多时候，“暴力”地终止整个程序确实是很简单有效的做法。比如在C++98中，存在着使用<code>throw()</code>来声明不抛出异常的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> T <span class="title">min</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">T</span>() ; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> T <span class="title">max</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">T</span>() ;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> T <span class="title">lowest</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">T</span>() ;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在C++11中，则使用<code>noexcept</code>来替换<code>throw()</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> T <span class="title">min</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">T</span>() ; &#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> T <span class="title">max</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">T</span>() ; &#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> T <span class="title">lowest</span><span class="params">()</span> <span class="keyword">noexcept</span></span>&#123; <span class="keyword">return</span> <span class="built_in">T</span>(); &#125;</span><br></pre></td></tr></table></figure></p>
<p>又比如，在C++98中，<code>new</code>可能会包含一些抛出的<code>std::bad_alloc</code> 异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[] (std::<span class="type">size_t</span>) <span class="built_in">throw</span>(std::bad_alloc) ;</span><br></pre></td></tr></table></figure></p>
<p>而在C++11中，则使用<code>noexcept(false)</code>来进行替代。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">noexcept</span> <span class="params">(<span class="literal">false</span>)</span> </span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[] (std::<span class="type">size_t</span>) <span class="built_in">noexcept</span> (<span class="literal">false</span>) ;</span><br></pre></td></tr></table></figure></p>
<p>当然，<code>noexcept</code>更大的作用是保证应用程序的安全。比如一个类析构函数不应该抛出异常，那么对于常被析构函数调用的<code>delete</code>函数来说，C++11默认将<code>delete</code>函数设置成<code>noexcept</code>，就可以提高应用程序的安全性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="type">void</span>*)</span> <span class="keyword">noexcept</span> </span>; </span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[] (<span class="type">void</span>*) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>而同样出于安全考虑，C++11 标准中让类的析构函数默认也是<code>noexcept(true)</code>的。当然，如果程序员显式地为析构函数指定了<code>noexcept</code>，或者类的基类或成员有<code>noexcept(false)</code>的析构函数，析构函数就不会再保持默认值。我们可以看看下面的例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; <span class="keyword">throw</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    ~<span class="built_in">B</span>() <span class="built_in">noexcept</span> (<span class="literal">false</span>) &#123; <span class="keyword">throw</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">funA</span><span class="params">()</span> </span>&#123; A a; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">funB</span><span class="params">()</span> </span>&#123; B b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">funC</span><span class="params">()</span> </span>&#123; C c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">funB</span>() ;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;caught funB.&quot;</span> &lt;&lt; endl; <span class="comment">// caught funB .</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">funC</span>() ;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;caught funC.&quot;</span> &lt;&lt; endl; <span class="comment">// caught funC.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">funA</span>(); <span class="comment">// terminate called after throwing an instance of &#x27;int&#x27;</span></span><br><span class="line">    &#125; <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;caught funA.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-6-2.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中，无论是析构函数声明为<code>noexcept(false)</code>的类B，还是包含了B类型成员的类C，其析构函数都是可以抛出异常的。只有什么都没有声明的类A，其析构函数被默认为<code>noexcept(true)</code>，从而阻止了异常的扩散。这在实际的使用中，应该引起程序员的注意。</p>
<h2 id="快速初始化成员变量"><a href="#快速初始化成员变量" class="headerlink" title="快速初始化成员变量"></a>快速初始化成员变量</h2><p>在C++98中，支持了在类声明中使用等号“=”加初始值的方式，来初始化类中静态成员常量。这种声明方式我们也称之为“就地”声明。就地声明在代码编写时非常便利，不过C++98对类中就地声明的要求却非常高。如果静态成员不满足常量性，则不可以就地声明，而且即使常量的静态成员也只能是整型或者枚举型才能就地初始化。而非静态成员变量的初始化则必须在构造函数中进行。我们来看看下面的例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Init</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init</span>(): <span class="built_in">a</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Init</span>(<span class="type">int</span> d): <span class="built_in">a</span>(d) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 成员，无法通过编译</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 成员，无法通过编译</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> e = <span class="number">1.3</span>;</span><br><span class="line">    <span class="comment">// 非整型或者枚举，无法通过编译</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> f = <span class="string">&quot;e&quot;</span>; <span class="comment">// 非整型或者枚举，无法通过编译</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译选项：g++ -c 2-7-1.ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中，成员c、静态成员d、静态常量成员e以及静态常量指针f的就地初始化都无法通过编译。在C++11中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在C++11中，标准还允许使用等号<code>=</code>或者花括号<code>&#123;&#125;</code>进行就地的非静态成员变量初始化。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">init</span>&#123; <span class="type">int</span> a = <span class="number">1</span>; <span class="type">double</span> b &#123;<span class="number">1.2</span>&#125;; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个名叫<code>init</code>的结构体中，我们给了非静态成员a和b分别赋予初值1和1.2。这在C++11中是一个合法的结构体声明。花括号式的集合(列表)初始化已经成为C++11中初始化声明的一种通用形式。不过在C++11中，对于非静态成员进行就地初始化，两者却并非等价的，如代码所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> i):<span class="built_in">c</span>(i)&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">init</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function">string <span class="title">b</span><span class="params">(<span class="string">&quot;he1lo&quot;</span>)</span></span>; <span class="comment">// 无法通过编译</span></span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//无法通过编译</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 -c 2-7-2. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看到，就地圆括号式的表达式列表初始化非静态成员b和c都会导致编译出错。在C++11标准支持了就地初始化非静态成员的同时，初始化列表这个手段也被保留下来了。如果两者都使用，是否会发生冲突呢?我们来看下面这个例子，如代码所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mem</span> &#123;</span><br><span class="line">    <span class="built_in">Mem</span>() &#123; cout &lt;&lt; <span class="string">&quot;Mem default, num: &quot;</span> &lt;&lt; num &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Mem</span>(<span class="type">int</span> i): <span class="built_in">num</span>(i) &#123; cout &lt;&lt; <span class="string">&quot;Mem, num: &quot;</span> &lt;&lt; num &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">2</span>; <span class="comment">// 使用=初始化非静态成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Group</span>() &#123; cout &lt;&lt; <span class="string">&quot;Group default. val:&quot;</span> &lt;&lt; val &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Group</span>(<span class="type">int</span> i): <span class="built_in">val</span>(<span class="string">&#x27;G&#x27;</span>), <span class="built_in">a</span>(i) &#123; cout &lt;&lt; <span class="string">&quot;Group. val: &quot;</span> &lt;&lt; val &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NumOfA</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;number of A:&quot;</span> &lt;&lt; a.num &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NumOfB</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;number of B:&quot;</span> &lt;&lt; b.num &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> val&#123;<span class="string">&#x27;g&#x27;</span>&#125;; <span class="comment">// 使用&#123;&#125;初始化非静态成员</span></span><br><span class="line">    Mem a;</span><br><span class="line">    Mem b&#123;<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="comment">//使用&#123;&#125;初始化非静态成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mem member;</span><br><span class="line">    <span class="comment">// Mem default, num: 2</span></span><br><span class="line">    Group group;</span><br><span class="line">    <span class="comment">// Mem default, num: 2</span></span><br><span class="line">    <span class="comment">// Mem， num: 1</span></span><br><span class="line">    <span class="comment">// Group default. val: g</span></span><br><span class="line">    group.<span class="built_in">NumOfA</span>() ;</span><br><span class="line">    <span class="comment">// number of A: 2</span></span><br><span class="line">    group.<span class="built_in">NumOfB</span>() ;</span><br><span class="line">    <span class="comment">// number of B: 19</span></span><br><span class="line">    <span class="function">Group <span class="title">group2</span><span class="params">(<span class="number">7</span>)</span> </span>;</span><br><span class="line">    <span class="comment">// Mem， num: 7</span></span><br><span class="line">    <span class="comment">// Mem, num: 1</span></span><br><span class="line">    <span class="comment">// Group. val: G</span></span><br><span class="line">    group<span class="number">2.</span><span class="built_in">NumOfA</span>() ;</span><br><span class="line">    <span class="comment">// number of A: 7</span></span><br><span class="line">    group<span class="number">2.</span><span class="built_in">NumOfB</span>() ;</span><br><span class="line">    <span class="comment">// number of B: 19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-7-3.ccpp -std=C++11 .</span></span><br></pre></td></tr></table></figure>
<p>在代码中，我们定义了有两个初始化函数的类Mem，此外还定义了包含两个Mem对象的Group类。类Mem中的成员变量num，以及classGroup中的成员变量a、b、val,采用了与C++98完全不同的初始化方式。</p>
<p>相对于传统的初始化列表，在类声明中对非静态成员变量进行就地列表初始化可以降低程序员的工作量。当然，我们只在有多个构造函数，且有多个成员变量的时候可以看到新方式带来的便利。</p>
<h2 id="非静态成员的sizeof"><a href="#非静态成员的sizeof" class="headerlink" title="非静态成员的sizeof"></a>非静态成员的sizeof</h2><p>在C++引入类(class) 类型之后， sizeof 的定义也随之进行了拓展。不过在C++98标准中，对非静态成员变量使用sizeof是不能够通过编译的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hand;</span><br><span class="line">    <span class="type">static</span> People *all;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    People P;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span> (p.hand) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// C++98 中通过，C++11 中通过</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span> (People::all) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// C++98中通过，C++11 中通过</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span> (People: :hand) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// C++98 中错误，C++11中通过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-8-1. ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>注意最后一个<code>sizeof</code>操作。在C++11中，对非静态成员变量使用<code>sizeof</code>操作是合法的。而在C++98中，只有静态成员，或者对象的实例才能对其成员进行<code>sizeof</code>操作。因此如果读者只有一个支持C++98标准的编译器，在没有定义类实例的时候，要获得类成员的大小，我们通常会采用以下的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span> (( (People*)<span class="number">0</span>) -&gt;hand) ;</span><br></pre></td></tr></table></figure></p>
<p>这里我们强制转换0为一个<code>People</code>类的指针，继而通过指针的解引用获得其成员变量，并用<code>sizeof</code>求得该成员变量的大小。而在C++11中，我们无需这样的技巧，因为<code>sizeof</code>可以作用的表达式包括了类成员表达式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span> (People::hand) ;</span><br></pre></td></tr></table></figure></p>
<h2 id="扩展的friend语法"><a href="#扩展的friend语法" class="headerlink" title="扩展的friend语法"></a>扩展的friend语法</h2><p>friend 关键字用于声明类的友元，友元可以无视类中成员的属性。C++11对friend关键字进行了一些改进。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Poly</span>;</span><br><span class="line"><span class="keyword">typedef</span> Poly P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiLei</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Poly</span>; <span class="comment">// C++98 通过，C++11 通过</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jim</span></span><br><span class="line">    <span class="keyword">friend</span> Poly;</span><br><span class="line"><span class="comment">// C++98 失败，C++11 通过</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HanMeiMei</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> P;</span><br><span class="line"><span class="comment">// C++98失败，C++11 通过</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=C++11 2-9-1.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中，我们声明了3个类型：LiLei、 Jim和HanMeiMei，它们都有一个友元类型Poly。从编译通过与否的状况中我们可以看出，在C++11中，声明一个类为另外一个类的友元时，不再需要使用class关键字。</p>
<p>我们使用Poly的别名P来声明友元，程序员借此可以为类模板声明友元。比如下面这个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br><span class="line">People&lt;P&gt; PP;</span><br><span class="line"><span class="comment">//类型P在这里是People类型的友元</span></span><br><span class="line">People&lt;<span class="type">int</span>&gt; Pi; <span class="comment">//对于int类型模板参数，友元声明被忽略</span></span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-9-2.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>从代码中我们看到，对于People这个模板类，在使用类P为模板参数时，P是<code>People&lt;P&gt;</code>的一个friend 类。而在使用内置类型int作为模板参数的时候，<code>People&lt;int&gt;</code>会被实例化为一个普通的没有友元定义的类型。这样一来，我们就可以在模板实例化时才确定一个模板类是否有友元，以及谁是这个模板类的友元。</p>
<h2 id="final-override-控制"><a href="#final-override-控制" class="headerlink" title="final/override 控制"></a>final/override 控制</h2><p>在通常情况下，一旦在基类A中的成员函数fun被声明为virtual 的，那么对于其派生类B而言，fun总是能够被重载的(除非被重写了)。有的时候我们并不想fun在B类型派生类中被重载，那么，C++98没有方法对此进行限制。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mathobject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Arith</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span> : <span class="keyword">public</span> Mathobject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Arith</span><span class="params">()</span> </span>= <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;<span class="comment">//在C++98中我们无法阻止该接口被重写</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Output is: &quot;</span> &lt;&lt; <span class="built_in">Arith</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add2</span> : <span class="keyword">public</span> Printable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Add2</span> (<span class="type">double</span> a, <span class="type">double</span> b): <span class="built_in">x</span>(a)， <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Arith</span><span class="params">()</span> </span>&#123; returnx + y; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x，y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mu13</span> : <span class="keyword">public</span> Printable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mul3</span> (<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c): <span class="built_in">x</span>(a), <span class="built_in">y</span>(b), <span class="built_in">z</span>(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Arith</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x*y*z; &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">double</span> x，y, z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-10-1. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>我们的基础类<code>MathObject</code>定义了两个接口：<code>Arith</code>和<code>Print</code>。类<code>Printable</code>则继承于<code>MathObject</code>并实现了<code>Print</code>接口。接下来，<code>Add2</code>和<code>Mul3</code>为了使用<code>MathObject</code>的接口和<code>Printable</code>的<code>Print</code>的实现，于是都继承了<code>Printable</code>。</p>
<p>final关键字的作用是使派生类不可覆盖它所修饰的虚函数。C++11 也采用了类似的做法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">object</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> : <span class="keyword">public</span> object &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// 声明为final</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//无法通过编译</span></span><br><span class="line">&#125;;.</span><br><span class="line"><span class="comment">//编译选项：g++ -c -std=c++11 2-10-2. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>派生于<code>Object</code>的<code>Base</code>类重载了<code>Object</code>的<code>fun</code>接口，并将本类中的<code>fun</code>函数声明为final的。那么派生于<code>Base</code>的<code>Derived</code>类对接口<code>fun</code>的重载则会导致编译时的错误。</p>
<p>基类中的虚函数可以使用final关键字，不过这样将使用该虚函数无法被重载，也就失去了虚函数的意义。如果不想成员函数被重载，程序员可以直接将该成员函数定义为非虚的。而final通常只在继承关系的“中途”终止派生类的重载中有意义。</p>
<p>在C++中重载还有一个特点，就是对于基类声明为virtual的函数，之后的重载版本都不需要再声明该重载函数为virtual。即使在派生类中声明了virtual，该关键字也是编译器可以忽略的。</p>
<p>在C++11中为了帮助程序员写继承结构复杂的类型，引入了虚函数描述符override,如<br>果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Turing</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VNeumann</span><span class="params">(<span class="type">int</span> g)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DKnuth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DerivedMid</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// void VNeumann (double g) ;</span></span><br><span class="line">    <span class="comment">//接口被隔离了，曾想多一个版本的VNeumann函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DerivedTop</span> : <span class="keyword">public</span> DerivedMid &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Turing</span><span class="params">()</span> <span class="keyword">override</span> </span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dikjstral</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">//无法通过编译，拼写错误，并非重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">VNeumann</span> <span class="params">(<span class="type">double</span> g)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">//无法通过编译，参数不一致，并非重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DKnuth</span><span class="params">()</span> <span class="keyword">override</span> </span>;</span><br><span class="line">    <span class="comment">//无法通过编译，常量性不一致，并非重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">//无法通过编译，非虚函数重载</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -c -std=C++11 2-10-3. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>我们在基类<code>Base</code>中定义了一些virtual的函数(接口)以及一个非virtual的函数Print。其派生类DerivedMid中，基类的Base的接口都没有重载，<code>DerivedTop</code>的作者在重载所有Base类的接口的时候，犯下了3种不同的错误：</p>
<ul>
<li>函数名拼写错，Djjkstra 误写作了Dikjstra。</li>
<li>函数原型不匹配，VNeumann 函数的参数类型误做了double类型，而DKnuth的常量性在派生类中被取消了。</li>
<li>重写了非虛函数Print。</li>
</ul>
<h2 id="模板函数的默认模板参数"><a href="#模板函数的默认模板参数" class="headerlink" title="模板函数的默认模板参数"></a>模板函数的默认模板参数</h2><p>在C++11中模板和函数一样，可以有默认的参数。这就带来了一定的复杂性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义一个函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">TempFun</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">TempFun</span>(<span class="number">1</span>) ;</span><br><span class="line">    <span class="comment">// 1，(实例化为TempFun&lt;const int&gt;(1))</span></span><br><span class="line">    <span class="built_in">TempFun</span>(<span class="string">&quot;1&quot;</span>) ;</span><br><span class="line">    <span class="comment">// 1，(实例化为TempFun&lt;const char *&gt;(&quot;1&quot;))</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-11-1. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码清单2-26中，当编译器解析到函数调用<code>fun(1)</code>的时候，发现<code>fun</code>是一个函数模板。这时候编译器就会根据实参1的类型const int推导实例化出模板函数<code>void TempFun&lt;const int&gt;(int)</code>，再进行调用。相应的，对于<code>fun(&quot;1&quot;)</code>来说也是类似的，不过编译器实例化出的模板函数的参数的类型将是<code>const char *</code>。</p>
<p>函数模板在C++98中与类模板一起被引入，不过在模板类声明的时候，标准允许其有默认模板参数。默认的模板参数的作用好比函数的默认形参。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefParm</span><span class="params">(<span class="type">int</span> m = <span class="number">3</span>)</span> </span>&#123;&#125; <span class="comment">// C++98 编译通过，C++11编译通过</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> DefClass &#123;&#125;;</span><br><span class="line"><span class="comment">// C++98 编译通过，C++11 编译通过</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">DefTemcpparm</span>() &#123;&#125;; <span class="comment">// C++98 编译失败，C++11编译通过</span></span><br><span class="line"><span class="comment">//编译选项：g++ -c -std=c++11 2-11-1. ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>DefTemcpparm</code>函数模板拥有一个默认参数。使用仅支持C++98的编译器<br>编译，<code>DefTemcpparm</code>的编译会失败，而支持C++11的编译器则毫无问题。不过在语法上，与类模板有些不同的是，在为多个默认模板参数声明指定默认值的时候，程序员必须遵照“从右往左”的规则进行指定。</p>
<p>而这个条件对函数模板来说并不是必须的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 = <span class="type">int</span>&gt; <span class="keyword">class</span> DefClass1 ;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1 = <span class="type">int</span>, <span class="keyword">typename</span> T2&gt; <span class="keyword">class</span> DefClass2; <span class="comment">//无法通过编译</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T，<span class="type">int</span> i = <span class="number">0</span>&gt; <span class="keyword">class</span> DefClass3;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> i = <span class="number">0</span>，<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> DefClass4; <span class="comment">//无法通过编译</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1 </span>= <span class="type">int</span>, <span class="keyword">typename</span> T2&gt; <span class="function"><span class="type">void</span> <span class="title">DefFunc1</span><span class="params">(T1 a，T2 b)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> i </span>= <span class="number">0</span>，<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">DefFunc2</span><span class="params">(T a)</span> </span>;</span><br><span class="line"><span class="comment">//编译选项：g++ -c -std=c++11 2-11-2. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>从代码清单2-28中可以看到，不按照从右往左定义默认类模板参数的模板类<code>DefClass2</code>和<code>DefClass4</code>都无法通过编译。而对于函数模板来说，默认模板参数的位置则比较随意。可以看到<code>DefFunc1</code>和<code>DefFunc2</code>都为第一个模板参数定义了默认参数，而第二个模板参数的默认值并没有定义，C++11 编译器却认为没有问题。</p>
<p>函数模板的参数推导规则也并不复杂。简单地讲，如果能够从函数实参中推导出类型的话，那么默认模板参数就不会被使用，反之，默认模板参数则可能会被使用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span> = <span class="type">double</span>&gt;</span><br><span class="line"><span class="built_in">voidf</span>(T t = <span class="number">0</span>, U u = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>);      <span class="comment">// f&lt;int, char&gt;(1, &#x27;c&#x27;) </span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>);           <span class="comment">// f&lt;int, double&gt;(1,0),使用了默认模板参数double</span></span><br><span class="line">    <span class="built_in">f</span>();            <span class="comment">// 错误：T无法被推导出来</span></span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;();       <span class="comment">// f&lt;int , double&gt;(0,0)，使用了默认模板参数double</span></span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt;(); <span class="comment">// f&lt;int,char&gt;(0,0)</span></span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-11-3. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个函数模板f，f同时使用了默认模板参数和默认函数参数。可以看到，由于函数的模板参数可以由函数的实参推导而出，所以在<code>f(1)</code>这个函数调用中，我们实例化出了模板函数的调用应该为<code>f&lt;int,double&gt;(1,0)</code>，其中，第二个类型参数U使用了默认的模板类型参数double，而函数实参则为默认值0。类似地，<code>f&lt;int&gt;()</code>实例化出的模板函数第二参数类型为double，值为0。而表达式<code>f()</code>由于第一类型参数T的无法推导，从而导致了编译的失败。而通过这个例子我们也可以看到，默认模板参数通常是需要跟默认函数参数一起使用的。</p>
<h2 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h2><h3 id="为什么需要外部模板"><a href="#为什么需要外部模板" class="headerlink" title="为什么需要外部模板"></a>为什么需要外部模板</h3><p>通常情况下，我们在一个文件中a.c中定义了一个变量<code>int i</code>，而在另外一个文件b.c中想使用它，这个时候我们就会在没有定义变量i的b.c文件中做一个外部变量的声明。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;</span><br></pre></td></tr></table></figure></p>
<p>这样做的好处是，在分别编译了a.c 和b.c之后，其生成的目标文件a.o和b.o中只有i<br>这个符号的一份定义。如果b.c中我们声明<code>int i</code>的时候不加上<code>extern</code>的话，那么i就会实实在在地既存在于a.o的数据区中，也存在于b.o的数据区中。那么链接器在链接a.o和b.o的时候，就会报告错误，因为无法决定相同的符号是否需要合并。</p>
<p>而对于函数模板来说，现在我们遇到的几乎是一模一样的问题。我们在一个test.h的文件中声明了如下一个模板函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在第一个test1.cpp文件中，我们定义了以下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test .h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; <span class="built_in">fun</span>(<span class="number">3</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>而在另一个test2.cpp文件中，我们定义了以下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test. h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; <span class="built_in">fun</span>(<span class="number">4</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>由于两个源代码使用的模板函数的参数类型一致，所以在编译test1.cpp的时候，编译器实例化出了函数<code>fun&lt;int&gt;(int)</code>，而当编译test2.cpp的时候，编译器又再一次实例化出了函数<code>fun&lt;int&gt;(int)</code>。那么可以想象，在test1.o目标文件和test2.o目标文件中，会有两份一模一样的函数<code>fun&lt;int&gt;(int)</code>代码。</p>
<p>在链接的时候，链接器通过一些编译器辅助的手段将重复的模板函数代码<code>fun&lt;int&gt;(int)</code>删除掉，只保留了单个副本。由于编译器会产生大量冗余代码，会极大地增加编译器的编译时间和链接时间。解决这个问题的方法基本跟变量共享的思路是一样的，就是使用“外部的”模板。</p>
<h3 id="显式的实例化与外部模板的声明"><a href="#显式的实例化与外部模板的声明" class="headerlink" title="显式的实例化与外部模板的声明"></a>显式的实例化与外部模板的声明</h3><p>外部模板的使用实际依赖于C++98中一个已有的特性，即显式实例化(Explicit Instantiation)。显式实例化的语法很简单，比如对于以下模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们只需要声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span>&gt; (<span class="type">int</span>) ;</span><br></pre></td></tr></table></figure></p>
<p>这就可以使编译器在本编译单元中实例化出<code>fun&lt;int&gt;(int)</code>版本的函数。而在C++11标准中，又加入了外部模板( Exterm Template)的声明。语法上，外部模板的声明跟显式的实例化差不多，只是多了一个关键字<code>extern</code>。对于上面的例子，我们可以通过：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span>&gt; (<span class="type">int</span>) ;</span><br></pre></td></tr></table></figure></p>
<p>这样的语法完成一个外部模板的声明。</p>
<p>那么回到一开始我们的例子，来修改一下我们的代码。首先，在test1.cpp做显式地实<br>例化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>); <span class="comment">// 显示地实例化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; <span class="built_in">fun</span>(<span class="number">3</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，在test2.cpp中做外部模板的声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span>&gt; (<span class="type">int</span>); <span class="comment">//外部模板的声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; <span class="built_in">fun</span>(<span class="number">3</span>) ;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，在test2.o中不会再生成<code>fun&lt;int&gt;(int)</code>的实例代码，编译器也不用每次都产生一份<code>fun&lt;int&gt;(int)</code>的代码，所以可以减少编译时间。这里也可以把外部模板声明放在头文件中，这样所有包含test.h的头文件就可以共享这个外部模板声明了。</p>
<p>在使用外部模板的时候，我们还需要注意以下问题：如果外部模板声明出现于某个编译<br>单元中，那么与之对应的显示实例化必须出现于另一个编译单元中或者同一个编译单元的后续代码中；外部模板声明不能用于一个静态函数(即文件域函数)，但可以用于类静态成员函数。</p>
<h1 id="通用为本，专用为末"><a href="#通用为本，专用为末" class="headerlink" title="通用为本，专用为末"></a>通用为本，专用为末</h1><h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。比如下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="built_in">A</span>(<span class="type">int</span> i) &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123; <span class="built_in">B</span>(inti) : <span class="built_in">A</span>(i) &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>B派生于A，B又在构造函数中调用A的构造函数，从而完成构造函数的“传递”。这在C++代码中非常常见。当然，这样的设计有一定的好处，尤其是B中有成员的时候。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="built_in">A</span>(<span class="type">int</span> i) &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123; </span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i) : <span class="built_in">A</span>(i), <span class="built_in">d</span>(i) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译选项：g++ -c 3-1-1. ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>倘若基类中有大量的构造函数，而派生类却只有一些成员函数时，那么对于派生类而言，其构造就等同于构造基类。这时候问题就来了，在派生类中我们写的构造函数完完全全就是为了构造基类。那么为了遵从于语法规则，我们还需要写很多的“透传”的构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span> d, <span class="type">int</span> i) &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">float</span> f, <span class="type">int</span> i, <span class="type">const</span> <span class="type">char</span>* c) &#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A&#123;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i): <span class="built_in">A</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">double</span> d, <span class="type">int</span> i): <span class="built_in">A</span>(d, i) &#123;&#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">float</span> f, <span class="type">int</span> i, <span class="type">const</span> <span class="type">char</span>* c): <span class="built_in">A</span>(f, i, c)&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Extrainterface</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们的基类A有很多的构造函数的版本，而继承于A的派生类B实际上只是添加了一个接口<code>Extralnterface</code>。那么如果我们在构造B的时候想要拥有A这样多的构造方法的话，就必须一一“透传”各个接口。这无疑是相当不方便的。事实上，在C++中已经有了一个好用的规则，就是如果派生类要使用基类的成员函数的，可以通过using声明( using-declaration)来完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(<span class="type">double</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base:&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">    <span class="keyword">using</span> Base::f;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived:&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">f</span>(<span class="number">4.5</span>);    <span class="comment">// Base: 4.5</span></span><br><span class="line"></span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">f</span>(<span class="number">4.5</span>);    <span class="comment">// Base: 4.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类中的<code>f</code>函数接受int类型为参数，而基类中接受double类型的参数。这里我们使用了<code>using</code>声明，声明派生类<code>Derived</code>也使用基类版本的函数<code>f</code>。这样一来，派生类中实际就拥有了两个f函数的版本。可以看到，我们在main函数中分别定义了Base变量b和 Derived变量d，并传入浮点字面常量4.5，结果都会调用到基类的接受double为参数的版本。</p>
<p>在C++11中，这个想法被扩展到了构造函数上。子类可以通过使用 using声明来声明继承基类的构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span> d, <span class="type">int</span> i) &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">float</span> f, <span class="type">int</span> i, coust <span class="type">char</span>* c) &#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ExtraInterface</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里我们通过<code>using A::A</code>的声明，把基类中的构造函数悉数继承到派生类B中。C++11标准继承构造函数被设计为跟派生类中的各种类默认函数(默认构造、析构、拷贝构造等样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码。这无疑比“透传”方案总是生成派生类的各种构造函数更加节省目标代码空间。</p>
<p>有的时候，基类构造函数的参数会有默认值。对于继承构造函数来讲，参数的默认值是不会被继承的。事实上，默认值会导致基类产生多个构造函数的版本，这些函数版本都会被派生类继承。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span> (<span class="type">int</span> a = <span class="number">3</span>, <span class="type">double</span> d = <span class="number">2.4</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们的基类的构造函数<code>A(int a=3, double=2.4)</code>有一个接受两个参数的构造函数，且两个参数均有默认值。那么A到底有多少个可能的构造函数的版本呢?事实上，B可能从A中继承来的候选继承构造函数有如下一些：</p>
<ul>
<li><code>A(int=3, double =2.4);</code>这是使用两个参数的情况。</li>
<li><code>A(int=3);</code>这是减掉一个参数的情况。</li>
<li><code>A(const A&amp;);</code>这是默认的复制构造函数</li>
<li><code>A()</code>这是不使用参数的情况。</li>
</ul>
<p>相应地，B中的构造函数将会包括以下一些：</p>
<ul>
<li><code>B(int, double);</code>这是一个继承构造函数</li>
<li><code>B(int);</code>这是减少掉一个参数的继承构造函数。</li>
<li><code>B(const B&amp;);</code>这是复制构造函数，这不是继承来的。</li>
<li><code>B();</code>这是不包含参数的默认构造函数。</li>
</ul>
<p>有的时候，我们还会遇到继承构造函数“冲突”的情况。这通常发生在派生类拥有多个基类的时候。多个基类中的部分构造函数可能导致派生类中的继承构造函数的函数名、参数(有的时候，我们也称其为函数签名)都相同，那么继承类中的冲突的继承构造函数将导致不合法的派生类代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="built_in">A</span>(<span class="type">int</span>) &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123; <span class="built_in">B</span>(<span class="type">int</span>) &#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: A, B &#123;</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">    <span class="keyword">using</span> B::B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>A和B的构造函数会导致C中重复定义相同类型的继承构造函数这种情况下，可以通过显式定义继承类的冲突的构造函数，阻止隐式生成相应的继承构造函数来解决冲突。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: A, B&#123;</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">    <span class="keyword">using</span> B::B;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中的构造函数<code>C(int)</code>就很好地解决了继承构造函数的冲突问题。</p>
<p>另外我们还需要了解的一些规则是，如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。此外，如果一旦使用了继承构造函数，编译器就不会再为派生类生成默认构造函数了</p>
<h2 id="委派构造函数"><a href="#委派构造函数" class="headerlink" title="委派构造函数"></a>委派构造函数</h2><p>通过委派其他构造函数，多构造函数的类编写将更加容易。我们能够将一个构造函数设定为“基准版本”，而其他构造函数可以通过委派“基准版本”来进行初始化。按照这个想法，我们可能会如下编写构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Info</span>() &#123; <span class="built_in">Initrest</span>(); &#125;</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">int</span> i) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">Info</span>(); type = i; &#125;</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">char</span> e) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">Info</span>(); name = e;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们通过<code>this</code>指针调用我们的“基准版本”的构造函数。不过可惜的是，一般的编译器都会阻止<code>this-&gt;Info()</code>的编译。原则上，编译器不允许在构造函数中调用构造函数，即使参数看起来并不相同。</p>
<p>在C+11中，我们可以使用委派构造函数来达到期望的效果。更具体的，C++11中的委派构造函数是在构造函数的初始化列表位置进行构造的、委派的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Info</span>() &#123; <span class="built_in">Initrest</span>(); &#125;</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">int</span> i) : <span class="built_in">Info</span>() &#123; type = i; &#125;</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">char</span> e) : <span class="built_in">Info</span>() &#123; name = e;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Initrest</span><span class="params">()</span> </span>&#123;<span class="comment">/* 其他初始化 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> type &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">char</span> name &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们在<code>Info(int)</code>和<code>Info(char)</code>的初始化列表的位置，调用了“基准版本”的构造函数<code>Info()</code>。这里我们为了区分被调用者和调用者，称在初始化列表中调用“基准版本”的构造函数为委派构造函数(delegating constructor)，而被调用的“基准版本”则为目标构造函数( target constructor)。</p>
<p>在C++11中，所谓委派构造，就是指委派函数将构造的任务委派给了目标构造函数来完成这样一种类构造的方式。当然，委派构造函数只能在函数体中为ype、name等成员赋初值。这是由于委派构造函数不能有初始化列表造成的。</p>
<p>在C++中，构造函数不能同时“委派”和使用初始化列表，所以如果委派构造函数要给变量赋初值，初始化代码必须放在函数体中。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rule1</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">Rule1</span>(<span class="type">int</span> a); <span class="built_in">i</span>(a) &#123;&#125;</span><br><span class="line">    <span class="built_in">Rule1</span>(): <span class="built_in">Rule1</span>(<span class="number">40</span>), <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125; <span class="comment">//无法通过编译</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>Rule1</code>的委派构造函数<code>Rule1()</code>的写法就是非法的。我们不能在初始化列表中既初始化成员，又委托其他构造函数完成构造。</p>
<p>事实上，在使用委派构造函数的时候，我们也建议程序员抽象出最为“通用”的行为做目标构造函数。这样做一来代码清晰，二来行为也更加正确。在构造函数比较多的时候，我们可能会拥有不止一个委派构造函数，而一些目标构造函数很可能也是委派构造函数，这样一来，我们就可能在委派构造函数中形成链状的委派构造关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Info</span>() : <span class="built_in">Info</span>(<span class="number">1</span>) &#123; &#125; <span class="comment">//委派构造函数</span></span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">int</span> i) : <span class="built_in">Info</span>(i,<span class="string">&#x27;a&#x27;</span>) &#123; &#125; <span class="comment">//既是目标构造函数，也是委派构造函数</span></span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">char</span> e): <span class="built_in">Info</span>(<span class="number">1</span>, e) &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">int</span> i, <span class="type">char</span> e) : <span class="built_in">type</span>(i), <span class="built_in">name</span>(e)&#123;<span class="comment">/* 其他初始化 */</span> &#125;<span class="comment">//目标构造函数</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们使<code>Info()</code>委托<code>Info(int)</code>进行构造，而<code>Info(int)</code>又委托<code>Info(int, char)</code>进行构造。在委托构造的链状关系中，有一点程序员必须注意，就是不能形成委托环( delegation cycle)。比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rule2</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, c;</span><br><span class="line">    <span class="built_in">Rule2</span>(): <span class="built_in">Rule2</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Rule2</span>(<span class="type">int</span> i): <span class="built_in">Rule2</span>(<span class="string">&#x27;c&#x27;</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">Rule2</span>(<span class="type">char</span> c): <span class="built_in">Rule2</span>(<span class="number">2</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>Rule2</code>定义中，<code>Rule2()</code>、<code>Rule2(int)</code>和<code>Rule2(char)</code>都依赖于别的构造函数，形成环委托构造关系。这样的代码通常会导致编译错误。</p>
<h2 id="右值引用：移动语义和完美转发"><a href="#右值引用：移动语义和完美转发" class="headerlink" title="右值引用：移动语义和完美转发"></a>右值引用：移动语义和完美转发</h2><h3 id="指针成员与拷贝构造"><a href="#指针成员与拷贝构造" class="headerlink" title="指针成员与拷贝构造"></a>指针成员与拷贝构造</h3><p>在类中包含了一个指针成员特别小心拷贝构造函数的编写，因为一不小心，就会出现内存泄露。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtrMem</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">HasPtrMem</span>(): <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;&#125;</span><br><span class="line">        ~<span class="built_in">HasPtrMem</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span> d;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="type">int</span> *d; <span class="comment">//指针成员d</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HasPtrMem a;</span><br><span class="line">    <span class="function">HasPtrMem <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    cout&lt;&lt;*a.d&lt;&lt;endl;<span class="comment">//0</span></span><br><span class="line">    cout&lt;&lt;*b.d&lt;&lt;endl;<span class="comment">//0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个<code>HasptrMem</code>的类。这个类包含一个指针成员，该成员在构造时接受一个new操作分配堆内存返回的指针，而在析构的时候则会被delete操作用于释放之前分配的堆内存。在main函数中，我们声明了<code>HasPtrMem</code>类型的变量a，又使用a初始化了变量b。按照C++的语法，这会调用<code>HasptrMem</code>的拷贝构造函数。<code>a.d</code>和<code>b.d</code>都指向了同一块堆内存。在main作用域结束的时候，a和b的析构函数纷纷被调用，当其中之一完成析构之后(比如b)，那么<code>a.d</code>就成了一个“悬挂指针”(dangling pointer)，因为其不再指向有效的内存了。</p>
<p>这样的拷贝构造方式，在C++中也常被称为“浅拷贝”(shallow copy)。而在未声明构造函数的情况下，C++也会为类生成一个浅拷贝的构造函数。通常最佳的解决方案是用户自定义拷贝构造函数来实现“深拷贝”(deep copy)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasptrMem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasptrMem</span>(): <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">0</span>)) &#123; &#125;</span><br><span class="line">    <span class="built_in">HasptrMem</span>(HasptrMem &amp; h) : <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*h.d)) &#123; &#125; <span class="comment">//拷贝构造函数，从堆中分配内存，并用*h.d初始化</span></span><br><span class="line">    ~<span class="built_in">HasptrMem</span>() &#123; <span class="keyword">delete</span> d; &#125;</span><br><span class="line">    <span class="type">int</span> * d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HasptrMem a;</span><br><span class="line">    <span class="function">HasptrMem <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    cout &lt;&lt; *a.d &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; *b.d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们为<code>HasptrMem</code>添加了一个拷贝构造函数。拷贝构造函数从堆中分配新内存，将该分配来的内存的指针交还给d，又使用<code>*(h.d)</code>对d进行了初始化。通过这样的方法，就避免了悬挂指针的困扰。</p>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>拷贝构造函数中为指针成员分配新的内存再进行内容拷贝的做法在C++编程中几乎被视为是不可违背的。不过在一些时候，我们确实不需要这样的拷贝构造语义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtrMem</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">HasPtrMem</span>(): <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Construct:&quot;</span> &lt;&lt; ++n_cstr&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">HasPtrMem</span>(<span class="type">const</span> HasPtrMem&amp;h): <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*h.d))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Copy construct:&quot;</span>&lt;&lt; ++n_cptr&lt;&lt;endl;</span><br><span class="line">        &#125; <span class="comment">//拷贝构造函数，从堆中分配内存，并用*h.d初始化</span></span><br><span class="line">        ~<span class="built_in">HasPtrMem</span>() &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Destruct:&quot;</span>&lt;&lt;++n_dstr&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> *d; </span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> n_cstr;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> n_dstr;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> n_cptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> HasPtrMem::n_cstr=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> HasPtrMem::n_dstr=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> HasPtrMem::n_cptr=<span class="number">0</span>;</span><br><span class="line"><span class="function">HasPtrMem <span class="title">GetTemp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">HasPtrMem</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HasPtrMem a=<span class="built_in">GetTemp</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们声明了一个返回一个<code>HasptrMem</code>变量的函数。为了记录构造函数、拷贝构造函数，以及析构函数调用的次数，我们使用了一些静态变量。在main函数中，我们简单地声明了一个<code>HasptrMem</code>的变量a，要求它使用<code>Gettemp</code>的返回值进行初始化。编译运行该程序，我们可以看到下面的输出<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Construct: <span class="number">1</span></span><br><span class="line">Copy construct: <span class="number">1</span></span><br><span class="line">Destruct: <span class="number">1</span></span><br><span class="line">Copy construct: <span class="number">2</span></span><br><span class="line">Destruct: <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>这里构造函数被调用了一次，这是在<code>GetTemp</code>函数中<code>HasptrMem()</code>表达式显式地调用了构造函数而打印出来的。而拷贝构造函数则被调用了两次。这两次一次是从<code>GetTemp</code>函数中<code>HasPtrmeme()</code>生成的变量上拷贝构造出一个临时值，以用作<code>GetTemp</code>的返回值，而另外一次则是由临时值构造出<code>main</code>中变量a调用的。对应地，析构函数也就调用了3次。</p>
<p>如果<code>HasptrMem</code>的指针指向非常大的堆内存数据的话，那么拷贝构造的过程就会非常昂贵。按照C++的语义，临时对象将在语句结束后被析构，会释放它所包含的堆内存资源。而a在拷贝构造的时候，又会被分配堆内存。一种“新”方法是在构造时使得<code>a.d</code>指向临时对象的堆内存资。同时我们保证临时对象不释放所指向的堆内存，那么在构造完成后临时对象被析构，a就从中“偷”到了临时对象所拥有的堆内存资源。<br><img src="/img/1628477156.jpg" alt=""></p>
<p>C++11中，这样的“偷走”临时变量中资源的构造函数，就被称为“移动构造函数”而这样的“偷”的行为，则称之为“移动语义”( move semantics)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtrMem</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">HasPtrMem</span>(): <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Construct:&quot;</span> &lt;&lt; ++n_cstr&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">HasPtrMem</span>(<span class="type">const</span> HasPtrMem&amp;h): <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*h.d))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Copy construct:&quot;</span>&lt;&lt; ++n_cptr&lt;&lt;endl;</span><br><span class="line">        &#125; <span class="comment">//拷贝构造函数，从堆中分配内存，并用*h.d初始化</span></span><br><span class="line">        <span class="built_in">HasPtrMem</span>(HasPtrMem &amp;&amp;h):<span class="built_in">d</span>(h.d)&#123;</span><br><span class="line">            h.d=<span class="literal">nullptr</span>;<span class="comment">//将临时值得指针成员置空。</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Move construct:&quot;</span>&lt;&lt;++n_mvtr&lt;&lt;endl; </span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">HasPtrMem</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span> d;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Destruct:&quot;</span>&lt;&lt;++n_dstr&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> *d; </span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> n_cstr;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> n_dstr;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> n_cptr;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> n_mvtr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> HasPtrMem::n_cstr=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> HasPtrMem::n_dstr=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> HasPtrMem::n_cptr=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> HasPtrMem::n_mvtr=<span class="number">0</span>;</span><br><span class="line"><span class="function">HasPtrMem <span class="title">GetTemp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HasPtrMem h;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Resource from&quot;</span>&lt;&lt;__func__&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;hex&lt;&lt;h.d&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> h; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//HasPtrMem b;</span></span><br><span class="line">    HasPtrMem a=<span class="built_in">GetTemp</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Resource from&quot;</span>&lt;&lt;__func__&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;hex&lt;&lt;a.d&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>HasptrMem</code>类多了一个构造函数<code>HasPtrmem(HasptrMem&amp;&amp;)</code>，这个就是我们所谓的移动构造函数。移动构造函数接受一个所谓的“右值引用”的参数。可以看到，移动构造函数使用了参数<code>h</code>的成员<code>d</code>初始化了本对象的成员<code>d</code>，而<code>h</code>的成员<code>d</code>随后被置为指针空值<code>nullptr</code>。这就完成了移动构造的全过程。</p>
<p>这里所谓的“偷”堆内存，就是指将本对象<code>d</code>指向<code>h.d</code>所指的内存这一条语句，相应地，我们还将<code>h</code>的成员<code>d</code>置为指针空值。这其实也是我们“偷”内存时必须做的。这是因为在移动构造完成之后，临时对象会立即被析构。如果不改变<code>h.d</code>(临时对象的指针成员)的话，则临时对象会析构掉本是我们“偷”来的堆内存。这样一来，本对象中的<code>d</code>指针也就成了个悬挂指针，如果我们对指针进行解引用，就会发生严重的运行时错误。</p>
<p>将指针置为nullptr只是让这个指针不再指向任何对象，并没有释放原来这个指针指向的对象的内存。结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//理论上的结果：</span></span><br><span class="line">Construct:<span class="number">1</span></span><br><span class="line">Resource from GetTemp:<span class="number">0x603010</span></span><br><span class="line">Move construct:<span class="number">1</span></span><br><span class="line">Destruct:<span class="number">1</span></span><br><span class="line">Move construct:<span class="number">2</span></span><br><span class="line">Destruct:<span class="number">2</span></span><br><span class="line">Resource from main:<span class="number">0x603010</span></span><br><span class="line">Destruct:<span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里没有调用拷贝构造函数，而是调用了两次移动构造函数，移动构造的结果是，<code>GetTemp</code>中的<code>h</code>的指针成员<code>h.d</code>和<code>main</code>函数中的<code>a</code>的指针成员<code>a.d</code>的值是相同的，即<code>h.d</code>和<code>a.d</code>都指向了相同的堆地址内存。该堆内存在函数返回的过程中，成功地逃避了被析构的“厄运”，取而代之地，成为了赋值表达式中的变量<code>a</code>的资源。</p>
<p>事实上，移动语义并不是什么新的概念，在C++98/03的语言和库中，它已经存在了，比如：</p>
<ul>
<li>在某些情况下拷贝构遗函数的省略</li>
<li>智能指针的拷贝</li>
<li>链表拼接</li>
<li>容器内的置换</li>
</ul>
<p>以上这些操作都包含了从一个对象向另外一个对象的资源转移的过程，唯一欠缺的是统一的语法和语义的支持，来使我们可以使用通用的代码移动任意的对象。如果能够任意地使用对象的移动而不是拷贝，那么标准库中的很多地方的性能都会大大提高。</p>
<h3 id="左值、右值与右值引用"><a href="#左值、右值与右值引用" class="headerlink" title="左值、右值与右值引用"></a>左值、右值与右值引用</h3><p>在赋值表达式中，出现在等号左边的就是“左值”，而在等号右边的，则称为“右值”。C++中还有一个被广泛认同的说法，那就是可以取地址的有名字的就是左值，反之，不能取地址的、没有名字的就是右值。</p>
<p>更为细致地，在C++11中，右值是由两个概念构成的个是将亡值( xvalue, expiring Value),另一个则是纯右值( rvalue, Pure Rvalue)。其中纯右值就是C++98标准中右值的概念，讲的是用于辨识临时变量和一些不跟对象关联的值。比如非引用返回的函数返回的临时变量值就是一个纯右值。一些运算表达式，比如1+3产生的临时变量值，也是纯右值。而不跟对象关联的字面量值，比如：2、’c’、true，也是纯右值。此外，类型转换函数的返回值、 lambda表达式等，也都是右值。</p>
<p>而将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象，比如返回右值引用<code>T&amp;&amp;</code>的函数返回值、<code>std:move</code>的返回值，或者转换为<code>T&amp;&amp;</code>的类型转换函数的返回值。而剩余的，可以标识函数、对象的值都属于左值。在C++11的程序中，所有的值必属于左值、将亡值、纯右值三者之一。</p>
<p>通常情况下，我们只能是从右值表达式获得其引用。比如<code>T &amp;&amp; a = Returnrvalue();</code>，这个表达式中，假设<code>Returnrvalue</code>返回一个右值，我们就声明了一个名为<code>a</code>的右值引用，其值等于<code>Returnrvalue</code>函数返回的临时变量的值。</p>
<p>为了区别于C++98中的引用类型，我们称C++98中的引用为“左值引用”。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名(匿名)变量的别名。</p>
<p>在上面的例子中，<code>Returnrvalue</code>函数返回的右值在表达式语句结束后，其生命也就终结了(通常我们也称其具有表达式生命期)，而通过右值引用的声明，该右值又“重获新生”其生命期将与右值引用类型变量a的生命期一样。所以相比于以下语句的声明方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T b = <span class="built_in">Returnrvalue</span>()</span><br></pre></td></tr></table></figure></p>
<p>我们刚才的右值引用变量声明，就会少一次对象的析构及一次对象的构造。因为<code>a</code>是右值引用，直接绑定了<code>Returnrvalue()</code>返回的临时量，而<code>b</code>只是由临时值构造而成的，而临时量在表达式结東后会析构因应就会多一次析构和构造的开销。</p>
<p>能够声明右值引用<code>a</code>的前提是<code>Returnrvalue</code>返回的是一个右值。通常情况下，右值引用是不能够绑定到任何的左值的。比如下面的表达式就是无法通过编译的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="type">int</span> &amp;&amp;d = c;</span><br></pre></td></tr></table></figure></p>
<p>这样的语句是否能够通过编译呢?<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T &amp;e = <span class="built_in">ReturnRvalue</span>();</span><br><span class="line"><span class="type">const</span> T &amp; f = <span class="built_in">ReturnRvalue</span>();</span><br></pre></td></tr></table></figure></p>
<p>这里的答案是：<code>e</code>的初始化会导致编译时错误，而<code>f</code>则不会。</p>
<p>在常量左值引用在C++98标准中可以接受非常量左值、常量左值、右值对其进行初始化。而且在使用右值对其初始化的时候，常量左值引用还可以像右值引用一样将右值的生命期延长。不过相比于右值引用所引用的右值，常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p>
<p>即使在C++98中，我们也常可以使用常量左值引用来减少临时对象的开销<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Copyable</span> &#123;</span><br><span class="line">    <span class="built_in">Copyable</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Copyable</span>(<span class="type">const</span> Copyable &amp;o) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copied&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Copyable <span class="title">ReturnRvalue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Copyable</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AcceptVal</span><span class="params">(Copyable)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AcceptRef</span><span class="params">(<span class="type">const</span> Copyable &amp; )</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pass by value: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">AcceptVal</span>(<span class="built_in">ReturnRvalue</span>()); <span class="comment">// 临时值被拷贝传入</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pass by reference: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">AcceptRef</span>(<span class="built_in">ReturnRvalue</span>()); <span class="comment">// 临时值被作为引用传递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们声明了结构体<code>Copyable</code>，该结构体唯一作用是在被拷贝构造的时候打印一句话：Copied。两个函数，<code>AcceptVal</code>使用了值传递参数，<code>AcceptRef</code>使用了引用传递。在以<code>ReturnRvalue</code>返回的右值为参数的时候，<code>AcceptRef</code>就可以直接使用产生的临时值，而<code>AcceptVal</code>则不能直接使用临时对象。</p>
<p>编译运行代码，可以得到以下结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pass by value:</span><br><span class="line">Copied</span><br><span class="line">Copied</span><br><span class="line">Pass by reference:</span><br><span class="line">Copied</span><br></pre></td></tr></table></figure></p>
<p>可以看到，由于使用了左值引用，临时对象被直接作为函数的参数，而不需要从中拷贝。在C++11中，以右值引用为参数声明如下函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AcceptRvalueRef</span><span class="params">(Copyable &amp;&amp;)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>也同样可以减少临时变量拷贝的开销。进一步地，还可以在<code>AcceptRvalueRef</code>中修改该临时值。</p>
<p>如果我们这样实现函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AcceptRvalueRef</span><span class="params">(Copyable &amp;&amp; s)</span> </span>&#123;</span><br><span class="line">    Copyable news = std::<span class="built_in">move</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>std::move(s)</code>的作用是强制一个左值成为右值。该函数就是使用右值来初始化 <code>Copyable</code>变量<code>news</code>。使用移动语义的前提是<code>Copyable</code>还需要添加一个以右值引用为参数的移动构造函数，比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Copyable</span>(Copyable &amp;&amp;o) &#123; <span class="comment">/*实现移动语义*/</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，如果<code>Copyable</code>类的临时对象中包含一些大块内存的指针，<code>news</code>就可以将临时值中的内存“窃”为己用，从而从这个以右值引用参数的<code>AcceptRvalueRef</code>函数中获得最大的收益。</p>
<p>如果<code>Copyable</code>没有移动构造函数，下列语句<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyable news = std::<span class="built_in">move</span>(s);</span><br></pre></td></tr></table></figure></p>
<p>将调用以常量左值引用为参数的拷贝构造函数。这是一种非常安全的设计，移动不成，至少还可以执行拷贝。</p>
<p>为了语义的完整，C++11中还存在着常量右值引用，比如我们通过以下代码声明一个常量右值引用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> T &amp;&amp; crvalueref = <span class="built_in">ReturnRvalue</span>();</span><br></pre></td></tr></table></figure></p>
<p>我们列出了在C++11中各种引用类型可以引用的值的类型。值得注意的是只要能够绑定右值的引用类型，都能够延长右值的生命期。<br><img src="/img/1628492956.jpg" alt=""></p>
<p>有的时候，我们可能不知道一个类型是否是引用类型，以及是左值引用还是右值引用。标准库在<code>&lt;type_traits&gt;</code>头文件中提供了3个模板类：<code>is_rvalue_reference</code>、<code>is_lvalue_reference</code>、<code>is_reference</code>，可供我们进行判断。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; is_rvalue_reference&lt;string &amp;&amp;&gt;::value;</span><br></pre></td></tr></table></figure></p>
<h3 id="std-move：强制转化为右值"><a href="#std-move：强制转化为右值" class="headerlink" title="std::move：强制转化为右值"></a>std::move：强制转化为右值</h3><p>在C++11中，标准库在<code>utility</code>中提供了一个有用的函数<code>std::move</code>，这个函数的功能是将一个左值强制转化为右值引用，继而我们可以通过右值引用使用该值，以用于移动语义。从实现上讲<code>std::move</code>基本等同于一个类型转换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(lvalue);</span><br></pre></td></tr></table></figure></p>
<p>值得一提的是，被转化的左值，其生命期并没有随着左右值的转化而改变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Moveable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Moveable</span>():<span class="built_in">i</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>)) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Moveable</span>() &#123; <span class="keyword">delete</span> i; &#125;</span><br><span class="line">    <span class="built_in">Moveable</span>(<span class="type">const</span> Moveable &amp; m): <span class="built_in">i</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*m.i)) &#123; &#125;</span><br><span class="line">    <span class="built_in">Moveable</span>(Moveable &amp;&amp; m):<span class="built_in">i</span>(m.i) &#123;</span><br><span class="line">        m.i = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>* i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Moveable a;</span><br><span class="line"></span><br><span class="line">    <span class="function">Moveable <span class="title">c</span><span class="params">(move(a))</span></span>;    <span class="comment">// 会调用移动构造函数</span></span><br><span class="line">    cout &lt;&lt; *a.i &lt;&lt; endl;   <span class="comment">// 运行时错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们为类型<code>Moveable</code>定义了移动构造函数。这个函数定义本身没有什么问题，但调用的时候，使用了<code>Moveable c(move(a));</code>这样的语句。这里的<code>a</code>本来是个左值变量，通过<code>std::move</code>将其转换为右值。这样一来，<code>a.i</code>就被<code>c</code>的移动构造函数设置为指针空值。由于<code>a</code>的生命期实际要到<code>main</code>函数结束才结東，那么随后对表达式<code>*a.i</code>进行计算的时候，就会发生严重的运行时错误。这是个典型误用<code>std::move</code>的例子。</p>
<p>我们来看看正确例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HugeMem</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HugeMem</span>(<span class="type">int</span> size): <span class="built_in">sz</span>(size &gt; <span class="number">0</span> ? size : <span class="number">1</span>) &#123;</span><br><span class="line">        c = <span class="keyword">new</span> <span class="type">int</span>[sz];</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">HugeMem</span>() &#123; <span class="keyword">delete</span> [] c; &#125;</span><br><span class="line">    <span class="built_in">HugeMem</span>(HugeMem &amp;&amp; hm): <span class="built_in">sz</span>(hm.sz), <span class="built_in">c</span>(hm.c) &#123;</span><br><span class="line">        hm.c = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> * c;</span><br><span class="line">    <span class="type">int</span> sz;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Moveable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Moveable</span>():<span class="built_in">i</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>)), <span class="built_in">h</span>(<span class="number">1024</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Moveable</span>() &#123; <span class="keyword">delete</span> i; &#125;</span><br><span class="line">    <span class="built_in">Moveable</span>(Moveable &amp;&amp; m):</span><br><span class="line">        <span class="built_in">i</span>(m.i), <span class="built_in">h</span>(<span class="built_in">move</span>(m.h)) &#123;      <span class="comment">// 强制转为右值，以调用移动构造函数</span></span><br><span class="line">        m.i = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>* i;</span><br><span class="line">    HugeMem h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Moveable <span class="title">GetTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Moveable tmp = <span class="built_in">Moveable</span>();</span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; <span class="string">&quot;Huge Mem from &quot;</span> &lt;&lt; __func__</span><br><span class="line">        &lt;&lt; <span class="string">&quot; @&quot;</span> &lt;&lt; tmp.h.c &lt;&lt; endl; <span class="comment">// Huge Mem from GetTemp @0x603030</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Moveable <span class="title">a</span><span class="params">(GetTemp())</span></span>;</span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; <span class="string">&quot;Huge Mem from &quot;</span> &lt;&lt; __func__</span><br><span class="line">        &lt;&lt; <span class="string">&quot; @&quot;</span> &lt;&lt; a.h.c &lt;&lt; endl;   <span class="comment">// Huge Mem from main @0x603030</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了两个类型：<code>Hugemem</code>和<code>Moveable</code>，其中<code>Moveable</code>包含了一个<code>HugeMem</code>的对象。在<code>Moveable</code>的移动构造函数中，我们就看到了<code>std::move</code>函数的使用。该函数将<code>m.h</code>强制转化为右值，以迫使<code>Moveable</code>中的<code>h</code>能够实现移动构造。这里可以使用<code>std::move</code>，是因为<code>m.h</code>是<code>m</code>的成员，既然<code>m</code>将在表达式结束后被析构，其成员也自然会被析构，因此不存在生存期不对的问题。</p>
<p>另外一个问题可能是<code>std::move</code>使用的必要性。可以接受右值的右值引用本身却是个左值。这里的<code>m.h</code>引用了一个确定的对象，而且<code>m.h</code>也有名字，可以使用<code>&amp;m.h</code>取到地址，因此是个不折不扣的左值。不过这个左值确确实实会很快“灰飞烟灭”，因为拷贝构造函数在<code>Moveable</code>对象<code>a</code>的构造完成后也就结束了。那么这里使用<code>std::move</code>强制其为右值就不会有问题了。</p>
<p>事实上，为了保证移动语义的传递，程序员在编写移动构造函数的时候，应该总是记得使用<code>std::move</code>转换拥有形如堆内存、文件句柄等资源的成员为右值，这样一来，如果成员支持移动构造的话，就可以实现其移动语义。而即使成员没有移动构造函数，那么接受常量左值的构造函数版本也会轻松地实现拷贝构造，因此也不会引起大的问题。</p>
<h3 id="移动语义的一些其他问题"><a href="#移动语义的一些其他问题" class="headerlink" title="移动语义的一些其他问题"></a>移动语义的一些其他问题</h3><p>移动语义一定是要修改临时变量的值。程序员在实现移动语义一定要注意排除不必要的const关键字。</p>
<p>在C++11中，拷贝/移动构造函数实际上有以下3个版本：</p>
<ul>
<li><code>T object(T &amp;)</code></li>
<li><code>T Object(const T &amp;)</code></li>
<li><code>T object(T &amp;&amp;)</code></li>
</ul>
<p>其中常量左值引用的版本是一个拷贝构造版本，而右值引用版本是一个移动构造版本。默认情况下，编译器会为程序员隐式地生成一个移动构造函数。不过如果程序员声明了自定义的拷贝构造函数、拷贝赋值函数、移动赋值函数、析构函数中的一个或者多个，编译器都不会再为程序员生成默认版本。默认的移动构造函数实际上跟默认的拷贝构造函数一样，只能做一些按位拷贝的工作。这对实现移动语义来说是不够的。</p>
<p>声明了移动构造函数、移动赋值函数、拷贝赋值函数和析构函数中的一个或者多个，编译器也不会再为程序员生成默认的拷贝构造函数。所以在C++11中，拷贝构造/赋值和移动构造/赋值函数必须同时提供，或者同时不提供，程序员才能保证类同时具有拷贝和移动语义。只声明其中一种的话，类都仅能实现一种语义。</p>
<p>只有移动语义构造的类型往往都是“资源型”的类型，比如说智能指针，文件流等，都可以视为“资源型”的类型。一些编译器现在也把<code>ifstream</code>这样的类型实现为仅可移动的。</p>
<p>在标准库的头文件<code>&lt;type_traits&gt;</code>里，我们还可以通过一些辅助的模板类来判断一个类型是否是可以移动的。比如<code>is_move_constructible</code>、<code>is_trivially_move_constructible</code>、<code>is_nothrow_move_constructible</code>，使用方法仍然是使用其成员<code>value</code>。比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; is_move_constructible&lt;UnknownType&gt;::value;</span><br></pre></td></tr></table></figure></p>
<p>就可以打印出<code>UnknowType</code>是否可以移动，这在一些情况下还是非常有用的。</p>
<p>而有了移动语义，还有一个比较典型的应用是可以实现高性能的置换(swap)函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(move(a))</span></span>;</span><br><span class="line">    a = <span class="built_in">move</span>(b);</span><br><span class="line">    b = <span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果T是可以移动的，那么移动构造和移动赋值将会被用于这个置换。整个过程，代码都只会按照移动语义进行指针交换，不会有资源的释放与申请。而如果T不可移动却是可拷贝的，那么拷贝语义会被用来进行置换。这就跟普通的置换语句是相同的了。</p>
<p>另外一个关于移动构造的话题是异常。程序员应该尽量编写不抛出异常的移动构造函数，通过为其添加一个<code>noexcept</code>关键字，可以保证移动构造函数中抛出来的异常会直接调用<code>terminate</code>程序终止运行，而不是造成指针悬挂的状态。而标准库中，我们还可以用一个<code>std::move_if_noexcept</code>的模板函数替代<code>move</code>函数。该函数在类的移动构造函数没有<code>noexcept</code>关键字修饰时返回一个左值引用从而使变量可以使用拷贝语义，而在类的移动构造函数有<code>noexcept</code>关键字时，返回一个右值引用，从而使变量可以使用移动语义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Maythrow</span> &#123;</span><br><span class="line">    <span class="built_in">Maythrow</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Maythrow</span>(<span class="type">const</span> Maythrow&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Maythorow copy constructor.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Maythrow</span>(Maythrow&amp;&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Maythorow move constructor.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Nothrow</span> &#123;</span><br><span class="line">    <span class="built_in">Nothrow</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Nothrow</span>(Nothrow&amp;&amp;) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Nothorow move constructor.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Nothrow</span>(<span class="type">const</span> Nothrow&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Nothorow move constructor.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Maythrow m;</span><br><span class="line">    Nothrow n;</span><br><span class="line"></span><br><span class="line">    Maythrow mt = <span class="built_in">move_if_noexcept</span>(m);  <span class="comment">// Maythorow copy constructor.</span></span><br><span class="line">    Nothrow nt = <span class="built_in">move_if_noexcept</span>(n);   <span class="comment">// Nothorow move constructor.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以清楚地看到<code>move_if_noexcept</code>的效果。事实上，<code>move_if_noexcept</code>是以牺牲性能保证安全的一种做法，而且要求类的开发者对移动构造函数使用<code>noexcept</code>进行描述，否则就会损失更多的性能。</p>
<p>还有一个与移动语义看似无关，但偏偏有些关联的话题是，编译器中被称为RVO/NRVO的优化(RVO, 返回值优化)。事实上，在本节中大量的代码都使用了<code>-fno-elide-constructors</code>选项在g++/clang++中关闭这个优化，这样可以使读者在代码中较为容易地利用函数返回的临时量右值。</p>
<p>但若在编译的时候不使用该选项的话，读者会发现很多构造和移动都被省略了。对于下面这样的代码，一旦打开g++/clang++的RVO/NRVO，从<code>ReturnValue</code>函数中a变量拷贝/移动构造临时变量，以及从临时变量拷贝/移动构造b的二重奏就通通没有了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">ReturnRvalue</span><span class="params">()</span> </span>&#123; <span class="function">A <span class="title">a</span><span class="params">()</span></span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">A b = <span class="built_in">ReturnRvalue</span>();</span><br></pre></td></tr></table></figure></p>
<p><code>b</code>变量实际就使用了<code>ReturnRvalue</code>函数中<code>a</code>的地址，任何的拷贝和移动都没有了。通俗地说，就是b变量直接“霸占”了a变量。这是编译器中一个效果非常好的一个优化。不过RVO/NRVO并不是对任何情况都有效。比如有些情况下，一些构造是无法省略的。还有一些情况，即使 RVO/NRVO完成了，也不能达到最好的效果</p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>所谓完美转发(perfect forwarding)，是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwording</span><span class="params">(T t)</span> </span>&#123; <span class="built_in">IruncodeActually</span>(t); &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个简单的例子中，<code>IamForwording</code>是一个转发函数模板。而函数<code>IruncodeActually</code>则是真正执行代码的目标函数。对于目标函数<code>IruncodeActually</code>而言，它总是希望转发函数将参数按照传入<code>Iamforwarding</code>时的类型传递，而不产生额外的开销，就好像转发者不存在一样。通常程序员需要的是一个引用类型，引用类型不会有拷贝的开销。其次，则需要考虑转发函数对类型的接受能力。因为目标函数可能需要能够既接受左值引用，又接受右值引用。</p>
<p>以常量左值为参数的转发函数却会遇到一些尷尬，比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IrunCodeActually</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwording</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123; <span class="built_in">IrunCodeActually</span>(t); &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，由于目标函数的参数类型是非常量左值引用类型，因此无法接受常量左值引用作为参数，这样一来，虽然转发函数的接受能力很高，但在目标函数的接受上却出了问题。那么我们可能就需要通过一些常量和非常量的重载来解决目标函数的接受问题。C++11通过引入一条所谓“引用折叠”(reference collapsing)的新语言规则，并结合新的模板推导规则来完成完美转发。</p>
<p>在C++11以前，形如下列语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int</span> T;</span><br><span class="line"><span class="keyword">typedef</span> T&amp; TR;</span><br><span class="line">TR&amp; v = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>TR&amp; v = 1</code>这样的表达式会被编译器认为是不合法的表达式，而在C++11中，一旦出现了这样的表达式，就会发生引用折叠，即将复杂的未知表达式折叠为已知的简单表达式，具体如表。<br><img src="/img/1628501072.jpg" alt=""></p>
<p>这个规则并不难记忆，因为一旦定义中出现了左值引用，引用折叠总是优先将其折叠为值引用。而模板对类型的推导规则就比较简单，当转发函数的实参是类型X的一个左值引用，那么模板参数被推导为<code>X&amp;</code>类型，而转发函数的实参是类型<code>X</code>的一个右值引用的话，那么模板的参数被推导为<code>X&amp;&amp;</code>类型。结合以上的引用折叠规则，就能确定出参数的实际类型进一步，我们可以把转发函数写成如下形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwording</span> <span class="params">(T &amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">IrunCodeActually</span>(<span class="built_in">static_cast</span>&lt;T &amp;&amp;&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们不仅在参数部分使用了<code>T&amp;&amp;</code>这样的标识，在目标函数传参的强制类型转换中也使用了这样的形式。比如我们调用转发函数时传入了一个<code>X</code>类型的左值引用，可以想象，转发函数将被实例化为如下形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwording</span><span class="params">(X&amp; &amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">IrunCodeActually</span>(<span class="built_in">static_cast</span>&lt;X&amp;&amp;&amp;&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>应用上引用折叠规则，就是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwording</span><span class="params">(X&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">IrunCodeActually</span>(<span class="built_in">static_cast</span>&lt;X&amp;&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，我们的左值传递就毫无问题了。实际使用的时候，<code>IrunCodeActually</code>如果接受左值引用的话，就可以直接调用转发函数。不过读者可能发现，这里调用前的 <code>static_cast</code>没有什么作用。事实上，这里的<code>static_cast</code>是留给传递右值用的。</p>
<p>而如果我们调用转发函数时传入了一个<code>X</code>类型的右值引用的话，我们的转发函数将被实例化为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwording</span><span class="params">(X&amp;&amp; &amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">IrunCodeActually</span>(<span class="built_in">static_cast</span>&lt;X&amp;&amp;&amp;&amp;&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>应用上引用折叠规则，就是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwording</span><span class="params">(X&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">IrunCodeActually</span>(<span class="built_in">static_cast</span>&lt;X&amp;&amp;&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们就看到了<code>static_cast</code>的重要性。对于一个右值而言，当它使用右值引用表达式引用的时候，该右值引用却是个不折不扣的左值，那么我们想在函数调用中继续传递右值，就需要使用<code>std::move</code>来进行左右值的转换。而<code>std::move</code>通常就是一个<code>static_cast</code>。不过在C++11中，用于完美转发的函数却不再叫作<code>move</code>，而是另外一个名字：<code>forward</code>。所以我们可以把转发函数写成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">IamForwording</span><span class="params">(T &amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">IrunCodeActually</span>(forward(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看一个完美转发的例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">int</span> &amp;&amp; m)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;rvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">int</span> &amp; m)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;lvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;&amp; m)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const rvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; m)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const lvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RunCode</span>(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PerfectForward</span>(a);      <span class="comment">// lvalue ref</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="built_in">move</span>(b));      <span class="comment">// rvalue ref</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(c);      <span class="comment">// const lvalue ref</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="built_in">move</span>(d));      <span class="comment">// const rvalue ref</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用了表3-1中的所有4种类型的值对完美转发进行测试，可以看到，所有的转发都被正确地送到了目的地。</p>
<p>完美转发的一个作用就是做包装函数，这是一个很方便的功能。可以用很少的代码记录单参数函数的参数传递状况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t, U&amp; Func)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; <span class="string">&quot;\tforwarded.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Func</span>(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">double</span> &amp;&amp; m)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunHome</span><span class="params">(<span class="type">double</span> &amp;&amp; )</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunComp</span><span class="params">(<span class="type">double</span> &amp;&amp; m)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="number">1.5</span>, RunComp);</span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="number">8</span>,   RunCode);</span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="number">1.5</span>, RunHome);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++11标准库中我们可以看到大量完美转发的实际应用，一些很小巧好用的函数，比如<code>make_pair</code>、<code>make_unique</code>等都通过完美转发实现了。</p>
<h2 id="显式转换操作符"><a href="#显式转换操作符" class="headerlink" title="显式转换操作符"></a>显式转换操作符</h2><p>我们确实应该阻止会产生歧义的隐式转换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Ptr</span>(T* p) : _p(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function">Ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(&amp;a)</span></span>; <span class="comment">//自动转换为bool型，没有问题</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;valid pointer. &quot;</span> &lt;&lt; endl; <span class="comment">// valid pointer</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;invalid pointer. &quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    <span class="function">Ptr&lt;<span class="type">double</span>&gt; <span class="title">pd</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; p + pd &lt;&lt; endl; <span class="comment">// 1， 相加没有意义</span></span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个指针模板类型<code>Ptr</code>。我们为指针编写了自定义类型转换到bool类型的函数，这样的转换使得<code>Ptr&lt;int&gt;</code>和<code>Ptr&lt;double&gt;</code>两个指针的加法运算获得了语法上的允许。</p>
<p>在C++11中，标准将<code>explicit</code>的使用范围扩展到了自定义的类型转换操作符上，以支持所谓的“显式类型转换”。<code>explicit</code>关键字作用于类型转换操作符上，意味着只有在直接构造目标类型或显式类型转换的时候可以使用该类型。所谓显式类型转换并没完全禁止从源类型到目标类型的转换，不过由于此时拷贝构造和非显式类型转换不被允许，那么我们通常就不能通过赋值表达式或者函数参数的方式来产生这样一个目标类型。</p>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>如标准程序库中的vector这样的容器，总是需要声明对象-循环初始化这样的重复动作，这对于使用模板的泛型编程无疑是非常不利的。在C++11中，集合(列表)的初始化已经成为C++语言的一个基本功能，在C++11中，这种初始化的方法被称为“初始化列表”。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;; <span class="comment">//C++98通过，C++11通过</span></span><br><span class="line"><span class="type">int</span> b[] &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;; <span class="comment">//C++98失败，C++11通过</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;; <span class="comment">//C++98失败，C++11通过</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">float</span>&gt; d = &#123;&#123;<span class="number">1</span>, <span class="number">1.0f</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2.0f</span>&#125;, &#123;<span class="number">5</span>, <span class="number">3.2f</span>&#125;&#125;; <span class="comment">//C++98失败，C+11通过</span></span><br></pre></td></tr></table></figure></p>
<p>我们看到了变量b、c、d在C++98的情况下均无法通过编译，在C++11中，却由于列表初始化的存在而可以通过编译。这里，列表初始化可以在“{}”花括号之前使用等号，其效果与不带使用等号的初始化相同。</p>
<p>这样一来，自动变量和全局变量的初始化在C++11中被丰富了。程序员可以使用以下几种形式完成初始化的工作</p>
<ul>
<li>等号“=”加上赋值表达式，比如<code>int a = 3+4</code></li>
<li>等号“=”加上花括号式的初始化列表，比如<code>int a = &#123;3+4&#125;</code></li>
<li>圆括号式的表达式列表，比如<code>int a (3+4)</code></li>
<li>花括号式的初始化列表，比如<code>int a &#123;3+4&#125;</code></li>
</ul>
<p>而后两种形式也可以用于获取堆内存new操作符中，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">double</span> *d = <span class="keyword">new</span> <span class="type">double</span>&#123;<span class="number">1.2f</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在C++11中，标准总是倾向于使用更为通用的方式来支持新的特性。标准模板库中容器对初始化列表的支持源自<code>&lt;initializer_list&gt;</code>这个头文件中<code>initialize_list</code>类模板的支持。程序员只要include了<code>&lt;initializer_list&gt;</code>头文件，井且声明一个以<code>initialize_list&lt;T&gt;</code>模板类为参数的构造函数，同样可以使得自定义的类使用列表初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;boy, girl&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>(initializer_list&lt;pair&lt;string, Gender&gt;&gt; l) &#123;</span><br><span class="line">        <span class="keyword">auto</span> i = l.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (; i != l.<span class="built_in">end</span>(); i ++)</span><br><span class="line">            data.<span class="built_in">push_back</span>(*i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;pair&lt;string, Gender&gt;&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">People ship2 = &#123;&#123;<span class="string">&quot;Garfield&quot;</span>, boy&#125;, &#123;<span class="string">&quot;Hellokitty&quot;</span>, girl&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>类和结构体的成员函数也可以使用初始化列表，包括一些操作符的重载函数。而在代码所示的这个例子中，我们利用了初始化列表重载了<code>operator[]</code>，并且重载了<code>operator=</code>以及使用辅助的数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mydata</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mydata &amp; <span class="keyword">operator</span>[] (initializer_list&lt;<span class="type">int</span>&gt; input) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = input.<span class="built_in">begin</span>(); i != input.<span class="built_in">end</span>(); ++i)</span><br><span class="line">            idx.<span class="built_in">push_back</span>(*i);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Mydata &amp; <span class="keyword">operator</span> = (<span class="type">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx.<span class="built_in">empty</span>() != <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = idx.<span class="built_in">begin</span>(); i != idx.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">                d.<span class="built_in">resize</span>((*i &gt; d.<span class="built_in">size</span>()) ? *i : d.<span class="built_in">size</span>());</span><br><span class="line">                d[*i - <span class="number">1</span>] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            idx.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.<span class="built_in">begin</span>(); i != d.<span class="built_in">end</span>(); ++i)</span><br><span class="line">            cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; idx;<span class="comment">//辅助数组，用于记录index</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">&#125;;</span><br><span class="line">Mydata mydata;	</span><br><span class="line">mydata[&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;] = <span class="number">7</span>;	</span><br><span class="line">mydata[&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>&#125;] = <span class="number">4</span>;	</span><br><span class="line">mydata.<span class="built_in">print</span>();</span><br></pre></td></tr></table></figure></p>
<p>此外，初始化列表还可以用于函数返回的情况。返回一个初始化列表，通常会导致构造个临时变量，比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">3</span>&#125;; &#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，跟声明时采用列表初始化一样，列表初始化构造成什么类型是依据返回类型的比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">Func2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">3</span>, <span class="number">5</span>&#125;; &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的返回值就是以<code>deque&lt;int&gt;</code>列表初始化构造函数而构造的。而跟普通的字面量相同，如果返回值是一个引用类型的话，则会返回一个临时变量的引用。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">Func1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">3</span>, <span class="number">5</span>&#125;; &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里注意，必须要加const限制符。该规则与返回一个字面常量是一样的。</p>
<h3 id="防止类型收窄"><a href="#防止类型收窄" class="headerlink" title="防止类型收窄"></a>防止类型收窄</h3><p>类型收窄一般是指一些可以使得数据变化或者精度丢失的隐式类型转换。可能导致类型收窄的典型情况如下：</p>
<ul>
<li>从浮点数隐式地转化为整型数。</li>
<li>从高精度的浮点数转为低精度的浮点数</li>
<li>从整型转化为浮点型</li>
<li>从整型转化为较低长度的整型</li>
</ul>
<p>在C++11中，使用初始化列表进行初始化的数据，编译器是会检查其是否发生类型收窄的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a = x;                  <span class="comment">// 收窄，但可以通过编译</span></span><br><span class="line"><span class="type">char</span>* b = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="number">1024</span>);    <span class="comment">// 收窄，但可以通过编译</span></span><br><span class="line"><span class="type">char</span> c = &#123;x&#125;;                <span class="comment">// 收窄，无法通过编译</span></span><br><span class="line"><span class="type">char</span> d = &#123;y&#125;;                <span class="comment">// 可以通过编译</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> e &#123;<span class="number">-1</span>&#125;;        <span class="comment">// 收窄，无法通过编译</span></span><br><span class="line"><span class="type">float</span> f &#123;<span class="number">7</span>&#125;                  <span class="comment">// 可以通过编译</span></span><br><span class="line"><span class="type">int</span> g &#123; <span class="number">2.0f</span> &#125;;              <span class="comment">// 收窄，无法通过编译</span></span><br><span class="line"><span class="type">float</span> *h = <span class="keyword">new</span> <span class="type">float</span> &#123;<span class="number">1e48</span>&#125;; <span class="comment">// 收窄，无法通过编译</span></span><br><span class="line"><span class="type">float</span> i = <span class="number">1.2l</span>;              <span class="comment">// 可以通过编译</span></span><br></pre></td></tr></table></figure></p>
<p>在C++11中，列表初始化是唯一一种可以防止类型收窄的初始化方式。这也是列表初始化区别于其他初始化方式的地方。事实上，现有编译器大多数会在发生类型收窄的时候提示用户，因为类型收窄通常是代码可能出现问题的征兆。C++11将列表初始化设定为可以防范收窄，也就是为了加强类型使用的安全性。</p>
<h2 id="POD类型"><a href="#POD类型" class="headerlink" title="POD类型"></a>POD类型</h2><p>POD是英文中 Plain Old Data的缩写。C++11将POD划分为两个基本概念的合集，即：平凡的(trivial)和标准布局的(standard layout)。</p>
<p>通常情况下，一个平凡的类或结构体应该符合以下定义：</p>
<ol>
<li>拥有平凡的默认构造函数(trivial constructor)和析构函数(trivial destructor)。平凡的默认构造函数就是说构造函数“什么都不干””。通常情况下，不定义类的构造函数，编译器就会为我们生成一个平凡的默认构造函数。而一旦定义了构造函数，即使构造函数不包含参数，函数体里也没有任何的代码，那么该构造函数也不再是“平凡”的。</li>
<li>拥有平凡的拷贝构造函数(trivial copy constructor)和移动构造函数(trivial move constructor)。平凡的拷贝构造函数基本上等同于使用<code>memcpy</code>进行类型的构造。同平凡的默认构造函数一样，不声明拷贝构造函数的话，编译器会帮程序员自动地生成。同样地，可以显式地使用<code>= default</code>声明默认拷贝构造函数。</li>
<li>拥有平凡的拷贝赋值运算符(trivial assignment operator)和移动赋值运算符(trivial move operator)。这基本上与平凡的拷贝构造函数和平凡的移动构造运算符类似。</li>
<li>不能包含虚函数以及虚基类。</li>
</ol>
<p>C++11中，我们可以通过一些辅助的类模板来帮我们进行以上属性的判断<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">std</span>::is_trivial;</span><br></pre></td></tr></table></figure></p>
<p>类模板<code>is_trivial</code>的成员<code>value</code>可以用于判断<code>T</code>的类型是否是一个平凡的类型。除了类和结构体外，<code>is_trivial</code>还可以对内置的标量类型数据及数组类型进行判断。</p>
<p>POD包含的另外一个概念是标准布局。标准布局的类或结构体应该符合以下定义：</p>
<ul>
<li>所有非静态成员有相同的访问权限(public，prvate，protected)</li>
<li>在类或者结构体继承时，满足以下两种情况之一<ul>
<li>派生类中有非静态成员，且只有一个仅包含静态成员的基类</li>
<li>基类有非静态成员，而派生类没有非静态成员</li>
<li>这样的类或者结构体，也是标准布局的。比如：<ul>
<li><code>struct B1 &#123; static int a; &#125;;</code></li>
<li><code>struct D1 : B1 &#123; int d; &#125;;</code></li>
<li><code>struct B2 &#123; int a; &#125;;</code></li>
<li><code>struct D2 : B2 &#123; static int d; &#125;</code></li>
<li><code>struct D3 : B2, B1 &#123; static int d; &#125;;</code></li>
<li><code>struct D4 : B2 &#123; int d; &#125;;</code></li>
<li><code>struct D5 : B2, D1 &#123; &#125;</code></li>
</ul>
</li>
<li>D1、D2和D3都是标准布局的，而D4和D5则不属于标准布局的。这实际上使得非静态成员只要同时出现在派生类和基类间，其即不属于标准布局的。而多重继承也会导致类型布局的一些变化，所以一且非静态成员出现在多个基类中，派生类也不属于标准布局的</li>
</ul>
</li>
<li>类中第一个非静态成员的类型与其基类不同。<ul>
<li>用于形如<code>struct A : B &#123; B b; &#125;;</code>这样的情况。这里A类型不是一个标准布局的类型，因为第一个非静态成员变量b的类型跟A所继承的类型B相同。</li>
<li>形如<code>struct C: B &#123; int a; B b; &#125;</code>则是一个标准布局的类型。</li>
<li>该规则实际上是基于C++中允许优化不包含成员的基类而产生的。</li>
</ul>
</li>
<li>没有虚函数和虚基类</li>
<li>所有非静态数据成员均符合标准布局类型，其基类也符合标准布局。</li>
</ul>
<p>在C++标准中，如果基类没有成员，标准允许派生类的第一个成员与基类共享地址，基类并没有占据任何实际的空间，但此时若该派生类的第一个成员类型仍然是基类，编译器仍会为基类分配1字节的空间，这是因为C++标准要求类型相同的对象必须地址不同，所以C++11标准强制要求POD类型的派生类的第一个非静态成员的类型必须不同于基类。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>:<span class="keyword">public</span> A1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A1 a1;</span><br><span class="line">    <span class="type">int</span> b1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span>:<span class="keyword">public</span> A1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A2 a2;</span><br><span class="line">    <span class="type">int</span> b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B3</span>:<span class="keyword">public</span> A1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> b3;</span><br><span class="line">    A1 a1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B1 b1;b<span class="number">1.</span>b1=<span class="number">0xb1</span>;</span><br><span class="line">    B2 b2;b<span class="number">2.</span>b2=<span class="number">0xb2</span>;</span><br><span class="line">    B3 b3;b<span class="number">3.</span>b3=<span class="number">0xb3</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b1)=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b1)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;b1   =&quot;</span>&lt;&lt;&amp;b1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;b1.a1=&quot;</span>&lt;&lt;&amp;b<span class="number">1.</span>a1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;b1.b1=&quot;</span>&lt;&lt;&amp;b<span class="number">1.</span>b1&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b2)=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b2)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;b2   =&quot;</span>&lt;&lt;&amp;b2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;b2.a2=&quot;</span>&lt;&lt;&amp;b<span class="number">2.</span>a2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;b2.b2=&quot;</span>&lt;&lt;&amp;b<span class="number">2.</span>b2&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b3)=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b3)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;b3   =&quot;</span>&lt;&lt;&amp;b3&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;b3.b3=&quot;</span>&lt;&lt;&amp;b<span class="number">3.</span>b3&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;b3.a1=&quot;</span>&lt;&lt;&amp;b<span class="number">3.</span>a1&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;boolalpha&lt;&lt;is_standard_layout&lt;B1&gt;::value&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;boolalpha&lt;&lt;is_standard_layout&lt;B2&gt;::value&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;boolalpha&lt;&lt;is_standard_layout&lt;B3&gt;::value&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sizeof(b1)=8</span><br><span class="line">&amp;b1   =0x28ff28</span><br><span class="line">&amp;b1.a1=0x28ff29</span><br><span class="line">&amp;b1.b1=0x28ff2c</span><br><span class="line"></span><br><span class="line">sizeof(b2)=8</span><br><span class="line">&amp;b2   =0x28ff20</span><br><span class="line">&amp;b2.a2=0x28ff20</span><br><span class="line">&amp;b2.b2=0x28ff24</span><br><span class="line"></span><br><span class="line">sizeof(b3)=8</span><br><span class="line">&amp;b3   =0x28ff18</span><br><span class="line">&amp;b3.b3=0x28ff18</span><br><span class="line">&amp;b3.a1=0x28ff1c</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p>
<p>在C++11中，我们可以使用模板类来帮助判断类型是否是一个标准布局的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">std</span>::is_standard_layout;</span><br></pre></td></tr></table></figure></p>
<p>对于POD而言，在C++11中的定义就是平凡的和标准布局的两个方面。同样地，要判定某一类型是否是POD，标准库中的<code>&lt;type_traits&gt;</code>头文件也为程序员提供了如下模板类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">std</span>::is_pod;</span><br></pre></td></tr></table></figure></p>
<p>POD最为复杂的地方还是在类或者结构体的判断。使用POD有什么好处呢?</p>
<ul>
<li>字节赋值，代码中我们可以安全地使用<code>memset</code>和<code>memcpy</code>对POD类型进行初始化和拷贝等操作。</li>
<li>提供对C内存布局兼容。C++程序可以与C函数进行相互操作，因为POD类型的数据在C与C++间的操作总是安全的</li>
<li>保证了静态初始化的安全有效。静态初始化在很多时候能够提高程序的性能，而POD类型的对象初始化往往更加简单</li>
</ul>
<h2 id="非受限联合体"><a href="#非受限联合体" class="headerlink" title="非受限联合体"></a>非受限联合体</h2><p>联合体(union)是一种构造类型的数据结构。在一个联合体内，我们可以定义多种不同的数据类型，这些数据将会共享相同内存空间，这在一些需要复用内存的情况下，可以达到节省空间的目的。</p>
<p>除了非POD类型之外，C++98标准也不允许联合体拥有静态或引用类型的成员。这样虽然可能在一定程度上保证了和C的兼容性，不过也为联合体的使用带来了很大的限制。而且通过长期的实践应用证明，C++98标准对于联合体的限制是完全没有必要的。在新的C++11标准中，取消了联合体对于数据成员类型的限制。标准规定，任何非引用类型都可以成为联合体的数据成员，这样的联合体即所谓的非受限联合体(Unrestricted Union)。</p>
<h2 id="用户自定义字面量"><a href="#用户自定义字面量" class="headerlink" title="用户自定义字面量"></a>用户自定义字面量</h2><p>在C/C++程序中，程序员常常会使用结构体或者类来创造新的类型，以满足实际的需求。C++11标准可以通过确定一个后缀标识的操作符，将声明了该后缀标识的字面量转化为需要的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> uint8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RGBA</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8 r;</span><br><span class="line">    uint8 g;</span><br><span class="line">    uint8 b;</span><br><span class="line">    uint8 a;</span><br><span class="line">    <span class="built_in">RGBA</span>(uint8 R, uint8 G, uint8 B, uint8 A = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">r</span>(R), <span class="built_in">g</span>(G), <span class="built_in">b</span>(B), <span class="built_in">a</span>(A)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RGBA <span class="keyword">operator</span> <span class="string">&quot;&quot;</span> _C(<span class="type">const</span> <span class="type">char</span>* col, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = col;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* end = col + n;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* r, *g, *b, *a;</span><br><span class="line">    r = g = b = a = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p != end; ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">&#x27;r&#x27;</span>) r = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">&#x27;g&#x27;</span>) g = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">&#x27;b&#x27;</span>) b = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">&#x27;a&#x27;</span>) a = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="literal">nullptr</span> == r) || (<span class="literal">nullptr</span> == g) || (<span class="literal">nullptr</span> == b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">nullptr</span> == a)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">RGBA</span>(<span class="built_in">atoi</span>(r + <span class="number">1</span>), <span class="built_in">atoi</span>(g + <span class="number">1</span>), <span class="built_in">atoi</span>(b + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">RGBA</span>(<span class="built_in">atoi</span>(r + <span class="number">1</span>), <span class="built_in">atoi</span>(g + <span class="number">1</span>), <span class="built_in">atoi</span>(b + <span class="number">1</span>), <span class="built_in">atoi</span>(a + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, RGBA&amp; col)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; <span class="string">&quot;r: &quot;</span> &lt;&lt; (<span class="type">int</span>)col.r</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, g: &quot;</span> &lt;&lt; (<span class="type">int</span>)col.g</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; (<span class="type">int</span>)col.b</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, a: &quot;</span> &lt;&lt; (<span class="type">int</span>)col.a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">blend</span><span class="params">(RGBA &amp;&amp; col1, RGBA &amp;&amp; col2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;blend &quot;</span> &lt;&lt; endl &lt;&lt; col1 &lt;&lt; col2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">blend</span>(<span class="string">&quot;r255 g240 b155&quot;</span>_C, <span class="string">&quot;r15 g255 b10 a7&quot;</span>_C);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">blend</span></span><br><span class="line"><span class="comment">r: 255, g: 240, b: 155, a: 0</span></span><br><span class="line"><span class="comment">r: 15, g: 255, b: 10, a: 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>这里，我们声明了一个字面量操作符(literal operator)函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RGBA <span class="keyword">operator</span> <span class="string">&quot;&quot;</span>_C(<span class="type">const</span> <span class="type">char</span> *col, <span class="type">size_t</span> n)</span><br></pre></td></tr></table></figure></p>
<p>函数。这个函数会解析以<code>_C</code>为后缀的字符串，并返回一个RGBA的临时变量。有了这样一个用户字面常量的定义，<code>main</code>函数中我们不再需要通过声明RGBA类型的声明变量-传值运算的方式来传递实际意义上的常量。通过声明一个字符串以及一个<code>_C</code>后缀，<code>operator &quot;&quot; _C</code>函数会产生临时变量。<code>blend</code>函数就可以通过右值引用获得这些临时值并进行计算了。这样一来，用户就完成了定义自定义类型的字面常量，<code>main</code>函数中的代码书写显得更加清晰。</p>
<p>在C++11中，标准要求声明字面量操作符有一定的规则该规则跟字面量的“类型”密切相关。C++11中具体规则如下：</p>
<ul>
<li>如果字面量为整型数，那么字面量操作符函数只可接受unsigned long long或者 <code>const char*</code>为其参数。当unsigned long long无法容纳该字面量的时候，编译器会自动将该字面量转化为以0为结束符的字符串，并调用以<code>const char*</code>为参数的版本进行处理。</li>
<li>如果字面量为浮点型数，则字面量操作符函数只可接受long double或者<code>const char*</code>为参数。<code>const char*</code>版本的调用规则同整型的一样。</li>
<li>如果字面量为字符串，则字面量操作符函数函数只可接受<code>const char*</code>、<code>size_t</code>为参数。</li>
<li>如果字面量为字符，则字面量操作符函数只可接受一个char为参数。</li>
</ul>
<p>应该注意以下几点:</p>
<ul>
<li>在字面量操作符函数的声明中，<code>operator&quot;&quot;</code>与用户自定义后缀之间必须有空格。</li>
<li>后缀建议以下划线开始。不宜使用非下划线后级的用户自定义字符串常量，否则会被编译器警告。</li>
</ul>
<h2 id="内联名字空间"><a href="#内联名字空间" class="headerlink" title="内联名字空间"></a>内联名字空间</h2><p>C++11中，标准引入了一个新特性，叫做“内联的名字空间”。通过关键字<code>inline namespace</code>就可以声明一个内联的名字空间。内联的名字空间允许程序员在父名字空间定义或特化子名字空间的模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Jim &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">namespace</span> Basic &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Knife</span> &#123; <span class="built_in">Knife</span>() &#123; cout &lt;&lt; <span class="string">&quot; Knife in Basic.&quot;</span> &lt;&lt; endl; &#125; &#125;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Corkscrew</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">namespace</span> Toolkit &#123;</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">SwissArmyknife</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">namespace</span> Other &#123;</span><br><span class="line">        Knife b;<span class="comment">// Knife in Basic </span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Knife</span> &#123; <span class="built_in">Knife</span>() &#123; cout &lt;&lt; <span class="string">&quot;Knife in other&quot;</span> &lt;&lt; endl; &#125; &#125;;</span><br><span class="line">        Knife c; <span class="comment">// Knife in other</span></span><br><span class="line">        Basic::Knife k; <span class="comment">// Knife in Basic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Jim &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">SwissArmyKnife</span>&lt;Knife&gt;&#123;&#125;; <span class="comment">//编译通过</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Jim;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SwissArmyKnife&lt;Knife&gt; sknife;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们将名字空间 Basic和 Toolkit都声明为 inline的。此时，Lilei对库中模板的偏特化(<code>SwissArmyKnife&lt;Knife&gt;</code>)则可以通过编译。不过这里我们需要再次注意一下 <code>Other</code>这个名字空间中的状况。可以看到，变量<code>b</code>的声明语句是可以通过编译的，而且其被声明为一个<code>Basic::Knife</code>的类型。</p>
<h2 id="模板的别名"><a href="#模板的别名" class="headerlink" title="模板的别名"></a>模板的别名</h2><p>当遇到一些比较长的名字，尤其是在使用模板和域的时候，使用别名的优势会更加明显。比如：<code>typedef std::vector&lt;std::string&gt; strvec;</code>。这里使用<code>strvec</code>作为<code>std::vector&lt;std::string&gt;</code>的别名。在C++11中，定义别名已经不再是<code>typedef</code>的专属能力，使用<code>using</code>同样也可以定义类型的别名，而且从语言能力上看，<code>using</code>丝毫不比<code>typedef</code>逊色。</p>
<p>在使用模板程的时候，<code>using</code>的语法甚至比<code>typedef</code>更加灵活。比如下面这个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> Mapstring = std::map&lt;T, <span class="type">char</span>*&gt;;</span><br><span class="line">Mapstring&lt;<span class="type">int</span>&gt; numberedstring;</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们“模板式”地使用了<code>using</code>关键字，将<code>std::map&lt;T, char*&gt;</code>定义为了一个<code>Mapstring</code>类型，之后我们还可以使用类型参数对<code>Mapstring</code>进行类型的实例化，而使用<code>typedef</code>将无法达到这样的效果。</p>
<h2 id="一般化的SFINEA规则"><a href="#一般化的SFINEA规则" class="headerlink" title="一般化的SFINEA规则"></a>一般化的SFINEA规则</h2><p>SFINEA- Substitution failure is not an error，即“匹配失败不是错误”。更为确切地说，这条规则表示的是对重载的模板的参数进行展开的时候，如果展开导致了一些类型不匹配，编译器并不会报错。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> foo;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="keyword">typename</span> T::foo)</span> </span>&#123;&#125; <span class="comment">//第一个模板定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123;&#125;   <span class="comment">// 第二个模板定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>&lt;Test&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过typename知道<code>T</code>是一个类，第二个模板定义则接受一个<code>T</code>类型的参数。在<code>main</code>函数中，分别使用<code>f&lt;Test&gt;</code>和<code>f&lt;int&gt;</code>对模板进行实例化的时候会发现，对于<code>f&lt;int&gt;</code>来讲，虽然不存在<code>int::foo</code>这样的类型，编译器依然不会报错，相反地编译器会找到第二个模板定义并对其进行实例化。这样一来，就保证了编译的正确性。</p>
<p>基本上，这是一个使得C++模板推导规则符合程序员想象的规则。通过SFINAE我们能够使得模板匹配更为“精确”，即使得一些模板函数、模板类在实例化时使用特殊的模板版本，而另外一些则使用通用的版本，这样就大大增加了模板设计使用上的灵活性。</p>
<h1 id="新手易学，老兵易用"><a href="#新手易学，老兵易用" class="headerlink" title="新手易学，老兵易用"></a>新手易学，老兵易用</h1><h2 id="右尖括号-gt-的改进"><a href="#右尖括号-gt-的改进" class="headerlink" title="右尖括号&gt;的改进"></a>右尖括号&gt;的改进</h2><p>在C++98中，有一条需要程序员规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号<code>&gt;</code>，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。我们定义了两个模板类型<code>X</code>和<code>Y</code>，并且使用模板定义分别声明了以<code>X&lt;1&gt;</code>为参数的<code>Y&lt;X&lt;1&gt;&gt;</code>类型变量<code>x1</code>，以及以<code>X&lt;2&gt;</code>为参数的<code>Y&lt;X&lt;2&gt;&gt;</code>类型变量<code>x2</code>。不过<code>x2</code>的定义编译器却不能正确解析。在<code>x2</code>的定义中，编译器会把<code>&gt;</code>优先解析为右移符号。</p>
<p>除去嵌套的模板标识，在使用形如<code>static_cast</code>、<code>dynamic cast</code>、<code>reinterpret_cast</code>或者<code>const_cast</code>表达式进行转换的时候，我们也常会遇到相同的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; v = <span class="keyword">static_cast</span>&lt;vector&lt;<span class="type">int</span>&gt;&gt;(v);</span><br></pre></td></tr></table></figure></p>
<h2 id="auto类型推导"><a href="#auto类型推导" class="headerlink" title="auto类型推导"></a>auto类型推导</h2><h3 id="静态类型、动态类型与类型推导"><a href="#静态类型、动态类型与类型推导" class="headerlink" title="静态类型、动态类型与类型推导"></a>静态类型、动态类型与类型推导</h3><p>每个变量使用前必须定义被视为编程语言中的“静态类型”的体现。而变量不需要声明，“拿来就用”则被视为“动态类型”的体现。</p>
<p>不过从技术上严格地讲，静态类型和动态类型的主要区别在于对变量进行类型检査的时间点。静态类型类型检査主要发生在编译阶段；动态类型类型检查主要发生在运行阶段。变量“拿来就用”的特性归功于类型推导。</p>
<p><code>auto</code>关键字在早期的C/C++标准中有着完全不同的含义。声明时使用<code>auto</code>修饰的变量，按照早期C/C++标准的解释，是具有自动存储期的局部变量。不过现实情况是该关键字几儿乎无人使用，因为一般函数内没有声明为<code>static</code>的变量总是具有自动存储期的局部变量。因此在C++11中，标准委员会决定赋予<code>auto</code>全新的含义，即<code>auto</code>不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，<code>auto</code>声明变量的类型必须由编译器在编译时期推导而得。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="number">1</span>;      <span class="comment">// x的类型为int</span></span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">foo</span>();  <span class="comment">// y的类型为double</span></span><br><span class="line">    <span class="keyword">auto</span> z;          <span class="comment">// 无法推导，无法通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>变量x被初始化为1，因为字面常量1的类型为<code>const int</code>，所以编译器推导出<code>x</code>的类型应该为int。同理在变量<code>y</code>的定义中，<code>auto</code>类型的<code>y</code>被推导为<code>double</code>类型；使用<code>auto</code>关键字来“声明”<code>z</code>，但不立即对其进行定义则会报错。<code>auto</code>声明的变量必须被初始化，以使编译器能够从其初始化表达式中推导出其类型。从这个意义上来讲，auto并非一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替代为变量实际的类型。</p>
<h3 id="auto的优势"><a href="#auto的优势" class="headerlink" title="auto的优势"></a>auto的优势</h3><p>直观地，auto推导的一个最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loopover</span><span class="params">(std::vector&lt;std::string&gt; &amp; vs)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt;::iterator i = vs.<span class="built_in">begin</span>();<span class="comment">//想要使用iterator，往往需要大量代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们想定义一个迭代器<code>i</code>的时侯我们必须写出<code>std::vector&lt;std::string&gt;::iterator</code>这样长的类型声明。这么长的类型声明只需要一个<code>auto</code>即可。</p>
<p><code>auto</code>的第二个优势则在于可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误。对于不同的平台上的代码维护，<code>auto</code>也会带来一些“泛型”的好处。这里我们以<code>strlen</code>函数为例，在32位的编译环境下，<code>strlen</code>返回的为一个4字节的整型，而在64位的编译环境下，<code>strlen</code>会返回一个8字节的整型。虽然系统库<code>&lt;cstring&gt;</code>为其提供了<code>size_t</code>类型来支持多平台间的代码共享支持，但是使用<code>auto</code>关键字我们同样可以达到代码跨平台的效果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> var = <span class="built_in">strlen</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>由于<code>size_t</code>的适用范围往往局限于<code>&lt;cstring&gt;</code>中定义的函数，<code>auto</code>的适用范围明显更为广泛。</p>
<h3 id="auto的使用细则"><a href="#auto的使用细则" class="headerlink" title="auto的使用细则"></a>auto的使用细则</h3><p>在C++11中，auto可以与指针和引用结合起来使用，使用的效果基本上会符合C/C++程序员的想象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x; </span><br><span class="line"><span class="type">int</span> * y = &amp;x; </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">foo</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> &amp; <span class="title">bar</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> * a = &amp;x; <span class="comment">// int* </span></span><br><span class="line"><span class="keyword">auto</span> &amp; b = x; <span class="comment">// int&amp; </span></span><br><span class="line"><span class="keyword">auto</span> c = y; <span class="comment">// int* </span></span><br><span class="line"><span class="keyword">auto</span> * d = y; <span class="comment">// int* </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> * e = &amp;<span class="built_in">foo</span>(); <span class="comment">// 编译失败，指针不能指向一个临时变量</span></span><br><span class="line"><span class="keyword">auto</span> &amp; f = <span class="built_in">foo</span>(); <span class="comment">// 编译失败，nonconst的左值引用不能和一个临时变量绑定</span></span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bar</span>(); <span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> &amp; h = <span class="built_in">bar</span>(); <span class="comment">// int&amp;</span></span><br></pre></td></tr></table></figure></p>
<p>本例中，变量a、c、d的类型都是指针类型，且都指向变量x。实际上对于a、c、d变量而言，声明其为<code>auto*</code>或<code>auto</code>并没有区别。而如果要使得<code>auto</code>声明的变量是另一个变量的引用，则必须使用<code>auto&amp;</code>，如同本例中的变量b和h一样。</p>
<p>其次，<code>auto</code>与<code>volatile</code>和<code>const</code>之间也存在着一些相互的联系。<code>volatile</code>和<code>const</code>代表了变量的两种不同的属性：易失的和常量的。在C++标准中，它们常常被一起叫作cv限制符(cv-qualifier)。鉴于cv限制符的特殊性，C+1标准规定<code>auto</code>可以与cv限制符一起使用。不过声明为<code>auto</code>的变量并不能从其初始化表达式中“带走”cv限制符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">foo</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="type">float</span> * <span class="title">bar</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> a = <span class="built_in">foo</span>(); <span class="comment">// a: const double </span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp; b = <span class="built_in">foo</span>(); <span class="comment">// b: const double&amp; </span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">auto</span> * c = <span class="built_in">bar</span>(); <span class="comment">// c: volatile float* </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> d = a; <span class="comment">// d: double </span></span><br><span class="line"><span class="keyword">auto</span> &amp; e = a; <span class="comment">// e: const double &amp; </span></span><br><span class="line"><span class="keyword">auto</span> f = c; <span class="comment">// f: float * </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">auto</span> &amp; g = c; <span class="comment">// g: volatile float * &amp; </span></span><br></pre></td></tr></table></figure></p>
<p>我们可以通过非cv限制的类型初始化一个cv限制的类型，如变量a、b、c所示。不过通过auto声明的变量d、f却无法带走a和f的常量性或者易失性。这里的例外还是引用，可以看出，声明为引用的变量e、g都保持了其引用的对象相同的属性。此外，跟其他的变量指示符一样，同一个赋值语句中，auto可以用来声明多个变量的类型，不过这些变量的类型必须相同。如果这些变量的类型不相同，编译器则会报错。事实上，用auto来声明多个变量类型时，只有第一个变量用于auto的类型推导，然后推导出来的数据类型被作用于其他的变量。所以不允许这些变量的类型不相同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>, y = <span class="number">2</span>; <span class="comment">// x和y的类型均为int </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// m是一个指向const int类型变量的指针，n是一个int类型的变量 </span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>* m = &amp;x, n = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">1</span>, j = <span class="number">3.</span> <span class="number">14</span>f; <span class="comment">// 编译失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> o = <span class="number">1</span>, &amp;p = o, *q = &amp;p; <span class="comment">// 从左向右推导</span></span><br></pre></td></tr></table></figure></p>
<p>我们使用auto声明了两个类型相同变量x和y，并用逗号进行分隔，这可以通过编译。而在声明变量i和j的时候，按照我们所说的第一变量用于推导类型的规则，那么由于x所推导出的类型是int，那么对于变量j而言，其声明就变成了<code>int j = 3.14f</code>，这无疑会导致精度的损失。而对于变量m和n，就变得非常有趣，这里似乎是auto被替换成了int，所以m是一个<code>int*</code>指针类型，而n只是一个<code>int</code>类型。同样的情况也发生在变量o、p、q上，这里o是一个类型为<code>int</code>的变量，p是o的引用，而q是p的指针。<code>auto</code>的类型推导按照从左往右，且类似于字面替换的方式进行。事实上，标准里称auto是一个将要推导出的类型的“占位符”(placeholder)。这样的规则无疑是直观而让人略感意外的。</p>
<p>受制于语法的二义性，或者是实现的困难性，auo往往也会有使用上的限制。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">( <span class="keyword">auto</span> x = <span class="number">1</span>)</span></span>&#123;&#125; <span class="comment">// 1: auto函数参数，无法通过编译 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span>&#123; </span><br><span class="line">    <span class="keyword">auto</span> var = <span class="number">10</span>; <span class="comment">// 2: auto非静态成员变量，无法通过编译</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">char</span> x[ <span class="number">3</span>]; </span><br><span class="line">    <span class="keyword">auto</span> y = x; </span><br><span class="line">    <span class="keyword">auto</span> z[ <span class="number">3</span>] = x; <span class="comment">// 3: auto数组，无法通过编译</span></span><br><span class="line">    <span class="comment">// 4: auto模板参数（实例化时），无法通过编译</span></span><br><span class="line">    vector&lt; <span class="keyword">auto</span>&gt; v = &#123;<span class="number">1</span>&#125;; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<ol>
<li>对于函数<code>fun</code>来说，auto不能是其形参类型。<code>auto</code>是不能做形参的类型的。如果程序员需要泛型的参数，还是需要求助于模板。</li>
<li>对于结构体来说，非静态成员变量的类型不能是<code>auto</code>的。同样的，由于<code>var</code>定义了初始值，读者可能认为<code>auto</code>可以推导<code>str</code>成员<code>var</code>的类型为<code>int</code>的。但编译器阻止<code>auto</code>对结构体中的非静态成员进行推导，即使成员拥有初始值。</li>
<li>声明<code>auto</code>数组。我们可以看到，<code>main</code>中的<code>x</code>是一个数组，<code>y</code>的类型是可以推导的。而声明<code>auto z[3]</code>这样的数组同样会被编译器禁止</li>
<li>在实例化模板的时候使用<code>auto</code>作为模板参数，如<code>main</code>中我们声明的<code>vector&lt;auto&gt;</code>虽然读者可能认为这里一眼而知是int类型，但编译器却阻止了编译。</li>
</ol>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><h3 id="typeid与decltype"><a href="#typeid与decltype" class="headerlink" title="typeid与decltype"></a>typeid与decltype</h3><p>C++98对动态类型支持就是C++中的运行时类型识别(RTTI)。RTTI的机制是为每个类型产生一个type info类型的数据，程序员可以在程序中使用<code>typeid</code>随时查询一个变量的类型，<code>typeid</code>就会返回变量相应的<code>type_info</code>数据。而<code>type_info</code>的<code>name</code>成员函数可以返回类型的名字。而在C++11中，又增加了<code>hash_code</code>，这个成员函数返回该类型唯一的哈希值，以供程序员对变量的类型随时进行比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">White</span>&#123;&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Black</span>&#123;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    White a; </span><br><span class="line">    Black b; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">// 5White </span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">// 5Black </span></span><br><span class="line">    White c; </span><br><span class="line">    <span class="type">bool</span> a_b_sametype = (<span class="built_in">typeid</span>(a).<span class="built_in">hash_code</span>() == <span class="built_in">typeid</span>(b).<span class="built_in">hash_code</span>()); </span><br><span class="line">    <span class="type">bool</span> a_c_sametype = (<span class="built_in">typeid</span>(a).<span class="built_in">hash_code</span>() == <span class="built_in">typeid</span>(c).<span class="built_in">hash_code</span>()); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Same type? &quot;</span> &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A and B? &quot;</span> &lt;&lt; (<span class="type">int</span>) a_b_sametype &lt;&lt; endl; <span class="comment">// 0 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A and C? &quot;</span> &lt;&lt; (<span class="type">int</span>) a_c_sametype &lt;&lt; endl; <span class="comment">// 1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在RTTI的支持下，程序员可以在一定程度上了解程序中类型的信息。除了<code>typeid</code>外，RTTI还包括了C++中的<code>dynamic_cast</code>等特性。不过不得不提的是，由于RTTI会带来一些运行时的开销，所以一些编译器会让用户选择性地关闭该特性(比如XLCC++编译器的- qnortti，GCC的选项-fno-rttion，或者微软编译器选项/GR-)。</p>
<p>在decltype产生之前，很多编译器的厂商都开发了自己的C++语言扩展用于类型推导。比如GCC的<code>typeof</code>操作符就是其中的一种。C++11则将这些类型推导手段标准化为<code>auto</code>以及<code>decltype</code>。与<code>auto</code>类似地，<code>decltype</code>也能进行类型推导，不过两者的使用方式却有一定的区别。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">decltype</span>(i) j = <span class="number">0</span>; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(j).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">// 打印出&quot; i&quot;, g++ 表示 int </span></span><br><span class="line">    <span class="type">float</span> a; </span><br><span class="line">    <span class="type">double</span> b; </span><br><span class="line">    <span class="keyword">decltype</span>(a + b) c; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">// 打印出&quot; d&quot;, g++ 表示 double </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p>我们看到变量j的类型由<code>decltype(i)</code>进行声明，表示j的类型跟i相同。而c的类型则跟<code>(a+b)</code>这个表达式返回的类型相同。而由于<code>a+b</code>加法表达式返回的类型为double，所以<code>c</code>的类型被 <code>decltype</code>推导为double。</p>
<p>从这个例子中可以看到，<code>decltype</code>的类型推导并不是像<code>auto</code>一样是从变量声明的初始化表达式获得变量的类型，<code>decltype</code>总是以一个普通的表达式为参数，返回该表达式的类型。而与<code>auto</code>相同的是，作为一个类型指示符，<code>decltype</code>可以将获得的类型来定义另外一个变量。与<code>auto</code>相同，<code>decltype</code>类型推导也是在编译时进行的。</p>
<h3 id="decltype的应用"><a href="#decltype的应用" class="headerlink" title="decltype的应用"></a>decltype的应用</h3><p>在C+11中，使用<code>decltype</code>推导类型是非常常见的事情。比较典型的就是<code>decltype</code>与<code>typedef/using</code>的合用。在C++11的头文件中，我们常能看以下这样的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> size_ t = <span class="keyword">decltype</span>(<span class="built_in">sizeof</span>(<span class="number">0</span>)); </span><br><span class="line"><span class="keyword">using</span> ptrdiff_ t = <span class="keyword">decltype</span>((<span class="type">int</span>*) <span class="number">0</span> - (<span class="type">int</span>*) <span class="number">0</span>); </span><br><span class="line"><span class="keyword">using</span> nullptr_ t = <span class="keyword">decltype</span>(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里<code>size_t</code>以及<code>ptrdiff_t</code>还有<code>nullptr_t</code>都是由<code>decltype</code>推导出的类型。这种定义方式非常有意思。在一些常量、基本类型、运算符、操作符等都已经被定义好的情况下，类型可以按照规则被推导出。而使用<code>using</code>，就可以为这些类型取名。这就颠覆了之前类型拓展需要将扩展类型“映射”到基本类型的常规做法。</p>
<p>除此之外，<code>decltype</code>在某些场景下，可以极大地增加代码的可读性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(vec.begin())</span> vectype</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vectype i = vec.<span class="built_in">begin</span>(); i &lt; vec.<span class="built_in">end</span>(); i ++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">decltype</span>(vec)::iterator i = vec.<span class="built_in">begin</span>(); i &lt; vec.<span class="built_in">end</span>(); i ++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p>我们定义了vector的iterator的类型。这个类型还可以在<code>main</code>函数中重用。当我们遇到一些具有复杂类型的变量或表达式时，就可以利用<code>decltype</code>和<code>typedef using</code>的组合来将其转化为一个简单的表达式，这样在以后的代码写作中可以提高可读性和可维护性。此外我们可以看到<code>decltype(vec)::iterator</code>这样的灵活用法，这看起来跟<code>auto</code>非常类似，也类似于是一种“占位符”式的替代。</p>
<p>拥有了<code>decltype</code>这个利器之后，重用匿名类型也并非难事。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">class</span> &#123;K1, K2, K3&#125; anon_e; <span class="comment">//匿名的强类型枚举</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">decltype</span> (anon_e) key;</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">&#125; anon_u;<span class="comment">//匿名的 union联合体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">decltype</span>(anon_u) id; </span><br><span class="line">&#125; anon_s[<span class="number">100</span>]; <span class="comment">// 匿名的struct数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>&lt;anon_s) as;</span><br><span class="line">    as[<span class="number">0</span>].id.key = <span class="keyword">decltype</span>(anon_e)::K1; <span class="comment">//引用匿名强类型枚举中的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用了3种不同的匿名类型：匿名的强类型枚举<code>anon_e</code>、匿名的联合体<code>anon_u</code>，以及匿名的结构体数组<code>anon_s</code>。可以看到，只要通过匿名类型的变量名<code>anon_e</code>、<code>anon_u</code>，以及<code>anon_s</code>,<code>decltype</code>可以推导其类型并且进行重用。</p>
<p>有了<code>decltype</code>，我们可以适当扩大模板泛型的能力。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sum</span><span class="params">(T1 &amp; t1, T2 &amp; t2, <span class="keyword">decltype</span>(t1+t2) &amp; s)</span> </span>&#123;</span><br><span class="line">    s = t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，<code>Sum</code>的适用范围增加，因为其返回的类型不再是单一的类型，而是根据<code>t1+2</code>推导而来的类型。不过这里还是有一定的限制，我们可以看到返回值的类型必须一开始就被指定，程序员必须清楚<code>Sum</code>运算的结果使用什么样的类型来存储是合适的，这在一些泛型编程中依然不能满足要求。解决的方法是结合<code>decltype</code>与<code>auto</code>关键字，使用追踪返回类型的函数定义来使得编译器对函数返回值进行推导。</p>
<p>我们在实例化一些模板的时候，<code>decltype</code>也可以起到一些作用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">char</span>*, <span class="keyword">decltype</span>(hash)&gt; dict_key; <span class="comment">// 无法通过编译</span></span><br><span class="line">map&lt;<span class="type">char</span>*, <span class="keyword">decltype</span>(hash(<span class="literal">nullptr</span>))&gt; dict_key1;</span><br></pre></td></tr></table></figure></p>
<p>我们实例化了标准库中的<code>map</code>模板。因为该<code>map</code>是为了存储字符串以及与其对应哈希值的，因此我们可以通过<code>decltype(hash(nullptr)</code>来确定哈希值的类型。这样的定义非常直观，但是程序员必须要注意的是，<code>decltype</code>只能接受表达式做参数，像函数名做参数的表达式<code>decltype(hash)</code>是无法通过编译的。</p>
<p>一些标准库的实现也会依赖于类型推导。一个典型的例子是基于<code>decltype</code>的模板类<code>result_of</code>，其作用是推导函数的返回类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    result_of&lt;<span class="built_in">func</span>()&gt;::type f;</span><br><span class="line">    <span class="comment">//由func()推导其结果类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里f的类型最终被推导为double，而<code>result_of</code>并没有真正调用<code>func()</code>这个函数，这切都是因为底层的实现使用了<code>decltype</code>。<code>result_of</code>的一个可能的实现方式如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">result_of</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>.. ArgTypes&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">result_of</span>&lt;<span class="built_in">F</span>(ArgTypes.. )&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        std::declval&lt;F&gt;()(std::declval&lt;ArgTypes&gt;()...)</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> type</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里标准库将<code>decltype</code>作用于函数调用上，并将函数调用表达式返回的类型<code>typedef</code>为一个名为<code>type</code>的类型。这样一来，<code>result_of&lt;func()&gt;::type</code>就会被<code>decltype</code>推导为<code>double</code>。</p>
<h3 id="decltype推导四规则"><a href="#decltype推导四规则" class="headerlink" title="decltype推导四规则"></a>decltype推导四规则</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">decltype</span>(i) a;</span><br><span class="line"><span class="keyword">decltype</span>((i)) b;  <span class="comment">// b int&amp;: 必须初始化引用</span></span><br></pre></td></tr></table></figure>
<p><code>decltype((i))b</code>这样的语句编译不过。编译器会提示<code>b</code>是一个引用，但没有被赋初值。而<code>decltypet(i) a</code>这一句却能通过编译，因为其类型被如预期地推导为<code>int</code>。这种问题显得非常诡异，单单多了一对圆括号，<code>decltype</code>所推导出的类型居然发生了变化。事实上，C++11中<code>decltype</code>推导返回类型的规则比我们想象的复杂。具体地，当程序员用<code>decltype(e)</code>来获取类型时，编译器将依序判断以下四规则：</p>
<ol>
<li>如果<code>e</code>是一个没有带括号的标记符表达式或者类成员访问表达式，那么<code>decltype(e)</code>就是<code>e</code>所命名的实体的类型。此外，如果<code>e</code>是一个被重载的函数，则会导致编译时错误。</li>
<li>否则，假设<code>e</code>的类型是<code>T</code>，如果<code>e</code>是一个将亡值，那么<code>decltype(e)</code>为<code>T&amp;&amp;</code>。</li>
<li>否则，假设<code>e</code>的类型是<code>T</code>，如果<code>e</code>是一个左值，则<code>decltype(e)</code>为<code>T&amp;</code>。</li>
<li>否则，假设<code>e</code>的类型是<code>T</code>，则<code>decltype(e)</code>为<code>T</code>。</li>
</ol>
<p>基本上，所有除去关键字、字面量等编译器需要使用的标记之外的程序员自定义的标记都可以是标记符。而单个标记符对应的表达式就是标记符表达式。比如程序员定义了<code>int arr[4]</code>，那么<code>arr</code>是一个标记符表达式，而<code>arr[3]+0</code>，<code>arr[3]</code>等，则都不是标记符表达式。</p>
<p><code>decltype(i) a</code>使用了推导规则1，因为<code>i</code>是一个标记符表达式，所以类型被推导为<code>int</code>；而<code>decltype((i))b</code>中，由于<code>(i)</code>不是一个标记符表达式，但却是一个左值表达式(可以有具名的地址)，因此，按照 <code>decltype</code>推导规则3，其类型应该是一个int的引用。上面的规则看起来非常复杂，但事实上，在实际应用中，<code>decltype</code>类型推导规则中最容易引起迷惑的只有规则1和规则3。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123; <span class="type">double</span> d; &#125; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overloaded</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overloaded</span><span class="params">(<span class="type">char</span>)</span></span>; <span class="comment">//重载的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;&amp; <span class="title">RvalRef</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则1:单个标记符表达式以及访问类成员，推导为本类型</span></span><br><span class="line"><span class="keyword">decltype</span>(arr) var1;        <span class="comment">// int[5]，标记符表达式</span></span><br><span class="line"><span class="keyword">decltype</span>(ptr) var2;        <span class="comment">// int*，标记符表达式</span></span><br><span class="line"><span class="keyword">decltype</span>(s.d) var4;        <span class="comment">// doub1e，成员访问表达式</span></span><br><span class="line"><span class="keyword">decltype</span>(Overloaded) var5; <span class="comment">// 无法通过编译，是个重载的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//规则2:将亡值，推导为类型的右值引用</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">RvalRef</span>()) var6 = <span class="number">1</span>; <span class="comment">//int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则3:左值，推导为类型的引用</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="literal">true</span> ? i : i) var7 = i;       <span class="comment">// int&amp;，三元运算符，这里返回一个i的左值</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) var8 = i;                <span class="comment">// int&amp;，带圆括号的左值</span></span><br><span class="line"><span class="keyword">decltype</span>(++i) var9 = i;                <span class="comment">// int&amp;，++i返回i的左值</span></span><br><span class="line"><span class="keyword">decltype</span>(arr[<span class="number">3</span>]) var10 = i             <span class="comment">// int[]操作返回左值</span></span><br><span class="line"><span class="keyword">decltype</span>(*ptr) var11 = i;              <span class="comment">// int&amp; *操作返回左值</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="string">&quot;lval&quot;</span>) var12 = <span class="string">&quot;lval&quot;</span>;       <span class="comment">// const char(&amp;)[9]，字符串字面常量为左值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//规则4:以上都不是，推导为本类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">1</span>) var13;                     <span class="comment">// int，除字符串外字面常量为右值</span></span><br><span class="line"><span class="keyword">decltype</span>(i++)var14;                    <span class="comment">// int，i++返回右值</span></span><br><span class="line"><span class="keyword">decltype</span>((<span class="built_in">Func</span>(<span class="number">1</span>))) var15;             <span class="comment">// const bool，圆括号可以忽略</span></span><br></pre></td></tr></table></figure></p>
<p>另外一些时候，C++11标准库中添加的模板类<code>is_lvalue_reference</code>，可以帮助程序员进行一些推导结果的识别。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::is_lvalue_reference&lt;<span class="keyword">decltype</span>(++i)&gt;::value &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></p>
<p>结果1表示为左值，结果为0为非右值。同样的，也有<code>is_rvalue_reference</code>这样的模板类来判断decltype推断结果是否为右值。</p>
<h3 id="cv限制符的继承与冗余的符号"><a href="#cv限制符的继承与冗余的符号" class="headerlink" title="cv限制符的继承与冗余的符号"></a>cv限制符的继承与冗余的符号</h3><p>与auto类型推导时不能“带走”cv限制符不同， decltype是能够“带走”表达式的cv限制符的。不过，如果对象的定义中有 const 或 volatile 限制符，使用 decltype进行推导时其成员不会继承 const或 volatile限制符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ic = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> iv;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">S</span>&#123; <span class="type">int</span> i; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> S a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">volatile</span> S b;</span><br><span class="line">    <span class="keyword">volatile</span> S*p = &amp;b;</span><br><span class="line">    std::cout &lt;&lt; std::is_const&lt;<span class="keyword">decltype</span>(ic)&gt;::value &lt;&lt; std::endl;       <span class="comment">//1 推导类型为:const int</span></span><br><span class="line">    std::cout &lt;&lt; std::is_volatile&lt;<span class="keyword">decltype</span>(iv)&gt;::value &lt;&lt; std::endl;    <span class="comment">//1 推导类型为:volatile int</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::is_const&lt;<span class="keyword">decltype</span>(a)&gt;::value &lt;&lt; std::endl;        <span class="comment">//1 推导类型为:const S</span></span><br><span class="line">    std::cout &lt;&lt; std::is_volatile&lt;<span class="keyword">decltype</span>(b)&gt;::value &lt;&lt; std::endl;     <span class="comment">//1 推导类型为:volatile S</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::is_const&lt;<span class="keyword">decltype</span>(a.i)&gt;::value &lt;&lt; std::endl;      <span class="comment">//0 推导类型a为const,但是成员不继承const类型</span></span><br><span class="line">    std::cout &lt;&lt; std::is_volatile&lt;<span class="keyword">decltype</span>(p-&gt;i)&gt;::value &lt;&lt; std::endl;  <span class="comment">//0 推导类型p为volatile,但是成员不继承volatile类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，结构体变量a、b和结构体指针p的cv限制符并没有出现在其成员的 decltype类型推导结果中。而与auto相同的， decltype从表达式推导出类型后，进行类型定义时，也会允许一些冗余的符号。比如cv限制符以及引用符号<code>&amp;</code>，通常情况下，如果推导出的类型已经有了这些属性，冗余的符号则会被忽略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>&amp; j = i;</span><br><span class="line">    <span class="type">int</span> *p = &amp;i;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(i)&amp; var1 = i;</span><br><span class="line">    <span class="keyword">decltype</span>(j)&amp; var2 = i;</span><br><span class="line">    std::cout &lt;&lt; std::is_lvalue_reference&lt;<span class="keyword">decltype</span>(var1)&gt;::value &lt;&lt; std::endl;    <span class="comment">//1,是左值引用</span></span><br><span class="line">    std::cout &lt;&lt; std::is_rvalue_reference&lt;<span class="keyword">decltype</span>(var2)&gt;::value &lt;&lt; std::endl;    <span class="comment">//0,不是右值引用</span></span><br><span class="line">    std::cout &lt;&lt; std::is_lvalue_reference&lt;<span class="keyword">decltype</span>(var2)&gt;::value &lt;&lt; std::endl;    <span class="comment">//1，是左值引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//decltype(p)* var3 = &amp;i;   //编译错误</span></span><br><span class="line">    <span class="keyword">decltype</span>(p)* var4 = &amp;p;     <span class="comment">//var4的类型为int **</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* v3 = p;               <span class="comment">//v3的类型为int *</span></span><br><span class="line">    v3 = &amp; i;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">decltype</span><span class="params">(k)</span> var5 </span>= <span class="number">1</span>; <span class="comment">//冗余的const,被忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了类型为<code>decltype(i)&amp;</code>的变量<code>var1</code>，以及类型为<code>decltype(j)&amp;</code>的变量<code>var2</code>。由于<code>i</code>的类型为int，所以这里的引用符号保证<code>var1</code>成为一个<code>int&amp;</code>引用类型。而由于<code>j</code>本来就是一个<code>int&amp;</code>的引用类型，所以<code>decltype</code>之后的<code>&amp;</code>成为了冗余符号，会被编译器忽略，因此<code>j</code>的类型依然是<code>int&amp;</code>。这里特别要注意的是<code>decltype(p)*</code>的情况。可以看到，在定义<code>var3</code>变量的时候，由于<code>p</code>的类型是<code>int*</code>，因此<code>var3</code>被定义为了<code>int**</code>类型。这跟<code>auto</code>声明中，<code>*</code>也可以是冗余的不同。在<code>decltype</code>后的<code>*</code>号，并不会被编译器忽略。</p>
<p>此外我们也可以看到，<code>var4</code>中const可以被冗余的声明，但会被编译器忽略，同样的情况也会发生在<code>volatile</code>限制符上。总的说来，<code>decltype</code>算得上是C++11中类型推导使用方式上最灵活的一种。虽然看起来它的推导规则比较复杂，有的时候跟auto推导结果还略有不同，但大多数时候，我们发现使用<code>decltype</code>还是自然而亲切的。</p>
<h2 id="追踪返回类型"><a href="#追踪返回类型" class="headerlink" title="追踪返回类型"></a>追踪返回类型</h2><h3 id="追踪返回类型的引入"><a href="#追踪返回类型的引入" class="headerlink" title="追踪返回类型的引入"></a>追踪返回类型的引入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(t1+t2)</span> <span class="title">Sum</span><span class="params">(T1&amp; t1, T2&amp; t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器在推导<code>decltype(t1+t2)</code>时，表达式中的<code>t1</code>和<code>t2</code>都未声明，为了解决这个问题C++11引入新语法——追踪返回类型，来声明和定义这样的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(T1 &amp;t1, T2 &amp;t2)</span> -&gt; <span class="title">decltype</span><span class="params">(t1 + t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们把函数的返回值移至参数声明之后，复合符号<code>decltype(t1 + t2)</code>被称为追踪返回类型。而原本函数返回值的位置由<code>auto</code>关键字占据。这样，我们就可以让编译器来推导<code>Sum</code>函数模板的返回类型了。而<code>auto</code>占位符和<code>-&gt; ereturn type</code>也就是构成追踪返回类型函数的两个基本元素</p>
<h3 id="使用追踪返回类型的函数"><a href="#使用追踪返回类型的函数" class="headerlink" title="使用追踪返回类型的函数"></a>使用追踪返回类型的函数</h3><p>追踪返回类型的函数和普通函数的声明最大的区别在于返回类型的后置。在一般情况下，普通函数的声明方式会明显简单于最终返回类型。比如<code>int func (char a, int b)</code>这样的书写会比下面<code>auto func(char*a, int b)-&gt; int</code>少上不少。</p>
<p>如我们刚才提到的，返回类型后置，使模板中的一些类型推导就成为了可能。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(<span class="type">const</span> T1 &amp; t1, <span class="type">const</span> T2 &amp; t2)</span> -&gt; <span class="title">decltype</span><span class="params">(t1 + t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Mul</span><span class="params">(<span class="type">const</span> T1 &amp; t1, <span class="type">const</span> T2 &amp; t2)</span> -&gt; <span class="title">decltype</span><span class="params">(t1 * t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 * t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">4L</span>;</span><br><span class="line">    <span class="keyword">auto</span> pi = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">Mul</span>(<span class="built_in">Sum</span>(a, b), pi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了两个模板函数<code>Sum</code>和<code>Mul</code>，它们的参数的类型和返回值都在实例化时决定。而由于<code>main</code>函数中还使用了auto，整个例子中没有看到一个具体的类型声明。</p>
<p>追踪返回类型的另一个优势是简化函数的定义，提高代码的可读性。这种情况常见于函数指针中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*(*<span class="built_in">pf</span>())())() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// auto (*)() -&gt; int(*)() 一个返回函数指针的函数(假设为a函数)</span></span><br><span class="line"><span class="comment">// auto pf1() -&gt; auto (*)() -&gt; int(*)() 一个返回a函数的指针的函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pf1</span><span class="params">()</span> -&gt; <span class="title">auto</span><span class="params">(*)</span><span class="params">()</span>-&gt; <span class="title">int</span> <span class="params">(*)</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    eturn <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; is_same&lt;<span class="keyword">decltype</span>(pf), <span class="keyword">decltype</span>(pf1)&gt;::value &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>定义了两个类型完全一样的函数<code>pf</code>和<code>pf1</code>其返回的都是一个函数指针。而该函数指针又指向一个返回函数指针的函数。这一点通过<code>is_same</code>的成员value已经能够确定了。而仔细看一看函数类型的声明，可以发现老式的声明法可读性非常差。而追踪返回类型只需要依照从右向左的方式，就可以将嵌套的声明解析出来。这大大提高了嵌套函数这类代码的可读性。</p>
<p>除此之外，追踪返回类型也被广泛地应用在转发函数中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)a + <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Forward</span><span class="params">(T t)</span> -&gt; <span class="title">decltype</span><span class="params">(foo(t))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Forward</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Forward</span>(<span class="number">0.5</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>由于使用了追踪返回类型，可以实现参数和返回类型不同时的转发。</p>
<p>追踪返回类型还可以用在函数指针中，其声明方式与追踪返回类型的函数比起来，并没有太大的区别。比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto</span>(*fp)() -&gt; <span class="type">int</span></span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*fp) ();</span><br></pre></td></tr></table></figure></p>
<p>的函数指针声明是等价的。同样的情况也适用于函数引用，比如：<code>auto (&amp;fr)() -&gt; int</code>和<code>int (&amp;fr)();</code>的声明也是等价的。</p>
<p>P 168</p>
<h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><p>C++的标准模板库中，我们可以找到形如<code>for_each</code>的模板函数。如果我们使用<code>for_each</code>，代码看起来会是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">action1</span><span class="params">(<span class="type">int</span> &amp;e)</span> </span>&#123; e *= <span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">action2</span><span class="params">(<span class="type">int</span> &amp;e)</span> </span>&#123; cout &lt;&lt; e &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    for_each(arr, arr+<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(arr[<span class="number">0</span>]), action1);</span><br><span class="line">    for_each(arr, arr+<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(arr[<span class="number">0</span>]), action2);</span><br></pre></td></tr></table></figure></p>
<p>上述代码要告诉循环体其界限的范围，即<code>arr</code>到<code>arr+sizeof(arr)/sizeof(arr[0])</code>之间，才能按元素执行操作。</p>
<p>C++11也引入了基于范围的for循环，就可以很好地解决了这个问题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;e: arr)</span><br><span class="line">        e *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;e: arr)</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个基于范围的for循环的实例。for循环后的括号由冒号<code>:</code>分为两部分，第一部分是范围内用于迭代的变量，第二部分则表示将被送代的范围。基于范围的for循环跟普通循环是一样的，可以用continue语句来跳过循环的本次迭代，而用break语句来跳出整个循环。</p>
<p>值得指出的是，是否能够使用基于范围的for循环，必须依赖于一些条件。首先，就是for循环迭代的范围是可确定的。对于类来说，如果该类有<code>begin</code>和<code>end</code>函数，那么<code>begin</code>和<code>end</code>之间就是for循环迭代的范围。对于数组而言，就是数组的第一个和最后一个元素间的范围。其次，基于范围的for循环还要求迭代的对象实现<code>++</code>和<code>==</code>等操作符。对于标准库中的容器，如string、aray、 vector、 deque、list、 queue、map、set等，不会有问题，因为标准库总是保证其容器定义了相关的操作。普通的已知长度的数组也不会有问题。而用户自己写的类，则需要自行提供相关操作。</p>
<h1 id="提高类型安全"><a href="#提高类型安全" class="headerlink" title="提高类型安全"></a>提高类型安全</h1><h2 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h2><h3 id="强类型枚举-1"><a href="#强类型枚举-1" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p>非强类型作用域，允许隐式转换为整型，占用存储空间及符号性不确定，都是枚举类的缺点。针对这些缺点，新标准C++11引入了一种新的枚举类型，即“枚举类”，又称“强类型枚举”。声明强类型枚举非常简单，只需要在<code>enum</code>后加上关键字<code>class</code>。比如<code>enum class Type &#123; General, Light, Medium, Heavy&#125;;</code>就声明了一个强类型的枚举<code>Type</code>。</p>
<p>强类型枚举具有以下几点优势</p>
<ul>
<li>强作用域，强类型枚举成员的名称不会被输出到其父作用域空间。</li>
<li>转换限制，强类型枚举成员的值不可以与整型隐式地相互转换。</li>
<li>可以指定底层类型。强类型枚举默认的底层类型为int，但也可以显式地指定底层类型具体方法为在枚举名称后面加上“:type”，其中<code>type</code>可以是除<code>wchar_t</code>以外的任何整型。比如<code>enum class Type: char &#123; General, Light, Medium, Heavy&#125;;</code>就指定了<code>Type</code>是基于<code>char</code>类型的强类型枚举。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Type</span> &#123; General, Light, Medium, Heavy &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Category</span> &#123; General = <span class="number">1</span>, Pistol, Machinegun, Cannon&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Type t = Type::Light;</span><br><span class="line">    t = General;                <span class="comment">//编译失败，必须使用强类型名称</span></span><br><span class="line">    <span class="keyword">if</span> (t == Category::General) <span class="comment">//编译失败，必须使用Type中的 General</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;General Weapon&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; Type::General)      <span class="comment">//通过编译</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Not General Weapon&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0</span>)                  <span class="comment">//编译失败，无法转换为int类型</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Not General Weapon&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">int</span>)t &gt; <span class="number">0</span>)             <span class="comment">//通过编译</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Not General Weapon&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; is_pod&lt;Type&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; is_pod&lt;Category&gt;::value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码清单5-5中，我们定义了两个强类型枚举<code>Type</code>和<code>Category</code>，它们都包含一个称为<code>General</code>的成员。由于强类型枚举成员的名字不会输出到父作用域，因此不会有编译问题。也由于不输出成员名字，所以我们在使用该类型成员的时候必须加上其所属的枚举类型的名字。此外，可以看到，枚举成员间仍然可以进行数值式的比较，但不能够隐式地转为int型。事实上，如果要将强类型枚举转化为其他类型，必须进行显式转换。事实上，强类型制止enum成员和int之间的转换，使得枚举更加符合“枚举”的本来意义，即对同类进行列举的一个集合，而定义其与数值间的关联则使之能够默认拥有种对成员排列的机制。而制止成员名字输出则进一步避免了名字空间冲突的问题。我们可以看到，<code>Type</code>和<code>Category</code>都是POD类型，不会像 class 封装版本一样被编译器视为结构体。</p>
<h2 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h2><h3 id="显式内存管理"><a href="#显式内存管理" class="headerlink" title="显式内存管理"></a>显式内存管理</h3><p>从语言层面来讲，我们可以将不正确处理堆内存的分配与释放归纳为以下一些问题。</p>
<ul>
<li>野指针：一些内存单元已被释放，之前指向它的指针却还在被使用。这些内存有可能被运行时系统重新分配给程序使用，从而导致了无法预测的错误</li>
<li>重复释放：程序试图去释放已经被释放过的内存单元，或者释放已经被重新分配过的内存单元，就会导致重复释放错误。通常重复释放内存会导致C++运行时系统打印出大量错误及诊断信息。</li>
<li>内存泄漏：不再需要使用的内存单元如果没有被释放就会导致内存泄漏。如果程序不断地重复进行这类操作，将会导致内存占用剧增。</li>
</ul>
<h3 id="C-11的智能指针"><a href="#C-11的智能指针" class="headerlink" title="C++11的智能指针"></a>C++11的智能指针</h3><p>在C++98中，智能指针通过一个模板类型<code>auto_ptr</code>来实现。<code>auto_ptr</code>以对象的方式管理堆分配的内存，并在适当的时间(比如析构)，释放所获得的堆内存。这种堆内存管理的方式只需要程序员将new操作返回的指针作为<code>auto_ptr</code>的初始值即可，程序员不用再显式地调用delete。不过<code>auto_ptr</code>有一些缺点(拷贝时返回一个左值，不能调用delete等)，所以在C++11标准中被废弃了。C++11标准中改用<code>unique_ptr</code>、<code>shared_ptr</code>及<code>weak_ptr</code>等智能指针来自动回收堆分配的对象。</p>
<p>这里我们可以看一个C++11中使用新的智能指针的简单例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">11</span>))</span></span>; <span class="comment">// 无法复制的 unique_ptr</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; up2 = up1;        <span class="comment">// 不能通过编译</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; up3 = <span class="built_in">move</span>(up1);  <span class="comment">// 现在p3是数据唯一的 unique_ptr智能指针</span></span><br><span class="line">    cout &lt;&lt; *up3 &lt;&lt; endl;             <span class="comment">// 11</span></span><br><span class="line">    cout &lt;&lt; *up1 &lt;&lt; endl;             <span class="comment">// 运行时错误</span></span><br><span class="line">    up<span class="number">3.</span><span class="built_in">reset</span>();                      <span class="comment">// 显式释放内存</span></span><br><span class="line">    up<span class="number">1.</span><span class="built_in">reset</span>();                      <span class="comment">// 不会导致运行时错误</span></span><br><span class="line">    cout &lt;&lt; *up3 &lt;&lt; endl;             <span class="comment">// 运行时错误</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">22</span>))</span></span>;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1;</span><br><span class="line">    cout &lt;&lt; *sp1 &lt;&lt; endl;             <span class="comment">// 22</span></span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; endl;             <span class="comment">// 22</span></span><br><span class="line"></span><br><span class="line">    sp<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; endl;             <span class="comment">// 22</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>在代码中使用了两种不同的智能指针<code>unique_ptr</code>及<code>shared_ptr</code>来自动地释放堆对象的内存。由于每个智能指针都重载了<code>*</code>运算符，用户可以使用<code>up1</code>这样的方式来访问所分配的雄内存。而在该指针析构或者调用<code>reset</code>成员的时候，智能指针都可能释放其拥有的堆内存。从作用上来讲，<code>unique_ptr</code>和<code>shared_ptr</code>还是和以前的<code>auto_ptr</code>保持了一致。</p>
<p>不过从代码中还是可以看到，<code>unique_ptr</code>和<code>shared_ptr</code>在对所占内存的共享上还是有一定区别的。直观地看来，<code>unique_ptr</code>与所指对象的内存绑定紧密，不能与其他<code>unique_ptr</code>类型的指针对象共享所指对象的内存。比如，本例中的<code>unique_ptr&lt;int&gt; up2 = up1</code>不能通过编译，是因为每个<code>unique_ptr</code>都是唯一地“拥有”所指向的对象内存，由于<code>up1</code>唯一地占有了new分配的堆内存，所以<code>up2</code>无法共享其“所有权”。事实上，这种“所有权”仅能够通过标准库的<code>move</code>函数来转移。</p>
<p>我们可以看到代码中<code>up3</code>的定义，<code>unique_ptr&lt;int&gt; up3 = move(up1)</code>，一旦“所有权”转移成功了，原来的<code>unique_ptr</code>指针就失去了对象内存的所有权。此时再使用已经“失势”的<code>unique_ptr</code>，就会导致运行时的错误。</p>
<p>从实现上讲，<code>unique_ptr</code>则是一个删除了拷贝构造函数、保留了移动构造函数的指针封装类型。程序员仅可以使用右值对<code>unique_ptr</code>对象进行构造，而且一旦构造成功，右值对象中的指针即被“窃取”，因此该右值对象即刻失去了对指针的“所有权”。而<code>shared_ptr</code>同样形如其名，允许多个该智能指针共享地“拥有”同一堆分能对象的内存。与<code>unique_ptr</code>不同的是，由手在实现上采用了引用计数，所以一旦一个<code>shared_ptr</code>指针放弃了“所有权”(失效)，其他的<code>shared_ptr</code>对象内存的引用并不会受到影响。虽然<code>sp1</code>调用了<code>reset</code>成员函数，但由于<code>sp1</code>和<code>sp2</code>共享了new分配的堆内存，所以<code>sp1</code>调用<code>reset</code>成员函数只会导致引用计数的降低，而不会导致堆内存的释放。只有在引用计数归零的时候，<code>shared_ptr</code>才会真正释放所占有的堆内存的空间。</p>
<p>在C++11标准中，除了<code>unique_ptr</code>和<code>shared_ptr</code>，智能指针还包括了<code>weak_ptr</code>这个类模板。<code>weak_ptr</code>的使用更为复杂一点，它可以指向<code>shared_ptr</code>指针指向的对象内存，却并不拥有该内存。而使用<code>weak_ptr</code>成员<code>lock</code>，则可返回其指向内存的一个<code>shared_ptr</code>对象，且在所指对象内存已经无效时，返回指针空值(<code>nullptr</code>)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Check</span><span class="params">(weak_ptr&lt;<span class="type">int</span>&gt;&amp; wp)</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ap = wp.<span class="built_in">lock</span>();   <span class="comment">//转换为shared_ptr&lt;int&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (sp != <span class="literal">nullptr</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;still &quot;</span> &lt;&lt; *sp &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pointer is invalid&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span> <span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">22</span>))</span></span>;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp = sp1;    <span class="comment">//指向shared_ptr&lt;int&gt;所指对象</span></span><br><span class="line">    </span><br><span class="line">    cout &gt;&gt; *sp1 &lt;&lt; endl;             <span class="comment">// 22 </span></span><br><span class="line">    cout &gt;&gt; *sp2 &lt;&lt; endl;             <span class="comment">// 22 </span></span><br><span class="line">    <span class="built_in">Check</span>(wp)                         <span class="comment">// still 22</span></span><br><span class="line">    </span><br><span class="line">    sp<span class="number">1.</span><span class="built_in">reset</span>()</span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; endl;             <span class="comment">// 22</span></span><br><span class="line">    <span class="built_in">Check</span>(wp);                        <span class="comment">// still 22</span></span><br><span class="line">    sp<span class="number">2.</span><span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">Check</span>(wp)                         <span class="comment">// pointer is invalid</span></span><br></pre></td></tr></table></figure>
<p>在<code>sp1</code>和<code>sp2</code>都有效的时候，调用<code>wp</code>的<code>lock</code>函数，将返回一个有效的<code>shared_ptr</code>对象供使用，此后我们分别调用了<code>sp1</code>及<code>sp2</code>的<code>reset</code>函数，这会导致对唯一的堆内存对象的引用计数降至0。而一旦引用计数归0，<code>shared_ptr&lt;int&gt;</code>就会释放堆内存空间，使之失效。此时我们再调用<code>weak_ptr</code>的<code>lock</code>函数时，则返回一个指针空值<code>nullptr</code>。</p>
<h3 id="垃圾回收的分类"><a href="#垃圾回收的分类" class="headerlink" title="垃圾回收的分类"></a>垃圾回收的分类</h3><p>垃圾回收的方式虽然很多，但主要可以分为两大类</p>
<ul>
<li>基于引用计数的垃圾回收器<ul>
<li>引用计数主要是使用系统记录对象被引用(引用、指针)的次数。当对象被引用的次数变为0时，该对象即可被视作“垃圾”而回收。</li>
<li>使用引用计数做垃圾回收的算法的一个优点是实现很简单，与其他垃圾回收算法相比，该方法不会造成程序暂停，因为计数的增减与对象的使用是紧密结合的。</li>
<li>此外，引用计数也不会对系统的缓存或者交换空间造成冲击，因此被认为“副作用”较小。</li>
<li>但是这种方法比较难处理“环形引用”问题，此外由于计数带来的额外开销也并不小，所以在实用上也有一定的限制。</li>
</ul>
</li>
<li>基于跟踪处理的垃圾回收器<ul>
<li>跟踪处理的垃圾回收机制基本方法是产生跟踪对象的关系图，然后进行垃圾回收。</li>
<li>使用跟踪方式的垃圾回收算法主要有以下几种：<ul>
<li>标记-清除(Mark-Swep)<ul>
<li>首先该算法将程序中正在使用的对象视为“根对象”，从根对象开始查找它们所引用的堆空间，并在这些堆空间上做标记。当标记结束后所有被标记的对象就是可达对象( Reachable Object)或活对象( Live Object)，而没有被标记的对象就被认为是垃圾</li>
<li>在第二步的清扫(Swep)阶段会被回收掉。</li>
<li>这种方法的特点是活的对象不会被移动，但是其存在会出现大量的内存碎片的问题。</li>
</ul>
</li>
<li>标记-整理(Mark-Compact)<ul>
<li>标记完之后，不再遍历所有对象清扫垃圾，而是将活的对象向“左”靠齐，这就解决了内存碎片的问题。</li>
<li>标记-整理的方法有个特点就是移动活的对象，因此相应的，程序中所有对堆内存的引用都必须更新</li>
</ul>
</li>
<li>标记-拷贝(Mark-Copy)<ul>
<li>这种算法将堆空间分为两个部分：From和To。</li>
<li>刚开始系统只从From的堆空间里面分配内存，当From分配满的时候系统就开始垃圾回收：从From堆空间找出所有活的对象，拷贝到To的堆空间里。这样一来，From的堆空间里面就全剩下垃圾了。而对象被拷贝到T0里之后，在To里是紧湊排列的。</li>
<li>接下来是需要将From和To交换一下角色，接着从新的From里面开始分配。</li>
<li>标记-拷贝算法的一个问题是堆的利用率只有一半，而且也需要移动活的对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="提高性能及操作硬件的能力"><a href="#提高性能及操作硬件的能力" class="headerlink" title="提高性能及操作硬件的能力"></a>提高性能及操作硬件的能力</h1><h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><h3 id="运行时常量性与编译时常量性"><a href="#运行时常量性与编译时常量性" class="headerlink" title="运行时常量性与编译时常量性"></a>运行时常量性与编译时常量性</h3><p>常量通常是通过 const关键字来修饰的。比如<code>const int i = 3</code>。</p>
<p>上述代码就声明了一个名字为i的常量。const还可以修饰函数参数、函数返回值、函数本身、类等。在不同的使用条件下， const有不同的意义，不过大多数情况下， const描述的都是一些“运行时常量性”的概念，即具有运行时数据的不可更改性。不过有的时候，我们需要的却是编译时期的常量性，这是 const关键字无法保证的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">Getconst</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Constless</span><span class="params">(<span class="type">int</span> cond)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="built_in">Getconst</span>()] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//无法通过编译</span></span><br><span class="line">    <span class="keyword">enum</span>&#123; e1 = <span class="built_in">Getconst</span>(), e2 &#125;; <span class="comment">//无法通过编译</span></span><br><span class="line">    <span class="keyword">switch</span> (cond) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">Getconst</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">            break;</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个返回常数1的函数<code>Getconst()</code>。我们使用了const关键字修饰了返回类型。不过编译后我们发现，无论将<code>Getconst</code>的结果用于需要初始化数组<code>arr</code>的声明中，还是用于匿名枚举中，或用于switch-case的case表达式中，编译器都会报告错误。这些语句都需要的是编译时期的常量值。而<code>const</code>修饰的函数返回值，只保证了在运行时期内其值是不可以被更改的。这是两个完全不同的概念。</p>
<p>C++11中对象时期常量的回答是<code>constexpr</code>，即常量表达式(constant expression)。可以用下面的声明方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">Getconst</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>即在函数表达式前加上<code>constexpr</code>关键字即可。有了常量表达式这样的声明，编译器就可以在编译时期对<code>Getconst</code>表达式进行值计算(evaluation)，从而将其视为一个绵译时期的常量。常量表达式实际上可以作用的实体不仅限于函数，还可以作用于数据声明，以及类的构造函数等。</p>
<h3 id="常量表达式函数"><a href="#常量表达式函数" class="headerlink" title="常量表达式函数"></a>常量表达式函数</h3><p>通常我们可以在函数返回类型前加入关键字<code>constexpr</code>来使其成为常量表达式函数。不过并非所有的函数都有资格成为常量表达式函数。事实上，常量表达式函数的要求非常严格。总结起来，大概有以下几点：</p>
<ul>
<li>函数体只有单一的return返回语句。<ul>
<li>函数体中只有一条语句，且该条语句必须是 return语句。</li>
<li>这就意味着形如<code>int i = 1; return i;</code>这样的多条语句的写法是无法通过编译的。</li>
<li>不过一些不会产生实际代码的语句不会导致编译器的“抱怨”。</li>
</ul>
</li>
<li>函数必须返回值(不能是void函数)。<ul>
<li>形如<code>constexpr void f() &#123;&#125;</code>这样的不返回值的函数就不能是常量表达式。</li>
<li>因为无法获得常量的常量表达式是不被认可的。</li>
</ul>
</li>
<li>在使用前必须已有定义。<br>  - </li>
<li>return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式。<ul>
<li>形如<code>constexpr int g() &#123; return e();&#125;</code>或者形如<code>constexpr int h() &#123; return g;&#125;</code>的常量表达式定义是不能通过编译的。</li>
<li>如果我们要使得<code>g()</code>是个编译时的常量，那么其return表达式语句就不能包含运行时才能确定返回值的函数。</li>
</ul>
</li>
</ul>
<h3 id="常量表达式值"><a href="#常量表达式值" class="headerlink" title="常量表达式值"></a>常量表达式值</h3><p>通常情况下，常量表达式值必须被常量表达式赋值，而跟常量表达式函数一样，常量表达式值在使用前必须被初始化。而使用<code>constexpr</code>声明的数据最常被问起的问题是，下列两条语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> j = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>在大多数情况下是没有区别的。如果<code>i</code>在全局名字空间中，编译器一定会为<code>i</code>产生数据。而对于<code>j</code>，如果不是有代码显式地使用了它的地址，编译器可以选择不为它生成数据，而仅将其当做编译时期的值。</p>
<p>有的时候，我们在常量表达式中会看到浮点数。通常情况下，编译器对浮点数做编译时期常量这件事情很敏感。因为编译时环境和运行时环境可能有所不同，那么编译时的浮点常量和实际运行时的浮点数常量可能在精度上存在差别。而对于自定义类型的数据，要使其成为常量表达式值的话，则不像内置类型这么简单。C++标准中，<code>constexpr</code>关键字是不能用于修饰自定义类型的定义的。比如下面这样的类型定义和使用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Mytype</span> &#123; <span class="type">int</span> i; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> Mytype mt = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在C++11中，就是无法通过编译的。正确地做法是，定义自定义常量构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Mytype</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Mytype</span><span class="params">(<span class="type">int</span> x)</span>: i(x) &#123;</span>&#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> Mytype mt = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们对<code>Mytype</code>的构造函数进行了定义。不过在定义前，我们加上了<code>constexpr</code>关键字。通过这样的定义，<code>Mytype</code>类型的<code>constexpr</code>的变量<code>mt</code>的定义就可以通过编译了。</p>
<p>常量表达式的构造函数也有使用上的约束，主要的有以下两点</p>
<ul>
<li>函数体必须为空。</li>
<li>初始化列表只能由常量表达式来赋值。</li>
</ul>
<p>形如下面的常量表达式构造函数都是无法通过编译的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mytype</span> &#123; <span class="type">int</span> i; <span class="function"><span class="keyword">constexpr</span> <span class="title">Mytype</span><span class="params">()</span>: i(f()) &#123;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="常量表达式的其他应用"><a href="#常量表达式的其他应用" class="headerlink" title="常量表达式的其他应用"></a>常量表达式的其他应用</h3><p>常量表达式是可以用于模板函数的。不过由于模板中类型的不确定性，所以模板函数是否会被实例化为一个能够满足编译时常量性的版本通常也是未知的。针对这种情况，C++11标准规定，当声明为常量表达式的模板函数后，而某个该模板函数的实例化结果不满足常量表达式的需求的话，<code>constexpr</code>会被自动忽略。该实例化后的函数将成为一个普通函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Notliteral</span> &#123;</span><br><span class="line">    <span class="built_in">Notliteral</span>() &#123; i = <span class="number">5</span>; &#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line">Notliteral nl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">contexpr T <span class="title">Constexp</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Nothiteral nl;</span><br><span class="line">    Notliteral nl1 = <span class="built_in">Constexp</span>(nl);</span><br><span class="line">    <span class="keyword">constexpr</span> Notliteral nl2 = <span class="built_in">Constexp</span>(nl); <span class="comment">//无法通过编译</span></span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">Constexp</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>结构体<code>Notliteral</code>不是一个定义了常量表达式构造函数的类型，因此是不能够声明为常量表达式值的。而模板函数<code>Constexp</code>一旦以<code>Notliteral</code>为参数的话，那么其<code>constexpr</code>关键字将被忽略，如<code>nl1</code>变量所示。实例化为<code>Constexp&lt;Notliteral&gt;</code>的函数将不是一个常量表达式函数，因此，我们也看到<code>nl2</code>是无法通过编译的。而在可以实例化为常量表达式函数的时候，<code>Constexp</code>则可以用于常量表达式值的初始化。比如本例中的<code>a</code>，就是由实例化为<code>Constexp&lt;int&gt;</code>的常量表达式函数所初始化的。</p>
<p>对于常量表达式的应用，还有一个有趣的问题就是函数递归问题。在标准中说明，符合C++11标准的编译器对常量表达式函数应该至少支持512层的递归。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n == <span class="number">1</span>) ? <span class="number">1</span> : ((n == <span class="number">2</span>) ? <span class="number">1</span> : <span class="built_in">Fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">Fibonacci</span>(n<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fib[] = &#123;</span><br><span class="line">        <span class="built_in">Fibonacci</span>(<span class="number">11</span>), <span class="built_in">Fibonacci</span>(<span class="number">12</span>),</span><br><span class="line">        <span class="built_in">Fibonacci</span>(<span class="number">13</span>), <span class="built_in">Fibonacci</span>(<span class="number">14</span>),</span><br><span class="line">        <span class="built_in">Fibonacci</span>(<span class="number">15</span>),<span class="built_in">Fibonacci</span> (<span class="number">16</span>)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p>
<p>早在C++模板刚出现的时候，就出现了基于模板的编译时期运算的编程方式，这种编程通常被称为模板元编程(template meta-programming)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">long</span> num&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> val = Fibonacci&lt;num<span class="number">-1</span>&gt;::val + Fibonacci&lt;num<span class="number">-2</span>&gt;::val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">2</span>&gt;&#123; <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> val = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt;&#123; <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> val = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt;&#123; <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> val = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fib[] = &#123;</span><br><span class="line">        Fibonacci&lt;<span class="number">11</span>&gt;::val, Fibonacci&lt;<span class="number">12</span>&gt;::val,</span><br><span class="line">        Fibonacci&lt;<span class="number">13</span>&gt;::val, Fibonacci&lt;<span class="number">14</span>&gt;::val,</span><br><span class="line">        Fibonacci&lt;<span class="number">15</span>&gt;::val, Fibonacci&lt;<span class="number">16</span>&gt;::val</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义了一个非类型参数的模板<code>Fibonacci</code>。该模板类定义了一个静态变量<code>val</code>，而<code>val</code>的定义方式是递归的。因此模板将会递归地进行推导。此外，我们还通过偏特化定义了模板推导的边界条件，即斐波那契的初始值。那么模板在推导到边界条件的时候就会终止推导。通过这样的方法，我们同样可以在编译时进行值计算，从而生成数组的值。通过<code>constexpr</code>进行的运行时值计算，跟模板元编程非常类似。因此有的程序员自然地称利用constexpr进行编译时期运算的编程方式为constexpr元编程。</p>
<h2 id="变长模板"><a href="#变长模板" class="headerlink" title="变长模板"></a>变长模板</h2><h3 id="变长函数和变长的模板参数"><a href="#变长函数和变长的模板参数" class="headerlink" title="变长函数和变长的模板参数"></a>变长函数和变长的模板参数</h3><p>通过使用变长函数(variadic funciton)，<code>printf</code>的实现能够接受任何长度的参数列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarh.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sumoffloat</span><span class="params">(<span class="type">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">va_start</span>(ap, count);     <span class="comment">//获得变长列表的句柄ap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i ++)</span><br><span class="line">        sum += <span class="built_in">va_arg</span>(ap, <span class="type">double</span>);    <span class="comment">//每次获得一个参数</span></span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在被调用者中，需要通过一个类型为<code>va_list</code>的数据结构<code>ap</code>来辅助地获得参数。可以看到，这里代码首先使用<code>va_start</code>函数对<code>ap</code>进行初始化，使得<code>ap</code>成为被传递的变长参数的一个句柄。而后代码再使用<code>va_arg</code>函数从<code>ap</code>中将参数一一取出用于运算。由于这里是计算浮点数的和，所以每次总是给<code>va_arg</code>传递一个<code>double</code>类型作为参数。图显示了一种变长函数的可能的实现方式，即以句柄<code>ap</code>为指向各个变长参数的指针，而<code>va_arg</code>则通过改变指针的方式来返回下一个指针所指向的对象。<br><img src="/img/1628912842.jpg" alt=""></p>
<h3 id="変长模板：模板参数包和函数参数包"><a href="#変长模板：模板参数包和函数参数包" class="headerlink" title="変长模板：模板参数包和函数参数包"></a>変长模板：模板参数包和函数参数包</h3><p>以<code>tuple</code>为例，我们需要以下代码来声明<code>tuple</code>是一个变长类模板<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Elements&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们在标示符<code>Elements</code>之前的使用了省略号来表示该参数是变长的。在C++11中，<code>Elements</code>被称作是一个“模板参数包”。这是一种新的模板参数类型。有了这样的参数包，类模板<code>tuple</code>就可以接受任意多个参数作为模板参数。对于以下实例化的<code>tuple</code>模板类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">char</span>, <span class="type">double</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>编译器则可以将多个模板参数打包成为“单个的”模板参数包<code>Elements</code>，即<code>Element</code>在进行模板推导的时候，就是一个包含int、char和 double三种类型类型集合。</p>
<p>与普通的模板参数类似，模板参数包也可以是非类型的，比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span>... A&gt; <span class="keyword">class</span> <span class="title class_">Nontypevariadictemplate</span>&#123;&#125;;</span><br><span class="line">Nontypevariadictemplate&lt;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&gt; ntvt;</span><br></pre></td></tr></table></figure></p>
<p>就定义了接受非类型参数的变长模板<code>Nontypevariadictemplate</code>。这里，我们实例化参数<code>(1,0,2)</code>的模板实例该声明方式相当于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="keyword">class</span> <span class="title class_">Nontypevariadictemplate</span>&#123;&#125;;</span><br><span class="line">Nontypevariadictemplate&lt;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&gt; ntvt;</span><br></pre></td></tr></table></figure></p>
<p>这样的类模板定义和实例化。除了类型的模板参数包和非类型的模板参数包，模板参数包实际上还是模板类型的。</p>
<p>一个模板参数包在模板推导时会被认为是模板的单个参数(虽然实际上它将会打包任意数量的实参)。为了使用模板参数包，我们总是需要将其解包(unpack)。在C++11中，这通常是通过一个名为包扩展(pack expansion)的表达式来完成。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... A&gt; <span class="keyword">class</span> <span class="title class_">Template</span>: <span class="keyword">private</span> B&lt;A...&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里的表达式<code>A...</code>就是一个包扩展。直观地看，参数包会在包扩展的位置展开为多个参数。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">class</span> <span class="title class_">B</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...A&gt; <span class="keyword">class</span> <span class="title class_">Template</span>: <span class="keyword">private</span> B&lt;A...&gt;&#123;&#125;;</span><br><span class="line">Template&lt;X, Y&gt; xy;</span><br></pre></td></tr></table></figure></p>
<p>这里我们为类模板声明了一个参数包<code>A</code>，而使用参数包<code>A</code>则是在<code>Template</code>的私有基类<code>B&lt;A...&gt;</code>中，那么最后一个表达式就声明了一个基类为<code>B&lt;X,Y&gt;</code>的模板类<code>Template&lt;X,Y&gt;</code>的对象<code>xy</code>。其中<code>X</code>、<code>Y</code>两个模板参数先是被打包为参数包<code>A</code>，而后又在包扩展表达式<code>A...</code>中被还原。</p>
<p>通过定义递归的模板偏特化定义，我们可以使得模板参数包在实例化时能够层层展开，直到参数包中的参数逐渐耗尽或到达某个数量的边界为止。下面的例子是一个用变长模板实现<code>tuple</code>的代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Elements&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>; <span class="comment">//变长模板的声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;   <span class="comment">//递归的偏特化定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head, Tail...&gt; : <span class="keyword">private</span> tuple&lt;Tail...&gt; &#123;</span><br><span class="line">    Head head;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt; &#123;&#125;;                <span class="comment">//边界条件</span></span><br></pre></td></tr></table></figure></p>
<p>我们声明了变长模板类<code>tuple</code>，其只包含一个模板参数，即<code>Elements</code>模板参数包。此外，我们又偏特化地定义了一个双参数的<code>tuple</code>的版本。该偏特化版本的<code>tuple</code>包含了两个参数，一个是类型模板参数<code>Head</code>，另一个则是模板参数包<code>Tail</code>。<code>Head</code>型的数据作为<code>tuple&lt;Head,Tail...&gt;</code>的第一个成员，而将使用了包扩展表达式的模板类<code>tuple&lt;Tail...&gt;</code>作为<code>tuple&lt;Head,Tail...&gt;</code>的私有基类。这样来，当程序员实例化一个形如<code>tuple &lt;double, int, char, float&gt;</code>的类型时，则会引起基类的递归构造，这样的递归在<code>tuple</code>的参数包为0个的时候会结束。</p>
<p>我们再来看一个使用非类型模板的一个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">long</span>... nums&gt; <span class="keyword">struct</span> <span class="title class_">Multiply</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">long</span> first, <span class="type">long</span>... last&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span>&lt;first, last...&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> val = first * Multiply&lt;last...&gt;::val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span>&lt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> val = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Multiply&lt;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;::val &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; Multip1y&lt;<span class="number">22</span>,<span class="number">44</span>,<span class="number">66</span>,<span class="number">88</span>,<span class="number">9</span>&gt;::val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="变长模板：进阶"><a href="#变长模板：进阶" class="headerlink" title="变长模板：进阶"></a>变长模板：进阶</h3><p>标准定义了以下7种参数包可以展开的位置</p>
<ul>
<li>表达式</li>
<li>初始化列表</li>
<li>基类描述列表</li>
<li>类成员初始化列表</li>
<li>模板参数列表</li>
<li>通用属性列表</li>
<li>lambda函数的捕捉列表</li>
</ul>
<p>语言的其他“地方”则无法展开参数包。而对于包扩展而言，其解包也与其声明的形式息息相关。事实上，我们还可以声明一些有趣的包扩展表达式。比如声明了<code>Arg</code>为参数包，那么我们可以使用<code>Arg&amp;&amp;...</code>这样的包扩展表达式，其解包后等价于<code>Arg1&amp;&amp;, ..., Argn&amp;&amp;</code>。</p>
<p>一个更为有趣的包扩展表达式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...A&gt; <span class="keyword">class</span> <span class="title class_">T</span>: <span class="keyword">private</span> B&lt;A&gt;...&#123;&#125;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>注意这个包扩展跟下面的类模板声明<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...A&gt; <span class="keyword">class</span> <span class="title class_">T</span>: <span class="keyword">private</span> B&lt;A...&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在解包后是不同的，对于同样的实例化<code>T&lt;X,Y&gt;</code>，前者会解包为：<code>class T&lt;X, Y&gt;: private B&lt;X&gt;, private B&lt;Y&gt;&#123;&#125;;</code>即多重继承的派生类，而后者则会解包为<code>class T&lt;X, Y&gt;: private B&lt;X, Y&gt;&#123;&#125;;</code>即派生于多参数的模板类的派生类，这点存在着本质的不同。</p>
<p>在C++11中，标准还引入了新操作符<code>sizeof...</code>，其作用是计算参数包中的参数个数。通过这个操作符，我们能够实现参数包更多的用法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>...A&gt; <span class="type">void</span> <span class="title">Print</span><span class="params">(A...arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化6参数的版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, <span class="type">int</span> a6)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; a1 &lt;&lt; a2 &lt;&lt; a3 &lt;&lt; a4 &lt;&lt; a5 &lt;&lt; a6 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>...A&gt; <span class="type">int</span> <span class="title">Vaargs</span><span class="params">(A ...args)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>...(A);      <span class="comment">//计算变长包的长度</span></span><br><span class="line">    <span class="keyword">switch</span>(size) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">Print</span>(<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">Print</span>(<span class="number">99</span>, <span class="number">99</span>, args..., <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">Print</span>(<span class="number">99</span>, <span class="number">99</span>, args..., <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">Print</span>(args..., <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">Print</span>(<span class="number">99</span>, args..., <span class="number">99</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">Print</span>(<span class="number">99</span>, args...);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">Print</span>(args...);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">Print</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="原子类型与原子操作"><a href="#原子类型与原子操作" class="headerlink" title="原子类型与原子操作"></a>原子类型与原子操作</h2><h3 id="原子操作与C-11原子类型"><a href="#原子操作与C-11原子类型" class="headerlink" title="原子操作与C++11原子类型"></a>原子操作与C++11原子类型</h3><p>所谓原子操作，就是多线程程序中“最小的且不可并行化的”的操作。通常对一个共享资源的操作是原子操作的话，意味着多个线程访问该资源时，有且仅有唯一一个线程在对这个资源进行操作。那么从线程(处理器)的角度看来，其他线程就不能够在本线程对资源访问期间对该资源进行操作，因此原子操作对于多个线程而言，就不会发生有别于单线程程序的意外状况。通常情况下，原子操作都是通过“互斥”( mutual exclusive)的访问来保证的。实现互斥通常需要平台相关的特殊指令，这在C++11标准之前，这常常意味着需要在C/C++代码中嵌入内联汇编代码。</p>
<p>在C++11的并行程序中，使用原子类型是非常容易的。事实上，由于C++11与C11标准都支持原子类型，因此我们可以简单地通过<code>#include&lt;cstdatomic&gt;</code>头文件中来使用对应于内置类型的原子类型定义。<code>&lt;cstdatomic&gt;</code>中包含的原子类型定义如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原子类型名称</th>
<th>对应的内置类型名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>atomic_bool</td>
<td>bool</td>
</tr>
<tr>
<td>atomic_char</td>
<td>char</td>
</tr>
<tr>
<td>atomic_schar</td>
<td>signed char</td>
</tr>
<tr>
<td>atomic_uchar</td>
<td>unsigned char</td>
</tr>
<tr>
<td>atomic_int</td>
<td>int</td>
</tr>
<tr>
<td>atomic_uint</td>
<td>unsigned int</td>
</tr>
<tr>
<td>atomic_short</td>
<td>short</td>
</tr>
<tr>
<td>atomic_ushort</td>
<td>unsigned short</td>
</tr>
<tr>
<td>atomic_long</td>
<td>long</td>
</tr>
<tr>
<td>atomic_ulong</td>
<td>unsigned long</td>
</tr>
<tr>
<td>atomic_llong</td>
<td>long long</td>
</tr>
<tr>
<td>atomic_ullong</td>
<td>unsigned long long</td>
</tr>
<tr>
<td>atomic_char16_t</td>
<td>char16_t</td>
</tr>
<tr>
<td>atomic_char32_t</td>
<td>char32_t</td>
</tr>
<tr>
<td>atomic_wchar_t</td>
<td>wchar_t</td>
</tr>
</tbody>
</table>
</div>
<p>程序员可以使用<code>atomic</code>类模板任意定义出需要的原子类型。比如下列语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;T&gt; t;</span><br></pre></td></tr></table></figure></p>
<p>就声明了一个类型为<code>T</code>的原子类型変量<code>t</code>。编译器会保证产生并行情况下行为良好的代码，以避免线程间对数据<code>t</code>的竞争。</p>
<p>对于线程而言，原子类型通常属于“资源型”的数据，这意味着多个线程通常只能访问单个原子类型的拷贝。因此在C++11中，原子类型只能从其模板参数类型中进行构造，标准不允许原子类型进行拷贝构造、移动构造，以及使用<code>operator=</code>等，以防止发生意外。比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">float</span>&gt; af &#123;<span class="number">1.2f</span>&#125;; </span><br><span class="line">atomic&lt;<span class="type">float</span>&gt; af1 &#123;af&#125;;<span class="comment">//无法通过编译</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>af1&#123;af&#125;</code>的构造方式在C++11中是不允许的。不过从<code>atomic&lt;T&gt;</code>类型的变量来构造其模板参数类型T的变量则是可以的。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">float</span>&gt; af &#123;<span class="number">1.2f</span>&#125;;</span><br><span class="line"><span class="type">float</span> f = af;</span><br><span class="line"><span class="type">float</span> f1 &#123;af&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是由于<code>atomic</code>类模板总是定义了从<code>atomic&lt;T&gt;</code>到<code>T</code>的类型转换函数的缘故。在需要时，编译器会隐式地完成原子类型到其对应的类型的转换。</p>
<h3 id="内存模型，顺序一致性与memory-order"><a href="#内存模型，顺序一致性与memory-order" class="headerlink" title="内存模型，顺序一致性与memory order"></a>内存模型，顺序一致性与memory order</h3><p>要了解顺序一致性以及内存模型，我们不妨看看代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; a &#123;<span class="number">0</span>&#125;;</span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; b &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">valueset</span> <span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    a = t;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Observer</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125; <span class="comment">//可能有多种输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(valueset, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(observer, <span class="number">0</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们创建了两个线程1和2，分别执行<code>valueset</code>和<code>observer</code>。在<code>valueset</code>中，为<code>a</code>和<code>b</code>分别赋值1和2。而在<code>observer</code>中，只是打印出<code>a</code>和<code>b</code>的值。可以想象，由于<code>observer</code>打印<code>a</code>和<code>b</code>的时间与<code>valueset</code>设置<code>a</code>和<code>b</code>的时间可能有多种组合方式。</p>
<p>默认情况下，在C++11中的原子类型的变量在线程中总是保持着顺序执行的特性。我们称这样的特性为“顺序一致”的，即代码在线程中运行的顺序与程序员看到的代码顺序一致。</p>
<p>对于C++11中的内存模型而言，要保证代码的顺序一致性，就必须同时做到以下几点</p>
<ul>
<li>编译器保证原子操作的指令间顺序不变，即保证产生的读写原子类型的变量的机器指令与代码编写者看到的是一致的。</li>
<li>处理器对原子操作的汇编指令的执行顺序不变。这对于x86这样的强顺序的体系结构而言，并没有任何的问题。</li>
</ul>
<p>如前文所述，在C++11中，原子类型的成员函数(原子操作)总是保证了顺序一致性。这对于x86这样的平台来说，禁止了编译器对原子类型变量间的重排序优化。在C++11中，设计者给出的解决方式是让程序员为原子操作指定所谓的内存顺序。代码中可以采用一种松散的内存模型来放松对原子操作的执行顺序的要求。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; a &#123;<span class="number">0</span>&#125;;</span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; b &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Valueset</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    a.<span class="built_in">store</span>(t, memory_order_relaxed);</span><br><span class="line">    b.<span class="built_in">store</span>(<span class="number">2</span>, memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Observer</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; <span class="comment">//可能有多种输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(valueset, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(observer, <span class="number">0</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对<code>Valueset</code>函数进行了改造。之前的对<code>a</code>、<code>b</code>进行赋值的语句我们改用了<code>atomic</code>类模板的<code>store</code>成员。<code>store</code>能够接受两个参数，一个是需要写入的值，一个是名为<code>memory_order</code>的枚举值。这里我们使用的值是<code>memory_order_relaxed</code>，表示使用松散的内存模型，该指令可以任由编译器重排序或者由处理器乱序执行。这样一来，<code>a</code>、<code>b</code>赋值语句的“先于发生”顺序得到了解除，我们也就可能得到最佳的运行性能。</p>
<p>大多数<code>atomic</code>原子操作都可以使用<code>memory_order</code>作为一个参数，在C++11中，标准一共定义了7种<code>memory_order</code>的枚举值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>枚举值</th>
<th>定义规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>memory_order_relaxed</td>
<td>不对执行顺序做任何保证</td>
</tr>
<tr>
<td>memory_order_acquire</td>
<td>本线程中，所有后续的读操作必须在本条原子操作完成后执行</td>
</tr>
<tr>
<td>memory_orfer_release</td>
<td>本线程中，所有之前的写操作完成后才能执行本条原子操作</td>
</tr>
<tr>
<td>memory_order_acq_rel</td>
<td>同时包含memory_order_acquire和memory_order_release标记</td>
</tr>
<tr>
<td>memory_order_consume</td>
<td>本线程中，所有后续的有关本原子类型的操作，必须在本条原子操作完成之后执行</td>
</tr>
<tr>
<td>memory_order_seq_cst</td>
<td>全部存取都按顺序执行</td>
</tr>
</tbody>
</table>
</div>
<p><code>memory_order_seq_cst</code>表示该原子操作必须是顺序一致的，这是C++11中所有<code>atomic</code>原子操作的默认值，不带<code>memory_order</code>参数的原子操作就是使用该值。而<code>memory_order_relaxed</code>则表示该原子操作是松散的，可以被任意重排序的。值得注意的是，并非每种<code>memory_order</code>都可以被<code>atomic</code>的成员使用。通常情况下，我们可以把<code>atomic</code>成员函数可使用的<code>memory_order</code>值分为以下3组</p>
<ul>
<li>原子存储操作(store)可以使用<code>memorey_order_relaxed</code>、<code>memory_order_release</code>、<code>memory_order_seq_cst</code></li>
<li>原子读取操作(load)可以使用<code>memorey_order_relaxed</code>、<code>memory_order_consume</code>、<code>memory_order_acquire</code>、<code>memory_order_seq_cst</code></li>
<li>RMW操作，一些需要同时读写的操作，比如之前提过的<code>atomic_flag</code>类型的<code>test_and_set()</code>操作。又比如<code>atomic</code>类模板的<code>atomic_compare_exchange()</code>操作等都是需要同时读写的。RMW操作可以使用<code>memorey_order_relaxed</code>、<code>memory_order_consume</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code>、<code>memory_order_acq_rel</code>、<code>memory_order_seq_cst</code></li>
</ul>
<p>形如<code>operator=</code>、<code>operator+=</code>的函数，事实上都是<code>memory_order_seq_cst</code>作为memory order参数的原子操作的简单封装。也即是说，之前小节中的代码都是采用顺序致性的内存模型。如之前提到的，<code>memory_order_seq_cst</code>这种memory order对于<code>atomic</code>类型数据的内存顺序要求过高，容易阻碍系统发挥线程应有的性能。而<code>memorey_order_relaxed</code>对内存顺序毫无要求。</p>
<p>但在另外一些情况下，则还是可能无法满足真正的需求<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Thread1</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    a.<span class="built_in">store</span>(t, memory_order_relaxed);</span><br><span class="line">    b.<span class="built_in">store</span>(<span class="number">2</span>, memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Thread2</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b.<span class="built_in">load</span>(memory_order_relaxed) != <span class="number">2</span>); <span class="comment">//自旋等待</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">load</span>(memory_order_relaxed) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(Thread1, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(Thread2, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们并不希望完全禁用关于原子类型的优化，而采用了<code>memory_order_relaxed</code>作为memory order参数。在一些弱内存模型的机器上，这两条a、b赋值语句将有可能任意一条被先执行。那么对于<code>Thread2</code>函数而言，它先是自旋等待<code>b</code>的值被赋为2，随后将<code>a</code>的值输出。按照松散的内存顺序，我们输出的<code>a</code>的值则有可能为0，也有可能为1。</p>
<p>如果读者仔细地分析的话，我们所需要的只是<code>a.store</code>先于<code>b.store</code>发生，<code>b.load</code>先于<code>a.load</code>发生的顺序。这要这两个“先于发生”关系得到了遵守，对于整个程序而言来说，就不会发生线程间的错误。建立这种“先于发生”关系，即原子操作间的顺序则需要利用其他的memory order枚举值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Thread1</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    a.<span class="built_in">store</span>(t, memory_order_relaxed);</span><br><span class="line">    b.<span class="built_in">store</span>(<span class="number">2</span>, memory_order_release); <span class="comment">//本原子操作前所有的写原子操作必须完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Thread2</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b.<span class="built_in">load</span>(memory_order_acquire)!=<span class="number">2</span>); <span class="comment">//本原子操作必須完成才能执行之后所有的读原子操作</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">load</span>(memory_order_relaxed) &lt;&lt; endl: <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(Thread1, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(Thread2, <span class="number">0</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一是<code>b.store</code>采用了<code>memory_order_release</code>内存顺序，这保证了本原子操作前所有的写原子操作必完成，也即<code>a.store</code>作必发生于<code>b.store</code>之前。二是<code>b.load</code>采用了<code>memory_order_acquire</code>作为内存顺序，这保证了本原子操作必须完成才能执行之后所有的读原子操作。即<code>b.load</code>必须发生在<code>a.load</code>操作之前。这样一来，通过确立“先于发生”关系的，我们就完全保证了代码运行的正确性，即当<code>b</code>的值为2的时候，<code>a</code>的值也确定地为1。而打印语句也不会在自旋等待之前打印<code>a</code>的值。</p>
<p>通常情况下，“先于发生”关系总是传递的，比如原子操作A发生于原子操作B之前而原子操作B又发生于原子操作C之前的话，则A一定发生于C之前。有了这样的顺序就可以指导编译器在重排序指令的时候在不破坏依赖规则(相当于多给了一些依赖关系)的情况下，仅在适当的位置插入内存栅栏，以保证执行指令时数据执行正确的同时获得最佳的运行性能。</p>
<p>形如其名，<code>memory_order_release</code>和<code>memory_order_consume</code>的配合会建立关于原子类程的“生产者消费者”的同步顺序。同样的，我们可以称之为 release- consume内存顺序。顺序一致、松散、release-acquire和release-consume通常是最为典型的4种内存顺序。其他的如<code>memory_order_acq_rel</code>，则是常用于实现一种叫做CAS( compare and swap)的基本同步元语，对应到<code>atomic</code>的原子操作<code>compare_exchange_strong</code>成员函数上。我们也称之为acquire-release内存顺序。</p>
<h2 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h2><p>线程局部存储(TLS, thread local storage)是一个已有的概念。简单地说，所谓线程局部存储变量，就是拥有线程生命期及线程可见性的变量。</p>
<p>线程局部存储实际上是由单线程程序中的全局/静态变量被应用到多线程程序中被线程共享而来。通常情况下，线程会拥有自己的栈空间，但是堆空间、静态数据区(如果从可执行文件的角度来看，静态数据区对应的是可执行文件的daa、bss段的数据，而从CC++语言层面而言，则对应的是全局/静态量)则是共享的。这样一来，全局、静态变量在这种多线程模型下就总是在线程间共享的。多全局、静态变量的共享虽然会带来一些好处，尤其对一些资源性的变量(比如文件句柄)来说也是应该的，不过并不是所有的全局、静态变量都适合在多线程的情况下共享。</p>
<p>各个编译器公司都有自己的TLS标准。我们在g++/clang++/xlc++中可以看到如下的语法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread <span class="type">int</span> errCode;</span><br></pre></td></tr></table></figure></p>
<p>在全局或者静态变量的声明中加上关键字<code>__thread</code>，即可将变量声明为TLS变量。每个线程将拥有独立的<code>errcode</code>的拷贝，一个线程中对<code>errcode</code>的读写并不会影响另外一个线程中的<code>errcode</code>的数据。C++11对TLS标准做出了一些统一的规定。与<code>__thread</code>修饰符类似，声明一个TLS变量的语法很简单，即通过<code>thread_local</code>修饰符声明变量即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">thread_local</span> errCode;</span><br></pre></td></tr></table></figure></p>
<p>一旦声明一个变量为<code>thread_local</code>，其值将在线程开始时被初始化，而在线程结束时，该值也将不再有效。对于<code>thread_local</code>变量地址取值(&amp;)，也只可以获得当前线程中的TLS变量的地址值。</p>
<h2 id="快速退出：quick-exit与at-quick-exit"><a href="#快速退出：quick-exit与at-quick-exit" class="headerlink" title="快速退出：quick_exit与at_quick_exit"></a>快速退出：quick_exit与at_quick_exit</h2><p>首先我们可以看看<code>terminate</code>函数，没有被捕捉的异常就会导致<code>terminate</code>函数的调用。<code>terminate</code>函数在默认情况下，是去调用<code>abort</code>，不过用户可以通过<code>set_terminate</code>函数来改変要认的行为。</p>
<p>源自于C中的<code>abort</code>则更加低层。<code>abort</code>函数不会调用任何的析构函数，默认情况下，它会向合乎POSIX标准的系统抛出一个信号(signal)：<code>SIGABRT</code>。相比而言，<code>exit</code>这样的属于“正常退出”范畴的程序终止，则不太可能有以上的问题。<code>exit</code>函数会正常调用自动变量的析构函数，并且还会调用<code>atexit</code>注册的函数。</p>
<p>在C++11中，标准引入了<code>quick_exit</code>函数，该函数并不执行析构函数而只是使程序终止。与 abort不同的是，abor的结果通常是异常退出(可能系统还会进行 coredump等以辅助程序员进行问题分析)，而<code>quick_exit</code>与<code>exit</code>同属于正常退出。此外，使用<code>at_quick_exit</code>注册的函数也可以在<code>quick_exit</code>的时候被调用。这样一来，我们同样可以像<code>exit</code>一样做一些清理的工作。在C++11标准中， <code>at_quick_exit</code>和<code>at_exit</code>一样，标准要求编译器至少支持32个注册函数的调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destruct A.&quot;</span> &lt;&lt; endl; &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">closedevice</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;device is closed. &quot;</span>&lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">at_quick_exit</span>(closedevice);</span><br><span class="line">    <span class="built_in">quick_exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="为改变思考方式而改变"><a href="#为改变思考方式而改变" class="headerlink" title="为改变思考方式而改变"></a>为改变思考方式而改变</h1><h2 id="指针空值nullptr"><a href="#指针空值nullptr" class="headerlink" title="指针空值nullptr"></a>指针空值nullptr</h2><h3 id="指针空值：从0到NULL，再到nullptr"><a href="#指针空值：从0到NULL，再到nullptr" class="headerlink" title="指针空值：从0到NULL，再到nullptr"></a>指针空值：从0到NULL，再到nullptr</h3><p>一般情况下，NULL是一个宏定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cpluspuls)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>NULL可能被定义为字面常量0，或者是定义为无类型指针<code>void*</code>常量。编译器总是会优先把NULL看作是一个整型常量，这会引起一些二义性，比如<code>int</code>和<code>char*</code>的重载。在C++11新标准中，为二义性给出了新的答案，就是<code>nullptr</code>，<code>nullptr</code>是一个所谓“指针空值类型”的常量。指针空值类型被命名为<code>nullptr_t</code>，事实上，我们可以在支持<code>nullptr_t</code>的头文件中找出如下定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="type">nullptr_t</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>nullptr_t</code>的定义方式非常有趣，使用<code>nullptr_t</code>的时候必须<code>include&lt;cstddef&gt;</code>，而<code>nullptr</code>则不用。这大概就是由于<code>nullptr</code>是关键字，而<code>nullptr_t</code>是通过推导而来的缘故。</p>
<p>而相比于gcc等编译器将NULL预处理为编译器内部标识<code>nul</code>，<code>nullptr</code>拥有更大的优势。简单而言，由于<code>nullptr</code>是有类型的，且仅可以被隐式转化为指针类型</p>
<h3 id="nullptr和nullptr-t"><a href="#nullptr和nullptr-t" class="headerlink" title="nullptr和nullptr_t"></a>nullptr和nullptr_t</h3><p>C++11标准不仅定义了指针空值常量<code>nullptr</code>，也定义了其指针空值类型<code>nullptr_t</code>，也就表示了指针空值类型并非仅有<code>nullptr</code>一个实例。通常情况下，也可以通过<code>nullptr_t</code>来声明个指针空值类型的变量(即使看起来用途不大)。除去<code>nullptr</code>及<code>nullptr_t</code>以外，C++中还存在各种内置类型。C++11标准严格规定了数据间的关系。大体上常见的规则简单地列在了下面：</p>
<ul>
<li>所有定义为<code>nullptr_t</code>类型的数据都是等价的，行为也是完全一致。</li>
<li><code>nullptr_t</code>类型数据可以隐式转换成任意一个指针类型</li>
<li><code>nullptr_t</code>类型数据不能转换为非指针类型，即使使用<code>reinterpret_cast&lt;nullptr_t&gt;()</code>的方式也是不可以的。</li>
<li><code>nullptr_t</code>类型数据不适用于算术运算表达式。</li>
<li><code>nullptr_t</code>类型数据可以用于关系运算表达式，但仅能与<code>nullptr_t</code>类型数据或者指针类型数据进行比较，当且仅当关系运算符为=、&lt;=、&gt;=等时返回true</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//nullptr可以隐式转换为 char*</span></span><br><span class="line">    <span class="type">char</span> *cp = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不可转换为整型，而任何类型也不能转换为 nullptr_t</span></span><br><span class="line">    <span class="comment">// 以下代码不能通过编译</span></span><br><span class="line">    <span class="comment">// int n1 = nullptr;</span></span><br><span class="line">    <span class="comment">// int n2 = reinterpret_cast&lt;int&gt;(nullptr)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//nul1ptr与nullptr_t类型变量可以作比较</span></span><br><span class="line">    <span class="comment">//当使用=、&lt;=、&gt;=符号比较时返回true</span></span><br><span class="line">    <span class="type">nullptr_t</span> nptr;</span><br><span class="line">    <span class="keyword">if</span> (nptr == <span class="literal">nullptr</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;nullptr_t nptr == nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;nullptr_t nptr != nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (nptr &lt; <span class="literal">nullptr</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;nullptr_t nptr &lt; nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;nullptr_t nptr !&lt; nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能转换为整型或bool类型，以下代码不能通过编译</span></span><br><span class="line">    <span class="comment">// if (0 == nullptr);</span></span><br><span class="line">    <span class="comment">// if (nullptr)</span></span><br><span class="line">    <span class="comment">// 不可以进行算术运算，以下代码不能通过编译</span></span><br><span class="line">    <span class="comment">// nullptr += 1;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下操作均可以正常进行</span></span><br><span class="line">    <span class="built_in">sizeof</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">typeid</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">throw</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一些关于nullptr规则的讨论"><a href="#一些关于nullptr规则的讨论" class="headerlink" title="一些关于nullptr规则的讨论"></a>一些关于nullptr规则的讨论</h3><p>在C++11标准中，<code>nullptr</code>类型数据所占用的内存空间大小跟<code>void*</code>相同的，即<code>sizeof(nullptr_t)==sizeof(void*)</code>。两者在语法层面有着不同的内涵。<code>nullptr</code>是一个编译时期的常量，它的名字是一个编译时期的关键字，能够为编译器所识别。而<code>(void*)0</code>只是一个强制转换表达式，其返回的也是一个<code>void*</code>指针类型。而且最为重要的是，在C++语言中，<code>nullptr</code>到任何指针的转换是隐式的，而<code>(void*)0</code>则必须经过类型转换后才能使用。</p>
<h2 id="默认函数的控制"><a href="#默认函数的控制" class="headerlink" title="默认函数的控制"></a>默认函数的控制</h2><h3 id="类与默认函数"><a href="#类与默认函数" class="headerlink" title="类与默认函数"></a>类与默认函数</h3><p>在C++中声明自定义的类，编译器会默认帮助程序员生成一些他们未自定义的成员函数。这样的函数版本被称为“默认函数”。这包括了以下一些自定义类型的成员函数</p>
<ul>
<li>构造函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值函数</li>
<li>移动构造函数</li>
<li>移动拷贝函数</li>
<li>析构函数</li>
</ul>
<p>此外，C++编译器还会为以下这些自定义类型提供全局默认操作符函数：</p>
<ul>
<li><code>operator&amp;</code></li>
<li><code>operator&amp;&amp;</code></li>
<li><code>operator*</code></li>
<li><code>operator-&gt;</code></li>
<li><code>operator-&gt;*</code></li>
<li><code>operator new</code></li>
<li><code>operator delete</code></li>
</ul>
<p>在C++语言规则中，一旦程序员实现了这些函数的自定义版本，则编译器不会再为该类自动生成默认版本。有时这样的规则会被程序员忘记，最常见的是声明了带参数的构造版本，则必须声明不带参数的版本以完成无参的变量初始化。不过通过编译器的提示，这样的问题通常会得到更正。但更为严重的问题是，一旦声明了自定义版本的构造函数，则有可能导致我们定义的类型不再是POD的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_trait&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Twocstor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供了带参数版本的构造函数，则必须自行提供</span></span><br><span class="line">    <span class="comment">// 不带参数版本，且Twocstor不再是POD类型</span></span><br><span class="line">    <span class="built_in">Twocstor</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Twocstor</span>(<span class="type">int</span> i): <span class="built_in">data</span>(i) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; is_pod&lt;Twocstor&gt;::value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然提供了<code>Twocstor()</code>构造函数，它与默认的构造函数接口和使用方式也完全一致，不过该构造函数却不是平凡的，因此<code>Twocstor</code>也就不再是POD的了。使用<code>is_pod</code>模板类查看<code>Twocstor</code>，也会发现程序输出为0。</p>
<p>在C++11中，标准提供default关键字，程序员可以在默认函数定义或者声明时加上<code>=default</code>，从而显式地指示编译器生成该函数的默认版本。而如果指定产生默认版本后，程序员不再也不应该实现一份同名的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &lt;iostream》</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Twocstor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供了带参数版本的构造函数，再指示编译器</span></span><br><span class="line">    <span class="comment">// 提供默认版本，则本自定义类型依然是POD类型</span></span><br><span class="line">    <span class="built_in">Twocstor</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Twocstor</span>(<span class="type">int</span> i): <span class="built_in">data</span>(i) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一方面，程序员在一些情况下则希望能够限制一些默认函数的生成。最典型地，类的编写者有时需要禁止使用者使用拷贝构造函数，在C++98标准中，我们的做法是将拷贝构造函数声明为<code>private</code>的成员，并且不提供函数实现。这样一来，一且有人试图(或者无意识)使用拷贝构造函数，编译器就会报错。</p>
<p>在C++11中，标准则给出了更为简单的方法，即在函数的定义或者声明加上<code>=delete</code>会指示编译器不生成函数的缺省版本。</p>
<h3 id="“-default”与”-deleted”"><a href="#“-default”与”-deleted”" class="headerlink" title="“= default”与”= deleted”"></a>“= default”与”= deleted”</h3><p>C++11标准称<code>= default</code>修饰的函数为显式缺省(explicit defaulted)函数，而称<code>= delete</code>修饰的函数为删除(deleted)函数。C++11引入显式缺省和显式删除是为了增强对类默认函数的控制，让程序员能够更加精细地控制默认版本的函数。不过这并不是它们的唯一功能，而且使用上，也不仅仅局限在类的定义内。事实上，显式缺省不仅可以用于在类的定义中修饰成员函数，也可以在类定义之外修饰成员函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Defaultedoptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用“= default”来产生缺省版本</span></span><br><span class="line">    <span class="built_in">Defaultdoptr</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里没使用“default”</span></span><br><span class="line">    Defaultedoptr &amp; <span class="keyword">operator</span> = (<span class="type">const</span> Defaultedoptr &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在类定义外用“= default”来指明使用缺省版本</span></span><br><span class="line"><span class="keyword">inline</span> Defaultedoptr &amp; Defaultedoptr::<span class="keyword">operator</span> =(<span class="type">const</span> Defaultedoptr &amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><br>类<code>Defaultedoptr</code>的操作符<code>operator=</code>被声明在了类的定义外，并且被设定为缺省版本。这在C++11规则中也是被允许的。在类定义外显式指定缺省版本所带来的好处是，程序员可以对一个 class定义提供多个实现版本。</p>
<p>对一些普通的函数仍然可以通过显式删除来禁止类型转换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">char</span> c)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Func</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">Func</span>(<span class="string">&#x27;c&#x27;</span>);   <span class="comment">// 显式删除char版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显式删除还有一些有趣的使用方式。比如使用显式删除来删除自定义类型的<code>operator new</code>操作符的话，皆可以做到避免在堆上分配该class的对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoHeapAlloc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NoHeapAlloc n;</span><br><span class="line">    NoHeapAlloc * a = <span class="keyword">new</span> <span class="built_in">NoHeapAlloc</span>(); <span class="comment">// 失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h2><h3 id="C-11中的lambda函数"><a href="#C-11中的lambda函数" class="headerlink" title="C++11中的lambda函数"></a>C++11中的lambda函数</h3><p>我们可以通过一个例子先来观察一下，如代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> girls = <span class="number">3</span>, boys = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">auto</span> totalChild = [] &#123;<span class="type">int</span> x, <span class="type">int</span> y&#125; -&gt;<span class="built_in">int</span>( <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">totalChild</span>(girls, boys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个lambda函数。该函数接受两个参数<code>(int x, int y)</code>，并且返回其和。直观地看， lambda函数跟普通函数相比不需要定义函数名，取而代之的多了一对方括号<code>[]</code>。此外， lambda函数还采用了追踪返回类型的方式声明其返回值。其余方面看起来则跟普通函数定义一样。</p>
<p>而通常情况下， lambda函数的语法定义如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] (parameters) <span class="keyword">mutable</span> -&gt; <span class="keyword">return</span>-type&#123;statement&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li><code>[capture]</code>：捕捉列表。捕捉列表总是出现在 lambda函数的开始处。事实上，<code>[]</code>是lambda引出符。编译器根据该引出符判断接下来的代码是否是lambda函数。捕捉列表能够捕捉上下文中的变量以供 lambda函数使用。具体的方法在下文中会再描述。</li>
<li><code>(parameters)</code>：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号一起省略。</li>
<li><code>mutable</code>：<code>mutable</code>修饰符。默认情况下，lambda函数总是一个const函数，<code>mutable</code>可以取消其常量性。在使用该修饰符时，参数列表不可省略(即使参数为空)。</li>
<li><code>return-type</code>：返回类型。用追踪返回类型形式声明函数的返回类型。出于方便，不需要返回值的时候也可以连同符号<code>-&gt;</code>一起省略。此外，在返回类型明确的情况下也可以省略该部分，让编译器对返回类型进行推导。</li>
<li><code>&#123;statement&#125;</code>：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</li>
</ul>
<p>在lambda函数的定义中，参数列表和返还类型都是可选的部分，而捕捉列表和函数体都可能为空。那么在极端情况下，C++11中最为简略的alambda函数只需要声明为<code>[]&#123;&#125;</code>就可以了。不过该lambda函数不能做任何事情。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    []&#123;&#125;; <span class="comment">// 最简单的lambda函数</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">4</span>;</span><br><span class="line">    [=] &#123; <span class="keyword">return</span> a + b; &#125;   <span class="comment">// 省略了参数列表与返回类型，返回类型由编译器推断为int</span></span><br><span class="line">    <span class="keyword">auto</span> fun1 = [&amp;](<span class="type">int</span> c) &#123; b = a + c; &#125; <span class="comment">//省略了返回类型，无返回值</span></span><br><span class="line">    <span class="keyword">auto</span> fun2 = [=, &amp;b](<span class="type">int</span> c) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> b = a + c; &#125;;<span class="comment">//各部分都很完整的lambda函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直观地讲， lambda函数与普通函数可见的最大区别之一，就是lambda函数可以通过捕捉列表访问一些上下文中的数据。具体地，捕捉列表描述了上下文中哪些的数据可以被lambda使用，以及使用方式(以值传递的方式或引用传递的方式)。</p>
<p>lambda函数的运算是基于初始状态进行的运算。这与函数简单基于参数的运算是有所不同的。语法上，捕捉列表由多个捕捉项组成，并以逗号分割。捕提列表有如下几种形式：</p>
<ul>
<li><code>[var]</code>表示值传递方式捕捉变量<code>var</code></li>
<li><code>[=]</code>表示值传递方式捕捉所有父作用域的变量(包括this)</li>
<li><code>[&amp;var]</code>表示引用传递捕捉变量<code>var</code></li>
<li><code>[&amp;]</code>表示引用传递捕捉所有父作用域的变量(包括this)</li>
<li><code>[this]</code>表示值传递方式捕提当前的this指针。</li>
</ul>
<p>通过一些组合，捕捉列表可以表示更复杂的意思。比如</p>
<ul>
<li><code>[=, &amp;a, &amp;b]</code>表示以引用传递的方式捕捉变量<code>a</code>和<code>b</code>，值传递方式捕提其他所有变量。</li>
<li><code>[&amp;, a, this]</code>表示以值传递的方式捕捉变量<code>a</code>和<code>this</code>，引用传递方式捕捉其他所有变量。</li>
</ul>
<p>不过值得注意的是，捕捉列表不允许变量重复传递。下面一些例子就是典型的重复，会导致编译时期的错误。</p>
<ul>
<li><code>[=, a]</code>这里<code>=</code>已经以值传递方式捕捉了所有变量，捕捉<code>a</code>重复</li>
<li><code>[&amp;, &amp;this]</code>这里<code>&amp;</code>已经以引用传递方式捕捉了所有变量，再捕捉this也是一种重复。</li>
</ul>
<h3 id="lambda与仿函数"><a href="#lambda与仿函数" class="headerlink" title="lambda与仿函数"></a>lambda与仿函数</h3><p>仿函数简单地说，就是重定义了成员函数<code>operator ()</code>的一种自定义类型对象。这样的对象有个特点，就是其使用在代码层面感觉跟函数的使用并无二样，但究其本质却并非函数。我们可以看一个仿函数的例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_functor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> girls = <span class="number">3</span>, boys = <span class="number">4</span>;</span><br><span class="line">    _functor totalChild;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">totalChild</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>class _functor</code>的<code>operator()</code>被重载，因此，在调用该函数的时候，我们看到跟函数调用一样的形式，只不过这里的<code>totalChild</code>不是函数名称，而是对象名称。</p>
<p>注意相比于函数，仿函数可以拥有初始状态，一般通过class定义私有成员，并在声明对象的时候对其进行初始化。私有成员的状态就成了仿函数的初始状态。而由于声明一个仿函数对象可以拥有多个不同初始状态的实例，因此可以借由仿函数产生多个功能类似却不同的仿函数实例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tax</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> rate;</span><br><span class="line">    <span class="type">int</span> base;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tax</span>(<span class="type">float</span> r, <span class="type">int</span> b): <span class="built_in">rate</span>(r), <span class="built_in">base</span>(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">float</span> money)</span> </span>&#123; <span class="keyword">return</span> (money - base) * rate; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Tax <span class="title">high</span><span class="params">(<span class="number">0.4</span>, <span class="number">3000</span>)</span></span>;</span><br><span class="line">    <span class="function">Tax <span class="title">middle</span><span class="params">(<span class="number">0.25</span>, <span class="number">20000</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过带状态的仿函数，可以设定两种不同的税率的计算。而仔细观察的话，除去自定义类型<code>_functor</code>的声明及其对象的定义，除去在语法层面上的不同， lambda和仿函数有着相同的内涵，都可以捕捉一些变量作为初始状态并接受参数进行运算。</p>
<h3 id="lambda的基础使用"><a href="#lambda的基础使用" class="headerlink" title="lambda的基础使用"></a>lambda的基础使用</h3><p>最为简单的应用下，我们会利用 lambda函数来封装一些代码逻辑，使其不仅具有函数的包装性，也具有就地可见的自说明性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> z;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> c;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Calc</span><span class="params">(<span class="type">int</span>&amp;, <span class="type">int</span>, <span class="type">float</span> &amp;, <span class="type">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Testcalc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> success = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> validate = [&amp;]() -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x == y+z) &amp;&amp; (a == b+c))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Calc</span> (x, y, a, b);</span><br><span class="line">    success += <span class="built_in">validate</span>();</span><br><span class="line">    y = <span class="number">1024</span>;</span><br><span class="line">    b = <span class="number">1e13</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Calc</span> (x, y, a, b);</span><br><span class="line">    success += <span class="built_in">validate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里使用了一个<code>auto</code>关键字推导出了<code>validate</code>变量的类型为匿名 lambda函数。可以看到，我们使用lambda函数直接访问了<code>Testcal</code>中的局部的变量来完成这个工作。在没有 lambda函数之前，通常需要在<code>Testcalc</code>外声明同样一个函数，并且把 <code>Testcalc</code>中的变量当作参数进行传递。出于函数作用域及运行效率考虑，这样声明的函数通常还需要加上关键字 static和 inline。相比于一个传统意义上的函数定义， lambda函数在这里更加直观。</p>
<h3 id="关于lambda的一些问题及有趣的实验"><a href="#关于lambda的一些问题及有趣的实验" class="headerlink" title="关于lambda的一些问题及有趣的实验"></a>关于lambda的一些问题及有趣的实验</h3><p>使用 lambda函数的时候，捕捉列表不同会导致不同的结果。具体地讲，按值方式传递捕提列表和按引用方式传递捕捉列表效果是不一样的。对于按值方式传递的捕捉列表，其传递的值在 lambda函数定义的时候就已经决定了。而按引用传递的捕捉列表变量，其传递的值则等于 lambda函数调用时的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">auto</span> by_val_lambda = [=] &#123; <span class="keyword">return</span> j + <span class="number">1</span>; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> by_ref_lambda = [&amp;] &#123; <span class="keyword">return</span> j + <span class="number">1</span>; &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;by val lambda: &quot;</span> &lt;&lt; <span class="built_in">by_val_lambda</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;by ref lambda: &quot;</span> &lt;&lt; <span class="built_in">by_ref_lambda</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    j ++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;by val lambda: &quot;</span> &lt;&lt; <span class="built_in">by_val_lambda</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;by ref lambda: &quot;</span> &lt;&lt; <span class="built_in">by_ref_lambda</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">by val lambda: 13</span><br><span class="line">by ref lambda: 13</span><br><span class="line">by val lambda: 13</span><br><span class="line">by ref lambda: 13</span><br></pre></td></tr></table></figure></p>
<p>这个结果的原因是由于在<code>by_val_lambda</code>中，<code>j</code>被视为了一个常量，一旦初始化后不会再改变(可以认为之后只是一个跟父作用域中<code>j</code>同名的常量)而在<code>by_ref_lambda</code>中，<code>j</code>仍在使用父作用域中的值。</p>
<p>因此简单地总结的话，在使用 lambda函数的时候，如果需要捕捉的值成为 lambda函数的常量，我们通常会使用按值传递的方式捕捉；反之，需要捕捉的值成为 lambda函数运行时的变量(类似于参数的效果)，则应该采用按引用方式进行捕捉。</p>
<p>从C++11标准的定义上可以发现， lambda的类型被定义为“闭包”(closure)的类，而每个 lambda表达式则会产生一个闭包类型的临时对象(右值)。因此，严格地讲， lambda函数并非函数指针。不过C++11标准却允许 lambda表达是向函数指针的转换，但前提是lambda函数没有捕捉任何变量，且函数指针所示的函数原型，必须跟 lambda函数有着相同的调用方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> girls = <span class="number">3</span>, boys = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">auto</span> totalchild = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*allchild)</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*oneChild)</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    allchild p;</span><br><span class="line">    p = totalchild;</span><br><span class="line"></span><br><span class="line">    onechild q;</span><br><span class="line">    q = totalchild;    <span class="comment">// 编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(totalchild) allpeople = totalchild; <span class="comment">// 需通过decltype获得lambda类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(totalchild) totalpeople = p;        <span class="comment">// 编译失败，指针无法转成lambda</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以把没有捕捉列表的<code>totalchild</code>转化为接受参数类型相同的<code>allchild</code>类型的函数指针。不过，转化为参数类型不一致的<code>onechild</code>类型则会失败。此外，将函数指针转化为lambda也是不成功的。值得注意的是，程序员也可以通过<code>decltype</code>的方式来获得 lambda函数的类型。</p>
<p>除此之外，还有一个问题是关于 lambda函数的常量性及 mutable关键字的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">auto</span> const_val_lambda = [=]() &#123; val = <span class="number">3</span>; &#125;; <span class="comment">//编译失败，在const的lambda中修改常量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//非const的lambda，可以修改常量数据</span></span><br><span class="line">    <span class="keyword">auto</span> mutable_val_lambda = [=]() <span class="keyword">mutable</span> &#123; val = <span class="number">3</span>; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//依然是 const的lambda，不过没有改动引用本身</span></span><br><span class="line">    <span class="keyword">auto</span> const_ref_lambda = [&amp;] &#123; val = <span class="number">3</span>; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//依然是 const的lambda，通过参数传递val</span></span><br><span class="line">    <span class="keyword">auto</span> const_param_lambda = [&amp;](<span class="type">int</span> v) &#123; v = <span class="number">3</span>; &#125;;</span><br><span class="line">    <span class="built_in">const_param_lambda</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了4种不同的 lambda函数，这4种 lambda 函数本身的行为都是一致的，即修改父作用域中传递而来的val参数的值。不过对于<code>const_val_lambda</code>函数而言，编译器认为这是一个错误。而对于声明了 mutable属性的函数<code>mutable_val_lambda</code>，以及通过引用传递变量<code>val</code>的<code>const_ref_lambda</code>函数，甚至是通过参数来传递变量<code>val</code>的<code>const_param_lambda</code>，编译器均不会报错。如我们之前的定义中提到一样，C++11中，默认情况下 lambda函数是一个 const函数。按照规则，一个 const的成员函数是不能在函数体中改变非静态成员变量的值的。但这里明显编译器对不同传参或捕捉列表的 lambda函数执行了不同的规则有着不同的见解。</p>
<p>这跟 lambda函数的特别的常量性相关。lambda函数的函数体部分被转化为仿函数之后会成为一个 class 的常量成员函数。整个<code>const_val_lambda</code>看起来会是代码清单所示的样子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">const_val_lambda</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">const_val_lambda</span>(<span class="type">int</span> v): <span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123; val = <span class="number">3</span>; &#125; <span class="comment">/*注意：常量成员函数*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于常量成员函数，其常量的规则跟普通的常量函数是不同的。具体而言，对于常量成员函数，不能在函数体内改变 class 中任何成员变量。</p>
<p>lambda的捕捉列表中的变量都会成为等价仿函数的成员变量，而常量成员函数(如<code>operator()</code>)中改变其值是不允许的，因而按值捕捉的变量在没有声明为 mutable的 lambda函数中，其值一旦被修改就会导致编译器报错。</p>
<p>而使用引用的方式传递的变量在常量成员函数中值被更改则不会导致错误。简单地说，由于函数<code>const_ref_lambda</code>不会变引用本身，而只会改变引用的值，因此编译器将编译通过。至于按传参数的<code>const_param_lambd</code>就更加不会引起编译器的“抱怨”了。准确地讲，现有C+11标准中的 lambda等价的是有常量<code>operator()</code>的仿函数。因此在使用捕捉列表的时候必须注意，按值传递方式捕捉的变量是 lambda函数中不可更改的常量。</p>
<p>此外， lambda函数的<code>mutable</code>修饰符可以消除其常量性，不过这实际上只是提供了一种语法上的可能性。大多数时侯，我们使用默认版本的(非<code>mutable</code>)的lambda函数也就足够了。</p>
<h3 id="lambda与STL"><a href="#lambda与STL" class="headerlink" title="lambda与STL"></a>lambda与STL</h3><p>首先我们来看一个最为常见的STL算法<code>for_each</code>。简单地说，<code>for_each</code>算法的原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UnaryProc <span class="title">for_each</span><span class="params">(InputIterator beg, InputIterator end, UnaryProc op)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>for_each</code>算法需要一个标记开始的<code>Iterator</code>，一个标记结束的<code>Iterator</code>，以及一个接受单个参数的“函数”(即一个函数指针、仿函数或者lambda函数)。<code>for_each</code>的一个示意实现如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for_each(Iterator begin, Iterator end, Function fn) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator i = begin; i ! end; ++i)</span><br><span class="line">        <span class="built_in">fn</span>(*i);</span><br></pre></td></tr></table></figure></p>
<p>通过<code>for_each</code>，我们可以完成各种循环操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; largenums;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ubound = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Largenumsfunc</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; ubound)</span><br><span class="line">        largenums.<span class="built_in">push_back</span> (i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Above</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传统的for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itr = nums.<span class="built_in">begin</span>(); itr != nums.<span class="built_in">end</span>(): ++itr)</span><br><span class="line">        <span class="keyword">if</span> (*itr &gt;= ubound)</span><br><span class="line">            largenums.<span class="built_in">push_back</span>(*itr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用函数指针</span></span><br><span class="line">    for_each (nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), Largenumsfunc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用lambda函数和算法for_each</span></span><br><span class="line">    for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [-](<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; ubound)</span><br><span class="line">            largenums.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们分别用了3种方式来遍历一个<code>vector nums</code>，找出其中大于<code>ubound</code>的值，并将其写入另外一个<code>vector largenums</code>中。第一种是传统的for循环；第二种，则更泛型地使用了<code>for_each</code>算法以及函数指针；第三种同样使用了<code>for_each</code>，但是第三个参数传入的是 lambda函数。首先必须指出的是使用<code>for_each</code>的好处，使用<code>for_each</code>算法不用关心<code>Iterator</code>，或者说循环的细节，只需要设定边界，作用于每个元素的操作，就可以在近似“一条语句”内完成循环，正如函数指针版本和 lambda版本完成的那样。</p>
<p>函数指针的方式看似简洁，不过却有很大的缺陷。第一点是函数定义在别的地方，比如很多行以前(后)或者别的文件中这样的代码阅读起来并不方便。第二点则是出于效率考虑，使用函数指针很可能导致编译器不对其进行 inline优化，在循环次数较多的时候，内联的 lambda和没有能够内联的函数指针可能存在着巨大的性能差别。因此，相比于函数指针，lambda拥有无可替代的优势。</p>
<h1 id="融入实际应用"><a href="#融入实际应用" class="headerlink" title="融入实际应用"></a>融入实际应用</h1><h2 id="对齐支持"><a href="#对齐支持" class="headerlink" title="对齐支持"></a>对齐支持</h2><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><p>在了解为什么数据需要对齐之前，我们可以回顾一下打印结构体的大小<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HowManyBytes</span>&#123;</span><br><span class="line">    <span class="type">char</span>     a;</span><br><span class="line">    <span class="type">int</span>      b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(char): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(int): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(HowManyBytes): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(HowManyBytes) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;offset of char a: &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(HowManyBytes, a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;offset of int b: &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(HowManyBytes, b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结构体<code>HowManyBytes</code>由一个char类型成员<code>a</code>及一个int类型成员<code>b</code>组成。编译运行得到如下结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sizeof(char): 1</span><br><span class="line">sizeof (int): 4</span><br><span class="line">sizeof (Howmanybytes): 8</span><br><span class="line"></span><br><span class="line">offset of char a: 0</span><br><span class="line">offset of int b:  4</span><br></pre></td></tr></table></figure></p>
<p>这个现象主要是由于数据对齐要求导致的。通常情况下，C/C++结构体中的数据会有一定的对齐要求。在这个例子中，可以通过<code>offsetof</code>查看成员的偏移的方式来检验数据的对齐方式。这里<code>b</code>并非紧邻着<code>a</code>排列。C/C++的int类型数据要求对齐到4字节，即要求int类型数据必须放在一个能够整除4的地址上；而char要求对齐到1字节。这就造成了成员a之后的3字节空间被空出，通常我们也称因为对齐而造成的内存留空为填充数据( padding data)。</p>
<p>对齐方式通常是一个整数，它表示的是一个类型的对象存放的内存地址应满足的条件。对齐的数据在读写上会有性能上的优势。比如频繁使用的数据如果与处理器的高速缓存器大小对齐，有可能提高缓存性能。而数据不对齐可能造成一些不良的后果，比较严重的当属导致应用程序退出。典型的，如在有的平台上，硬件将无法读取不按字对齐的某些类型数据，这个时候硬件会抛出异常来终止程序。而更为普遍的，在一些平台上，不按照字对齐的数据会造成数据读取效率低下</p>
<p>我们利用C++11新提供的修饰符<code>alignas</code>来重新设定<code>Colorvector</code>的对齐方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">32</span>) Colorvector &#123;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    <span class="type">double</span> g;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-11的alignof和alignas"><a href="#C-11的alignof和alignas" class="headerlink" title="C++11的alignof和alignas"></a>C++11的alignof和alignas</h3><p><code>alignof</code>的操作数表示一个定义完整的自定义类型或者内置类型或者变量，返回的值是一个<code>std::size_t</code>类型的整型常量。如同<code>sizeof</code>操作符一样，<code>alignof</code>获得的也是一个与平台相关的值。</p>
<p><code>alignas</code>既可以接受常量表达式，也可以接受类型作为参数，比如<code>aligns(double) char c</code>也是合法的描述符。其使用效果跟<code>alignas(alignof(double)) char c</code>是一样的。</p>
<blockquote>
<p>在C++11标准之前，我们也可以使用一些编译器的扩展来描述对齐方式，比如GNU格式的<code>__attribute__((__aligned__(8))</code>就是一个广泛被接受的版本。</p>
</blockquote>
<p>我们在使用常量表达式作为<code>alignas</code>的操作符的时候，其结果必须是以2的自然数幂次作为对齐值。对齐值越大，我们称其对齐要求越高；而对齐值越小，其对齐要求也越低。</p>
<p>在C++11标准中规定了一个“基本对齐值”(fundamental alignment)。一般情况下其值通常等于平台上支持的最大标量类型数据的对齐值(常常是<code>long double</code>)。我们可以通过<code>alignof(std::max_align_t)</code>来查询其值。</p>
<p>对齐描述符可以作用于各种数据。具体来说，可以修饰变量、类的数据成员等，而位域(bit field)以及用<code>register</code>声明的变量则不可以。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alignas</span>(<span class="type">double</span>) <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">//错误：alignas不能修饰函数</span></span><br><span class="line"><span class="built_in">alignas</span>(<span class="type">double</span>) <span class="type">unsigned</span> <span class="type">char</span> c[<span class="built_in">sizeof</span>(<span class="type">double</span>)); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> c [<span class="built_in">sizeof</span>(<span class="type">double</span>)];</span><br><span class="line"><span class="built_in">alignas</span>(<span class="type">float</span>)</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> c[<span class="built_in">sizeof</span>(<span class="type">double</span>)); <span class="comment">// 错误：不同对齐方式的变量定义</span></span><br></pre></td></tr></table></figure>
<p>我们再来看一个例子，这个例子中我们采用了模板的方式来实现一个固定容量但是大小随着所用的数据类型变化的容器类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">aligns</span>(<span class="built_in">alignof</span>(<span class="type">double</span>)*<span class="number">4</span>) Colorvector &#123;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    <span class="type">double</span> g;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//固定容量的模板数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fixedcapacityarray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T t)</span> </span>&#123;<span class="comment">/*在data中加入t变量*/</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">alignas</span><span class="params">(T)</span> data[1024] </span>= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// int length = 1024 / sizeof(T);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Fixedcapacityarray&lt;<span class="type">char</span>&gt; arrch;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;alignof(char):&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;alignof(arch. data): &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(arch.data) &lt;&lt; endl;</span><br><span class="line">    Fixedcapacityarray&lt;colorvector&gt; arrcv;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;alignof(Colorvector):&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(colorvector) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;alignof(arrcv.data):&quot;</span> &lt;&lt; <span class="built_in">alignof</span> (arrcv.data) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在本例中，<code>Fixedcapacityarray</code>固定使用1024字节的空间，但由于模板的存在，可以实例化为各种版本。这样一来，我们可以在相同的内存使用量的前提下，做出多种类型(内置或者自定义)版本的数组。</p>
<p>如我们之前提到的一样，为了有效地访问数据，必须使得数据按照其固有特性进行对齐。对于<code>arrch</code>，由于数组中的元素都是char类型，所以对齐到1就行了，而对于我们定义的<code>arrcv</code>，必须使其符合<code>Colorvector</code>的扩展对齐，即对齐到8字节的内存边界上。在这个例子中，起到关键作用的代码是下面这一句<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">alignas</span><span class="params">(T)</span> data[1024]</span>=&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该句指示<code>data[1024]</code>这个char类型数组必须按照模板参数T的对齐方式进行对齐。编译运行该例子后，可以在实验机上得到如下结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alignof (char): 1</span><br><span class="line">alignof (arrch.data): 1</span><br><span class="line">alignof (Colorvector): 32</span><br><span class="line">alignof (arrcv.data): 32</span><br></pre></td></tr></table></figure></p>
<p>如果我们去掉<code>alignas(T)</code>这个修饰符，代码的运行结果会完全不同，具体如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alignof (char): 1</span><br><span class="line">alignof (arch.data): 1</span><br><span class="line">alignof (Colorvector): 32</span><br><span class="line">alignof (arrcv.data): 1</span><br></pre></td></tr></table></figure></p>
<p>可以看到，由于char数组默认对齐值为1，会导致<code>data[1024]</code>数组也对齐到1。这肯定不是程序员愿意见到的。事实上，在C++11标准引入<code>alignas</code>修饰符之前，这样的固定容量的泛型数组有时可能遇到因为对齐不佳而导致的性能损失(甚至程序错误)，这给库的编写者带来了很大的困扰。而引入<code>alignas</code>能够解决这些移植性的困难</p>
<p>在STL库中，还内建了<code>std::align</code>函数来动态地根据指定的对齐方式调整数据块的位置。该函数的原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">align</span><span class="params">(std::<span class="type">size_t</span> alignment, std::<span class="type">size_t</span> size, <span class="type">void</span>*&amp; ptr, std::<span class="type">size_t</span>&amp; space)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>该函数在<code>ptr</code>指向的大小为<code>space</code>的内存中进行对齐方式的调整，将<code>ptr</code>开始的<code>size</code>大小的数据调整为按<code>alignment</code>对齐。</p>
<h2 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h2><h3 id="语言扩展到通用属性"><a href="#语言扩展到通用属性" class="headerlink" title="语言扩展到通用属性"></a>语言扩展到通用属性</h3><p>扩展语法中比较常见的就是“属性”( attribute)。属性是对语言中的实体对象(比如函数、变量、类型等)附加一些的额外注解信息，其用来实现一些语言及非语言层面的功能，或是实现优化代码等的一种手段。不同编译器有不同的属性语法。比如对于g++，属性是通过GNU的关键字<code>__attribute__</code>来声明的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">area</span><span class="params">(<span class="type">int</span> n)</span> __<span class="title">attribute__</span><span class="params">((<span class="type">const</span>))</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> areas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">        areas += <span class="built_in">area</span>(<span class="number">3</span>) * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>const</code>属性告诉编译器，本函数返回值只依赖于输入，不会改变任何函数外的值，因此没有副作用，编译器可以对函数进行优化，从而大大提高了程序的执行性能。</p>
<h3 id="C-11的通用属性"><a href="#C-11的通用属性" class="headerlink" title="C++11的通用属性"></a>C++11的通用属性</h3><p>C++11语言中的通用属性使用了左右双中括号的形式<code>[[attribute-list]]</code>，这样设计的好处是：既不会消除语言添加或者重载关键字的能力，又不会占用用户而的关键字的名字空间。语法上，C+11的通用属性可以作用于类型、变量、名称、代码块等。对于作用声的通用属性，既可以写在声明的起始处，也可以写在声明的标识符之后。而对于作用于整个语句的通用属性，则应该写在语句起始处。</p>
<p>而出现在以上两种规则描述的位置之外的通用属性，作用于哪个实体跟编译器具体的实现有关。我们可以看几个例子。第一个是关于通用属性应用于函数的，具体如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[attr1]] <span class="type">void</span> func [[attr2]] ();</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>[[attr1]]</code>出现在函数定义之前，而<code>[[attr2]]</code>则位于函数名称之后，根据定义，<code>[[attr1]]</code>和<code>[[attr2]]</code>均可以作用于函数<code>func</code>。</p>
<p>现有C++11标准中，只预定义了两个通用属性，分别是<code>[[noreturn]]</code>和<code>[[carries_dependency]]</code>。</p>
<h3 id="预定义的通用属性"><a href="#预定义的通用属性" class="headerlink" title="预定义的通用属性"></a>预定义的通用属性</h3><p><code>[[noreturn]]</code>是用于标识不会返回的函数的。这里必须注意，不会返回和没有返回值的(void)函数的区别。没有返回值的void函数在调用完成后，调用者会接着执行函数后的代码；而不会返回的函数在被调用完成后，后续代码不会再被执行。主要用于标识那些不会将控制流返回给原调用函数的函数，典型的例子有有终止应用程序语句的函数、有无限循环语句的函数、有异常抛出的函数等。通过这个属性，开发人员可以告知编译器某些函数不会将控制流返回给调用函数，这能帮助编译器产生更好的警告信息，同时编译器也可以做更多的诸如死代码消除、免除为函数调用者保存一些特定寄存器等代码优化工作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dosomething1</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dosomething2</span> <span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">[[noreturn]] <span class="function"><span class="type">void</span> <span class="title">Throwaway</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;expection&quot;</span>;</span><br><span class="line">&#125; <span class="comment">//控制流跳转到异常处理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Dosomething1</span>();</span><br><span class="line">    <span class="built_in">Throwaway</span>();</span><br><span class="line">    <span class="built_in">Dosomething2</span>();<span class="comment">//该函数不可到达</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>Throwaway</code>抛出了异常，<code>Dosomething2</code>水远不会被执行，这个时候将<code>Throwaway</code>标记为<code>[[noreturn]]</code>的话，编译器会不再为<code>Throwaway</code>之后生成调用<code>Dosomething2</code>的代码。当然，编译器也可以选择为<code>func</code>函数中的<code>Dosomething2</code>做出一些警告以提示程序员这里有不可到达的代码。不返回的函数除了是有异常抛出的函数外，还有可能是有终止应用程序语句的函数，或是有无限循环语句的函数等。</p>
<p>另外一个通用属性<code>[[carries_dependency]]</code>则跟并行情况下的编译器优化有关。事实上<code>[[carries_dependency]]</code>主要是为了解决弱内存模型平台上使用<code>memory_order_consume</code>内存顺序枚举问题。</p>
<p><code>memory_order_consume</code>的主要作用是保证对当前原子类型数据的读取操作先于所有之后关于该原子变量的操作完成，但它不影响其他原子操作的顺序。要保证这样的“先于发生”的关系，编译器往往需要根据memory_model枚举值在原子操作间构建一系列的依赖关系，以减少在弱一致性模型的平台上产生内存栅栏。不过这样的关系则往往会由于函数的存在而被破坏。比如下面的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">int</span>*&gt; a;</span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)a.<span class="built_in">load</span>(memory_order_consume);</span><br><span class="line"><span class="built_in">func</span>(p);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，编译器在编译时可能并不知道<code>func</code>函数的具体实现，因此，如果要保证<code>load</code>先于任何关于<code>a</code>(或是<code>p</code>)的操作发生，编译器往往会在<code>func</code>函数之前加入一条内存栅栏。然而，如果<code>func</code>的实现是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(<span class="type">int</span> * p) &#123;</span><br><span class="line">    <span class="comment">// 假设p2是一个 atomic&lt;int*&gt;的变量</span></span><br><span class="line">    p<span class="number">2.</span><span class="built_in">store</span>(p, memory_order_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么对于<code>func</code>函数来说，由于<code>p2.store</code>使用了<code>memory_order_release</code>的内存顺序，因此，<code>p2.store</code>对<code>p</code>的使用会被保证在任何关于<code>p</code>的使用之后完成。这样一来，编译器在<code>func</code>函数之前加入的内存栅栏就变得毫无意义，且影响了性能。</p>
<p>而解决的方法正是使用<code>[[carries_dependency]]</code>。该通用属性既可以标识函数参数，又可以标识函数的返回值。当标识函数的参数时，它表示数据依赖随着参数传递进入函数，即不需要产生内存栅栏。而当标识函数的返回值时，它表示数据依赖随着返回值传递出函数，不需要产生内存栅栏。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/19/%E5%8C%97%E4%BA%AC%E5%9C%B0%E9%93%81%E8%A7%84%E5%88%92/" rel="prev" title="北京地铁2025年规划">
      <i class="fa fa-chevron-left"></i> 北京地铁2025年规划
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/24/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B02/" rel="next" title="深入分析Linux内核源码笔记2">
      深入分析Linux内核源码笔记2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B0%E6%A0%87%E5%87%86%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="nav-number">1.</span> <span class="nav-text">新标准的诞生</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11%E8%AF%AD%E8%A8%80%E5%8F%98%E5%8C%96%E7%9A%84%E9%A2%86%E5%9F%9F"><span class="nav-number">1.1.</span> <span class="nav-text">C++11语言变化的领域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E7%A1%AC%E4%BB%B6%E7%B4%A7%E5%AF%86%E5%90%88%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">与硬件紧密合作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%9E%8D%E5%85%A5%E7%BC%96%E7%A8%8B%E7%8E%B0%E5%AE%9E"><span class="nav-number">1.3.</span> <span class="nav-text">融入编程现实</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%92%8C%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">保证稳定性和兼容性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E6%8C%81%E4%B8%8EC99%E5%85%BC%E5%AE%B9"><span class="nav-number">2.1.</span> <span class="nav-text">保持与C99兼容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="nav-number">2.1.1.</span> <span class="nav-text">预定义宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#func%E9%A2%84%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">2.1.2.</span> <span class="nav-text">func预定义标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pragma-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">2.1.3.</span> <span class="nav-text">_Pragma 操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A-VA-ARGS"><span class="nav-number">2.1.4.</span> <span class="nav-text">变长参数的宏定义以及 VA_ARGS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#long-long%E6%95%B4%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">long long整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%9A%84%E6%95%B4%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text">扩展的整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F-cplusplus"><span class="nav-number">2.4.</span> <span class="nav-text">宏__cplusplus</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80"><span class="nav-number">2.5.</span> <span class="nav-text">静态断言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E8%A8%80%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86%E6%97%B6"><span class="nav-number">2.5.1.</span> <span class="nav-text">断言：运行时与预处理时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80%E4%B8%8Estatic-assert"><span class="nav-number">2.5.2.</span> <span class="nav-text">静态断言与static_assert</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#noexcept%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B8%8Enoexcept%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">2.6.</span> <span class="nav-text">noexcept修饰符与noexcept操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">2.7.</span> <span class="nav-text">快速初始化成员变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84sizeof"><span class="nav-number">2.8.</span> <span class="nav-text">非静态成员的sizeof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%9A%84friend%E8%AF%AD%E6%B3%95"><span class="nav-number">2.9.</span> <span class="nav-text">扩展的friend语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-override-%E6%8E%A7%E5%88%B6"><span class="nav-number">2.10.</span> <span class="nav-text">final&#x2F;override 控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">2.11.</span> <span class="nav-text">模板函数的默认模板参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.12.</span> <span class="nav-text">外部模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%96%E9%83%A8%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.12.1.</span> <span class="nav-text">为什么需要外部模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%8E%E5%A4%96%E9%83%A8%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">2.12.2.</span> <span class="nav-text">显式的实例化与外部模板的声明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E4%B8%BA%E6%9C%AC%EF%BC%8C%E4%B8%93%E7%94%A8%E4%B8%BA%E6%9C%AB"><span class="nav-number">3.</span> <span class="nav-text">通用为本，专用为末</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">继承构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A7%94%E6%B4%BE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">委派构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%9A%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-number">3.3.</span> <span class="nav-text">右值引用：移动语义和完美转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%88%90%E5%91%98%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="nav-number">3.3.1.</span> <span class="nav-text">指针成员与拷贝构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-number">3.3.2.</span> <span class="nav-text">移动语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">3.3.3.</span> <span class="nav-text">左值、右值与右值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-move%EF%BC%9A%E5%BC%BA%E5%88%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8F%B3%E5%80%BC"><span class="nav-number">3.3.4.</span> <span class="nav-text">std::move：强制转化为右值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.5.</span> <span class="nav-text">移动语义的一些其他问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-number">3.3.6.</span> <span class="nav-text">完美转发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.4.</span> <span class="nav-text">显式转换操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.5.</span> <span class="nav-text">列表初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">3.5.1.</span> <span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84"><span class="nav-number">3.5.2.</span> <span class="nav-text">防止类型收窄</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#POD%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.6.</span> <span class="nav-text">POD类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93"><span class="nav-number">3.7.</span> <span class="nav-text">非受限联合体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">3.8.</span> <span class="nav-text">用户自定义字面量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4"><span class="nav-number">3.9.</span> <span class="nav-text">内联名字空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%AB%E5%90%8D"><span class="nav-number">3.10.</span> <span class="nav-text">模板的别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%8C%96%E7%9A%84SFINEA%E8%A7%84%E5%88%99"><span class="nav-number">3.11.</span> <span class="nav-text">一般化的SFINEA规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B0%E6%89%8B%E6%98%93%E5%AD%A6%EF%BC%8C%E8%80%81%E5%85%B5%E6%98%93%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">新手易学，老兵易用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%B3%E5%B0%96%E6%8B%AC%E5%8F%B7-gt-%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="nav-number">4.1.</span> <span class="nav-text">右尖括号&gt;的改进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">4.2.</span> <span class="nav-text">auto类型推导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">4.2.1.</span> <span class="nav-text">静态类型、动态类型与类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">4.2.2.</span> <span class="nav-text">auto的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E5%88%99"><span class="nav-number">4.2.3.</span> <span class="nav-text">auto的使用细则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decltype"><span class="nav-number">4.3.</span> <span class="nav-text">decltype</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#typeid%E4%B8%8Edecltype"><span class="nav-number">4.3.1.</span> <span class="nav-text">typeid与decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">decltype的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype%E6%8E%A8%E5%AF%BC%E5%9B%9B%E8%A7%84%E5%88%99"><span class="nav-number">4.3.3.</span> <span class="nav-text">decltype推导四规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cv%E9%99%90%E5%88%B6%E7%AC%A6%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%86%97%E4%BD%99%E7%9A%84%E7%AC%A6%E5%8F%B7"><span class="nav-number">4.3.4.</span> <span class="nav-text">cv限制符的继承与冗余的符号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E8%B8%AA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.</span> <span class="nav-text">追踪返回类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%BD%E8%B8%AA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">4.4.1.</span> <span class="nav-text">追踪返回类型的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%BD%E8%B8%AA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.2.</span> <span class="nav-text">使用追踪返回类型的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.5.</span> <span class="nav-text">基于范围的for循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="nav-number">5.</span> <span class="nav-text">提高类型安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE"><span class="nav-number">5.1.</span> <span class="nav-text">强类型枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE-1"><span class="nav-number">5.1.1.</span> <span class="nav-text">强类型枚举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.2.</span> <span class="nav-text">堆内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.2.1.</span> <span class="nav-text">显式内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-11%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">5.2.2.</span> <span class="nav-text">C++11的智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">5.2.3.</span> <span class="nav-text">垃圾回收的分类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%A1%AC%E4%BB%B6%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="nav-number">6.</span> <span class="nav-text">提高性能及操作硬件的能力</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">6.1.</span> <span class="nav-text">常量表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%80%A7%E4%B8%8E%E7%BC%96%E8%AF%91%E6%97%B6%E5%B8%B8%E9%87%8F%E6%80%A7"><span class="nav-number">6.1.1.</span> <span class="nav-text">运行时常量性与编译时常量性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0"><span class="nav-number">6.1.2.</span> <span class="nav-text">常量表达式函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%80%BC"><span class="nav-number">6.1.3.</span> <span class="nav-text">常量表达式值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8"><span class="nav-number">6.1.4.</span> <span class="nav-text">常量表达式的其他应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E6%A8%A1%E6%9D%BF"><span class="nav-number">6.2.</span> <span class="nav-text">变长模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%98%E9%95%BF%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">6.2.1.</span> <span class="nav-text">变长函数和变长的模板参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%89%E9%95%BF%E6%A8%A1%E6%9D%BF%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E5%8C%85%E5%92%8C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%8C%85"><span class="nav-number">6.2.2.</span> <span class="nav-text">変长模板：模板参数包和函数参数包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E6%A8%A1%E6%9D%BF%EF%BC%9A%E8%BF%9B%E9%98%B6"><span class="nav-number">6.2.3.</span> <span class="nav-text">变长模板：进阶</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">6.3.</span> <span class="nav-text">原子类型与原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8EC-11%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.3.1.</span> <span class="nav-text">原子操作与C++11原子类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8Ememory-order"><span class="nav-number">6.3.2.</span> <span class="nav-text">内存模型，顺序一致性与memory order</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="nav-number">6.4.</span> <span class="nav-text">线程局部存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E9%80%80%E5%87%BA%EF%BC%9Aquick-exit%E4%B8%8Eat-quick-exit"><span class="nav-number">6.5.</span> <span class="nav-text">快速退出：quick_exit与at_quick_exit</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E6%94%B9%E5%8F%98%E6%80%9D%E8%80%83%E6%96%B9%E5%BC%8F%E8%80%8C%E6%94%B9%E5%8F%98"><span class="nav-number">7.</span> <span class="nav-text">为改变思考方式而改变</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BCnullptr"><span class="nav-number">7.1.</span> <span class="nav-text">指针空值nullptr</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BC%EF%BC%9A%E4%BB%8E0%E5%88%B0NULL%EF%BC%8C%E5%86%8D%E5%88%B0nullptr"><span class="nav-number">7.1.1.</span> <span class="nav-text">指针空值：从0到NULL，再到nullptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nullptr%E5%92%8Cnullptr-t"><span class="nav-number">7.1.2.</span> <span class="nav-text">nullptr和nullptr_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8Enullptr%E8%A7%84%E5%88%99%E7%9A%84%E8%AE%A8%E8%AE%BA"><span class="nav-number">7.1.3.</span> <span class="nav-text">一些关于nullptr规则的讨论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="nav-number">7.2.</span> <span class="nav-text">默认函数的控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.1.</span> <span class="nav-text">类与默认函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9C-default%E2%80%9D%E4%B8%8E%E2%80%9D-deleted%E2%80%9D"><span class="nav-number">7.2.2.</span> <span class="nav-text">“&#x3D; default”与”&#x3D; deleted”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda%E5%87%BD%E6%95%B0"><span class="nav-number">7.3.</span> <span class="nav-text">lambda函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-11%E4%B8%AD%E7%9A%84lambda%E5%87%BD%E6%95%B0"><span class="nav-number">7.3.1.</span> <span class="nav-text">C++11中的lambda函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E4%B8%8E%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">7.3.2.</span> <span class="nav-text">lambda与仿函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.3.</span> <span class="nav-text">lambda的基础使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Elambda%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%8F%8A%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AE%9E%E9%AA%8C"><span class="nav-number">7.3.4.</span> <span class="nav-text">关于lambda的一些问题及有趣的实验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E4%B8%8ESTL"><span class="nav-number">7.3.5.</span> <span class="nav-text">lambda与STL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%9E%8D%E5%85%A5%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">8.</span> <span class="nav-text">融入实际应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E9%BD%90%E6%94%AF%E6%8C%81"><span class="nav-number">8.1.</span> <span class="nav-text">对齐支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90"><span class="nav-number">8.1.1.</span> <span class="nav-text">数据对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-11%E7%9A%84alignof%E5%92%8Calignas"><span class="nav-number">8.1.2.</span> <span class="nav-text">C++11的alignof和alignas</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">8.2.</span> <span class="nav-text">通用属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E6%89%A9%E5%B1%95%E5%88%B0%E9%80%9A%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">8.2.1.</span> <span class="nav-text">语言扩展到通用属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-11%E7%9A%84%E9%80%9A%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">8.2.2.</span> <span class="nav-text">C++11的通用属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E9%80%9A%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">8.2.3.</span> <span class="nav-text">预定义的通用属性</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
