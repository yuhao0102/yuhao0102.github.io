<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zn-ch">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="积累," />










<meta name="description" content="1. OpenMP基本介绍OpenMP是一个编译器指令和库函数的集合，主要是为共享式存储计算机上的并行程序设计使用的。目前支持OpenMP的语言主要有Fortran，C&#x2F;C++。 1.1 fork&#x2F;join并行执行模式的概念OpenMP在并行执行程序时，采用的是fork&#x2F;join式并行模式，共享存储式并行程序就是使用fork&#x2F;join式并行的。在开始时，只有一个叫做主线程的运行线程存在 。在运行过">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenMP基础">
<meta property="og:url" content="http://yoursite.com/2021/12/06/openmp%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="1. OpenMP基本介绍OpenMP是一个编译器指令和库函数的集合，主要是为共享式存储计算机上的并行程序设计使用的。目前支持OpenMP的语言主要有Fortran，C&#x2F;C++。 1.1 fork&#x2F;join并行执行模式的概念OpenMP在并行执行程序时，采用的是fork&#x2F;join式并行模式，共享存储式并行程序就是使用fork&#x2F;join式并行的。在开始时，只有一个叫做主线程的运行线程存在 。在运行过">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/22782486-39c6a9a1da904c10.gif">
<meta property="og:image" content="http://yoursite.com/img/22782486-6e84877ae3d67aae.gif">
<meta property="og:image" content="http://yoursite.com/img/22782486-dbd6ee9610fb13a5.gif">
<meta property="og:image" content="http://yoursite.com/img/20211202115649.png">
<meta property="og:image" content="http://yoursite.com/img/OpenMPRef-5.0-111802-web_Page1.png">
<meta property="og:image" content="http://yoursite.com/img/OpenMPRef-5.0-111802-web_Page2.png">
<meta property="og:image" content="http://yoursite.com/img/OpenMPRef-5.0-111802-web_Page3.png">
<meta property="og:image" content="http://yoursite.com/img/OpenMPRef-5.0-111802-web_Page4.png">
<meta property="og:image" content="http://yoursite.com/img/OpenMPRef-5.0-111802-web_Page5.png">
<meta property="og:image" content="http://yoursite.com/img/OpenMPRef-5.0-111802-web_Page6.png">
<meta property="og:image" content="http://yoursite.com/img/OpenMPRef-5.0-111802-web_Page7.png">
<meta property="og:image" content="http://yoursite.com/img/OpenMPRef-5.0-111802-web_Page8.png">
<meta property="og:image" content="http://yoursite.com/img/OpenMPRef-5.0-111802-web_Page9.png">
<meta property="og:image" content="http://yoursite.com/img/OpenMPRef-5.0-111802-web_Page10.png">
<meta property="og:image" content="http://yoursite.com/img/OpenMPRef-5.0-111802-web_Page11.png">
<meta property="og:image" content="http://yoursite.com/img/OpenMPRef-5.0-111802-web_Page12.png">
<meta property="article:published_time" content="2021-12-06T13:45:00.000Z">
<meta property="article:modified_time" content="2022-12-26T08:52:01.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="积累">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/22782486-39c6a9a1da904c10.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/12/06/openmp基础/"/>





  <title>OpenMP基础 | Hao Yu's blog</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/06/openmp%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OpenMP基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-06T21:45:00+08:00">
                2021-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-OpenMP基本介绍"><a href="#1-OpenMP基本介绍" class="headerlink" title="1. OpenMP基本介绍"></a>1. OpenMP基本介绍</h1><p>OpenMP是一个编译器指令和库函数的集合，主要是为共享式存储计算机上的并行程序设计使用的。目前支持OpenMP的语言主要有Fortran，C/C++。</p>
<h2 id="1-1-fork-join并行执行模式的概念"><a href="#1-1-fork-join并行执行模式的概念" class="headerlink" title="1.1 fork/join并行执行模式的概念"></a>1.1 fork/join并行执行模式的概念</h2><p>OpenMP在并行执行程序时，采用的是fork/join式并行模式，共享存储式并行程序就是使用fork/join式并行的。在开始时，只有一个叫做主线程的运行线程存在 。在运行过程中，当遇到需要进行并行计算的时候，派生出（Fork）线程来执行并行任务 。在并行代码结束执行，派生线程退出或挂起，控制流程回到单独的主线程中（Join）。</p>
<p>如图，标准并行模式执行代码的基本思想是，程序开始时只有一个主线程，程序中的串行部分都由主线程执行，并行的部分是通过派生其他线程来执行，但是如果并行部分没有结束时是不会执行串行部分的，先看一个简单例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">     <span class="type">clock_t</span> t1 = <span class="built_in">clock</span>();</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         a = i+<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">clock_t</span> t2 = <span class="built_in">clock</span>();</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Time = %d\n&quot;</span>, t2-t1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">clock_t</span> t1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">     <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ )&#123;</span><br><span class="line">         <span class="built_in">test</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">clock_t</span> t2 = <span class="built_in">clock</span>();</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Total time = %d\n&quot;</span>, t2-t1);</span><br><span class="line">     <span class="built_in">test</span>();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>main()</code>函数中，没有执行完for循环中的代码之前，后面的<code>clock_t t2 = clock();</code>这行代码是不会执行的，如果和调用线程创建函数相比，它相当于先创建线程，并等待线程执行完，所以这种并行模式中在主线程里创建的线程并没有和主线程并行运行。</p>
<h2 id="OpenMP编程模型"><a href="#OpenMP编程模型" class="headerlink" title="OpenMP编程模型"></a>OpenMP编程模型</h2><h3 id="共享内存模型"><a href="#共享内存模型" class="headerlink" title="共享内存模型"></a>共享内存模型</h3><p>OpenMP是为多处理器或多核共享内存机器设计的。底层架构可以是共享内存 UMA 或 NUMA。</p>
<p>Uniform Memory Access 一致内存访问<br><img src="/img/22782486-39c6a9a1da904c10.gif" alt=""></p>
<p>Ununiform Memory Access 非一致内存访问<br><img src="/img/22782486-6e84877ae3d67aae.gif" alt=""></p>
<p>因为OpenMP是为共享内存并行编程而设计的，所以它在很大程度上局限于单节点并行性。通常，节点上处理元素(核心)的数量决定了可以实现多少并行性。</p>
<h3 id="在-HPC-中使用-OpenMP-的动机"><a href="#在-HPC-中使用-OpenMP-的动机" class="headerlink" title="在 HPC 中使用 OpenMP 的动机"></a>在 HPC 中使用 OpenMP 的动机</h3><ul>
<li>OpenMP本身的并行性仅限于单个节点。</li>
<li>对于高性能计算(HPC - High Performance Computing)应用程序，OpenMP 与 MPI 相结合以实现分布式内存并行。这通常被称为混合并行编程。<ul>
<li>OpenMP 用于每个节点上的计算密集型工作。</li>
<li>MPI 用于实现节点之间的通信和数据共享。</li>
</ul>
</li>
</ul>
<p>这使得并行性可以在集群的整个范围内实现Hybrid OpenMP-MPI Parallelism。</p>
<h3 id="基于线程的并行性"><a href="#基于线程的并行性" class="headerlink" title="基于线程的并行性"></a>基于线程的并行性</h3><p>OpenMP 程序仅通过使用线程来实现并行性。执行线程是操作系统可以调度的最小处理单元。一种可以自动运行的子程序，这个概念可能有助于解释什么是线程。线程存在于单个进程的资源中。没有这个进程，它们就不复存在。通常，线程的数量与机器处理器/核心的数量相匹配。但是，线程的实际使用取决于应用程序。</p>
<h3 id="显式并行性"><a href="#显式并行性" class="headerlink" title="显式并行性"></a>显式并行性</h3><p>OpenMP 是一个显式的(而不是自动的)编程模型，为程序员提供了对并行化的完全控制。并行化可以像获取串行程序和插入编译器指令一样简单…或者像插入子程序来设置多个并行级别、锁甚至嵌套锁一样复杂</p>
<h3 id="Fork-Join-模型"><a href="#Fork-Join-模型" class="headerlink" title="Fork - Join 模型"></a>Fork - Join 模型</h3><p>OpenMP 使用并行执行的 fork-join 模型：<br><img src="/img/22782486-dbd6ee9610fb13a5.gif" alt=""></p>
<ul>
<li>所有 OpenMP 程序都开始于一个主线程。主线程按顺序执行，直到遇到第一个并行区域结构。</li>
<li>FORK：主线程然后创建一组并行线程。</li>
<li>之后程序中由并行区域结构封装的语句在各个团队线程中并行执行。</li>
<li>JOIN：当团队线程完成并行区域结构中的语句时，它们将进行同步并终止，只留下主线程。</li>
</ul>
<p>并行区域的数量和组成它们的线程是任意的。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li>因为 OpenMP 是共享内存编程模型，所以在默认情况下，并行区域中的大多数数据都是共享的。</li>
<li>一个并行区域中的所有线程都可以同时访问共享数据。</li>
<li>OpenMP 为程序员提供了一种方法，可以在不需要默认共享范围的情况下显式地指定数据的“作用域”。</li>
</ul>
<h3 id="动态线程"><a href="#动态线程" class="headerlink" title="动态线程"></a>动态线程</h3><p>该 API 为运行时环境提供了动态更改线程数量的功能，这些线程用于执行并行区域。如有可能，旨在促进更有效地利用资源。实现可能支持这个特性，也可能不支持。</p>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><p>OpenMP 没有指定任何关于并行 I/O 的内容。如果多个线程试图从同一个文件进行写/读操作，这一点尤其重要。如果每个线程都对不同的文件执行 I/O，那么问题就不那么重要了。完全由程序员来确保在多线程程序的上下文中正确地执行 I/O。</p>
<h3 id="内存模型：经常刷新？"><a href="#内存模型：经常刷新？" class="headerlink" title="内存模型：经常刷新？"></a>内存模型：经常刷新？</h3><p>OpenMP 提供了线程内存的“宽松一致性”和“临时”视图(用他们的话说)。换句话说，线程可以“缓存”它们的数据，并且不需要始终与实际内存保持精确的一致性。当所有线程以相同的方式查看共享变量非常重要时，程序员负责确保所有线程根据需要刷新该变量。</p>
<h1 id="2-OpenMP编程"><a href="#2-OpenMP编程" class="headerlink" title="2. OpenMP编程"></a>2. OpenMP编程</h1><h2 id="2-1-OpenMP指令和库函数介绍"><a href="#2-1-OpenMP指令和库函数介绍" class="headerlink" title="2.1 OpenMP指令和库函数介绍"></a>2.1 OpenMP指令和库函数介绍</h2><p>下面来介绍OpenMP的基本指令和常用指令的用法，在C/C++中，OpenMP指令使用的格式为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp 指令 [子句[子句]…]</span><br></pre></td></tr></table></figure><br>前面提到的<code>parallel for</code>就是一条指令，有些书中也将OpenMP的“指令”叫做“编译指导语句”，后面的子句是可选的。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp parallel private(i, j)</span><br></pre></td></tr></table></figure></p>
<p><code>parallel</code>就是指令，<code>private</code>是子句。为叙述方便把包含#pragma和OpenMP指令的一行叫做语句，如上面那行叫parallel语句。</p>
<h2 id="2-2-OpenMP指令列表"><a href="#2-2-OpenMP指令列表" class="headerlink" title="2.2 OpenMP指令列表"></a>2.2 OpenMP指令列表</h2><p>这里我们先列举出OpenMP常用的指令和函数，并附上一些简单的说明。如果你看不懂，没关系，后面我们会对每个指令有详细的例子介绍。</p>
<ul>
<li><code>parallel</code>：用在一个代码段之前，表示这段代码将被多个线程并行执行</li>
<li><code>for</code>：用于for循环之前，将循环分配到多个线程中并行执行，必须保证每次循环之间无相关性。</li>
<li><code>parallel for</code>，<code>parallel</code>和<code>for</code>语句的结合，也是用在一个for循环之前，表示for循环的代码将被多个线程并行执行。</li>
<li><code>sections</code>，用在可能会被并行执行的代码段之前</li>
<li><code>parallel sections</code>，<code>parallel</code>和<code>sections</code>两个语句的结合</li>
<li><code>critical</code>，用在一段代码临界区之前</li>
<li><code>single</code>，用在一段只被单个线程执行的代码段之前，表示后面的代码段将被单线程执行。</li>
<li><code>flush</code>，用来保证线程的内存临时视图和实际内存保持一致，即各个线程看到的共享变量是一致的</li>
<li><code>barrier</code>，用于并行区内代码的线程同步，所有线程执行到barrier时要停止，直到所有线程都执行到barrier时才继续往下执行。</li>
<li><code>atomic</code>，用于指定一块内存区域被制动更新</li>
<li><code>master</code>，用于指定一段代码块由主线程执行</li>
<li><code>ordered</code>， 用于指定并行区域的循环按顺序执行</li>
<li><code>threadprivate</code>，用于指定一个变量是线程私有的</li>
<li><code>copyprivate</code>，配合single指令，将指定线程的专有变量广播到并行域内其他线程的同名变量中；</li>
<li><code>copyin n</code>，用来指定一个threadprivate类型的变量需要用主线程同名变量进行初始化；</li>
<li><code>default</code>，用来指定并行域内的变量的使用方式，缺省是shared。</li>
</ul>
<h2 id="2-3-OpenMP库函数"><a href="#2-3-OpenMP库函数" class="headerlink" title="2.3 OpenMP库函数"></a>2.3 OpenMP库函数</h2><p>OpenMP除上述指令外，还有一些库函数，OpenMP运行时库函数原本用以设置和获取执行环境相关的信息.其也包含一系列用以同步的API.要使用运行时函数库所包含的函数，应该在相应的源文件中包含OpenMP头文件omp.h.OpenMP的运行时库函数的使用类似于相应编程语言内部的函数调用.</p>
<p>由编译指导语句和运行时库函数可见，OpenMP同时结合了两种并行编程的方式，通过编译指导语句，可以将串行的程序逐步地改造成一个并行程序，达到增量更新程序的目的，从而减少程序编写人员的一定负担。同时，这样的方式也能将串行程序和并行程序保存在同一个源代码文件当中。OpenMP在运行的时候，需要运行函数库的支持，并会获取一些环境变量来控制运行的过程。环境变量是动态函数库中用来控制函数运行的一些参数.</p>
<p>OpenMP API 包括越来越多的运行时库函数。这些函数有多种用途，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>opm_set_num_threads</td>
<td>设置将在下一个并行区域中使用的线程数</td>
</tr>
<tr>
<td>opm_get_num_threads</td>
<td>返回当前在团队中执行并行区域的线程数，该区域是调用该线程的地方</td>
</tr>
<tr>
<td>opm_get_max_threads</td>
<td>返回可通过调用 opm_get_num_threads 函数返回的最大值</td>
</tr>
<tr>
<td>opm_get_thread_num</td>
<td>返回在团队中执行此调用的线程的线程号</td>
</tr>
<tr>
<td>opm_get_thread_limit</td>
<td>返回程序可用的 OpenMP 线程的最大数量</td>
</tr>
<tr>
<td>opm_get_num_procs</td>
<td>返回程序可用的处理器数量</td>
</tr>
<tr>
<td>opm_in_parallel</td>
<td>用于确定正在执行的代码段是否并行</td>
</tr>
<tr>
<td>opm_set_dynamic</td>
<td>启用或禁用(由运行时系统)可用于执行并行区域的线程数的动态调整</td>
</tr>
<tr>
<td>opm_get_dynamic</td>
<td>用于确定是否启用动态线程调整</td>
</tr>
<tr>
<td>opm_set_nested</td>
<td>用于启用或禁用嵌套并行性</td>
</tr>
<tr>
<td>opm_get_nested</td>
<td>用于确定是否启用嵌套并行性</td>
</tr>
<tr>
<td>opm_set_schedule</td>
<td>在 OpenMP 指令中将“runtime”用作调度类型时，设置循环调度策略</td>
</tr>
<tr>
<td>opm_get_schedule</td>
<td>当 OpenMP 指令中使用“runtime”作为调度类型时，返回循环调度策略</td>
</tr>
<tr>
<td>opm_set_max-active_levels</td>
<td>设置嵌套并行区域的最大数目</td>
</tr>
<tr>
<td>opm_get_max-active_levels</td>
<td>返回嵌套并行区域的最大数目</td>
</tr>
<tr>
<td>opm_get_level</td>
<td>返回嵌套并行区域的当前级别</td>
</tr>
<tr>
<td>opm_get_ancestor_thread_num</td>
<td>对于当前线程的给定嵌套级别，返回祖先线程的线程数</td>
</tr>
<tr>
<td>opm_get_team_size</td>
<td>对于当前线程的给定嵌套级别，返回线程团队的大小</td>
</tr>
<tr>
<td>opm_get_active_level</td>
<td>返回包含调用的任务的嵌套活动并行区域的数目</td>
</tr>
<tr>
<td>opm_in_final</td>
<td>如果程序在最后一个任务区域执行，则返回true；否则返回false</td>
</tr>
<tr>
<td>opm_init_lock</td>
<td>初始化与锁变量关联的锁</td>
</tr>
<tr>
<td>opm_destory_lock</td>
<td>将给定的锁变量与任何锁分离</td>
</tr>
<tr>
<td>opm_set_lock</td>
<td>获得锁的所有权</td>
</tr>
<tr>
<td>opm_unset_lock</td>
<td>释放锁</td>
</tr>
<tr>
<td>opm_test_lock</td>
<td>尝试设置锁，但如果锁不可用，则不会阻塞</td>
</tr>
<tr>
<td>opm_init_nest_lock</td>
<td>初始化与锁变量关联的嵌套锁</td>
</tr>
<tr>
<td>opm_destory_nest_lock</td>
<td>将给定的嵌套锁变量与任何锁分离</td>
</tr>
<tr>
<td>opm_set_nest_lock</td>
<td>获取嵌套锁的所有权</td>
</tr>
<tr>
<td>opm_unset_nest_lock</td>
<td>释放嵌套锁</td>
</tr>
<tr>
<td>opm_test_nest_lock</td>
<td>尝试设置嵌套锁，但如果锁不可用，则不会阻塞</td>
</tr>
<tr>
<td>opm_get_wtime</td>
<td>提供便携式挂钟定时程序</td>
</tr>
<tr>
<td>opm_get_wtick</td>
<td>返回一个双精度浮点值，该值等于连续时钟滴答之间的秒数</td>
</tr>
</tbody>
</table>
</div>
<p>对于C/C++，所有运行时库函数都是实际的子程序。对于Fortran来说，有些是函数，有些是子程序。例如:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">omp_get_num_threads</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure><br>注意，对于C/C++，通常需要包含<code>&lt;omp.h&gt;</code>头文件。</p>
<p>对于锁程序/函数：</p>
<ul>
<li>锁变量只能通过锁程序访问</li>
<li>对于Fortran，锁变量的类型应该是integer，并且要足够大，以便容纳一个地址。</li>
<li>对于C/C++，lock 变量的类型必须是<code>omp_lock_t</code>或<code>omp_nest_lock_t</code>，这取决于所使用的函数。</li>
</ul>
<p>实现注意事项：</p>
<ul>
<li>实现可能支持也可能不支持所有 OpenMP API 特性。例如，如果支持嵌套并行，那么它可能只是名义上的，因为嵌套并行区域可能只有一个线程。</li>
<li>有关详细信息，请参阅您的实现文档—或者亲自试验一下，如果您在文档中找不到它，请自己查找。</li>
</ul>
<h2 id="2-3-OpenMP子句"><a href="#2-3-OpenMP子句" class="headerlink" title="2.3 OpenMP子句"></a>2.3 OpenMP子句</h2><ul>
<li><code>private</code>：指定每个线程都有它自己的变量私有副本。</li>
<li><code>firstprivate</code>：指定每个线程都有它自己的变量私有副本，并且变量要被继承主线程中的初值。</li>
<li><code>lastprivate</code>：主要是用来指定将线程中的私有变量的值在并行处理结束后复制回主线程中的对应变量。</li>
<li><code>reduce</code>：用来指定一个或多个变量是私有的，并且在并行处理结束后这些变量要执行指定的运算。</li>
<li><code>nowait</code>：忽略指定中暗含的等待</li>
<li><code>num_threads</code>：指定线程的个数</li>
<li><code>schedule</code>：指定如何调度for循环迭代</li>
<li><code>shared</code>：指定一个或多个变量为多个线程间的共享变量</li>
<li><code>ordered</code>：用来指定for循环的执行要按顺序执行</li>
<li><code>copyprivate</code>：用于single指令中的指定变量为多个线程的共享变量</li>
<li><code>copyin</code>：用来指定一个threadprivate的变量的值要用主线程的值进行初始化。</li>
<li><code>default</code>：用来指定并行处理区域内的变量的使用方式，缺省是shared</li>
</ul>
<h2 id="2-4-环境变量"><a href="#2-4-环境变量" class="headerlink" title="2.4 环境变量"></a>2.4 环境变量</h2><p>OpenMP 提供了几个环境变量，用于在运行时控制并行代码的执行。这些环境变量可以用来控制这些事情：</p>
<ul>
<li>设置线程数</li>
<li>指定如何划分循环交互</li>
<li>将线程绑定到处理器</li>
<li>启用/禁用嵌套的并行性；设置嵌套并行度的最大级别</li>
<li>启用/禁用动态线程</li>
<li>设置线程堆栈大小</li>
<li>设置线程等待策略</li>
</ul>
<p>设置 OpenMP 环境变量的方法与设置任何其他环境变量的方法相同，并且取决于您使用的是哪种 shell。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">csh/tcsh: setenv OMP_NUM_THREADS 8</span><br><span class="line">sh/bash:  <span class="built_in">export</span> OMP_NUM_THREADS=8</span><br></pre></td></tr></table></figure></p>
<p>OpenMP 提供了以下环境变量来控制并行代码的执行。所有环境变量名都是大写的。分配给它们的值不区分大小写。</p>
<p><code>OMP_SCHEDULE</code>只适用于DO， PARALLEL DO (Fortran)和 for， parallel for (C/C++)指令，它们的 schedule 子句设置为运行时。此变量的值决定如何在处理器上调度循环的迭代。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_SCHEDULE <span class="string">&quot;guided, 4&quot;</span> </span><br><span class="line">setenv OMP_SCHEDULE <span class="string">&quot;dynamic&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><code>OMP_NUM_THREADS</code>设置执行期间使用的最大线程数。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_NUM_THREADS 8</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_DYNAMIC</code>启用或禁用可用于并行区域执行的线程数量的动态调整。有效值为 TRUE 或 FALSE。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_DYNAMIC TRUE</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_PROC_BIND</code>启用或禁用线程绑定到处理器。有效值为 TRUE 或 FALSE。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_PROC_BIND TRUE</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_NESTED</code>启用或禁用嵌套并行性。有效值为 TRUE 或 FALSE。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_NESTED TRUE</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_STACKSIZE</code>控制已创建(非主)线程的堆栈大小。例子:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_STACKSIZE 2000500B </span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot;3000 k &quot;</span> </span><br><span class="line">setenv OMP_STACKSIZE 10M </span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot; 10 M &quot;</span> </span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot;20 m &quot;</span> </span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot; 1G&quot;</span> </span><br><span class="line">setenv OMP_STACKSIZE 20000</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_WAIT_POLICY</code>为 OpenMP 实现提供有关等待线程的所需行为的提示。一个兼容的 OpenMP 实现可能遵守也可能不遵守环境变量的设置。有效值分为 ACTIVE 和 PASSIVE。ACTIVE 指定等待的线程大部分应该是活动的，即，在等待时消耗处理器周期。PASSIVE 指定等待的线程大部分应该是被动的，即，而不是在等待时消耗处理器周期。ACTIVE 和 PASSIVE 行为的细节是由实现定义的。例子:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_WAIT_POLICY ACTIVE </span><br><span class="line">setenv OMP_WAIT_POLICY active </span><br><span class="line">setenv OMP_WAIT_POLICY PASSIVE </span><br><span class="line">setenv OMP_WAIT_POLICY passive</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_MAX_ACTIVE_LEVELS</code>控制嵌套的活动并行区域的最大数目。该环境变量的值必须是非负整数。如果 OMP_MAX_ACTIVE_LEVELS 的请求值大于实现所能支持的嵌套活动并行级别的最大数量，或者该值不是一个非负整数，则该程序的行为是由实现定义的。例子:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_MAX_ACTIVE_LEVELS 2</span><br></pre></td></tr></table></figure></p>
<p><code>OMP_THREAD_LIMIT</code>设置用于整个 OpenMP 程序的 OpenMP 线程的数量。这个环境变量的值必须是正整数。如果 OMP_THREAD_LIMIT 的请求值大于实现所能支持的线程数，或者该值不是正整数，则程序的行为是由实现定义的。例子：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_THREAD_LIMIT 8</span><br></pre></td></tr></table></figure></p>
<h2 id="2-5-编译-OpenMP-程序"><a href="#2-5-编译-OpenMP-程序" class="headerlink" title="2.5 编译 OpenMP 程序"></a>2.5 编译 OpenMP 程序</h2><p>OpenMP 版本依赖的 GCC 版本</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>OpenMP 版本</th>
<th>GCC版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>OpenMP 5.0</td>
<td>&gt;= GCC 9.1</td>
</tr>
<tr>
<td>OpenMP 4.5</td>
<td>&gt;= GCC 6.1</td>
</tr>
<tr>
<td>OpenMP 4.0</td>
<td>&gt;= GCC 4.9.0</td>
</tr>
<tr>
<td>OpenMP 3.1</td>
<td>&gt;= GCC 4.7.0</td>
</tr>
<tr>
<td>OpenMP 3.0</td>
<td>&gt;= GCC 4.4.0</td>
</tr>
<tr>
<td>OpenMP 2.5</td>
<td>&gt;= GCC 4.2.0</td>
</tr>
</tbody>
</table>
</div>
<p>linux 下编译命令示例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ Test.cpp -o omptest -fopenmp</span><br></pre></td></tr></table></figure></p>
<h2 id="2-6-OpenMP-API-概述"><a href="#2-6-OpenMP-API-概述" class="headerlink" title="2.6 OpenMP API 概述"></a>2.6 OpenMP API 概述</h2><h3 id="三大构成"><a href="#三大构成" class="headerlink" title="三大构成"></a>三大构成</h3><p>OpenMP 3.1 API 由三个不同的组件组成：</p>
<ul>
<li>编译器指令</li>
<li>运行时库函数</li>
<li>环境变量</li>
</ul>
<p>后来的一些 API 包含了这三个相同的组件，但是增加了指令、运行时库函数和环境变量的数量。应用程序开发人员决定如何使用这些组件。在最简单的情况下，只需要其中的几个。实现对所有 API 组件的支持各不相同。例如，一个实现可能声明它支持嵌套并行，但是 API 清楚地表明它可能被限制在一个线程上——主线程。不完全符合开发人员的期望？</p>
<h3 id="编译器指令"><a href="#编译器指令" class="headerlink" title="编译器指令"></a>编译器指令</h3><p>编译器指令在源代码中以注释的形式出现，编译器会忽略它们，除非您另外告诉它们 — 通常通过指定适当的编译标志，如后面的编译部分所述。OpenMP 编译器指令用于各种目的：</p>
<ul>
<li>生成一个并行区域</li>
<li>在线程之间划分代码块</li>
<li>在线程之间分配循环迭代</li>
<li>序列化代码段</li>
<li>线程之间的工作同步</li>
</ul>
<p>编译器指令有以下语法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel directive-name [clause, ...] </span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel default(shared) private(beta, pi)</span></span><br></pre></td></tr></table></figure><br>后面将详细讨论编译器指令。</p>
<h3 id="运行时库函数-Run-time-Library-Routines"><a href="#运行时库函数-Run-time-Library-Routines" class="headerlink" title="运行时库函数 Run-time Library Routines:"></a>运行时库函数 Run-time Library Routines:</h3><p>OpenMP API 包括越来越多的运行时库函数。这些程序用于各种目的：</p>
<ul>
<li>设置和查询线程的数量</li>
<li>查询线程的唯一标识符(线程ID)、父线程的标识符、线程团队大小</li>
<li>设置和查询动态线程特性</li>
<li>查询是否在一个并行区域，以及在什么级别</li>
<li>设置和查询嵌套并行性</li>
<li>设置、初始化和终止锁以及嵌套锁</li>
<li>查询 wall clock time 和分辨率</li>
</ul>
<p>对于 C/C++，所有运行时库函数都是实际的子程序。对于Fortran来说，有些是函数，有些是子程序。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">omp_get_num_threads</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>注意，对于C/C++，通常需要包含<code>&lt;omp.h &gt;</code>头文件。</p>
<p>运行时库函数将在运行时库函数一节中作为概述进行简要讨论，更多细节将在附录A中讨论。</p>
<h2 id="2-7-OpenMP-指令"><a href="#2-7-OpenMP-指令" class="headerlink" title="2.7 OpenMP 指令"></a>2.7 OpenMP 指令</h2><h3 id="C-C-指令格式"><a href="#C-C-指令格式" class="headerlink" title="C/C++ 指令格式"></a>C/C++ 指令格式</h3><p>格式<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp	directive-name	[clause, ...]	newline</span><br></pre></td></tr></table></figure></p>
<p>所有 OpenMP C/C++ 指令都需要。    一个有效的 OpenMP 指令。必须出现在 pragma 之后和任何子句之前。    可选的。除非另有限制，子句可以按任何顺序重复。    必需的。在此指令所包含的结构化块之前。</p>
<p>一般规则</p>
<ul>
<li>区分大小写。</li>
<li>指令遵循 C/C++ 编译器指令标准的约定。</li>
<li>每个指令只能指定一个指令名。</li>
<li>每个指令最多应用于一个后续语句，该语句必须是一个结构化块。</li>
<li>长指令行可以通过在指令行的末尾使用反斜杠(“\”)来转义换行符，从而在后续的行中“继续”。</li>
</ul>
<h3 id="指令范围"><a href="#指令范围" class="headerlink" title="指令范围"></a>指令范围</h3><h4 id="静态-词法-范围"><a href="#静态-词法-范围" class="headerlink" title="静态(词法)范围"></a>静态(词法)范围</h4><ul>
<li>在指令后面的结构化块的开始和结束之间以文本形式封装的代码。</li>
<li>指令的静态范围不跨越多个程序或代码文件。</li>
</ul>
<h4 id="孤立的指令"><a href="#孤立的指令" class="headerlink" title="孤立的指令"></a>孤立的指令</h4><p>一个 OpenMP 指令，独立于另一个封闭指令，称为孤立型指令。它存在于另一个指令的静态(词法)范围之外。将跨越程序和可能的代码文件。</p>
<h4 id="动态范围"><a href="#动态范围" class="headerlink" title="动态范围"></a>动态范围</h4><p>指令的动态范围包括静态(词法)范围和孤立指令的范围。</p>
<h4 id="为什么这很重要？"><a href="#为什么这很重要？" class="headerlink" title="为什么这很重要？"></a>为什么这很重要？</h4><p>OpenMP 为指令如何相互关联(绑定)和嵌套指定了许多范围规则。如果忽略 OpenMP 绑定和嵌套规则，可能会导致非法或不正确的程序。有关详细信息，请参阅指令绑定和嵌套规则。</p>
<h3 id="并行区域结构"><a href="#并行区域结构" class="headerlink" title="并行区域结构"></a>并行区域结构</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>并行区域是由多个线程执行的代码块。这是基本的 OpenMP 并行结构。</p>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel [clause ...]  newline </span></span><br><span class="line">                     <span class="keyword">if</span> (scalar_expression) </span><br><span class="line">                     private (<span class="built_in">list</span>) </span><br><span class="line">                     shared (<span class="built_in">list</span>) </span><br><span class="line">                     <span class="keyword">default</span> (shared | none) </span><br><span class="line">                     firstprivate (<span class="built_in">list</span>) </span><br><span class="line">                     reduction (operator: <span class="built_in">list</span>) </span><br><span class="line">                     copyin (<span class="built_in">list</span>) </span><br><span class="line">                     num_threads (integer-expression)</span><br><span class="line"></span><br><span class="line">   structured_block</span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>当一个线程执行到一个并行指令时，它创建一个线程组并成为该线程组的主线程。主线程是该团队的成员，在该团队中线程号为0。</li>
<li>从这个并行区域开始，代码被复制，所有线程都将执行该代码。</li>
<li>在并行区域的末端有一个隐含的屏障。只有主线程在此之后继续执行。</li>
<li>如果任何线程在一个并行区域内终止，则团队中的所有线程都将终止，并且在此之前所做的工作都是未定义的。</li>
</ul>
<h4 id="有多少线程"><a href="#有多少线程" class="headerlink" title="有多少线程"></a>有多少线程</h4><p>并行区域内的线程数由以下因素决定，按优先级排序：</p>
<ul>
<li><code>IF</code>子句的计算</li>
<li><code>NUM_THREADS</code>子句的设置</li>
<li>使用<code>omp_set_num_threads()</code>库函数</li>
<li>设置<code>OMP_NUM_THREADS</code>环境变量</li>
<li>实现缺省值 — 通常是一个节点上的 cpu 数量，尽管它可以是动态的(参见下一小节)</li>
<li>线程的编号从0(主线程)到N-1。</li>
</ul>
<h4 id="动态线程-1"><a href="#动态线程-1" class="headerlink" title="动态线程"></a>动态线程</h4><p>使用<code>omp_get_dynamic()</code>库函数来确定是否启用了动态线程。如果支持的话，启用动态线程的两种方法是：</p>
<ul>
<li><code>omp_set_dynamic()</code>库函数</li>
<li>将<code>OMP_NESTED</code>环境变量设置为 TRUE</li>
</ul>
<p>如果不支持，则在另一个并行区域内嵌套一个并行区域，从而在默认情况下创建一个由单个线程组成的新团队。</p>
<h4 id="子句"><a href="#子句" class="headerlink" title="子句"></a>子句</h4><p>IF 子句：如果存在，它的值必须为非零，以便创建一个线程组。否则，该区域将由主线程串行执行。</p>
<h4 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h4><ul>
<li>并行区域必须是不跨越多个程序或代码文件的结构化块。</li>
<li>从一个并行区域转入或转出是非法的。</li>
<li>只允许一个 IF 子句。</li>
<li>只允许一个 NUM_THREADS 子句。</li>
<li>程序不能依赖于子句的顺序。</li>
</ul>
<h4 id="并行区域例子"><a href="#并行区域例子" class="headerlink" title="并行区域例子"></a>并行区域例子</h4><p>简单的“Hello World”程序。每个线程执行包含在并行区域中的所有代码。OpenMP 库函数用于获取线程标识符和线程总数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> nthreads, tid;</span><br><span class="line">    <span class="comment">/* Fork a team of threads with each thread having a private tid variable */</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(tid)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Obtain and print thread id */</span></span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World from thread = %d\n&quot;</span>, tid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Only master thread does this */</span></span><br><span class="line">        <span class="keyword">if</span> (tid == <span class="number">0</span>) &#123;</span><br><span class="line">            nthreads = omp_get_num_threads();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Number of threads = %d\n&quot;</span>, nthreads);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/* All threads join master thread and terminate */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="工作共享结构"><a href="#工作共享结构" class="headerlink" title="工作共享结构"></a>工作共享结构</h4><p>工作共享结构将封闭代码区域的执行划分给遇到它的团队成员。工作共享结构不会启动新线程。在进入工作共享结构时没有隐含的屏障，但是在工作共享结构的末尾有一个隐含的屏障。</p>
<p>工作共享结构的类型：</p>
<ul>
<li>DO / for - 整个团队的循环迭代。表示一种“数据并行性”。</li>
<li>SECTIONS - 把工作分成单独的、不连续的部分。每个部分由一个线程执行。可以用来实现一种“函数并行性”。</li>
<li>SINGLE - 序列化一段代码。</li>
</ul>
<p><img src="/img/20211202115649.png" alt="">    </p>
<h4 id="限制条件-1"><a href="#限制条件-1" class="headerlink" title="限制条件"></a>限制条件</h4><p>为了使指令能够并行执行，必须将工作共享结构动态地封装在一个并行区域中。团队的所有成员都必须遇到工作共享结构，或者根本不遇到。团队的所有成员必须以相同的顺序遇到连续的工作共享结构。</p>
<h4 id="DO-for-指令"><a href="#DO-for-指令" class="headerlink" title="DO / for 指令"></a>DO / for 指令</h4><p>DO / for 指令指定紧随其后的循环迭代必须由团队并行执行。这假定已经启动了并行区域，否则它将在单个处理器上串行执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for [clause ...]  newline </span></span><br><span class="line">                schedule (type [,chunk]) </span><br><span class="line">                ordered</span><br><span class="line">                <span class="title function_">private</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line">                <span class="title function_">firstprivate</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line">                <span class="title function_">lastprivate</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line">                <span class="title function_">shared</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line">                <span class="title function_">reduction</span> <span class="params">(operator: <span class="built_in">list</span>)</span> </span><br><span class="line">                <span class="title function_">collapse</span> <span class="params">(n)</span> </span><br><span class="line">                nowait </span><br><span class="line"></span><br><span class="line">   for_loop</span><br></pre></td></tr></table></figure>
<ul>
<li><code>schedule</code>：描述循环迭代如何在团队中的线程之间进行分配。默认的调度是依赖于实现的。有关如何使一种调度比其他调度更优的讨论，请参见<a target="_blank" rel="noopener" href="http://openmp.org/forum/viewtopic.php?f=3&amp;t=83">http://openmp.org/forum/viewtopic.php?f=3&amp;t=83</a> 。<ul>
<li>静态(STATIC) - 循环迭代被分成小块，然后静态地分配给线程。如果没有指定 chunk，则迭代是均匀地(如果可能)在线程之间连续地划分。</li>
<li>动态(DYNAMIC) - 循环迭代分成小块，并在线程之间动态调度；当一个线程完成一个块时，它被动态地分配给另一个块。默认块大小为1。</li>
<li>引导(GUIDED) - 当线程请求迭代时，迭代被动态地分配给块中的线程，直到没有剩余的块需要分配为止。与 DYNAMIC 类似，只是每次将一个工作包分配给一个线程时，块的大小就会减小。<ul>
<li>初始块的大小与 number_of_iteration / number_of_threads 成比例</li>
<li>后续块与number_of_iterations_remaining / number_of_threads 成比例</li>
<li>chunk 参数定义最小块大小。默认块大小为1。</li>
</ul>
</li>
<li>运行时(RUNTIME) - 环境变量 OMP_SCHEDULE 将调度决策延迟到运行时。为这个子句指定块大小是非法的。</li>
<li>自动(AUTO) - 调度决策被委托给编译器或运行时系统。</li>
</ul>
</li>
<li><code>nowait</code>： 如果指定，那么线程在并行循环结束时不会同步。</li>
<li><code>ordered</code>：指定循环的迭代必须像在串行程序中一样执行。</li>
<li><code>collapse</code>：指定在一个嵌套循环中有多少个循环应该折叠成一个大的迭代空间，并根据 schedule 子句进行划分。折叠迭代空间中的迭代的顺序是确定的，就好像它们是按顺序执行的一样。可能会提高性能。</li>
<li>其他子句稍后将在数据范围属性子句一节中详细描述。</li>
</ul>
<h5 id="限制条件-2"><a href="#限制条件-2" class="headerlink" title="限制条件"></a>限制条件</h5><ul>
<li>DO 循环不能是 DO WHILE 循环，也不能是没有循环控制的循环。此外，循环迭代变量必须是整数，并且对于所有线程，循环控制参数必须相同。</li>
<li>程序的正确性不能依赖于哪个线程执行特定的迭代。</li>
<li>在与 DO / for 指令关联的循环中跳转（转到）是非法的。</li>
<li>块大小必须指定为循环不变的整数表达式，因为在不同线程求值期间不存在同步。</li>
<li>ORDERED、COLLAPSE、SCHEDULE 子句可以出现一次。</li>
<li>有关其他限制，请参阅 OpenMP 规范文档。</li>
</ul>
<h5 id="DO-for-指令示例"><a href="#DO-for-指令示例" class="headerlink" title="DO / for 指令示例"></a>DO / for 指令示例</h5><p>简单的 vector 相加程序，数组 A、B、C 和变量 N 将由所有线程共享。变量 i 对每个线程都是私有的；每个线程都有自己唯一的副本。循环迭代将在 CHUNK 大小的块中动态分布。线程在完成各自的工作后将不会同步 (NOWAIT)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, chunk;</span><br><span class="line">    <span class="type">float</span> a[N], b[N], c[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some initializations */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        a[i] = b[i] = i * <span class="number">1.0</span>;</span><br><span class="line">    chunk = CHUNKSIZE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(a,b,c,chunk) private(i)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for schedule(dynamic,chunk) nowait</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            c[i] = a[i] + b[i];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">/* end of parallel region */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="sections-指令"><a href="#sections-指令" class="headerlink" title="sections 指令"></a>sections 指令</h4><h5 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h5><p>sections 指令是一个非迭代的工作共享结构。它指定所包含的代码段将被分配给团队中的各个线程。</p>
<p>独立的 section 指令嵌套在 sections 指令中。每个部分由团队中的一个线程执行一次。不同的部分可以由不同的线程执行。如果一个线程执行多个部分的速度足够快，并且实现允许这样做，那么它就可以执行多个部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp sections [clause ...]  newline </span></span><br><span class="line">                     private (<span class="built_in">list</span>) </span><br><span class="line">                     firstprivate (<span class="built_in">list</span>) </span><br><span class="line">                     lastprivate (<span class="built_in">list</span>) </span><br><span class="line">                     reduction (operator: <span class="built_in">list</span>) </span><br><span class="line">                     nowait</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> omp section   newline </span></span><br><span class="line">     structured_block</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> omp section   newline </span></span><br><span class="line">     structured_block</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="子句-1"><a href="#子句-1" class="headerlink" title="子句"></a>子句</h5><p>除非使用了 NOWAIT/nowait 子句，否则在 sections 指令的末尾有一个隐含的屏障（译者注：an implied barrier 意思应该是线程会相互等待）。稍后将在数据范围属性子句一节中详细描述子句。</p>
<h5 id="限制条件-3"><a href="#限制条件-3" class="headerlink" title="限制条件"></a>限制条件</h5><p>跳转（转到）或跳出 section 代码块是非法的。section 指令必须出现在一个封闭的 sections 指令的词法范围内(没有独立部分)。</p>
<h5 id="sections-指令示例"><a href="#sections-指令示例" class="headerlink" title="sections 指令示例"></a>sections 指令示例</h5><p>下面一个简单的程序演示不同的工作块将由不同的线程完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> a[N], b[N], c[N], d[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some initializations */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        a[i] = i * <span class="number">1.5</span>;</span><br><span class="line">        b[i] = i + <span class="number">22.35</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(a,b,c,d) private(i)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp sections nowait</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">                c[i] = a[i] + b[i];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">                d[i] = a[i] * b[i];</span><br><span class="line">        &#125; <span class="comment">/* end of sections */</span></span><br><span class="line">    &#125; <span class="comment">/* end of parallel region */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="single-指令"><a href="#single-指令" class="headerlink" title="single 指令"></a>single 指令</h4><h5 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h5><p>single 指令指定所包含的代码仅由团队中的一个线程执行。在处理非线程安全的代码段(如 I/O )时可能很有用</p>
<h5 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single [clause ...]  newline </span></span><br><span class="line">                   private (<span class="built_in">list</span>) </span><br><span class="line">                   firstprivate (<span class="built_in">list</span>) </span><br><span class="line">                   nowait</span><br><span class="line"></span><br><span class="line">     structured_block</span><br></pre></td></tr></table></figure>
<h5 id="子句-2"><a href="#子句-2" class="headerlink" title="子句"></a>子句</h5><p>除非指定了 nowait 子句，否则团队中不执行 single 指令的线程将在代码块的末尾等待。稍后将在数据范围属性子句一节中详细描述子句。</p>
<h5 id="限制条件-4"><a href="#限制条件-4" class="headerlink" title="限制条件"></a>限制条件</h5><p>进入或跳出一个 single 代码块是非法的。</p>
<h3 id="合并并行工作共享结构"><a href="#合并并行工作共享结构" class="headerlink" title="合并并行工作共享结构"></a>合并并行工作共享结构</h3><p>OpenMP 提供了三个简单的指令：</p>
<ul>
<li>parallel for</li>
<li>parallel sections</li>
<li>PARALLEL WORKSHARE (fortran only)</li>
</ul>
<p>在大多数情况下，这些指令的行为与单独的并行指令完全相同，并行指令后面紧跟着一个单独的工作共享指令。大多数适用于这两个指令的规则、条款和限制都是有效的。有关详细信息，请参阅 OpenMP API。</p>
<p>下面显示了一个使用 parallel for 组合指令的示例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N       1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE   100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, chunk;</span><br><span class="line">    <span class="type">float</span> a[N], b[N], c[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some initializations */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        a[i] = b[i] = i * <span class="number">1.0</span>;</span><br><span class="line">    chunk = CHUNKSIZE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for shared(a,b,c,chunk) private(i) schedule(static,chunk)</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        c[i] = a[i] + b[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="任务结构"><a href="#任务结构" class="headerlink" title="任务结构"></a>任务结构</h3><h4 id="目的-3"><a href="#目的-3" class="headerlink" title="目的"></a>目的</h4><p>任务结构定义了一个显式任务，该任务可以由遇到的线程执行，也可以由团队中的任何其他线程延迟执行。任务的数据环境由数据共享属性子句确定。任务执行取决于任务调度 — 详细信息请参阅 OpenMP 3.1 规范文档</p>
<h4 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp task [clause ...]  newline </span></span><br><span class="line">                 <span class="keyword">if</span> (scalar expression) </span><br><span class="line">                 final (scalar expression) </span><br><span class="line">                 untied</span><br><span class="line">                 <span class="title function_">default</span> <span class="params">(shared | none)</span></span><br><span class="line">                 mergeable</span><br><span class="line">                 <span class="title function_">private</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line">                 <span class="title function_">firstprivate</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line">                 <span class="title function_">shared</span> <span class="params">(<span class="built_in">list</span>)</span> </span><br><span class="line"></span><br><span class="line">    structured_block</span><br></pre></td></tr></table></figure>
<h3 id="同步结构"><a href="#同步结构" class="headerlink" title="同步结构"></a>同步结构</h3><p>考虑一个简单的例子，两个线程都试图同时更新变量x：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">THREAD1	</span><br><span class="line"><span class="title function_">update</span><span class="params">(x)</span></span><br><span class="line">&#123;</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">update(x)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">THREAD2</span><br><span class="line"><span class="title function_">update</span><span class="params">(x)</span></span><br><span class="line">&#123;</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">update(x)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>一种可能的执行顺序：</p>
<ul>
<li>线程1初始化 x 为0并调用</li>
<li>线程1将 x 加1，x 现在等于1</li>
<li>线程2初始化 x 为0并调用 update(x)，x现在等于0</li>
<li>线程1输出 x，它等于0而不是1</li>
<li>线程2将 x 加1，x 现在等于1</li>
<li>线程2打印 x 为1</li>
</ul>
<p>为了避免这种情况，必须在两个线程之间同步 x 的更新，以确保产生正确的结果。OpenMP 提供了各种同步结构，这些构造控制每个线程相对于其他团队线程的执行方式。</p>
<h4 id="master-指令"><a href="#master-指令" class="headerlink" title="master 指令"></a>master 指令</h4><h5 id="目的-4"><a href="#目的-4" class="headerlink" title="目的"></a>目的</h5><p>master 指令指定了一个区域，该区域只由团队的主线程执行。团队中的所有其他线程都将跳过这部分代码。这个指令没有隐含的障碍( implied barrier )。</p>
<h5 id="格式-3"><a href="#格式-3" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp master  newline</span></span><br><span class="line">    structured_block</span><br></pre></td></tr></table></figure>
<h5 id="限制条件-5"><a href="#限制条件-5" class="headerlink" title="限制条件"></a>限制条件</h5><p>进入或跳出一个 master 代码块是非法的。</p>
<h4 id="critical-指令"><a href="#critical-指令" class="headerlink" title="critical 指令"></a>critical 指令</h4><h5 id="目的-5"><a href="#目的-5" class="headerlink" title="目的"></a>目的</h5><p>critical 指令指定了一个只能由一个线程执行的代码区域。</p>
<h5 id="格式-4"><a href="#格式-4" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical [ name ]  newline</span></span><br><span class="line">    structured_block</span><br></pre></td></tr></table></figure>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>如果一个线程当前在一个 critical 区域内执行，而另一个线程到达该 critical 区域并试图执行它，那么它将阻塞，直到第一个线程退出该 critical 区域。</li>
<li>可选的名称使多个不同的临界区域存在：<ul>
<li>名称充当全局标识符。具有相同名称的不同临界区被视为相同的区域。</li>
<li>所有未命名的临界段均视为同一段。</li>
</ul>
</li>
</ul>
<h5 id="限制条件-6"><a href="#限制条件-6" class="headerlink" title="限制条件"></a>限制条件</h5><p>进入或跳出一个 critical 代码块是非法的。</p>
<p>Fortran only: The names of critical constructs are global entities of the program. If a name conflicts with any other entity, the behavior of the program is unspecified.</p>
<h5 id="critical-结构示例"><a href="#critical-结构示例" class="headerlink" title="critical 结构示例"></a>critical 结构示例</h5><p>团队中的所有线程都将尝试并行执行，但是由于 x 的增加由 critical 结构包围，在任何时候只有一个线程能够读/增量/写 x。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(x)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">        x = x + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="comment">/* end of parallel region */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="barrier-指令"><a href="#barrier-指令" class="headerlink" title="barrier 指令"></a>barrier 指令</h4><h5 id="目的-6"><a href="#目的-6" class="headerlink" title="目的"></a>目的</h5><p>barrier 指令同步团队中的所有线程。当到达 barrier 指令时，一个线程将在该点等待，直到所有其他线程都到达了 barrier 指令。然后，所有线程继续并行执行 barrier 之后的代码。</p>
<h5 id="格式-5"><a href="#格式-5" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp barrier  newline</span></span><br></pre></td></tr></table></figure>
<p>f</p>
<h5 id="限制条件-7"><a href="#限制条件-7" class="headerlink" title="限制条件"></a>限制条件</h5><p>团队中的所有线程(或没有线程)都必须执行 barrier 区域。对于团队中的每个线程，遇到的 work-sharing 区域和 barrier 区域的顺序必须是相同的。</p>
<h4 id="taskwait-指令"><a href="#taskwait-指令" class="headerlink" title="taskwait 指令"></a>taskwait 指令</h4><h5 id="目的-7"><a href="#目的-7" class="headerlink" title="目的"></a>目的</h5><p>taskwait 结构指定自当前任务开始以来生成的子任务完成时的等待时间。</p>
<h5 id="格式-6"><a href="#格式-6" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp taskwait  newline</span></span><br></pre></td></tr></table></figure>
<h5 id="限制条件-8"><a href="#限制条件-8" class="headerlink" title="限制条件"></a>限制条件</h5><p>因为 taskwait 结构是一个独立的指令，所以它在程序中的位置有一些限制。taskwait 指令只能放置在允许使用基本语言语句的地方。taskwait 指令不能代替 if、while、do、switch 或 label 后面的语句。有关详细信息，请参阅 OpenMP 3.1 规范文档。</p>
<h4 id="atomic-指令"><a href="#atomic-指令" class="headerlink" title="atomic 指令"></a>atomic 指令</h4><h5 id="目的-8"><a href="#目的-8" class="headerlink" title="目的"></a>目的</h5><p>atomic 结构确保以原子方式访问特定的存储位置，而不是将其暴露给多个线程同时读写，这些线程可能会导致不确定的值。本质上，这个指令提供了一个最小临界( mini-CRITICAL )区域。</p>
<h5 id="格式-7"><a href="#格式-7" class="headerlink" title="格式"></a>格式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp atomic  [ read | write | update | capture ] newline</span><br><span class="line">   statement_expression</span><br></pre></td></tr></table></figure>
<h5 id="限制条件-9"><a href="#限制条件-9" class="headerlink" title="限制条件"></a>限制条件</h5><p>该指令仅适用于紧接其后的单个语句。原子语句必须遵循特定的语法。查看最新的OpenMP规范。</p>
<h4 id="flush-指令"><a href="#flush-指令" class="headerlink" title="flush 指令"></a>flush 指令</h4><h5 id="目的-9"><a href="#目的-9" class="headerlink" title="目的"></a>目的</h5><p>flush 指令标识了一个同步点，在这个点上，内存数据必须一致。这时，线程可见的变量被写回内存。请参阅最新的 OpenMP 规范以获取详细信息。</p>
<h5 id="格式-8"><a href="#格式-8" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp flush (list)  newline</span></span><br></pre></td></tr></table></figure>
<h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><p>可选 list 参数包含一个将被刷新的已命名变量列表，以避免刷新所有变量。对于列表中的指针，请注意指针本身被刷新，而不是它指向的对象。实现必须确保线程可见变量的任何修改在此之后对所有线程都是可见的，例如编译器必须将值从寄存器恢复到内存，硬件可能需要刷新写缓冲区，等等。对于下面的指令，将使用 flush 指令。如果存在 nowait 子句，则该指令无效。</p>
<ul>
<li>barrier</li>
<li>parallel - 进入和退出</li>
<li>critical - 进入和退出</li>
<li>ordered - 进入和退出</li>
<li>for - 退出</li>
<li>sections - 退出</li>
<li>single - 退出</li>
</ul>
<h4 id="ordered-指令"><a href="#ordered-指令" class="headerlink" title="ordered 指令"></a>ordered 指令</h4><h5 id="目的-10"><a href="#目的-10" class="headerlink" title="目的"></a>目的</h5><p>ordered 指令指定封闭的循环迭代将以串行处理器上执行顺序执行。如果之前的迭代还没有完成，线程在执行它们的迭代块之前需要等待。在带有 ordered 子句的 for 循环中使用。ordered 指令提供了一种“微调”的方法，其中在循环中应用了排序。否则，它不是必需的。</p>
<h5 id="格式-9"><a href="#格式-9" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for ordered [clauses...]</span></span><br><span class="line">   (loop region)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp ordered  newline</span></span><br><span class="line">   structured_block</span><br><span class="line">   (endo of loop region)</span><br></pre></td></tr></table></figure>
<h5 id="限制条件-10"><a href="#限制条件-10" class="headerlink" title="限制条件"></a>限制条件</h5><ul>
<li>一个 ordered 指令只能在以下指令的动态范围内出现：<ul>
<li>for 或者 parallel for (C/C++)。</li>
</ul>
</li>
<li>在一个有序的区段中，任何时候都只允许一个线程。</li>
<li>进入或跳出一个 ordered 代码块是非法的。</li>
<li>一个循环的迭代不能多次执行同一个有序指令，也不能一次执行多个有序指令。</li>
<li>包含有序指令的循环必须是带有 ordered 子句的循环。</li>
</ul>
<h3 id="threadprivate-指令"><a href="#threadprivate-指令" class="headerlink" title="threadprivate 指令"></a>threadprivate 指令</h3><h4 id="目的-11"><a href="#目的-11" class="headerlink" title="目的"></a>目的</h4><p>threadprivate 指令指定复制变量，每个线程都有自己的副本。</p>
<p>可用于通过执行多个并行区域将全局文件作用域变量(C/C++/Fortran)或公共块(Fortran)局部化并持久化到一个线程。</p>
<h4 id="格式-10"><a href="#格式-10" class="headerlink" title="格式"></a>格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate (list)</span></span><br></pre></td></tr></table></figure>
<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>指令必须出现在列出的变量/公共块的声明之后。每个线程都有自己的变量/公共块的副本，所以一个线程写的数据对其他线程是不可见的。</li>
<li>在第一次进入一个并行区域时，应该假设 threadprivate 变量和公共块中的数据是未定义的，除非在并行指令中指定了 copyin 子句。</li>
<li>threadprivate 变量不同于 private 变量(稍后讨论)，因为它们能够在代码的不同并行区域之间持久存在。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a, b, i, tid;</span><br><span class="line"><span class="type">float</span> x;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(a, x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* 显式关闭动态线程 Explicitly turn off dynamic threads */</span></span><br><span class="line">    omp_set_dynamic(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1st Parallel Region:\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(b,tid)</span></span><br><span class="line">    &#123;</span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        a = tid;</span><br><span class="line">        b = tid;</span><br><span class="line">        x = <span class="number">1.1</span> * tid + <span class="number">1.0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d:   a,b,x= %d %d %f\n&quot;</span>, tid, a, b, x);</span><br><span class="line">    &#125; <span class="comment">/* end of parallel region */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Master thread doing serial work here\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;************************************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2nd Parallel Region:\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(tid)</span></span><br><span class="line">    &#123;</span><br><span class="line">        tid = omp_get_thread_num();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d:   a,b,x= %d %d %f\n&quot;</span>, tid, a, b, x);</span><br><span class="line">    &#125; <span class="comment">/* end of parallel region */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1st Parallel Region:</span><br><span class="line">Thread 4:   a,b,x= 4 4 5.400000</span><br><span class="line">Thread 7:   a,b,x= 7 7 8.700000</span><br><span class="line">Thread 2:   a,b,x= 2 2 3.200000</span><br><span class="line">Thread 3:   a,b,x= 3 3 4.300000</span><br><span class="line">Thread 6:   a,b,x= 6 6 7.600000</span><br><span class="line">Thread 1:   a,b,x= 1 1 2.100000</span><br><span class="line">Thread 5:   a,b,x= 5 5 6.500000</span><br><span class="line">Thread 0:   a,b,x= 0 0 1.000000</span><br><span class="line">************************************</span><br><span class="line">Master thread doing serial work here</span><br><span class="line">************************************</span><br><span class="line">2nd Parallel Region:</span><br><span class="line">Thread 1:   a,b,x= 1 0 2.100000</span><br><span class="line">Thread 6:   a,b,x= 6 0 7.600000</span><br><span class="line">Thread 4:   a,b,x= 4 0 5.400000</span><br><span class="line">Thread 5:   a,b,x= 5 0 6.500000</span><br><span class="line">Thread 2:   a,b,x= 2 0 3.200000</span><br><span class="line">Thread 7:   a,b,x= 7 0 8.700000</span><br><span class="line">Thread 0:   a,b,x= 0 0 1.000000</span><br><span class="line">Thread 3:   a,b,x= 3 0 4.300000</span><br></pre></td></tr></table></figure></p>
<h4 id="限制条件-11"><a href="#限制条件-11" class="headerlink" title="限制条件"></a>限制条件</h4><p>只有在动态线程机制“关闭”并且不同并行区域中的线程数量保持不变的情况下，threadprivate 对象中的数据才能保证持久。动态线程的默认设置是未定义的。</p>
<h3 id="数据范围属性子句"><a href="#数据范围属性子句" class="headerlink" title="数据范围属性子句"></a>数据范围属性子句</h3><p>也称为数据共享属性子句。</p>
<p>OpenMP 编程的一个重要考虑是理解和使用数据作用域。因为 OpenMP 是基于共享内存编程模型的，所以大多数变量在默认情况下是共享的。</p>
<p>全局变量包括：</p>
<ul>
<li>Fortran: COMMON blocks, SAVE variables, MODULE variables</li>
<li>文件作用域变量，static</li>
</ul>
<p>私有变量包括：</p>
<ul>
<li>循环索引变量</li>
<li>从并行区域调用的子程序中的堆栈变量</li>
<li>Fortran: Automatic variables within a statement block</li>
</ul>
<p>OpenMP 数据范围属性子句用于显式定义变量的范围。它们包括：</p>
<ul>
<li>private</li>
<li>firstprivate</li>
<li>lastprivate</li>
<li>shared</li>
<li>default</li>
<li>reduction</li>
<li>copyin</li>
</ul>
<p>数据范围属性子句与几个指令（parallel、DO/for 和 sections）一起使用，以控制所包含变量的范围。这些结构提供了在并行结构执行期间控制数据环境的能力。它们定义了如何将程序的串行部分中的哪些数据变量传输到程序的并行区域(以及向后传输)。它们定义哪些变量将对并行区域中的所有线程可见，哪些变量以私有形式分配给所有线程。数据范围属性子句仅在其词法/静态范围内有效。</p>
<h4 id="private-子句"><a href="#private-子句" class="headerlink" title="private 子句"></a>private 子句</h4><h5 id="目的-12"><a href="#目的-12" class="headerlink" title="目的"></a>目的</h5><p>private 子句将在其列表中的变量声明为每个线程的私有变量。</p>
<h5 id="格式-11"><a href="#格式-11" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h5><p>私有变量的行为如下：</p>
<ul>
<li>为团队中的每个线程声明一个相同类型的新对象</li>
<li>所有对原始对象的引用都被替换为对新对象的引用</li>
<li>应该假定每个线程都没有初始化</li>
</ul>
<h4 id="shared-子句"><a href="#shared-子句" class="headerlink" title="shared 子句"></a>shared 子句</h4><h5 id="目的-13"><a href="#目的-13" class="headerlink" title="目的"></a>目的</h5><p>shared 子句声明其列表中的变量在团队中的所有线程之间共享。</p>
<h5 id="格式-12"><a href="#格式-12" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h5><p>共享变量只存在于一个内存位置，所有线程都可以读写该地址，程序员有责任确保多个线程正确地访问共享变量(例如通过临界区)</p>
<h4 id="default-子句"><a href="#default-子句" class="headerlink" title="default 子句"></a>default 子句</h4><h5 id="目的-14"><a href="#目的-14" class="headerlink" title="目的"></a>目的</h5><p>default 子句允许用户为任何并行区域的词法范围内的所有变量指定默认作用域。</p>
<h5 id="格式-13"><a href="#格式-13" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> (shared | none)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h5><p>使用 private、shared、firstprivate、lastprivate 和 reduction 子句可以避免使用特定变量。C/C++ OpenMP 规范不包括将 private 或 firstprivate 作为可能的默认值。但是，实际的实现可能会提供这个选项。使用 none 作为默认值要求程序员显式地限定所有变量的作用域。</p>
<h4 id="firstprivate-子句"><a href="#firstprivate-子句" class="headerlink" title="firstprivate 子句"></a>firstprivate 子句</h4><h5 id="目的-15"><a href="#目的-15" class="headerlink" title="目的"></a>目的</h5><p>firstprivate 子句将 private 子句的行为与它的列表中变量的自动初始化相结合。</p>
<h5 id="格式-14"><a href="#格式-14" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firstprivate (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h5><p>在进入并行或工作共享结构之前，将根据其原始对象的值初始化列出的变量。</p>
<h4 id="lastprivate-子句"><a href="#lastprivate-子句" class="headerlink" title="lastprivate 子句"></a>lastprivate 子句</h4><h5 id="目的-16"><a href="#目的-16" class="headerlink" title="目的"></a>目的</h5><p>lastprivate 子句将 private 子句的行为与从最后一个循环迭代或部分到原始变量对象的复制相结合。</p>
<h5 id="格式-15"><a href="#格式-15" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lastprivate (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h5><p>复制回原始变量对象的值是从封闭结构的最后一次(顺序)迭代或部分获得的。例如，为 DO 部分执行最后一次迭代的团队成员，或者执行 sections 上下文的最后一部分的团队成员，使用其自身的值执行副本。</p>
<h4 id="copyin-子句"><a href="#copyin-子句" class="headerlink" title="copyin 子句"></a>copyin 子句</h4><h5 id="目的-17"><a href="#目的-17" class="headerlink" title="目的"></a>目的</h5><p>copyin 子句提供了为团队中的所有线程分配相同值的 threadprivate 变量的方法。</p>
<h5 id="格式-16"><a href="#格式-16" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copyin  (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h5 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h5><p>列表包含要复制的变量的名称。在Fortran中，列表既可以包含公共块的名称，也可以包含已命名变量的名称。主线程变量用作复制源。在进入并行结构时，将使用其值初始化团队线程。</p>
<h4 id="copyprivate-子句"><a href="#copyprivate-子句" class="headerlink" title="copyprivate 子句"></a>copyprivate 子句</h4><h5 id="目的-18"><a href="#目的-18" class="headerlink" title="目的"></a>目的</h5><p>copyprivate 子句可用于将单个线程获得的值直接传播到其他线程中私有变量的所有实例。与 single 指令相关联</p>
<h5 id="格式-17"><a href="#格式-17" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copyprivate  (<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h4 id="reduction-子句"><a href="#reduction-子句" class="headerlink" title="reduction 子句"></a>reduction 子句</h4><h5 id="目的-19"><a href="#目的-19" class="headerlink" title="目的"></a>目的</h5><p>reduction 子句对出现在其列表中的变量执行约简操作。为每个线程创建并初始化每个列表变量的私有副本。在约简结束时，将约简变量应用于共享变量的所有私有副本，并将最终结果写入全局共享变量。</p>
<h5 id="格式-18"><a href="#格式-18" class="headerlink" title="格式"></a>格式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduction (operator: <span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h5 id="Example-REDUCTION-Vector-Dot-Product"><a href="#Example-REDUCTION-Vector-Dot-Product" class="headerlink" title="Example: REDUCTION - Vector Dot Product:"></a>Example: REDUCTION - Vector Dot Product:</h5><p>并行循环的迭代将以相同大小的块分配给团队中的每个线程(调度静态)，在并行循环构造的末尾，所有线程将添加它们的“result”值来更新主线程的全局副本。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, n, chunk;</span><br><span class="line">    <span class="type">float</span> a[<span class="number">100</span>], b[<span class="number">100</span>], result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some initializations */</span></span><br><span class="line">    n = <span class="number">100</span>;</span><br><span class="line">    chunk = <span class="number">10</span>;</span><br><span class="line">    result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = i * <span class="number">1.0</span>;</span><br><span class="line">        b[i] = i * <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for default(shared) private(i) \</span></span><br><span class="line"><span class="meta">    schedule(static,chunk) reduction(+:result)</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        result = result + (a[i] * b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final result= %f\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="限制条件-12"><a href="#限制条件-12" class="headerlink" title="限制条件"></a>限制条件</h5><ul>
<li>列表项的类型必须对约简操作符有效。</li>
<li>列表项/变量不能声明为共享或私有。</li>
<li>约简操作可能与实数无关。</li>
<li>有关其他限制，请参见 OpenMP 标准 API。</li>
</ul>
<h3 id="指令绑定和嵌套规则"><a href="#指令绑定和嵌套规则" class="headerlink" title="指令绑定和嵌套规则"></a>指令绑定和嵌套规则</h3><p>本节主要是作为管理 OpenMP 指令和绑定的规则的快速参考。用户应该参考他们的实现文档和 OpenMP 标准以了解其他规则和限制。除非另有说明，规则适用于 Fortran 和 C/C++ OpenMP 实现。</p>
<p>注意：Fortran API 还定义了许多数据环境规则。这些没有在这里复制。</p>
<h4 id="指令绑定"><a href="#指令绑定" class="headerlink" title="指令绑定"></a>指令绑定</h4><ul>
<li>DO/for、sections、single、master 和 barrier 指令绑定到动态封闭的 parallel (如果存在的话)。如果当前没有并行区域被执行，指令就没有效果。</li>
<li>有序指令绑定到动态封闭的 DO/for 。</li>
<li>atomic 指令强制对所有线程中的 atomic 指令进行独占访问，而不仅仅是当前的团队。</li>
<li>critical 指令强制对所有线程中的 critical 指令进行独占访问，而不仅仅是当前的团队。</li>
<li>指令永远不能绑定到最接近的封闭并行之外的任何指令。</li>
</ul>
<h4 id="指令嵌套"><a href="#指令嵌套" class="headerlink" title="指令嵌套"></a>指令嵌套</h4><ul>
<li>工作共享区域不能紧密嵌套在工作共享、显式任务、关键区域、有序区域、原子区域或主区域内。</li>
<li>屏障区域不能紧密嵌套在工作共享、显式任务、关键区域、有序区域、原子区域或主区域中。</li>
<li>主区域不能紧密嵌套在工作共享、原子或显式任务区域内。</li>
<li>有序区域可能不会紧密嵌套在临界、原子或显式任务区域内。</li>
<li>一个有序区域必须与一个有序子句紧密嵌套在一个循环区域(或并行循环区域)内。</li>
<li>临界区不能嵌套(紧密嵌套或以其他方式嵌套)在具有相同名称的临界区内。注意，此限制不足以防止死锁。</li>
<li>并行、刷新、临界、原子、taskyield 和显式任务区域可能不会紧密嵌套在原子区域内。</li>
</ul>
<h2 id="2-8-线程堆栈大小和线程绑定"><a href="#2-8-线程堆栈大小和线程绑定" class="headerlink" title="2.8 线程堆栈大小和线程绑定"></a>2.8 线程堆栈大小和线程绑定</h2><h3 id="线程堆栈大小"><a href="#线程堆栈大小" class="headerlink" title="线程堆栈大小"></a>线程堆栈大小</h3><p>OpenMP 标准没有指定一个线程应该有多少堆栈空间。因此，默认线程堆栈大小的实现将有所不同。<br>默认的线程堆栈大小很容易耗尽。它也可以在编译器之间不可移植。以过去版本的LC编译器为例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Compiler</th>
<th>Approx. Stack Limit</th>
<th>Approx. Array Size (doubles)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux icc, ifort</td>
<td>4 MB</td>
<td>700 x 700</td>
</tr>
<tr>
<td>Linux pgcc, pgf90</td>
<td>8 MB</td>
<td>1000 x 1000</td>
</tr>
<tr>
<td>Linux gcc, gfortran</td>
<td>2 MB</td>
<td>500 x 500</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>超出其堆栈分配的线程可能存在或不存在段错误。当数据被破坏时，应用程序可以继续运行。</li>
<li>静态链接代码可能受到进一步的堆栈限制。</li>
<li>用户的登录shell还可以限制堆栈大小</li>
</ul>
<p>如果您的 OpenMP 环境支持 OpenMP 3.0  OMP_STACKSIZE 环境变量(在前一节中介绍过)，那么您可以使用它在程序执行之前设置线程堆栈大小。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_STACKSIZE 2000500B</span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot;3000 k &quot;</span></span><br><span class="line">setenv OMP_STACKSIZE 10M</span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot; 10 M &quot;</span></span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot;20 m &quot;</span></span><br><span class="line">setenv OMP_STACKSIZE <span class="string">&quot; 1G&quot;</span></span><br><span class="line">setenv OMP_STACKSIZE 20000</span><br></pre></td></tr></table></figure></p>
<p>否则，在LC上，您应该能够对Linux集群使用下面的方法。该示例显示将线程堆栈大小设置为12 MB，作为预防措施，将shell堆栈大小设置为无限制。</p>
<p>csh/tcsh:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv KMP_STACKSIZE 12000000</span><br><span class="line"><span class="built_in">limit</span> stacksize unlimited</span><br></pre></td></tr></table></figure></p>
<p>ksh/sh/bash:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KMP_STACKSIZE=12000000</span><br><span class="line"><span class="built_in">ulimit</span> -s unlimited</span><br></pre></td></tr></table></figure></p>
<h3 id="线程绑定"><a href="#线程绑定" class="headerlink" title="线程绑定"></a>线程绑定</h3><ul>
<li>在某些情况下，如果一个程序的线程被绑定到处理器/核心，那么它的性能会更好。</li>
<li>“绑定”一个线程到一个处理器意味着操作系统将调度一个线程始终在同一个处理器上运行。否则，可以将线程调度为在任何处理器上执行，并在每个时间片的处理器之间来回“弹回”。也称为“线程关联性”或“处理器关联性”。</li>
<li>将线程绑定到处理器可以更好地利用缓存，从而减少昂贵的内存访问。这是将线程绑定到处理器的主要动机。</li>
</ul>
<p>根据平台、操作系统、编译器和 OpenMP 实现的不同，可以通过几种不同的方式将线程绑定到处理器。OpenMP 3.1 版 API 提供了一个环境变量来“打开”或“关闭”处理器绑定。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv OMP_PROC_BIND  TRUE</span><br><span class="line">setenv OMP_PROC_BIND  FALSE</span><br></pre></td></tr></table></figure></p>
<p>在更高的级别上，进程也可以绑定到处理器。</p>
<h1 id="3-OpenMP详细代码示例"><a href="#3-OpenMP详细代码示例" class="headerlink" title="3. OpenMP详细代码示例"></a>3. OpenMP详细代码示例</h1><h2 id="3-1-hello-openmp-cpp"><a href="#3-1-hello-openmp-cpp" class="headerlink" title="3.1 hello_openmp.cpp"></a>3.1 hello_openmp.cpp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 尝试着在编译选项里使用和不使用-openmp 这个编译选项分别编译并执行代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _OPENMP  <span class="comment">// 如果定义了这个宏</span></span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, OpenMP!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OpenMP is not enabled.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-header-and-env-cpp"><a href="#3-2-header-and-env-cpp" class="headerlink" title="3.2 header_and_env.cpp"></a>3.2 header_and_env.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  引入&lt;omp.h&gt;头文件，OpenMP的几乎所有函数定义都在这个头文件中。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span>  <span class="comment">// 包含OpenMP头文件 </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// omp_get_max_threads() 等其它函数都定义在omp.h头文件中</span></span><br><span class="line">	<span class="comment">// omp_get_max_threads() 获取本机的CPU线程数</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;OpenMP will use &quot;</span> &lt;&lt; <span class="built_in">omp_get_max_threads</span>() &lt;&lt;</span><br><span class="line">	    <span class="string">&quot; threads maximum.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-parallel-cpp"><a href="#3-3-parallel-cpp" class="headerlink" title="3.3 parallel.cpp"></a>3.3 parallel.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. 尝试将环境变量改为 OMP_NUM_THREADS=2 和 OMP_NUM_THREADS=3 再编译运行程序试试</span></span><br><span class="line"><span class="comment">  2. 尝试在 #pragma omp parallel 后添加num_threads(5) 试试</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel   <span class="comment">// OpenMP 并行区域</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 花括号里的内容会被N个线程同时执行，N定义在环境变量OMP_NUM_THREADS中 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d of %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), <span class="built_in">omp_get_num_threads</span>());</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-parallel-cout-cpp"><a href="#3-4-parallel-cout-cpp" class="headerlink" title="3.4 parallel_cout.cpp"></a>3.4 parallel_cout.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   程序说明： 我们会发现打印在控制台的内容是乱的，这是因为在一个线程还没输出完成时，另一个线程就抢着要输出了！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello from thread &quot;</span> &lt;&lt; <span class="built_in">omp_get_thread_num</span>() &lt;&lt; <span class="string">&quot; of &quot;</span> &lt;&lt;  <span class="built_in">omp_get_num_threads</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-nested-cpp"><a href="#3-5-nested-cpp" class="headerlink" title="3.5 nested.cpp"></a>3.5 nested.cpp</h2><p>如果嵌套并行可用，则在并行区里还会继续创建线程，level 2会输出4次。否则的话level 2输出2次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 看看打印输出是否跟您想的一样，如果不一样，为什么？</span></span><br><span class="line"><span class="comment">    2. 试着禁止嵌套并行;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">omp_set_nested</span>(<span class="number">1</span>);   <span class="comment">// 允许嵌套并行可用 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Level 1, thread %d of %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(),<span class="built_in">omp_get_num_threads</span>());</span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Level 2, thread %d of %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(),<span class="built_in">omp_get_num_threads</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-6-parallel-for-cpp"><a href="#3-6-parallel-for-cpp" class="headerlink" title="3.6 parallel-for.cpp"></a>3.6 parallel-for.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    for循环的并行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> size = <span class="number">50</span>;</span><br><span class="line">	<span class="type">int</span> a[size];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		a[i] = i;                     <span class="comment">// 这里的代码是并行执行的</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)    <span class="comment">// 这里是串行执行的，#pragma omp parallel for作用范围只有紧接着的for循环，当然这个for循环是可以嵌套的.</span></span><br><span class="line">		std::cout &lt;&lt; a[i] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-7-scoping-cpp"><a href="#3-7-scoping-cpp" class="headerlink" title="3.7 scoping.cpp"></a>3.7 scoping.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   1. 变量的作用范围在并行程序设计中非常重要</span></span><br><span class="line"><span class="comment">   2. 如果在并行区域再加一个私有的a变量，想想会发生什么？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// a在并行块内部是共享(默认)的，所有线程都有权操作它(操作的都是同一个变量，没有备份)，而且并行快结束后，块内代码对其的修改有效</span></span><br><span class="line">	<span class="type">int</span> b;     <span class="comment">// 在并行区域外不可见，每个线程有一个备份拷贝</span></span><br><span class="line">	a = <span class="built_in">omp_get_thread_num</span>() + <span class="number">100</span>;</span><br><span class="line">	b = <span class="built_in">omp_get_thread_num</span>() + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;   <span class="comment">// 理论上这里的输出是[100+0,100+threads)之间随机的, 得看哪个线程最后执行完</span></span><br><span class="line">    <span class="comment">//	b = 0;   // 对外不可见，这里会发生错误，所以注释</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-8-firstprivate-cpp"><a href="#3-8-firstprivate-cpp" class="headerlink" title="3.8 firstprivate.cpp"></a>3.8 firstprivate.cpp</h2><p>firstprivate的作用是，让i默认使用并行区域外i的值来初始化并行区域内的私有i，但是初始化后并行去内部的i就跟外面的没有关系了，各个线程仍然持有一个i的私有备份，运行结束时，原有的i值保持i=10不变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 私有变量i是覆盖了并行区域外的共享变量i，所以这里并没有初始化，值应该为0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread %d, i = %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), i);</span><br><span class="line">	i = <span class="number">200</span> + <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-9-lastprivate-cpp"><a href="#3-9-lastprivate-cpp" class="headerlink" title="3.9 lastprivate.cpp"></a>3.9 lastprivate.cpp</h2><p>跟firstprivate相反，lastprivate主要是用来指定将线程中的私有变量的值在并行处理结束后复制回主线程中的对应变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> size = <span class="number">1000</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">-1</span>, a[size];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for lastprivate(i)</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		a[i] = i;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-10-single-master-critical-cpp"><a href="#3-10-single-master-critical-cpp" class="headerlink" title="3.10 single-master-critical.cpp"></a>3.10 single-master-critical.cpp</h2><ol>
<li>omp critical -&gt; execute by one thread at a time</li>
<li>omp single   -&gt; execute by any one thread</li>
<li>omp master   -&gt; execute by the master thread (id == 0)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(8)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello from thread &quot;</span> &lt;&lt; <span class="built_in">omp_get_thread_num</span>() &lt;&lt; <span class="string">&quot; of &quot;</span> &lt;&lt;</span><br><span class="line">	    <span class="built_in">omp_get_num_threads</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-11-mutex-cpp"><a href="#3-11-mutex-cpp" class="headerlink" title="3.11 mutex.cpp"></a>3.11 mutex.cpp</h2><p>锁是多线程计算里非常重要的概念，他是保证数据一致性的基础，没有锁的并行计算会导致非常奇怪的结果。</p>
<p>举个栗子：当多个线程操作一个数据时，一个线程在读取一个数的时候另两个线程在对这个数作写操作，那这个读线程到底应该拿哪一个数值去做计算呢？回答当然是，拿最后更改这个值的线程的值去计算，但是这个值就是对的么？</p>
<p>很多时候即使是并行的，但是对于一个简单操作来讲，它也是需要有先后循序的，比如这个线程在操作这个变量的时候要求别的线程要等待这个线程操作完成，这时候就使用锁将该变量锁住。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">omp_lock_t</span> lock;</span><br><span class="line">	<span class="built_in">omp_init_lock</span>(&amp;lock);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(4)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">omp_set_lock</span>(&amp;lock); <span class="comment">// mutual exclusion (mutex)</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; <span class="built_in">omp_get_thread_num</span>() &lt;&lt;  <span class="string">&quot; has acquired the lock. Sleeping 2 seconds...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; <span class="built_in">omp_get_thread_num</span>() &lt;&lt;<span class="string">&quot; is releasing the lock...&quot;</span> &lt;&lt; std:: endl; <span class="built_in">omp_unset_lock</span>(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="built_in">omp_destroy_lock</span>(&amp;lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-12-barrier-cpp"><a href="#3-12-barrier-cpp" class="headerlink" title="3.12 barrier.cpp"></a>3.12 barrier.cpp</h2><ol>
<li>同步也是并行计算中特别重要的概念，跟上面讲的锁一样;</li>
<li>特别是在时间相关的计算领域里，如含时的有限差分等等;</li>
<li>因为在具体程序中，每个线程执行的任务不一样，即使执行的任务一样，也不能保证每个线程执行任务消费的时间都完全一致。有的线程已经执行了5行代码，有的线程才执行到第0行。而含时的迭代需要所有线程都执行完t步骤后，才能继续执行t+1时间步，不然会导致错误的结果。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d of %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(),</span><br><span class="line">	    <span class="built_in">omp_get_num_threads</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp barrier <span class="comment">//  所有的线程都执行到这里时才能继续往后执行 </span></span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Thread %d of %d have passed the barrier\n&quot;</span>,</span><br><span class="line">	    <span class="built_in">omp_get_thread_num</span>(), <span class="built_in">omp_get_num_threads</span>());</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-13-atomic-cpp"><a href="#3-13-atomic-cpp" class="headerlink" title="3.13 atomic.cpp"></a>3.13 atomic.cpp</h2><p>原子变量跟锁有相近似的作用，都是保证变量或者事务的一致性；举个栗子：银行转账，A给B转账过程中突然停电，A账户前丢失了B却没有收到，这是谁的责任？当然是银行的责任。当然，银行的程序员们可不是吃白米饭的，转账的操作就是一个原子操作，只有成功或失败，没有成功了一半这个说法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">two_body_energy</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">2.0</span> * i + <span class="number">3.0</span> * j) / <span class="number">10.0</span>; <span class="comment">// some dummy return value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> nbodies = <span class="number">1000</span>;</span><br><span class="line">	<span class="type">double</span> energy = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nbodies; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; nbodies; j++) &#123;</span><br><span class="line">			<span class="type">double</span> eij = <span class="built_in">two_body_energy</span>(i, j);</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> omp atomic</span></span><br><span class="line">			energy += eij;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;energy = &quot;</span> &lt;&lt; energy &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-14-reduction-cpp"><a href="#3-14-reduction-cpp" class="headerlink" title="3.14 reduction.cpp"></a>3.14 reduction.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span></span></span><br><span class="line"><span class="function"><span class="title">two_body_energy</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">2.0</span> * i + <span class="number">3.0</span> * j) / <span class="number">10.0</span>; <span class="comment">// some dummy return value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> nbodies = <span class="number">1000</span>;</span><br><span class="line">	<span class="type">double</span> energy = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// + 是进行加运算</span></span><br><span class="line"><span class="comment">// energy 是要进行归约的变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+:energy)   </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nbodies; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; nbodies; j++) &#123;</span><br><span class="line">			<span class="type">double</span> eij = <span class="built_in">two_body_energy</span>(i, j);</span><br><span class="line">			energy += eij;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;energy = &quot;</span> &lt;&lt; energy &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-15-scheduling-cpp"><a href="#3-15-scheduling-cpp" class="headerlink" title="3.15 scheduling.cpp"></a>3.15 scheduling.cpp</h2><p>schedule只能用于循环并行构造中，其作用是用于控制循环并行结构的任务调度。一个简单的理解，一个for循环假设有10次迭代，使用4个线程去执行，那么哪些线程去执行哪些迭代呢？可以通过schedule去控制迭代的调度和分配，从而适应不同的使用情况，提高性能。</p>
<ul>
<li>static -&gt; 大部分的编译器实现，在没有使用schedule子句的时候，系统就是采用static方式调度的。<ul>
<li>对于<code>schedule(static,size)</code>的含义，OpenMP会给每个线程分配size次迭代计算。这个分配是静态的，“静态”体现在这个分配过程跟实际的运行是无关的，可以从逻辑上推断出哪几次迭代会在哪几个线程上运行。具体而言，对于一个N次迭代，使用M个线程，那么，<code>[0,size-1]</code>的size次的迭代是在第一个线程上运行，<code>[size, size + size -1]</code>是在第二个线程上运行，依次类推。那么，如果M太大，size也很大，就可能出现很多个迭代在一个线程上运行，而某些线程不执行任何迭代。需要说明的是，这个分配过程就是这样确定的，不会因为运行的情况改变，比如，我们知道，进入OpenMP后，假设有M个线程，这M个线程开始执行的时间不一定是一样的，这是由OpenMP去调度的，并不会因为某一个线程先被启动，而去改变for的迭代的分配，这就是静态的含义。</li>
</ul>
</li>
<li>dynamic -&gt; 每个线程运行结束时获得新的计算任务<ul>
<li>动态调度迭代的分配是依赖于运行状态进行动态确定的，所以哪个线程上将会运行哪些迭代是无法像静态一样事先预料的。对于dynamic，没有size参数的情况下，每个线程按先执行完先分配的方式执行1次循环，比如，刚开始，线程1先启动，那么会为线程1分配一次循环开始去执行（i=0的迭代），然后，可能线程2启动了，那么为线程2分配一次循环去执行（i=1的迭代），假设这时候线程0和线程3没有启动，而线程1的迭代已经执行完，可能会继续为线程1分配一次迭代，如果线程0或3先启动了，可能会为之分配一次迭代，直到把所有的迭代分配完。所以，动态分配的结果是无法事先知道的，因为我们无法知道哪一个线程会先启动，哪一个线程执行某一个迭代需要多久等等，这些都是取决于系统的资源、线程的调度等等。</li>
</ul>
</li>
<li>guided -&gt; 类似动态钓鱼，但是 chunk size是自适应的。<ul>
<li>类似于动态调度，但每次分配的循环次数不同，开始比较大，以后逐渐减小。size表示每次分配的迭代次数的最小值，由于每次分配的迭代次数会逐渐减少，较少到size时，将不再减少。如果不知道size的大小，那么默认size为1，即一直减少到1。具体是如何减少的，以及开始比较大（具体是多少？），参考相关手册的信息。</li>
</ul>
</li>
<li>auto -&gt; 编译器动态决定采用那种策略<ul>
<li>runtime表示根据环境变量确定上述调度策略中的某一种，默认也是静态的（static）。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_SIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scheduling:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> niter = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for schedule(static, CHUNK_SIZE)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; niter; i++) &#123;</span><br><span class="line">		<span class="type">int</span> thr = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;iter %d of %d on thread %d\n&quot;</span>, i, niter, thr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-16-ordered-cpp"><a href="#3-16-ordered-cpp" class="headerlink" title="3.16 ordered.cpp"></a>3.16 ordered.cpp</h2><p>在循环代码中某些代码的执行需要按规定的顺序执行，比如在一个循环中，一部分的工作可以并行执行，而特定的部分需要按照串行的工作流程依次执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> niter = <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for ordered       <span class="comment">// 这里必须这么写</span></span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; niter; i++) &#123;</span><br><span class="line">		<span class="type">int</span> thr = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unordered iter %d of %d on thread %d\n&quot;</span>, i, niter, thr);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp ordered                    <span class="comment">// 这里是需要顺序执行的部分</span></span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ordered iter %d of %d on thread %d\n&quot;</span>, i, niter, thr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-17-loop-dependencies-cpp"><a href="#3-17-loop-dependencies-cpp" class="headerlink" title="3.17 loop-dependencies.cpp"></a>3.17 loop-dependencies.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">( <span class="type">int</span> N, <span class="type">int</span> M, <span class="type">double</span> **A, <span class="type">double</span> **B, <span class="type">double</span> **C )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">double</span> alpha = <span class="number">1.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for collapse(2) ordered(2)</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; M<span class="number">-1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">        A[i][j] = <span class="built_in">foo</span>(i, j);</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp ordered depend(source)</span></span><br><span class="line"></span><br><span class="line">        B[i][j] = alpha * A[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp ordered depend(sink: i-1,j) depend(sink: i,j-1)</span></span><br><span class="line">        C[i][j] = <span class="number">0.2</span> * (A[i<span class="number">-1</span>][j] + A[i+<span class="number">1</span>][j] + A[i][j<span class="number">-1</span>] + A[i][j+<span class="number">1</span>] + A[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-18-sections-cpp"><a href="#3-18-sections-cpp" class="headerlink" title="3.18 sections.cpp"></a>3.18 sections.cpp</h2><ol>
<li>有些需要并行的任务并不是一个for循环之类的，而是一个个代码块，这种情况下就可以使用sections的情形；</li>
<li>sections下包含多个section，section相互之间只并行执行的，但是section内部是串行执行的；</li>
<li>多个sections之间也是串行执行的</li>
<li>如果<code>#pragma omp parallel sections</code> 写成<code>#pragma omp sections</code>，则各个section之间是串行执行的 </li>
<li>如果变成两个线程的话，会有一个线程执行两个section</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel sections num_threads(4)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section <span class="comment">// 独立线程</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> thr = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;section 1, thread %d - sleeping 1 second\n&quot;</span>, thr);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;section 1 done\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section <span class="comment">// 独立线程</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> thr = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;section 2, thread %d - sleeping 2 second\n&quot;</span>, thr);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;section 2 done\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section <span class="comment">// 独立线程</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> thr = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;section 3, thread %d - sleeping 3 second\n&quot;</span>, thr);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;section 3 done\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// printf(&quot;not in omp section&quot;); // error - code must be in section</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-19-threadprivate-cpp"><a href="#3-19-threadprivate-cpp" class="headerlink" title="3.19 threadprivate.cpp"></a>3.19 threadprivate.cpp</h2><p>threadprivate指令用来指定全局的对象被各个线程各自复制了一个私有的拷贝，即各个线程具有各自私有的全局对象。threadprivate和private的区别在于threadprivate声明的变量通常是全局范围内有效的，而private声明的变量只在它所属的并行构造中有效。用作threadprivate的变量的地址不能是常数。对于C++的类（class）类型变量，用作threadprivate的参数时有些限制，当定义时带有外部初始化时，必须具有明确的拷贝构造函数。程序示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(g)       <span class="comment">//一定要先声明</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Explicitly turn off dynamic threads */</span></span><br><span class="line">    <span class="built_in">omp_set_dynamic</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">       g = <span class="built_in">omp_get_thread_num</span>();   </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;tid: %d\n&quot;</span>,g);         <span class="comment">//随机依次输出0~3</span></span><br><span class="line">    &#125; <span class="comment">// End of parallel region</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = g*g;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tid : %d, tid*tid: %d\n&quot;</span>,g, temp);  <span class="comment">//不同线程中全局变量值不同</span></span><br><span class="line">    &#125; <span class="comment">// End of parallel region</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：在使用threadprivate的时候，要用omp_set_dynamic(0)关闭动态线程的属性，才能保证结果正确。</p>
<h2 id="3-20-Copyin-cpp"><a href="#3-20-Copyin-cpp" class="headerlink" title="3.20 Copyin.cpp"></a>3.20 Copyin.cpp</h2><p>copyin子句用于将主线程中threadprivate变量的值拷贝到执行并行区域的各个线程的threadprivate变量中，从而使得team内的子线程都拥有和主线程同样的初始值。程序示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> A = <span class="number">100</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(A) </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        A++; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,<span class="built_in">omp_get_thread_num</span>(), i, A);   <span class="comment">// #1 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A); <span class="comment">// 并行区域外的打印的“Globa A”的值总是和前面的thread 0的结果相等，因为退出并行区域后，只有master线程即0号线程运行。</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for copyin(A)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        A++; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,<span class="built_in">omp_get_thread_num</span>(), i, A);   <span class="comment">// #1 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A); <span class="comment">// #2 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-21-Copyprivate-cpp"><a href="#3-21-Copyprivate-cpp" class="headerlink" title="3.21 Copyprivate.cpp"></a>3.21 Copyprivate.cpp</h2><p>copyprivate子句用于将线程私有副本变量的值从一个线程广播到执行同一并行区域的其他线程的同一变量。copyprivate只能用于single指令（single指令:用在一段只被单个线程执行的代码段之前,表示后面的代码段将被单线程执行）的子句中，在一个single块的结尾处完成广播操作。copyprivate只能用于private/firstprivate或threadprivate修饰的变量。程序示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(counter)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">increment_counter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">return</span>(counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>    count;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single copyprivate(counter)</span></span><br><span class="line">        &#123;</span><br><span class="line">            counter = <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count = <span class="built_in">increment_counter</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ThreadId: %ld, count = %ld/n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// count 都是51</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-22-nowait-cpp"><a href="#3-22-nowait-cpp" class="headerlink" title="3.22 nowait.cpp"></a>3.22 nowait.cpp</h2><p>栅障（Barrier）是OpenMP用于线程同步的一种方法。线程遇到栅障是必须等待，直到并行区中的所有线程都到达同一点。注意：在任务分配for循环和任务分配section结构中，我们已经隐含了栅障，在parallel,for,sections,single结构的最后，也会有一个隐式的栅障。</p>
<p>隐式的栅障会使线程等到所有的线程继续完成当前的循环、结构化块或并行区，再继续执行后面的工作。可以使用nowait去掉这个隐式的栅障.去掉隐式栅障，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel <span class="comment">//并行区内</span></span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="meta">#<span class="keyword">pragma</span> omp for nowait <span class="comment">// 任务分配for循环</span></span></span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;m;k++)&#123;</span><br><span class="line">             <span class="built_in">fun1</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="meta">#<span class="keyword">pragma</span> omp sections private(y,z)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#pragme omp section<span class="comment">//任务分配section</span></span></span><br><span class="line">            &#123;y=<span class="built_in">sectionA</span>(x);&#125;</span><br><span class="line">        <span class="meta">#pragme omp section</span></span><br><span class="line">            &#123;z=<span class="built_in">sectionB</span>(x);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为第一个 任务分配for循环和第二个任务分配section代码块之间不存在数据相关。加上显示栅障，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(x,y,z) num_threads(2)<span class="comment">//使用的线程数为2</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tid=<span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    <span class="keyword">if</span>(tid==<span class="number">0</span>)</span><br><span class="line">        y=<span class="built_in">fun1</span>();<span class="comment">//第一个线程得到y</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        z=<span class="built_in">fun2</span>();<span class="comment">//第二个线程得到z</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp barrier <span class="comment">//显示加上栅障，保证y和z在使用前已有值</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)</span><br><span class="line">        x[k]=y+z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单线程和多线程交错执行： 当开发人员为了减少开销而把并行区设置的很大时，有些代码很可能只执行一次，并且由一个线程执行，这样单线程和多线程需要交错执行</p>
<p>举例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel <span class="comment">//并行区</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tid=<span class="built_in">omp_get_thread_num</span>();<span class="comment">//每个线程都调用这个函数，得到线程号</span></span><br><span class="line">    <span class="comment">//这个循环被划分到多个线程上进行</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp for nowait</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)</span><br><span class="line">        x[k]=<span class="built_in">fun1</span>(tid);<span class="comment">//这个循环的结束处不存在使所有线程进行同步的隐式栅障</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp master</span></span><br><span class="line">    y=<span class="built_in">fn_input_only</span>(); <span class="comment">//只有主线程会调用这个函数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp barrier   <span class="comment">//添加一个显示的栅障对所有的线程同步，从而确保x[0-99]和y处于就绪状态</span></span></span><br><span class="line">    <span class="comment">//这个循环也被划分到多个线程上进行</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp for nowait</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)</span><br><span class="line">        x[k]=y+<span class="built_in">fn2</span>(x[k]); <span class="comment">//这个线程没有栅障，所以不会相互等待</span></span><br><span class="line">    <span class="comment">//一旦某个线程执行完上面的代码，不需要等待就可以马上执行下面的代码</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp single <span class="comment">//注意：single后面意味着有隐式barrier</span></span></span><br><span class="line">    <span class="built_in">fn_single_print</span>(y);</span><br><span class="line">    <span class="comment">//所有的线程在执行下面的函数前会进行同步</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp master</span></span><br><span class="line">    <span class="built_in">fn_print_array</span>(x);<span class="comment">//只有主线程会调用这个函数</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h2 id="3-23-task"><a href="#3-23-task" class="headerlink" title="3.23 task"></a>3.23 task</h2><p>从功能上说：</p>
<ol>
<li>The TASK construct defines an explicit task, which may be executed by the encountering thread, or deferred for execution by any other thread in the team.</li>
<li>The data environment of the task is determined by the data sharing attribute clauses.</li>
<li>Task execution is subject to task scheduling - see the OpenMP 3.0 specification document for details.</li>
</ol>
<p>任务构造定义一个显式的任务，可能会被遇到的线程马上执行，也可能被延迟给线程组内其他线程来执行。任务的执行，依赖于OpenMP的任务调度。</p>
<p>语法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp task [clause ...]  newline </span><br><span class="line">                   if (scalar expression) </span><br><span class="line">                   final (scalar expression) </span><br><span class="line">                   untied</span><br><span class="line">                   default (shared | none)</span><br><span class="line">                   mergeable</span><br><span class="line">                   private (list) </span><br><span class="line">                   firstprivate (list) </span><br><span class="line">                   shared (list) </span><br><span class="line">     structured_block</span><br></pre></td></tr></table></figure></p>
<p>task，简单的理解，就是定义一个任务，线程组内的某一个线程来执行此任务。和工作共享结构很类似，我们都知道，for也是某一个线程执行某一个迭代，如果把每一个迭代看成一个task，那么就是task的工作方式了，在for只能用于循环迭代的基础上，OpenMP提供了sections构造，用于构造一个sections，然后里面定义一堆的section，每一个section被一个线程去执行，这样，每一个section也类似于for的每一次迭代，只是使用sections会更灵活，更简单，但是其实，for和sections在某种程度上是可以转换的，用下面的例子来看一个使用sections和for指令分别执行“三个”任务的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_COUNT	3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task1</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task1, Thread ID: %d, task: %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task2</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task2, Thread ID: %d, task: %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task3</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task3, Thread ID: %d, task: %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp sections</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">			<span class="built_in">task1</span>(<span class="number">10</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">			<span class="built_in">task2</span>(<span class="number">20</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">			<span class="built_in">task3</span>(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; TASK_COUNT; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">task1</span>(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">task2</span>(<span class="number">20</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) </span><br><span class="line">				<span class="built_in">task3</span>(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，这个程序不是这里要讨论的重点，只是为了说明for和sections的一些类似之处，或者其实可以理解为sections其实是for的展开形式，适合于少量的“任务”，并且适合于没有迭代关系的“任务”。很显然，上面的例子适合用sections去解决，因为本身是三个任务，不存在迭代的关系，三个任务和循环迭代变量没有什么关联。</p>
<p>接下来，分析下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task, Thread ID: %d, task: %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N		3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span>*a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">		a[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[N];</span><br><span class="line">	<span class="built_in">init</span>(a);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp sections</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">			<span class="built_in">task</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">			<span class="built_in">task</span>(a[<span class="number">1</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">			<span class="built_in">task</span>(a[<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">task</span>(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子，很容易理解了，把一个数组内的每一个元素“并行”的传递给<code>task()</code>函数，执行一个“任务”。同样，for和sections都能解决，但是如果N太大了，比如N是100，那sections就为难了，这里要说明的是：sections不能使用嵌套的形式，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">	<span class="built_in">task</span>(a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样是不行的，section只能显式的，直接的在sections里面书写，可以理解为”静态“的。继续研究这个例子，假设现在的需求是对如下的代码进行并行化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i=i+a[i])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">task</span>(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于这样的需求，OpenMP的for指令也是无法完成的，因为for指令在进行并行执行之前，就需要”静态“的知道任务该如何划分，而上面的i=i+a[i]，在运行之前，是无法知道有那些迭代，需要如何进行划分，因为其迭代的循环依赖于数组a里面保存的值。那么对于这样的循环，该如何并行？最关键的是，从语义上，这个循环是明显可以进行并行的。这就是之所以OpenMP3.0提供task的原因了。</p>
<p>在此，先总结一下for和sections指令的”缺陷“：无法根据运行时的环境动态的进行任务划分，必须是预先能知道的任务划分的情况。</p>
<p>使用task解决上面遗留的问题的方法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task, Thread ID: %d, task: %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N		50</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span>*a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">		a[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[N];</span><br><span class="line">	<span class="built_in">init</span>(a);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i=i+a[i])</span><br><span class="line">			&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp task</span></span><br><span class="line">				<span class="built_in">task</span>(a[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里之所以用single表示只有一个线程会执行下面的代码，否则会执行两次（这里用的线程数量为2），这是single的子句的理解，就不在此分析了。看其中task的代码，其实很简单，OpenMP遇到了task之后，就会使用当前的线程或者延迟一会后接下来的线程来执行task定义的任务。task的作用，就是定义了一个显式的任务。</p>
<p>那么，task和前面的for和sections的区别在于：task是“动态”定义任务的，在运行过程中，只需要使用task就会定义一个任务，任务就会在一个线程上去执行，那么其它的任务就可以并行的执行。可能某一个任务执行了一半的时候，或者甚至要执行完的时候，程序可以去创建第二个任务，任务在一个线程上去执行，一个动态的过程，不像sections和for那样，在运行之前，已经可以判断出可以如何去分配任务。而且，task是可以进行嵌套定义的，可以用于递归的情况等等。</p>
<p>总结task的使用：task主要适用于不规则的循环迭代（如上面的循环）和递归的函数调用。都是无法使用for来完成的情况。</p>
<p>显示任务和隐式任务（implicit&amp;explicit）</p>
<p>task的作用就是创建一个显式的任务，那么什么是隐式的任务呢？OpenMP的任务分为显式和隐式两种，根据我的个人理解，分析下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i=i+a[i])</span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp task</span></span><br><span class="line">			<span class="built_in">task</span>(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	    <span class="built_in">task</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中task(1000);就属于一个隐式的任务。因为执行完for后，会执行这一个任务，而上面的任务可能也会同时执行。</p>
<p>task的嵌套</p>
<p>任务构造结构可以嵌套在另一个task结构中，但是内部的task结构并不属于外部的task区域的一部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp task</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">task</span>(a[i]);</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp task</span></span><br><span class="line">    <span class="built_in">task</span>(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的理解，OpenMP遇到task指令就会定义一个显式的任务，就会在当前的线程或者延迟等待其它线程去执行，而不是将嵌套task的部分当作外部task的一部分。</p>
<p>task指令的子句</p>
<p>如果给一个task使用了if子句，如果if子句的表达式是false，会生成一个不延迟的任务，这样，遇到这个task的当前线程必须挂起当前的task区域，直到当前的任务完成之后才会恢复。个人理解，当前线程挂起，那么这个task是不是由其它的线程去执行呢，还是就是当前的这个线程执行这个任务？</p>
<p>如果给task使用了final子句，如果final表达式的值为true，生成的任务是一个终结任务。所有任务遇到终结任务执行的时候会生成终结和包含的任务。PS：不太理解！</p>
<h2 id="3-25-flush-cpp"><a href="#3-25-flush-cpp" class="headerlink" title="3.25 flush.cpp"></a>3.25 flush.cpp</h2><p>当并行区域里存在一共享变量，并且对其进行修改时，需要用flush更新变量，确保并行的多线程对共享变量的读操作是最新值.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">done=<span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp flush(done)</span></span><br><span class="line"> <span class="keyword">if</span>(!done)</span><br><span class="line"> &#123;</span><br><span class="line">    ...</span><br><span class="line">    done=<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="OpenMP中数据属性相关子句详解"><a href="#OpenMP中数据属性相关子句详解" class="headerlink" title="OpenMP中数据属性相关子句详解"></a>OpenMP中数据属性相关子句详解</h1><h2 id="private-firstprivate-lastprivate-threadprivate之间的比较"><a href="#private-firstprivate-lastprivate-threadprivate之间的比较" class="headerlink" title="private/firstprivate/lastprivate/threadprivate之间的比较"></a>private/firstprivate/lastprivate/threadprivate之间的比较</h2><p>private/firstprivate/lastprivate/threadprivate，首先要知道的是，它们分为两大类，一类是private/firstprivate/lastprivate子句，另一类是threadprivate，为指令。</p>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>private子句将一个或多个变量声明为线程的私有变量。每个线程都有它自己的变量私有副本，其他线程无法访问。即使在并行区域外有同名的共享变量，共享变量在并行区域内不起任何作用，并且并行区域内不会操作到外面的共享变量。<br>注意：</p>
<ol>
<li>private variables are undefined on entry and exit of the parallel region.即private变量在进入和退出并行区域是“未定义“的。</li>
<li>The value of the original variable (before the parallel region) is undefined after the parallel region!在并行区域之前定义的原来的变量，在并行区域后也是”未定义“的。</li>
<li>A private variable within the parallel region has no storage association with the same variable outside of the region. 并行区域内的private变量和并行区域外同名的变量没有存储关联。</li>
</ol>
<p>说明：private的很容易理解错误。下面用例子来说明上面的注意事项，</p>
<p>A. private变量在进入和退出并行区域是”未定义“的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for private(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初学OpenMP很容易认为这段代码是没有问题的。其实，这里的A在进入并行区域的时候是未定义的，所以在并行区域直接对其进行读操作，会导致运行时错误。<br>其实，在VS中编译这段代码，就会有编译警告：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning C4700: uninitialized local variable &#x27;A&#x27; used</span><br></pre></td></tr></table></figure></p>
<p>很清楚的指向”printf”这句，A是没有初始化的变量。所以，运行时候会出现运行时崩溃的错误。</p>
<p>这段代码能说明，private在进入并行区域是未定义的，至于退出并行区域就不容易举例说明了，本身，这里的三个注意事项是交叉理解的，说明的是一个含义，所以，看下面的例子来理解。</p>
<p>B. 在并行区域之前定义的原来的变量，在并行区域后也是”未定义“的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> B;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for private(B)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		B = <span class="number">100</span>; </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,B);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的B在并行区域内进行了赋值等操作，但是在退出并行区域后，是未定义的。理解”在并行区域之 前定义的 原来的变量，在并行区域 后也是” 未定义“的“这句话的时候，要注意，不是说所有的在并行区域内定义的原来的变量，使用了private子句后，退出并行区域后就一定是未定义的，如果原来的变量，本身已经初始化，那么，退出后，不会处于未定义的状态，就是下面的第三个注意事项要说明的问题。</p>
<p>C. 并行区域内的private变量和并行区域外同名的变量没有存储关联<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> C = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for private(C)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		C = <span class="number">200</span>; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,C);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,C);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，在退出并行区域后，printf的C的结果是100，和并行区域内对其的操作无关。</p>
<p>总结来说，上面的三点是交叉的，第三点包含了所有的情况。所以，private的关键理解是：A private variable within the parallel region has no storage association with the same variable outside of the region. 简单点理解，可以认为，并行区域内的private变量和并行区域外的变量没有任何关联。如果非要说点关联就是，在使用private的时候，在之前要先定义一下这个变量，但是，到了并行区域后，并行区域的每个线程会产生此变量的副本，而且是没有初始化的。</p>
<p>下面是综合上面的例子，参考注释的解释：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A=<span class="number">100</span>,B,C=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for private(A) private(B)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		B = A + i;		<span class="comment">// A is undefined! Runtime error!</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*--End of OpemMP paralle region. --*/</span></span><br><span class="line"> </span><br><span class="line">	C = B;			<span class="comment">// B is undefined outside of the parallel region!</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;A:%d\n&quot;</span>, A);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;B:%d\n&quot;</span>, B);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="firstprivate"><a href="#firstprivate" class="headerlink" title="firstprivate"></a>firstprivate</h3><p>private子句的私有变量不能继承同名变量的值，firstprivate则用于实现这一功能-继承并行区域额之外的变量的值，用于在进入并行区域之前进行一次初始化。</p>
<p>Firstprivate(list): All variables in the list areinitialized with the value the original object had before entering the parallelconstruct.</p>
<p>分析下面的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for firstprivate(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>,i, A);	<span class="comment">// #1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用VS编译发现，也会报一个“warning C4700: uninitialized local variable ‘A’ used”的警告，但是这里其实两个地方用到了A。实际上，这个警告是针对第二处的，可以看出，VS并没有给第一处OpenMP并行区域内的A有警告，这是由于使用firstprivate的时候，会对并行区域内的A使用其外的同名共享变量就行初始化，当然，如果严格分析，外面的变量其实也是没有初始化的，理论上也是可以认为应该报警告，但是，具体而言，这是跟VS的实现有关的，另外，在debug下，上面的程序会崩溃，release下，其实是可以输出值的，总之，上面的输出是无法预料的。<br>再看下面的例子，和前面private的例子很类似：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for firstprivate(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>,i, A);	<span class="comment">// #1</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，如果使用private，那么并行区域内是有问题的，因为并行区域内的A是没有初始化的，导致无法预料的输出或崩溃。但是，使用了firstprivate后，这样，进入并行区域的时候，每一个线程的A的副本都会利用并行区域外的同名共享变量A的值进行一次初始化，所以，输出的A都是100.<br>继续探讨这里的“进行一次初始化”，为了理解“一次”的含义，看下面的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for firstprivate(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,omp_get_thread_num(), i, A);	<span class="comment">// #1</span></span><br><span class="line">		A = i;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，每次输出后，改变A的值，需要注意的是，这里的“进行一次初始化”是针对team内的每一个线程进行一次初始化，对于上面的程序，在4核的CPU上运行，并行区域内有四个线程，所以每一个线程都会有A的一个副本，因而，上面的程序输出结果可能如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread ID: 0, 0: 100</span><br><span class="line">Thread ID: 0, 1: 0</span><br><span class="line">Thread ID: 0, 2: 1</span><br><span class="line">Thread ID: 2, 6: 100</span><br><span class="line">Thread ID: 2, 7: 6</span><br><span class="line">Thread ID: 1, 3: 100</span><br><span class="line">Thread ID: 2, 4: 3</span><br><span class="line">Thread ID: 1, 5: 4</span><br><span class="line">Thread ID: 3, 8: 100</span><br><span class="line">Thread ID: 3, 9: 8</span><br><span class="line">100</span><br></pre></td></tr></table></figure></p>
<p>其实，这个结果是很容易理解的，不可能是每一个for都有一个变量的副本，而是每一个线程，所以这个结果在预料之中。</p>
<p>仍然借助上面这个例子，帮助理解private和firstprivate，从而引出lastprivate，private对于并行区域的每一个线程都有一个副本，并且和并行区域外的变量没有关联；firstprivate解决了进入并行区的问题，即在进入并行区域的每个线程的副本变量使用并行区域外的共享变量进行一个初始化的工作，那么下面有一个问题就是，如果希望并行区域的副本变量，在退出并行区的时候，能反过来赋值给并行区域外的共享变量，那么就需要依靠lastprivate了。</p>
<h3 id="lastprivate"><a href="#lastprivate" class="headerlink" title="lastprivate"></a>lastprivate</h3><p>如果需要在并行区域内的私有变量经过计算后，在退出并行区域时，需要将其值赋给同名的共享变量，就可以使用lastprivate完成。</p>
<p>Lastprivate(list):The thread that executes the sequentially last iteration or section updates thevalue of the objects in the list.</p>
<p>从上面的firstprivate的最后一个例子可以看出，并行区域对A进行了赋值，但是退出并行区域后，其值仍然为原来的值。</p>
<p>这里首先有一个问题是：退出并行区域后，需要将并行区域内的副本的值赋值为同名的共享变量，那么，并行区域内有多个线程，是哪一个线程的副本用于赋值呢？</p>
<p>是否是最后一个运行完毕的线程？否！OpenMP规范中指出，如果是循环迭代，那么是将最后一次循环迭代中的值赋给对应的共享变量；如果是section构造，那么是最后一个section语句中的值赋给对应的共享变量。注意这里说的最后一个section是指程序语法上的最后一个，而不是实际运行时的最后一个运行完的。</p>
<p>在理解这句话之前，先利用一个简单的例子来理解一下lastprivate的作用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for lastprivate(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		A = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，很容易知道结果为10，而不是100.这就是lastprivate带来的效果，退出后会有一个赋值的过程。<br>理解了lastprivate的基本含义，就可以继续来理解上面的红色文字部分的描述了，即到底是哪一个线程的副本用于对并行区域外的变量赋值的问题，下面的例子和前面firstprivate的例子很类似：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for lastprivate(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d\n&quot;</span>,omp_get_thread_num(), i);	<span class="comment">// #1</span></span><br><span class="line">		A = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread ID: 0, 0</span><br><span class="line">Thread ID: 0, 1</span><br><span class="line">Thread ID: 0, 2</span><br><span class="line">Thread ID: 3, 8</span><br><span class="line">Thread ID: 3, 9</span><br><span class="line">Thread ID: 2, 6</span><br><span class="line">Thread ID: 1, 3</span><br><span class="line">Thread ID: 1, 4</span><br><span class="line">Thread ID: 1, 5</span><br><span class="line">Thread ID: 2, 7</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>从结果可以看出，最后并行区域外的共享变量的值并不是最后一个线程退出的值，多次运行发现，并行区域的输出结果可能发生变化，但是最终的输出都是9，这就是上面的OpenMP规范说明的问题，退出并行区域的时候，是根据“逻辑上”的最后一个线程用于对共享变量赋值，而不是实际运行的最后一个线程，对于for而言，就是最后一个循环迭代所在线程的副本值，用于对共享变量赋值。</p>
<p>另外，firstprivate和lastprivate分别是利用共享变量对线程副本初始化（进入）以及利用线程副本对共享变量赋值（退出），private是线程副本和共享变量无任何关联，那么如果希望进入的时候初始化并且退出的时候赋值呢？事实上，可以对同一个变量使用firstprivate和lastprivate的，下面的例子即可看出：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for firstprivate(A) lastprivate(A)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,omp_get_thread_num(), i, A);	<span class="comment">// #1</span></span><br><span class="line">		A = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：不能对一个变量同时使用两次private，或者同时使用private和firstprivate/lastprivate，只能firstprivate和lastprivate一起使用。<br>关于lastprivate，还需要说明的一点是，如果是类（class）类型的变量使用在lastprivate参数中，那么使用时有些限制，需要一个可访问的，明确的缺省构造函数，除非变量也被使用作为firstprivate子句的参数；还需要一个拷贝赋值操作符，并且这个拷贝赋值操作符对于不同对象的操作顺序是未指定的，依赖于编译器的定义。</p>
<p>另外，firstprivate和private可以用于所有的并行构造块，但是lastprivate只能用于for和section组成的并行块之中。</p>
<h3 id="threadprivate"><a href="#threadprivate" class="headerlink" title="threadprivate"></a>threadprivate</h3><p>首先，threadprivate和上面几个子句的区别在于，threadprivate是指令，不是子句。threadprivate指定全局变量被OpenMP所有的线程各自产生一个私有的拷贝，即各个线程都有自己私有的全局变量。一个很明显的区别在于，threadprivate并不是针对某一个并行区域，而是整个于整个程序，所以，其拷贝的副本变量也是全局的，即在不同的并行区域之间的同一个线程也是共享的。</p>
<p>threadprivate只能用于全局变量或静态变量，这是很容易理解的，根据其功能。</p>
<p>根据下面的例子，来进一步理解threadprivate的使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> A = <span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(A)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		A++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,omp_get_thread_num(), i, A);	<span class="comment">// #1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		A++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,omp_get_thread_num(), i, A);	<span class="comment">// #1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A);	<span class="comment">// #2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Thread ID: 0, 0: 101</span><br><span class="line">Thread ID: 0, 1: 102</span><br><span class="line">Thread ID: 0, 2: 103</span><br><span class="line">Thread ID: 3, 8: 101</span><br><span class="line">Thread ID: 3, 9: 102</span><br><span class="line">Thread ID: 1, 3: 101</span><br><span class="line">Thread ID: 1, 4: 102</span><br><span class="line">Thread ID: 1, 5: 103</span><br><span class="line">Thread ID: 2, 6: 101</span><br><span class="line">Thread ID: 2, 7: 102</span><br><span class="line">Global A: 103</span><br><span class="line">Thread ID: 2, 6: 103</span><br><span class="line">Thread ID: 2, 7: 104</span><br><span class="line">Thread ID: 0, 0: 104</span><br><span class="line">Thread ID: 0, 1: 105</span><br><span class="line">Thread ID: 0, 2: 106</span><br><span class="line">Thread ID: 1, 3: 104</span><br><span class="line">Thread ID: 1, 4: 105</span><br><span class="line">Thread ID: 1, 5: 106</span><br><span class="line">Thread ID: 3, 8: 103</span><br><span class="line">Thread ID: 3, 9: 104</span><br><span class="line">Global A: 106</span><br></pre></td></tr></table></figure>
<p>分析结果，发现，第二个并行区域是在第一个并行区域的基础上继续递增的；每一个线程都有自己的全局私有变量。另外，观察在并行区域外的打印的“Globa A”的值可以看出，这个值总是前面的thread 0的结果，这也是预料之中的，因为退出并行区域后，只有master线程运行。</p>
<p>threadprivate指令也有自己的一些子句，就不在此分析了。另外，如果使用的是C++的类，对于类的构造函数也会有类似于lastprivate的一些限制。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>private/firstprivate/lastprivate都是子句，用于表示并行区域内的变量的数据范围属性。其中，private表示并行区域team内的每一个线程都会产生一个并行区域外同名变量的共享变量，且和共享变量没有任何关联；firstprivaet在private的基础上，在进入并行区域时（或说每个线程创建时，或副本变量构造时），会使用并行区域外的共享变量进行一次初始化工作；lastprivate在private的基础上，在退出并行区域时，会使用并行区域内的副本的变量，对共享变量进行赋值，由于有多个副本，OpenMP规定了如何确定使用哪个副本进行赋值。另外，private不能和firstprivate/lastprivate混用于同一个变量，firstprivate和lastprivate可以对同一变量使用，效果为两者的结合。</p>
<p>threadprivate是指令，和private的区别在于，private是针对并行区域内的变量的，而threadprivate是针对全局的变量的。</p>
<h2 id="shared-default-copyin-copyprivate子句的使用"><a href="#shared-default-copyin-copyprivate子句的使用" class="headerlink" title="shared/default/copyin/copyprivate子句的使用"></a>shared/default/copyin/copyprivate子句的使用</h2><h3 id="shared"><a href="#shared" class="headerlink" title="shared"></a>shared</h3><p>shared子句可以用于声明一个或多个变量为共享变量。所谓的共享变量，是在一个并行区域的team内的所有线程只拥有变量的一个内存地址，所有线程访问同一地址。所以，对于并行区域内的共享变量，需要考虑数据竞争条件，要防止竞争，需要增加对应的保护，这是程序员需要自行考虑的。</p>
<p>下面的例子是一个求和的并行实现，使用共享变量，由于没有采取保护，会有数据竞争：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT	10000</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for shared(sum)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; COUNT;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum = sum + i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多次运行，结果可能不一样。</p>
<p>另外，需要注意，循环迭代变量在循环构造区域里是私有的，声明在循环构造区域内的自动变量都是私有的。这一点其实也是比较容易理解的，很难想象，如果循环迭代变量也是共有的，OpenMP该如何去执行，所以也只能是私有的了。即使使用shared来修饰循环迭代变量，也不会改变循环迭代变量在循环构造区域中是私有的这一特点:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT	10</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for shared(sum, i)</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; COUNT;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum = sum + i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子能侧面能说明问题，这里的最后输出i是0，并不是0到COUNT之内的一个可能的值，尽管这里使用shared修饰变量i。注意，这里的规则只是针对循环并行区域，对于其他的并行区域没有这样的要求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT	10</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(sum) private(i)</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; COUNT;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum = sum + i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里输出的i为0，如果改为shared，那么就是10了。当然，这段代码和上面的求和的代码含义上就是不一样的。</p>
<p>另外，这里顺便一个问题是，在循环并行区域内，循环迭代变量是不可修改的。这也是上面的例子，为何不采用下面的写法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for shared(sum) shared(i)</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; COUNT;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		sum = sum + i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，i++会报错，原因是在循环并行区域内，迭代变量i是可读不可写的。</p>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>default指定并行区域内变量的属性，C++的OpenMP中default的参数只能为shared或none，对于Fortran，可以为private等参数，具体参考手册。</p>
<p><code>default(shared)</code>：表示并行区域内的共享变量在不指定的情况下都是shared属性</p>
<p><code>default(none)</code>：表示必须显式指定所有共享变量的数据属性，否则会报错，除非变量有明确的属性定义（比如循环并行区域的循环迭代变量只能是私有的）</p>
<p>另外，如果一个并行区域，没有使用default子句，会是什么情况？实际测试，个人认为，没有使用default，那么其默认行为为default(shared)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT	10</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; COUNT;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum = sum + i;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，sum为shared属性，而i的属性不会改变，仍然只能为私有。这里的效果和加上default(shared)是一样的。如果使用default(none)，那么编译会报错“没有给sum指定数据共享属性”，不会为变量i报错，因为i是有明确的含义的，只能为私有。</p>
<h3 id="copyin"><a href="#copyin" class="headerlink" title="copyin"></a>copyin</h3><p>copyin子句用于将主线程中threadprivate变量的值拷贝到执行并行区域的各个线程的threadprivate变量中，从而使得team内的子线程都拥有和主线程同样的初始值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> A = <span class="number">100</span>;  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(A)  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        A++;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,omp_get_thread_num(), i, A);   <span class="comment">// #1  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A); <span class="comment">// #2  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for copyin(A)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        A++;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread ID: %d, %d: %d\n&quot;</span>,omp_get_thread_num(), i, A);   <span class="comment">// #1  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A); <span class="comment">// #2  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>输出如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Thread ID: 0, 0: 101</span><br><span class="line">Thread ID: 0, 1: 102</span><br><span class="line">Thread ID: 0, 2: 103</span><br><span class="line">Thread ID: 3, 8: 101</span><br><span class="line">Thread ID: 3, 9: 102</span><br><span class="line">Thread ID: 1, 3: 101</span><br><span class="line">Thread ID: 1, 4: 102</span><br><span class="line">Thread ID: 1, 5: 103</span><br><span class="line">Thread ID: 2, 6: 101</span><br><span class="line">Thread ID: 2, 7: 102</span><br><span class="line">Global A: 103</span><br><span class="line"></span><br><span class="line">Thread ID: 2, 6: 104</span><br><span class="line">Thread ID: 2, 7: 105</span><br><span class="line">Thread ID: 1, 3: 104</span><br><span class="line">Thread ID: 1, 4: 105</span><br><span class="line">Thread ID: 1, 5: 106</span><br><span class="line">Thread ID: 3, 8: 104</span><br><span class="line">Thread ID: 3, 9: 105</span><br><span class="line">Thread ID: 0, 0: 104</span><br><span class="line">Thread ID: 0, 1: 105</span><br><span class="line">Thread ID: 0, 2: 106</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>运行此程序，得到的结果和不使用copyin的结果是不一样的。不使用copyin的情况下，进入第二个并行区域的时候，不同线程的私有副本A的初始值是不一样的，这里使用了copyin之后，发现所有的线程的初始值都使用主线程的值初始化，然后继续运算。</p>
<p>为了更好的理解copyin，分析下面的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> A = <span class="number">100</span>;  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(A)  </span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Initial A = %d\n&quot;</span>, A);</span><br><span class="line">		A = omp_get_thread_num();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel copyin(A)			<span class="comment">// copyin</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Initial A = %d\n&quot;</span>, A);</span><br><span class="line">		A = omp_get_thread_num();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel				<span class="comment">// Will not copy, to check the result.</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Initial A = %d\n&quot;</span>, A);</span><br><span class="line">		A = omp_get_thread_num();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Global A: %d\n&quot;</span>,A);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br></pre></td></tr></table></figure></p>
<p>得到输出如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Initial A = 100</span><br><span class="line">Initial A = 100</span><br><span class="line">Initial A = 100</span><br><span class="line">Initial A = 100</span><br><span class="line">Global A: 0</span><br><span class="line">Initial A = 0</span><br><span class="line">Initial A = 0</span><br><span class="line">Initial A = 0</span><br><span class="line">Initial A = 0</span><br><span class="line">Global A: 0</span><br><span class="line">Initial A = 0</span><br><span class="line">Initial A = 3</span><br><span class="line">Initial A = 2</span><br><span class="line">Initial A = 1</span><br><span class="line">Global A: 1</span><br></pre></td></tr></table></figure></p>
<p>简单理解，在使用了copyin后，所有的线程的threadprivate类型的副本变量都会与主线程的副本变量进行一次“同步”。</p>
<p>另外，copyin中的参数必须被声明成threadprivate的，对于类类型的变量，必须带有明确的拷贝赋值操作符。而且，对于第一个并行区域，是默认含有copyin的功能的（比如上面的例子的前面的四个A的输出都是100）。copyin的一个可能需要用到的情况是，比如程序中有多个并行区域，每个线程希望保存一个私有的全局变量，但是其中某一个并行区域执行前，希望与主线程的值相同，就可以利用copyin进行赋值。</p>
<h3 id="copyprivate"><a href="#copyprivate" class="headerlink" title="copyprivate"></a>copyprivate</h3><p>copyprivate子句用于将线程私有副本变量的值从一个线程广播到执行同一并行区域的其他线程的同一变量。</p>
<p>说明：copyprivate只能用于single指令的子句中，在一个single块的结尾处完成广播操作。copyprivate只能用于private/firstprivate或threadprivate修饰的变量。</p>
<p>根据下面的程序，可以理解copyprivate的使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;omp.h&gt;  </span><br><span class="line">int A = 100;  </span><br><span class="line">#pragma omp threadprivate(A)  </span><br><span class="line"> </span><br><span class="line">int main(int argc, _TCHAR* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">	int B = 100;</span><br><span class="line">	int C = 1000;</span><br><span class="line">#pragma omp parallel firstprivate(B) copyin(A)	// copyin(A) can be ignored!</span><br><span class="line">	&#123;</span><br><span class="line">#pragma omp single copyprivate(A) copyprivate(B)// copyprivate(C)	// C is shared, cannot use copyprivate!</span><br><span class="line">		&#123;</span><br><span class="line">			A = 10;</span><br><span class="line">			B = 20;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Initial A = %d\n&quot;, A);		// 10 for all threads</span><br><span class="line">		printf(&quot;Initial B = %d\n&quot;, B);		// 20 for all threads</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	printf(&quot;Global A: %d\n&quot;,A);		// 10</span><br><span class="line">	printf(&quot;Global A: %d\n&quot;,B);		// 100. B is still 100! Will not be affected here!</span><br><span class="line"> </span><br><span class="line">	return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="reduction子句"><a href="#reduction子句" class="headerlink" title="reduction子句"></a>reduction子句</h2><p>reduction的作用： A private copy for each list variable is created for each thread. At the end of the reduction, the reduction variable is applied to all private copies of the shared variable, and the final result is written to the global shared variable.</p>
<p>reduction子句为变量指定一个操作符，每个线程都会创建reduction变量的私有拷贝，在OpenMP区域结束处，将使用各个线程的私有拷贝的值通过制定的操作符进行迭代运算，并赋值给原来的变量。</p>
<p>reduction的语法为recutioin(operator:list)和其他的数据属性子句不一样的是多了一个operator参数。由于最后会进行迭代运算，所以不是所有的运算符都能作为reduction的参数，而且，迭代运算需要一个初始值，不是所有的操作符需要有相同的初始值，一般而言，常见的reduction操作符的初始值为：+(0),*(1),-(0),&amp;~(0),|(0),^(0),&amp;&amp;(1),||(0)，当然，这不是必须的，比如叠加运算的初始值，可以是任意值，只是表达的含义不一样而已，但是对于某些操作符，有些初始值是没有什么意义的，比如乘法迭代如果初始值为0没有什么意义，结果肯定是0了！</p>
<p>典型的使用reduction的例子，就是迭加（求和）操作了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT 10</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">100</span>;		<span class="comment">// Assign an initial value.</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+:sum)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; COUNT; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>,sum);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子就是对0到COUNT进行求和，由于初始值为100，所以还会加一个100，如果只是为了求和，只需要初始值为0即可。使用reduction可以避免数据竞争的发生，将上面例子的COUNT修改为一个比较大的值，如果不使用reduction，会发现有数据竞争导致结果不一致，使用reduction后，每次都能得到正确的结果。</p>
<p>reduction的使用是比较简单的，主要还是需要理解上面说到的“初始值”，第一个理解是这里的100这样的初始值，这是并行区域外的初始值，会在最后计算到迭代结果中，那么还有一个隐含的初始值，就是我们知道，使用了reduction，那么每个线程都会构造一个reduction变量的线程副本，那么其值为多少呢？从上面的例子可以看出，其初始值就是0，如果初始值都是100，那么结果应该是100会被加线程数目的次数。初始值的确定方法就是上面提到的：+(0),*(1),-(0),&amp;~(0),|(0),^(0),&amp;&amp;(1),||(0)。</p>
<p>所以，理解reduction的工作过程：</p>
<ol>
<li>进入并行区域后，team内的每个新的线程都会对reduction变量构造一个副本，比如上面的例子，假设有四个线程，那么，进入并行区域的初始化值分别为：sum0=100，sum1 = sum2 = sum3 = 0。为何sum0为100呢？因为主线程不是一个新的线程，所以不需要再为主线程构造一个副本（没有找到官方这样的说法，但是从理解上，应该就是这样工作的，只会有一个线程使用到并行区域外的初始值，其余的都是0）。</li>
<li>每个线程使用自己的副本变量完成计算。</li>
<li>在退出并行区域时，对所有的线程的副本变量使用指定的操作符进行迭代操作，对于上面的例子，即sum’ = sum0’+sum1’+sum2’+sum3’.</li>
<li>将迭代的结果赋值给原来的变量（sum），sum=sum’.</li>
</ol>
<p>注意：</p>
<ul>
<li>reduction只能用于标量类型（int、float等等）；</li>
<li>reduction只用于一个区域构造或者工作共享构造的结构中，并且，在这个区域中，reduction的变量只能被用于类似如下的语句：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = x op expr </span><br><span class="line">x = expr op x (except subtraction) </span><br><span class="line">x binop = expr </span><br><span class="line">x++ </span><br><span class="line">++x </span><br><span class="line">x-- </span><br><span class="line">--x</span><br></pre></td></tr></table></figure>
<p>说明：经过测试，其实不符合这一规则的时候，编译运行都不会有问题，有些甚至也是可以解释清楚为什么结果是这样的，但是无论如何，一般使用reduction的时候，都是一些迭代的情况，语义应该是很清楚的情况。看下面的一个“错误”的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT 10</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, _TCHAR* argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">100</span>;		<span class="comment">// Assign an initial value.</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+:sum)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; COUNT; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		sum += i;</span><br><span class="line">		sum = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>,sum);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为104（4核机器）。这个例子，<code>sum=1;</code>这个表达式是不应该出现的，但是如果就这么写，编译运行都没问题，而且，这个结果甚至也算是预料中的。每一个线程计算结束后，其sum的值都是1，四个线程，然后初始值是100，所以最后结果是104。:) 无论如何，即使可以解释得通，相信也没有这样使用的场合，至少，不要依赖于这样的实现的结果。从这个错误的例子，反过来，我发现上面的关于”理解reduction的工作过程“似乎不太完全正确，其中第一步，进入并行区域后，初始值为”sum0=100,sum1 = sum2 = sum3 = 0“，如果这样，只是一个初始值，那么计算后，在这个例子里，所有线程的sum都是1，结果应该为4才对。所以看来，实际的理解应该是，主线程也会创建一个副本变量，其初始值也为0，在最后迭代的时候，是用sum原来的值和每个线程的副本进行计算。过程大概如下：</p>
<ol>
<li>sum=100</li>
<li>进入并行区域，创建4个线程的4个副本：sum0=sum1=sum2=sum3=0;</li>
<li>计算完成后，得到sum0’,sum1’,sum2’,sum3’</li>
<li>计算sum，sum=sum op sum 0‘ op sum1’ op sum2‘ op sum3’。</li>
</ol>
<p>总之，具体编译器是如何实现的并不重要，关键是理解reduction是如何工作的。</p>
<h1 id="OpenMP参考文档"><a href="#OpenMP参考文档" class="headerlink" title="OpenMP参考文档"></a>OpenMP参考文档</h1><p><img src="/img/OpenMPRef-5.0-111802-web_Page1.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page2.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page3.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page4.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page5.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page6.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page7.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page8.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page9.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page10.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page11.png" alt=""></p>
<p><img src="/img/OpenMPRef-5.0-111802-web_Page12.png" alt=""></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%A7%AF%E7%B4%AF/" rel="tag"># 积累</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/12/06/%E6%9C%89%E8%B6%A3%E7%9A%84cache%E6%B5%8B%E9%87%8F%E6%95%B0%E6%8D%AE/" rel="next" title="有趣的cache测量数据">
                <i class="fa fa-chevron-left"></i> 有趣的cache测量数据
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/12/14/Intel_MPI%E6%89%8B%E5%86%8C/" rel="prev" title="Intel MPI library developer reference for Linux">
                Intel MPI library developer reference for Linux <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">130</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-OpenMP%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">1. OpenMP基本介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-fork-join%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 fork&#x2F;join并行执行模式的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenMP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">OpenMP编程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">共享内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-HPC-%E4%B8%AD%E4%BD%BF%E7%94%A8-OpenMP-%E7%9A%84%E5%8A%A8%E6%9C%BA"><span class="nav-number">1.2.2.</span> <span class="nav-text">在 HPC 中使用 OpenMP 的动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%80%A7"><span class="nav-number">1.2.3.</span> <span class="nav-text">基于线程的并行性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%B9%B6%E8%A1%8C%E6%80%A7"><span class="nav-number">1.2.4.</span> <span class="nav-text">显式并行性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join-%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.5.</span> <span class="nav-text">Fork - Join 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4"><span class="nav-number">1.2.6.</span> <span class="nav-text">数据范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.7.</span> <span class="nav-text">动态线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O"><span class="nav-number">1.2.8.</span> <span class="nav-text">I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9A%E7%BB%8F%E5%B8%B8%E5%88%B7%E6%96%B0%EF%BC%9F"><span class="nav-number">1.2.9.</span> <span class="nav-text">内存模型：经常刷新？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-OpenMP%E7%BC%96%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">2. OpenMP编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-OpenMP%E6%8C%87%E4%BB%A4%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 OpenMP指令和库函数介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-OpenMP%E6%8C%87%E4%BB%A4%E5%88%97%E8%A1%A8"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 OpenMP指令列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-OpenMP%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 OpenMP库函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-OpenMP%E5%AD%90%E5%8F%A5"><span class="nav-number">2.4.</span> <span class="nav-text">2.3 OpenMP子句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">2.5.</span> <span class="nav-text">2.4 环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E7%BC%96%E8%AF%91-OpenMP-%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.6.</span> <span class="nav-text">2.5 编译 OpenMP 程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-OpenMP-API-%E6%A6%82%E8%BF%B0"><span class="nav-number">2.7.</span> <span class="nav-text">2.6 OpenMP API 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E6%9E%84%E6%88%90"><span class="nav-number">2.7.1.</span> <span class="nav-text">三大构成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">2.7.2.</span> <span class="nav-text">编译器指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93%E5%87%BD%E6%95%B0-Run-time-Library-Routines"><span class="nav-number">2.7.3.</span> <span class="nav-text">运行时库函数 Run-time Library Routines:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-OpenMP-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.</span> <span class="nav-text">2.7 OpenMP 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-C-%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.8.1.</span> <span class="nav-text">C&#x2F;C++ 指令格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E8%8C%83%E5%9B%B4"><span class="nav-number">2.8.2.</span> <span class="nav-text">指令范围</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81-%E8%AF%8D%E6%B3%95-%E8%8C%83%E5%9B%B4"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">静态(词法)范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A4%E7%AB%8B%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">孤立的指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4"><span class="nav-number">2.8.2.3.</span> <span class="nav-text">动态范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="nav-number">2.8.2.4.</span> <span class="nav-text">为什么这很重要？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%8C%BA%E5%9F%9F%E7%BB%93%E6%9E%84"><span class="nav-number">2.8.3.</span> <span class="nav-text">并行区域结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84"><span class="nav-number">2.8.3.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.8.3.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">2.8.3.3.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.8.3.4.</span> <span class="nav-text">有多少线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B-1"><span class="nav-number">2.8.3.5.</span> <span class="nav-text">动态线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E5%8F%A5"><span class="nav-number">2.8.3.6.</span> <span class="nav-text">子句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.8.3.7.</span> <span class="nav-text">限制条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%8C%BA%E5%9F%9F%E4%BE%8B%E5%AD%90"><span class="nav-number">2.8.3.8.</span> <span class="nav-text">并行区域例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%85%B1%E4%BA%AB%E7%BB%93%E6%9E%84"><span class="nav-number">2.8.3.9.</span> <span class="nav-text">工作共享结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6-1"><span class="nav-number">2.8.3.10.</span> <span class="nav-text">限制条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DO-for-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.3.11.</span> <span class="nav-text">DO &#x2F; for 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6-2"><span class="nav-number">2.8.3.11.1.</span> <span class="nav-text">限制条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DO-for-%E6%8C%87%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.8.3.11.2.</span> <span class="nav-text">DO &#x2F; for 指令示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sections-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.3.12.</span> <span class="nav-text">sections 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-1"><span class="nav-number">2.8.3.12.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%90%E5%8F%A5-1"><span class="nav-number">2.8.3.12.2.</span> <span class="nav-text">子句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6-3"><span class="nav-number">2.8.3.12.3.</span> <span class="nav-text">限制条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sections-%E6%8C%87%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.8.3.12.4.</span> <span class="nav-text">sections 指令示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#single-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.3.13.</span> <span class="nav-text">single 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-2"><span class="nav-number">2.8.3.13.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-1"><span class="nav-number">2.8.3.13.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%90%E5%8F%A5-2"><span class="nav-number">2.8.3.13.3.</span> <span class="nav-text">子句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6-4"><span class="nav-number">2.8.3.13.4.</span> <span class="nav-text">限制条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%B9%B6%E8%A1%8C%E5%B7%A5%E4%BD%9C%E5%85%B1%E4%BA%AB%E7%BB%93%E6%9E%84"><span class="nav-number">2.8.4.</span> <span class="nav-text">合并并行工作共享结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%84"><span class="nav-number">2.8.5.</span> <span class="nav-text">任务结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-3"><span class="nav-number">2.8.5.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-2"><span class="nav-number">2.8.5.2.</span> <span class="nav-text">格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%BB%93%E6%9E%84"><span class="nav-number">2.8.6.</span> <span class="nav-text">同步结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#master-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.6.1.</span> <span class="nav-text">master 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-4"><span class="nav-number">2.8.6.1.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-3"><span class="nav-number">2.8.6.1.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6-5"><span class="nav-number">2.8.6.1.3.</span> <span class="nav-text">限制条件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#critical-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.6.2.</span> <span class="nav-text">critical 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-5"><span class="nav-number">2.8.6.2.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-4"><span class="nav-number">2.8.6.2.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.8.6.2.3.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6-6"><span class="nav-number">2.8.6.2.4.</span> <span class="nav-text">限制条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#critical-%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.8.6.2.5.</span> <span class="nav-text">critical 结构示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#barrier-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.6.3.</span> <span class="nav-text">barrier 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-6"><span class="nav-number">2.8.6.3.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-5"><span class="nav-number">2.8.6.3.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6-7"><span class="nav-number">2.8.6.3.3.</span> <span class="nav-text">限制条件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#taskwait-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.6.4.</span> <span class="nav-text">taskwait 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-7"><span class="nav-number">2.8.6.4.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-6"><span class="nav-number">2.8.6.4.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6-8"><span class="nav-number">2.8.6.4.3.</span> <span class="nav-text">限制条件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#atomic-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.6.5.</span> <span class="nav-text">atomic 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-8"><span class="nav-number">2.8.6.5.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-7"><span class="nav-number">2.8.6.5.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6-9"><span class="nav-number">2.8.6.5.3.</span> <span class="nav-text">限制条件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flush-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.6.6.</span> <span class="nav-text">flush 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-9"><span class="nav-number">2.8.6.6.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-8"><span class="nav-number">2.8.6.6.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-number">2.8.6.6.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ordered-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.6.7.</span> <span class="nav-text">ordered 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-10"><span class="nav-number">2.8.6.7.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-9"><span class="nav-number">2.8.6.7.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6-10"><span class="nav-number">2.8.6.7.3.</span> <span class="nav-text">限制条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#threadprivate-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.7.</span> <span class="nav-text">threadprivate 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-11"><span class="nav-number">2.8.7.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-10"><span class="nav-number">2.8.7.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="nav-number">2.8.7.3.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.8.7.4.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6-11"><span class="nav-number">2.8.7.5.</span> <span class="nav-text">限制条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%B1%9E%E6%80%A7%E5%AD%90%E5%8F%A5"><span class="nav-number">2.8.8.</span> <span class="nav-text">数据范围属性子句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#private-%E5%AD%90%E5%8F%A5"><span class="nav-number">2.8.8.1.</span> <span class="nav-text">private 子句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-12"><span class="nav-number">2.8.8.1.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-11"><span class="nav-number">2.8.8.1.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="nav-number">2.8.8.1.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shared-%E5%AD%90%E5%8F%A5"><span class="nav-number">2.8.8.2.</span> <span class="nav-text">shared 子句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-13"><span class="nav-number">2.8.8.2.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-12"><span class="nav-number">2.8.8.2.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="nav-number">2.8.8.2.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#default-%E5%AD%90%E5%8F%A5"><span class="nav-number">2.8.8.3.</span> <span class="nav-text">default 子句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-14"><span class="nav-number">2.8.8.3.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-13"><span class="nav-number">2.8.8.3.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5"><span class="nav-number">2.8.8.3.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#firstprivate-%E5%AD%90%E5%8F%A5"><span class="nav-number">2.8.8.4.</span> <span class="nav-text">firstprivate 子句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-15"><span class="nav-number">2.8.8.4.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-14"><span class="nav-number">2.8.8.4.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-6"><span class="nav-number">2.8.8.4.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lastprivate-%E5%AD%90%E5%8F%A5"><span class="nav-number">2.8.8.5.</span> <span class="nav-text">lastprivate 子句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-16"><span class="nav-number">2.8.8.5.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-15"><span class="nav-number">2.8.8.5.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-7"><span class="nav-number">2.8.8.5.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copyin-%E5%AD%90%E5%8F%A5"><span class="nav-number">2.8.8.6.</span> <span class="nav-text">copyin 子句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-17"><span class="nav-number">2.8.8.6.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-16"><span class="nav-number">2.8.8.6.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-8"><span class="nav-number">2.8.8.6.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copyprivate-%E5%AD%90%E5%8F%A5"><span class="nav-number">2.8.8.7.</span> <span class="nav-text">copyprivate 子句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-18"><span class="nav-number">2.8.8.7.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-17"><span class="nav-number">2.8.8.7.2.</span> <span class="nav-text">格式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reduction-%E5%AD%90%E5%8F%A5"><span class="nav-number">2.8.8.8.</span> <span class="nav-text">reduction 子句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84-19"><span class="nav-number">2.8.8.8.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-18"><span class="nav-number">2.8.8.8.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Example-REDUCTION-Vector-Dot-Product"><span class="nav-number">2.8.8.8.3.</span> <span class="nav-text">Example: REDUCTION - Vector Dot Product:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6-12"><span class="nav-number">2.8.8.8.4.</span> <span class="nav-text">限制条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%BB%91%E5%AE%9A%E5%92%8C%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99"><span class="nav-number">2.8.9.</span> <span class="nav-text">指令绑定和嵌套规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%BB%91%E5%AE%9A"><span class="nav-number">2.8.9.1.</span> <span class="nav-text">指令绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%B5%8C%E5%A5%97"><span class="nav-number">2.8.9.2.</span> <span class="nav-text">指令嵌套</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%BB%91%E5%AE%9A"><span class="nav-number">2.9.</span> <span class="nav-text">2.8 线程堆栈大小和线程绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.9.1.</span> <span class="nav-text">线程堆栈大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%91%E5%AE%9A"><span class="nav-number">2.9.2.</span> <span class="nav-text">线程绑定</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-OpenMP%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.</span> <span class="nav-text">3. OpenMP详细代码示例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-hello-openmp-cpp"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 hello_openmp.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-header-and-env-cpp"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 header_and_env.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-parallel-cpp"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 parallel.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-parallel-cout-cpp"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 parallel_cout.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-nested-cpp"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 nested.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-parallel-for-cpp"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 parallel-for.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-scoping-cpp"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 scoping.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-firstprivate-cpp"><span class="nav-number">3.8.</span> <span class="nav-text">3.8 firstprivate.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-lastprivate-cpp"><span class="nav-number">3.9.</span> <span class="nav-text">3.9 lastprivate.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-single-master-critical-cpp"><span class="nav-number">3.10.</span> <span class="nav-text">3.10 single-master-critical.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-11-mutex-cpp"><span class="nav-number">3.11.</span> <span class="nav-text">3.11 mutex.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-12-barrier-cpp"><span class="nav-number">3.12.</span> <span class="nav-text">3.12 barrier.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-13-atomic-cpp"><span class="nav-number">3.13.</span> <span class="nav-text">3.13 atomic.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-14-reduction-cpp"><span class="nav-number">3.14.</span> <span class="nav-text">3.14 reduction.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-15-scheduling-cpp"><span class="nav-number">3.15.</span> <span class="nav-text">3.15 scheduling.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-16-ordered-cpp"><span class="nav-number">3.16.</span> <span class="nav-text">3.16 ordered.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-17-loop-dependencies-cpp"><span class="nav-number">3.17.</span> <span class="nav-text">3.17 loop-dependencies.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-18-sections-cpp"><span class="nav-number">3.18.</span> <span class="nav-text">3.18 sections.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-19-threadprivate-cpp"><span class="nav-number">3.19.</span> <span class="nav-text">3.19 threadprivate.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-20-Copyin-cpp"><span class="nav-number">3.20.</span> <span class="nav-text">3.20 Copyin.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-21-Copyprivate-cpp"><span class="nav-number">3.21.</span> <span class="nav-text">3.21 Copyprivate.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-22-nowait-cpp"><span class="nav-number">3.22.</span> <span class="nav-text">3.22 nowait.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-23-task"><span class="nav-number">3.23.</span> <span class="nav-text">3.23 task</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-25-flush-cpp"><span class="nav-number">3.24.</span> <span class="nav-text">3.25 flush.cpp</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OpenMP%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3%E5%AD%90%E5%8F%A5%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">OpenMP中数据属性相关子句详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#private-firstprivate-lastprivate-threadprivate%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">4.1.</span> <span class="nav-text">private&#x2F;firstprivate&#x2F;lastprivate&#x2F;threadprivate之间的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#private"><span class="nav-number">4.1.1.</span> <span class="nav-text">private</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#firstprivate"><span class="nav-number">4.1.2.</span> <span class="nav-text">firstprivate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lastprivate"><span class="nav-number">4.1.3.</span> <span class="nav-text">lastprivate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#threadprivate"><span class="nav-number">4.1.4.</span> <span class="nav-text">threadprivate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.1.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shared-default-copyin-copyprivate%E5%AD%90%E5%8F%A5%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">shared&#x2F;default&#x2F;copyin&#x2F;copyprivate子句的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shared"><span class="nav-number">4.2.1.</span> <span class="nav-text">shared</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#default"><span class="nav-number">4.2.2.</span> <span class="nav-text">default</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copyin"><span class="nav-number">4.2.3.</span> <span class="nav-text">copyin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copyprivate"><span class="nav-number">4.2.4.</span> <span class="nav-text">copyprivate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reduction%E5%AD%90%E5%8F%A5"><span class="nav-number">4.3.</span> <span class="nav-text">reduction子句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OpenMP%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-number">5.</span> <span class="nav-text">OpenMP参考文档</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
