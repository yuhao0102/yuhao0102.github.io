<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zn-ch">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux," />










<meta name="description" content="Ext2 文件系统Ext2(第二扩充文件系统)是一种功能强大、易扩充、性能上进行了全面的优化的文件系统，也是当前Linux文件系统实际上的标准。 Ext2有如下几方面的特点。  它的节点中使用了 15 个数据块指针，这样它最大可支持4TB的磁盘分区。 它使用变长的目录项，这样既可以不浪费磁盘空间，又能支持最长 255 个字符的文件名。 使用位图来管理数据块和节点的使用情况，解决了Ext出现的问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="深入分析Linux内核源码笔记4">
<meta property="og:url" content="http://yoursite.com/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B04/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Ext2 文件系统Ext2(第二扩充文件系统)是一种功能强大、易扩充、性能上进行了全面的优化的文件系统，也是当前Linux文件系统实际上的标准。 Ext2有如下几方面的特点。  它的节点中使用了 15 个数据块指针，这样它最大可支持4TB的磁盘分区。 它使用变长的目录项，这样既可以不浪费磁盘空间，又能支持最长 255 个字符的文件名。 使用位图来管理数据块和节点的使用情况，解决了Ext出现的问题。">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1634038822.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634038883.jpg">
<meta property="article:published_time" content="2021-10-09T08:00:00.000Z">
<meta property="article:modified_time" content="2021-10-13T08:19:48.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1634038822.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/10/09/深入分析LINUX内核源码 笔记4/"/>





  <title>深入分析Linux内核源码笔记4 | Hao Yu's blog</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入分析Linux内核源码笔记4</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-10-09T16:00:00+08:00">
                2021-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Ext2-文件系统"><a href="#Ext2-文件系统" class="headerlink" title="Ext2 文件系统"></a>Ext2 文件系统</h1><p>Ext2(第二扩充文件系统)是一种功能强大、易扩充、性能上进行了全面的优化的文件系统，也是当前<code>Linux</code>文件系统实际上的标准。</p>
<p><code>Ext2</code>有如下几方面的特点。</p>
<ul>
<li>它的节点中使用了 15 个数据块指针，这样它最大可支持<code>4TB</code>的磁盘分区。</li>
<li>它使用变长的目录项，这样既可以不浪费磁盘空间，又能支持最长 255 个字符的文件名。</li>
<li>使用位图来管理数据块和节点的使用情况，解决了<code>Ext</code>出现的问题。</li>
<li>最重要的一点是，它在磁盘上的布局做了改进，即使用了块组的概念，从而使数据的读和写更快、更有效，也便系统变得更安全可靠。</li>
<li>易于扩展。</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>具体文件系统管理的是一个逻辑空间，这个逻辑空间就像一个大的数组，数组的每个元素就是文件系统操作的基本单位——逻辑块，逻辑块是从 0 开始编号的，而且，逻辑块是连续的。</p>
<p>与逻辑块相对的是物理块，物理块是数据在磁盘上的存取单位，也就是每进行一次<code>I/O</code>操作，最小传输的数据大小。如果物理块定的比较大，比如一个柱面大小，这时，即使是 1 个字节的文件都要占用整个一个柱面，大的存取单位将带来严重的磁盘空间浪费。另一方面，如果物理块过小，则意味着对一个文件的操作将进行更多次的寻道延迟和旋转延迟。</p>
<p>因此，最优的方法是计算出<code>Linux</code>环境下文件的平均大小，然后将物理块大小定为最接近扇区的整数倍大小。</p>
<p>假设用户要对一个已有文件进行写操作，用户进程必须先打开这个文件，<code>file</code>结构记录了该文件的当前位置。然后用户把一个指向用户内存区的指针和请求写的字节数传送给系统，请求写操作，这时系统要进行两次映射。</p>
<ol>
<li>一组字节到逻辑块的映射。这个映射过程就是找到起始字节到结束字节所占用的所有逻辑块号。这是因为在逻辑空间，文件传输的基本单位是逻辑块而不是字节。</li>
<li>逻辑块到物理块的映射。这个过程必须要用到索引节点结构，该结构中有一个物理块指针数组，以逻辑块号为索引，通过这些指针找到磁盘上的物理块，具体实现将在介绍<code>Ext2</code>索引节点时再进行介绍。</li>
</ol>
<p>每个文件必然占用整数个逻辑块，除非每个文件大小都恰好是逻辑块的整数倍，否则最后一个逻辑块必然有空间未被使用，实际上，每个文件的最后一个逻辑块平均要浪费一半的空间，显然最终浪费的还是物理块。在一个有很多文件的系统中，这种浪费是很大的。Ext2使用片来解决这个问题。 </p>
<p>片也是一个逻辑空间中的概念，其大小在<code>1KB</code>至<code>4KB</code>之间，但片的大小总是不大于逻辑块。假设逻辑块大小为 4KB，片大小为 1KB，物理块大小也是 1KB，当你要创建一个<code>3KB</code>大小的文件时，实际上分配给你了 3 个片，而不会给你一个逻辑块，当文件大小增加到<code>4KB</code>时，文件系统则分配一个逻辑块给你，而原来的四个片被清空。如果文件又增加到<code>5KB</code>时，则占用 1 个逻辑块和 1 个片。上述 3 种情况下，所占用的物理块分别是 3 个、4 个、5 个，如果不采用片，则要用到 4 个、4 个、8 个物理块，可见，使用片，减少了磁盘空间的浪费。当然，在物理块和逻辑块大小一样时，片就没有意义了。</p>
<p>由上面分析也可看出：物理块大小&lt;=片大小&lt;=逻辑块大小</p>
<h2 id="Ext2-的磁盘布局和数据结构"><a href="#Ext2-的磁盘布局和数据结构" class="headerlink" title="Ext2 的磁盘布局和数据结构"></a>Ext2 的磁盘布局和数据结构</h2><h3 id="Ext2-的磁盘布局"><a href="#Ext2-的磁盘布局" class="headerlink" title="Ext2 的磁盘布局"></a>Ext2 的磁盘布局</h3><p>文件系统的逻辑空间最终要通过逻辑块到物理块的映射转化为磁盘等介质上的物理空间，因此，对逻辑空间的组织和管理的好坏必然影响到物理空间的使用情况。一个文件系统，在磁盘上如何布局，要综合考虑以下几个方面的因素。 </p>
<ul>
<li>首先也是最重要的是要保证数据的安全性，也就是说当在向磁盘写数据时发生错误，要能保证文件系统不遭到破坏。</li>
<li>其次，数据结构要能高效地支持所有的操作。Ext2 中，最复杂的操作是硬链接操作。硬链接允许一个文件有多个名称，通过任何一个名称都将访问相同的数据。另一个比较复杂的操作是删除一个已打开的文件。</li>
<li>第三，磁盘布局应使数据查找的时间尽量短，以提高效率。驱动器查找分散的数据要比查找相邻的数据花多得多的时间。一个好的磁盘布局应该让相关的数据尽量连续分布。例如，同一个文件的数据应连续分布，并和包含该文件的目录文件相邻。</li>
<li>最后，磁盘布局应该考虑节省空间。虽然现在节省磁盘空间已不太重要，但也不应该无谓地浪费磁盘空间。</li>
</ul>
<p>Ext2 的磁盘布局在逻辑空间中的映像由一个引导块和重复的块组构成的，每个块组又由超级块、组描述符表、块位图、索引节点位图、索引节点表、数据区构成。引导块中含有可执行代码，启动计算机时，硬件从引导设备将引导块读入内存，然后执行它的代码。系统启动后，引导块不再使用。因此，引导块不属于文件系统管理。</p>
<h3 id="Ext2-的超级块"><a href="#Ext2-的超级块" class="headerlink" title="Ext2 的超级块"></a>Ext2 的超级块</h3><p>Ext2 超级块是用来描述<code>Ext2</code>文件系统整体信息的数据结构，是<code>Ext2</code>的核心所在。它是一个<code>ext2_super_block</code>数据结构(在<code>include/Linux/ext2_fs.h</code>中定义)，其各个域及含义如下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_super_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__u32 s_inodes_count; <span class="comment">/*文件系统中索引节点总数 */</span></span><br><span class="line">	__u32 s_blocks_count; <span class="comment">/*文件系统中总块数 */</span></span><br><span class="line">	__u32 s_r_blocks_count; <span class="comment">/*为超级用户保留的块数 */</span></span><br><span class="line">	__u32 s_free_blocks_count; <span class="comment">/*文件系统中空闲块总数 */</span></span><br><span class="line">	__u32 s_free_inodes_count; <span class="comment">/*文件系统中空闲索引节点总数*/</span></span><br><span class="line">	__u32 s_first_data_block; <span class="comment">/* 文件系统中第一个数据块 */</span></span><br><span class="line">	__u32 s_log_block_size; <span class="comment">/* 用于计算逻辑块大小 */</span> </span><br><span class="line">	__s32 s_log_frag_size; <span class="comment">/* 用于计算片大小 */</span></span><br><span class="line">	__u32 s_blocks_per_group; <span class="comment">/* 每组中块数 */</span></span><br><span class="line">	__u32 s_frags_per_group; <span class="comment">/* 每组中片数 */</span></span><br><span class="line">	__u32 s_inodes_per_group; <span class="comment">/* 每组中索引节点数 */</span></span><br><span class="line">	__u32 s_mtime; <span class="comment">/*最后一次安装操作的时间 */</span></span><br><span class="line">	__u32 s_wtime; <span class="comment">/*最后一次对该超级块进行写操作的时间 */</span></span><br><span class="line">	__u16 s_mnt_count; <span class="comment">/* 安装计数 */</span></span><br><span class="line">	__s16 s_max_mnt_count; <span class="comment">/* 最大可安装计数 */</span></span><br><span class="line">	__u16 s_magic; <span class="comment">/* 用于确定文件系统版本的标志 */</span></span><br><span class="line">	__u16 s_state; <span class="comment">/* 文件系统的状态*/</span></span><br><span class="line">	__u16 s_errors; <span class="comment">/* 当检测到有错误时如何处理 */</span></span><br><span class="line">	__u16 s_minor_rev_level; <span class="comment">/* 次版本号 */</span></span><br><span class="line">	__u32 s_lastcheck; <span class="comment">/* 最后一次检测文件系统状态的时间 */</span></span><br><span class="line">	__u32 s_checkinterval; <span class="comment">/* 两次对文件系统状态进行检测的间隔时间 */</span></span><br><span class="line">	__u32 s_rev_level; <span class="comment">/* 版本号 */</span></span><br><span class="line">	__u16 s_def_resuid; <span class="comment">/* 保留块的默认用户标识号 */</span></span><br><span class="line">	__u16 s_def_resgid; <span class="comment">/* 保留块的默认用户组标识号*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* These fields are for EXT2_DYNAMIC_REV superblocks only.</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* Note: the difference between the compatible feature set and</span></span><br><span class="line"><span class="comment">	* the incompatible feature set is that if there is a bit set</span></span><br><span class="line"><span class="comment">	* in the incompatible feature set that the kernel doesn&#x27;t</span></span><br><span class="line"><span class="comment">	* know about, it should refuse to mount the filesystem.</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* e2fsck&#x27;s requirements are more strict; if it doesn&#x27;t know</span></span><br><span class="line"><span class="comment">	* about a feature in either the compatible or incompatible</span></span><br><span class="line"><span class="comment">	* feature set, it must abort and not try to meddle with</span></span><br><span class="line"><span class="comment">	* things it doesn&#x27;t understand...</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	__u32 s_first_ino; <span class="comment">/* 第一个非保留的索引节点 */</span></span><br><span class="line">	__u16 s_inode_size; <span class="comment">/* 索引节点的大小 */</span></span><br><span class="line">	__u16 s_block_group_nr; <span class="comment">/* 该超级块的块组号 */</span></span><br><span class="line">	__u32 s_feature_compat; <span class="comment">/* 兼容特点的位图*/</span></span><br><span class="line">	__u32 s_feature_incompat; <span class="comment">/* 非兼容特点的位图 */</span></span><br><span class="line">	__u32 s_feature_ro_compat; <span class="comment">/* 只读兼容特点的位图*/</span></span><br><span class="line">	__u8 s_uuid[<span class="number">16</span>]; <span class="comment">/* 128 位的文件系统标识号*/</span></span><br><span class="line">	<span class="type">char</span> s_volume_name[<span class="number">16</span>]; <span class="comment">/* 卷名 */</span></span><br><span class="line">	<span class="type">char</span> s_last_mounted[<span class="number">64</span>]; <span class="comment">/* 最后一个安装点的路径名 */</span></span><br><span class="line">	__u32 s_algorithm_usage_bitmap; <span class="comment">/* 用于压缩*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Performance hints. Directory preallocation should only</span></span><br><span class="line"><span class="comment">	* happen if the EXT2_COMPAT_PREALLOC flag is on.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	__u8 s_prealloc_blocks; <span class="comment">/* 预分配的块数*/</span></span><br><span class="line">	__u8 s_prealloc_dir_blocks; <span class="comment">/* 给目录预分配的块数 */</span></span><br><span class="line">	__u16 s_padding1;</span><br><span class="line">	__u32 s_reserved[<span class="number">204</span>]; <span class="comment">/* 用`NULL`填充块的末尾 */</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>从中我们可以看出，这个数据结构描述了整个文件系统的信息，下面对其中一些域作一些解释。</p>
<ul>
<li>文件系统中并非所有的块普通用户都可以使用，有一些块是保留给超级用户专用的，这些块的数目就是在<code>s_r_blocks_count</code>中定义的。一旦空闲块总数等于保留块数，普通用户无法再申请到块了。如果保留块也被使用，则系统就可能无法启动了。有了保留块，我们就可以确保一个最小的空间用于引导系统。</li>
<li>逻辑块是从 0 开始编号的，对块大小为<code>1KB</code>的文件系统，<code>s_first_data_block</code>为 1，对其他文件系统，则为 0。</li>
<li><code>s_log_block_size</code>是一个整数，以 2 的幂次方表示块的大小，用 1024 字节作为单位。因此，0 表示 1024 字节的块，1 表示 2048 字节的块，如此等等。同样，片的大小计算方法也是类似的，因为<code>Ext2</code>中还没有实现片，因此，<code>s_log_frag_size</code>与<code>s_log_block_size</code>相等。</li>
<li>Ext2 要定期检查自己的状态，它的状态取下面两个值之一。<ul>
<li><code>#define EXT2_VALID_FS 0x0001</code>文件系统没有出错。</li>
<li><code>#define EXT2_ERROR_FS 0x0002</code>内核检测到错误。</li>
<li><code>s_lastcheck</code>就是用来记录最近一次检查状态的时间，而<code>s_checkinterval</code>则规定了两次检查状态的最大允许间隔时间。</li>
</ul>
</li>
<li>如果检测到文件系统有错误，则对<code>s_errors</code>赋一个错误值。一个好的系统应该能在错误发生时进行正确处理，有关<code>Ext2</code>如何处理错误将在后面介绍。</li>
</ul>
<p>超级块被读入内存后，主要用于填写<code>VFS</code>的超级块，此外，它还要用来填写另外一个结构，这就是<code>ext2_super_info</code>结构，这一点我们可以从有关<code>Ext2</code>超级块的操作中看出，比如<code>ext2_read_super()</code>。之所以要用到这个结构，是因为<code>VFS</code>的超级块必须兼容各种文件系统的不同的超级块结构，所以对某个文件系统超级块自己的特性必须用另一个结构保存于内存中，以加快对文件的操作，比如对Ext2 来说，片就是它特有的，所以不能存储在<code>VFS</code>超级块中。</p>
<p>Ext2 中的这个结构是<code>ext2_super_info</code>，它其中的信息多是从磁盘上的索引节点计算得来的 。该结构定义于<code>include/Linux/ext2_fs_sb.h</code>，下面是该结构及各个域含义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_sb_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_frag_size; <span class="comment">/* 片大小(以字节计) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_frags_per_block; <span class="comment">/* 每块中片数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_inodes_per_block; <span class="comment">/* 每块中节点数*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_frags_per_group; <span class="comment">/* 每组中片数*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_blocks_per_group; <span class="comment">/* 每组中块数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_inodes_per_group; <span class="comment">/*每组中节点数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_itb_per_group; <span class="comment">/* 每组中索引节点表所占块数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_db_per_group; <span class="comment">/* 每组中组描述符所在块数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_desc_per_block; <span class="comment">/* 每块中组描述符数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_groups_count; <span class="comment">/* 文件系统中块组数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_sbh</span>;</span> <span class="comment">/* 指向包含超级块的缓存 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> ** <span class="title">s_group_desc</span>;</span> <span class="comment">/* 指向高速缓存中组描述符表块的指针数组的一个指针 */</span> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_loaded_inode_bitmaps; <span class="comment">/* 装入高速缓存中的节点位图块数*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_loaded_block_bitmaps; <span class="comment">/*装入高速缓存中的块位图块数*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_inode_bitmap_number[Ext2_MAX_GROUP_LOADED];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_inode_bitmap</span>[<span class="title">Ext2_MAX_GROUP_LOADED</span>];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_block_bitmap_number[Ext2_MAX_GROUP_LOADED];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_block_bitmap</span>[<span class="title">Ext2_MAX_GROUP_LOADED</span>];</span></span><br><span class="line">	<span class="type">int</span> s_rename_lock; <span class="comment">/*重命名时的锁信号量*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wait_queue</span> * <span class="title">s_rename_wait</span>;</span> <span class="comment">/*指向重命名时的等待队列*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_mount_opt; <span class="comment">/*安装选项*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_resuid; <span class="comment">/*默认的用户标识号*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_resgid; <span class="comment">/* 默认的用户组标识号*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_mount_state; <span class="comment">/*专用于管理员的安装选项*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> s_pad; <span class="comment">/*填充*/</span></span><br><span class="line">	<span class="type">int</span> s_inode_size; <span class="comment">/*节点的大小*/</span></span><br><span class="line">	<span class="type">int</span> s_first_ino; <span class="comment">/*第一个节点号*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>s_block_bitmap_number[]</code>、<code>s_block_bitmap[]</code>、<code>s_inode_bitmap_number[]</code>、<code>s_inode_bitmap[]</code>是用来管理位图块高速缓存的。</p>
<p>另外，由于每个文件系统的组描述符表可能占多个块，这些块进入缓存后，用一个指针数组分别指向它们在缓存中的地址，而<code>s_group_desc</code>则是用来指向这个数组的，用相对于组描述符表首块的块数作索引，就可以找到指定的组描述符表块。</p>
<p><img src="/img/1634038822.jpg" alt=""><br>图 9.3 是 3 个与超级块相关的数据结构的关系示意图。</p>
<h3 id="Ext2-的索引节点"><a href="#Ext2-的索引节点" class="headerlink" title="Ext2 的索引节点"></a>Ext2 的索引节点</h3><p>Ext2使用索引节点来记录文件信息。每一个普通文件和目录都有唯一的索引节点与之对应，索引节点中含有文件或目录的重要信息。当你要访问一个文件或目录时，通过文件或目录名首先找到与之对应的索引节点，然后通过索引节点得到文件或目录的信息及磁盘上的具体的存储位置。Ext2 的索引节点的数据结构叫<code>ext2_inode</code>，在<code>include/Linux/ext2_fs.h</code>中定义，下面是其结构及各个域的含义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_inode</span> &#123;</span></span><br><span class="line">	__u16 i_mode; <span class="comment">/* 文件类型和访问权限 */</span></span><br><span class="line">	__u16 i_uid; <span class="comment">/* 文件拥有者标识号*/</span></span><br><span class="line">	__u32 i_size; <span class="comment">/* 以字节计的文件大小 */</span></span><br><span class="line">	__u32 i_atime; <span class="comment">/* 文件的最后一次访问时间 */</span></span><br><span class="line">	__u32 i_ctime; <span class="comment">/* 该节点最后被修改时间 */</span></span><br><span class="line">	__u32 i_mtime; <span class="comment">/* 文件内容的最后修改时间 */</span></span><br><span class="line">	__u32 i_dtime; <span class="comment">/* 文件删除时间 */</span></span><br><span class="line">	__u16 i_gid; <span class="comment">/* 文件的用户组标志符 */</span></span><br><span class="line">	__u16 i_links_count; <span class="comment">/* 文件的硬链接计数 */</span></span><br><span class="line">	__u32 i_blocks; <span class="comment">/* 文件所占块数(每块以 512 字节计)*/</span></span><br><span class="line">	__u32 i_flags; <span class="comment">/* 打开文件的方式 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> /* 特定操作系统的信息 */</span></span><br><span class="line"><span class="class">	__<span class="title">u32</span> <span class="title">i_block</span>[<span class="title">Ext2_N_BLOCKS</span>];</span> <span class="comment">/* 指向数据块的指针数组 */</span></span><br><span class="line">	__u32 i_version; <span class="comment">/* 文件的版本号(用于`NFS) */</span></span><br><span class="line">	__u32 i_file_acl; <span class="comment">/*文件访问控制表(已不再使用) */</span></span><br><span class="line">	__u32 i_dir_acl; <span class="comment">/*目录访问控制表(已不再使用)*/</span></span><br><span class="line">	__u8 l_i_frag; <span class="comment">/* 每块中的片数 */</span></span><br><span class="line">	__u32 i_faddr; <span class="comment">/* 片的地址 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> /*特定操作系统信息*/</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>从中可以看出，索引节点是用来描述文件或目录信息的。</p>
<p>以下，对其中一些域作一定解释。</p>
<ul>
<li>前面说过，Ext2 通过索引节点中的数据块指针数组进行逻辑块到物理块的映射。在Ext2 索引节点中，数据块指针数组共有 15 项，前 12 个为直接块指针，后 3 个分别为“一次间接块指针”、“二次间接块指针”、“三次间接块指针”，如图 9.4 所示。</li>
</ul>
<p><img src="/img/1634038883.jpg" alt=""></p>
<p>所谓“直接块”，是指该块直接用来存储文件的数据，而“一次间接块”是指该块不存储数据，而是存储直接块的地址。这里所说的块，指的都是物理块。Ext2 默认的物理块大小为 1KB，块地址占 4 个字节(32 位)，所以每个物理块可以存储 256 个地址。这样，文件大小最大可达 12KB+256KB+ 64MB+16GB。</p>
<p>系统是以逻辑块号为索引查找物理块的。例如，要找到第 100 个逻辑块对应的物理块，因为 256+12&gt;100+12，所以要用到一次间接块，在一次间接块中查找第 88 项，此项内容就是对应的物理块的地址。而如果要找第 1000 个逻辑块对应的物理块，由于 1000&gt;256+12，所以要用到二次间接块了。</p>
<ul>
<li><p>索引节点的标志(flags)取下列几个值的可能组合。</p>
<ul>
<li><code>EXT2_SECRM_FL</code> <code>0x00000001</code>：完全删除标志。设置这个标志后，删除文件时，随机数据会填充原来的数据块。</li>
<li><code>EXT2_UNRM_FL</code> <code>0x00000002</code>：可恢复标志。设置这个标志后，删除文件时，文件系统会保留足够信息，以确保文件仍能恢复(仅在一段时间内)。</li>
<li><code>EXT2_COMR_FL</code> <code>0x00000004</code>：压缩标志。设置这个标志后，表明该文件被压缩过。当访问该文件时，文件系统必须采用解压缩算法进行解压。</li>
<li><code>EXT2_SYNC_FL</code> <code>0x00000008</code>：同步更新标志。设置该标志后，则该文件必须和内存中的内容保持一致，对这种文件进行异步输入、输出操作是不允许的。这个标志仅用于节点本身和间接块。数据块总是异步写入磁盘的。</li>
</ul>
</li>
<li><p>索引节点在磁盘上是经过编号的。其中，有一些节点有特殊用途，用户不能使用。这些特殊节点也在<code>include/Linux/ext2_fs.h</code>中定义。</p>
<ul>
<li><code>#define EXT2_BAD_INO 1</code>：该节点所对应的文件中包含着该文件系统中坏块的链接表。</li>
<li><code>#define EXT2_ROOT_INO 2</code>：该文件系统的根目录所对应的节点。</li>
<li><code>#define EXT2_IDX_INO 3</code>：ACL(访问控制链表)节点。</li>
<li><code>#define EXT2_DATA_INO 4</code>：ACL节点。</li>
<li><code>#define EXT2_BOOT_LOADER_INO 5</code>：用于引导系统的文件所对应的节点。</li>
<li><code>#define EXT2_UNDEL_DIR_INO 6</code>：文件系统中可恢复的目录对应的节点。</li>
<li><code>#define EXT2_FIRST_INO 11</code>：没有特殊用途的第一个节点号为 11。</li>
</ul>
</li>
</ul>
<p>与 Ext2 超级块类似，当磁盘上的索引节点调入内存后，除了要填写<code>VFS</code>的索引节点外，系统还要根据它填写另一个数据结构，该结构叫<code>ext2_inode_info</code>，其作用也是为了存储特定文件系统自己的特性，它在<code>include/Linux/ext2_fs_i.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_inode_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__u32 i_data[<span class="number">15</span>]; <span class="comment">/*数据块指针数组*/</span></span><br><span class="line">	__u32 i_flags; <span class="comment">/*打开文件的方式*/</span></span><br><span class="line">	__u32 i_faddr; <span class="comment">/*片的地址*/</span></span><br><span class="line">	__u8 i_frag_no; <span class="comment">/*如果用到片，则是第一个片号*/</span></span><br><span class="line">	__u8 i_frag_size; <span class="comment">/*片大小*/</span></span><br><span class="line">	__u16 i_osync; <span class="comment">/*同步*/</span></span><br><span class="line">	__u32 i_file_acl; <span class="comment">/*文件访问控制链表*/</span></span><br><span class="line">	__u32 i_dir_acl; <span class="comment">/*目录访问控制链表*/</span></span><br><span class="line">	__u32 i_dtime; <span class="comment">/*文件的删除时间*/</span></span><br><span class="line">	__u32 i_block_group; <span class="comment">/*索引节点所在的块组号*/</span></span><br><span class="line">	<span class="comment">/******以下四个域是用于操作预分配块的*************/</span></span><br><span class="line">	__u32 i_next_alloc_block;</span><br><span class="line">	__u32 i_next_alloc_goal;</span><br><span class="line">	__u32 i_prealloc_block;</span><br><span class="line">	__u32 i_prealloc_count;</span><br><span class="line">	__u32 i_dir_start_lookup</span><br><span class="line">	<span class="type">int</span> i_new_inode:<span class="number">1</span> <span class="comment">/* Is a freshly allocated inode */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>VFS</code>索引节点中是没有物理块指针数组的域，这个<code>Ext2</code>特有的域在调入内存后，就必须保存在<code>ext2_inode_info</code>这个结构中。此外，片作为<code>Ext2</code>比较特殊的地方，在<code>ext2_inode_info</code>中也保存了一些相关的域。另外，<code>Ext2</code>在分配一个块时通常还要预分配几个连续的块，因为它判断这些块很可能将要被访问，所以采用预分配的策略可以减少磁头的寻道时间。这些用于预分配操作的域也被保存在<code>ext2_inode_info</code>结构中。</p>
<h3 id="组描述符"><a href="#组描述符" class="headerlink" title="组描述符"></a>组描述符</h3><p>块组中，紧跟在超级块后面的是组描述符表，其每一项称为组描述符，是一个叫<code>ext2_group_desc</code>的数据结构，共 32 字节。它是用来描述某个块组的整体信息的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_group_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__u32 bg_block_bitmap; <span class="comment">/*组中块位图所在的块号 */</span></span><br><span class="line">	__u32 bg_inode_bitmap; <span class="comment">/*组中索引节点位图所在块的块号 */</span></span><br><span class="line">	__u32 bg_inode_table; <span class="comment">/*组中索引节点表的首块号 */</span></span><br><span class="line">	__u16 bg_free_blocks_count; <span class="comment">/*组中空闲块数 */</span></span><br><span class="line">	__u16 bg_free_inodes_count; <span class="comment">/* 组中空闲索引节点数 */</span></span><br><span class="line">	__u16 bg_used_dirs_count; <span class="comment">/*组中分配给目录的节点数 */</span></span><br><span class="line">	__u16 bg_pad; <span class="comment">/*填充，对齐到字*/</span></span><br><span class="line">	__u32［<span class="number">3</span>］ bg_reserved; <span class="comment">/*用NULL填充 12 个字节*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个块组都有一个相应的组描述符来描述它，所有的组描述符形成一个组描述符表，组描述符表可能占多个数据块。组描述符就相当于每个块组的超级块，一旦某个组描述符遭到破坏，整个块组将无法使用，所以组描述符表也像超级块那样，在每个块组中进行备份，以防遭到破坏。组描述符表所占的块和普通的数据块一样，在使用时被调入块高速缓存。</p>
<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>在 Ext2 中，是采用位图来描述数据块和索引节点的使用情况的，每个块组中都有两个块，一个用来描述该组中数据块的使用情况，另一个描述该组中索引节点的使用情况。这两个块分别称为数据位图块和索引节点位图块。数据位图块中的每一位表示该组中一个块的使用情况，如果为 0，则表示相应数据块空闲，为 1，则表示已分配，索引节点位图块的使用情况类似。</p>
<p>Ext2 在安装后，用两个高速缓存分别来管理这两种位图块。每个高速缓存最多同时只能装入<code>Ext2_MAX_GROUP_LOADED</code>个位图块或索引节点块，当前该值定义为 8，所以也应该采用一些算法来管理这两个高速缓存，<code>Ext2</code>中采用的算法类似于<code>LRU</code>算法。</p>
<p>前面说过，<code>ext2_sp_info</code>结构中有 4 个域用来管理这两个高速缓存，其中<code>s_block_bitmap_number[]</code>数组中存有进入高速缓存的位图块号(即块组号，因为一个块组中只有一个位图块)，而<code>s_block_bitmap[]</code>数组则存储了相应的块在高速缓存中的地址。<code>s_inode_bitmap_number[]</code>和<code>s_inode_bitmap[]</code>数组的作用类似上面。</p>
<p>我们通过一个具体的函数来看<code>Ext2</code>如何通过这 4 个域管理位图块管理高速缓存。在<code>Linux/fs/ext2/balloc.c</code>中，有一个函数<code>load__block_bitmap()</code>，它用来调入指定的数据位图块，下面是它的执行过程。 </p>
<ul>
<li>如果指定的块组号大于块组数，出错，结束。</li>
<li>通过搜索<code>s_block_bitmap_number[]</code>数组可知位图块是否已进入高速缓存，如果已进入，则结束，否则，继续；</li>
<li>如果块组数不大于<code>Ext2_MAX_GROUP_LOADED</code>，高速缓存可以同时装入所有块组的数据块位图块，不用采用什么算法，只要找到<code>s_block_bitmap_number[]</code>数组中第一个空闲元素，将块组号写入，然后将位图块调入高速缓存，最后将它在高速缓存中的地址写入<code>s_block_bitmap[]</code>数组中。</li>
<li>如果块组数大于<code>Ext2_MAX_GROUP_LOADED</code>，则需要采用以下算法：<ul>
<li>首先通过<code>s_block_bitmap_number[]</code>数组判断高速缓存是否已满，若未满，则操作过程类似上一步，不同之处在于需要将<code>s_block_bitmap_number[]</code>数组各元素依次后移一位，而用空出的第一个元素存储块组号，<code>s_block_bitmap[]</code>也要做相同处理；</li>
<li>如果高速缓存已满，则将<code>s_block_bitmap[]</code>数组最后一项所指的位图块从高速缓存中交换出去，然后调入所指定的位图块，最后对这两个数组做与上面相同的操作。</li>
</ul>
</li>
</ul>
<p>可以看出，这个算法很简单，就是对两个数组的简单操作，只是在块组数大于<code>Ext2_MAX_GROUP_LOADED</code>时，要求数组的元素按最近访问的先后次序排列，显然，这样也是为了更合理的进行高速缓存的替换操作。</p>
<h3 id="索引节点表及实例分析"><a href="#索引节点表及实例分析" class="headerlink" title="索引节点表及实例分析"></a>索引节点表及实例分析</h3><p>在两个位图块后面，就是索引节点表了，每个块组中的索引节点都存储在各自的索引节点表中，并且按索引节点号依次存储。索引节点表通常占好几个数据块，索引节点表所占的块使用时也像普通的数据块一样被调入块高速缓存。</p>
<p>在<code>fs/ext2/inode.c</code>中，有一个<code>ext2_read_inode()</code>，用来读取指定的索引节点信息。其代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ext2_read_inode</span> <span class="params">(<span class="keyword">struct</span> inode * inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext2_inode</span> * <span class="title">raw_inode</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> block_group;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> group_desc;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> desc;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> block;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> offset;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext2_group_desc</span> * <span class="title">gdp</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ( ( inode-&gt;i_ino != EXT2_ROOT_INO &amp;&amp; inode-&gt;i_ino != EXT2_ACL_IDX_INO &amp;&amp; </span><br><span class="line">	inode-&gt;i_ino != EXT2_ACL_DATA_INO &amp;&amp; inode-&gt;i_ino &lt; EXT2_FIRST_INO(inode-&gt;i_sb)) || </span><br><span class="line">	inode-&gt;i_ino &gt; le32_to_cpu(inode-&gt;i_sb-&gt;u.ext2_sb.s_es-&gt;s_inodes_count)) &#123;</span><br><span class="line">		ext2_error (inode-&gt;i_sb, <span class="string">&quot;ext2_read_inode&quot;</span>, <span class="string">&quot;bad inode number: %lu&quot;</span>, inode-&gt;i_ino); </span><br><span class="line">		<span class="keyword">goto</span> bad_inode;</span><br><span class="line">	&#125;</span><br><span class="line">	block_group = (inode-&gt;i_ino – <span class="number">1</span>) / EXT2_INODES_PER_GROUP(inode-&gt;i_sb);</span><br><span class="line">	<span class="keyword">if</span> (block_group &gt;= inode-&gt;i_sb-&gt;u.ext2_sb.s_groups_count) &#123;</span><br><span class="line">		ext2_error (inode-&gt;i_sb, <span class="string">&quot;ext2_read_inode&quot;</span>, <span class="string">&quot;group &gt;= groups count&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> bad_inode;</span><br><span class="line">	&#125;</span><br><span class="line">	group_desc = block_group &gt;&gt; EXT2_DESC_PER_BLOCK_BITS(inode-&gt;i_sb);</span><br><span class="line">	desc = block_group &amp; (EXT2_DESC_PER_BLOCK(inode-&gt;i_sb) - <span class="number">1</span>);</span><br><span class="line">	bh = inode-&gt;i_sb-&gt;u.ext2_sb.s_group_desc[group_desc];</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		ext2_error (inode-&gt;i_sb, <span class="string">&quot;ext2_read_inode&quot;</span>, <span class="string">&quot;Descriptor not loaded&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> bad_inode;</span><br><span class="line">	&#125;</span><br><span class="line">	gdp = (<span class="keyword">struct</span> ext2_group_desc *) bh-&gt;b_data;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Figure out the offset within the block group inode table</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	offset = ((inode-&gt;i_ino - <span class="number">1</span>) % EXT2_INODES_PER_GROUP(inode-&gt;i_sb)) *</span><br><span class="line">	EXT2_INODE_SIZE(inode-&gt;i_sb);</span><br><span class="line">	block = le32_to_cpu(gdp[desc].bg_inode_table) +</span><br><span class="line">	(offset &gt;&gt; EXT2_BLOCK_SIZE_BITS(inode-&gt;i_sb));</span><br><span class="line">	<span class="keyword">if</span> (!(bh = sb_bread(inode-&gt;i_sb, block))) &#123;</span><br><span class="line">		ext2_error (inode-&gt;i_sb, <span class="string">&quot;ext2_read_inode&quot;</span>,</span><br><span class="line">		<span class="string">&quot;unable to read inode block - &quot;</span></span><br><span class="line">		<span class="string">&quot;inode=%lu, block=%lu&quot;</span>, inode-&gt;i_ino, block);</span><br><span class="line">		<span class="keyword">goto</span> bad_inode;</span><br><span class="line">	&#125;</span><br><span class="line">	offset &amp;= (EXT2_BLOCK_SIZE(inode-&gt;i_sb) - <span class="number">1</span>);</span><br><span class="line">	raw_inode = (<span class="keyword">struct</span> ext2_inode *) (bh-&gt;b_data + offset);</span><br><span class="line">	inode-&gt;i_mode = le16_to_cpu(raw_inode-&gt;i_mode);</span><br><span class="line">	inode-&gt;i_uid = (<span class="type">uid_t</span>)le16_to_cpu(raw_inode-&gt;i_uid_low);</span><br><span class="line">	inode-&gt;i_gid = (<span class="type">gid_t</span>)le16_to_cpu(raw_inode-&gt;i_gid_low);</span><br><span class="line">	<span class="keyword">if</span>(!(test_opt (inode-&gt;i_sb, NO_UID32))) &#123;</span><br><span class="line">		inode-&gt;i_uid |= le16_to_cpu(raw_inode-&gt;i_uid_high) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">		inode-&gt;i_gid |= le16_to_cpu(raw_inode-&gt;i_gid_high) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_nlink = le16_to_cpu(raw_inode-&gt;i_links_count);</span><br><span class="line">	inode-&gt;i_size = le32_to_cpu(raw_inode-&gt;i_size);</span><br><span class="line">	inode-&gt;i_atime = le32_to_cpu(raw_inode-&gt;i_atime);</span><br><span class="line">	inode-&gt;i_ctime = le32_to_cpu(raw_inode-&gt;i_ctime);</span><br><span class="line">	inode-&gt;i_mtime = le32_to_cpu(raw_inode-&gt;i_mtime);</span><br><span class="line">	inode-&gt;u.ext2_i.i_dtime = le32_to_cpu(raw_inode-&gt;i_dtime);</span><br><span class="line">	<span class="comment">/* We now have enough fields to check if the inode was active or not.</span></span><br><span class="line"><span class="comment">	* This is needed because nfsd might try to access dead inodes</span></span><br><span class="line"><span class="comment">	* the test is that same one that e2fsck uses</span></span><br><span class="line"><span class="comment">	* NeilBrown 1999oct15</span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_nlink == <span class="number">0</span> &amp;&amp; (inode-&gt;i_mode == <span class="number">0</span> || inode-&gt;u.ext2_i.i_dtime)) &#123;</span><br><span class="line">		<span class="comment">/* this inode is deleted */</span></span><br><span class="line">		brelse (bh);</span><br><span class="line">		<span class="keyword">goto</span> bad_inode;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_blksize = PAGE_SIZE; <span class="comment">/* This is the optimal IO size (for stat), not the fs block size */</span></span><br><span class="line">	inode-&gt;i_blocks = le32_to_cpu(raw_inode-&gt;i_blocks);</span><br><span class="line">	inode-&gt;i_version = ++event;</span><br><span class="line">	inode-&gt;u.ext2_i.i_flags = le32_to_cpu(raw_inode-&gt;i_flags);</span><br><span class="line">	inode-&gt;u.ext2_i.i_faddr = le32_to_cpu(raw_inode-&gt;i_faddr);</span><br><span class="line">	inode-&gt;u.ext2_i.i_frag_no = raw_inode-&gt;i_frag;</span><br><span class="line">	inode-&gt;u.ext2_i.i_frag_size = raw_inode-&gt;i_fsize;</span><br><span class="line">	inode-&gt;u.ext2_i.i_file_acl = le32_to_cpu(raw_inode-&gt;i_file_acl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">		inode-&gt;i_size |=((__u64)le32_to_cpu(raw_inode-&gt;i_size_high))&lt;&lt;<span class="number">32</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		inode-&gt;u.ext2_i.i_dir_acl = le32_to_cpu(raw_inode-&gt;i_dir_acl);</span><br><span class="line">	inode-&gt;i_generation = le32_to_cpu(raw_inode-&gt;i_generation);</span><br><span class="line">	inode-&gt;u.ext2_i.i_prealloc_count = <span class="number">0</span>;</span><br><span class="line">	inode-&gt;u.ext2_i.i_block_group = block_group;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* NOTE! The in-memory inode i_data array is in little-endian order</span></span><br><span class="line"><span class="comment">	* even on big-endian machines: we do NOT byteswap the block numbers!</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (block = <span class="number">0</span>; block &lt; EXT2_N_BLOCKS; block++)</span><br><span class="line">		inode-&gt;u.ext2_i.i_data[block] = raw_inode-&gt;i_block[block];</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_ino == EXT2_ACL_IDX_INO || inode-&gt;i_ino == EXT2_ACL_DATA_INO)</span><br><span class="line">		<span class="comment">/* Nothing to do */</span> ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line">		inode-&gt;i_op = &amp;ext2_file_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;ext2_file_operations;</span><br><span class="line">		inode-&gt;i_mapping-&gt;a_ops = &amp;ext2_aops;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">		inode-&gt;i_op = &amp;ext2_dir_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;ext2_dir_operations;</span><br><span class="line">		inode-&gt;i_mapping-&gt;a_ops = &amp;ext2_aops;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(inode-&gt;i_mode)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!inode-&gt;i_blocks)</span><br><span class="line">			inode-&gt;i_op = &amp;ext2_fast_symlink_inode_operations;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			inode-&gt;i_op = &amp;page_symlink_inode_operations;</span><br><span class="line">			inode-&gt;i_mapping-&gt;a_ops = &amp;ext2_aops;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		init_special_inode(inode, inode-&gt;i_mode,</span><br><span class="line">	</span><br><span class="line">	le32_to_cpu(raw_inode-&gt;i_block[<span class="number">0</span>]));</span><br><span class="line">	brelse (bh);</span><br><span class="line">	inode-&gt;i_attr_flags = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;u.ext2_i.i_flags &amp; EXT2_SYNC_FL) &#123;</span><br><span class="line">		inode-&gt;i_attr_flags |= ATTR_FLAG_SYNCRONOUS;</span><br><span class="line">		inode-&gt;i_flags |= S_SYNC;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;u.ext2_i.i_flags &amp; EXT2_APPEND_FL) &#123;</span><br><span class="line">		inode-&gt;i_attr_flags |= ATTR_FLAG_APPEND;</span><br><span class="line">		inode-&gt;i_flags |= S_APPEND;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;u.ext2_i.i_flags &amp; EXT2_IMMUTABLE_FL) &#123;</span><br><span class="line">		inode-&gt;i_attr_flags |= ATTR_FLAG_IMMUTABLE;</span><br><span class="line">		inode-&gt;i_flags |= S_IMMUTABLE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;u.ext2_i.i_flags &amp; EXT2_NOATIME_FL) &#123;</span><br><span class="line">		inode-&gt;i_attr_flags |= ATTR_FLAG_NOATIME;</span><br><span class="line">		inode-&gt;i_flags |= S_NOATIME;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">bad_inode:</span><br><span class="line">	make_bad_inode(inode);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的代码有 200 多行，为了突出重点，下面是对该函数主要内容的描述。</p>
<ul>
<li>如果指定的索引节点号是一个特殊的节点号(<code>EXT2_ROOT_INO</code>、<code>EXT2_ACL_IDX_INO</code>及<code>EXT2_ACL_DATA_INO</code>)，或者小于第一个非特殊用途的节点号，即<code>EXT2_FIRST_INO</code>(为11)，或者大于该文件系统中索引节点总数，则输出错误信息，并返回。</li>
<li>用索引节点号整除每组中索引节点数，计算出该索引节点所在的块组号。即：<code>block_group = (inode-&gt;i_ino - 1) / Ext2_INODES_PER_GROUP(inode-&gt;i_sb)</code>。</li>
<li>找到该组的组描述符在组描述符表中的位置。因为组描述符表可能占多个数据块，所以需要确定组描述符在组描述符表的哪一块以及是该块中第几个组描述符。即：<code>group_desc = block_group &gt;&gt; Ext2_DESC_PER_BLOCK_BITS(inode-&gt;i_sb)</code>表示块组号整除每块中组描述符数，计算出该组的组描述符在组描述符表中的哪一块。</li>
<li>块组号与每块中组的描述符数进行“与”运算，得到这个组描述符具体是该块中第几个描述符。即<code>desc = block_group &amp; (Ext2_DESC_PER_BLOCK(inode-&gt;i_sb) - 1)</code>。</li>
<li>有了<code>group_desc</code>和<code>desc</code>，接下来在高速缓存中找这个组描述符就比较容易了。即：<code>bh = inode-&gt;i_sb-&gt;u.ext2_sb.s_group_desc[group_desc]</code>，首先通过<code>s_group_desc[]</code>数组找到这个组描述符所在块在高速缓存中的缓冲区首部；然后通过缓冲区首部找到数据区，即<code>gdp = (struct ext2_group_desc *) bh-&gt;b_data</code>。</li>
<li>找到组描述符后，就可以通过组描述符结构中的<code>bg_inode_tabl</code>找到索引节点表首块在高速缓存中的地址：<ul>
<li><code>offset = ((inode-&gt;i_ino - 1) % Ext2_INODES_PER_GROUP(inode-&gt;i_sb)) * Ext2_INODE_SIZE(inode-&gt;i_sb)/*计算该索引节点在块中的偏移位置*/</code>；</li>
<li><code>block = le32_to_cpu(gdp[desc].bg_inode_table) + (offset &gt;&gt; Ext2_BLOCK_SIZE_BITS(inode-&gt;i_sb))/*计算索引节点所在块的地址*/</code>。 </li>
</ul>
</li>
<li>代码中<code>le32_to_cpu()</code>、<code>le16_to_cpu()</code>按具体<code>CPU</code>的要求进行数据的排列，在i386 处理器上访问<code>Ext2</code>文件系统时这些函数不做任何事情。因为不同的处理器在存取数据时在字节的排列次序上有所谓“big ending”和“little ending”之分。</li>
<li>计算出索引节点所在块的地址后，就可以调用<code>sb_bread()</code>通过设备驱动程序读入该块。从磁盘读入的索引节点为<code>ext2_Inode</code>数据结构，前面我们已经看到它的定义。磁盘上索引节点中的信息是原始的、未经加工的，所以代码中称之为<code>raw_INOde</code>，即：<code>raw_inode = (struct ext2_inode *) (bh-&gt;b_data + offset)</code></li>
<li>与磁盘索引节点<code>ext2_INOde</code>相对照，内存中<code>VFS</code>的<code>inode</code>结构中的信息则分为两部分，一部分是属于<code>VFS</code>层的，适用于所有的文件系统；另一部分则属于具体的文件系统，这就是<code>inode</code>中的那个<code>union</code>，因具体文件系统的不同而赋予不同的解释。对<code>Ext2</code>来说，这部分数据就是前面介绍的<code>ext2_inode_info</code>结构。至于代表着符号链接的节点，则并没有文件内容(数据)，所以正好用这块空间来存储链接目标的路径名。<code>ext2_inode_info</code>结构的大小为 60 个字节。虽然节点名最长可达 255 个字节，但一般都不会太长，因此将符号链接目标的路径名限制在 60 个字节不至于引起问题。代码中<code>inode-&gt;u.*</code>设置的就是<code>Ext2</code>文件系统的<br>特定信息。</li>
<li>接着，根据索引节点所提供的信息设置<code>inode</code>结构中的<code>inode_operations</code>结构指针和<code>file_operations</code>结构指针，完成具体文件系统与虚拟文件系统<code>VFS</code>之间的连接。</li>
<li>目前 2.4 版内核并不支持存取控制表`ACL，因此，代码中只是为之留下了位置，而暂时没做任何处理。</li>
<li>另外，通过检查<code>inode</code>结构中的<code>mode</code>域来确定该索引节点是常规文件(<code>S_ISREG</code>)、目录(<code>S_ISDIR</code>)、符号链接(<code>S_ISLNK</code>)还是其他特殊文件而作不同的设置或处理。例如，对<code>Ext2</code>文件系统的目录节点，就将<code>i_op</code>和<code>i_fop</code>分配设置为<code>ext2_dir_inode_operations</code>和<code>ext2_dir_operations</code>。而对于<code>Ext2</code>常规文件，则除<code>i_op</code>和<code>i_fop</code>以外，还设置了另一个指针<code>a_ops</code>，它指向一个<code>address_apace_operation</code>结构，用于文件到内存空间的映射或缓冲。对特殊文件，则通过<code>init_special_inode()</code>函数加以检查和处理。</li>
</ul>
<h3 id="Ext2-的目录项及文件的定位"><a href="#Ext2-的目录项及文件的定位" class="headerlink" title="Ext2 的目录项及文件的定位"></a>Ext2 的目录项及文件的定位</h3><p>文件系统一个很重要的问题就是文件的定位，如何通过一个路径来找到一个文件的具体位置，就要依靠<code>ext2_dir_entry</code>这个结构。 </p>
<h4 id="Ext2-目录项结构"><a href="#Ext2-目录项结构" class="headerlink" title="Ext2 目录项结构"></a>Ext2 目录项结构</h4><p>在<code>Ext2</code>中，目录是一种特殊的文件，它是由<code>ext2_dir_entry</code>这个结构组成的列表。这个结构是变长的，这样可以减少磁盘空间的浪费，但是，它还是有一定的长度方面的限制，一是文件名最长只能为 255 个字符。二是尽管文件名长度可以不限(在 255 个字符之内)，但系统自动将之变成 4 的整数倍，不足的地方用<code>NULL</code>字符(\0)填充。目录中有文件和子目录，每一项对应一个<code>ext2_dir_entry</code>。该结构在<code>include/Linux/ext2_fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Structure of a directory entry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT2_NAME_LEN 255</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_dir_entry</span> &#123;</span></span><br><span class="line">	__u32 inode; <span class="comment">/* Inode number */</span></span><br><span class="line">	__u16 rec_len; <span class="comment">/* Directory entry length */</span></span><br><span class="line">	__u16 name_len; <span class="comment">/* Name length */</span></span><br><span class="line">	<span class="type">char</span> name[EXT2_NAME_LEN]; <span class="comment">/* File name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是老版本的定义方式，在<code>ext2_fs.h</code>中还有一种新的定义方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* The new version of the directory entry. Since EXT2 structures are</span></span><br><span class="line"><span class="comment">* stored in intel byte order, and the name_len field could never be</span></span><br><span class="line"><span class="comment">* bigger than 255 chars, it&#x27;s safe to reclaim the extra byte for the</span></span><br><span class="line"><span class="comment">* file_type field.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_dir_entry_2</span> &#123;</span></span><br><span class="line">	__u32 inode; <span class="comment">/* Inode number */</span></span><br><span class="line">	__u16 rec_len; <span class="comment">/* Directory entry length */</span></span><br><span class="line">	__u8 name_len; <span class="comment">/* Name length */</span></span><br><span class="line">	__u8 file_type;</span><br><span class="line">	<span class="type">char</span> name[EXT2_NAME_LEN]; <span class="comment">/* File name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其二者的差异在于，一是新版中结构名改为<code>ext2_dir_entry_2</code>；二是老版本中<code>ext2_dir_entry</code>中的<code>name_len</code>为无符号短整数，而新版中则改为 8 位的无符号字符，腾出一半用作文件类型。目前已定义的文件类型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ext2 directory file types. Only the low 3 bits are used. The</span></span><br><span class="line"><span class="comment"> * other bits are reserved for now.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	EXT2_FT_UNKNOWN, <span class="comment">/*未知*/</span></span><br><span class="line">	EXT2_FT_REG_FILE, <span class="comment">/*常规文件*/</span></span><br><span class="line">	EXT2_FT_DIR, <span class="comment">/*目录文件*/</span></span><br><span class="line">	EXT2_FT_CHRDEV, <span class="comment">/*字符设备文件*/</span></span><br><span class="line">	EXT2_FT_BLKDEV, <span class="comment">/*块设备文件*/</span></span><br><span class="line">	EXT2_FT_FIFO, <span class="comment">/*命名管道文件*/</span></span><br><span class="line">	EXT2_FT_SOCK, <span class="comment">/*套接字文件*/</span></span><br><span class="line">	EXT2_FT_SYMLINK, <span class="comment">/*符号连文件*/</span></span><br><span class="line">	EXT2_FT_MAX <span class="comment">/*文件类型的最大个数*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="各种文件类型如何使用数据块"><a href="#各种文件类型如何使用数据块" class="headerlink" title="各种文件类型如何使用数据块"></a>各种文件类型如何使用数据块</h4><p>我们说，不管哪种类型的文件，每个文件都对应一个<code>inode</code>结构，在<code>inode</code>结构中有一个指向数据块的指针<code>i_blaock</code>，用来标识分配给文件的数据块。但是<code>Ext2</code>所定义的文件类型以不同的方式使用数据块。有些类型的文件不存放数据，因此，根本不需要数据块，下面对不同文件类型如何使用数据块给予说明。</p>
<p>常规文件是最常用的文件。常规文件在刚创建时是空的，并不需要数据块，只有在开始有数据时才需要数据块；可以用系统调用<code>truncate()</code>清空一个常规文件。</p>
<p>目录文件：Ext2 以一种特殊的方式实现了目录，这种文件的数据块中存放的就是<code>ext2_dir_entry_2</code>结构。如前所述，这个结构的最后一个域是可变长度数组，因此该结构的长度是可变的。在<code>ext2_dir_entry_2</code>结构中，因为<code>rec_len</code>域是目录项的长度，把它与目录项的起始地址相加就得到下一个目录项的起始地址，因此说，<code>rec_len</code>可以被解释为指向下一个有效目录项的指针。为了删除一个目录项，把<code>ext2_dir_entry_2</code>的<code>inode</code>域置为 0 并适当增加前一个有效目录项<code>rec_len</code>域的值就可以了。</p>
<p>符号连：如果符号连的路径名小于 60 个字符，就把它存放在索引节点的<code>i_blaock</code>域，该域是由15 个 4 字节整数组成的数组，因此无需数据块。但是，如果路径名大于 60 个字符，就需要一个单独的数据块。</p>
<p>设备文件、管道和套接字：这些类型的文件不需要数据块。所有必要的信息都存放在索引节点中。</p>
<h4 id="文件的定位"><a href="#文件的定位" class="headerlink" title="文件的定位"></a>文件的定位</h4><p>如果要找的文件为普通文件，则可通过文件所对应的索引节点找到文件的具体位置，如果是一个目录文件，则也可通过相应的索引节点找到目录文件具体所在，然后再从这个目录文件中进行下一步查找。</p>
<p>现在，我们来分析一下<code>fs/ext2/dir.c</code>中的函数<code>ext2_find_entry()</code>，该函数从磁盘上找到并读入当前节点的目录项，其代码及解释如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ext2_find_entry()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * finds an entry in the specified directory with the wanted name. It</span></span><br><span class="line"><span class="comment"> * returns the page in which the entry was found, and the entry itself</span></span><br><span class="line"><span class="comment"> * (as a parameter - res_dir). Page is returned mapped and unlocked.</span></span><br><span class="line"><span class="comment"> * Entry is guaranteed to be valid.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ext2_dir_entry_2</span> <span class="title">ext2_dirent</span>；</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_dir_entry_2</span> * <span class="title">ext2_find_entry</span> (<span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">dir</span>,</span></span><br><span class="line"><span class="class"> <span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>, <span class="keyword">struct</span> <span class="title">page</span> ** <span class="title">res_page</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name = dentry-&gt;d_name.name; <span class="comment">/*目录项名*/</span></span><br><span class="line">	<span class="type">int</span> namelen = dentry-&gt;d_name.len; <span class="comment">/*目录项名的长度*/</span></span><br><span class="line">	<span class="type">unsigned</span> reclen = EXT2_DIR_REC_LEN(namelen); <span class="comment">/*目录项的长度*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start, n;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> npages = dir_pages(dir); <span class="comment">/*把以字节为单位的文件大小转换为物理页面数*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	ext2_dirent * de; <span class="comment">/*de`为要返回的`Ext2`目录项</span></span><br><span class="line"><span class="comment">	/*结构*/</span></span><br><span class="line">	<span class="comment">/* OFFSET_CACHE */</span></span><br><span class="line">	*res_page = <span class="literal">NULL</span>;</span><br><span class="line">	start = dir-&gt;u.ext2_i.i_dir_start_lookup; <span class="comment">/*目录项在内存的起始位置*/</span></span><br><span class="line">	<span class="keyword">if</span> (start &gt;= npages)</span><br><span class="line">		start = <span class="number">0</span>;</span><br><span class="line">	n = start;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="type">char</span> *kaddr;</span><br><span class="line">		page = ext2_get_page(dir, n); <span class="comment">/*从页面高速缓存中获得目录项所在的页面*/</span></span><br><span class="line">		<span class="keyword">if</span> (!IS_ERR(page)) &#123;</span><br><span class="line">			kaddr = page_address(page); <span class="comment">/*获得page所对应的内核虚拟地址*/</span></span><br><span class="line">			de = (ext2_dirent *) kaddr; <span class="comment">/*获得该目录项结构的起始地址*/</span></span><br><span class="line">			kaddr += PAGE_CACHE_SIZE - reclen; <span class="comment">/* PAGE_CACHE_SIZE的大小为 1 个页面的大小，假定所有的目录项结构都存放在一个页面内*/</span></span><br><span class="line">			<span class="keyword">while</span> ((<span class="type">char</span> *) de &lt;= kaddr) &#123; <span class="comment">/*循环查找，直到找到匹配的目录项*/</span></span><br><span class="line">				<span class="keyword">if</span> (ext2_match (namelen, name, de))</span><br><span class="line">					<span class="keyword">goto</span> found;</span><br><span class="line">				de = ext2_next_entry(de);</span><br><span class="line">			&#125;</span><br><span class="line">			ext2_put_page(page); <span class="comment">/*释放目录项所在的页面*/</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (++n &gt;= npages)</span><br><span class="line">		n = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (n != start);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">	*res_page = page;</span><br><span class="line">	dir-&gt;u.ext2_i.i_dir_start_lookup = n;</span><br><span class="line">	<span class="keyword">return</span> de;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h2><p>目录项中，每一对文件名和索引节点号的一个一一对应称为一个链接，这就使同一个索引节点号出现在多个链接中成为可能，也就是说，同一个索引节点号可以对应多个不同的文件名。这种链接称为硬链接，可以用<code>ln</code>命令为一个已存在的文件建立一个新的硬链接：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln /home/user1/file1 /home/user1/file2</span><br></pre></td></tr></table></figure></p>
<p>建立了一个文件<code>file2</code>，链接到<code>file1</code>上。<code>file2</code>和<code>file1</code>有相同的索引节点号，也就是和<code>file1</code>共享同一个索引节点。在建立了一个新的硬链接后，这个索引节点中的<code>i_links_count</code>值将加 1，<code>i_links_count</code>的值反映了链接到这个索引节点上的文件数。</p>
<p>使用硬链接的好处如下所示。</p>
<ol>
<li>由于在删除文件时，实际上先对<code>i_links_count</code>作减 1，如果<code>i_links_count</code>不为0，则结束，即仅仅删除了一个硬链接，具体文件的数据并没有被删除。只有在<code>i_links_count</code>为 0 时，才真正将文件从磁盘上删除。这样，你可以对重要的文件作多个链接，防止文件被误删除。</li>
<li>允许用户在不进入某个目录的情况下对该目录下面的文件进行处理。</li>
</ol>
<p>由于同一个文件系统中，索引节点号是系统用来辨认文件的唯一标志，而两个不同的文件系统中，可能有索引节点号一样的文件，所以硬链接仅允许在同一个文件系统上进行，要在多个文件系统之间建立链接，必须用到符号链接。</p>
<p>符号链接与硬链接最大的不同就在于它并不与索引节点建立链接，也就是说当为一个文件建立一个符号链接时，索引节点的链接计数并不变化。当你删除一个文件时，它的符号链接文件也就失去了作用，而当你删去一个文件的符号链接文件，对该文件本身并无影响。</p>
<p>因为内核为符号链接文件也创建一个索引节点，但它跟普通文件的索引节点所有不同。关于符号链接的操作也就比较简单。对Ext2 文件系统来说，只有<code>ext2_readlink()</code>和<code>ext2_follow_link()</code>函数，这是在<code>fs/ext2/symlink.c</code>中定义的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">ext2_fast_symlink_inode_operations</span> =</span> &#123;</span><br><span class="line">	readlink: ext2_readlink,</span><br><span class="line">	follow_link: ext2_follow_link,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>ext2_readlink()</code>函数的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ext2_readlink</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="type">char</span> *buffer, <span class="type">int</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *s = (<span class="type">char</span> *)dentry-&gt;d_inode-&gt;u.ext2_i.i_data;</span><br><span class="line">	<span class="keyword">return</span> vfs_readlink(dentry, buffer, buflen, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如前所述，对于<code>Ext2</code>文件系统，连接目标的路径在<code>ext2_INOde_info</code>结构(即<code>inode</code>结构的<code>union</code>域)的<code>i_data</code>域中存放，因此字符串<code>s</code>就存放有连接目标的路径名。</p>
<p><code>vfs_readlink()</code>的代码在<code>fs/namei.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vfs_readlink</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="type">char</span> *buffer, <span class="type">int</span> buflen, <span class="type">const</span> <span class="type">char</span> *link)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	len = PTR_ERR(link);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(link))</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">	len = <span class="built_in">strlen</span>(link);</span><br><span class="line">	<span class="keyword">if</span> (len &gt; (<span class="type">unsigned</span>) buflen)</span><br><span class="line">	len = buflen;</span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(buffer, link, len))</span><br><span class="line">	len = -EFAULT;</span><br><span class="line">out: </span><br><span class="line"> <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码可以看出，该函数比较简单，即把连接目标的路径名拷贝到用户空间的缓冲区中，并返回路径名的长度。</p>
<p><code>ext2_follow_link()</code>函数用于搜索符号连接所在的目标文件，其代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ext2_follow_link</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *s = (<span class="type">char</span> *)dentry-&gt;d_inode-&gt;u.ext2_i.i_data;</span><br><span class="line">	<span class="keyword">return</span> vfs_follow_link(nd, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数与<code>ext2_readlink()</code>类似，值得注意的是，从<code>ext2_readlink()</code>中对<code>vfs_readlink()</code>的调用意味着从较低的层次(Ext2 文件系统)回到更高的<code>VFS</code>层次。为什么呢？这是因为符号链接的目标有可能在另一个不同的文件系统中，因此，必须通过<code>VFS</code>来中转，在<code>vfs_follow_link()</code>中必须要调用路径搜索函数<code>link_path_walk()</code>来找到代表着连接对象的<code>dentry</code>结构，函数的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">vfs_follow_link</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">const</span> <span class="type">char</span> *link)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> *name;</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(link))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	<span class="keyword">if</span> (*link == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">		path_release(nd);</span><br><span class="line">		<span class="keyword">if</span> (!walk_init_root(link, nd))</span><br><span class="line">			<span class="comment">/* weird __emul_prefix() stuff did it */</span></span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	res = link_path_walk(link, nd);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;link_count || res || nd-&gt;last_type!=LAST_NORM)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* If it is an iterative symlinks resolution in open_namei() we</span></span><br><span class="line"><span class="comment">	* have to copy the last component. And all that crap because of</span></span><br><span class="line"><span class="comment">	* bloody create() on broken symlinks. Furrfu...</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	name = __getname();</span><br><span class="line">	<span class="keyword">if</span> (!name)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="built_in">strcpy</span>(name, nd-&gt;last.name);</span><br><span class="line">	nd-&gt;last.name = name;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">	path_release(nd);</span><br><span class="line">	<span class="keyword">return</span> PTR_ERR(link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>nameidata</code>结构为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> &#123;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">last</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">int</span> last_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>last_type</code>域的可能取值定义于<code>fs.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Type of the last component on LOOKUP_PARENT</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在路径的搜索过程中，这个域的值会随着路径名当前的搜索结果而变。例如，如果成功地找到了目标文件，那么这个域的值就变成了<code>LAST_NORM</code>；而如果最后停留在一个“.”上，则变成<code>LAST_DOT</code>。</p>
<p><code>Qstr</code>结构用来存放路径名中当前节点的名字、长度及哈希值，其定义于<code>include/linux/dcache.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &quot;quick string&quot; -- eases parameter passing, but more importantly</span></span><br><span class="line"><span class="comment"> * saves &quot;metadata&quot; about the string (ie length and the hash).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> &#123;</span></span><br><span class="line"> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * name;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> hash;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面来对<code>vfs_follow_link()</code>函数的代码给予说明。</p>
<ul>
<li>如果符号链接的路径名是以“/”开头的绝对路径，那就要通过<code>walk_init_root()</code>从根节点开始查找。</li>
<li>调用<code>link_path_walk()</code>函数查找符号链接所在目标文件对应的信息。从<code>link_path_walk()</code>返回时，返回值为 0 表示搜索成功，此时，<code>nameidata</code>结构中的指针<code>dentry</code>指向目标节点的<code>dentry</code>结构，指针<code>mnt</code>指向目标节点所在设备的安装结构，同时，这个结构中的<code>last_type</code>表示最后一个节点的类型，节点名则在类型为<code>qstr</code>结构的<code>last</code>中。该函数失败时，则函数返回值为一负的出错码，而<code>nameidata</code>结构中则提供失败的节点名等信息。</li>
<li><code>vfs_follow_link()</code>返回值的含义与<code>ink_path_walk()</code>函数完全相同。</li>
</ul>
<h2 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h2><p>一个好的分配物理块的策略，将导致文件系统性能的提高。一个好的思路是将相关的数据尽量存储在磁盘上相邻的区域，以减少磁头的寻道时间。Ext2 使用块组的优越性就体现出来了，因为，同一个组中的逻辑块所对应的物理块通常是相邻存储的。Ext2 企图将每一个新的目录分到它的父目录所在的组。所以，将父目录和子目录放在同一个组是有必要的。它还企图将文件和它的目录项分在同一个组，因为目录访问常常导致文件访问。当然如果组已满，则文件或目录可能分在某一个未满的组中。</p>
<p>分配新块的算法如下所述。</p>
<ol>
<li>文件的数据块尽量和它的索引节点在同一个组中。</li>
<li>每个文件的数据块尽量连续分配。</li>
<li>父目录和子目录尽量在一个块组中。</li>
<li>文件和它的目录项尽量在同一个块组中。</li>
</ol>
<h3 id="数据块寻址"><a href="#数据块寻址" class="headerlink" title="数据块寻址"></a>数据块寻址</h3><p>每个非空的普通文件都是由一组数据块组成。这些块或者由文件内的相对位置(文件块号)来表示，或者由磁盘分区内的位置(它们的逻辑块号)来表示。从文件内的偏移量<code>f</code>导出相应数据块的逻辑块号需要以下两个步骤。</p>
<ul>
<li>从偏移量<code>f</code>导出文件的块号，即偏移量<code>f</code>处的字符所在的块索引。</li>
<li>把文件的块号转化为相应的逻辑块号。</li>
</ul>
<p>只用关心文件的块号确实不错。但是，由于<code>Ext2</code>文件的数据块在磁盘上并不是相邻的，因此把文件的块号转化为相应的逻辑块号可不是那么直接了当。</p>
<p>因此，<code>Ext2</code>文件系统必须提供一种方法，用这种方法可以在磁盘上建立每个文件块号与相应逻辑块号之间的关系。在索引节点内部部分实现了这种映射，这种映射也包括一些专门的数据块，可以把这些数据块看成是用来处理大型文件的索引节点的扩展。磁盘索引节点的<code>i_block</code>域是一个有<code>EXT2_N_BLOCKS</code>个元素且包含逻辑块号的数组。在下面的讨论中，我们假定<code>EXT2_N_BLOCKS</code>的默认值为 15，如图 9.4 所示，这个数组表示一个大型数据结构的初始化部分。正如你从图中所看到的，数组的 15 个元素有 4 种不同的类型。</p>
<ul>
<li>最初的 12 个元素产生的逻辑块号与文件最初的 12 个块对应，即对应的文件块号从 0到 11。</li>
<li>索引 12 中的元素包含一个块的逻辑块号，这个块代表逻辑块号的一个二级数组。这个数组对应的文件块号从 12 到<code>b/4+11</code>，这里<code>b</code>是文件系统的块大小(每个逻辑块号占 4 个字节，因此我们在式子中用 4 做除数)。因此，内核必须先用指向一个块的指针访问这个元素，然后，用另一个指向包含文件最终内容的块的指针访问那个块。</li>
<li>索引 13 中的元素包含一个块的逻辑块号，这个块包含逻辑块号的一个二级数组；这个二级数组的数组项依次指向三级数组，这个三级数组存放的才是逻辑块号对应的文件块号，范围从<code>b/4+12</code>到<code>(b/4)^2+(b/4)+11</code>。</li>
<li>最后，索引 14 中的元素利用了三级间接索引：第四级数组中存放的才是逻辑块号对应的文件块号，范围从<code>(b/4)^2+(b/4)+12</code>到<code>(b/4)^3+(b/4)^2+(b/4)+11</code>。</li>
</ul>
<p>注意这种机制是如何支持小文件的。如果文件需要的数据块小于 12，那么两次访问磁盘就可以检索到任何数据：一次是读磁盘索引节点<code>i_block</code>数组的一个元素，另一次是读所需要的数据块。对于大文件来说，可能需要 3～4 次的磁盘访问才能找到需要的块。实际上，这是一种最坏的估计，因为目录项、缓冲区及页高速缓存都有助于极大地减少实际访问磁盘的次数。也要注意文件系统的块大小是如何影响寻址机制的，因为大的块大小允许<code>Ext2</code>把更多的逻辑块号存放在一个单独的块中。例如，如果块的大小是 1024 字节，并且文件包含的数据最多为 268KB，那么，通过直接映射可以访问文件最初的<code>12KB</code>数据，通过简单的间接映射可以访问剩余的<code>13KB</code>到<code>268KB</code>的数据。对于 4096 字节的块，两次间接就完全满足了对<code>2GB</code>文件的寻址。</p>
<h3 id="文件的洞"><a href="#文件的洞" class="headerlink" title="文件的洞"></a>文件的洞</h3><p>文件的洞是普通文件的一部分,它是一些空字符但没有存放在磁盘的任何数据块中。洞是<code>UNIX</code>文件一直存在的一个特点。例如，下列的<code>Linux</code>命令创建了第一个字节是洞的文件。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&quot;X&quot;</span> | <span class="built_in">dd</span> of=/tmp/hole bs=1024 seek=6</span><br></pre></td></tr></table></figure></p>
<p>现在，<code>/tmp/hole</code>有 6145 个字符(6144 个<code>NULL</code>字符加一个<code>X</code>字符)，然而，这个文件只占磁盘上一个数据块。</p>
<p>文件洞在<code>Ext2</code>的实现是基于动态数据块的分配：只有当进程需要向一个块写数据时，才真正把这个块分配给文件。每个索引节点的<code>i_size</code>域定义程序所看到的文件大小，包括洞，而<code>i_blocks</code>域存放分配给文件有效的数据块数(以 512 字节为单位)。</p>
<p>在前面<code>dd</code>命令的例子中，假定<code>/tmp/hole</code>文件被创建在块大小为 4096 的<code>Ext2</code>分区上。其相应磁盘索引节点的<code>i_size</code>域存放的数为 6145，而<code>i_blocks</code>域存放的数为 8(因为每 4096字节的块包含 8 个 512 字节的块)。<code>i_block</code>数组的第 2 个元素(对应块的文件块号为 1)存放已分配块的逻辑块号，而数组中的其他元素都为空。</p>
<h3 id="分配一个数据块"><a href="#分配一个数据块" class="headerlink" title="分配一个数据块"></a>分配一个数据块</h3><p>当内核要分配一个新的数据块来保存<code>Ext2</code>普通文件的数据时，就调用<code>ext2_get_block()</code>函数。这个函数依次处理在“数据块寻址”部分所描述的那些数据结构，并在必要时调用<code>ext2_alloc_block()</code>函数在<code>Ext2</code>分区实际搜索一个空闲的块。</p>
<p>为了减少文件的碎片，<code>Ext2</code>文件系统尽力在已分配给文件的最后一个块附近找一个新块分配给该文件。如果失败，<code>Ext2</code>文件系统又在包含这个文件索引节点的块组中搜寻一个新的块。作为最后一个办法，可以从其他一个块组中获得空闲块。</p>
<p>Ext2 文件系统使用数据块的预分配策略。文件并不仅仅获得所需要的块，而是获得一组多达 8 个邻接的块。<code>ext2_inode_info</code>结构的<code>i_prealloc_count</code>域存放预分配给某一文件但还没有使用的数据块数，而<code>i_prealloc_block</code>域存放下一次要使用的预分配块的逻辑块号。</p>
<p>当下列情况发生时，即文件被关闭时，文件被删除时，或关于引发块预分配的写操作而言，有一个写操作不是顺序的时候，就释放预分配但一直没有使用的块。</p>
<p>下面我们来看一下<code>ext2_get_block()</code>函数，其代码在<code>fs/ext2/inode.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allocation strategy is simple: if we have to allocate something, we will</span></span><br><span class="line"><span class="comment"> * have to go the whole way to leaf. So let&#x27;s do it before attaching anything</span></span><br><span class="line"><span class="comment"> * to tree, set linkage between the newborn blocks, write them if sync is</span></span><br><span class="line"><span class="comment"> * required, recheck the path, free and repeat if check fails, otherwise</span></span><br><span class="line"><span class="comment"> * set the last missing link (that will protect us from any truncate-generated</span></span><br><span class="line"><span class="comment"> * removals - all blocks on the path are immune now) and possibly force the</span></span><br><span class="line"><span class="comment"> * write on the parent block.</span></span><br><span class="line"><span class="comment"> * That has a nice additional property: no special recovery from the failed</span></span><br><span class="line"><span class="comment"> * allocations is needed - we simply release blocks and do not touch anything</span></span><br><span class="line"><span class="comment"> * reachable from inode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ext2_get_block</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">long</span> iblock, <span class="keyword">struct</span> buffer_head *bh_result, <span class="type">int</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err = -EIO;</span><br><span class="line">	<span class="type">int</span> offsets[<span class="number">4</span>];</span><br><span class="line">	Indirect chain[<span class="number">4</span>];</span><br><span class="line">	Indirect *partial;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> goal;</span><br><span class="line">	<span class="type">int</span> left;</span><br><span class="line">	<span class="type">int</span> depth = ext2_block_to_path(inode, iblock, offsets);</span><br><span class="line">	<span class="keyword">if</span> (depth == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	lock_kernel();</span><br><span class="line">reread:</span><br><span class="line">	partial = ext2_get_branch(inode, depth, offsets, chain, &amp;err);</span><br><span class="line">	<span class="comment">/* Simplest case - block found, no allocation needed */</span></span><br><span class="line">	<span class="keyword">if</span> (!partial) &#123;</span><br><span class="line">got_it:</span><br><span class="line">		bh_result-&gt;b_dev = inode-&gt;i_dev;</span><br><span class="line">		bh_result-&gt;b_blocknr = le32_to_cpu(chain[depth<span class="number">-1</span>].key);</span><br><span class="line">		bh_result-&gt;b_state |= (<span class="number">1UL</span> &lt;&lt; BH_Mapped);</span><br><span class="line">		<span class="comment">/* Clean up and exit */</span></span><br><span class="line">		partial = chain+depth<span class="number">-1</span>; <span class="comment">/* the whole chain */</span></span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* Next simple case - plain lookup or failed read of indirect block */</span></span><br><span class="line">	<span class="keyword">if</span> (!create || err == -EIO) &#123;</span><br><span class="line">cleanup:</span><br><span class="line">	<span class="keyword">while</span> (partial &gt; chain) &#123;</span><br><span class="line">		brelse(partial-&gt;bh);</span><br><span class="line">		partial--;</span><br><span class="line">	&#125;</span><br><span class="line">	unlock_kernel();</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Indirect block might be removed by truncate while we were</span></span><br><span class="line"><span class="comment">* reading it. Handling of that case (forget what we&#x27;ve got and</span></span><br><span class="line"><span class="comment">* reread) is taken out of the main path.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">if</span> (err == -EAGAIN)</span><br><span class="line">		<span class="keyword">goto</span> changed;</span><br><span class="line">	<span class="keyword">if</span> (ext2_find_goal(inode, iblock, chain, partial, &amp;goal) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> changed;</span><br><span class="line">	left = (chain + depth) - partial;</span><br><span class="line">	err = ext2_alloc_branch(inode, left, goal,</span><br><span class="line">	offsets+(partial-chain), partial);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> cleanup;</span><br><span class="line">	<span class="keyword">if</span> (ext2_splice_branch(inode, iblock, chain, partial, left) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> changed;</span><br><span class="line">	bh_result-&gt;b_state |= (<span class="number">1UL</span> &lt;&lt; BH_New);</span><br><span class="line">	<span class="keyword">goto</span> got_it;</span><br><span class="line">changed:</span><br><span class="line">	<span class="keyword">while</span> (partial &gt; chain) &#123;</span><br><span class="line">		brelse(partial-&gt;bh);</span><br><span class="line">		partial--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> reread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数的参数<code>inode</code>指向文件的<code>inode</code>结构；参数<code>iblock</code>表示文件中的逻辑块号；参数<code>bh_result</code>为指向缓冲区首部的指针，<code>buffer_head</code>结构已在上一章做了介绍；参数<code>create</code>表示是否需要创建。其中<code>Indirect</code>结构在同一文件中定义如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	u32 *p;</span><br><span class="line">	u32 key;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">&#125; Indirect</span><br></pre></td></tr></table></figure>
<p>用数组<code>chain[4]</code>描述 4 种不同的索引，即直接索引、一级间接索引、二级间接索引、三级间接索引。举例说明这个结构各个域的含义。如果文件内的块号为 8，则不需要间接索引，所以只用<code>chain[0]</code>一个<code>Indirect</code>结构，<code>p</code>指向直接索引表下标为 8 处，即<code>&amp;inode-&gt;u.ext2_i.i_data[8]</code>；而<code>key</code>则持有该表项的内容，即文件块号所对应的设备上的块号；<code>bh</code>为<code>NULL</code>，因为没有用于间接索引的块。如果文件内的块号为 20，则需要一次间接索引，索引要用<code>chian[0]</code>和<code>chain[1]</code>两个表项。</p>
<p>第一个表项<code>chian[0]</code>中，指针<code>bh</code>仍为<code>NULL</code>，因为这一层没有用于间接索引的数据块；指针<code>p</code>指向<code>&amp;inode-&gt;u.ext2_i.i_data[12]</code>，即间接索引的表项；而<code>key</code>持有该项的内容，即对应设备的块号。<code>chain[1]</code>中的指针<code>bh</code>则指向进行间接索引的块所在的缓冲区，这个缓冲区的内容就是用作间接索引的一个整数数组，而<code>p</code>指向这个数组中下标为 8 处，而<code>key</code>则持有该项的内容。这样，根据具体索引的深度<code>depth</code>，数组<code>chain[]</code>中的最后一个元素，即<code>chain[depth-1].key</code>，总是持有目标数据块的物理块号。而从<code>chain[]</code>中第 1 个元素<code>chain[0]</code>到具体索引的最后一个元素<code>chain[depth-1]</code>，则提供了具体索引的整个路径，构成了一条索引链，这也是数据名<code>chain</code>的由来。</p>
<p>了解了以上基本内容后，我们来看<code>ext2_get_block()</code>函数的具体实现代码。</p>
<ul>
<li>首先调用<code>ext2_block_to_path()</code>函数，根据文件内的逻辑块号<code>iblock</code>计算出这个数据块落在哪个索引区间，要采用几重索引(1 表示直接)。如果返回值为 0，表示出错，因为文件内块号与设备上块号之间至少也得有一次索引。出错的原因可能是文件内块号太大或为负值。</li>
<li><code>ext2_get_branch()</code>函数深化从<code>ext2_block_to_path()</code>所取得的结果，而这合在一起基本上完成了从文件内块号到设备上块号的映射。从<code>ext2_get_branch()</code>返回的值有两种可能。一是，如果顺利完成了映射则返回值为<code>NULL</code>。二是，如果在某一索引级发现索引表内的相应表项为 0，则说明这个数据块原来并不存在，现在因为写操作而需要扩充文件的大小。此时，返回指向<code>Indirect</code>结构的指针，表示映射在此断裂。此外，如果映射的过程中出错，例如，读数据块失败，则通过<code>err</code>返回一个出错代码。</li>
<li>如果顺利完成了映射，就把所得结果填入缓冲区结构<code>bh_result</code>中，然后把映射过程中读入的缓冲区(用于间接索引)全部释放。</li>
<li>可是，如果<code>ext2_get_branch()</code>返回一个非 0 指针，那就说明映射在某一索引级上断裂了。根据映射的深度和断裂的位置，这个数据块也许是个用于间接索引的数据块，也许是最终的数据块。不管怎样，此时都应该为相应的数据块分配空间。</li>
<li>要分配空间，首先应该确定从物理设备上何处读取目标块。根据分配算法，所分配的数据块应该与上一次已分配的数据块在设备上连续存放。为此目的，在<code>ext2_inode_info</code>结构中设置了两个域<code>i_next_alloc_block</code>和<code>i_next_alloc_goal</code>。前者用来记录下一次要分配的文件内块号，而后者则用来记录希望下一次能分配的设备上的块号。在正常情况下，对文件的扩充是顺序的，因此，每次所分配的文件内块号都与前一次的连续，而理想上来说，设备上的块号也同样连续，二者平行地向前推进。这种理想的“建议块号”就是由<code>ext2_find_goal()</code>函数来找的。</li>
<li>设备上具体物理块的分配，以及文件内数据块与物理块之间映射的建立，都是调用<code>ext2_alloc_branch()</code>函数完成的。调用之前，先要算出还有几级索引需要建立。</li>
<li>从<code>ext2_alloc_branch()</code>返回以后，我们已经从设备上分配了所需的数据块，包括用于间接索引的中间数据块。但是，原先映射开始断开的最高层上所分配的数据块号只是记录了其<code>Indirect</code>结构中的<code>key</code>域，却并没有写入相应的索引表中。现在，就要把断开的“树枝”接到整个索引树上，同时，还需要对文件所属<code>inode</code>结构中的有关内容做一些调整。这些操作都是由<code>ext2_splice_branch()</code>函数完成。</li>
</ul>
<p>到此为止，万事具备，则转到标号<code>got_it</code>处，把映射后的数据块连同设备号置入<code>bh_result</code>所指的缓冲区结构中，这就完成了数据块的分配。 </p>
<h1 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h1><p><code>Linux</code>的整体式结构决定了要给内核增加新的成分也是非常困难，因此<code>Linux</code>提供了一种全新的机制—可装入模块(Loadable Modules，以下简称模块)，用户可以根据自己的需要，在不需要对内核进行重新编译的条件下，模块能被动态地插入到内核或从内核中移走。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h3><p>模块是内核的一部分(通常是设备驱动程序)，但是并没有被编译到内核里面去。它们被分别编译并连接成一组目标文件，这些文件能被插入到正在运行的内核，或者从正在运行的内核中移走，进行这些操作可以使用<code>insmod</code>(插入模块)或<code>rmmod</code>(移走模块)命令，或者，在必要的时候，内核本身能请求内核守护进程(kerned)装入或卸下模块。这里列出在<code>Linux</code>内核源程序中所包括的一些模块。</p>
<ul>
<li>文件系统: minix, xiafs, msdos, umsdos, sysv, isofs, hpfs, smbfs, ext3, nfs, proc等。</li>
<li>大多数<code>SCSI</code>驱动程序: (如：aha1542, in2000)。</li>
<li>所有的<code>SCSI</code>高级驱动程序: disk, tape, cdrom, generic。</li>
<li>大多数以太网驱动程序。</li>
<li>大多数<code>CD-ROM</code>驱动程序：</li>
</ul>
<p>一旦一个<code>Linux</code>内核模块被装入，那么它就像任何标准的内核代码一样成为内核的一部分，它和任何内核代码一样具有相同的权限和职责。像所有的内核代码或驱动程序一样，<code>Linux</code>内核模块也能使内核崩溃。</p>
<h3 id="Linux内核模块的优缺点"><a href="#Linux内核模块的优缺点" class="headerlink" title="Linux内核模块的优缺点"></a>Linux内核模块的优缺点</h3><p>利用内核模块的动态装载性具有如下优点：</p>
<ul>
<li>将内核映像的尺寸保持在最小，并具有最大的灵活性；</li>
<li>便于检验新的内核代码，而不需重新编译内核并重新引导。</li>
</ul>
<p>但是，内核模块的引入也带来了如下问题： </p>
<ul>
<li>对系统性能和内存利用有负面影响；</li>
<li>装入的内核模块和其他内核部分一样，具有相同的访问权限，因此，差的内核模块会导致系统崩溃；</li>
<li>为了使内核模块访问所有内核资源，内核必须维护符号表，并在装入和卸载模块时修改这些符号表；</li>
<li>有些模块要求利用其他模块的功能，因此，内核要维护模块之间的依赖性；</li>
<li>内核必须能够在卸载模块时通知模块，并且要释放分配给模块的内存和中断等资源；</li>
<li>内核版本和模块版本的不兼容，也可能导致系统崩溃，因此，严格的版本检查是必需的。</li>
</ul>
<h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="模块符号"><a href="#模块符号" class="headerlink" title="模块符号"></a>模块符号</h4><p>为了方便起见，<code>Linux</code>把内核也看作一个模块。那么模块与模块之间如何进行交互呢，一种常用的方法就是共享变量和函数。但并不是模块中的每个变量和函数都能被共享，内核只把各个模块中主要的变量和函数放在一个特定的区段，这些变量和函数就统称为符号。对于内核模块，在<code>kernel/ksyms.c</code>中定义了从中可以“移出”的符号，例如进程管理子系统可以“移出”的符号定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* process memory management */</span></span><br><span class="line">EXPORT_SYMBOL(do_mmap_pgoff);</span><br><span class="line">EXPORT_SYMBOL(do_munmap);</span><br><span class="line">EXPORT_SYMBOL(do_brk);</span><br><span class="line">EXPORT_SYMBOL(exit_mm);</span><br><span class="line">EXPORT_SYMBOL(exit_files);</span><br><span class="line">EXPORT_SYMBOL(exit_fs);</span><br><span class="line">EXPORT_SYMBOL(exit_sighand);</span><br><span class="line">EXPORT_SYMBOL(complete_and_exit); </span><br><span class="line">EXPORT_SYMBOL(__wake_up);</span><br><span class="line">EXPORT_SYMBOL(__wake_up_sync);</span><br><span class="line">EXPORT_SYMBOL(wake_up_process);</span><br><span class="line">EXPORT_SYMBOL(sleep_on);</span><br><span class="line">EXPORT_SYMBOL(sleep_on_timeout);</span><br><span class="line">EXPORT_SYMBOL(interruptible_sleep_on);</span><br><span class="line">EXPORT_SYMBOL(interruptible_sleep_on_timeout);</span><br><span class="line">EXPORT_SYMBOL(schedule);</span><br><span class="line">EXPORT_SYMBOL(schedule_timeout);</span><br><span class="line">EXPORT_SYMBOL(jiffies);</span><br><span class="line">EXPORT_SYMBOL(xtime);</span><br><span class="line">EXPORT_SYMBOL(do_gettimeofday);</span><br><span class="line">EXPORT_SYMBOL(do_settimeofday);</span><br></pre></td></tr></table></figure></p>
<p>实际上，仅仅知道这些符号的名字是不够的，还得知道它们在内核映像中的地址才有意义。因此，内核中定义了如下结构来描述模块的符号：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module_symbol</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> value; <span class="comment">/*符号在内核映像中的地址*/</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name; <span class="comment">/*指向符号名的指针*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从后面对<code>EXPORT_SYMBOL</code>宏的定义可以看出，连接程序(ld)在连接内核映像时将这个结构存放在一个叫做<code>__ksymtab</code>的区段中，而这个区段中所有的符号就组成了模块对外“移出”的符号表，这些符号可供内核及已安装的模块来引用。而其他“对内”的符号则由连接程序自行生成，并仅供内部使用。</p>
<p>与<code>EXPORT_SYMBOL</code>相关的定义在<code>include/linux/module.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __MODULE_STRING_1(x) #x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MODULE_STRING(x) __MODULE_STRING_1(x)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __EXPORT_SYMBOL(sym, str) \</span></span><br><span class="line"><span class="meta">const char __kstrtab_##sym[] \</span></span><br><span class="line"><span class="meta">__attribute__((section(<span class="string">&quot;.kstrtab&quot;</span>))) = str; \</span></span><br><span class="line"><span class="meta">const struct module_symbol __ksymtab_##sym \</span></span><br><span class="line"><span class="meta">__attribute__((section(<span class="string">&quot;__ksymtab&quot;</span>))) = \</span></span><br><span class="line"><span class="meta"> &#123; (unsigned long)&amp;sym, __kstrtab_##sym &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(MODVERSIONS) || !defined(CONFIG_MODVERSIONS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL(var) __EXPORT_SYMBOL(var, __MODULE_STRING(var))</span></span><br></pre></td></tr></table></figure></p>
<p>下面我们以<code>EXPORT_SYMBOL(schedule)</code>为例，来看一下这个宏的结果是什么。</p>
<p>首先<code>EXPORT_SYMBOL(schedule)</code>的定义成了<code>__EXPORT_SYMBOL(schedule, &quot;schedule&quot;)</code>。而<code>__EXPORT_SYMBOL()</code>定义了两个语句，第 1 个语句定义了一个名为<code>__kstrtab_schedule</code>的字符串，将字符串的内容初始化为“schedule”，并将其置于内核映像中的<code>.kstrtab</code>区段，注意这是一个专门存放符号名字符串的区段。第 2 个语句则定义了一个名为<code>__kstrtab_schedule</code>的<code>module_symbol</code>结构，将其初始化为<code>&#123;&amp;schedule, __kstrtab_schedule&#125;</code>结构，并将其置于内核映像中的<code>__ksymtab</code>区段。这样，<code>module_symbol</code>结构中的域<code>value</code>的值就为<code>schedule</code>在内核映像中的地址，而指针<code>name</code>则指向字符串“schedule”。</p>
<h4 id="模块引用-Module-Reference"><a href="#模块引用-Module-Reference" class="headerlink" title="模块引用(Module Reference)"></a>模块引用(Module Reference)</h4><p>模块引用是一个不太好理解的概念。 有些装入内核的模块必须依赖其他模块，例如，因为<code>VFAT</code>文件系统是<code>FAT</code>文件系统或多或少的扩充集，那么，<code>VFAT</code>文件系统依赖(depend)于<code>FAT</code>文件系统，或者说，<code>FAT</code>模块被<code>VFAT</code>模块引用，或换句话说，<code>VFAT</code>为“父”模块，`FAT为“子”模块。其结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module_ref</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">dep</span>;</span> <span class="comment">/* “父”模块指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">ref</span>;</span> <span class="comment">/* “子”模块指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module_ref</span> *<span class="title">next_ref</span>;</span><span class="comment">/*指向下一个子模块的指针*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这里“dep”指的是依赖，也就是引用，而“ref”指的是被引用。因为模块引用的关系可能延续下去，例如<code>A</code>引用<code>B</code>，<code>B</code>有引用<code>C</code>，因此，模块的引用形成一个链表。</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>模块的结构为<code>module</code>，其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module_persist</span>;</span> <span class="comment">/* 待决定 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size_of_struct; <span class="comment">/* 模块结构的大小，即`sizeof(module) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">next</span>;</span> <span class="comment">/*指向下一个模块 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name; <span class="comment">/*模块名，最长为 64 个字符*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size; <span class="comment">/*以页为单位的模块大小*/</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="type">atomic_t</span> usecount; <span class="comment">/*使用计数，对其增减是原子操作*/</span></span><br><span class="line">		<span class="type">long</span> pad;</span><br><span class="line">	&#125; uc; <span class="comment">/* Needs to keep its size - so says rth */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* 模块的标志 */</span></span><br><span class="line">	<span class="type">unsigned</span> nsyms; <span class="comment">/* 模块中符号的个数 */</span></span><br><span class="line">	<span class="type">unsigned</span> ndeps; <span class="comment">/* 模块依赖的个数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module_symbol</span> *<span class="title">syms</span>;</span> <span class="comment">/* 指向模块的符号表,表的大小为`nsyms */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module_ref</span> <span class="title">deps</span>;</span> <span class="comment">/*指向模块引用的数组，大小为`ndeps */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module_ref</span> *<span class="title">refs</span>;</span></span><br><span class="line">	<span class="type">int</span> (*init)(<span class="type">void</span>); <span class="comment">/* 指向模块的`init_module()`函数 */</span></span><br><span class="line">	<span class="type">void</span> (*cleanup)(<span class="type">void</span>); <span class="comment">/* 指向模块的`cleanup_module()`函数 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exception_table_entry</span> *<span class="title">ex_table_start</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exception_table_entry</span> *<span class="title">ex_table_end</span>;</span></span><br><span class="line"><span class="comment">/* 以下域是在以上基本域的基础上的一种扩展，因此是可选的。可以调用`mod_member_present()函数来检查以下域的存在与否。*/</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">module_persist</span> *<span class="title">persist_start</span>;</span><span class="comment">/*尚未定义*/</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">module_persist</span> *<span class="title">persist_end</span>;</span></span><br><span class="line">	<span class="type">int</span> (*can_unload)(<span class="type">void</span>);</span><br><span class="line">	<span class="type">int</span> runsize <span class="comment">/*尚未使用*/</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *kallsyms_start; <span class="comment">/*用于内核调试的所有符号 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *kallsyms_end;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *archdata_start; <span class="comment">/* 与体系结构相关的特定数据*/</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *archdata_end;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *kernel_data; <span class="comment">/*保留 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>moudle</code>中的状态，即<code>flags</code>的取值定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Bits of module.flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD_UNINITIALIZED 0 <span class="comment">/*模块还未初始化*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD_RUNNING 1 <span class="comment">/*模块正在运行*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD_DELETED 2 <span class="comment">/*卸载模块的过程已经启动*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD_AUTOCLEAN 4 <span class="comment">/*安装模块时带有此标记，表示允许自动卸载模块*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD_VISITED 8 <span class="comment">/*模块被访问过*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD_USED_ONCE 16 <span class="comment">/*模块已经使用过一次*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD_JUST_FREED 32 <span class="comment">/*模块刚刚被释放*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD_INITIALIZING 64 <span class="comment">/*正在进行模块的初始化*/</span></span></span><br></pre></td></tr></table></figure></p>
<p>如前所述，虽然内核不是可安装模块，但它也有符号表，实际上这些符号表受到其他模块的频繁引用，将内核看作可安装模块大大简化了模块设计。因此，内核也有一个<code>module</code>结构，叫做<code>kernel_module</code>，与<code>kernel_module</code>相关的定义在<code>kernel/module_c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MODULES) || defined(CONFIG_KALLSYMS)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">module_symbol</span> __<span class="title">start___ksymtab</span>[];</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">module_symbol</span> __<span class="title">stop___ksymtab</span>[];</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exception_table_entry</span> __<span class="title">start___ex_table</span>[];</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exception_table_entry</span> __<span class="title">stop___ex_table</span>[];</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> __start___kallsyms[] __attribute__ ((weak));</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> __stop___kallsyms[] __attribute__ ((weak));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> <span class="title">kernel_module</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">	size_of_struct: <span class="keyword">sizeof</span>(<span class="keyword">struct</span> module),</span><br><span class="line">	name: <span class="string">&quot;&quot;</span>,</span><br><span class="line">	uc: &#123;ATOMIC_INIT(<span class="number">1</span>)&#125;,</span><br><span class="line">	flags: MOD_RUNNING,</span><br><span class="line">	syms: __start___ksymtab,</span><br><span class="line">	ex_table_start: __start___ex_table,</span><br><span class="line">	ex_table_end: __stop___ex_table,</span><br><span class="line">	kallsyms_start: __start___kallsyms,</span><br><span class="line">	kallsyms_end: __stop___kallsyms,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>首先要说明的是，内核对可安装模块的的支持是可选的。如果在编译内核代码之前的系统配置阶段选择了可安装模块，就定义了编译提示<code>CONFIG_MODULES</code>，使支持可安装模块的代码受到编译。同理，对用于内核调试的符号的支持也是可选的。</p>
<p>凡是在以上初始值未出现的域，其值均为 0 或<code>NULL</code>。显然，内核没有<code>init_module()</code>和<code>cleanup_module()</code>函数，因为内核不是一个真正的可安装模块。同时，内核没有<code>deps</code>数组，开始时也没有<code>refs</code>链。可是，这个结构的指针<code>syms</code>指向<code>__start___ksymtab</code>，这就是内核符号表的起始地址。符号表的大小<code>nsyms</code>为 0，但是在系统能初始化时会在<code>init_module()</code>函数中将其设置成正确的值。</p>
<p>在模块映像中也可以包含对异常的处理。发生于一些特殊地址上的异常，可以通过一种描述结构<code>exception_table_entry</code>规定对异常的反映和处理，这些结构在可执行映像连接时都被集中在一个数组中，内核的<code>exception_table_entry</code>结构数组就为<code>__start___ex_table[]</code>。当异常发生时，内核的异常响应处理程序就会先搜索这个数组，看看是否对所发生的异常规定了特殊的处理。</p>
<p>另外，从<code>kernel_module</code>开始，所有已安装模块的<code>module</code>结构都链在一起成为一条链，内核中的全局变量<code>module_list</code>就指向这条链：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module_list</span> =</span> &amp;kernel_module；</span><br></pre></td></tr></table></figure></p>
<h3 id="实现机制的分析"><a href="#实现机制的分析" class="headerlink" title="实现机制的分析"></a>实现机制的分析</h3><p>当你新建立了最小内核，并且重新启动后，你可以利用实用程序<code>insmod</code>和<code>rmmod</code>，随意地给内核插入或从内核中移走模块。如果<code>kerneld</code>守护进程启动，则由<code>kerneld</code>自动完成模块的插拔。有关模块实现的源代码在<code>/kernel/module.c</code>中，以下是对源代码中主要函数的分析。</p>
<h4 id="启动时内核模块的初始化函数init-modules"><a href="#启动时内核模块的初始化函数init-modules" class="headerlink" title="启动时内核模块的初始化函数init_modules()"></a>启动时内核模块的初始化函数init_modules()</h4><p>当内核启动时，要进行很多初始化工作，其中，对模块的初始化是在<code>main.c</code>中调用<code>init_modules()</code>函数完成的。实际上，当内核启动时唯一的模块就为内核本身，因此，初始化要做的唯一工作就是求出内核符号表中符号的个数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called at boot time</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">init_modules</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	kernel_module.nsyms = __stop___ksymtab - __start___ksymtab;</span><br><span class="line">	arch_init_modules(&amp;kernel_module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为内核代码被编译以后，连接程序进行连接时内核符号的符号结构就“移出”到了<code>ksymtab</code>区段，<code>__start___ksymtab</code>为第 1 个内核符号结构的地址，<code>__stop___ksymtab</code>为最后一个内核符号结构的地址，因此二者之差为内核符号的个数。其中，<code>arch_init_modules</code>是与体系结构相关的函数，对<code>i386</code>来说，<code>arch_init_modules</code>在<code>include/i386/module.h</code>中定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> arch_init_modules(x) do &#123; &#125; while (0)</span></span><br></pre></td></tr></table></figure></p>
<p>可见，对<code>i386</code>来说，这个函数为空。</p>
<h4 id="创建一个新模块"><a href="#创建一个新模块" class="headerlink" title="创建一个新模块"></a>创建一个新模块</h4><p>当用<code>insmod</code>给内核中插入一个模块时，意味着系统要创建一个新的模块，即为一个新的模块分配空间，函数<code>sys_create_module()</code>完成此功能，该函数也是系统调用<code>screate_module()</code>在内核的实现函数，其代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allocate space for a module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">asmlinkage <span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">sys_create_module</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name_user, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *name;</span><br><span class="line">	<span class="type">long</span> namelen, error;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">mod</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="keyword">if</span> (!capable(CAP_SYS_MODULE))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	lock_kernel();</span><br><span class="line">	<span class="keyword">if</span> ((namelen = get_mod_name(name_user, &amp;name)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		error = namelen;</span><br><span class="line">		<span class="keyword">goto</span> err0;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> module)+namelen) &#123;</span><br><span class="line">		error = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (find_module(name) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		error = -EEXIST;</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((mod = (<span class="keyword">struct</span> module *)module_map(size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(mod, <span class="number">0</span>, <span class="keyword">sizeof</span>(*mod));</span><br><span class="line">	mod-&gt;size_of_struct = <span class="keyword">sizeof</span>(*mod);</span><br><span class="line">	mod-&gt;name = (<span class="type">char</span> *)(mod + <span class="number">1</span>);</span><br><span class="line">	mod-&gt;size = size;</span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="type">char</span>*)(mod+<span class="number">1</span>), name, namelen+<span class="number">1</span>);</span><br><span class="line">	put_mod_name(name);</span><br><span class="line">	spin_lock_irqsave(&amp;modlist_lock, flags); </span><br><span class="line"></span><br><span class="line">	mod-&gt;next = module_list;</span><br><span class="line">	module_list = mod; <span class="comment">/* link it in */</span></span><br><span class="line">	spin_unlock_irqrestore(&amp;modlist_lock, flags);</span><br><span class="line">	error = (<span class="type">long</span>) mod;</span><br><span class="line">	<span class="keyword">goto</span> err0;</span><br><span class="line">err1:</span><br><span class="line">	 put_mod_name(name);</span><br><span class="line">err0:</span><br><span class="line">	 unlock_kernel();</span><br><span class="line">	 <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面对该函数中的主要语句给予解释。</p>
<ul>
<li><code>capable(CAP_SYS_MODULE)</code>检查当前进程是否有创建模块的特权。</li>
<li>参数<code>size</code>表示模块的大小，它等于<code>module</code>结构的大小加上模块名的大小，再加上模块映像的大小，显然，<code>size</code>不能小于后两项之和。</li>
<li><code>get_mod_name()</code>函数获得模块名的长度。</li>
<li><code>find_module()</code>函数检查是否存在同名的模块，因为模块名是模块的唯一标识。</li>
<li>调用<code>module_map()</code>分配空间，对<code>i386</code>来说，就是调用<code>vmalloc()</code>函数从内核空间的非连续区分配空间。</li>
<li><code>memset()</code>将分配给<code>module</code>结构的空间全部填充为 0，也就是说，把通过<code>module_map()</code>所分配空间的开头部分给了<code>module</code>结构；然后(module+1)表示从<code>mod</code>所指的地址加上一个<code>module</code>结构的大小，在此处放上模块的名字；最后，剩余的空间给模块映像。</li>
<li>新建<code>moudle</code>结构只填充了三个值，其余值有待于从用户空间传递过来。</li>
<li><code>put_mod_name()</code>释放局部变量<code>name</code>所占的空间。</li>
<li>将新创建的模块结构链入<code>module_list</code>链表的首部。</li>
</ul>
<h4 id="初始化一个模块"><a href="#初始化一个模块" class="headerlink" title="初始化一个模块"></a>初始化一个模块</h4><p>从上面可以看出，<code>sys_create_module()</code>函数仅仅在内核为模块开辟了一块空间，但是模块的代码根本没有拷贝过来。实际上，模块的真正安装工作及其他的一些初始化工作由<code>sys_init_module()</code>函数完成，该函数就是系统调用<code>init_module()</code>在内核的实现代码。</p>
<p>该函数的原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_init_module</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name_user, <span class="keyword">struct</span> module *mod_user)</span></span><br></pre></td></tr></table></figure></p>
<p>其中参数<code>name_user</code>为用户空间的模块名，<code>mod_user</code>为指向用户空间欲安装模块的<code>module</code>结构。</p>
<p>该函数的主要操作描述如下。</p>
<ul>
<li><code>sys_create_module()</code>在内核空间创建了目标模块的<code>module</code>结构，但是这个结构还基本为空，其内容只能来自用户空间。因此，初始化函数就要把用户空间的<code>module</code>结构拷贝到内核中对应的<code>module</code>结构中。但是，由于内核版本在不断变化，因此用户空间<code>module</code>结构可能与内核中的<code>module</code>结构不完全一样。为了防止二者的<code>module</code>结构在大小上的不一致而造成麻烦，因此，首先要把用户空间的<code>module</code>结构中的<code>size_of_struct</code>域复制过来加以检查。</li>
<li>通过了对结构大小的检查以后，先把内核中的<code>module</code>结构保存在堆栈中作为后备，然后就从用户空间拷贝其<code>module</code>结构。复制时是以内核中<code>module</code>结构的大小为准的，以免破坏内核中的内存空间。</li>
<li>复制过来以后，还要检查<code>module</code>结构中各个域的合理性。</li>
<li>最后，还要对模块名进行进一步的检查。虽然已经根据参数<code>name_user</code>从用户空间拷贝过来了模块名，但是这个模块名可能与用户空间<code>module</code>结构中所指示的模块名不一致，因此还要根据<code>module</code>结构的内容把模块映像中的模块名也复制过来，再与原来使用的模块名进行比较。</li>
<li>经过以上检查以后，可以从用户空间把模块的映像复制过来了。</li>
<li>模块之间的依赖关系还得进行修正，因为正在安装的模块可能要引用其他模块中的符号。虽然在用户空间已经完成了对这些符号的连接，但现在必须验证所依赖的模块在内核中还未被卸载。如果所依赖的模块已经不在内核中了，则对目标模块的安装就失败了。在这种情况下，应用程序(例如<code>insmod</code>)有责任通过系统调用<code>delete_module()</code>将已经创建的<code>module</code>结构从<code>moudle_list</code>中删除。</li>
<li>至此，模块的安装已经基本完成，但还有一件事要做，那就是启动待执行模块的<code>init_moudle()</code>函数，每个模块块必须有一个这样的函数，<code>module</code>结构中的函数指针<code>init</code>就指向这个函数，内核可以通过这个函数访问模块中的变量和函数，或者说，<code>init_moudle()</code>是模块的入口，就好像每个可执行程序的入口都是<code>main()</code>一样。</li>
</ul>
<h4 id="卸载模块的函数sys-delete-module"><a href="#卸载模块的函数sys-delete-module" class="headerlink" title="卸载模块的函数sys_delete_module()"></a>卸载模块的函数sys_delete_module()</h4><p>卸载模块的系统调用为<code>delete_module()</code>，其内核的实现函数为<code>sys_delete_module()</code>，该函数的原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_delete_module</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name_user)</span></span><br></pre></td></tr></table></figure></p>
<p>与前面几个系统调用一样，只有特权用户才允许卸载模块。卸载模块的方式有两种，这取决于参数<code>name_user</code>，<code>name_user</code>是用户空间中的模块名。如果<code>name_user</code>非空，表示卸载一个指定的模块；如果为空，则卸载所有可以卸载的模块。</p>
<p>(1)卸载指定的模块：一个模块能否卸载，首先要看内核中是否还有其他模块依赖该模块，也就是该模块中的符号是否被引用，更具体地说，就是检查该模块的<code>refs</code>指针是否为空。此外，还要判断该模块是否在使用中，即<code>__MOD_IN_USE()</code>宏的值是否为 0。只有未被依赖且未被使用的模块才可以卸载。</p>
<p>卸载模块时主要要调用目标模块的<code>cleanup_module()</code>函数，该函数撤销模块在内核中的注册，使系统不再能引用该模块。</p>
<p>一个模块的拆除有可能使它所依赖的模块获得自由，也就是说，它所依赖的模块其<code>refs</code>队列变为空，一个<code>refs</code>队列为空的模块就是一个自由模块，它不再被任何模块所依赖。 </p>
<p>(2)卸载所有可以卸载的模块：如果参数<code>name_user</code>为空，则卸载同时满足以下条件的所有模块。</p>
<ul>
<li>不再被任何模块所依赖。</li>
<li>允许自动卸载，即安装时带有<code>MOD_AUTOCLEAN</code>标志位。</li>
<li>已经安装但尚未被卸载，即处于运行状态。</li>
<li>尚未被开始卸载。</li>
<li>安装以后被引用过。</li>
<li>已不再使用。</li>
</ul>
<p>以上介绍了<code>init_module()</code>、<code>create_module()</code>、<code>delete_module()</code>三个系统调用在内核的实现机制，还有一个查询模块名的系统调用<code>query_module()</code>。这几个系统调用是在实现<code>insmod</code>及<code>rmmod</code>实用程序的过程中被调用的。</p>
<h4 id="装入内核模块request-module-函数"><a href="#装入内核模块request-module-函数" class="headerlink" title="装入内核模块request_module()函数"></a>装入内核模块request_module()函数</h4><p>在用户通过<code>insmod</code>安装模块的过程中，内核是被动地接受用户发出的安装请求。但是，在很多情况下，内核需要主动地启动某个模块的安装。例如，当内核从网络中接收到一个特殊的<code>packet</code>或报文时，而支持相应规程的模块尚未安装；又如，当内核检测到某种硬件时，而支持这种硬件的模块尚未安装等等，类似情况还有很。在这种情况下，内核就调用<code>request_module()</code>主动地启动模块的安装。</p>
<p><code>request_module()</code>函数在<code>kernel/kmod.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request_module - try to load a kernel module</span></span><br><span class="line"><span class="comment"> * @module_name: Name of module</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"> * Load a module using the user mode module loader. The function returns</span></span><br><span class="line"><span class="comment"> * zero on success or a negative errno code on failure. Note that a</span></span><br><span class="line"><span class="comment"> * successful module load does not mean the module did not then unload</span></span><br><span class="line"><span class="comment"> * and exit on an error of its own. Callers must check that the service</span></span><br><span class="line"><span class="comment"> * they requested is now available not blindly invoke it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If module auto-loading support is disabled then this function</span></span><br><span class="line"><span class="comment"> * becomes a no-operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_module</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * module_name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">int</span> waitpid_result;</span><br><span class="line">	<span class="type">sigset_t</span> tmpsig;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">static</span> <span class="type">atomic_t</span> kmod_concurrent = ATOMIC_INIT(<span class="number">0</span>);</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> MAX_KMOD_CONCURRENT 50 <span class="comment">/* Completely arbitrary value - KAO */</span></span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> kmod_loop_msg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don&#x27;t allow request_module() before the root fs is mounted! */</span></span><br><span class="line">	<span class="keyword">if</span> ( ! current-&gt;fs-&gt;root ) &#123; </span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;request_module[%s]: Root fs not mounted\n&quot;</span>, module_name);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If modprobe needs a service that is in a module, we get a recursive</span></span><br><span class="line"><span class="comment">	* loop. Limit the number of running kmod threads to max_threads/2 or</span></span><br><span class="line"><span class="comment">	* MAX_KMOD_CONCURRENT, whichever is the smaller. A cleaner method</span></span><br><span class="line"><span class="comment">	* would be to run the parents of this process, counting how many times</span></span><br><span class="line"><span class="comment">	* kmod was invoked. That would mean accessing the internals of the</span></span><br><span class="line"><span class="comment">	* process tables to get the command line, proc_pid_cmdline is static</span></span><br><span class="line"><span class="comment">	* and it is not worth changing the proc code just to handle this case.</span></span><br><span class="line"><span class="comment">	* KAO.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	i = max_threads/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; MAX_KMOD_CONCURRENT)</span><br><span class="line">		i = MAX_KMOD_CONCURRENT;</span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;kmod_concurrent);</span><br><span class="line">	<span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;kmod_concurrent) &gt; i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (kmod_loop_msg++ &lt; <span class="number">5</span>)</span><br><span class="line">			printk(KERN_ERR</span><br><span class="line">			<span class="string">&quot;kmod: runaway modprobe loop assumed and stopped\n&quot;</span>);</span><br><span class="line">		<span class="type">atomic_dec</span>(&amp;kmod_concurrent);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pid = kernel_thread(exec_modprobe, (<span class="type">void</span>*) module_name, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;request_module[%s]: fork failed, errno %d\n&quot;</span>, module_name, -pid);</span><br><span class="line">		<span class="type">atomic_dec</span>(&amp;kmod_concurrent);</span><br><span class="line">		<span class="keyword">return</span> pid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Block everything but SIGKILL/SIGSTOP */</span></span><br><span class="line">	spin_lock_irq(&amp;current-&gt;sigmask_lock);</span><br><span class="line">	tmpsig = current-&gt;blocked;</span><br><span class="line">	siginitsetinv(&amp;current-&gt;blocked, sigmask(SIGKILL) | sigmask(SIGS- TOP));</span><br><span class="line">	recalc_sigpending(current);</span><br><span class="line">	spin_unlock_irq(&amp;current-&gt;sigmask_lock);</span><br><span class="line"></span><br><span class="line">	waitpid_result = waitpid(pid, <span class="literal">NULL</span>, __WCLONE);</span><br><span class="line">	<span class="type">atomic_dec</span>(&amp;kmod_concurrent);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow signals again.. */</span></span><br><span class="line">	spin_lock_irq(&amp;current-&gt;sigmask_lock);</span><br><span class="line">	current-&gt;blocked = tmpsig;</span><br><span class="line">	recalc_sigpending(current);</span><br><span class="line">	spin_unlock_irq(&amp;current-&gt;sigmask_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (waitpid_result != pid) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;request_module[%s]: waitpid(%d,...) failed, errno %d\n&quot;</span>,</span><br><span class="line">		module_name, pid, -waitpid_result); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对该函数的解释如下。</p>
<ul>
<li>因为<code>request_module()</code>是在当前进程的上下文中执行的，因此首先检查当前进程所在的根文件系统是否已经安装。</li>
<li>对<code>request_module()</code>的调用有可能嵌套，因为在安装过程中可能会发现必须先安装另一个模块。因此，就要对嵌套深度加以限制，程序中设置了一个静态变量<code>kmod_concurrent</code>，作为嵌套深度的计数器，并且还规定了嵌套深度的上限为<code>MAX_KMOD_CONCURRENT</code>。不过，对嵌套深度的控制还要考虑到系统中对进程数量的限制，即<code>max_therads</code>，因为在安装的过程中要创建临时的进程。</li>
<li>通过了这些检查以后，就调用<code>kernel_thread()</code>创建一个内核线程<code>exec_modprobe()</code>。<code>exec_modprobe()</code>接受要安装的模块名作为参数，调用<code>execve()</code>系统调用执行外部程序<code>/sbin/modprobe</code>，然后，<code>modprobe</code>程序真正地安装要安装的模块以及所依赖的任何模块。</li>
<li>创建内核线程成功以后，先把当前进程信号中除<code>SIGKILL</code>和<code>SIGSTOP</code>以外的所有信号都屏蔽掉，免得当前进程在等待模块安装的过程中受到干扰，然后就通过<code>waitpid()</code>使当前进程睡眠等待，直到<code>exec_modprobe()</code>内核线程完成模块安装后退出。当前进程被唤醒而从<code>waitpid()</code>返回时，又要恢复当前进程原有信号的设置。根据<code>waitpid()</code>的返回值可以判断<code>exec_modprobe()</code>操作的成功与否。如果失败，就通过<code>prink()</code>在系统的运行日志<code>/var/log/message</code>中记录一条出错信息。</li>
</ul>
<h2 id="模块的装入和卸载"><a href="#模块的装入和卸载" class="headerlink" title="模块的装入和卸载"></a>模块的装入和卸载</h2><h3 id="实现机制-1"><a href="#实现机制-1" class="headerlink" title="实现机制"></a>实现机制</h3><p>有两种装入模块的方法，第 1 种是用<code>insmod</code>命令人工把模块插入到内核，第 2 种是一种更灵活的方法，当需要时装入模块，这就是所谓的请求装入。</p>
<p>当内核发现需要一个模块时，例如，用户安装一个不在内核的文件系统时，内核将请求内核守护进程(kerneld)装入一个合适的模块。内核守护进程(kerneld)是一个标准的用户进程，但它具有超级用户权限。<code>kerneld</code>通<br>常是在系统启动时就开始执行，它打开<code>IPC</code>(Inter-Process Communication)到内核的通道，内核通过给<code>kerneld</code>发送消息请求执行各种任务。</p>
<p><code>kerneld</code>的主要功能是装入和卸载内核模块，但它也具有承担其他任务的能力，<code>kerneld</code>并不执行这些任务，它通过运行诸如<code>insmod</code>这样的程序来做这些工作，<code>kerneld</code>仅仅是内核的一个代理。<code>insmod</code>实用程序必须找到请求装入的内核模块，请求装入的内核模块通常保存在<code>/lib/modules/kernel-version/</code>目录下。内核模块被连接成目标文件，与系统中其他程序不同的是，这种目标文件是可重定位的(它们是<code>a.out</code>或<code>ELF</code>格式的目标文件)。<code>insmods</code>实用程序位于<code>/sbin</code>目录下，该程序执行以下操作。</p>
<ol>
<li>从命令行中读取要装入的模块名。</li>
<li>确定模块代码所在的文件在系统目录树中的位置，即<code>/lib/modules/kernel-version/</code>目录。</li>
<li>计算存放模块代码、模块名和<code>module</code>结构所需要的内存区大小。调用<code>create_module()</code>系统调用，向它传递新模块的模块名和大小。</li>
<li>用<code>QM_MODULES</code>子命令反复调用<code>query_module()</code>系统调用来获得所有已安装模块的模块名。</li>
<li>用<code>QM_SYMBOL</code>子命令反复调用<code>query_module()</code>系统调用来获得内核符号表和所有已经安装到内核的模块的符号表。</li>
<li>使用内核符号表、模块符号表以及<code>create_module()</code>系统调用所返回的地址重新定位该模块文件中所包含的文件的代码。这就意味着用相应的逻辑地址偏移量来替换所有出现的外部符号和全局符号。</li>
<li>在用户态地址空间中分配一个内存区，并把<code>module</code>结构、模块名以及为正在运行的内核所重定位的模块代码的一个拷贝装载到这个内存区中。如果该模块定义了<code>init_module()</code>函数，那么<code>module</code>结构的<code>init</code>域就被设置成该模块的<code>init_module()</code>函数重新分配的地址。同理，如果模块定义了<code>cleanup_module()</code>函数，那么<code>cleanup</code>域就被设置成模块的<code>cleanup_module()</code>函数所重新分配的地址。</li>
<li>调用<code>init_module()</code>系统调用，向它传递上一步中所创建的用户态的内存区地址。</li>
<li>释放用户态内存区并结束。</li>
</ol>
<p>为了取消模块的安装，用户需要调用<code>/sbin/rmmod</code>实用程序，它执行以下操作：</p>
<ol>
<li>从命令行中读取要卸载的模块的模块名。</li>
<li>使用<code>QM_MODULES</code>子命令调用<code>query_module()</code>系统调用来取得已经安装的模块的链表。</li>
<li>使用<code>QM_REFS</code>子命令多次调用<code>query_module()</code>系统调用来检索已安装的模块间的依赖关系。如果一个要卸载的模块上面还安装有某一模块，就结束。</li>
<li>调用<code>delete_module()</code>系统调用，向其传递模块名。</li>
</ol>
<h2 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h2><h3 id="内核版本与模块版本的兼容性"><a href="#内核版本与模块版本的兼容性" class="headerlink" title="内核版本与模块版本的兼容性"></a>内核版本与模块版本的兼容性</h3><p>内核版本的变化直接影响着曾经编写的模块是否能被新的内核认可。</p>
<p>例如，<code>mydriver.o</code>是基于Linux 2.2.1 内核编写和编译的，但是有人想把它装入到Linux2.2.2 的内核中，如果<code>mydriver.o</code>所调用的内核函数在 2.2.2 中有所变化，那么内核怎么知道内核版本与模块所调用函数的版本不一致呢？</p>
<p>为了解决这个问题，可装入模块的开发者就决定给模块也编以内核的版本号。在上面的例子中，<code>mydriver.o</code>目标文件的<code>.modinfo</code>特殊区段就含有“2.2.1”，因为<code>mydriver.o</code>的编译使用了来自Linux 2.2.1 的头文件，因此，当把该驱动程序装入到 2.2.2 内核时，<code>insmod</code>就会发现不匹配而失败，从而告诉你内核版本不匹配。</p>
<p>当以符号编码来编译内核或模块时，我们前面介绍的<code>EXPORT_SYMBOL()</code>宏定义的形式就有所不同，例如模块最常调用的内核函数<code>register_chrdev()</code>，其函数名的宏定义的在<code>C</code>中为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> register_chrdev register_chrdev_Rc8dc8350</span></span><br></pre></td></tr></table></figure></p>
<p>把符号<code>register_chrdev</code>定义为<code>register_chrdev</code>加上一个后缀，这个后缀就是<code>register_chrdev()</code>函数实际源代码的校验和，只要函数的源代码改动一个字符，这个校验和也会发生变化。因此，尽管你在源代码中读到的函数名为<code>register_chrdev</code>，但<code>C</code>的预处理程序知道真正调用的是<code>register_chrdev_Rc8dc8350</code>。</p>
<h3 id="从版本-2-0-到-2-2-内核API的变化"><a href="#从版本-2-0-到-2-2-内核API的变化" class="headerlink" title="从版本 2.0 到 2.2 内核API的变化"></a>从版本 2.0 到 2.2 内核API的变化</h3><h4 id="用户空间与内核空间之间数据的拷贝"><a href="#用户空间与内核空间之间数据的拷贝" class="headerlink" title="用户空间与内核空间之间数据的拷贝"></a>用户空间与内核空间之间数据的拷贝</h4><p>我们知道，内核空间与用户空间之间数据的拷贝要通过一个缓冲区，在以前的内核中，对这个缓冲区有效性的检查是通过<code>verify_area()</code>函数的，如果这个缓冲区有效，则调用<code>memcpy_tofs()</code>把数据从内核空间拷贝到用户空间。但是，<code>verify_area()</code>函数是低效的，因为它必须检查每一个页面，看其是否是一个有效的映射。</p>
<p>在 2.1.x(以及后来的版本)中，取消了对用户空间缓冲区每个页面的检查，取而代之的是用异常来处理非法的缓冲区。这就避免了在<code>SMP</code>上的竞争条件及有效性检查。<code>verify_area()</code>函数现在仅仅用来检查缓冲区的范围是否合法，这是一个快速的操作。因此，如果你要把数据拷贝到用户空间，就使用<code>copy_to_user()</code>函数，其用法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( copy_to_user (ubuff, kbuff, length) ) <span class="keyword">return</span> -EFAULT;</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>ubuff</code>是用户空间的缓冲区，<code>kbuff</code>是内核空间的缓冲区，而<code>length</code>是要拷贝的字节数。如果<code>copy_to_user()</code>函数返回一个非 0 值，就意味着某些数据没有被拷贝(由于无效的缓冲区)。在这种情况下，返回<code>-EFAULT</code>以表示缓冲区是无效的。类似地，从用户空间拷贝到内核空间的用法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( copy_from_user (kbuff, ubuff, length) ) <span class="keyword">return</span> -EFAULT;</span><br></pre></td></tr></table></figure></p>
<p>注意，这两个函数都自动调用<code>verify_area()</code>函数，你没必要自己调用它。</p>
<h4 id="文件操作的方法"><a href="#文件操作的方法" class="headerlink" title="文件操作的方法"></a>文件操作的方法</h4><p>在内核 2.1.42 版本以后，增加了一个目录高速缓存(dcache)层，这个层加速了目录搜索操作(大约能提高 4 倍)，但同时也需要改变文件操作接口。对驱动程序的编写者，这个变化相对比较简单：原来传递给<code>file_operations</code>某些方法的参数为<code>struct inode *</code>，现在改为<code>struct dentry *</code>。如果你的驱动程序要引用<code>inode</code>，下面代码就足够了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br></pre></td></tr></table></figure></p>
<p>假定<code>dentry</code>是目录项的变量名。实际上，有些驱动程序就不涉及<code>inode</code>，因此可忽略这一步。然而，你必须改变的是，重新声明<code>file_operations</code>中的函数。注意，某些方法还是把<code>inode</code>而不是<code>dentry</code>作为参数来传递。</p>
<p>有些方法甚至没有提供<code>dentry</code>，仅仅提供了<code>struct file *</code>，在这种情况下，你可以用下面的代码提取出<code>dentry</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> file-&gt;f_dentry;</span><br></pre></td></tr></table></figure></p>
<p>假定<code>file</code>是指向<code>file</code>指针的变量名。</p>
<p>下面是内核 2.2.x文件操作的方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">loff_t</span> <span class="title function_">llseek</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>)</span>; </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">readdir</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">poll</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span> <span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mmap</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span> <span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">flush</span> <span class="params">(<span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">release</span> <span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dentry *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fasync</span> <span class="params">(<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check_media_change</span> <span class="params">(<span class="type">kdev_t</span> dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">revalidate</span> <span class="params">(<span class="type">kdev_t</span> dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lock</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *)</span>;</span><br></pre></td></tr></table></figure></p>
<p>在你声明自己的<code>file_operations</code>结构时，应当确保把自己的方法放置在与上面一致的位置。不过，还有另外一种我们提到过的方法，其形式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mydev_fops</span> =</span> &#123;</span><br><span class="line"> open: mydev_open,</span><br><span class="line"> release: mydev_close,</span><br><span class="line"> read: mydev_read,</span><br><span class="line"> write: mydev_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>gcc</code>编译程序能够把这些方法放在正确的位置，并把未定义的方法置为<code>NULL</code>。</p>
<p>另外还值得注意的是，<code>Linux 2.2</code>中引入了<code>pread()</code>和<code>pwrite()</code>系统调用，这就允许进程可以从一个文件的指定位置进行读和写，这与另一个<code>lseek()</code>系统调用类似但不完全相同。其不同之处是，<code>pread()</code>和<code>pwrite()</code>系统调用能对一个文件进行并发访问。为了对这些新的系统调用进行支持，在<code>read()</code>和<code>write()</code>方法中增加了第 4 个(或最后一个)参数，这个参数是指向<code>offset</code>的一个指针。</p>
<h4 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h4><p>新增加的<code>signal_pending()</code>函数时的信号的处理更加容易和健壮。2.0 版处理方式是:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current-&gt;signal &amp; ~current-&gt;blocked)</span><br></pre></td></tr></table></figure></p>
<p>2.2 版是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( signal_pending (current) ) </span><br></pre></td></tr></table></figure></p>
<h4 id="IO事件的多路技术"><a href="#IO事件的多路技术" class="headerlink" title="IO事件的多路技术"></a>IO事件的多路技术</h4><p><code>select()</code>和<code>poll()</code>系统调用可以让一个进程同时处理多个文件描述符，也就是说可以使进程检测同时等待的多个<code>I/O</code>设备，当没有设备准备好时，<code>select()</code>阻塞，其中任一设备准备好时，<code>select()</code>就返回。在<code>Linux 2.0</code>中，驱动程序通过在<code>file_operations</code>结构中提供<code>select()</code>方法来支持这种技术，而在<code>Linux 2.2</code>中，驱动程序必须提供的是<code>poll()</code>方法，这种方法具有更大的灵活性。</p>
<h4 id="丢弃初始化函数和数据"><a href="#丢弃初始化函数和数据" class="headerlink" title="丢弃初始化函数和数据"></a>丢弃初始化函数和数据</h4><p>当内核初始化全部完成以后，就可以丢弃以后不再需要的函数和数据，这意味着存放这些函数和数据的内存可以重新得到使用。但这仅仅应用在编译进内核的驱动程序，而不适合于可安装模块。</p>
<p>定义一个以后要丢弃的变量的形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> mydata __initdata = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>定义一个以后要丢弃的函数的形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__initfunc(<span class="type">void</span> myfunc (<span class="type">void</span>))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__initdata</code>和<code>__initfunc</code>关键字把代码和数据放在一个特殊的“初始化”区段。较理想的做法应当是，尽可能地把更多的代码和数据放在初始化区段，当然，这里的代码和数据指的是初始化以后(当<code>init</code>进程启动时)不再使用的。</p>
<h4 id="定时的设定"><a href="#定时的设定" class="headerlink" title="定时的设定"></a>定时的设定</h4><p>新增加了一些定时设定函数。Linux 2.0 设定定时是这样的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current-&gt;timeout = jiffies + timeout;</span><br><span class="line">schedule ();</span><br></pre></td></tr></table></figure></p>
<p>Linux 2.2 是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout = schedule_timeout (timeout);</span><br></pre></td></tr></table></figure></p>
<p>同理，如果你需要在一个等待队列上睡眠，但需要定时，Linux 2.0 操作是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current-&gt;timeout = jiffies + timeout;</span><br><span class="line">interruptible_sleep_on (&amp;wait);</span><br></pre></td></tr></table></figure></p>
<p>Linux 2.2 是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout = interruptible_sleep_on_timeout (&amp;wait, timeout);</span><br></pre></td></tr></table></figure></p>
<p>注意，这些新函数返回的是剩余时间的多少。在某些情况下，这些函数在定时时间还没到就返回。</p>
<h4 id="向后兼容的宏"><a href="#向后兼容的宏" class="headerlink" title="向后兼容的宏"></a>向后兼容的宏</h4><p>你可以把下面的代码包含进自己编写的代码中，这样就不必费神维护是为<code>Linux 2.2.x</code>还是为<code>Linux 2.0.x</code>所编译的驱动程序。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KERNEL_VERSION</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KERNEL_VERSION(a,b,c) (((a) &lt;&lt; 16) + ((b) &lt;&lt; 8) + (c)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,1,0))</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_to_user</span> <span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> *from,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ( !verify_area (VERIFY_WRITE, to, n) ) <span class="keyword">return</span> n;</span><br><span class="line">	memcpy_tofs (to, from, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_from_user</span> <span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> *from,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ( !verify_area (VERIFY_READ, from, n) ) <span class="keyword">return</span> n;</span><br><span class="line">	memcpy_fromfs (to, from, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __initdata</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __initfunc(func) func</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> signal_pending</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> signal_pending(p) ( (p)-&gt;signal &amp; ~(p)-&gt;blocked )</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="把内核-2-2-移植到内核-2-4"><a href="#把内核-2-2-移植到内核-2-4" class="headerlink" title="把内核 2.2 移植到内核 2.4"></a>把内核 2.2 移植到内核 2.4</h3><h4 id="使用设备文件系统-DevFS"><a href="#使用设备文件系统-DevFS" class="headerlink" title="使用设备文件系统(DevFS)"></a>使用设备文件系统(DevFS)</h4><p><code>DevFS</code>设备文件系统是<code>Linux 2.4</code>一个全新的功能，它主要为了有效地管理<code>/dev</code>目录而开发的。<code>UNIX/Linux</code>中所有的目录都是层次结构，唯独<code>/dev</code>目录是一维结构(没有子目录)，这就直接影响着访问的效率及管理的方便与否。另外，<code>/dev</code>目录下的节点并不是按实际需要创建的，因此，该目录下存在大量实际不用的节点，但一般也不能轻易删除。</p>
<p>理想的<code>/dev</code>目录应该是层次的、其规模是可伸缩的。<code>DevFS</code>就是为达到此目的而设计的。它在底层改写了用户与设备交互的方式和途径。它会给用户在两方面带来影响。</p>
<ul>
<li>首先，几乎所有的设备名称都做了改变，例如：<code>/dev/hda</code>是用户的硬盘，现在可能被定位于<code>/dev/ide0/...</code>。这一修改方案增大了设备可用的名字空间，且容许<code>USB</code>类和类似设备的系统集成。</li>
<li>其次，不再需要用户自己创建设备节点。<code>DevFS</code>的<code>/dev</code>目录最初是空的，里面特定的文件是在系统启动时、或是加载模块后驱动程序装入时建立的。当模块和驱动程序卸载时，文件就消失了。</li>
</ul>
<p>字符设备的注册和注销调用<code>register_chrdev()</code>和<code>unregister_chrdev()</code>函数。注册了设备驱动程序以后，驱动程序应该调用<code>devfs_register()</code>登记设备的入口点，所谓设备的入口点就是设备所在的路径名；在注销设备驱动程序之前，应该调用<code>devfs_unregister()</code>取消注册。</p>
<p><code>devfs_register()</code>和<code>devfs_unregister()</code>函数原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">devfs_handle_t</span> <span class="title function_">devfs_register</span><span class="params">(<span class="type">devfs_handle_t</span> dir, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">unsigned</span> <span class="type">int</span> minor,</span></span><br><span class="line"><span class="params"><span class="type">umode_t</span> mode, <span class="type">void</span> *ops, <span class="type">void</span> *info)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">devfs_unregister</span><span class="params">(<span class="type">devfs_handle_t</span> de)</span>;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>devfs_handle_t</code>表示<code>DevFS</code>的句柄(一个结构类型)，每个参数的含义如下。</p>
<ul>
<li><code>dir</code>：我们要创建的文件所在的<code>DevFS</code>的句柄。<code>NULL</code>意味着这是<code>DevFS</code>的根，即<code>/dev</code>。</li>
<li><code>flags</code>：设备文件系统的标志，缺省值为<code>DEVFS_FL_DEFAULT</code>。</li>
<li><code>major</code>：主设备号，普通文件不需要这一参数。</li>
<li><code>minor</code>：次设备号，普通文件也不需要这一参数。</li>
<li><code>mode</code>：缺省的文件模式(包括属性和许可权)。</li>
<li><code>ops</code>：指向<code>file_operations</code>或<code>block_device_operations</code>结构的指针。</li>
<li><code>info</code>：任意一个指针，这个指针将被写到<code>file</code>结构的<code>private_data</code>域。</li>
</ul>
<p>例如，如果我们要注册的设备驱动程序叫做<code>DEVICE_NAME</code>，其主设备号为<code>MAJOR_NR</code>，次设备号为<code>MINOR_NR</code>，缺省的文件操作为<code>device_fops</code>，则该设备驱动程序的<code>init_module()</code>函数和<code>cleanup_module()</code>函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">if</span>((ret = register_chrdev(MAJOR_NR, DEVICE_NAME, &amp;device_fops))==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	unregister_chrdev(MAJOR_NR, DEVICE_NAME); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对以上代码进行改写以支持设备文件系统(假定设备入口点的名字为<code>DEVICE_ENTRY</code>)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/devfs_fs_kernel.h&gt;</span></span></span><br><span class="line"><span class="type">devfs_handle_t</span> devfs_handle;</span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">if</span> ((ret = devfs_register_chrdev(MAJOR_NR, DEVICE_NAME, &amp;device_fops)) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	devfs_handle = devfs_register(<span class="literal">NULL</span>, DEVICE_ENTRY, DEVFS_FL_DEFAULT,</span><br><span class="line">		MAJOR_NR, MINOR_NR, S_IFCHR | S_IRUGO | S_IWUSR,</span><br><span class="line">		&amp;device_fops, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	devfs_unregister_chrdev(MAJOR_NR, DEVICE_NAME);</span><br><span class="line">	devfs_unregister(devfs_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>devfs_mk_dir()</code>用来创建一个目录，这个函数返回<code>DevFS</code>的句柄，这个句柄用作<code>devfs_register</code>的参数<code>dir</code>。</p>
<p>例如，为了在<code>/dev/mydevice</code>目录下创建一个设备设备入口点，则进行如下操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devfs_handle = devfs_mk_dir(<span class="literal">NULL</span>, <span class="string">&quot;mydevice&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">devfs_register(devfs_handle, DEVICE_ENTRY, DEVFS_FL_DEFAULT,</span><br><span class="line"> MAJOR_NR, MINOR_NR, S_IFCHR | S_IRUGO | S_IWUSR,</span><br><span class="line"> &amp;device_fops, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p>注册和注销块设备的函数为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devfs_register_blkdev()</span><br><span class="line">devfs_unregister_blkdev () </span><br></pre></td></tr></table></figure></p>
<h4 id="使用-proc文件系统"><a href="#使用-proc文件系统" class="headerlink" title="使用/proc文件系统"></a>使用/proc文件系统</h4><p><code>/proc</code>是一个特殊的文件系统，其安装点一般都固定为<code>/proc</code>。这个文件系统中所有的文件都是特殊文件，其内容不存在于任何设备上。每当创建一个进程时，系统就以其<code>pid</code>为文件名在这个目录下建立起一个特殊文件，使得通过这个文件就可以读/写相应进程的用户空间，而当进程退出时则将此文件删除。</p>
<p><code>/proc</code>文件系统中的目录项结构<code>dentry</code>，在磁盘上没有对应结构，而以内存中的<code>proc_dir_entry</code>结构来代替，在<code>include/linux/proc_fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> low_ino;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> namelen;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">mode_t</span> mode;</span><br><span class="line">	<span class="type">nlink_t</span> nlink;</span><br><span class="line">	<span class="type">uid_t</span> uid;</span><br><span class="line">	<span class="type">gid_t</span> gid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> * <span class="title">proc_iops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> * <span class="title">proc_fops</span>;</span></span><br><span class="line">	<span class="type">get_info_t</span> *get_info;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">next</span>, *<span class="title">parent</span>, *<span class="title">subdir</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">	<span class="type">read_proc_t</span> *read_proc;</span><br><span class="line">	<span class="type">write_proc_t</span> *write_proc;</span><br><span class="line">	<span class="type">atomic_t</span> count; <span class="comment">/* use count */</span></span><br><span class="line">	<span class="type">int</span> deleted; <span class="comment">/* delete flag */</span></span><br><span class="line">	<span class="type">kdev_t</span> rdev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注册和注销<code>/proc</code>文件系统的机制已经发生了变化。在<code>Linux 2.2</code>中，<code>proc_dir_entry</code>结构是静态定义和初始化的，而在<code>Linux 2.4</code>中，这个数据结构被动态地创建。</p>
<p>当传送的数据小于一个页面大小时，<code>/proc</code>文件系统的实现可以通过<code>proc_dir_entry</code>中的<code>read_proc</code>和<code>write_proc</code>方法来实现。假定我们要注册的<code>/proc</code>文件系统名为<code>foo</code>，在<code>Linux 2.2</code>中的代码如下。</p>
<p><code>foo_proc_entry</code>结构的初始化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> <span class="title">foo_proc_entry</span> =</span> &#123;</span><br><span class="line">	namelen: <span class="number">3</span>,</span><br><span class="line">	name : <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">	mode : S_IRUGO | S_IWUSR,</span><br><span class="line">	read_proc : foo_read_proc,</span><br><span class="line">	write_proc : foo_write_proc,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>proc</code>文件系统根节点，即目录项<code>proc_root</code>的初始化为：<br>struct proc_dir_entry proc_root = {<br>    low_ino: PROC_ROOT_INO,<br>    namelen: 5,<br>    name: “/proc”,<br>    mode: S_IFDIR | S_IRUGO | S_IXUGO,<br>    nlink: 2,<br>    proc_iops: &amp;proc_root_inode_operations,<br>    proc_fops: &amp;proc_root_operations,<br>    parent: &amp;proc_root,<br>};<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注册：</span><br><span class="line">```C</span><br><span class="line">proc_register(&amp;proc_root, &amp;foo_proc_entry);</span><br></pre></td></tr></table></figure></p>
<p>注销：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc_unreigster(&amp;proc_root, foo_proc_entry.low_ino);</span><br></pre></td></tr></table></figure></p>
<p>在<code>Linux 2.4</code>中注册：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">ent</span>;</span></span><br><span class="line"><span class="keyword">if</span> ((ent = create_proc_entry(<span class="string">&quot;foo&quot;</span>, S_IRUGO | S_IWUSR, <span class="literal">NULL</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	ent-&gt;read_proc = foo_read_proc;</span><br><span class="line">	ent-&gt;write_proc = foo_write_proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注销：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_proc_entry(<span class="string">&quot;foo&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p>当传送数据大于一个页面大小时，<code>/proc</code>文件系统的实现应当通过完整的<code>file</code>结构来实现，在<code>Linux 2.2</code>中相关数据结构为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">foo_file_ops</span> =</span> &#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">foo_inode_ops</span> =</span> &#123;</span><br><span class="line">	default_file_ops : &amp;foo_file_ops;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> <span class="title">foo_proc_entry</span> =</span> &#123;</span><br><span class="line">	namelen: <span class="number">3</span>,</span><br><span class="line">	name : <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">	mode : S_IRUGO | S_IWUSR,</span><br><span class="line">	ops : &amp;foo_inode_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注册为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc_register(&amp;proc_root, &amp;foo_proc_entry);</span><br></pre></td></tr></table></figure></p>
<p>注销为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc_unreigster(&amp;proc_root, foo_proc_entry.low_ino);</span><br></pre></td></tr></table></figure></p>
<p>在<code>Linux 2.4</code>中相关数据结构为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">foo_file_ops</span> =</span> &#123; </span><br><span class="line">......</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">foo_inode_ops</span> =</span> &#123;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注册为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">ent</span>;</span></span><br><span class="line"><span class="keyword">if</span> ((ent = create_proc_entry(<span class="string">&quot;foo&quot;</span>, S_IRUGO | S_IWUSR, <span class="literal">NULL</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	ent-&gt;proc_iops = &amp;foo_inode_ops;</span><br><span class="line">	ent-&gt;proc_fops = &amp;foo_file_ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注销为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_proc_entry(<span class="string">&quot;foo&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="块设备驱动程序"><a href="#块设备驱动程序" class="headerlink" title="块设备驱动程序"></a>块设备驱动程序</h4><p>块设备驱动程序的界面有了很大的变化，新引入了<code>block_device_operations</code>结构，缓冲区高速缓存的接口也发生了变化。</p>
<p>在<code>Linux 2.2</code>中，块设备与字符设备驱动程序的注册基本相同，都是通过<code>file_operations</code>结构进行的。在<code>Linux 2.4</code>中，引入了新结构<code>block_device_operations</code>。</p>
<p>例如，块设备的名字为<code>DEVICE_NAME</code>，主设备号为<code>MAJOR_NR</code>，则在<code>Linux 2.2</code>中如下所述。</p>
<p>数据结构为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">device_fops</span> =</span> &#123;</span><br><span class="line">	open : device_open,</span><br><span class="line">	release : device_release,</span><br><span class="line">	read : block_read,</span><br><span class="line">	write : block_write,</span><br><span class="line">	ioctl : device_ioctl,</span><br><span class="line">	fsync : block_fsync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注册为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register_blkdev(MAJOR_NR, DEVICE_NAME, &amp;device_fops);</span><br></pre></td></tr></table></figure></p>
<p>在<code>Linux 2.4</code>中数据结构为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/blkpg.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> <span class="title">device_fops</span> =</span> &#123;</span><br><span class="line">	open : device_open,</span><br><span class="line">	release : device_release,</span><br><span class="line">	ioctl : device_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注册为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register_blkdev(MAJOR_NR, DEVICE_NAME, &amp;device_fops);</span><br></pre></td></tr></table></figure></p>
<p>在块设备驱动程序中，有一个“请求函数”来处理缓冲区高速缓存的请求。在<code>Linux 2.2</code>中，请求函数的注册和定义如下。函数原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">device_request</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>注册为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blk_dev[MAJOR_NR].request_fn = &amp;device_request;</span><br></pre></td></tr></table></figure></p>
<p>请求函数的定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">device_request</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		INIT_REQUEST;</span><br><span class="line">		......</span><br><span class="line">		<span class="keyword">switch</span> (CURRENT-&gt;cmd) &#123;</span><br><span class="line">			<span class="keyword">case</span> READ :</span><br><span class="line">				<span class="comment">// read</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> WRITE :</span><br><span class="line">				<span class="comment">// write</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span> :</span><br><span class="line">				end_request(<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		end_request(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Linux 2.4</code>中函数原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">device_make_request</span><span class="params">(<span class="type">request_queue_t</span> *q, <span class="type">int</span> rw, <span class="keyword">struct</span> buffer_head *sbh)</span>;</span><br></pre></td></tr></table></figure></p>
<p>注册：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blk_queue_make_request(BLK_DEFAULT_QUEUE(MAJOR_NR),&amp;device_make_request);</span><br></pre></td></tr></table></figure></p>
<p>请求函数的定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">device_make_request</span><span class="params">(<span class="type">request_queue_t</span> *q, <span class="type">int</span> rw, <span class="keyword">struct</span> buffer_head *sbh)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *bdata;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	......</span><br><span class="line">	bdata = bh_kmap(sbh);</span><br><span class="line">	<span class="keyword">switch</span> (rw) &#123;</span><br><span class="line">		<span class="keyword">case</span> READ :</span><br><span class="line">			<span class="comment">// read</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> READA : </span><br><span class="line">			<span class="comment">// read ahead</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> WRITE :</span><br><span class="line">			<span class="comment">// write</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span> :</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="number">1</span>;</span><br><span class="line">fail:</span><br><span class="line">	sbh-&gt;b_end_io(sbh, ret);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="编写内核模块"><a href="#编写内核模块" class="headerlink" title="编写内核模块"></a>编写内核模块</h2><h3 id="简单内核模块的编写"><a href="#简单内核模块的编写" class="headerlink" title="简单内核模块的编写"></a>简单内核模块的编写</h3><p>一个内核模块应当至少有两个函数，第 1 个为<code>init_moudle</code>，当模块被插入到内核时调用它；第 2 个为<code>cleanup_module</code>，当模块从内核移走时调用它。<code>init_module</code>的主要功能是在内核中注册一个处理某些事的处理程序。<code>cleanup_module</code>函数的功能是取消<code>init_module</code>所做的事情。 </p>
<p>下面看一个例子“Hello,world！”。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello.c</span></span><br><span class="line"><span class="comment"> * &quot;Hello,world&quot; */</span></span><br><span class="line"><span class="comment">/*下面是必要的头文件*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* 内核模块共享这个头文件 */</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* 这是一个模块 */</span></span></span><br><span class="line"><span class="comment">/* 处理CONFIG_MODVERSIONS */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_MODVERSIONS==1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODVERSIONS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/modversions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*初始化模块 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;Hello, world - this is a simple module\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* 如果返回一个非 0，那就意味着init_module失败，不能装载该内核模块*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 取消init_module所作的工作*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> printk(<span class="string">&quot;the module exits the kernel\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="内核模块的Makefiles文件"><a href="#内核模块的Makefiles文件" class="headerlink" title="内核模块的Makefiles文件"></a>内核模块的Makefiles文件</h3><p>内核模块不是独立的可执行文件，但在运行时其目标文件被连接到内核中，因此，编译内核模块时必须加<code>-c</code>标志，另外， 还得加确定的预定义符号。</p>
<ul>
<li><code>__KERNEL__</code> — 相当于告诉头文件，这个代码必须运行在内核模式下，而不是用户进程的一部分。</li>
<li><code>MODULE</code> — 这个标志告诉头文件，要给出适当的内核模块的定义。</li>
<li><code>LINUX</code> — ，从技术上讲，这个标志不是必要的。但是，如果你希望写一个比较正规的内核模块，在多个操作系统上能进行编译，这个标志将会使你感到方便。它可以允许你在独立于操作系统的部分进行常规的编译。</li>
</ul>
<p>还有其他的一些标志是否被包含进去，这取决于编译模块时的选项。如果你不能明确内核怎样被编译，可以在<code>in/usr/include/linux/config.h</code>中查到。</p>
<ul>
<li><code>__SMP__</code> — ，对称多处理机。如果内核被编译成支持对称多处理机，这必须被定义。如果你要用对称多处理机，还有一些其他的事情必须做，<br>在此不进行详细的讨论。 </li>
<li><code>CONFIG_MODVERSIONS</code> — ，如果<code>CONFIG_MODVERSIONS</code>被激活，当编译内核模块时，你必须定义它，并且包含进<code>usr/include/linux/modversions.h</code>中，这也可以由代码本身来做。</li>
</ul>
<p><code>Makefile</code>举例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">MODCFLAGS := -Wall -DMODULE -D__KERNEL__ -DLINUX</span><br><span class="line">hello.o: hello.c /usr/include/linux/version.h</span><br><span class="line"> $(CC) $(MODCFLAGS) -c hello.c</span><br><span class="line"> echo insmod hello.o to turn it on</span><br><span class="line"> echo rmmod hello to turn it off</span><br><span class="line"> echo</span><br></pre></td></tr></table></figure></p>
<p>现在，你以<code>root</code>的身份对这个内核模块进行编译并连接后，形成一个目标文件<code>hello.o</code>，然后用<code>insmod</code>把<code>hello</code>插入到内核，也可以用<code>rmmod</code>命令把<code>hello</code>从内核移走。如果你想知道结果如何，你可以查看<code>/proc/modules</code>文件，从中会找到一个新加入的模块。</p>
<h3 id="内核模块的多个文件"><a href="#内核模块的多个文件" class="headerlink" title="内核模块的多个文件"></a>内核模块的多个文件</h3><p>有时，可以从逻辑上把内核模块分成几个源文件，在这种情况下，需要做以下事情。</p>
<p>(1)除了一个源文件外，在其他所有的源文件中都要增加一行<code>#define __NO_VERSION__</code>，这是比较重要的，因为<code>module.h</code>通常包括了对<code>kernel_version</code>的定义，<code>kernel_version</code>是一个具有内核版本信息的全局变量，并且编译模块时要用到它。如果你需要<code>version.h</code>，<br>你就必须自己包含它，但如果你定义了<code>__NO_VERSION__</code>，<code>module.h</code>就不会被包含进去。</p>
<p>(2)像通常那样编译所有的源文件。</p>
<p>(3)把所有的目标文件结合到一个单独文件中。在<code>x86</code>下，这样连接：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 -r -o &lt;name of module&gt;.o &lt;第 <span class="number">1</span> 个源文件&gt;.o &lt;第 <span class="number">2</span> 个源文件&gt;.o</span><br></pre></td></tr></table></figure></p>
<p>请看下面例子<code>start.c</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* start.c</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &quot;Hello, world&quot;</span></span><br><span class="line"><span class="comment">* 这个文件包含了启动例程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*下面是必要的头文件 */</span></span><br><span class="line"><span class="comment">/* 内核模块的标准形式*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 处理`CONFIG_MODVERSIONS */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_MODVERSIONS==1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODVERSIONS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/modversions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 初始化模块 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">	printk(<span class="string">&quot;Hello, world - this is the kernel speaking\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一个例子<code>stop.c</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* stop.c */</span></span><br><span class="line"><span class="comment">/* 这个文件仅仅包含`stop`例程。*/</span></span><br><span class="line"><span class="comment">/* 必要的头文件*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NO_VERSION__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_MODVERSIONS==1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODVERSIONS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/modversions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;Short is the life of a kernel module\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是多个文件的<code>Makefile</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">MODCFLAGS := -Wall -DMODULE -D__KERNEL__ -DLINUX</span><br><span class="line">hello.o: start.o stop.o</span><br><span class="line"> ld -m elf_i386 -r -o hello.o start.o stop.o</span><br><span class="line">start.o: start.c /usr/include/linux/version.h</span><br><span class="line"> $(CC) $(MODCFLAGS) -c start.c</span><br><span class="line">stop.o: stop.c /usr/include/linux/version.h</span><br><span class="line"> $(CC) $(MODCFLAGS) -c stop.c</span><br></pre></td></tr></table></figure></p>
<p><code>hello</code>是模块名，它占用了一页(4KB)的内存，此时，没有其他内核模块依赖它。</p>
<p>要从内核移走这个模块，敲入<code>rmmod hello</code>，注意，<code>rmmod</code>命令需要的是模块名而不是文件名。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/10/07/cache%E7%BC%93%E5%AD%98%E5%99%A8%E4%BB%8B%E7%BB%8D/" rel="next" title="Cache 缓存器介绍">
                <i class="fa fa-chevron-left"></i> Cache 缓存器介绍
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B05/" rel="prev" title="深入分析Linux内核源码笔记5">
                深入分析Linux内核源码笔记5 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">130</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Ext2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">Ext2 文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ext2-%E7%9A%84%E7%A3%81%E7%9B%98%E5%B8%83%E5%B1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">Ext2 的磁盘布局和数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ext2-%E7%9A%84%E7%A3%81%E7%9B%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.2.1.</span> <span class="nav-text">Ext2 的磁盘布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ext2-%E7%9A%84%E8%B6%85%E7%BA%A7%E5%9D%97"><span class="nav-number">1.2.2.</span> <span class="nav-text">Ext2 的超级块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ext2-%E7%9A%84%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="nav-number">1.2.3.</span> <span class="nav-text">Ext2 的索引节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.2.4.</span> <span class="nav-text">组描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%9B%BE"><span class="nav-number">1.2.5.</span> <span class="nav-text">位图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E8%A1%A8%E5%8F%8A%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">1.2.6.</span> <span class="nav-text">索引节点表及实例分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ext2-%E7%9A%84%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%8F%8A%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="nav-number">1.2.7.</span> <span class="nav-text">Ext2 的目录项及文件的定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Ext2-%E7%9B%AE%E5%BD%95%E9%A1%B9%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">Ext2 目录项结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">各种文件类型如何使用数据块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">文件的定位</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.</span> <span class="nav-text">链接文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.</span> <span class="nav-text">分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%9D%97%E5%AF%BB%E5%9D%80"><span class="nav-number">1.4.1.</span> <span class="nav-text">数据块寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%B4%9E"><span class="nav-number">1.4.2.</span> <span class="nav-text">文件的洞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="nav-number">1.4.3.</span> <span class="nav-text">分配一个数据块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">模块机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97"><span class="nav-number">2.1.1.</span> <span class="nav-text">什么是模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.1.2.</span> <span class="nav-text">Linux内核模块的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">2.2.</span> <span class="nav-text">实现机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%AC%A6%E5%8F%B7"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">模块符号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%BC%95%E7%94%A8-Module-Reference"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">模块引用(Module Reference)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E7%9A%84%E5%88%86%E6%9E%90"><span class="nav-number">2.2.2.</span> <span class="nav-text">实现机制的分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%97%B6%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0init-modules"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">启动时内核模块的初始化函数init_modules()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E6%A8%A1%E5%9D%97"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">创建一个新模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">初始化一个模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0sys-delete-module"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">卸载模块的函数sys_delete_module()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E5%85%A5%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97request-module-%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">装入内核模块request_module()函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E5%8D%B8%E8%BD%BD"><span class="nav-number">2.3.</span> <span class="nav-text">模块的装入和卸载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">实现机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC"><span class="nav-number">2.4.</span> <span class="nav-text">内核版本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC%E4%B8%8E%E6%A8%A1%E5%9D%97%E7%89%88%E6%9C%AC%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-number">2.4.1.</span> <span class="nav-text">内核版本与模块版本的兼容性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E7%89%88%E6%9C%AC-2-0-%E5%88%B0-2-2-%E5%86%85%E6%A0%B8API%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">2.4.2.</span> <span class="nav-text">从版本 2.0 到 2.2 内核API的变化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">用户空间与内核空间之间数据的拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">文件操作的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">信号的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%A4%9A%E8%B7%AF%E6%8A%80%E6%9C%AF"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">IO事件的多路技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A2%E5%BC%83%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E6%8D%AE"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">丢弃初始化函数和数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E7%9A%84%E8%AE%BE%E5%AE%9A"><span class="nav-number">2.4.2.6.</span> <span class="nav-text">定时的设定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%AE%8F"><span class="nav-number">2.4.2.7.</span> <span class="nav-text">向后兼容的宏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E5%86%85%E6%A0%B8-2-2-%E7%A7%BB%E6%A4%8D%E5%88%B0%E5%86%85%E6%A0%B8-2-4"><span class="nav-number">2.4.3.</span> <span class="nav-text">把内核 2.2 移植到内核 2.4</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-DevFS"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">使用设备文件系统(DevFS)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">使用&#x2F;proc文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">块设备驱动程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="nav-number">2.5.</span> <span class="nav-text">编写内核模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BC%96%E5%86%99"><span class="nav-number">2.5.1.</span> <span class="nav-text">简单内核模块的编写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9A%84Makefiles%E6%96%87%E4%BB%B6"><span class="nav-number">2.5.2.</span> <span class="nav-text">内核模块的Makefiles文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">2.5.3.</span> <span class="nav-text">内核模块的多个文件</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
