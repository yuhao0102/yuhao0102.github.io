<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="内存管理RAM中的某些部分永久的分配给内核，并用来存放内核代码以及静态的内核数据结构。其余的部分我们称为动态内存，这不仅是进程所需要的宝贵资源，也是内核本身所需要的宝贵资源。 页框管理Linux采用4KB页框大小作为标准的内存分配单元。基于以下两个原因，这会使事情变得简单：  由分页单元引发的缺页异常很容易得到解释，或者是由于请求的页存在但不允许进程对其访问，或者是由于请求的页不存在。在第二种情况">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Linux内核8-9章">
<meta property="og:url" content="http://yoursite.com/2020/10/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B03/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="内存管理RAM中的某些部分永久的分配给内核，并用来存放内核代码以及静态的内核数据结构。其余的部分我们称为动态内存，这不仅是进程所需要的宝贵资源，也是内核本身所需要的宝贵资源。 页框管理Linux采用4KB页框大小作为标准的内存分配单元。基于以下两个原因，这会使事情变得简单：  由分页单元引发的缺页异常很容易得到解释，或者是由于请求的页存在但不允许进程对其访问，或者是由于请求的页不存在。在第二种情况">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1601873129.jpg">
<meta property="og:image" content="http://yoursite.com/img/1601873364.jpg">
<meta property="og:image" content="http://yoursite.com/img/1601873368.jpg">
<meta property="og:image" content="http://yoursite.com/img/1601873600.jpg">
<meta property="og:image" content="http://yoursite.com/img/1601873602.jpg">
<meta property="og:image" content="http://yoursite.com/img/1601906932.jpg">
<meta property="og:image" content="http://yoursite.com/img/1601907216.jpg">
<meta property="og:image" content="http://yoursite.com/img/1601915053.jpg">
<meta property="og:image" content="http://yoursite.com/img/1601915112.jpg">
<meta property="og:image" content="http://yoursite.com/img/1601915113.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602070897.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602070899.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602070900.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602070968.png">
<meta property="og:image" content="http://yoursite.com/img/1602071361.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602150476.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602156662.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602156913.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602070969.png">
<meta property="og:image" content="http://yoursite.com/img/1602070970.png">
<meta property="og:image" content="http://yoursite.com/img/1602070971.png">
<meta property="og:image" content="http://yoursite.com/img/1602070972.png">
<meta property="og:image" content="http://yoursite.com/img/1602070973.png">
<meta property="og:image" content="http://yoursite.com/img/1602070974.png">
<meta property="og:image" content="http://yoursite.com/img/1602317308.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602317388.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602317489.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602427094.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602070975.png">
<meta property="og:image" content="http://yoursite.com/img/1602591966.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602592050.jpg">
<meta property="article:published_time" content="2020-10-02T08:00:00.000Z">
<meta property="article:modified_time" content="2020-10-15T10:10:58.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1601873129.jpg">

<link rel="canonical" href="http://yoursite.com/2020/10/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B03/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>深入理解Linux内核8-9章 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">128</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yuhao0102" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解Linux内核8-9章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-02 16:00:00" itemprop="dateCreated datePublished" datetime="2020-10-02T16:00:00+08:00">2020-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-15 18:10:58" itemprop="dateModified" datetime="2020-10-15T18:10:58+08:00">2020-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>RAM中的某些部分永久的分配给内核，并用来存放内核代码以及静态的内核数据结构。其余的部分我们称为<strong>动态内存</strong>，这不仅是进程所需要的宝贵资源，也是内核本身所需要的宝贵资源。<br><img src="/img/1601873129.jpg" alt=""></p>
<h2 id="页框管理"><a href="#页框管理" class="headerlink" title="页框管理"></a>页框管理</h2><p>Linux采用<strong>4KB页框大小</strong>作为标准的内存分配单元。基于以下两个原因，这会使事情变得简单：</p>
<ul>
<li>由分页单元引发的缺页异常很容易得到解释，或者是由于请求的页存在但不允许进程对其访问，或者是由于请求的页不存在。在第二种情况下，内存分配器必须找到一个4KB的空闲页框，并将其分配给进程。</li>
<li>虽然4KB和4MB都是磁盘块大小的倍数，但是在绝大多数情况下，当主存和磁盘之间传输小块数据时更高效。</li>
</ul>
<h3 id="页描述符"><a href="#页描述符" class="headerlink" title="页描述符"></a>页描述符</h3><p>内核必须记录每个页框当前的状态。在以下情况下页框是不空闲的：</p>
<ul>
<li>包含用户态进程的数据；</li>
<li>某个软件高速缓存的数据；</li>
<li>动态分配的内核数据结构；</li>
<li>设备驱动程序缓冲的数据；</li>
<li>内核模块的代码等等。</li>
</ul>
<p>页框的状态信息保存在一个类型为<code>page</code>的页描述符中，其中的字段如表8.1所示。所有的页描述符存放在<code>mem_map</code>数组中。因为每个描述符长度为32字节，所以<code>mem_map</code>所需要的空间略小于整个RAM的1%。<code>virt_to_page(addr)</code>宏产生线性地址<code>addr</code>对应的页描述符地址。<code>pfn_to_page(pfn)</code>宏产生与页框号<code>pfn</code>对应的页描述符地址。<br><img src="/img/1601873364.jpg" alt=""></p>
<p><code>_count</code>字段：为页的引用计数器。如果为-1，那么说明该页框空闲，可以被分配给任何一个进程或者内核本身；如果大于0或者等于0，则说明页框被分配给了一个或者多个进程，或者用于存放一些内核数据结构。<code>page_count()</code>函数就是返回这个<code>count</code>的值加1，也即是该页使用者的数目。</p>
<p><code>flags</code>字段包含多达32个用于描述页框状态的标志。<br><img src="/img/1601873368.jpg" alt=""></p>
<h3 id="非一致性内存访问（NUMA）"><a href="#非一致性内存访问（NUMA）" class="headerlink" title="非一致性内存访问（NUMA）"></a>非一致性内存访问（NUMA）</h3><p>内核2.6支持这种内存访问模型，这种模型中，给定CPU对不同内存单元的访问时间可能不一样。系统的物理内存被划分为几个节点（node）.在一个单独的节点内，任何一个给定CPU访问页面所需的时间都是相同的。然而，对不同的CPU，这个时间可能就不同，对于每个CPU而言，内核都试图把耗时节点的访问次数减到最小，这就要小心地选择CPU最常引用的内核数据结构的存放位置。</p>
<p>每个节点中的物理内存又可以分为几个<strong>管理区</strong>。<strong>每个节点都有一个<code>pg_data_t</code>的描述符，所有节点的描述符存放在一个单向链表中</strong>，第一个元素由<code>pgdata_list</code>变量指向。<br><img src="/img/1601873600.jpg" alt=""></p>
<p>IBM兼容PC使用一致访问内存（UMA）模型，因此并不真正需要NUMA的支持。但是即使对NUMA的支持没有被编译进内核，Linux还是使用一个节点，只是这个节点包含了系统中所有的物理内存。因此<code>pgdata_list</code>指向一个只包含一个节点的链表，这个节点也就是节点0的描述符，存放于<code>contig_page_data</code>变量中。这样做的好处是有助于内存代码的处理更具可移植性。</p>
<h3 id="内存管理区"><a href="#内存管理区" class="headerlink" title="内存管理区"></a>内存管理区</h3><p>由于计算机体系结构有硬件的制约，所以内核必须处理80x86体系结构的两种硬件约束：</p>
<ul>
<li>ISA总线的直接内存存取（DMA）处理器有一个严格的限制：只能对主存的前16M寻址。</li>
<li>在具有大容量的内存的现代32位计算机中，CPU不能直接访问所有的物理内存，因为线性地址空间太小，只有4G。超过4G的部分就不能直接进行寻址了。</li>
</ul>
<p>为了应对上述的两种限制，内核2.6把每个内存节点的物理内存划分为3个<strong>管理区</strong>（zone），在x86 UMA体系结构下的管理区为：</p>
<ul>
<li><code>ZONE_DMA</code>包含低于16M的内存页框</li>
<li><code>ZONE_NORMAL</code>包含高于16M低于896M的内存页框</li>
<li><code>ZONE_HIGHMEN</code>包含从896M开始到高于896M的内存页框</li>
</ul>
<p>前两个包含内存的<strong>常规页框</strong>，通过把它们映射到虚拟地址空间中的第4个G，内核就可以直接进行访问。第三个区包含的内存页不能由内核直接访问。</p>
<p>同样，每个管理区也都有自己的描述符。<br><img src="/img/1601873602.jpg" alt=""></p>
<p>每个页描述符都有到内存节点node以及到节点内管理区(即这个页所在的管理区)的指针。为了节省空间，这下指针和典型的指针不一样，而是被编码成索引放到了flags字段的高位。</p>
<p><code>page_zone()</code>函数接收一个页描述符的物理地址作为参数，读取页描述符中flags字段的最高位，然后通过查看<code>zone_table</code>数组来确定相应管理区描述符的地址。在启动时用所内存节点的所有管理区描述符的地址初始化这个数组。</p>
<p>当内核调用一个内存分配函数的时候，必须指明请求的页框所在的管理区。为了在内存分配中请求中指定首选管理区，内核使用<code>zonelist</code>数据结构，也就是管理区描述符指针数组。</p>
<h3 id="保留的页框池"><a href="#保留的页框池" class="headerlink" title="保留的页框池"></a>保留的页框池</h3><p>用两种不同的方法来满足内存分配请求，如果有足够的空闲内存则满足请求；否则必须回收一些内存，并且将发出请求的内核控制路径阻塞，直到有内存被释放。</p>
<p>保留内存的数量（以KB为单位）存放在<code>min_free_kbytes</code>变量中，初始值在内核初始化时设置，并取决于直接映射到内核线性地址空间第4个GB的物理内存的数量，即取决于包含在<code>ZONE_DMA</code>和<code>ZONE_NORMAL</code>内存管理区内的页框数目。保留的原因是因为<strong>在原子请求从不被阻塞，如果没有足够的空闲页，那么就是分配失败，为了尽量减少这种情况发生，当内存不足的时候，就会使用保留的页框池</strong>。<br><img src="/img/1601906932.jpg" alt=""></p>
<p><code>ZONE_DMA</code>和<code>ZONE_NORMAL</code>内存管理区将一定量的页框贡献给保留内存，这个数目与两个管理区的相对大小成比例。管理区描述符中的<code>pages_min</code>字段存储了管理区内保留的页框的数据。这个字段和<code>pages_low</code>、<code>pages_high</code>字段一起还在页框回收算法中起作用。<code>page_low</code>字段总是被设为<code>pages_min</code>的值的5/4，而<code>pages_high</code>总是被设置为<code>pages_min</code>的值的3/2。</p>
<h3 id="分区页框分配器"><a href="#分区页框分配器" class="headerlink" title="分区页框分配器"></a>分区页框分配器</h3><p>叫做<strong>分区页框分配器</strong>（zoned page frame allocator）的内核子系统，处理对连续页框组的内存分配请求。<br><img src="/img/1601907216.jpg" alt=""></p>
<p><strong>管理区分配器</strong>部分接受动态分配和释放的请求，<strong>在请求分配的情况下，搜索一个能满足请求的一组连续页框内存的管理区</strong>。在每个管理区内，页框被<strong>伙伴系统</strong>来处理，为了达到更好的系统性能，<strong>一小部分页框保留在高速缓存中用于快速地满足对单个页框的分配请求</strong>。</p>
<h4 id="请求和释放页框"><a href="#请求和释放页框" class="headerlink" title="请求和释放页框"></a>请求和释放页框</h4><p>6个函数被用来请求页框，一般都返回第一个所分配页框描述符的地址，分配失败则返回NULL。</p>
<ul>
<li><code>alloc_pages(gfp_mask, order)</code>：请求2的order次方个连续的页框，</li>
<li><code>alloc_page(gfp_mask)</code>：用于获得单独页框的宏</li>
<li><code>__get_free_pages(gfp_mask,order)</code>：返回第一个所分配页的线性地址</li>
<li><code>__get_free_page(gfp_mask)</code>：用于获得单独页框的宏</li>
<li><code>__get_zeroed_page(gfp_mask)</code>：获取归零的页框，它调用<code>alloc_pages(gfp_mask | __GFP_ZERO, 0)</code></li>
<li><code>__get_dma_pages(gfp_mask,order)</code>：获取适用于DMA的页框，它扩展为<code>__get_free_pages(gfp_mask | __GFP_DMA, order)</code></li>
</ul>
<p><code>gfp_mask</code>是一组标志，它指明了如何寻找空闲的页框，能在<code>gfp_mask</code>中使用的标志如图<br><img src="/img/1601915053.jpg" alt=""></p>
<p>实际上Linux使用预定义标志值的集合，如下表。<br><img src="/img/1601915112.jpg" alt=""></p>
<p><code>__GFP_DMA</code>和<code>__GFP_HIGHMEM</code>被称作<strong>管理区修饰符</strong>，他们标示寻找空闲页框时内核所搜索的管理区。<code>contig_page_data</code>节点描述符的<code>node_zonelists</code>字段是一个管理区描述符链表的数组，它代表后备管理区，对管理区修饰符的每一个设置，相应的链表包含的内存管理区能在原来的管理区缺少页框的情况下，被用于满足内存分配需求，在80x86下，后备管理区如下：</p>
<ul>
<li>如果<code>__GFP_DMA</code>标志被置位，则只能从内存管理区获取页框。</li>
<li>否则，如果<code>__GFP_HIGHMEM</code>标志没有被置位，则只能接优先次序从<code>ZONE_NORMAL</code>和<code>ZONE_DMA</code>内存管理区获取页框。</li>
<li>否则(<code>__GFP_HIGHMEM</code>标志被置位），则可以按优先次序从<code>ZONE_HIGHMEM</code>、<code>ZONE_NORMAL</code>和<code>ZONE_DMA</code>内存管理区获得页框。</li>
</ul>
<p>下面4个函数和宏中的任一个都可以释放页框：</p>
<ul>
<li><code>__free_pages(page,order)</code>：该函数先检查page指向的页描述符；如果该页框未被保留（<code>PG_reserved</code>标志为0），就把描述符的字段减1。如果count值变为0，就假定从与page对应的页框开始的2的order次方个连续页框不再被使用。在这种情况下，该函数释放页框</li>
<li><code>free_pages(addr, order)</code>：这个函数类似于<code>__free_pges(page,order)</code>，但是它接收的参数为要释放的第一个页框的线性地址addr。</li>
<li><code>__free_page(page)</code>：这个宏释放page所指描述符对应的页框；它扩展为：<code>__free_pages(page, 0)</code></li>
<li><code>free_page(addr)</code>：该宏释放线性地址为addr的页框，它扩展为<code>free_pages(addr, 0)</code></li>
</ul>
<h3 id="高端内存页框的内核映射"><a href="#高端内存页框的内核映射" class="headerlink" title="高端内存页框的内核映射"></a>高端内存页框的内核映射</h3><p>与直接映射的物理内存末端、高端内存的始端所对应的线性地址存放在<code>high_memory</code>变量中，它被设置为896MB。896MB边界以上的页框并不映射在内核线性地址空间的第四个GB，因此内核不能直接访问。这意味着返回所分配页框线性地址的页分配器函数并不适用于高端内存。</p>
<p>Linux设计者不得不找到某种方法来允许内核使用所有可使用的RAM，达到PAE所支持的64GB0采用的方法如下：</p>
<ul>
<li>高端内存页框的分配只能通过<code>alloc_pages()</code>函数和它的快捷函数<code>alloc_page()</code>。这些函数不返回第一个被分配页框的线性地址，因为如果该页框属于高端内存，那么这样的线性地址根本不存在。取而代之，<strong>这些函数返回第一个被分配页框的页描述符的线性地址</strong>。这些线性地址总是存在的，因为所有页描述符一旦被分配在低端内存中，它们在内核初始化阶段就不会改变。</li>
<li>没有线性地址的高端内存中的页框不能被内核访问。因此，<strong>内核线性地址空间的最后128MB中的一部分专门用于映射高端内存页框</strong>。当然，这种映射是暂时的，否则只有128MB的高端内存可以被访问。取而代之，通过重复使用线性地址，使得整个高端内存能够在不同的时间被访问。</li>
</ul>
<p>内核可以采用三种不同的机制将页框映射到高端内存；分别叫做<strong>永久内核映射</strong>、<strong>临时内核映射</strong>及<strong>非连续内存分配</strong>。</p>
<p>建立永久内核映射可能阻塞当前进程；这发生在空闲页表项不存在时，也就是在高端内存上没有页表项可以用作页框的“窗口”时。因此，永久内核映射不能用于中断处理程序和可延迟函数。相反建立临时内核映射绝不会要求阻塞当前进程。</p>
<h4 id="永久内核映射"><a href="#永久内核映射" class="headerlink" title="永久内核映射"></a>永久内核映射</h4><p><strong>永久内核映射允许内核建立高端页框到内核地址空间的长期映射</strong>。他们使用主内核页表中一个专门的页表，其地址存放在变量<code>pkmap_page_table</code>中，这在前面的页表机制管理区初始化中已经介绍过了。页表中的表项数由<code>LAST_PKMAP</code>宏产生，内核一次最多访问2MB或4MB的高端内存。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里由定义可以看出永久内存映射为固定映射下面的4M空间*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PKMAP_BASE ((FIXADDR_BOOT_START - PAGE_SIZE * (LAST_PKMAP + 1))	\</span></span><br><span class="line"><span class="meta">		    &amp; PMD_MASK)</span></span><br></pre></td></tr></table></figure><br>该页表映射的线性地址从<code>PKMAP_BASE</code>开始。<code>pkmap_count</code>数组包含<code>LAST_PKMAP</code>个计数器，<code>pkmap_page_table</code>页表中的每一项都有一个。</p>
<ul>
<li>计数器为0：对应页表项没有映射任何高端内存页框，并且是可用的。</li>
<li>计数器为1：对应页表项没有映射任何高端内存页框，但是不能使用，因为其相应的TLB还未刷新。</li>
<li>计数器为n，远大于1：对应页表项映射一个高端内存页框，正好有n-1个内核成分在使用这个页框。</li>
</ul>
<p>为了<strong>记录高端内存页框与永久内核映射包含的线性地址之间的联系</strong>，内核使用了<code>page_address_htable</code>散列表。该表包含一个<code>page_address_map</code>结构，用于<strong>为高端内存中的每一个页框进行当前映射</strong>。而该数据结构还包含一个指向页描述符的指针和分配给该页框的线性地址。</p>
<p><code>page_address()</code>函数返回<strong>页框对应的线性地址</strong>，如果页框在高端内存中并且没有被映射，则返回NULL。这个函数接受一个页描述符指针page作为其参数，并区分以下两种情况：</p>
<ol>
<li><p>如果页框不在高端内存中（<code>PG_highmen</code>标志为0），则线性地址总是存在并且是通过计算页框下标，然后将其转换成物理地址，最后根据相应的物理地址得到线性地址。这是由下面的代码完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__va((<span class="type">unsigned</span> <span class="type">long</span>)(page - mem_map) &lt;&lt; <span class="number">12</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果页框在高端内存（<code>PG_highmen</code>标志为1）中，该函数就到<code>page_address_htable</code>散列表中查找。如果在散列表中找到页框，<code>page_address()</code>就返回它的线性地址，否则返回NULL。</p>
</li>
</ol>
<p>kmap()函数建立永久内核映射。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 高端内存映射，运用数组进行操作分配情况 */</span></span><br><span class="line"><span class="comment">/* 分配好后需要加入哈希表中；*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmap</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!PageHighMem(page)) <span class="comment">/*如果页框不属于高端内存*/</span></span><br><span class="line">		<span class="keyword">return</span> page_address(page);</span><br><span class="line">	<span class="keyword">return</span> kmap_high(page);<span class="comment">/*页框确实属于高端内存*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>页框确实属于高端内存，则调用<code>kmap_high()</code>函数，该函数获取<code>kmap_lock</code>自旋锁，以保护页表免受多处理器系统上的并发访问，检查页框是否已经被映射，如果不是则调用<code>map_new_virtual()</code>把页框的物理地址插入到<code>pkmap_page_table</code>的一个项中并在<code>page_address_htable</code>散列表中加入一个元素。使页框的分配计数加1来将调用该函数的新内核成分考虑在内，此时流程都正确应该是2了。最后释放自旋锁并返回线性地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmap_high - map a highmem page into memory</span></span><br><span class="line"><span class="comment"> * @page: &amp;struct page to map</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the page&#x27;s virtual memory address.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We cannot call this from interrupts, as it may block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmap_high</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vaddr;</span><br><span class="line">	lock_kmap();</span><br><span class="line"></span><br><span class="line">	vaddr = (<span class="type">unsigned</span> <span class="type">long</span>)page_address(page);</span><br><span class="line">	<span class="keyword">if</span> (!vaddr)</span><br><span class="line">		vaddr = map_new_virtual(page);</span><br><span class="line">	pkmap_count[PKMAP_NR(vaddr)]++;</span><br><span class="line">	BUG_ON(pkmap_count[PKMAP_NR(vaddr)] &lt; <span class="number">2</span>);</span><br><span class="line">	unlock_kmap();</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*) vaddr;<span class="comment">/*返回地址*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>map_new_virtual()</code>实际上执行两个嵌套循环：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">map_new_virtual</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	count = LAST_PKMAP;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="type">int</span> count;</span><br><span class="line">		DECLARE_WAITQUEUE(wait, current);</span><br><span class="line">		<span class="keyword">for</span>(count = LAST_PKMAP; count &gt; <span class="number">0</span>; count --) &#123;</span><br><span class="line">			last_pkmap_nr = (last_pkmap_nr + <span class="number">1</span>) &amp; LAST_PKMAP_MASK;</span><br><span class="line">			<span class="keyword">if</span> (!last_pkmap_nr) &#123;</span><br><span class="line">				flush_all_zero_pkmaps();</span><br><span class="line">				count = LAST_PKMAP;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!pkmap_count[last_pkmap_nr]) &#123;</span><br><span class="line">				<span class="type">unsigned</span> <span class="type">long</span> vaddr = PKMAP_BASE + (last_pkmap_nr &lt;&lt; PAGE_SHIFT);</span><br><span class="line">				set_pte(&amp;(pkmap_page_table[last_pkmap_nr]), mk_pte(page, __pgprot(<span class="number">0x63</span>)));</span><br><span class="line">				pkmap_count[last_pkmap_nr] = <span class="number">1</span>;</span><br><span class="line">				set_page_address(page, (<span class="type">void</span>*)vaddr);</span><br><span class="line">				<span class="keyword">return</span> vaddr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		current-&gt;state = TASK_UNITERRUPTIBLE;</span><br><span class="line">		add_wait_queue(&amp;pkmap_map_wait, &amp;wait);</span><br><span class="line">		unlock_kmap();</span><br><span class="line">		schedule();</span><br><span class="line">		remove_wait_queue(&amp;pkmap_map_wait, &amp;wait);</span><br><span class="line">		lock_kmap();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (page_address(page))</span><br><span class="line">			<span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span>)page_address(page);</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在内循环中，该函数扫描<code>pkmap_count</code>中的所有计数器直到找到一个空值。当在<code>pkmap_count</code>中找到了一个未使用的项时，大的if代码块运行。这段代码确定该项对应的线性地址，为它在<code>pkmap_page_table</code>页表中创建一个项，将count置1，因为该项现在已经被使用了，调用<code>set_page_address()</code>函数插入一个新元素到<code>page_address_htable</code>散列表中，并返回线性地址。</p>
<p>函数从上次停止的地方开始，穿越<code>pkmap_count</code>数组执行循环。这是函数通过将<code>pkmap_page_table</code>页表中上次使用过页表项的索引保存在一个名为<code>last_pkmap_nr</code>的变量中做到的。 因此，搜索从上次因调用<code>map_new_virtual()</code>函数而跳出的地方重新开始。</p>
<p>当在<code>pkmap_count</code>中搜索到最后一个计数器时，就又从下标为0的计数器重新开始搜索。不过，在继续之前，<code>map_new_virtual()</code>调用<code>flush_all_zero_pkmaps()</code>函数来开始寻找计数器 为1 的另一趟扫描。每个值为1的计数器都表示在<code>pkmap_page_table</code>页表中表项是空闲的，但不能使用，因为相应的TLB表项还没有被刷新。<code>flush_all_zero_pkmaps()</code><strong>把它们的计数器重置为0</strong>，删除<code>page_address_htable</code>散列表中对应的元素，并在<code>pkmap_page_table</code>的所有项上进行TLB刷新。</p>
<p>如果内循环在<code>pkmap_count</code>中没有找到空的计数器，<code>map_new_virtual()</code>函数就阻塞当前进程，直到某个进程释放了<code>pkmap_page_table</code>页表中的一个表项。通过把current插入到<code>pkmap_map_wait</code>等待队列，把current状态设置为<code>TASK_UNINTERRUPTIBLE</code>并调用<code>schedule()</code>放弃CPU来达到此目的。一旦进程被唤醒，该函数就通过调用<code>page_address()</code>检查是否存在另一个进程已经映射了该页；如果还没有其他进程映射该页，则内循环重新开始。</p>
<p><code>kunmap()</code>函数撤销先前由<code>kmap()</code>建立的永久内核映射。如果页确实在高端内存中，则调用<code>kunmap_high()</code>函数，它本质上等价于下列代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kunmap_high</span><span class="params">(<span class="keyword">struct</span> page * page)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;kmap_lock);</span><br><span class="line">    <span class="keyword">if</span> ((--pkmap_count[((<span class="type">unsigned</span> <span class="type">long</span>)page_address(page) - PKMAP_BASE) &gt;&gt; PAGE_SHIFT]) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;pkmap_map_wait))</span><br><span class="line">            wake_up(&amp;pkmap_map_wait);</span><br><span class="line">    spin_unlock(&amp;kmap_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>中括号内的表达式从页的线性地址计算出<code>pkmap_count</code>数组的索引。计数器被减1并与1相比。匹配成功表明没有进程在使用页。该函数最终能唤醒由<code>map_new_virtual()</code>添加在等待队列中的进程（如果有的话）。</p>
<p>总结一下，如果是通过<code>alloc_page()</code>获得了高端内存对应的page，内核专门为此留出一块线性空间，从<code>PKMAP_BASE</code>到<code>FIXADDR_START</code>，用于映射高端内存。在2.6内核上，如果不指定PAE，这个地址范围是4G-8M到4G-4M之间。这个空间叫<strong>内核永久映射空间</strong>或者<strong>永久内核映射空间</strong>。</p>
<p>这个空间和其它空间使用同样的页全局目录表，对于内核来说，就是<code>swapper_pg_dir</code>，对普通进程来说，通过 CR3寄存器指向。通常情况下，这个空间是 4M 大小，因此仅仅需要一个页表即可，内核通过来<code>pkmap_page_table</code>寻找这个页表。</p>
<p>通过<code>kmap()</code>， 可以把一个page映射到这个空间来。通过<code>kunmap()</code>，可以把一个page对应的线性地址从这个空间释放出来。</p>
<h4 id="临时内核映射"><a href="#临时内核映射" class="headerlink" title="临时内核映射"></a>临时内核映射</h4><p>临时内核映射比永久内核映射的实现要简单。在高端内存的任一页框都可以通过一个<strong>窗口</strong>（为此而保留的一个页表项）映射到内核地址空间。留给临时内核映射的窗口数是非常少的。</p>
<p>每个CPU都有它自己的包含13个窗口的集合，它们用<code>enum km_type</code>数据结构表示。该数据结构中定义的每个符号，如<code>KM_BOUNCE_READ</code>、<code>KM_USER0</code>或<code>KM_PTE0</code>，标识了窗口的线性地址。</p>
<p>内核必须确保同一窗口永不会被两个不同的控制路径同时使用。因此，<code>km_type</code>结构中的每个符号只能由一种内核成分使用，并以该成分命名。最后一个符号<code>KM_TYPE_NR</code>本身并不表示一个线性地址，但由每个CPU 用来产生不同的可用窗口数。</p>
<p>在<code>km_type</code>中的每个符号（除了最后一个）都是固定映射的线性地址的一个下标。<code>enum_fixed_addresses</code>数据结构包含符号<code>FIX_KMAP_BEGIN</code>和<code>FIX_KMAP_END</code>；把后者赋给下标<code>FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1</code>。在这种方式下，系统中的每个CPU都有<code>KM_TYPE_NR</code>个固定映射的线性地址。此外，内核用<code>fix_to_virt(FIX_KMAP_BEGIN)</code>线性地址对应的页表项的地址初始化<code>kmap_pte</code>变量。</p>
<p>为了建立临时内核映射，内核调用<code>kmap_atomic()</code>函数，它本质上等价于下列代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">kmap_atomic</span><span class="params">(<span class="keyword">struct</span> page * page, <span class="keyword">enum</span> km_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">fixed_addresses</span> <span class="title">idx</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vaddr;</span><br><span class="line"></span><br><span class="line">    current_thread_info( )-&gt;preempt_count++;</span><br><span class="line">    <span class="keyword">if</span> (!PageHighMem(page))</span><br><span class="line">        <span class="keyword">return</span> page_address(page);</span><br><span class="line">    idx = type + KM_TYPE_NR * smp_processor_id( );</span><br><span class="line">    vaddr = fix_to_virt(FIX_KMAP_BEGIN + idx);</span><br><span class="line">    set_pte(kmap_pte-idx, mk_pte(page, <span class="number">0x063</span>));</span><br><span class="line">    __flush_tlb_single(vaddr);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) vaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>type参数和CPU标识符（通过smp_processor_id()）指定必须用哪个固定映射的线性地址映射请求页。如果页框不属于高端内存，则该函数返回页框的线性地址；否则，用页的物理地址及Present、Accessed、Read/Write 和Dirty 位建立该固定映射的线性地址对应的页表项。最后，该函数刷新适当的TLB 项并返回线性地址。</p>
<p>为了撤销临时内核映射，内核使用<code>kunmap_atomic()</code>函数。在80x86结构中，这个函数减少当前进程的<code>preempt_count</code>；因此，如果在请求临时内核映像之前能抢占内核控制路径，那么在同一个映射被撤销后可以再次抢占。此外，<code>kunmap_atomic()</code>检查当前进程的<code>TIF_NEED_RESCHED</code>标志是否被置位，如果是，就调用<code>schedule()</code>。</p>
<p>总结一下临时内核映射。前边提到从线性地址4G向前倒数若干的页面有一个空间称为<strong>固定映射空间</strong>，在这个空间中，有一部分用于高端内存的临时映射。这块空间具有如下特点：</p>
<ol>
<li>每个 CPU 占用一块空间</li>
<li>在每个 CPU 占用的那块空间中，又分为多个小空间，每个小空间大小是 1 个 page，每个小空间用于一个目的，这些目的定义在kmap_types.h 中的 km_type 中。</li>
</ol>
<p>当要进行一次临时映射的时候，需要指定映射的目的，根据映射目的，可以找到对应的小空间，然后把这个空间的地址作为映射地址。这意味着一次临时映射会导致以前的映射被覆盖。通过 kmap_atomic() 可实现临时映射。</p>
<h2 id="伙伴系统算法"><a href="#伙伴系统算法" class="headerlink" title="伙伴系统算法"></a>伙伴系统算法</h2><p>频繁的请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框。从本质上来说，避免<strong>外碎片</strong>的方法有两种：</p>
<ul>
<li><strong>利用分页单元把一组非连续的空闲页框映射到连续的线性地址区间</strong>。</li>
<li>开发一种适当的技术来<strong>记录现存的空闲连续页框块的情况</strong>，以尽量避免为满足对小块的请求而分割大的空闲块。</li>
</ul>
<p>内核首选第二种方法，由于以下的原因：</p>
<ul>
<li>在某些情况下，<strong>连续的页框确实是必要的</strong>，因为连续的线性地址不足以满足请求。比如DMA分配缓冲区的时候，会忽略分页单元而直接访问地址总线，因此，所请求的缓冲区就必须位于连续的页框中。</li>
<li>频繁的修改页表势必导致平均访问内存次数的增加，因为会频繁的刷新TLB。</li>
<li>内核通过4MB的页可以访问大块连续的物理内存，减少了转换后缓冲器失效率，提高访问内存的平均速度。</li>
</ul>
<p><strong>伙伴系统算法</strong>就是用来解决外碎片问题。</p>
<p><strong>把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512，1024个连续的页框。对1024个页框的最大请求对应着4M大小的连续内存块。每个块的第一个页框的物理地址是该块大小的整数倍。</strong></p>
<p>假设要请求一个256个页框的块（即1MB）：</p>
<ul>
<li>算法先在256个页框的链表中检查是否有一个空闲块。</li>
<li>如果没有这样的块，算法会查找下一个更大的页块，也就是，在512个页框的链表中找一个空闲块。</li>
<li>如果存在这样的块，内核就把512的页框分成两等份，一半用作满足请求，另一半插入到256个页框的链表中。</li>
<li>如果在512个页框的块链表中也没找到空闲块，就继续找更大的块 —— 1024个页框的块。</li>
<li>如果这样的块存在，内核把1024个页框块的256个页框用作请求，然后从剩余的768个页框中拿512个插入到512个页框的链表中，再把最后的256个插入到256个页框的链表中。</li>
<li>如果1024个页框的链表还是空的，算法就放弃并发出错信号。</li>
</ul>
<p>内核试图把大小为b的一对空闲伙伴块合并为一个大小为2b的单独块，满足一下条件的两个块为伙伴：</p>
<ul>
<li>两个块具有相同的大小，记作b；</li>
<li>物理地址连续</li>
<li>第一个块的第一个页框的物理地址是<code>2*b*2^12</code>的倍数</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>有三种伙伴系统：第一种处理适合ISA DMA的页框，第二种处理“常规”页框，第三种处理高端内存页框。每个伙伴系统使用的主要数据结构如下：</p>
<ol>
<li>前面介绍过的<code>mem_map</code>数组。实际上，每个管理区都关系到<code>mem_map</code>元素的子集。子集中的第一个元素和元素的个数分别由管理区描述符的<code>zone_mem_map</code>和<code>size</code>字段指定。</li>
<li>包含有11个元素、元素类型为<code>free_area</code>的一个数组，每个元素对应一种块大小。该数组存放在管理区描述符<code>zone_t</code>的<code>free_area</code>字段中。</li>
</ol>
<p>我们考虑管理区描述符中<code>free_area</code>数组的第k个元素，它标识所有大小为2^k的空闲块。这个元素的<code>free_list</code>字段是双向循环链表的头，这个双向循环链表集中了大小为2^k页的空闲块对应的页描述符。更精确地说，该链表包含每个空闲页框块（大小为2^k）的起始页框的页描述符；指向链表中相邻元素的指针存放在页描述符page的lru字段中。</p>
<p>除了链表头外，<code>free_area</code>数组的第k个元素同样包含字段<code>nr_free</code>，它指定了大小为2^k页的空闲块的个数。当然，如果没有大小为2^k的空闲页框块，则<code>nr_free</code>等于0且<code>free_list</code>为空（<code>free_list</code>的两个指针next和prev都指向它自己的free_list字段）。</p>
<p>最后，一个2^k的空闲页块的第一个页的描述符的<code>private</code>字段存放了块的order，也就是数字k。正是由于这个字段，当页块被释放时，内核可以确定这个块的伙伴是否也空闲。如果是的话，它可以把两个块结合成大小为2^(k+1)页的单一块。</p>
<h3 id="块分配"><a href="#块分配" class="headerlink" title="块分配"></a>块分配</h3><p>内核使用<code>__rmqueue()</code>函数来在管理区中找到一个空闲块。该函数需要两个参数：管理区描述符的地址<code>zone</code>和<code>order</code>，<code>order</code>表示请求的空闲页块大小的对数值（0 表示一个单页块，1 表示一个两页块，2表示四个页块）。如果页框被成功分配，<code>__rmqueue()</code>函数就返回第一个被分配页框的页描述符。否则，函数返回NULL。</p>
<p>在<code>__rmqueue()</code>函数中，从所请求<code>order</code>的链表开始，它扫描每个可用块链表进行循环搜索，如果需要搜索更大的<code>order</code>，就继续搜索：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> current_order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (current_order=order; current_order&lt;<span class="number">11</span>; ++current_order) &#123;</span><br><span class="line">    area = zone-&gt;free_area + current_order;</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;area-&gt;free_list))</span><br><span class="line">        <span class="keyword">goto</span> block_found;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><br>如果直到循环结束还没有找到合适的空闲块，那么<code>__rmqueue()</code>就返回NULL。否则，找到了一个合适的空闲块，在这种情况下，从链表中删除它的第一个页框描述符，并减少管理区描述符中的free_pages的值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">block_found:</span><br><span class="line">    page = list_entry(area-&gt;free_list.next, <span class="keyword">struct</span> page, lru);</span><br><span class="line">    list_del(&amp;page-&gt;lru);</span><br><span class="line">    ClearPagePrivate(page);</span><br><span class="line">    page-&gt;private = <span class="number">0</span>;</span><br><span class="line">    area-&gt;nr_free--;</span><br><span class="line">    zone-&gt;free_pages -= <span class="number">1UL</span> &lt;&lt; order;</span><br></pre></td></tr></table></figure><br>如果从<code>curr_order</code>链表中找到的块大于请求的<code>order</code>，就执行一个<code>while</code>循环。这几行代码蕴含的原理如下：当为了满足2^h个页框的请求而有必要使用2^k个页框的块时（h &lt; k），程序就分配前面的2^h 个页框，而把后面<code>2^k - 2^h</code>个页框循环再分配给<code>free_area</code>链表中下标在h到k之间的元素：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="number">1</span> &lt;&lt; curr_order;</span><br><span class="line"><span class="keyword">while</span> (curr_order &gt; order) &#123;</span><br><span class="line">    area--;</span><br><span class="line">    curr_order--;</span><br><span class="line">    size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    buddy = page + size;</span><br><span class="line">    list_add(&amp;buddy-&gt;lru, &amp;area-&gt;free_list);</span><br><span class="line">    area-&gt;nr_free++;</span><br><span class="line">    buddy-&gt;private = curr_order;</span><br><span class="line">    SetPagePrivate(buddy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> page;</span><br></pre></td></tr></table></figure><br>因为<code>__rmqueue()</code>函数已经找到了合适的空闲块，所以它返回所分配的第一个页框对应的页描述符的地址page。</p>
<h3 id="块释放"><a href="#块释放" class="headerlink" title="块释放"></a>块释放</h3><p><code>__free_pages_bulk()</code>函数按照伙伴系统的策略释放页框。它使用3个基本输入参数：</p>
<ul>
<li><code>page</code>：被释放块中所包含的第一个页框描述符的地址。</li>
<li><code>zone</code>：管理区描述符的地址。</li>
<li><code>order</code>：块大小的对数。</li>
</ul>
<p><code>__free_pages_bulk()</code>首先声明和初始化一些局部变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct page * base = zone-&gt;zone_mem_map;</span><br><span class="line">unsigned long buddy_idx, page_idx = page - base;</span><br><span class="line">struct page * buddy, * coalesced;</span><br><span class="line">int order_size = 1 &lt;&lt; order;</span><br></pre></td></tr></table></figure><br><code>page_idx</code>局部变量包含块中第一个页框的下标，这是相对于管理区中的第一个页框而言的。<code>order_size</code>局部变量用于增加管理区中空闲页框的计数器：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zone-&gt;free_pages += order_size;</span><br></pre></td></tr></table></figure><br>现在函数开始执行循环，最多循环 (10-order) 次，每次都尽量把一个块和它的伙伴进行合并。函数以最小的块开始，然后向上移动到顶部：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while (order &lt; 10) &#123;</span><br><span class="line">    buddy_idx = page_idx ^ (1 &lt;&lt; order);</span><br><span class="line">    buddy = base + buddy_idx;</span><br><span class="line">    if (!page_is_buddy(buddy, order))</span><br><span class="line">        break;</span><br><span class="line">    list_del(&amp;buddy-&gt;lru);</span><br><span class="line">    zone-&gt;free_area[order].nr_free--;</span><br><span class="line">    ClearPagePrivate(buddy);</span><br><span class="line">    buddy-&gt;private = 0;</span><br><span class="line">    page_idx &amp;= buddy_idx;   /* 合并 */</span><br><span class="line">    order++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个循环我看了半天没有看懂，后来举个例子，再画个图才渐渐明白。比如，我们这里order是4，那么order_size的值为2^4，也就是16，表明要释放16个连续的page。page_idx为这个连续16个page的老大的mem_map数组的下标。进入循环后，函数首先寻找该块的伙伴，即mem_map数组中page_idx-16或page_idx+16的下标buddy_idx，进一步说明一下，就是为了在下标为16的free_area中找到一个空闲的块，并且这个块与page所带的那个拥有16个page的块相邻。</p>
<p>尤其要注意：<code>buddy_idx = page_idx ^ (1 &lt;&lt; order)</code>这行代码。这行代码很巧妙，短小精干。因为order一来就等于4，所以循环从4开始的，即第一个循环为<code>buddy_idx = page_idx ^ (1&lt;&lt;4)</code>，即<code>buddy_idx = page_idx ^ 10000</code>。如果page_idx第5位为1，比如是20号页框（10100），那么在异或以后，buddy_idx为4号页框（00100）。如果page_idx第5位为0，比如是第40号页框（101000），那么在异或以后，buddy_idx为56号页框（111000）。</p>
<p>为什么要做这么一个运算呢？想想我们的目的是什么。<code>__free_pages_bulk</code>是将以其参数page为首的2^order个页面找到一个伙伴，并与其合并。在mem_map数组中，这个伙伴的老大要么是在这个page的前2^order，要么就是后2^order。如果单单是加或者减，那么就会忽略前面的或者后面的伙伴。</p>
<p>找到伙伴以后，把该伙伴的老大page的地址赋给buddy：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buddy = base + buddy_idx;</span><br></pre></td></tr></table></figure><br>现在函数调用<code>page_is_buddy()</code>来检查buddy是否是真正的值得信赖的伙伴，也就是大小为<code>order_size</code>的空闲页框块的第一个页。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">page_is_buddy</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PagePrivate(buddy) &amp;&amp; page-&gt;private == order &amp;&amp;</span><br><span class="line">          !PageReserved(buddy) &amp;&amp; page_count(page) ==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>正如所见，要想成为伙伴，必须满足以下四个条件：</p>
<ol>
<li>buddy的第一个页必须为空闲（_count字段等于-1）；</li>
<li>它必须属于动态内存（PG_reserved 位清零）；</li>
<li>它的private字段必须有意义（PG_private 位置位）；</li>
<li>它的private字段必须存放将要被释放的块的order。</li>
</ol>
<p>如果所有这些条件都符合，就说明有新的伙伴存在啦，那么伙伴块就要跟page结合，先必须得脱离原来的free_list，执行<code>page_idx &amp;= buddy_idx</code>合并，并再执行一次循环以寻找两倍大小的伙伴块。</p>
<p>如果<code>page_is_buddy()</code>中至少有一个条件没有被满足，则该函数跳出循环，因为获得的空闲块不能再和其他空闲块合并。函数将它插入适当的链表并以块大小的order 更新第一个页框的private 字段。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coalesced = base + page_idx;</span><br><span class="line">coalesced-&gt;private = order;</span><br><span class="line">SetPagePrivate(coalesced);</span><br><span class="line">list_add(&amp;coalesced-&gt;lru, &amp;zone-&gt;free_area[order].free_list);</span><br><span class="line">zone-&gt;free_area[order].nr_free++;</span><br></pre></td></tr></table></figure></p>
<h2 id="每CPU页框高速缓存"><a href="#每CPU页框高速缓存" class="headerlink" title="每CPU页框高速缓存"></a>每CPU页框高速缓存</h2><p>内核经常请求和释放单个页框。为了提升系统性能，如果请求单个或释放单个页框时，内核在使用伙伴算法之前多添了一个步骤，即每CPU页框高速缓存。每个内存管理区定义了一个<strong>每CPU页框高速缓存</strong>，所有<strong>每CPU高速缓存</strong>包含一些预先分配的页框，它们被用于满足本地CPU 发出的单个页内存请求。</p>
<p>更进一步，内核为每个内存管理区和每个CPU提供了两个高速缓存：一个<strong>热高速缓存</strong>，<strong>它存放的页框中所包含的内容很可能就在CPU 硬件高速缓存中</strong>；还有一个<strong>冷高速缓存</strong>。</p>
<p>如果<strong>内核或用户态进程在刚分配到页框后就立即向页框写</strong>，那么从<strong>热高速缓存</strong>中获得页框就对系统性能有利。我们知道，CPU中的硬件高速缓存存在有最近使用过的页框。而我们每次对页框存储单元的访问将都会导致原来一个存在于硬件高速缓存的一页被替换掉。当然，除非硬件高速缓存包含有一行：它映射刚被访问的 “热”页框单元，那么我们称为“命中”。</p>
<p>反过来，如果页框将要被DMA操作填充，那么从冷高速缓存中获得页框是方便的。在这种情况下，不会涉及到CPU，并且硬件高速缓存的行不会被修改。从冷高速缓存获得页框为其他类型的内存分配保存了热页框储备。</p>
<p>如果实在理解不了上面对热缓存和冷缓存的定义，那我们就干脆这样理解：热缓存跟CPU有关，要使用到对应CPU的高速缓存，当我们读写一个页面时，如果没有命中硬件高速缓存就替换一个页；冷缓存跟CPU无关，当我们读写一个页面时根本不去管有没有命中CPU的硬件缓存。</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>实现每CPU页框高速缓存的主要数据结构是存放在内存管理区描述符<code>zone_t</code>的<code>pageset</code>字段中的一个<code>per_cpu_pageset</code>数组数据结构。该数组包含为每个CPU 提供的一个元素；这个元素依次由两个<code>per_cpu_pages</code>描述符组成，一个留给热高速缓存而另一个留给冷高速缓存。<br><img src="/img/1601915113.jpg" alt=""></p>
<p>内核使用两个位标来<strong>监视热高速缓存或冷高速缓存的大小</strong>：<strong>如果页框个数低于下界low，内核通过从伙伴系统中分配batch个单一页框来补充对应的高速缓存；否则，如果页框个数高过上界high，内核从高速缓存中释放batch个页框到伙伴系统中</strong>。值batch、low和high本质上取决于内存管理区中包含的页框个数。</p>
<h3 id="通过每CPU-页框高速缓存分配页框"><a href="#通过每CPU-页框高速缓存分配页框" class="headerlink" title="通过每CPU 页框高速缓存分配页框"></a>通过每CPU 页框高速缓存分配页框</h3><p><code>buffered_rmqueue()</code>函数<strong>在指定的内存管理区中分配页框</strong>。它使用每CPU页框高速缓存来处理单一页框请求。</p>
<p>参数为内存管理区描述符的地址，请求分配的内存大小的对数<code>order</code>，以及分配标志<code>gfp_flags</code>。如果<code>gfp_flags</code>中的<code>__GFP_COLD</code>标志被置位，那么页框应当从冷高速缓存中获取，否则它应从热高速缓存中获取（此标志只对单一页框请求有意义）。该函数本质上执行如下操作：</p>
<ol>
<li>如果order不等于0，每CPU页框高速缓存就不能被使用：函数跳到第4步。</li>
<li>检查由<code>__GFP_COLD</code>标志所标识的内存管理区本地每CPU高速缓存是否需要补充（<code>per_cpu_pages</code>描述符的<code>count</code>字段小于或等于low字段）。在这种情况下，它执行如下子步骤：<ol>
<li>通过反复调用<code>__rmqueue()</code>函数从伙伴系统中分配batch 个单一页框。</li>
<li>将已分配页框的描述符插入高速缓存链表中。</li>
<li>通过给count 增加实际被分配页框的个数来更新它。</li>
</ol>
</li>
<li>如果count值为正，则函数从高速缓存链表获得一个页框，count减1并跳到第5步。（注意，每CPU 页框高速缓存有可能为空，当在第2a 步调用<code>__rmqueue()</code>函数而分配页框失败时就会发生这种情况。）</li>
<li>到这里，内存请求还没有被满足，或者是因为请求跨越了几个连续页框，或者是因为被选中的页框高速缓存为空。调用<code>__rmqueue()</code>函数从伙伴系统中分配所请求的页框。</li>
<li>如果内存请求得到满足，函数就初始化（第一个）页框的页描述符：清除一些标志，将private字段置0，并将页框引用计数器置1。此外，如果<code>gfp_flags</code>中的<code>__GPF_ZERO</code>标志被置位，则函数将被分配的内存区域填充0。</li>
<li>返回（第一个）页框的页描述符地址，如果内存分配请求失败则返回NULL。</li>
</ol>
<h3 id="释放页框到每CPU-页框高速缓存"><a href="#释放页框到每CPU-页框高速缓存" class="headerlink" title="释放页框到每CPU 页框高速缓存"></a>释放页框到每CPU 页框高速缓存</h3><p>为了释放单个页框到每CPU 页框高速缓存，内核使用<code>free_hot_page()</code>和<code>free_cold_page()</code>函数。它们都是<code>free_hot_cold_page()</code>函数的简单封装，接收的参数为将要释放的页框的描述符地址page和cold标志（指定是热高速缓存还是冷高速缓存）。</p>
<p><code>free_hot_cold_page()</code>函数执行如下操作：</p>
<ol>
<li>从<code>page-&gt;flags</code>字段获取包含该页框的内存管理区描述符地址。</li>
<li>获取由cold标志选择的管理区高速缓存的per_cpu_pages 描述符的地址。</li>
<li>检查高速缓存是否应该被清空：如果count值高于或等于high，则调用<code>free_pages_bulk()</code>函数，将管理区描述符、将被释放的页框个数（batch字段）、高速缓存链表的地址以及数字0（为0 到order 个页框）传递给该函数。<code>free_pages_bulkl()</code>函数依次反复调用<code>__free_pages_bulk()</code>函数来释放指定数量的（从高速缓存链表获得的）页框到内存管理区的伙伴系统中。</li>
<li>把释放的页框添加到高速缓存链表上，并增加count 字段。</li>
</ol>
<p>应该注意的是，在当前的Linux 2.6内核版本中，从没有页框被释放到冷高速缓存中：至于硬件高速缓存，内核总是假设被释放的页框是热的。当然，这并不意味着冷高速缓存是空的：当达到下界时通过<code>buffered_rmqueue()</code>补充冷高速缓存。</p>
<h2 id="管理区分配器"><a href="#管理区分配器" class="headerlink" title="管理区分配器"></a>管理区分配器</h2><p>管理区分配器是内核页框分配器的前端。该成分必须<strong>分配一个包含足够多空闲页框的内存管理区</strong>，使他能满足内存请求。管理区分配器必须满足几个目标：</p>
<ul>
<li>它应当保护保留的页框池。</li>
<li>当内存不足且允许阻塞当前进程时，它应当触发页框回收算法；一旦某些页框被释放，管理区分配器将再次尝试分配。</li>
<li>如果可能，它应当保存小而珍贵的<code>ZONE_DMA</code>内存管理区。例如，如果是对<code>ZONE_NORMAL</code>或<code>ZONE_HIGHMEM</code>页框的请求，那么管理区分配器会不太愿意分配ZONE_DMA内存管理区中的页框。</li>
</ul>
<p>对一组连续页框的每次请求实质上是通过执行<code>alloc_pages</code>宏实现的，接着这个宏又调用<code>__alloc_pages()</code>函数，它接收以下三个参数：</p>
<ul>
<li><code>gfp_mask</code>：在内存分配请求中指定的标志</li>
<li><code>order</code>：将要分配的一组连续页框数量的对数</li>
<li><code>zonelist</code>：指向<code>zonelist</code>的指针，该数据结构按优先次序描述了适于内存分配的内存管理区</li>
</ul>
<p><code>__alloc_pages()</code>扫描包含在<code>zonelist</code>中的每个内存管理区：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; (z = zonelinst-&gt;zones[i]) != <span class="literal">NULL</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">zone_watermark_of</span>(z, order, ...)) &#123;</span><br><span class="line">        page = <span class="built_in">buffered_rmqueue</span>(z, order, gfp_mask);</span><br><span class="line">        <span class="keyword">if</span> (page)</span><br><span class="line">            <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于每个内存管理区，该函数将空闲页框的个数与一个阈值作比较，该阈值取决于内存分配标志、当前进程的类型以及管理区被函数检查过的次数。实际上，如果空闲内存不足，那么每个内存管理区一般会被检查n遍，每一遍在所请求的空闲内存最低量的基础上使用更低的阈值扫描。因此前面一段代码在<code>__alloc_pages()</code>函数体内被复制了几次，每次变化很小。<code>__alloc_pages()</code>函数调用<code>buffered_rmqueue()</code>函数：它返回第一个被分配的页框的页描述符；如果内存管理区没有所请求大小的一组连续页框，则返回NULL。</p>
<p><code>zone_watermark_ok()</code>辅助函数，他的目的就是来探测对应的内存管理区中有没有足够的空闲页框，该函数接收几个参数，它们决定对应内存管理区中空闲页框个数的阈值min。同时满足下列两个条件则返回1的情况：</p>
<ol>
<li>除了被分配的页框外，在内存管理区中至少还有min个空闲页框，不包括为内存不足保留的页框（管理区描述符的lowmem_reserve 字段）。</li>
<li>除了被分配的页框外，这里在order至少为k的块中起码还有min/2^k 个空闲页框，其中，对于每个k，取值在1 和分配的order 之间。因此，如果order大于0，那么在大小至少为2的块中至少还有min/2个空闲页框；如果order大于1，那么在大小至少为4的块中起码还有min/4个空闲页框。</li>
</ol>
<p><code>__alloc_pages()</code>本质上执行如下步骤：</p>
<ol>
<li>执行对内存管理区的第一次扫描。在第一次扫描中，阈值min被设为<code>z-&gt;pages_low</code>，其中的z指向正在被分析的管理区描述符（参数can_try_harder 和gfp_high 被设为0）。</li>
<li>如果函数在上一步没有终止，那么没有剩下多少空闲内存：函数唤醒<code>kswapd</code>内核线程来异步地开始回收页框。</li>
<li>执行对内存管理区的第二次扫描，将值<code>z-&gt;pages_min</code>作为阈值base传递。正如前面解释的，实际阈值由<code>the_can_try_harder</code>和<code>gfp_high</code>标志决定。这一步与第1步相似，但该函数使用了较低的阈值。</li>
<li>如果函数在上一步没有终止，那么系统内存肯定不足。如果产生内存分配请求的内核控制路径不是一个中断处理程序或一个可延迟函数，并且它试图回收页框（或者是<code>current</code>的<code>PF_MEMALLOC</code>标志被置位，或者是它的<code>PF_MEMDIE</code>标志被置位），那么函数随即执行对内存管理区的第三次扫描，试图分配页框并忽略内存不足的阈值, 也就是说，不调用<code>zone_watermark_ok()</code>。唯有在这种情况下才允许内核控制路径耗用为内存不足预留的页（由管理区描述符的<code>lowmem_reserve</code>字段指定）。其实，在这种情况下产生内存请求的内核控制路径最终将试图释放页框，因此只要有可能它就应当得到它所请求的。如果没有任何内存管理区包含足够的页框，函数就返回NULL 来提示调用者发生了错误。</li>
<li>在这里，正在调用的内核控制路径并没有试图回收内存。如果<code>gfp_mask</code>的<code>__GFP_WAIT</code>标志没有被置位，函数就返回NULL 来提示该内核控制路径内存分配失败：在这种情况下，如果不阻塞当前进程就没有办法满足请求。</li>
<li>在这里当前进程能够被阻塞：调用<code>cond_resched()</code>检查是否有其它的进程需要CPU。</li>
<li>设置<code>current</code>的<code>PF_MEMALLOC</code>标志来表示进程已经准备好执行内存回收。</li>
<li>将一个指向<code>reclaim_state</code>数据结构的指针存入<code>current-&gt;reclaim_state</code>。这个数据结构只包含一个字段<code>reclaimed_slab</code>，被初始化为0。</li>
<li>调用<code>try_to_free_pages()</code>寻找一些页框来回收。后一个函数可能阻塞当前进程。一旦函数返回，<code>__alloc_pages()</code>就重设<code>current</code>的<code>PF_MEMALLOC</code>标志并再次调用<code>cond_resched()</code>。</li>
<li>如果上一步已经释放了一些页框，那么该函数还要执行一次与第3步相同的内存管理区扫描。如果内存分配请求不能被满足，那么函数决定是否应当继续扫描内存管理区：如果<code>__GFP_NORETRY</code>标志被清除, 并且内存分配请求跨越了多达8个页框或<code>__GFP_REPEAT</code>和<code>__GFP_NOFAIL</code>标志其中之一被置位，那么函数就调用<code>blk_congestion_wait()</code>使进程休眠一会儿，并且跳回到第6步。否则，函数返回NULL来提示调用者内存分配失败了。</li>
<li>如果在第9步中没有释放任何页框，就意味着内核遇到很大的麻烦，因为空闲页框已经少到了危险的地步，并且不可能回收任何页框。也许到了该作出重要决定的时候了。如果允许内核控制路径执行依赖于文件系统的操作来杀死一个进程（<code>gfp_mask</code>中的<code>__GFP_FS</code>标志被置位）并且<code>__GFP_NORETRY</code>标志为0，那么执行如下子步骤：<ol>
<li>使用等于<code>z-&gt;pages_high</code>的阈值再一次扫描内存管理区。</li>
<li>调用<code>out_of_memory()</code>通过杀死一个进程开始释放一些内存。</li>
<li>跳回第1 步。</li>
</ol>
</li>
</ol>
<p>因为第11a 步使用的界值远比前面扫描时使用的界值要高，所以这个步骤很容易失败。实际上，只有当另一个内核控制路径已经杀死一个进程来回收它的内存后，第11a 步才会成功执行。因此，第11a步避免了两个无辜的进程（而不是一个）被杀死。</p>
<h3 id="释放一组页框"><a href="#释放一组页框" class="headerlink" title="释放一组页框"></a>释放一组页框</h3><p>管理区分配器同样负责释放页框。</p>
<p>释放页框的所有内核宏和函数都依赖于<code>__free_pages()</code>函数。它接收的参数为<strong>将要释放的第一个页框的页描述符的地址</strong>(page)和<strong>将要释放的一组连续页框的数量的对数</strong>（order）。该函数执行如下步骤：</p>
<ol>
<li>检查第一个页框是否真正属于动态内存（它的<code>PG_reserved</code>标志被清0）；如果不是，则终止。</li>
<li>减少<code>page-&gt;_count</code>使用计数器的值；如果它仍然大于或等于0，则终止。</li>
<li>如果order 等于0，那么该函数调用<code>free_hot_page()</code>来释放页框给适当内存管理区的每CPU 热高速缓存。</li>
<li>如果order大于0，那么它将页框加入到本地链表中，并调用<code>free_pages_bulk()</code>函数把它们释放到适当内存管理区的伙伴系统中。</li>
</ol>
<h2 id="内存区管理"><a href="#内存区管理" class="headerlink" title="内存区管理"></a>内存区管理</h2><p><strong>内部碎片</strong>的产生主要是<strong>由于请求内存的大小与分配给它的大小不匹配而造成的</strong>，即使多个此数据结构通过一定规则挤进一个页面，那么也还有若干字节的空间被浪费。使用<strong>slab分配器</strong>解决，它有以下特性：</p>
<ul>
<li><strong>所存放数据的类型可以影响内存区的分配方式</strong>。<ul>
<li>例如，当给用户态进程分配一个页框时，内核调用<code>get_zeroed_page()</code>函数用0填充这个页。</li>
<li>slab分配器概念扩充了这种思想，并把内存区看作<strong>对象</strong>（object），这些对象由一组数据结构和几个叫做<strong>构造或析构函数</strong>组成。前者初始化内存区，而后者回收内存区。</li>
<li>为了避免重复初始化对象，<strong>slab分配器并不丢弃已分配的对象，而是释放但把它们保存在内存中</strong>。当以后又要请求新的对象时，就可以从内存获取而不用重新初始化。</li>
</ul>
</li>
<li><strong>内核函数倾向于反复请求同一类型的内存区</strong>。例如，只要内核创建一个新进程，它就要为一些固定大小的数据结构分配内存区。当进程结束时，包含这些数据结构的内存区还可以被重新使用。slab分配器把那些页框保存在高速缓存中并很快地重新使用它们。</li>
<li><strong>对内存区的请求可以根据它们发生的频率来分类</strong>。对于预期频繁请求一个特定大小的内存区而言，可以通过<strong>创建一组具有适当大小的专用对象来高效地处理</strong>，由此以避免内碎片的产生。另一种情况，对于很少遇到的内存区大小，可以通过<strong>基于一系列几何分布大小的对象的分配模式来处理</strong>，即使这种方法会导致内碎片的产生。</li>
<li>在引入的对象大小不是几何分布的情况下，也就是说，数据结构的起始地址不是物理地址值的2的幂次方，事情反倒好办。这可以借助处理器硬件高速缓存而导致较好的性能。</li>
<li><strong>硬件高速缓存的高性能</strong>又是尽可能地限制对伙伴系统分配器调用的另一个理由，因为对伙伴系统函数的每次调用都“弄脏”硬件高速缓存，所以增加了对内存的平均访问时间。内核函数对硬件高速缓存的影响就是所谓的函数<strong>足迹（footprint）</strong>，其定义为<strong>函数结束时重写高速缓存的百分比</strong>。显而易见，大的“足迹”导致内核函数刚执行之后较慢的代码执行，因为硬件高速缓存此时填满了无用的信息。</li>
</ul>
<p><strong>slab分配器把对象分组放进高速缓存</strong>。<strong>每个高速缓存都是同种类型对象的一种“储备”</strong>。例如，当一个文件被打开时，存放相应“打开文件”对象所需的内存区是从一个叫做filp（“文件指针”）的slab 分配器的高速缓存中得到的。</p>
<p>包含高速缓存的主内存区被划分为多个slab，每个slab 由一个或多个连续的页框组成，这些页框中既包含已分配的对象，也包含空闲的对象。<br><img src="/img/1602070897.jpg" alt=""></p>
<h3 id="高速缓存描述符"><a href="#高速缓存描述符" class="headerlink" title="高速缓存描述符"></a>高速缓存描述符</h3><p>每个高速缓存都是由<code>kmem_cache_t</code>（等价于<code>struct kmem_cache_s</code>类型）类型的数据结构来描述的；<br><img src="/img/1602070899.jpg" alt=""></p>
<p><code>kmem_cache_t</code>描述符的<code>lists</code>字段又是一个<code>kmem_lists</code>结构体，<br><img src="/img/1602070900.jpg" alt=""></p>
<h3 id="slab描述符"><a href="#slab描述符" class="headerlink" title="slab描述符"></a>slab描述符</h3><p>高速缓存中的每个slab都有自己的类型为slab的描述符<br><img src="/img/1602070968.png" alt=""></p>
<p>slab描述符可能存放在两个地方：</p>
<ul>
<li>外部slab描述符，存放在slab外部，位于<code>cache_sizes</code>指向的一个不适合ISA DMA的普通高速缓存中。</li>
<li>内部slab描述符，存放在slab内部，位于分配给slab的第一个页框的起始位置。</li>
</ul>
<p><img src="/img/1602071361.jpg" alt=""></p>
<h3 id="普通和专用高速缓存"><a href="#普通和专用高速缓存" class="headerlink" title="普通和专用高速缓存"></a>普通和专用高速缓存</h3><p>高速缓存被分为两种类型：普通和专用。普通高速缓存只由slab分配器用于自己的目的，而专用高速缓存由内核的其余部分使用。</p>
<p>普通高速缓存：</p>
<ul>
<li>第一种：第一个高速缓存叫做<code>kmem_cache</code>，包含有内核使用的其余高速缓存描述符。<code>cache_cache</code>变量包含第一个高速缓存的描述符；</li>
<li>第二种：用作<strong>普通用途的内存区</strong>。内存区大小一般分为13个内存区。<code>malloc_sizes</code>的表（其元素类型为<code>cache_sizes</code>）分别指向26个高速缓存描述符，与其相关的内存区大小为：32,64,128,256,…,131072字节。每种大小，都有两个高速缓存：一个适用于ISA DMA分配，另一个使用与常规分配。</li>
</ul>
<p>在系统初始化调用<code>kmem_cache_init()</code>和<code>kmem_cache_sizes_init()</code>来建立普通高速缓存。</p>
<p>专用高速缓存是由<code>kmem_cache_create()</code>函数创建的。从普通高速缓存中的<code>cache_cache</code>中取出来的一个描述符，并把描述符插入到高速缓存描述符的<code>cache_chain</code>链表中；还可以调用<code>kmem_cache_destory()</code>撤销一个高速缓存并将它从<code>cache_chain</code>链表上删除。为避免浪费空间，将分配的slab撤销，<code>kmem_cache_shrink()</code>函数通过反复调用<code>slab_destroy()</code>撤销所有的slab</p>
<h3 id="slab分配器与分区页框分配器的接口"><a href="#slab分配器与分区页框分配器的接口" class="headerlink" title="slab分配器与分区页框分配器的接口"></a>slab分配器与分区页框分配器的接口</h3><p>当slab分配器创建新的slab时，需要依靠分区页框分配器来获得一组连续的空闲页框。为了达到此目的，需要调用<code>kmem_getpages()</code>函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">kmem_getpages</span><span class="params">(<span class="type">kmem_cache_t</span> *cachep, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    flags |= cachep-&gt;gfpflags;</span><br><span class="line">    page = alloc_pages(flags, cachep-&gt;gfporder);</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    i = (<span class="number">1</span> &lt;&lt; cachep-&gt;gfporder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i--)</span><br><span class="line">            SetPageSlab(page++);</span><br><span class="line">    <span class="keyword">return</span> page_address(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>cachep</code>指向需要外页框的高速缓存的高速缓存描述符，<code>flags</code>说明如何请求页框，与存放在高速缓存描述符的<code>gfpflags</code>中的专用高速缓存分配标志相结合。</p>
<p>内存分配请求的大小由高速缓存描述符的<code>gfporder</code>字段指定，该字段将高速缓存中slab的大小编码，注意不可能从<code>ZONE_HIGHMEM</code>内存管理区分配页框，因为<code>kmem_getpages()</code>函数返回由<code>page_address()</code>函数产生的线性地址。</p>
<p>在相反的操作中，通过调用<code>kmem_freepages()</code>函数可以释放分配给slab的页框。这个函数从线性地址addr开始释放页框，这些页框曾分配给由cachep标识的高速缓存中的slab。</p>
<h3 id="给高速缓存分配slab"><a href="#给高速缓存分配slab" class="headerlink" title="给高速缓存分配slab"></a>给高速缓存分配slab</h3><p>一个新创建的高速缓存没有包含任何slab，因此也没有空闲的对象。只有当以下两个条件都为真时，才给高速缓存分配slab：</p>
<ul>
<li>已发出一个分配新对象的请求。</li>
<li>高速缓存不包含任何空闲对象。</li>
</ul>
<p>当这些情况发生时，slab 分配器通过调用<code>cache_grow()</code>函数给高速缓存分配一个新的slab：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cache_grow</span> <span class="params">(<span class="type">kmem_cache_t</span> * cachep, <span class="type">int</span> flags, <span class="type">int</span> nodeid)</span></span><br></pre></td></tr></table></figure><br>而这个函数调用<code>kmem_getpages()</code>从分区页框分配器获得一组页框来存放一个单独的slab，然后又调用<code>alloc_slabmgmt()</code>获得一个新的slab描述符。如果高速缓存描述符的<code>CFLGS_OFF_SLAB</code>标志置位，则从高速缓存描述符的<code>slabp_cache</code>字段指向的普通高速缓存中分配这个新的slab描述符；否则，从slab的第一个页框中分配这个slab描述符。</p>
<p>给定一个页框，内核必须确定它是否被slab分配器使用，<strong>如果是，就迅速得到相应高速缓存和slab描述符的地址</strong>。因此，<code>cache_grow()</code>扫描分配给新slab的页框的所有页描述符，并<strong>将高速缓存描述符和slab描述符的地址分别赋给页描述符中lru字段的<code>next</code>和<code>prev</code>子字段</strong>。这项工作不会出错，因为只有当页框空闲时伙伴系统的函数才会使用lru字段，而只要涉及伙伴系统，slab 分配器函数所处理的页框就不空闲并将<code>PG_slab</code>标志置位。</p>
<p>接着，<code>cache_grow()</code>调用<code>cache_init_objs()</code>，它将构造方法（如果定义了的话）在新slab 上添加对象。</p>
<p>最后，<code>cache_grow()</code>调用<code>list_add_tail()</code>来将新得到的slab 描述符<code>*slabp</code>，添加到高速缓存描述符<code>*cachep</code>的全空slab 链表的末端，并更新高速缓存中的空闲对象计数器：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_add_tail(&amp;slabp-&gt;<span class="built_in">list</span>, &amp;cachep-&gt;lists-&gt;slabs_free);</span><br><span class="line">cachep-&gt;lists-&gt;free_objects += cachep-&gt;num;</span><br></pre></td></tr></table></figure></p>
<h3 id="从高速缓存中释放slab"><a href="#从高速缓存中释放slab" class="headerlink" title="从高速缓存中释放slab"></a>从高速缓存中释放slab</h3><p>在两种条件下才能撤销slab：</p>
<ul>
<li>slab 高速缓存中有太多的空闲对象。</li>
<li>被周期性调用的定时器函数确定是否有完全未使用的slab 能被释放。</li>
</ul>
<p>在两种情况下，调用<code>slab_destroy()</code>函数撤销一个slab，并释放相应的页框到分区页框分配器：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">slab_destroy</span><span class="params">(<span class="type">kmem_cache_t</span> *cachep, <span class="type">slab_t</span> *slabp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(cachep_dtor) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cachep-&gt;num; i ++) &#123;</span><br><span class="line">            <span class="type">void</span> *objp = slabp-&gt;s_mem + cachep-&gt;objsize * i;</span><br><span class="line">            (cachep-&gt;dtor)(objp, cachep, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kmem_freepages(cachep, slabp-&gt;s_mem - slabp-&gt;colouroff);</span><br><span class="line">    <span class="keyword">if</span>(cachep-&gt;flags &amp;&amp; CFLAGS_OFF_SLAB)</span><br><span class="line">        kmem_cache_free(cachep-&gt;slabp_cache, slabp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数检查高速缓存是否为它的对象提供了析构方法，如果是，就<strong>使用析构方法释放slab 中的所有对象</strong>。objp 局部变量记录当前已检查的对象。接下来，又调用<code>kmem_freepages()</code>，该函数把slab 使用的所有连续页框返回给伙伴系统。最后，如果slab 描述符存放在slab 的外面，那么，就从slab 描述符的高速缓存释放这个slab 描述符。</p>
<h3 id="对象描述符"><a href="#对象描述符" class="headerlink" title="对象描述符"></a>对象描述符</h3><p>每个对象都有类型为<code>kmem_bufctl_t</code>的一个描述符，对象描述符放在数组中，位于相应的slab描述符之后，两种可能的存放：</p>
<ul>
<li>外部对象描述符：在slab外面，位于高速缓存描述符的<code>slabp_cache</code>字段指向的一个普通高速缓存中。</li>
<li>内部对象描述符：在slab内部，正好位于描述符所描述的对象之前。</li>
</ul>
<p>数组中的第一个对象描述符描述slab中的第一个对象，依次类推。它包含的是<strong>下一个空闲对象在slab中的下标</strong>，因此实现了slab内部空闲对象的一个<strong>简单链表</strong>。空闲对象链表中的最后一个元素的对象描述符用常规值<code>BUFCTL_END</code>（0xffff）标记。例如，某个slab中有16个对象，其中只有1、3、5号对象空闲。那么1号对象描述符的值为3，3号对象描述符的值为5，5号对象描述符的值为<code>BUFCTL_END</code>。<br><img src="/img/1602150476.jpg" alt=""></p>
<h3 id="对齐内存中的对象"><a href="#对齐内存中的对象" class="headerlink" title="对齐内存中的对象"></a>对齐内存中的对象</h3><p>slab 分配器所管理的对象可以在内存中进行对齐，也就是说，存放它们的内存单元的起始物理地址是一个给定常量的倍数，通常是2的倍数。这个常量就叫<strong>对齐因子</strong>（alignment factor）。</p>
<p>slab分配器所允许的最大对齐因子是<strong>4096</strong>，即页框大小。这就意味着通过访问对象的物理地址或线性地址就可以对齐对象。在这两种情况下，只有最低的12 位才可以通过对齐来改变。</p>
<p>通常情况下，如果内存单元的物理地址是字大小（即计算机的内部内存总线的宽度）对齐的， 那么， 微机对内存单元的存取会非常快。因此，缺省情况下，<strong><code>kmem_cache_create()</code>函数根据<code>BYTES_PER_WORD</code>宏所指定的字大小来对齐对象</strong>。对于80x86 处理器，这个宏产生的值为4，因为字长是32 位。</p>
<p>当创建一个新的slab高速缓存时，就可以让它所包含的对象在第一级硬件高速缓存中对齐。为了做到这点，设置<code>SLAB_HWCACHE_ALIGN</code>高速缓存描述符标志。<code>kmem_cache_create()</code>函数按如下方式处理请求：</p>
<ul>
<li>如果对象的大小大于高速缓存行（cache line）的一半，就在RAM中根据<code>L1_CACHE_BYTES</code>的倍数（也就是行的开始）对齐对象。</li>
<li>否则，对象的大小就是<code>L1_CACHE_BYTES</code>的因子取整。这可以保证一个小对象不会横跨两个高速缓存行。</li>
</ul>
<p>显然，slab 分配器在这里所做的事情就是以内存空间换取访问时间，即通过人为地增加对象的大小来获得较好的高速缓存性能，由此也引起额外的内碎片。</p>
<h3 id="slab着色"><a href="#slab着色" class="headerlink" title="slab着色"></a>slab着色</h3><p>在CPU中，同一硬件高速缓存行可以映射RAM中不同的块。高速缓存的硬件可能因此而花费内存周期在同一高速缓存行与RAM内存单元之间来来往往传送两个对象，而其他的高速缓存行并未充分使用。slab 分配器通过一种叫做<strong>slab 着色</strong>的策略，尽量降低高速缓存的这种不愉快行为：<strong>把叫做颜色的不同随机数分配给slab</strong>。</p>
<p>在讨论slab着色之前，我们再回顾一下高速缓存内对象的布局。让我们考虑某个高速缓存，它的对象在RAM中被对齐。这就意味着对象的地址肯定是某个给定正数值（比如说aln，我们设aln=0x100）的倍数。连对齐的约束也考虑在内，在slab 内放置对象就有很多种可能的方式。方式的选择取决于对下列变量所做的决定：</p>
<ul>
<li>num：可以在slab 中存放的对象个数（其值在高速缓存描述符的num 字段中）。</li>
<li>osize：对象的大小，包括对齐的字节。</li>
<li>dsize：slap描述符的大小加上所有对象描述符的大小，就等于硬件高速缓存行大小的最小倍数。如果slab 描述符和对象描述符都存放在slap 的外部，那么这个值等于0。</li>
<li>free：在slab 内未用字节（没有分配给任一对象的字节）的个数。</li>
</ul>
<p>一个slab 中的总字节长度可以表示为如下表达式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slab 的长度 = (num × osize) + dsize + <span class="built_in">free</span></span><br></pre></td></tr></table></figure></p>
<p>free 总是小于osize，因为否则的话，就有可能把另外的对象放在slab 内。不过，free 可以大于aln。</p>
<p>slab 分配器利用空闲未用的字节free 来对slab着色。术语<strong>着色</strong>只是用来再细分slab，并允许内存分配器把对象展开在不同的线性地址之中。这样的话，内核从微处理器的硬件高速缓存中可能获得最好性能。</p>
<p>具有不同颜色的slab<strong>把slab的第一个对象存放在不同的内存单元</strong>，同时<strong>满足对齐约束</strong>。可用颜色的个数是<code>free/aln</code>（这个值存放在高速缓存描述符的colour 字段）。因此，第一个颜色表示为0，最后一个颜色表示为<code>(free/aln)-1</code>。（一种特殊情况是，如果free 比aln 小，那么colour 被设为0，不过所有slab 都使用颜色0，因此颜色真正的个数为1。）</p>
<p>如果用颜色col 对一个slab 着色，那么，第一个对象的偏移量（相对于slab 的起始地址）就等于<code>col × aln + dsize</code>字节。图8-6 显示了slab 内对象的布局对slab 颜色的依赖情况。着色本质上导致把slab 中的一些空闲区域从末尾移到开始。<br><img src="/img/1602156662.jpg" alt=""></p>
<p>只有当free 足够大时，着色才起作用。显然，如果对象没有请求对齐，或者如果slab 内的未用字节数小于所请求的对齐（free ≤ aln），那么，唯一可能着色的slab 就是具有颜色0 的slab，也就是说，把这个slab 的第一个对象的偏移量赋为0。</p>
<p>通过把当前颜色存放在高速缓存描述符的<code>colour_next字</code>段，就可以在一个给定对象类型的slab 之间平等地发布各种颜色。<code>cache_grow()</code>函数把<code>colour_next</code>所表示的颜色赋给一个新的slab，并递增这个字段的值。当<code>colour_next</code>的值变为colour后，又从0 开始。这样，每个新创建的slab 都与前一个slab 具有不同的颜色，直到最大可用颜色。此外，<code>cache_grow()</code>函数从高速缓存描述符的<code>colour_off</code>字段获得值aln，根据slab内对象的个数计算<code>dsize</code>，最后把<code>col×aln+dsize</code>的值存放到slab描述符的<code>colouroff</code>字段中。</p>
<h3 id="空闲slab对象的本地高速缓存"><a href="#空闲slab对象的本地高速缓存" class="headerlink" title="空闲slab对象的本地高速缓存"></a>空闲slab对象的本地高速缓存</h3><p>为了减少处理器之间对自旋锁的竞争并更好的利用硬件高速缓存，slab分配器的每个高速缓存包含一个被称作<strong>slab本地高速缓存</strong>的每CPU数据结构，该结构由一个指向被释放对象的小指针数组组成。slab对象的大多数分配和释放只影响本地数组，只有在本地数组下溢或上溢时才涉及slab数据结构。</p>
<p>高速缓存描述符的array字段是一组指向<code>array_cache</code>数据结构的指针，系统中每个CPU对应于一个元素。每个<code>array_cache</code>数据结构是空闲对象的本地高速缓存的一个描述符。<br><img src="/img/1602156913.jpg" alt=""></p>
<p><strong>本地高速缓存描述符并不包含本地高速缓存本身的地址</strong>；事实本地高速缓存本身的地址在本地高速缓存描述符之后。本地高速缓存存放的是指向已经释放的对象的指针，而不是对象本身，对象本身总是位于高速缓存的slab中。</p>
<p>当创建一个新的slab高速缓存时，<code>kmem_cache_create()</code>函数决定本地高速缓存大小、分配本地高速缓存，并将它们的指针存放在高速缓存描述符的array字段。</p>
<p>多处理器系统中，小对象使用的slab高速缓存同样包含一个附加的本地高速缓存，他的地址被存放在高速缓存描述符的<code>lists.shared</code>中，被所有的CPU共享，它使得将空闲对象从一个本地高速缓存移动到另一个高速缓存的任务更加容易。</p>
<h3 id="分配slab对象"><a href="#分配slab对象" class="headerlink" title="分配slab对象"></a>分配slab对象</h3><p>通过调用<code>kmem_cache_alloc()</code>函数获得新对象。参数<code>cachep</code>指向高速缓存描述符，新空闲对象必须从该高速缓存描述符获得，而参数flag表示传递给分区页框分配器函数的标志，该高速缓存的所有slab应当是满的。该函数本质上等价于下列代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">kmem_cache_alloc</span><span class="params">(<span class="type">kmem_cache_t</span> *cachep, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> save_flags;</span><br><span class="line">    <span class="type">void</span> *objp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">ac</span>;</span></span><br><span class="line"></span><br><span class="line">    local_irq_save(save_flags);</span><br><span class="line">    ac = cache_p-&gt;<span class="built_in">array</span>[smp_processor_id()];</span><br><span class="line">    <span class="keyword">if</span> (ac-&gt;avail) &#123;</span><br><span class="line">        ac-&gt;touched = <span class="number">1</span>;</span><br><span class="line">        objp = ((<span class="type">void</span> **)(ac+<span class="number">1</span>))[--ac-&gt;avail];</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        objp = cache_alloc_refill(cachep, flags);</span><br><span class="line">    local_irq_restore(save_flags);</span><br><span class="line">    <span class="keyword">return</span> objp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数首先试图从本地高速缓存获得一个空闲对象。如果有空闲对象，<code>avail</code>字段就包含指向最后被释放的对象的项在本地高速缓存中的下标。因为本地高速缓存数组正好存放在ac 描述符���面，所以<code>((void**)(ac+1))[--ac-&gt;avail]</code>获得那个空闲对象的地址并递减<code>ac-&gt;avail</code>的值。当本地高速缓存中没有空闲对象时，调用<code>cache_alloc_refill()</code>函数重新填充本地高速缓存并获得一个空闲对象。</p>
<p><code>cache_alloc_refill()</code>函数本质上执行如下步骤：</p>
<ol>
<li>将本地高速缓存描述符的地址存放在ac 局部变量中：<code>ac = cachep-&gt;array[smp_processor_id()];</code></li>
<li>获得<code>cachep-&gt;spinlock</code>。</li>
<li>如果slab高速缓存包含共享本地高速缓存，并且该共享本地高速缓存包含一些空闲对象，函数就通过从共享本地高速缓存中上移<code>ac-&gt;batchcount</code>个指针来重新填充CPU 的本地高速缓存。然后，函数跳到第6 步。</li>
<li>函数试图填充本地高速缓存， 填充值为高速缓存的slab中包含的多达<code>ac-&gt;batchcount</code>个空闲对象的指针：<ol>
<li>查看高速缓存描述符的<code>slabs_partial</code>和<code>slabs_free</code>链表，并获得slab 描述符的地址slabp，该slab描述符的相应slab或者部分被填充，或者为空。如果不存在这样的描述符，则函数转到第5 步。</li>
<li>对于slab 中的每个空闲对象，函数增加slab描述符的<code>inuse</code>字段，将对象的地址插入本地高速缓存，并更新free字段使得它存放了slab 中下一个空闲对象的下标：</li>
<li><code>slabp-&gt;inuse++;</code>，<code>((void**)(ac+1))[ac-&gt;avail++] = slabp-&gt;s_mem + slabp-&gt;free * cachep-&gt;obj_size;</code>，<code>slabp-&gt;free = ((kmem_bufctl_t*)(slabp+1))[slabp-&gt;free];</code></li>
<li>如果必要，将清空的slab 插入到适当的链表上，可以是<code>slab_full</code>链表，也可以是<code>slab_partial</code>链表。</li>
</ol>
</li>
<li>在这一步，被加到本地高速缓存上的指针个数被存放在<code>ac-&gt;avail</code>字段：函数递减同样数量的<code>kmem_list3</code>结构的<code>free_objects</code>字段来说明这些对象不再空闲。</li>
<li>释放<code>cachep-&gt;spinlock</code>。</li>
<li>如果现在<code>ac-&gt;avail</code>字段大于0（一些高速缓存再填充的情况发生了），函数将<code>ac-&gt;touched</code>字段设为1，并返回最后插入到本地高速缓存的空闲对象指针：<code>return ((void**)(ac+1))[--ac-&gt;avail];</code></li>
<li>否则，没有发生任何高速缓存再填充情况：调用<code>cache_grow()</code>获得一个新slab，从而获得了新的空闲对象。</li>
<li>如果<code>cache_grow()</code>失败了，则函数返回NULL；否则它返回到第1 步重复该过程。</li>
</ol>
<h3 id="释放Slab对象"><a href="#释放Slab对象" class="headerlink" title="释放Slab对象"></a>释放Slab对象</h3><p><code>kmem_cache_free()</code>函数<strong>释放一个曾经由slab分配器分配给某个内核函数的对象</strong>。它的参数为cachep和objp，前者是高速缓存描述符的地址，而后者是将被释放对象的地址：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_free</span><span class="params">(<span class="type">kmem_cache_t</span> *cachep, <span class="type">void</span> *objp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">ac</span>;</span></span><br><span class="line"></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line">    ac = cachep-&gt;<span class="built_in">array</span>[smp_processor_id()];</span><br><span class="line">    <span class="keyword">if</span> (ac-&gt;avail == ac-&gt;limit)</span><br><span class="line">        cache_flusharray(cachep, ac);</span><br><span class="line">    ((<span class="type">void</span>**)(ac+<span class="number">1</span>))[ac-&gt;avail++] = objp;</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数首先检查本地高速缓存是否有空间给指向一个空闲对象的额外指针。如果有，该指针就被加到本地高速缓存然后函数返回。否则，它首先调用<code>cache_flusharray()</code>来清空本地高速缓存，然后将指针加到本地高速缓存。</p>
<p><code>cache_flusharray()</code>函数执行如下操作：</p>
<ol>
<li>获得<code>cachep-&gt;spinlock</code>自旋锁。</li>
<li>如果slab高速缓存包含一个共享本地高速缓存，并且如果该共享本地高速缓存还没有满，函数就通过从CPU的本地高速缓存中上移<code>ac-&gt;batchcount</code>个指针来重新填充共享本地高速缓存。</li>
<li>调用<code>free_block()</code>函数将当前包含在本地高速缓存中的<code>ac-&gt;batchcount</code>个对象归还给slab 分配器。对于在地址objp处的每个对象，函数执行如下步骤：<ol>
<li>增加高速缓存描述符的<code>lists.free_objects</code>字段。</li>
<li>确定包含对象的slab 描述符的地址：<code>slabp = (struct slab *)(virt_to_page(objp)-&gt;lru.prev);</code>，请记住，slab 页的描述符的lru.prev 字段指向相应的slab 描述符。</li>
<li>从它的slab 高速缓存链表（<code>cachep-&gt;lists.slabs_partial</code>或是<code>cachep-&gt;lists.slabs_full</code>）上删除slab 描述符。</li>
<li>计算slab 内对象的下标：<code>objnr = (objp - slabp-&gt;s_mem) / cachep-&gt;objsize;</code></li>
<li>将<code>slabp-&gt;free</code>的当前值存放在对象描述符中，并将对象的下标放入<code>slabp-&gt;free</code>（最后被释放的对象将再次成为首先被分配的对象）：<code>((kmem_bufctl_t *)(slabp+1))[objnr] = slabp-&gt;free;</code>，<code>slabp-&gt;free = objnr;</code></li>
<li>递减<code>slabp-&gt;inuse</code>字段。</li>
<li>如果<code>slabp-&gt;inuse</code>等于0（也就是slab 中所有对象空闲），并且整个slab 高速缓存中空闲对象的个数(<code>cachep-&gt;lists.free_objects</code>)大于cachep-&gt;free_limit字段中存放的限制，那么函数将slab 的页框释放到分区页框分配器：<code>cachep-&gt;lists.free_objects -= cachep-&gt;num;</code>，<code>lab_destroy(cachep, slabp);</code>。放在<code>cachep-&gt;free_limit</code>字段中的值通常等于<code>cachep-&gt;num+(1+N)×cachep-&gt;batchcount</code>，其中N 代表系统中CPU 的个数。</li>
<li>否则，如果<code>slab-&gt;inuse</code>等于0，但整个slab 高速缓存中空闲对象的个数小于<code>cachep-&gt;free_limit</code>，函数就将slab描述符插入到<code>cachep-&gt;lists.slabs_free</code>链表中。</li>
<li>最后，如果<code>slab-&gt;inuse</code>大于0，slab 被部分填充，则函数将slab 描述符插入到<code>cachep-&gt;lists.slabs_partial</code>链表中。</li>
</ol>
</li>
<li>释放<code>cachep-&gt;spinlock</code>自旋锁。</li>
<li>通过减去被移到共享本地高速缓存或被释放到slab分配器的对象的个数来更新本地高速缓存描述符的avail 字段。</li>
<li>移动本地高速缓存数组起始处的那个本地高速缓存中的所有指针。这一步是必需的，因为已经把第一个对象指针从本地高速缓存上删除，因此剩下的指针必须上移。</li>
</ol>
<h3 id="通用对象"><a href="#通用对象" class="headerlink" title="通用对象"></a>通用对象</h3><p>初始化阶段建立了一些高速缓存包含用作通用用途的类型的slab对象。如果对存储区的请求不频繁，就用一组普通高速缓存来处理，普通高速缓存中的对象具有几何分布的大小，范围为32～131072 字节。</p>
<p>调用<code>kmalloc()</code>函数就可以得到这种类型的对象，函数等价于下列代码片段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cache_sizes</span> *<span class="title">csizep</span> =</span> malloc_sizes;</span><br><span class="line">    <span class="type">kmem_cache_t</span> * cachep;</span><br><span class="line">    <span class="keyword">for</span> (; csizep-&gt;cs_size; csizep++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; csizep-&gt;cs_size)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; _ _GFP_DMA)</span><br><span class="line">            cachep = csizep-&gt;cs_dmacachep;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cachep = csizep-&gt;cs_cachep;</span><br><span class="line">        <span class="keyword">return</span> kmem_cache_alloc(cachep, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该函数使用<code>malloc_sizes</code>表为所请求的大小分配最近的2 的幂次方大小的内存。然后，调用<code>kmem_cache_alloc()</code>分配对象，传递的参数或者为适用于ISA DMA 页框的高速缓存描述符，还是为适用于“常规”页框的高速缓存描述符，这取决于调用者是否指定了<code>__GFP_DMA</code>标志。</p>
<p>调用<code>kmalloc()</code>所获得的对象可以通过调用<code>kfree()</code>来释放：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *objp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">kmem_cache_t</span> * c;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="keyword">if</span> (!objp)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    local_irq_save(flags);</span><br><span class="line">    c = (<span class="type">kmem_cache_t</span> *)(virt_to_page(objp)-&gt;lru.next);</span><br><span class="line">     kmem_cache_free(c, (<span class="type">void</span> *)objp);</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过读取内存区所在的第一个页框描述符的<code>lru.next</code>子字段，就可确定出合适的高速缓存描述符。通过调用<code>kmem_cache_free()</code>来释放相应的内存区。</p>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p><strong>内存池</strong>（memory pool）是Linux 2.6 的一个新特性，主要供一些驱动程序使用。基本上讲，一个内存池允许一个内核成分，如块设备子系统，仅在内存不足的紧急情况下分配一些动态内存来使用。</p>
<p>一个内存池常常叠加在slab 分配器之上 —— 也就是说，<strong>它被用来保存slab 对象的储备</strong>。但是一般而言，内存池能被用来分配任何一种类型的动态内存，从整个页框到使用<code>kmalloc()</code>分配的小内存区。因此，我们一般将内存池处理的内存单元看作<strong>内存元素</strong>。</p>
<p>内存池由<code>mempool_t</code>对象描述，它的字段如下所示。<br><img src="/img/1602070969.png" alt=""></p>
<p><code>min_nr</code>字段存放了内存池中元素的初始个数。换句话说，<strong>存放在该字段中的值代表了内存元素的个数</strong>，内存池的拥有者确信能从内存分配器得到这个数目。<code>curr_nr</code>字段总是低于或等于<code>min_nr</code>，它<strong>存放了内存池中当前包含的内存元素个数</strong>。内存元素自身被一个指针数组引用，指针数组的地址存放在<code>elements</code>字段中。</p>
<p><code>alloc</code>和<code>free</code>方法与基本的内存分配器进行交互，<strong>分别用于获得和释放一个内存元素</strong>。两个方法可以是拥有内存池的内核成分提供的定制函数。<br>当内存元素是slab对象时，<code>alloc</code>和<code>free</code>方法一般由<code>mempool_alloc_slab()</code>和<code>mempool_free_slab()</code>函数实现，它们只是分别调用<code>kmem_cache_alloc()</code>和<code>kmem_cache_free()</code>函数。在这种情况下，<code>mempool_t</code>对象的<code>pool_data</code>字段存放了slab高速缓存描述符的地址。</p>
<p><code>mempool_create()</code>函数创建一个新的内存池；它接收的参数为内存元素的个数<code>min_nr</code>、实现<code>alloc</code>和<code>free</code>方法的函数的地址和赋给<code>pool_data</code>字段的任意值。该函数分别为<code>mempool_t</code>对象和指向内存元素的指针数组分配内存，然后反复调用<code>alloc</code>方法来得到<code>min_nr</code>个内存元素。相反地，<code>mempool_destroy()</code>函数释放池中所有内存元素，然后释放元素数组和<code>mempool_t</code>对象自己。</p>
<p>为了从内存池分配一个元素，内核调用<code>mempool_alloc()</code>函数，将<code>mempool_t</code>对象的地址和内存分配标志传递给它。函数本质上依据参数所指定的内存分配标志，试图通过调用<code>alloc</code>方法从基本内存分配器分配一个内存元素。<strong>如果分配成功，函数返回获得的内存元素而不触及内存池。否则，如果分配失败，就从内存池获得内存元素</strong>。当然，在内存不足的情况下过多的分配会用尽内存池：在这种情况下，如果<code>__GFP_WAIT</code>标志没有置位，则<code>mempool_alloc()</code>阻塞当前进程直到有一个内存元素被释放到内存池中。</p>
<p>相反地，为了释放一个元素到内存池，内核调用<code>mempool_free()</code>函数。如果内存池未满（<code>curr_min</code>小于<code>min_nr</code>），则函数将元素加到内存池中。否则，<code>mempool_free()</code>调用<code>free</code>方法来释放元素到基本内存分配器。</p>
<h2 id="非连续内存区管理"><a href="#非连续内存区管理" class="headerlink" title="非连续内存区管理"></a>非连续内存区管理</h2><p>把内存区映射到一组连续的页框是最好的选择，这样可以充分利用高速缓存就并获得较低的平均访问时间。不过，如果对内存区的请求不是很频繁，那通过连续的线性地址来访问非连续的页框这样一种分配方式将会很有意义，因为这样可以避免外部碎片，而缺点是必须打乱内核页表。显然，非连续内存区的大小必须是4096的倍数。</p>
<h3 id="非连续内存的线性地址"><a href="#非连续内存的线性地址" class="headerlink" title="非连续内存的线性地址"></a>非连续内存的线性地址</h3><p>查找线性地址的空闲区，可以从<code>PAGE_OFFSET</code>开始查找（通常为0xc0000000，即第四个GB的起始地址）：<br><img src="/img/1602070970.png" alt=""></p>
<ul>
<li>内存区的开始部分包含的是对前896MB RAM进行映射的线性地址。直接映射的物理内存末尾所对应的线性地址保存在<code>high_memory</code>全局变量中。当物理内存小于896MB，则线性地址0xc0000000以后的896MB与其一一对应；当物理内存大于896MB而小于4GB时，只直接映射前896MB的地址到0xc0000000以后的线性空间，然后把线性空间的其他部分与896MB和4GB物理空间映射起来，称为<strong>动态重映射</strong>；当物理内存大于4GB，则需要考虑PAE的情况。</li>
<li>从<code>PKMAP_BASE</code>开始，我们查找用于高端内存页框的永久内核映射的线性地址。</li>
<li>其余的线性地址可以用于非连续内存区。在物理内存映射的末尾与第一个内存区之间插入一个大小为8MB（宏<code>VMALLOC_OFFSET</code>）的安全区，目的是为了“捕获”对内存的越界访问。出于同样的理由，插入其他4KB 大小的安全区来隔离非连续的内存区。</li>
</ul>
<p>为非连续内存区保留的线性地址空间的起始地址由<code>VMALLOC_START</code>宏定义，而末尾地址由<code>VMALLOC_END</code>宏定义。</p>
<h3 id="非连续内存区的描述符"><a href="#非连续内存区的描述符" class="headerlink" title="非连续内存区的描述符"></a>非连续内存区的描述符</h3><p>每个非连续内存区都对应着一个类型为<code>vm_struct</code>的描述符：<br><img src="/img/1602070971.png" alt=""></p>
<p>通过<code>next</code>字段，这些描述符被插入到一个简单的链表中，链表第一个元素的地址存放在<code>vmlist</code>变量中。对这个链表的访问依靠<code>vmlist_lock</code>读/ 写自旋锁来保护。flags字段标识了非连续区映射的内存的类型：</p>
<ul>
<li><code>VM_ALLOC</code>表示使用<code>vmalloc()</code>得到的页；</li>
<li><code>VM_MAP</code>表示使用<code>vmap()</code>映射的已经被分配的页；</li>
<li><code>VM_IOREMAP</code>表示使用<code>ioremap()</code>映射的硬件设备的板上内存。</li>
</ul>
<p><code>get_vm_area()</code>函数在线性地址<code>VMALLOC_START</code>和<code>VMALLOC_END</code>之间查找一个空闲区域。该函数使用两个参数：<strong>将被创建的内存区的字节大小</strong>（size）和<strong>指定空闲区类型的标志</strong>（flag）。步骤执行如下：</p>
<ol>
<li>调用<code>kmalloc()</code>为<code>vm_struct</code>类型的新描述符获得一个内存区。</li>
<li>为写得到<code>vmlist_lock</code>锁，并扫描类型为<code>vm_struct</code>的描述符链表来查找线性地址一个空闲区域，至少覆盖<code>size + 4096</code>个地址（4096 是内存区之间的安全区间大小）。</li>
<li>如果存在这样一个区间，函数就初始化描述符的字段，释放<code>vmlist_lock</code>锁，并以返回这个非连续内存区的起始地址而结束。</li>
<li>否则，<code>get_vm_area()</code>释放先前得到的描述符，释放<code>vmlist_lock</code>，然后返回NULL。</li>
</ol>
<h3 id="分配非连续内存区"><a href="#分配非连续内存区" class="headerlink" title="分配非连续内存区"></a>分配非连续内存区</h3><p><code>vmalloc()</code>函数<strong>给内核分配一个非连续内存区</strong>。参数size表示所请求内存区的大小。如果这个函数能够满足请求，就返回新内存区的起始地址；否则，返回一个NULL指针（<code>mm/vmalloc.c</code>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pages</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> array_size, i;</span><br><span class="line">    size = (size + PAGE_SIZE - <span class="number">1</span>) &amp; PAGE_MASK;</span><br><span class="line">    area = get_vm_area(size, VM_ALLOC);</span><br><span class="line">    <span class="keyword">if</span> (!area)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    area-&gt;nr_pages = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    array_size = (area-&gt;nr_pages * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> page *));</span><br><span class="line">    area-&gt;pages = pages = kmalloc(array_size, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!area-&gt;pages) &#123;</span><br><span class="line">        remove_vm_area(area-&gt;addr);</span><br><span class="line">        kfree(area);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(area-&gt;pages, <span class="number">0</span>, array_size);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;area-&gt;nr_pages; i++) &#123;</span><br><span class="line">        area-&gt;pages[i] = alloc_page(GFP_KERNEL|_ _GFP_HIGHMEM);</span><br><span class="line">        <span class="keyword">if</span> (!area-&gt;pages[i]) &#123;</span><br><span class="line">            area-&gt;nr_pages = i;</span><br><span class="line">    fail:   vfree(area-&gt;addr);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map_vm_area(area, _ _pgprot(<span class="number">0x63</span>), &amp;pages) )</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    <span class="keyword">return</span> area-&gt;addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数首先将参数<code>size</code>设为4096（页框大小）的整数倍。然后，<code>vmalloc()</code>调用<code>get_vm_area()</code>来创建一个新的描述符，并返回分配给这个内存区的线性地址。描述符的<code>flags</code>字段被初始化为<code>VM_ALLOC</code>标志，该标志意味着通过使用<code>vmalloc()</code>函数，非连续页框将被映射到一个线性地址区间。然后<code>vmalloc()</code>函数调用<code>kmalloc()</code>来请求一组连续页框，这组连续页框足够包含一个页描述符指针数组。调用<code>memset()</code>函数来将所有这些指针设为NULL。接着重复调用<code>alloc_page()</code>函数，每一次为区间中<code>nr_pages</code>个页的每一个分配一个页框，并把对应页描述符的地址存放在<code>area-&gt;pages</code>数组中。注意，必须使用<code>area-&gt;pages</code>数组是因为页框可能属于<code>ZONE_HIGHMEM</code>内存管理区，所以此时它们不必被映射到一个线性地址上。</p>
<p>简要介绍一下<code>memset(area-&gt;pages, 0, array_size)</code>的实现函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> * __memset_generic(<span class="type">void</span> * s, <span class="type">char</span> c,<span class="type">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> d0, d1;</span><br><span class="line">__asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;rep/n/t&quot;</span></span><br><span class="line">    <span class="string">&quot;stosb&quot;</span></span><br><span class="line">    : <span class="string">&quot;=&amp;c&quot;</span> (d0), <span class="string">&quot;=&amp;D&quot;</span> (d1)</span><br><span class="line">    :<span class="string">&quot;a&quot;</span> (c),<span class="string">&quot;1&quot;</span> (s),<span class="string">&quot;0&quot;</span> (count)</span><br><span class="line">    :<span class="string">&quot;memory&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，已经得到了一个新的连续线性地址区间，并且已经分配了一组非连续页框来映射这些线性地址。最后至关重要的步骤是<strong>修改内核使用的页表项 ，以此表明分配给非连续内存区的每个页框现在对应着一个线性地址，这个线性地址被包含在<code>vmalloc()</code>产生的非连续线性地址区间中</strong>。这就是<code>map_vm_area()</code>所要做的，下面来详细说说:</p>
<p><code>map_vm_area()</code>函数使用以下3 个参数：</p>
<ul>
<li><code>area</code>：指向内存区的<code>vm_struct</code>描述符的指针。</li>
<li><code>prot</code>：已分配页框的保护位。它总是被置为0x63，对应着Present、Accessed、Read/Write 及Dirty。</li>
<li><code>pages</code>：指向一个指针数组的变量的地址，该指针数组的指针指向页描述符（因此，<code>struct page ***</code>被当作数据类型使用！）。</li>
</ul>
<p>函数首先把内存区的开始和末尾的线性地址分别分配给局部变量address和end：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address = area-&gt;addr;</span><br><span class="line">end = address + (area-&gt;size - PAGE_SIZE);</span><br></pre></td></tr></table></figure><br>请记住，<code>area-&gt;size</code>存放的是内存区的实际地址加上4KB 内存之间的安全区间。然后函数使用<code>pgd_offset_k</code>宏来得到在主内核页全局目录中的目录项，该项对应于内存区起始线性地址，然后获得内核页表自旋锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pgd = pgd_offset_k(address);</span><br><span class="line">spin_lock(&amp;init_mm.page_table_lock);</span><br></pre></td></tr></table></figure></p>
<p>然后，函数执行下列循环：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = pgd_index(address); i &lt; pgd_index(end<span class="number">-1</span>); i++) &#123;</span><br><span class="line">    <span class="type">pud_t</span> *pud = pud_alloc(&amp;init_mm, pgd, address);</span><br><span class="line">    ret = -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (!pud)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    next = (address + PGDIR_SIZE) &amp; PGDIR_MASK;</span><br><span class="line">    <span class="keyword">if</span> (next &lt; address || next &gt; end)</span><br><span class="line">        next = end;</span><br><span class="line">    <span class="keyword">if</span> (map_area_pud(pud, address, next, prot, pages))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    address = next;</span><br><span class="line">    pgd++;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock(&amp;init_mm.page_table_lock);</span><br><span class="line">flush_cache_vmap((<span class="type">unsigned</span> <span class="type">long</span>)area-&gt;addr, end);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure><br>每次循环都首先调用<code>pud_alloc()</code>来为新内存区创建一个页上级目录，并把它的物理地址写入内核页全局目录的合适表项。然后调用<code>alloc_area_pud()</code>为新的页上级目录分配所有相关的页表。接下来，把常量2^30（在PAE被激活的情况下，否则为2^22）与address的当前值相加（2^30 就是一个页上级目录所跨越的线性地址范围的大小），最后增加指向页全局目录的指针pgd。</p>
<p>循环结束的条件是：<strong>指向非连续内存区的所有页表项全被建立</strong>。</p>
<p><code>map_area_pud()</code>函数为页上级目录所指向的所有页表执行一个类似的循环：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">pmd_t</span> * pmd = pmd_alloc(&amp;init_mm, pud, address);</span><br><span class="line">    <span class="keyword">if</span> (!pmd)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (map_area_pmd(pmd, address, end-address, prot, pages))</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    address = (address + PUD_SIZE) &amp; PUD_MASK;</span><br><span class="line">    pud++;</span><br><span class="line">&#125; <span class="keyword">while</span> (address &lt; end);</span><br></pre></td></tr></table></figure><br><code>map_area_pmd()</code>函数<strong>为页中间目录所指向的所有页表执行一个类似的循环</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> * pte = pte_alloc_kernel(&amp;init_mm, pmd, address);</span><br><span class="line">    <span class="keyword">if</span> (!pte)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (map_area_pte(pte, address, end-address, prot, pages))</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    address = (address + PMD_SIZE) &amp; PMD_MASK;</span><br><span class="line">    pmd++;</span><br><span class="line">&#125; <span class="keyword">while</span> (address &lt; end);</span><br></pre></td></tr></table></figure><br><code>pte_alloc_kernel()</code>函数<strong>分配一个新的页表，并更新页中间目录中相应的目录项</strong>。接下来，<code>map_area_pte()</code>为页表中相应的表项分配所有的页框。address值增加2^22（2^22 就是一个页表所跨越的线性地址区间的大小），并且循环反复执行。</p>
<p><code>map_area_pte()</code>的主循环为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> * <span class="title">page</span> =</span> **pages;</span><br><span class="line">    set_pte(pte, mk_pte(page, prot));</span><br><span class="line">    address += PAGE_SIZE;</span><br><span class="line">    pte++;</span><br><span class="line">    (*pages)++;</span><br><span class="line">&#125; <span class="keyword">while</span> (address &lt; end);</span><br></pre></td></tr></table></figure><br>将被映射的页框的页描述符地址<code>page</code>是从地址<code>pages</code>处的变量指向的数组项读得的。通过<code>set_pte</code>和<code>mk_pte</code>宏，把新页框的物理地址写进页表。把常量4096（即一个页框的长度）加到address上之后，循环又重复执行。</p>
<p>注意，<code>map_vm_area()</code>并不触及当前进程的页表。因此，当内核态的进程访问非连续内存区时，缺页发生，因为该内存区所对应的进程页表中的表项为空。然而，<strong>缺页处理程序要检查这个缺页线性地址是否在主内核页表中（也就是<code>init_mm.pgd</code>页全局目录和它的子页表）。一旦处理程序发现一个主内核页表含有这个线性地址的非空项，就把它的值拷贝到相应的进程页表项中，并恢复进程的正常执行</strong>。</p>
<p>除了<code>vmalloc()</code>函数之外，非连续内存区还能由<code>vmalloc_32()</code>函数分配，该函数与<code>vmalloc()</code>很相似，但是它只从<code>ZONE_NORMAL</code>和<code>ZONE_DMA</code>内存管理区中分配页框。</p>
<p>Linux 2.6 还特别提供了一个<code>vmap()</code>函数，它将映射非连续内存区中已经分配的页框：本质上，该函数接收一组指向页描述符的指针作为参数，调用<code>get_vm_area()</code>得到一个新<code>vm_struct</code>描述符，然后调用<code>map_vm_area()</code>来映射页框。因此该函数与<code>vmalloc()</code>相似，但是它不分配页框。</p>
<h3 id="释放非连续内存区"><a href="#释放非连续内存区" class="headerlink" title="释放非连续内存区"></a>释放非连续内存区</h3><p><code>vfree()</code>函数释放<code>vmalloc()</code>或<code>vmalloc_32()</code>创建的非连续内存区，而<code>vunmap()</code>函数释放<code>vmap()</code>创建的内存区。两个函数都使用同一个参数 —— <strong>将要释放的内存区的起始线性地址address</strong>；它们都依赖于<code>__vunmap()</code>函数来做实质性的工作。</p>
<p><code>__vunmap()</code>函数接收两个参数：<strong>将要释放的内存区的起始地址的地址<code>addr</code></strong>，以及<strong>标志<code>deallocate_pages</code></strong>，如果被映射到内存区内的页框应当被释放到分区页框分配器（调用<code>vfree()</code>）中，那么这个标志被置位，否则被清除（<code>vunmap()</code>被调用）。该函数执行以下操作：</p>
<ol>
<li>调用<code>remove_vm_area()</code>函数得到<code>vm_struct</code>描述符的地址<code>area</code>，并清除非连续内存区中的线性地址对应的内核的页表项。</li>
<li>如果<code>deallocate_pages</code>被置位，函数扫描指向页描述符的<code>area-&gt;pages</code>指针数组；对于数组的每一个元素，调用<code>__free_page()</code>函数释放页框到分区页框分配器。此外，执行<code>kfree(area-&gt;pages)</code>来释放数组本身。</li>
<li>调用<code>kfree(area)</code>来释放<code>vm_struct</code>描述符。</li>
</ol>
<p><code>remove_vm_area()</code>函数执行如下循环：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">write_lock(&amp;vmlist_lock);</span><br><span class="line"><span class="keyword">for</span> (p = &amp;vmlist ; (tmp = *p) ; p = &amp;tmp-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp-&gt;addr == addr) &#123;</span><br><span class="line">        unmap_vm_area(tmp);</span><br><span class="line">        *p = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">write_unlock(&amp;vmlist_lock);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br></pre></td></tr></table></figure><br>内存区本身通过调用<code>unmap_vm_area()</code>来释放。这个函数接收单个参数，即指向内存区的<code>vm_struct</code>描述符的指针<code>area</code>。它执行下列循环以进行<code>map_vm_area()</code>的反向操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">address = area-&gt;addr;</span><br><span class="line">end = address + area-&gt;size;</span><br><span class="line">pgd = pgd_offset_k(address);</span><br><span class="line"><span class="keyword">for</span> (i = pgd_index(address); i &lt;= pgd_index(end<span class="number">-1</span>); i++) &#123;</span><br><span class="line">    next = (address + PGDIR_SIZE) &amp; PGDIR_MASK;</span><br><span class="line">    <span class="keyword">if</span> (next &lt;= address || next &gt; end)</span><br><span class="line">        next = end;</span><br><span class="line">    unmap_area_pud(pgd, address, next - address);</span><br><span class="line">    address = next;</span><br><span class="line">    pgd++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>unmap_area_pud()</code>依次在循环中执行<code>map_area_pud()</code>的反操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    unmap_area_pmd(pud, address, end-address);</span><br><span class="line">    address = (address + PUD_SIZE) &amp; PUD_MASK;</span><br><span class="line">    pud++;</span><br><span class="line">&#125; <span class="keyword">while</span> (address &amp;&amp; (address &lt; end));</span><br></pre></td></tr></table></figure><br><code>unmap_area_pmd()</code>函数在循环中执行<code>map_area_pmd()</code>的反操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    unmap_area_pte(pmd, address, end-address);</span><br><span class="line">    address = (address + PMD_SIZE) &amp; PMD_MASK;</span><br><span class="line">    pmd++;</span><br><span class="line">&#125; <span class="keyword">while</span> (address &lt; end);</span><br></pre></td></tr></table></figure><br>最后，<code>unmap_area_pte()</code>在循环中执行<code>map_area_pte()</code>的反操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> page = ptep_get_and_clear(pte);</span><br><span class="line">    address += PAGE_SIZE;</span><br><span class="line">    pte++;</span><br><span class="line">    <span class="keyword">if</span> (!pte_none(page) &amp;&amp; !pte_present(page))</span><br><span class="line">        printk(<span class="string">&quot;Whee... Swapped out page in kernel page table/n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (address &lt; end);</span><br></pre></td></tr></table></figure><br>在每次循环过程中，<code>ptep_get_and_clear</code>宏将<code>pte</code>指向的页表项设为0。</p>
<p>与<code>vmalloc()</code>一样，内核修改主内核页全局目录和它的子页表中的相应项，但是映射第4个GB的进程页表的项保持不变。这是在情理之中的，因为内核永远也不会收回扎根于主内核页全局目录中的页上级目录、页中间目录和页表。</p>
<p>例如，假定内核态的进程访问一个随后要释放的非连续内存区。进程的页全局目录项等于主内核页全局目录中的相应项，由于“缺页异常处理程序”博文中所描述的机制，这些目录项指向相同的页上级目录、页中间目录和页表。<code>unmap_area_pte()</code>函数只清除页表中的项（不回收页表本身）。进程对已释放非连续内存区的进一步访问必将由于空的页表项而触发缺页异常。但是，缺页处理程序会认为这样的访问是一个错误，因为主内核页表不包含有效的表项。</p>
<h1 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h1><p>内核中的函数以相当直接了当的方式获得动态内存。当给用户态进程分配内存时，情况完全不同了：</p>
<ul>
<li>进程对动态内存的请求被认为是不紧迫的，一般来说，内核总是尽量推迟给用户态进程分配内存。</li>
<li>由于用户进程时不可信任的，因此，内核必须能随时准备捕获用户态进程引起的所有寻址错误。</li>
</ul>
<p><strong>当用户态进程请求动态内存时，并没有获得请求的页框，而仅仅获得对一个新的线性地址区间的使用权，而这一线性地址区间就成为进程地址空间的一部分</strong>。</p>
<h2 id="进程地址空间-1"><a href="#进程地址空间-1" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p><strong>进程地址空间由允许进程使用的全部线性地址组成</strong>。内核可以通过增加或删除某些线程地址区间来动态地修改进程的地址空间。内核通过所谓线性去得资源来标示线性地址区间，线性区是由起始线性地址、长度和一些访问权限来描述的。进程获得新线性区的一些典型情况：</p>
<ol>
<li>用户在控制台输入一条命令时，shell进程创建一个新的进程去执行这个命令。结果是，一个全新的地址空间（也就是一组线性区）分配给新进程。</li>
<li>正在运行的进程有可能决定装入一个完全不同的程序。这时，进程描述符不变，可是在装入这个程序以前所有的线性区却被释放，并有一组新的线性区被分配给这个进程。</li>
<li>正在运行的进程可能对一个文件执行内存映像。</li>
<li>进程可能持续向他的用户态堆栈增加数据，知道映像这个堆栈的线性区用完为止，此时，内核也许会决定扩展这个线性区的大小。</li>
<li>进程可能创建一个IPC共享线性区来与其他合作进程共享数据。此时，内核给这个进程分配一个新的线性区以实现这个方案。</li>
<li>进程可能通过调用类似malloc这样的函数扩展自己的动态堆。结果是，内核可能决定扩展给这个堆所分配的线性区。</li>
</ol>
<p><img src="/img/1602070972.png" alt=""></p>
<h2 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h2><h3 id="数据结构描述"><a href="#数据结构描述" class="headerlink" title="数据结构描述"></a>数据结构描述</h3><p>进程描述符<code>task_struct</code>中的<code>mm</code>字段描述了进程地址空间：<br><img src="/img/1602070973.png" alt=""></p>
<p>所有内存描述符存放在一个双向链表中，每个描述符在<code>mmlist</code>字段存放相邻元素的地址。链表的每一个元素是<code>init_mm</code>的<code>mmlist</code>字段，<code>init_mm</code>是初始化阶段进程0所使用的内存描述符。<code>mmlist_lock</code>自旋锁保护多处理器系统对链表的同时访问。</p>
<p><code>mm_user</code>字段存放共享<code>mm_struct</code>数据结构的轻量级进程的个数。<code>mm_count</code>字段是内存描述符的主使用计数器，在<code>mm_users</code>次使用计数器中的所有用户在<code>mm_count</code>中只作为一个单位。每当<code>mm_count</code>递减时，内核都要检查它是否变为0，如果是，就要解除这个内存描述符，因为不再有用户使用它。</p>
<p>以下例子解释<code>mm_users</code>和<code>mm_count</code>之间的不同。考虑一个内存描述符由两个轻量级进程共享。它的<code>mm_users</code>字段通常存放的值为2，而<code>mm_count</code>字段存放的值为1(两个所有者进程算作一个)。</p>
<p>如果把内存描述符暂时借给一个内核线程，那么，内核就增加<code>mm_count</code>。这样即两个轻量级进程都死亡，且<code>mm_users</code>字段变为0，这个内存描述符也不被释放，直到内核线程使用完为止，因为mm_count字段仍然大于0。</p>
<p>如果内核想确保内存描述符在一个长操作的中间不被释放，那么就应该增加<code>mm_users</code>字段，而不是<code>mm_count</code>字段的值. 最终的结果是相同的，因为<code>mm_users</code>的增加确保了<code>mm_count</code>来变为0，即使拥有这个内存描述符的所有轻量级进程全部死亡。</p>
<p><code>mm_alloc()</code>函数用来从slab分配器高速缓存中获取一个新的内存描述符。<code>mm_alloc()</code>调用<code>kmem_cache_alloc()</code>来初始化新的内存描述符，并把<code>mm_count</code>和<code>mm_users</code>字段都置为1。<code>mmput()</code>函数递减内存描述符的<code>mm_users</code>字段。如果该字段变为0，这个函数就释放局部描述符表/线性区描述符及由内存描述符所引用的页表，并调用<code>mmdrop()</code>后一个函数把<code>mm_count</code>字段减1，如果该字段变为0，就释放<code>mm_struct</code>数据结构。</p>
<h3 id="内核线程的内存描述符"><a href="#内核线程的内存描述符" class="headerlink" title="内核线程的内存描述符"></a>内核线程的内存描述符</h3><p>内核线程仅运行在内核态，它们永远不会访问<code>TASK_SIZE</code>(等于<code>PAGE_OFFSET</code>，x86下通常为0xC0000000)以下的地址。内核线程不用线性区，因而内存描述符的很多字段对内核线程没有意义。大于<code>TASK_SIZE</code>线性地址的相应页表项都是相同的，因此一个内核线程到底使用什么样的页表集根本没关系。为了避免无用的TLB和高速缓存刷新，内核线程使用一组最近运行的普通进程的页表。进程描述符用<code>mm</code>和<code>active_mm</code>处理此情况。</p>
<p><code>mm</code>字段指向进程所拥有的内存描述符，<code>active_mm</code>字段指向进程运行时所使用的内存描述符。对普通进程而言，这两个字段存放相同的指针。但是，内核线程不拥有内存描述符，因此它们的<code>mm</code>字段总是NULL。内核线程运行时，它的<code>active_mm</code>字段被初始化为前一个运行进程的<code>active_mm</code>值。</p>
<p>内核态的进程为高于<code>TASK_SIZE</code>的线性地址修改页表项，那么它也就应当更新系统中所有进程页表集合中的相应表项。事实上，一旦内核态的一个进程进行了设置。映射应该对内核态的其他所有进程都有效.触及所有进程的页表集合是相当费时的操作，因此，linux采用延迟方式。每当一个高端地址必须被重新映射时，内核就更新根目录在<code>swapper_pg_dir</code>主内存页全局目录中的常规页表集合。这个页全局目录由主内存描述符的<code>pgd</code>字段指向，而主内存描述符存放于<code>init_mm</code>变量。</p>
<h2 id="线性区"><a href="#线性区" class="headerlink" title="线性区"></a>线性区</h2><p>Linux通过<code>vm_area_struct</code>的对象实现线性区：<br><img src="/img/1602070974.png" alt=""></p>
<p>每个线性区描述符表示一个线性地址区间。<code>vm_start</code>字段指向线性区的第一个线性地址，而<code>vm_end</code>字段指向线性区之后的第一个线性地址。<code>vm_end - vm_start</code>表示线性区的长度。<code>vm_mm</code>字段指向拥有这个区间的进程的<code>mm_struct</code>内存描述符。</p>
<p>进程所拥有的线性区从来不重叠，并且内核尽力把新分配的线性区与紧邻的现有线性区进行合并。如果两个线性区的访问权限相匹配，则合并。<br><img src="/img/1602317308.jpg" alt=""></p>
<p><code>vm_ops</code>指向<code>vm_operations_struct</code>结构，存放的是线性区的方法，以下四种方法可应用于UMA系统：<br><img src="/img/1602317388.jpg" alt=""></p>
<p><code>mmap_cache</code>字段保存进程最后一次引用线性区的描述符地址，引用此字段可减少查找一个给定线性地址所在线性区花费的时间。</p>
<h3 id="线性区数据结构"><a href="#线性区数据结构" class="headerlink" title="线性区数据结构"></a>线性区数据结构</h3><p>进程所拥有的所有线性区是通过一个简单的链表链接在一起的。每个<code>vm_area_struct</code>元素的<code>vm_next</code>字段指向链表的下一个元素。内核通过进程的内存描述符的<code>nmap</code>字段来查找线性区，其中<code>nmap</code>字段指向链表中的第一个线性区描述符。内存描述符中的<code>map_count</code>字段存放进程所拥有的线性区数目。默认情况下，一个进程可以最多拥有65536个不同的线性区。</p>
<p>进程地址空间、内存描述符和线性区链表之间的关系：<br><img src="/img/1602317489.jpg" alt=""></p>
<p>内核频繁执行的一个操作是查找包含指定线性地址的线性区。只要在指定线性地址之后找到一个线性区，搜索就可以结束。多数Linux的线性区非常少，但是如果线性区过于庞大，线性区链表的管理会变得非常低效。</p>
<p>Linux2.6把内存描述符存放在叫做<strong>红黑树</strong>（read-black-tree）的数据结构中。每个元素（或说节点）通常有两个孩子：左孩子和右孩子。树中的元素被排序。对关键字为N的节点，它的左子树上的所有元素的关键字都比N小；相反，它的右子树上的所有元素的关键字都比N大；节点的关键字被写入节点内部。而除了具有基本的二叉排序树的特点以外，红-黑树必须满足下列5条规则：</p>
<ol>
<li>每个节点必须或为黑或为红。</li>
<li>树的根必须为黑。</li>
<li>红节点的孩子必须为黑。</li>
<li>从一个节点到后代叶子节点的每个路径都包含相同数量的黑节点。当统计黑节点个数时，空指针也算作黑节点。</li>
</ol>
<p><img src="/img/1602427094.jpg" alt=""></p>
<p>这4条规则确保具有n个内部节点的任何红一黑树其高度最多为<code>2 × log(n+1)</code>。在红-黑树中搜索一个元素因此而变得非常高效，因为其操作的执行时间与树大小的对数成线性比例。换句话说，双倍的线性区个数只多增加一次循环。</p>
<p>为了存放进程的线性区，Linux既使用了链表，又使用了红黑树。这两种结构包含指向同一线性区描述符的指针，当插入或删除一个线性区描述符的时候，内核通过红黑树搜索前后元素，并用搜索结果快速更新链表而不用扫描链表。链表的头由内存描述符的<code>mmap</code>字段所指向，任何线性区对象都在<code>vm_next</code>字段存放指向链表下一个元素的指针。红黑树的首部由<code>mm_rb</code>字段所指向，任何线性区对象都在类型为<code>rb_node</code>的<code>vm_rb</code>字段存放节点颜色以及指向双亲、左孩子和右孩子的指针。</p>
<p>一般的，红黑树用来确定含有指定地址的线性区，而链表通常在扫描整个线性区集合时使用。</p>
<h3 id="线性区访问权限"><a href="#线性区访问权限" class="headerlink" title="线性区访问权限"></a>线性区访问权限</h3><p>每个线性区都由一组号码连续的页组成。线性区的大小是4KB的倍数（必须包含完整的页），而栈的大小却是任意的。与页相关的几种标志：</p>
<ul>
<li>在每个页表项中存放的几个标志，如<code>Read/Write</code>、<code>Present</code>或<code>User/Supervisor</code></li>
<li>存放在每个页描述符flags字段的一组</li>
</ul>
<p>第一种标志由80x86硬件用来检查能否执行所请求的寻址类型，第二种则由Linux用于许多不同目的，第三种则被存放在<code>vm_area_struct</code>描述符的<code>vm_flags</code>字段中。一些标志给内核提供关于这个线性区的全部页信息。<br><img src="/img/1602070975.png" alt=""></p>
<p><strong>线性区描述符所包含的页访问权限可以任意组合</strong>。例如，存在这样一种可能性，允许一个线性区中的页可以执行但是不可以读取。为了有效地实现这种保护方案，与线性区的页相关的访问权限（读、写及执行）必须被复制到相应的所有表项中，以便由分页单元直接执行检查。换句话说，<strong>页访问权限表示何种类型的访问应该产生一个缺页异常</strong>。Linux委派缺页处理程序查找导致缺页的原因，因为缺页处理程序实现了许多页处理策略。</p>
<p>页表标志的初值存放在<code>vm_area_struct</code>描述符的<code>vm_page_prot</code>字段中。当增加一个页时，内核根据<code>vm_page_prot</code>字段的值设置相应页表项中的标志。</p>
<p>然而，并不能把线性区的访问权限直接转换为页保护位：</p>
<ul>
<li>在某些情况下，即使由相应线性区描述符的<code>vm_flags</code>字段所指定的某个页的访问权限允许对该页进行访问，但是，对该页的访问还是应当产生一个缺页异常。例如“写时复制”的情况，内核可能决定把属于两个不同进程的两个完全一样的可写私有页（它的<code>VM_SHARE</code>标志被清0）存入同一个页框中；在这种情况下，无论哪一个进程试图改动这个页都应当产生一个异常。</li>
<li>80x86处理器的页表仅有两个保护位，即<code>Read</code>/<code>Write</code>和<code>User</code>/<code>Supervisor</code>标志。此外，一个线性区所包含的任何一个页的<code>User</code>/<code>Supervisor</code>标志必须总置为1，因为用户态进程必须总能够访问其中的页。</li>
<li>启用PAE的新近Intel Pentium 4微处理器，在所有64位页表项中支持NX（No eXecute）标志。</li>
</ul>
<p>如果内核没有被编译成支持PAE，那么Linux采取以下规则以克服80x86微处理器的硬件限制：</p>
<ul>
<li>读访问权限总是隐含着执行访问权限，反之亦然。</li>
<li>写访问权限总是隐含着读访问权限。</li>
</ul>
<p>反之，如果内核被编译成支持PAE，而且CPU有NX标志，Linux就采取不同的规则：</p>
<ul>
<li>行访问权限总是隐含着读访问权限。</li>
<li>访问权限总是隐含着读访问权限。</li>
</ul>
<p>此外，为了能做到“写时复制”中适当推迟页框的分配，只要相应的页不是由多个进程共享，那么这种页框都是写保护的。因此，要根据以下规则精简由读、写、执行和共享访问权限的16种可能组合：</p>
<ul>
<li>如果页具有写和共享两种访问权限，那么，<code>Read</code>/<code>Write</code>位被设置为1。</li>
<li>如果页具有读或执行访问权限，但是既没有写也没有共享访问权限，那么，<code>Read</code>/<code>Write</code>位被清0。</li>
<li>如果支持NX位，而且页没有执行访问权限，那么，把NX位设置为1。</li>
<li>如果页没有任何访问权限，那么，<code>Present</code>位被清0，以便每次访问都产生一个缺页异常。然而，为了把这种情况与真正的页框不存在的情况相区分，Linux还把<code>Page size</code>位置为1</li>
</ul>
<p>访问权限的每种组合所对应的精简后的保护位存放在<code>protection_map</code>数组的16个元素中（<code>mm/Mmap.c</code>）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pgprot_t</span> protection_map[<span class="number">16</span>] = &#123;</span><br><span class="line"> __P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,</span><br><span class="line"> __S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//include/asm-i386/Pgtable.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P000 PAGE_NONE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P001 PAGE_READONLY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P010 PAGE_COPY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P011 PAGE_COPY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P100 PAGE_READONLY_EXEC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P101 PAGE_READONLY_EXEC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P110 PAGE_COPY_EXEC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P111 PAGE_COPY_EXEC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __S000 PAGE_NONE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __S001 PAGE_READONLY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __S010 PAGE_SHARED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __S011 PAGE_SHARED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __S100 PAGE_READONLY_EXEC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __S101 PAGE_READONLY_EXEC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __S110 PAGE_SHARED_EXEC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __S111 PAGE_SHARED_EXEC</span></span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COPY_EXEC /</span></span><br><span class="line"> __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)</span><br></pre></td></tr></table></figure></p>
<h3 id="线性区的处理"><a href="#线性区的处理" class="headerlink" title="线性区的处理"></a>线性区的处理</h3><p>对线性区描述符进行操作的低层函数应当被看作简化了<code>do_map()</code>和<code>do_unmap()</code>实现的辅助函数。这两个函数分别<strong>扩大或者缩小进程的地址空间</strong>。这两个函数所处的层次比我们这里所考虑函数的层次要高一些，它们并不接受线性区描述符作为参数，而是使用一个线性地址区间的起始地址、长度和访问限权作为参数。</p>
<h4 id="查找给定地址的最邻近区"><a href="#查找给定地址的最邻近区" class="headerlink" title="查找给定地址的最邻近区"></a>查找给定地址的最邻近区</h4><p><code>find_vma()</code>函数有两个参数：<strong>进程内存描述符的地址mm</strong>和<strong>线性地址addr</strong>，查找线性区的<code>vm_end</code>字段大于<code>addr</code>的第一个线性区的位置，并返回这个线性区描述符的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vm_area_struct * <span class="title function_">find_vma</span><span class="params">(<span class="keyword">struct</span> mm_struct * mm, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">    <span class="comment">/* Check the cache first. */</span></span><br><span class="line">    <span class="comment">/* (Cache hit rate is typically around 35%.) */</span></span><br><span class="line">        vma = mm-&gt;mmap_cache;</span><br><span class="line">        <span class="keyword">if</span> (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> * <span class="title">rb_node</span>;</span></span><br><span class="line"></span><br><span class="line">            rb_node = mm-&gt;mm_rb.rb_node;</span><br><span class="line">            vma = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (rb_node) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vma_tmp</span>;</span></span><br><span class="line"></span><br><span class="line">                vma_tmp = rb_entry(rb_node,</span><br><span class="line">                <span class="keyword">struct</span> vm_area_struct, vm_rb);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;</span><br><span class="line">                    vma = vma_tmp;</span><br><span class="line">                    <span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    rb_node = rb_node-&gt;rb_left;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    rb_node = rb_node-&gt;rb_right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vma)</span><br><span class="line">                mm-&gt;mmap_cache = vma;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由<code>find_vma()</code>函数所选择的线性区并不一定要包含<code>addr</code>，也就是说<code>vm_end</code>可能会小于<code>addr</code>，因为<code>addr</code>可能位于任何线性区之外，这时候我们就要新建一个线性区对象，但不是在<code>find_vma</code>函数中创建，<code>find_vma</code>函数仅返回<code>mm-&gt;mmap_cache</code>，也就是当前的那个<code>vma</code>结构。</p>
<p>每个内存描述符包含一个<code>mmap_cache</code>字段，这个字段保存进程最后一次引用线性区的描述符地址。引进这个附加的字段是为了<strong>减少查找一个给定线性地址所在线性区而花费的时间</strong>。程序中引用地址的局部性使下面这种情况出现的可能性很大：<strong>如果检查的最后一个线性地址属于某一给定的线性区，那么，下一个要检查的线性地址也属于这一个线性区</strong>。</p>
<p>因此，该函数一开始就检查由<code>mmap_cache</code>所指定的线性区是否包含<code>addr</code>（<code>vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr</code>）。如果是，就返回这个线性区描述符的指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vma = mm-&gt;mmap_cache;</span><br><span class="line"><span class="keyword">if</span> (vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br></pre></td></tr></table></figure></p>
<p>否则，必须扫描进程的线性区，红-黑树算法就用到了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rb_node = mm-&gt;mm_rb.rb_node;</span><br><span class="line">vma = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (rb_node) &#123;</span><br><span class="line">    vma_tmp = rb_entry(rb_node, <span class="keyword">struct</span> vm_area_struct, vm_rb);</span><br><span class="line">    <span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;</span><br><span class="line">        vma = vma_tmp;</span><br><span class="line">        <span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        rb_node = rb_node-&gt;rb_left;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        rb_node = rb_node-&gt;rb_right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数使用的宏<code>rb_entry</code>，从指向红-黑树中一个节点的指针导出相应线性区描述符的地址：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rb_entry(ptr, type, member) container_of(ptr, type, member)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;   /</span></span><br><span class="line">        <span class="type">const</span> <span class="title function_">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr = (ptr); /</span><br><span class="line">        (type *)( (<span class="type">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure></p>
<p>那么，根据上面的代码，翻译过来就是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vma_tmp = (&#123; <span class="keyword">typeof</span>( ((vm_area_struct *)<span class="number">0</span>)-&gt;vm_rb ) *__mptr = (rb_node); /</span><br><span class="line">        (type *)( (<span class="type">char</span> *)__mptr - ((<span class="type">size_t</span>) &amp;((vm_area_struct *)<span class="number">0</span>)-&gt;vm_rb) );&#125;)</span><br></pre></td></tr></table></figure></p>
<p>第一行<code>typeof( ((vm_area_struct *)0)-&gt;vm_rb )</code>得到vm_rb的类型，即指向顶地址0的那个<code>vm_area_struct</code>结构<code>vm_rb</code>字段的那个类型，即<code>rb_node</code>类型，把他用一个临时变量<code>__mptr</code>表示，其值为函数类的临时变量<code>rb_node</code>，所以<code>*__mptr</code>就是临时变量<code>rb_node</code>的真实地址值。那么第二行用这个<code>*__mptr</code>减去<code>vm_rb</code>成员相对于<code>vm_area_struct</code>顶部的偏移值，就得到了其宿主的<code>vm_area_struct</code>的地址的真实值，即最后得出对应的线性区<code>vm_area_struct</code>的地址。</p>
<p>函数<code>find_vma_prev()</code>与<code>find_vma()</code>类似，不同的是它把函数选中的前一个线性区描述符的指针赋给附加参数的结果参数pprev。最后，函数<code>find_vma_prepare()</code>确定新叶子节点在与给定线性地址对应的红-黑树中的位置，并返回前一个线性区的地址和要插入的叶子节点的父节点的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *</span><br><span class="line"><span class="title function_">find_vma_prepare</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> vm_area_struct **pprev, <span class="keyword">struct</span> rb_node ***rb_link,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> rb_node ** rb_parent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vma</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> ** __<span class="title">rb_link</span>, * __<span class="title">rb_parent</span>, * <span class="title">rb_prev</span>;</span></span><br><span class="line"></span><br><span class="line">    __rb_link = &amp;mm-&gt;mm_rb.rb_node;</span><br><span class="line">    rb_prev = __rb_parent = <span class="literal">NULL</span>;</span><br><span class="line">    vma = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*__rb_link) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma_tmp</span>;</span></span><br><span class="line"></span><br><span class="line">        __rb_parent = *__rb_link;</span><br><span class="line">        vma_tmp = rb_entry(__rb_parent, <span class="keyword">struct</span> vm_area_struct, vm_rb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;</span><br><span class="line">            vma = vma_tmp;</span><br><span class="line">            <span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)</span><br><span class="line">                <span class="keyword">return</span> vma;</span><br><span class="line">            __rb_link = &amp;__rb_parent-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rb_prev = __rb_parent;</span><br><span class="line">            __rb_link = &amp;__rb_parent-&gt;rb_right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pprev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (rb_prev)</span><br><span class="line">        *pprev = rb_entry(rb_prev, <span class="keyword">struct</span> vm_area_struct, vm_rb);</span><br><span class="line">    *rb_link = __rb_link;</span><br><span class="line">    *rb_parent = __rb_parent;</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="查找一个与给定的地址区间相重叠的线性区"><a href="#查找一个与给定的地址区间相重叠的线性区" class="headerlink" title="查找一个与给定的地址区间相重叠的线性区"></a>查找一个与给定的地址区间相重叠的线性区</h4><p><code>find_vma_intersection()</code>函数<strong>查找与给定的线性地址区间相重叠的第一个线性区</strong>。<code>mm</code>参数指向<strong>进程的内存描述符</strong>，而线性地址<code>start_addr</code>和<code>end_addr</code>指定这个区间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> vm_area_struct * <span class="title function_">find_vma_intersection</span><span class="params">(<span class="keyword">struct</span> mm_struct * mm, <span class="type">unsigned</span> <span class="type">long</span> start_addr, <span class="type">unsigned</span> <span class="type">long</span> end_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vma</span> =</span> find_vma(mm,start_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vma &amp;&amp; end_addr &lt;= vma-&gt;vm_start)</span><br><span class="line">        vma = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有这样的线性区存在，函数就返回一个NULL指针。准确地说，如果<code>find_vma()</code>函数回一个有效的地址，但是所找到的线性区是从这个线性地址区间的末尾开始的，vma就被置为NULL。</p>
<h4 id="查找一个空闲的地址区间"><a href="#查找一个空闲的地址区间" class="headerlink" title="查找一个空闲的地址区间"></a>查找一个空闲的地址区间</h4><p><code>get_unmapped_area()</code>查找进程的地址空间以找到一个可以使用的线性地址区间。<code>len</code>参数指定区间的长度，<code>addr</code>指定必须从哪个地址开始查找。查找成功则返回这个新区间的地址；否则返回错误码<code>-ENOMEM</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_unmapped_area</span><span class="params">(<span class="keyword">struct</span> file * file, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br></pre></td></tr></table></figure></p>
<p>如果参数<code>addr</code>不等于NULL，函数就检查所指定的地址是否在用户态空间（<code>if (addr &gt; TASK_SIZE - len)</code>）并与页边界对齐（<code>if (addr &amp; ~PAGE_MASK)</code>）。接下来，函数根据线性地址区间是否应该用于文件内存映射或匿名内存映射，调用两个方法（<code>get_unmapped_area</code>文件操作<code>file-&gt;f_op-&gt;get_unmapped_area</code>和内存描述符的<code>get_unmapped_area</code>方法<code>current-&gt;mm-&gt;get_unmapped_area(file, addr, len, pgoff, flags)</code>）中的一个。在前一种情况下，函数执行<code>get_unmapped_area</code>文件操作。</p>
<p>第二种情况下，函数执行内存描述符的<code>get_unmapped_area</code>方法。根据进程的线性区类型，由函数<code>arch_get_unmapped_area()</code>或<code>arch_get_unmapped_area_topdown()</code>实现<code>get_unmapped_area</code>方法。通过系统调用<code>mmap()</code>，每个进程都可能获得两种不同形式的线性区：一种从线性地址0x40000000（1G）开始并向高端地址增长，即所谓的“堆”；另一种正好从用户态堆栈开始并向低端地址增长，即所谓的“栈”。前者就调用<code>arch_get_unmapped_area</code>函数，后者就会调用<code>arch_get_unmapped_area_topdown</code>函数，后面博文会详细讨论。</p>
<p>现在我们讨论函数<code>arch_get_unmapped_area()</code>，在分配从低端地址向高端地址移动的线性区时使用这个函数。它本质上等价于下面的代码片段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &gt; TASK_SIZE)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">addr = (addr + <span class="number">0xfff</span>) &amp; <span class="number">0xfffff000</span>;</span><br><span class="line"><span class="keyword">if</span> (addr &amp;&amp; addr + len &lt;= TASK_SIZE) &#123;</span><br><span class="line">    vma = find_vma(current-&gt;mm, addr);</span><br><span class="line">    <span class="keyword">if</span> (!vma || addr + len &lt;= vma-&gt;vm_start)</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line">start_addr = addr = mm-&gt;free_area_cache;</span><br><span class="line"><span class="keyword">for</span> (vma = find_vma(current-&gt;mm, addr); ; vma = vma-&gt;vm_next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addr + len &gt; TASK_SIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start_addr == (TASK_SIZE/<span class="number">3</span>+<span class="number">0xfff</span>)&amp;<span class="number">0xfffff000</span>)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        start_addr = addr = (TASK_SIZE/<span class="number">3</span>+<span class="number">0xfff</span>)&amp;<span class="number">0xfffff000</span>;</span><br><span class="line">        vma = find_vma(current-&gt;mm, addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!vma || addr + len &lt;= vma-&gt;vm_start) &#123;</span><br><span class="line">        mm-&gt;free_area_cache = addr + len;</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">    addr = vma-&gt;vm_end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数首先检查区间的长度是否在用户态下线性地址区间的限长<code>TASK_SIZE</code>（通常为3GB）之内。如果<code>addr</code>不为0，函数就试图从<code>addr</code>开始分配区间。为了安全起见，函数把<code>addr</code>的值调整为4KB的倍数（<code>addr = (addr + 0xfff) &amp; 0xfffff000</code>）。</p>
<p>如果<code>addr</code>等于0或前面的搜索失败，函数<code>arch_get_unmapped_area()</code>就<strong>扫描用户态线性地址空间以查找一个可以包含新区的足够大的线性地址范围</strong>，但任何已有的线性区都不包括这个地址范围。为了提高搜索的速度，让搜索从最近被分配的线性区后面的线性地址开始（<code>vma = find_vma(current-&gt;mm, addr)</code>）。</p>
<p>把内存描述符的字段<code>mm-&gt;free_area_cache</code>初始化为用户态线性地址空间的三分之一（通常是1GB，<code>start_addr = addr = (TASK_SIZE/3+0xfff)&amp;0xfffff000</code>），并在以后创建新线性区时对它进行更新。如果函数找不到一个合适的线性地址范围，就从用户态线性地址空间的三分之一的开始处重新开始搜索：其实，用户态线性地址空间的三分之一是为有预定义起始线性地址的线性区（典型的是可执行文件的正文段、数据段和bss段）而保留的。</p>
<p>函数调用<code>find_vma()</code>以确定搜索起点之后第一个线性区终点的位置。可能出现三种情况：</p>
<ul>
<li>如果所请求的区间大于正待扫描的线性地址空间部分（<code>addr + len &gt; TASK-SIZE</code>），函数就从用户态地址空间的三分之一处重新开始搜索，如果已经完成第二次搜索，就返回-ENOMEM（没有足够的线性地址空间来满足这个请求）。</li>
<li>刚刚扫描过的线性区后面的空闲区没有足够的大小（<code>vma !＝ NULL &amp;&amp; vma-&gt;vm_start &lt; addr + len</code>）。此时，继续考虑下一个线性区。</li>
<li>如果以上两种情况都没有发生，则找到一个足够大的空闲区，此时，函数返回addr。</li>
</ul>
<h4 id="向内存描述符链表中插入一个线性区"><a href="#向内存描述符链表中插入一个线性区" class="headerlink" title="向内存描述符链表中插入一个线性区"></a>向内存描述符链表中插入一个线性区</h4><p><code>insert_vm_struct()</code>函数在线性区对象链表和内存描述符的红-黑树中插入一个<code>vm_area_struct</code>结构。这个函数使用两个参数：<code>mm</code><strong>指定进程内存描述符的地址</strong>，<code>vmp</code><strong>指定要插入的<code>vm_area_struct</code>对象的地址</strong>。线性区对象的<code>vm_start</code>和<code>vm_end</code>字段必定已经初始化过。</p>
<p>该函数调用<code>find_vma_prepare()</code>在红-黑树<code>mm-&gt;mm_rb</code>中查找<code>vma</code>应该位于何处：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insert_vm_struct</span><span class="params">(<span class="keyword">struct</span> mm_struct * mm, <span class="keyword">struct</span> vm_area_struct * vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * __<span class="title">vma</span>, * <span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> ** <span class="title">rb_link</span>, * <span class="title">rb_parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!vma-&gt;vm_file) &#123;</span><br><span class="line">        BUG_ON(vma-&gt;anon_vma);</span><br><span class="line">        vma-&gt;vm_pgoff = vma-&gt;vm_start &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    __vma = find_vma_prepare(mm,vma-&gt;vm_start,&amp;prev,&amp;rb_link,&amp;rb_parent);</span><br><span class="line">    <span class="keyword">if</span> (__vma &amp;&amp; __vma-&gt;vm_start &lt; vma-&gt;vm_end)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *</span><br><span class="line"><span class="title function_">find_vma_prepare</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> vm_area_struct **pprev, <span class="keyword">struct</span> rb_node ***rb_link,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> rb_node ** rb_parent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vma</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> ** __<span class="title">rb_link</span>, * __<span class="title">rb_parent</span>, * <span class="title">rb_prev</span>;</span></span><br><span class="line"></span><br><span class="line">     __rb_link = &amp;mm-&gt;mm_rb.rb_node;</span><br><span class="line">    rb_prev = __rb_parent = <span class="literal">NULL</span>;    <span class="comment">/* rb_prev内部变量表示vma的前一个vm_area_struct结构在树中的位置 */</span></span><br><span class="line">    vma = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*__rb_link) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma_tmp</span>;</span></span><br><span class="line"></span><br><span class="line">        __rb_parent = *__rb_link;</span><br><span class="line">        vma_tmp = rb_entry(__rb_parent, <span class="keyword">struct</span> vm_area_struct, vm_rb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;</span><br><span class="line">            vma = vma_tmp;</span><br><span class="line">            <span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)</span><br><span class="line">                <span class="keyword">return</span> vma;</span><br><span class="line">            __rb_link = &amp;__rb_parent-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rb_prev = __rb_parent;</span><br><span class="line">            __rb_link = &amp;__rb_parent-&gt;rb_right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pprev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (rb_prev)</span><br><span class="line">        *pprev = rb_entry(rb_prev, <span class="keyword">struct</span> vm_area_struct, vm_rb);</span><br><span class="line">    *rb_link = __rb_link;</span><br><span class="line">    *rb_parent = __rb_parent;</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，<code>insert_vm_struct()</code>又调用<code>vma_link()</code>函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vma_link</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> vm_area_struct *prev, <span class="keyword">struct</span> rb_node **rb_link,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> rb_node *rb_parent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_file)</span><br><span class="line">        mapping = vma-&gt;vm_file-&gt;f_mapping;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mapping) &#123;</span><br><span class="line">        spin_lock(&amp;mapping-&gt;i_mmap_lock);</span><br><span class="line">        vma-&gt;vm_truncate_count = mapping-&gt;truncate_count;</span><br><span class="line">    &#125;</span><br><span class="line">    anon_vma_lock(vma);</span><br><span class="line"></span><br><span class="line">    __vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">    __vma_link_file(vma);</span><br><span class="line"></span><br><span class="line">    anon_vma_unlock(vma);</span><br><span class="line">    <span class="keyword">if</span> (mapping)</span><br><span class="line">        spin_unlock(&amp;mapping-&gt;i_mmap_lock);</span><br><span class="line"></span><br><span class="line">    mm-&gt;map_count++;</span><br><span class="line">    validate_mm(mm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__vma_link(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span><br><span class="line"> <span class="keyword">struct</span> vm_area_struct *prev, <span class="keyword">struct</span> rb_node **rb_link,</span><br><span class="line"> <span class="keyword">struct</span> rb_node *rb_parent)</span><br><span class="line">&#123;</span><br><span class="line">    __vma_link_list(mm, vma, prev, rb_parent);</span><br><span class="line">    __vma_link_rb(mm, vma, rb_link, rb_parent);</span><br><span class="line">    __anon_vma_link(vma);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>vma_link</code>依次执行以下操作：</p>
<ol>
<li>在<code>mm-&gt;mmap</code>所指向的链表中插入线性区</li>
<li>在红-黑树mm-&gt;mm_rb中插入线性区</li>
<li>如果线性区是匿名的，就把它插入以相应的<code>anon_vma</code>数据结构作为头节点的链表中（__anon_vma_link(vma)）。</li>
<li>递增<code>mm-&gt;map_count</code>计数器（<code>mm-&gt;map_count++;</code>）。</li>
</ol>
<p>如果线性区包含一个内存映射文件，则<code>vma_link()</code>函数执行在回收页框相关博文描述的其他任务。</p>
<p><code>__vma_unlink()</code>函数接收的参数为一个内存描述符地址mm和两个线性区对象地址vma和prev。两个线性区都应当属于mm，prev应当在线性区的排序中位于vma之前。该函数从内存描述符链表和红-黑树中删除vma，如果<code>mm-&gt;mmap_cache</code>（存放刚被引用的线性区）字段指向刚被删除的线性区，则还要对<code>mm-&gt;mmap_cache</code>进行更新。</p>
<h2 id="分配线性地址空间"><a href="#分配线性地址空间" class="headerlink" title="分配线性地址空间"></a>分配线性地址空间</h2><p><code>do_mmap()</code>函数<strong>为当前进程创建并初始化一个新的线性区</strong>。不过分配成功之后，可以把这个新的线性区与进程已有的其他线性区合并。函数相关参数：</p>
<ul>
<li><code>file</code>和<code>offset</code>：如果新的线性区将把一个文件映射到内存，则使用文件描述符指针和文件偏移量<code>offset</code>。</li>
<li><code>addr</code>：这个线性地址指定从何时开始查找一个空闲的区间。</li>
<li><code>len</code>：线性地址区间的长度。</li>
<li><code>prot</code>：这个参数指定这个线性区所包含页的访问权限。</li>
<li><p><code>flag</code>：这个参数指定线性区的其他标志。</p>
<ul>
<li><code>MAP_GROWSDOWN</code>、<code>MAP_LOCKED</code>、<code>MAP_DENYWRITE</code>和<code>MAP_EXECUTABLE</code><ul>
<li>它们的含义与“线性区数据结构”博文中所列出标志的含义相同。</li>
</ul>
</li>
<li><code>MAP_SHARED</code>和<code>MAP_PRIVATE</code><ul>
<li>前一个标志指定线性区中的页可以被几个进程共享；后一个标志作用和两个标志都指向vm_area_struct描述符中的VM_SHARED标志。</li>
</ul>
</li>
<li><code>MAX_FIXED</code><ul>
<li>区间的起始地址必须是由参数addr所指定的。</li>
</ul>
</li>
<li><code>MAX_ANONYMOUS</code><ul>
<li>没有文件与这个线性区相关联。</li>
</ul>
</li>
<li><code>MAP_NORESERVE</code><ul>
<li>函数不必预先检查空闲页框的数目。</li>
</ul>
</li>
<li><code>MAP_POPULATE</code><ul>
<li>函数应该为线性区建立的映射提前分配需要的页框。该标志仅对映射文件的线性区和IPC共享的线性区有意义。</li>
</ul>
</li>
<li><code>MAX_NONBLOCK</code><ul>
<li>只有在<code>MAP_POPULATE</code>标志置位时才有意义：提前分配页框时，函数肯定不阻塞。</li>
</ul>
</li>
</ul>
<p>我们看到<code>do_mmap()</code>函数对offset的值进行一些初步检查，然后执行<code>do_mmap_pgoff()</code>函数。这里假设新的线性地址区间映射的不是磁盘文件，仅对实现匿名线性区的<code>do_mmap_pgoff()</code>函数进行说明（mm/Mmap.c）：</p>
</li>
<li>首先检查参数的值是否正确，所提的请求是否能被满足。尤其是要检查以下不能满足请求的条件：<ul>
<li>线性地址区间的长度为0或者包含的地址大于<code>TASK_SIZE</code></li>
<li>进程已经映射了过多的线性区，<code>mm</code>内存描述符的<code>map_count</code>字段的值超过了允许的最大值</li>
<li><code>flag</code>指定新线性地址区间的页必须被锁在RAM中，但不允许创建上锁的线性区，或者进程加锁页的总数超过了保存在进程描述符<code>signal-&gt;rlim[RLIMIT_MEMLOCK].rlim_cur</code>字段中的阈值</li>
<li>以上任意一个成立则<code>do_mmap_pgoff()</code>终止并返回一个负值</li>
</ul>
</li>
<li>执行内存描述符的<code>get_unmapped_area()</code>方法</li>
<li>通过把存放在prot和flags参数中的值进行组合来计算新线性区描述符的标志<ul>
<li>只有在prot中设置了相应的<code>PROT_READ</code>、<code>PROT_WRITE</code>和<code>PROT_EXEC</code>标志，<code>calc_vm_prot_bits()</code>函数才在<code>vm_flags</code>中设置<code>VM_READ</code>，<code>VM_WRITE</code>和<code>VM_EXEC</code>标志；只有在flags设置了相应的<code>MAP_GROWSDOWN</code>，<code>MAP_DENYWRITE</code>，<code>MAP_EXECUTABLE</code>和<code>MAP_LOCKED</code>标志，<code>calc_vm_flag_bits()</code>也才在<code>VM_flags</code>中设置<code>VM_GROWSDOWN</code>、<code>VM_DENYWRITE</code>、<code>VM_EXECUTABLE</code>和<code>VM_LOCKED</code>标志。在<code>vm_flags</code>中还有几个标志被置为1：<code>VM_MAYREAD</code>、<code>VM_MAYWRITE</code>、<code>VM_MAYEXEC</code>，在<code>mm-&gt;def_flags</code>中所有线性区的默认标志，以及如果线性区的页与其他进程共享时的<code>VM_SHARED</code>和<code>VM_MAYSHARE</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |</span><br><span class="line">  mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; MAP_LOCKED) &#123;</span><br><span class="line"> <span class="keyword">if</span> (!can_do_mlock())</span><br><span class="line">  <span class="keyword">return</span> -EPERM;</span><br><span class="line"> vm_flags |= VM_LOCKED;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用<code>find_vma_prepare()</code>确定处于新区间之前的线性区对象的位置，以及在红-黑树中新线性区的位置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vma = find_vma_prepare(mm, addr, &amp;prev, &amp;rb_link, &amp;rb_parent);</span><br><span class="line"><span class="keyword">if</span> (!vma || vma-&gt;vm_start &gt;= addr + len) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (do_munmap(mm, addr, len))</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>检查插是否还存在与新区间重叠的线性区，这种情况发生在函数返回一个非空的地址，这个地址指向一个线性区，而该区的起始位置位于新区间结束地址之前的时候。这时<code>do_mmap_pgoff()</code>调用<code>do_munmap()</code>删除新的区间。</li>
<li>检查新的线性区是否引起进程地址空间的大小<code>(mm-&gt;total_vm&lt;&lt;PAGE_SHIFT) + len</code>超过存放在进程描述符<code>signal-&gt;rlim[RLIMIT_AS].rlim_cur</code>字段中的阈值。<ul>
<li>如果是，就返回出错码-ENOMEM。注意，这个检查只在这里进行，而不在前面与其他检查一起进行，</li>
<li>因为一些线性区可能在刚才调用<code>do_munmap()</code>时候被删除。</li>
</ul>
</li>
<li>如果在flags参数中没有设置<code>MAP_NORESERVE</code>标志，新的线性区包含私有可写页，并且没有足够的空闲页框，则返回出错码-ENOMEM；这最后一个检查是由<code>security_vm_enough_memory()</code>函数实现的。</li>
<li>如果新区间是私有的（没有设置<code>VM_SHARED</code>），且映射的不是磁盘上的一个文件，那么，调用<code>vma_merge()</code>检查前一个线性区是否可以以这样的方式进行扩展来包含新的区间。<ul>
<li>当然，前一个线性区必须与在vm_flags局部变量中存放标志的那些线性区具有完全相同的标志。</li>
<li>如果前一个线性区可以扩展，那么，<code>vma_merge()</code>也试图把它与随后的线性区进行合并（这发生在新区间填充两个线性区之间的空洞，且三个线性区全部具有相同的标志的时候）。</li>
<li>万一在扩展前一个线性区时获得成功，则跳到12步。</li>
</ul>
</li>
<li>调用slab分配函数<code>kmem_cache_alloc()</code>为新的线性区分配一个<code>vm_area_struct</code>数据结构</li>
<li>初始化新的线性区对象（由vma指向）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vma-&gt;vm_mm = mm;</span><br><span class="line">vma-&gt;vm_start = addr;</span><br><span class="line">vma-&gt;vm_end = addr + len;</span><br><span class="line">vma-&gt;vm_flags = vm_flags;</span><br><span class="line">vma-&gt;vm_page_prot = protection_map[vm_flags &amp; (VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)];</span><br><span class="line">vma-&gt;vm_pgoff = pgoff;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果<code>MAP_SHARED</code>标志被设置（以及新的线性区不映射磁盘上的文件），则该线性区是一个共享匿名区：<ul>
<li>调用<code>shmem_zero_setup()</code>对它进行初始化。共享匿名区主要用于进程间通信。</li>
</ul>
</li>
<li>调用<code>vma_link()</code>把新线性区插人到线性区链表和红-黑树中</li>
<li>增加存放在内存描述符total_vm字段中的进程地址空间的大小</li>
<li>如果设置了<code>VM_LOCKED</code>标志，就调用<code>make_pages_present()</code>连续分配线性区的所有页，并把它们锁在RAM中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mm-&gt;locked_vm += len &gt;&gt; PAGE_SHIFT;</span><br><span class="line">make_pages_present(addr, addr + len);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>make_pages_present()</code>函数按如下方式调用<code>get_user_pages()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write = (vma-&gt;vm_flags &amp; VM_WRITE) != <span class="number">0</span>;</span><br><span class="line">get_user_pages(current, current-&gt;mm, addr, len, write, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>get_user_pages()</code>函数在<code>addr</code>和<code>addr+len</code>之间页的所有起始线性地址上循环；</p>
<ul>
<li>对于其中的每个页，该函数调用<code>follow_page()</code>检查在当前页表中是否有到物理页的映射。</li>
<li>如果没有这样的物理页存在，则<code>get_user_pages()</code>调用<code>handle_mm_fault()</code>。</li>
<li>以后我们会看到，后一个函数分配一个页框并根据内存描述符的vm_flags字段设置它的页表项。</li>
</ul>
</li>
<li>最后，函数通过返回新线性区的线性地址而终止。 </li>
</ul>
<h4 id="释放线性地址区间"><a href="#释放线性地址区间" class="headerlink" title="释放线性地址区间"></a>释放线性地址区间</h4><p>内核使用<code>do_munmap()</code>函数从当前进程的地址空间中删除一个线性地址区间。参数<code>mm</code>为进程内存描述符的地址，<code>start</code>地址区间的起始地址，<code>len</code>长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_munmap(<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">size_t</span> len)    <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>该函数主要两个阶段：</p>
<ul>
<li>第一阶段，扫描进程所拥有的线性区链表，并把包含在进程地址空间的线性地址区间中的所有线性区从链表中解除链接。</li>
<li>第二阶段，更新进程的页表，并把第一阶段找到并标识出的线性区删除。函数利用后面要说明的<code>spilt_vma()</code>和<code>unmap_region()</code>函数。</li>
</ul>
<p><code>do_munmap()</code>执行下边的步骤：</p>
<ul>
<li>参数值进行一些初步检查：如果线性地址区间所含的地址大于<code>TASK_SIZE</code>，如start不是4096的倍数，或者如果线性地址区间的长度为0，则函数返回一个错误代码-EINVAL。</li>
<li>确定要删除的线性地址区间之后第一个线性区结构<code>vma</code>的位置（<code>mpnt-&gt;end &gt; start</code>)，如果有这样的线性区：<code>mpnt = find_vma_prev(mm, start, &amp;prev);</code></li>
<li>如果没有这样的线性区，也没有与线性地址区间重叠的线性区，就什么都不做，因为该线性地址区间上没有线性区：</li>
<li>如果线性区的起始地址在线性区<code>vma</code>内，就调用<code>split_vma()</code>把线性区<code>vma</code>划分成两个较小的区：一个区在线性地址区间外部，而另一个在区间内部。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (start &gt; vma-&gt;vm_start) &#123;</span><br><span class="line"> <span class="type">int</span> error = split_vma(mm, vma, start, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (error)</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line"> prev = vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>更新局部变量prev，以前它存储的是指向线性区vma前面一个线性区的指针，现在要让它指向vma，即指向线性地址区间外部的那个新线性区。这样，prev仍然指向要删除的第一个线性区前面的那个线性区。</li>
<li>如果线性地址区间的结束地址在一个线性区内部，就再次调用<code>split_vma()</code>把最后重叠的那个线性区划分成两个较小的区：一个区在线性地址区间内部，而另一个在区间外部。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">last = find_vma(mm, end);</span><br><span class="line"><span class="keyword">if</span> (last &amp;&amp; end &gt; last-&gt;vm_start) &#123;</span><br><span class="line"> <span class="type">int</span> error = split_vma(mm, last, end, <span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span> (error)</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果线性地址区间正好包含在某个线性区内部，就必须用用个较小的新线性区取代该线性区。当发生这种情况时，在第4步和第5步把该线性区分成三个较小的线性区：删除中间的那个线性区，而保留第一个和最后一个线性区。</li>
<li>更新<code>mpnt</code>的值，使它指向线性地址区间的第一个线性区。如果<code>prev</code>为NULL，即没有上述线性区，就从<code>mm-&gt;mmap</code>获得第一个线性区的地址：<code>mpnt = prev? prev-&gt;vm_next: mm-&gt;mmap;</code></li>
<li>调用<code>detach_vmas_to_be_unmapped()</code>从进程的线性地址空间中删除位于线性地址区间中的线性区。<ul>
<li>要删除的线性区的描述符放在一个排好序的链表中，</li>
<li>局部变量mpnt指向该链表的头（实际上，这个链表只是进程初始线性区链表的一部分）。</li>
</ul>
</li>
<li>获得<code>mm-&gt;page_table_lock</code>自旋锁</li>
<li>调用<code>unmap_region()</code>清除与线性地址区间对应的页表项并释放相应的页框：<code>unmap_region(mm, vma, prev, start, end);</code></li>
<li>释放<code>mm-&gt;page_table_lock</code>自旋锁</li>
<li>释放建立链表时收集的线性区描述符<ul>
<li>对在链表中的所有线性区调用<code>unmap_vma()</code>函数，本质上：<ul>
<li>更新<code>mm-&gt;total_vm</code>和<code>mm-&gt;locked_vm</code>字段</li>
<li>执行内存描述符的<code>mm-&gt;unmap_area</code>方法，根据进程线性区的不同类型选择<code>arch_unmap_area()</code>或<code>arch_unmap_area_topdown()</code>中的一个来实现<code>mm-&gt;unmap_area</code>方法</li>
<li>调用线性区的<code>close</code>方法</li>
<li>如果线性区是匿名的，则函数把它从<code>mm-&gt;anon_vma</code>所指向的匿名线性区链表中删除</li>
<li>调用<code>kmem_cache_free()</code>释放线性区描述符</li>
</ul>
</li>
</ul>
</li>
<li>返回成功</li>
</ul>
<h4 id="split-vma-函数"><a href="#split-vma-函数" class="headerlink" title="split_vma()函数"></a>split_vma()函数</h4><p><code>split_vma()</code>函数<strong>把与线性地址区间交叉的线性区划分成两个较小的区，一个在线性地址区间外部，另一个在区间的内部</strong>。该函数接收4个参数：<strong>内存描述符指针</strong><code>mm</code>，<strong>线性区描述符指针</strong><code>vma</code>（标识要被划分的线性区），<strong>表示区间与线性区之间交叉点的地址</strong><code>addr</code>，以及<strong>表示区间与线性区之间交叉点在区间起始处还是结束处的标志</strong><code>new_below</code>。我们来看看该函数的代码：</p>
<ul>
<li>调用<code>kmem_cache_alloc()</code>获得一个新的线性区描述符<code>vm_area_struct</code>，并把它的地址存放在新的局部变量中new，如果没有可用的空闲空间，就返回-ENOMEM。</li>
<li>用<code>vma</code>描述符的字段值初始化新描述符的字段。</li>
<li>如果<code>new_below</code>标志等于1，说明线性地址区间的结束地址在vma线性区的内部，因此必须把新线性区放在vma线性区的前面，所以函数把字段<code>new-&gt;vm_end</code>和<code>vma-&gt;vm_start</code>都赋值为addr。</li>
<li>相反，<code>new_below</code>为0，说明线性地址区间的起始地址在vma线性区的内部，因此必须把新线性区放在<code>vma</code>线性区之后，所以函数把<code>new-&gt;vm_start</code>和<code>vma-&gt;vm_end</code>字段都赋值为<code>addr</code>。</li>
<li>如果定义了新线性区的open方法，函数就执行它。</li>
<li>根据<code>new_below</code>的值调用<code>vma_adjust</code>函数把新线性区描述符链接到线性区链表<code>mm-&gt;mmap</code>和红-黑树<code>mm-&gt;mm_rb</code>。此外，<code>vma_adjust</code>函数还要根据线性区vma的最新大小对红-黑树进行调整。</li>
</ul>
<h4 id="unmap-region-函数"><a href="#unmap-region-函数" class="headerlink" title="unmap_region()函数"></a>unmap_region()函数</h4><p>unmap_region()函数遍历线性区链表并释放它们的页框，该函数有五个参数：</p>
<ul>
<li>内存描述符指针<code>mm</code></li>
<li>指向第一个被删除线性区描述符的指针<code>vma</code></li>
<li>指向进程链表中<code>vma</code>前面的线性区的指针<code>prev</code></li>
<li><p>界定被删除线性地址区间的范围的两个地址<code>start</code>和<code>end</code></p>
</li>
<li><p>调用<code>lru_add_drain()</code></p>
</li>
<li>调用<code>tlb_gather_mmu()</code>函数初始化每CPU变量<code>mmu_gathers</code>。<code>mmu_gathers</code>的值依赖于CPU体系结构：通常该变量应该存放成功更新进程页表项所需要的所有信息。在80x86体系结构中，<code>tlb_gather_mmu()</code>函数只是简单地把内存描述符指针<code>mm</code>的值赋给本地CPU的<code>mmu_gathers</code>变量。</li>
<li>把<code>mmu_gathers</code>变量的地址保存在局部变量<code>tlb</code>中。</li>
<li>调用<code>unmap_vmas()</code>扫描线性地址空间的所有页表项：如果只有一个有效CPU，函数就调用<code>free_swap_and_cache()</code>反复释放相应的页（页面回收中会提到）；否则，函数就把相应页描述符的指针保存在局部变量<code>mmu_gathers</code>中。</li>
<li>调用<code>free_pgtables(tlb, prev, start, end)</code>回收在上一步已经清空的进程页表。</li>
<li>调用<code>tlb_finish_mmu(tlb, start, end)</code>结束<code>unmap_region()</code>函数的工作，<code>tlb_finish_mmu(tlb, start, end)</code>依次执行下面的操作：<ul>
<li>调用<code>flush_tlb_mm()</code>刷新TLB。</li>
<li>在多处理器系统中，调用<code>freepages_and_swap_cache()</code>释放页框，这些页框的指针已经集中存放在<code>mmu_gather</code>数据结构中了。</li>
</ul>
</li>
</ul>
<h2 id="缺页异常处理程序"><a href="#缺页异常处理程序" class="headerlink" title="缺页异常处理程序"></a>缺页异常处理程序</h2><p>Linux的缺页（Page Fault）异常处理程序必须区分一下两种情况：</p>
<ul>
<li>由编程错误引起的异常</li>
<li>由引用属于进程地址空间还尚未分配物理页框的页所引起的异常。</li>
</ul>
<p>线性描述符可以让缺页异常处理程序非常有效的完成它的工作。<code>do_page_fault()</code>函数是80x86上的缺页中断服务程序，它把引起缺页的线性地址和当前进程的线性区相比较，从而能够选择适当的方法处理异常。<br><img src="/img/1602591966.jpg" alt=""></p>
<p>详细流程如图所示，图中标识<code>good_area</code>、<code>bad_area</code>和<code>no_context</code>等是出现在<code>do_page_fault()</code>中的标记，它们有助于你理清流程图中的块与代码中特定行之间的关系：<br><img src="/img/1602592050.jpg" alt=""></p>
<p><code>do_page_fault()</code>函数接收以下输入参数：</p>
<ul>
<li><code>pt_regs</code>结构的地址<code>regs</code>，该结构包含当异常发生时的微处理器寄存器的值。</li>
<li>3位的<code>error_code</code>，当异常发生时由控制单元压入栈中。这些位有以下含义：<ul>
<li>如果第0位被清0，则异常由访问一个不存在的页所引起（页表项中的Present标志被清0）；否则，如果第0位被设置，则异常由无效的访问权限所引起。</li>
<li>如果第1位被清0，则异常由读访问或者执行访问所引起；如果该位被设置，则异常由写访问所引起。</li>
<li>如果第2位被清0，则异常发生在处理器处于内核态时；否则，异常发生在处理器处于用户态时。</li>
</ul>
</li>
</ul>
<p><code>do_page_fault()</code>的第一步操作是<strong>读取引起缺页的b线性地址b</strong>（<code>address = read_cr2();</code>）。当异常发生时，CPU控制单元把这个值存放在cr2控制寄存器中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> read_cr2() (&#123; /</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> __dummy; /</span><br><span class="line"> __asm__ __volatile__( /</span><br><span class="line">  <span class="string">&quot;movl %%cr2,%0/n/t&quot;</span> /</span><br><span class="line">  :<span class="string">&quot;=r&quot;</span> (__dummy)); /</span><br><span class="line"> __dummy; /</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>函数将这个线性地址保存在address局部变量中，并把指向<code>current</code>进程描述符的指针保存在tsk局部变量中（<code>tsk = current;</code>）。</p>
<p>函数首先检查引起缺页的线性地址是否属于内核空间，即是否是第3GB~4GB之间：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">si_code = SEGV_MAPERR;</span><br><span class="line"><span class="keyword">if</span> (unlikely(address &gt;= TASK_SIZE)) &#123; <span class="comment">/* 0xd = 1101 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(error_code &amp; <span class="number">0x0000000d</span>) &amp;&amp; vmalloc_fault(address) &gt;= <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (notify_page_fault(DIE_PAGE_FAULT, <span class="string">&quot;page fault&quot;</span>, regs, error_code, <span class="number">14</span>,</span><br><span class="line">        SIGSEGV) == NOTIFY_STOP)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">goto</span> bad_area_nosemaphore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果发生了由于内核试图访问不存在的页框引起的异常，就去执行<code>vmalloc_fault(address)</code>函数，该部分代码处理可能由于在内核态访问非连续内存区而引起的缺页，否则就跳转去执行<code>bad_area_nosemaphore</code>标记处的代码。接下来缺页处理程序检查异常发生时内核是否正在执行一些关键例程或运行内核线程。如果缺页发生在下面任何一种情况，则<code>in_atomic()</code>产生等于1的值。</p>
<ul>
<li>内核正在执行中断处理程序或可延迟函数。</li>
<li>内核正在禁用内核抢占的情况下执行临界区代码。</li>
</ul>
<p>如果缺页的确发生在中断处理程序、可延迟函数、临界区或内核线程中，<code>do_page_fault()</code>就不会试图把这个线性地址与<code>current</code>的线性区做比较。再一个，内核线程从来不使用小于<code>TASK_SIZE</code>的地址。同样，中断处理程序、可延迟函数和临界区代码也不应该使用小于<code>TASK_SIZE</code>的地址，因为这可能导致当前进程的阻塞。</p>
<p>现在，让我们假定缺页没有发生在中断处理程序、可延迟函数、临界区或者内核线程中。于是函数必须检查进程所拥有的线性区以决定引起缺页的线性地址是否包含在进程的地址空间中，为此必须获得进程的mmap_sem读/写信号量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!down_read_trylock(&amp;mm-&gt;mmap_sem)) &#123;</span><br><span class="line"> <span class="keyword">if</span> ((error_code &amp; <span class="number">4</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">     !search_exception_tables(regs-&gt;eip))</span><br><span class="line">  <span class="keyword">goto</span> bad_area_nosemaphore;</span><br><span class="line"> down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果内核bug和硬件故障有可能被排除，那么当缺页发生时，当前进程就不会有为写而获得信号量<code>mmap_sem</code>。尽管如此，<code>do_page_fault()</code>还是想确定的确没有获得这个信号量，因为如果不是这样就会发生死锁。所以，函数使用<code>down_read_trylock()</code>而不是<code>down_read()</code>。</p>
<p>如果这个信号量被关闭而且缺页发生在内核态(<code>error_code &amp; 4</code>)，<code>do_page_fault()</code>就要确定异常发生的时候，是否正在使用作为系统调用参数被传递给内核的线性地址。此时，因为每个系统调用服务例程都小心地避免在访问用户态地址空间以前为写而获得mmap_sem信号量，所以<code>do_page_fault()</code>确信mmap_sem信号量由另外一个进程占有了（<code>!search_exception_tables(regs-&gt;eip)</code>），从而<code>do_page_fault(</code>)一直等待直到该信号量被释放（<code>down_read(&amp;mm-&gt;mmap_sem)</code>）。否则，如果缺页是由于内核bug或严重的硬件故障引起的，函数就跳转到<code>bad_area_nosemaphore</code>标记处。</p>
<p>我们假设已经为读而获得了<code>mmap_sem</code>信号量。现在，<code>do_page_fault()</code>开始搜索错误线性地址所在的线性区：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vma = find_vma(mm, address);</span><br><span class="line"><span class="keyword">if</span> (!vma)</span><br><span class="line">    <span class="keyword">goto</span> bad_area;</span><br><span class="line"><span class="keyword">if</span> (vma-&gt;vm_start &lt;= address)</span><br><span class="line">    <span class="keyword">goto</span> good_area;</span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))</span><br><span class="line">    <span class="keyword">goto</span> bad_area;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>vma</code>为NULL，说明<code>address</code>之后没有线性区，因此这个错误的地址肯定是无效的。另一方面，如果在<code>address</code>之后结束处的第一个线性区包含<code>address</code>，则函数跳到标记为<code>good_area</code>的代码处。</p>
<p>如果两个“if”条件都不满足，则函数就确定address没有包含在任何线性区中，但内部变量vma指向当前进程的mm_struct的mmap_cache指向的那个vm_area_struct。函数就执行进一步的检查，由于这个错误地址可能是由push或pusha指令在进程的用户态堆栈上的操作所引起的。</p>
<p>我们稍微离题一点，解释一下栈是如何映射到线性区上的。每个向低地址扩展的栈所在的区，它的<code>VM_GROWSDOWN</code>标志被设置，这样，当<code>vm_start</code>字段的值可能被减小的时候，而<code>vm_end</code>字段的值保持不变。这种线性区的边界包括、但不严格限定用户态堆栈当前的大小。这种细微的差别主要基于以下原因：</p>
<ul>
<li>线性区的大小是4KB的倍数（必须包含完整的页），而栈的大小却是任意的。</li>
<li>分配给一个线性区的页框在这个线性区被删除前永远不被释放。尤其是，一个栈所在线性区的<code>vm_start</code>字段的值只能减小，永远也不能增加。甚至进程执行一系列的pop指令时，这个线性区的大小仍然保持不变。</li>
</ul>
<p>现在这一点就很清楚了，当进程填满分配给它的堆栈的最后一个页框后，进程如何引起一个“缺页”异常——<strong>push引用了这个线性区以外的一个地址</strong>（即引用一个不存在的页框）。注意，这种异常不是由程序错误引起的，因此它必须由缺页处理程序单独处理。</p>
<p><code>do_page_fault()</code>它检查上面所描述的情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))</span><br><span class="line">    <span class="keyword">goto</span> bad_area;</span><br><span class="line"><span class="keyword">if</span> (error_code &amp; <span class="number">4</span> &amp;&amp; address + <span class="number">32</span> &lt; regs-&gt;esp)</span><br><span class="line">   <span class="keyword">goto</span> bad_area;</span><br><span class="line"><span class="keyword">if</span> (expand_stack(vma, address))</span><br><span class="line">  <span class="keyword">goto</span> bad_area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果线性区的<code>VM_GROWSDOWN</code>标志被设置，并且异常发生在用户态，函数就要检查<code>address</code>是否小于<code>regs-&gt;esp</code>栈指针的值（它应该只小于一点点）。因为几个与栈相关的汇编语言指令只有在访问内存之后才执行减esp寄存器的操作，所以允许进程有32字节的后备区间。如果这个地址足够高，则代码调用<code>espand_stack()</code>函数检查是否允许进程既扩展它的栈也扩展它的地址空间。如果一切都可以，<code>expand_stack</code>就把<code>vma</code>的<code>vm_start</code>字段设为<code>address</code>，并返回0；否则，<code>expand_stack</code>返回-ENOMEM。</p>
<p>注意：只要线性区的<code>VM_GROWSDOWN</code>标志被设置，但异常不是发生在用户态，上述代码就跳过容错检查。这些条件意味着内核正在访问用户态的栈，也意味着这段代码总是应当运行<code>expand_stack()</code>。</p>
<h3 id="处理地址空间以外的错误地址"><a href="#处理地址空间以外的错误地址" class="headerlink" title="处理地址空间以外的错误地址"></a>处理地址空间以外的错误地址</h3><p>如果address不属于进程的地址空间，那么<code>do_page_fault()</code>函数执行<code>bad_area</code>标记处的语句，如果错误在用户态，则发送一个SIGSEGV信号给current进程并结束函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bad_area:</span><br><span class="line">    up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line">bad_area_nosemaphore:</span><br><span class="line"><span class="keyword">if</span> (error_code &amp; <span class="number">4</span>) &#123;</span><br><span class="line">    tsk-&gt;thread.cr2 = address;</span><br><span class="line">    tsk-&gt;thread.error_code = error_code | (address &gt;= TASK_SIZE);</span><br><span class="line">    tsk-&gt;thread.trap_no = <span class="number">14</span>;</span><br><span class="line">    info.si_signo = SIGSEGV;</span><br><span class="line">    info.si_errno = <span class="number">0</span>;</span><br><span class="line">    info.si_addr = (<span class="type">void</span>*)address;</span><br><span class="line">    force_sig_info_fault(SIGSEGV, si_code, address, tsk);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>force_sig_info_fault()</code>函数确信进程不忽略或阻塞SIGSEGV信号，并通过info局部变量传递附加信息的同时把该信号发送给用户态进程。<code>info.si_code</code>变量已被置为<code>SEGV_MAPERR</code>（如果异常是由于一个不存在的页框引起），或置为<code>SEGV_ACCERR</code>（如果异常是由于对现有页框的无效访问引起）。</p>
<p>如果异常发生在内核态，仍然有两种可选的情况：</p>
<ul>
<li>异常的引起是由于把某个线性地址作为系统调用的参数传递给内核。</li>
<li>异常是因一个真正的内核缺陷所引起的。</li>
</ul>
<p>函数这样区分这两种可选的情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">no_context:</span><br><span class="line"><span class="keyword">if</span> ((fixup = search_exception_table(regs-&gt;eip)) != <span class="number">0</span>)</span><br><span class="line">    regs-&gt;eip = fixup;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在第一种情况中，代码跳到一段“修正代码”处，这段代码的典型操作就是向当前进程发送SIGSEGV信号，或用一个适当的出错码终止系统调用处理程序。</p>
<p>在第二种情况中，函数把CPU寄存器和内核态堆栈的全部转储打印到控制台，并输出到一个系统消息缓冲区，然后调用函数<code>do_exit()</code>杀死当前进程。这就是所谓按所显示的消息命名的<strong>内核漏洞（Kernel oops）</strong>错误。</p>
<h3 id="处理地址空间内的错误地址"><a href="#处理地址空间内的错误地址" class="headerlink" title="处理地址空间内的错误地址"></a>处理地址空间内的错误地址</h3><p>如果<code>addr</code>地址属于进程的地址空间，则<code>do_page_fault()</code>转到<code>good_area</code>标记处执行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">good_area:</span><br><span class="line">    info.si_code = SEGV_ACCERR;</span><br><span class="line">    write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(error_code &amp; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">            <span class="keyword">goto</span> bad_area;</span><br><span class="line">        write++;</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">if</span> ((error_code &amp; <span class="number">1</span>) || !(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC)))</span><br><span class="line">    <span class="keyword">goto</span> bad_area;</span><br></pre></td></tr></table></figure></p>
<p>如果异常由写访问引起，函数检查这个线性区是否可写（<code>!(vma-&gt;vm_flags &amp; VM_WRITE)</code>）。如果不可写，跳到<code>bad_area</code>代码处；如果可写，把<code>write</code>局部变量置为1。</p>
<p>如果异常由读或执行访问引起，函数检查这一页是否已经存在于RAM中。在存在的情况下，异常发生是由于进程试图访问用户态下的一个有特权的页框（页框的<code>User/Supervisor</code>标志被清除），因此函数跳到<code>bad_area</code>代码处（然而，这种情况从不会发生，因为内核不会把具有特权的页框贼给进程。）。在不存在的情况下（<code>error_code &amp; 3 = 0</code>），函数还将检查这个线性区是否可读或可执行。</p>
<p>如果这个线性区的访问权限与引起异常的访问类型相匹配，则调用<code>handle_mm_fault()</code>函数分配一个新的页框：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">survive:</span><br><span class="line">ret = handle_mm_fault(tsk-&gt;mm, vma, address, write);</span><br><span class="line"><span class="keyword">if</span> (ret == VM_FAULT_MINOR || ret == VM_FAULT_MAJOR) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ret == VM_FAULT_MINOR)</span><br><span class="line">        tsk-&gt;min_flt ++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tsk-&gt;maj_flt++;</span><br><span class="line">    up_read(&amp;tsk-&gt;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>handle_mm_fault()</code>函数成功地给进程分配一个页框，则返回<code>VM_FAULT_MINOR</code>或<code>VM_FAULT_MAJOR</code>。值<code>VM_FAULT_MINOR</code>表示在没有阻塞当前进程的情况下处理了缺页；这种缺页叫做<strong>次缺页</strong>（minor fault）。值<code>VM_FAULT_MAJOR</code>表示缺页迫使当前进程睡眠（很可能是由于当用磁盘上的数据填充所分配的页框时花费时间）；阻塞当前进程的缺页就叫做<strong>主缺页</strong>（major fault）。函数也返回<code>VM_FAULT_OOM</code>（没有足够的内存）或<code>VM_FAULT_STGBOS</code>（其他任何错误）。</p>
<p>如果<code>handle_mm_fault()</code>返回值<code>VM_FAULT_SIGBUS</code>，则向进程发送SIGBUS信号：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ret == VM_FAULT_SIGBUS) &#123;</span><br><span class="line"></span><br><span class="line">do_sigbus:</span><br><span class="line">    up_read(&amp;tsk-&gt;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="keyword">if</span> (!(error_code &amp; <span class="number">4</span>))</span><br><span class="line">        <span class="keyword">goto</span> no_context;</span><br><span class="line">    tsk-&gt;thread.cr2 = address;</span><br><span class="line">    tsk-&gt;thread.error_code = error_code;</span><br><span class="line">    tsk-&gt;thread.trap_no = <span class="number">14</span>;</span><br><span class="line">    info.si_signo = SIGBUS;</span><br><span class="line">    info.si_errno = <span class="number">0</span>;</span><br><span class="line">    info.si_code = BUS_ADRESS;</span><br><span class="line">    info.si_addr = (<span class="type">void</span>*)address;</span><br><span class="line">    force_sig_info_fault(SIGBUS, &amp;info, tsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>handle_mm_fault()</code>不分配新的页框，就返回值<code>VM_FAULT_OOM</code>，此时内核通常杀死当前进程，不过，如果当前进程是init进程（<code>tsk-&gt;pid == 1</code>），则只是把它放在运行队列的末尾并调用调度程序；一旦init恢复执行，则又去执行<code>handle_mm_fault()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ret == VM_FAULT_OOM) &#123;</span><br><span class="line"></span><br><span class="line">out_of_memory:</span><br><span class="line">    up_read(&amp;tsk-&gt;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;pid == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(error_code &amp; <span class="number">4</span>)</span><br><span class="line">            do_exit(SIGKILL);</span><br><span class="line">        <span class="keyword">goto</span> no_context;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">    down_read(&amp;tsk-&gt;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="keyword">goto</span> survive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>handle_mm_fault()</code>函数作用于4个参数：</p>
<ul>
<li><code>mm</code>：指向异常发生时正在CPU上运行的进程的内存描述符。</li>
<li><code>vma</code>：指向引起异常的线性地址所在线性区的描述符。</li>
<li><code>address</code>：引起异常的线性地址。</li>
<li><code>write_access</code>：如果tsk试图向address写，则置为1；如果<code>tsk</code>试图在address读或执行，则置为0。</li>
</ul>
<p>这个函数会检查用来映射address的页中间目录和页表是否存在：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pud)</span><br><span class="line"><span class="keyword">if</span> (!pmd)</span><br><span class="line"><span class="keyword">if</span> (!pte)</span><br></pre></td></tr></table></figure></p>
<p>即使address属于进程的地址空间，相应的页表也可能还没有被分配，因此，在做别的事情之前首先执行分配页目录和页表的任务：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pud = pud_alloc(mm, pgd, address);</span><br><span class="line">pmd = pmd_alloc(mm, pud, address);</span><br><span class="line">pte = pte_alloc_map(mm, pmd, address);</span><br></pre></td></tr></table></figure></p>
<p><code>pgd</code>局部变量包含引用address的页全局目录项。如果需要的话，调用<code>pud_alloc()</code>和<code>pmd_alloc()</code>函数分别分配一个新的页上级目录和页中间目录（在80x86微处理器中，这种分配永远不会发生，因为页上级目录总是包含在页全局目录中，并且页中间目录或者包含在页上级目录中（PAE未激活），或者与页上级目录一块被分配（PAE被激活））。然后，如果需要的话调用的<code>pte_alloc_map()</code>函数会分配一个新的页表。</p>
<p>如果以上两步都成功，pte局部变量所指向的页表项就是引用address的表项。然后调用<code>handle_pte_fault()</code>函数检查address地址所对应的页表项，并决定如何为进程分配一个新页框：</p>
<ol>
<li>如果被访问的页不存在，也就是说，这个页还没有被存放在任何一个页框中，那么，内核分配一个新的页框并适当地初始化。这种技术称为<strong>请求调页</strong>（demand paging）。</li>
<li>如果被访问的页存在但是标记为只读，也就是说，它已经被存放在一个页框中，那么，内核分配一个新的页框，并把旧页框的数据拷贝到新页框来初始化它的内容。这种技术称为<strong>写时复制</strong>（Copy On Write，COW）。</li>
</ol>
<h2 id="请求调页"><a href="#请求调页" class="headerlink" title="请求调页"></a>请求调页</h2><p>术语<strong>请求调页</strong>指的是一种动态内存分配技术，<strong>它把页框的分配推迟到不能再推迟位置</strong>，也就是说，一直推迟到进程要访问的页不在RAM中时位置，由此引起一个缺页异常。</p>
<p>请求调页技术背后的动机是：进程开始运行的时候并不访问其地址空间中的全部地址；事实上，有一部分地址也许永远不被进程使用。对于全局分配来说，请求调页是首选的，因为它增加了系统中空闲页框的平均数，从而更好地利用空闲内存。从另一个观点来看，在RAM总体保持不变的情况下，请求调页从总体上能使系统有更大的吞吐量。</p>
<p>被访问的页可能不在主存中，其原因或者是<strong>进程从没访问过该页</strong>，或者是<strong>内核已经回收了相应的页框</strong>。在这两种情况下，缺页处理程序必须为进程分配新的页框。不过，如何初始化这个页框取决于是哪一种页以及页以前是否被进程访问过。特殊情况下：</p>
<ol>
<li><strong>这个页从未被进程访问到且没有映射磁盘文件，或者页映射了磁盘文件</strong>。内核能够识别这些情况，它根据页表相应的表项被填充为0，也就是说，<code>pte_none</code>宏返回1。</li>
<li><strong>页属于非线性磁盘文件的映射</strong>。内核能够识别这种情况，因为<code>Present</code>标志被清0而且<code>Dirty</code>标志被置1，也就是说，<code>pte_file</code>宏返回1。</li>
<li><strong>进程已经访问过这个页，但是其内容被临时保存在磁盘上</strong>。内核能够识别这种情况，这是因为相应表项没被填充为0，但是<code>Present</code>和<code>Dirty</code>标志被清0。</li>
</ol>
<p>因此，<code>handle_pte_fault()</code>函数通过检查<code>address</code>对应的页表项能够区分三种情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">handle_pte_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> vm_area_struct * vma, <span class="type">unsigned</span> <span class="type">long</span> address,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> write_access, <span class="type">pte_t</span> *pte, <span class="type">pmd_t</span> *pmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pte_t</span> entry;</span><br><span class="line"></span><br><span class="line">    entry = *pte;</span><br><span class="line">    <span class="keyword">if</span> (!pte_present(entry)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pte_none(entry))</span><br><span class="line">            <span class="keyword">return</span> do_no_page(mm, vma, address, write_access, pte, pmd);</span><br><span class="line">        <span class="keyword">if</span> (pte_file(entry))</span><br><span class="line">            <span class="keyword">return</span> do_file_page(mm, vma, address, write_access, pte, pmd);</span><br><span class="line">        <span class="keyword">return</span> do_swap_page(mm, vma, address, pte, pmd, entry, write_access);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在第一种情况下，当页从未被访问或页线性地映射磁盘文件时则调用<code>do_no_page()</code>函数。通过检查<code>vma</code>线性区描述符的<code>nopage</code>确定这个页是否被映射到一个磁盘文件：</p>
<ul>
<li><code>vma-&gt;vm_ops-&gt;nopage</code>不为NULL，线性区映射了一个磁盘文件，<code>nopage</code>字段指向装入页的函数。</li>
<li><code>vma-&gt;vm_ops</code>为NULL，或者<code>vma-&gt;vm_ops-&gt;nopage</code>为NULL，线性区没有映射文件，它是一个<strong>匿名映射</strong>。因此<code>do_no_page()</code>调用<code>do_anonymous_page()</code>获得一个新的页框。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_anonymous_page</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pte_t</span> *page_table, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> write_access)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> *ptl;</span><br><span class="line">    <span class="type">pte_t</span> entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write_access) &#123;</span><br><span class="line">        pte_unmap(page_table);</span><br><span class="line">        spin_unlock(&amp;mm-&gt;page_table_lock);</span><br><span class="line">        page = alloc_page(GFP_HIGHUSER | __GFP_ZERO);</span><br><span class="line">        spin_lock(&amp;mm-&gt;page_table_lock);</span><br><span class="line">        page_table = pte_offset_map(pmd, addr);</span><br><span class="line">        mm-&gt;rss ++;</span><br><span class="line"></span><br><span class="line">        entry = maybe_mkwrite(pte_mkdirty(mk_pte(page, vma-&gt;vm_page_prot)), vma);</span><br><span class="line">        lru_cache_add_active(page);</span><br><span class="line">        SetPageReference(page);</span><br><span class="line">        set_pte(page_table, entry);</span><br><span class="line">        pte_unmap(page_table);</span><br><span class="line">        spin_unlock(&amp;mm-&gt;page_table_lock);</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_MINOR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pte_unmap</code>宏的第一次执行释放一种临时内核映射，这种映射了在调用<code>handle_pte_fault()</code>函数之前由<code>pte_offset_map</code>宏所建立页表项的高端内存物理地址。<code>pte_offset_map</code>和<code>pte_unmap</code>这对宏获取和释放同一个临时内核映射。临时内核映射必须在调用<code>alloc_zeroed_user_highpage</code>，本质上也就是<code>alloc_page()</code>之前释放，因为这个函数可能会阻塞当前进程。</p>
<p>函数递增内存描述符的rss字段以记录分配给进程的页框总数。相应的页表项设置为页框的物理地址，页表框被标记为既脏又可写的。<code>lru_cache_add_active()</code>函数把新页框插入与交换相关的数据结构中。</p>
<p>相反，当处理读访问时，即<code>write_access</code>为0，页的内容是无关紧要的，因为进程第一次对它访问。<strong>给进程一个填充为0的页要比给它一个由其他进程填充了信息的旧页更为安全</strong>。Linux在请求调页方面做得更深入一些。没有必要立即给进程分配一个填充为0的新页框，由于我们也可以给它一个现有的称为<strong>零页</strong>（zero page）的页，这样可以进一步推迟页框的分配。零页在内核初始化期间被静态分配，并存放在<code>empty_zero_page</code>变量中（长为4096字节的数组，并用0填充）。</p>
<h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><p>第一代Unix系统实现了一种傻瓜式的进程创建：当发出<code>fork()</code>系统调用时，内核原样复制父进程的整个地址空间并把复制的那一份分配给子进程。这种行为非常耗时，因为它需要：</p>
<ul>
<li>为子进程的页表分配页框</li>
<li>为子进程的页分配页框</li>
<li>初始化子进程的页表</li>
<li>把父进程的页复制到子进程相应的页中</li>
</ul>
<p><strong>写时复制</strong>（Copy On Write，COW）的思想相当简单：<strong>父进程和子进程共享页框而不是复制页框</strong>。然后只要页框被共享，它们就不能被修改。无论父进程还是子进程何时试图写一个共享的页框，就产生一个异常，这是内核就把这个页复制到一个新的页框中并标记可写。原来的页框仍然是写保护的：当其他进程试图写入时，内核检查写进程是否是这个页框的唯一属主，如果是，就把这个页框标记为对这个进程可写。</p>
<p>页描述符的<code>_count</code>字段用于跟踪共享相应页框的进程数目。只要进程释放一个页框或者在它上面执行写时复制，它的<code>_count</code>字段就减小；只有当<code>_count</code>变为-1时，这个页框才被释放。</p>
<p><code>handle_pte_fault()</code>函数确定缺页异常是由访问内存中现有的一个页而引起时：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(pte_present(entry)) &#123;</span><br><span class="line">    if (write_access) &#123;</span><br><span class="line">        if (!pte_write(entry))</span><br><span class="line">            return do_wp_page(mm, vma, address, pte, pmd, ptl, entry);</span><br><span class="line">            entry = pte_mkdirty(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    entry = pte_mkyoung(entry);</span><br><span class="line">    set_pte(pte,entry);</span><br><span class="line">    flush_tlb_page(vma, address);</span><br><span class="line">    pte_unmap(pte);</span><br><span class="line">    spin_unlock(&amp;mm-&gt;page_table_lock);</span><br><span class="line">    return VM_FAULT_MINOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>handle_pte_fault()</code>函数是与体系结构无关的：它考虑任何违背页访问权限的可能。然而，在80x86体系结构上，如果页是存在的，那么，访问权限是写允许的(write_access=1)而页框是写保护的（参见前面“处理地址空间内的错误地址”一博）。因此，总是要调用<code>do_wp_page()</code>函数。</p>
<p><code>do_wp_page()</code>函数首先获取与缺页异常相关的页框描述符：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">old_page = vm_normal_page(vma, address, orig_pte);</span><br></pre></td></tr></table></figure></p>
<p>接下来，函数确定页的复制是否真正必要。如果仅有一个进程拥有这个页，那么，写时复制就不必应用，且该进程应当自由地写该页。具体来说，函数读取页描述符的<code>_count</code>字段：如果它等于0（只有一个所有者），写时复制就不必进行。</p>
<p>实际上，检查要稍微复杂些，因为当页插入到交换高速缓存（并且当设置了页描述符的<code>PG_private</code>标志时，<code>_count</code>字段也增加。不过，当写时复制不进行时，就把该页框标记为可写的，以免试图写时引起进一步的缺页异常：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_pte(page_table, maybe_mkwrite(pte_mkyoung(pte_mkdirty(pte)),vma));</span><br><span class="line">flush_tlb_page(vma, address);</span><br><span class="line">pte_unmap(page_table);</span><br><span class="line">spin_unlock(&amp;mm-&gt;page_table_lock);</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_MINOR;</span><br></pre></td></tr></table></figure></p>
<p>如果两个或多个进程通过写时复制共享页框，那么函数就把旧页框（old page）的内容复制到新分配的页框(new page)中。为了避免竞争条件，在开始复制操作前调用<code>get_page()</code>把<code>old_page</code>的使用计数加1：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">old_page = pte_page(pte);</span><br><span class="line">pte_unmap(page_table);</span><br><span class="line">get_page(old_page);</span><br><span class="line">spin_unlock(&amp;mm-&gt;page_table_lock);</span><br><span class="line"><span class="keyword">if</span> (old_page == virt_to_page(empty_zero_page))</span><br><span class="line">    new_page = alloc_page(GFP_HIGHUSER | _ _GFP_ZERO);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    new_page = alloc_page(GFP_HIGHUSER);</span><br><span class="line">    vfrom = kmap_atomic(old_page, KM_USER0)</span><br><span class="line">    vto = kmap_atomic(new_page, KM_USER1);</span><br><span class="line">    copy_page(vto, vfrom);</span><br><span class="line">    kunmap_atomic(vfrom, KM_USER0);</span><br><span class="line">    kunmap_atomic(vto, KM_USER0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果旧页框是零页，就在分配新的页框时（<code>__GFP_ZERO</code>标志）把它填充为0。否则，使用<code>copy_page()</code>宏复制页框的内容。不要求一定要对零页做特殊的处理，但是特殊处理确实能够提高系统的性能，因为它减少地址引用而保护了微处理器的硬件高速缓存。</p>
<p>因为页框的分配可能阻塞进程，因此，函数检查自从函数开始执行以来是否已经修改了页表项（<code>pte</code>和<code>*page_table</code>具有不同的值）。如果是，新的页框被释放，<code>old_page</code>的使用计数器被减少（取消以前的增加），函数结束。</p>
<p>如果所有的事情看起来进展顺利，那么，新页框的物理地址最终被写进页表项，且使用相应的TLB寄存器无效：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spin_lock(&amp;mm-&gt;page_table_lock);</span><br><span class="line">entry = maybe_mkwrite(pte_mkdirty(mk_pte(new_page,</span><br><span class="line">                                         vma-&gt;vm_page_prot)),vma);</span><br><span class="line">set_pte(page_table, entry);</span><br><span class="line">flush_tlb_page(vma, address);</span><br><span class="line">lru_cache_add_active(new_page);</span><br><span class="line">pte_unmap(page_table);</span><br><span class="line">spin_unlock(&amp;mm-&gt;page_table_lock);</span><br></pre></td></tr></table></figure></p>
<p><code>lru_cache_add_active()</code>函数把新页框插入到与交换相关的数据结构中。</p>
<p>最后，<code>do_wp_page()</code>把<code>old_page</code>的使用计数器减少两次。第一次的减少是取消复制页框内容之前进行的安全性增加；第二次的减少是反映当前进程不再拥有该页框这一事实。</p>
<h2 id="处理非连续内存区访问"><a href="#处理非连续内存区访问" class="headerlink" title="处理非连续内存区访问"></a>处理非连续内存区访问</h2><p>内核在更新非连续内存区对应的页表项时是非常懒惰的。事实上，<code>vmalloc()</code>和<code>vfree()</code>函数只把自己现在在更新主内核页表。</p>
<p>然而一旦内核初始化结束，任何进程或内核线程便都不直接使用主内核页表。因此，我们来考虑内核态进程对非连续内存区的第一次访问。当把线性地址转换为物理地址时，CPU的内存管理单元遇到空的页表项并产生一个缺页。但是缺页异常处理程序认识这种特殊的情况，因为异常发生在内核态且产生缺页的线性地址大于<code>TASK_SIZE</code>。</p>
<p>因此<code>do_page_fault()</code>检查相应的主内核页表项。把存放在<code>cr3</code>寄存器中的当前进程页全局目录的物理地址赋给局部变量<code>pgd_paddr</code>（内核不使用<code>current-&gt;mm_pgd</code>导出当前进程的页全局目录地址，因为这种缺页可能在任何时刻都发生，甚至在进程切换期间发生。），把与<code>pgd_paddr</code>相应的线性地址赋给局部变量pgd，并且把主内核页全局目录的线性地址赋给<code>pgd_k</code>局部变量。</p>
<p>如果产生缺页的线性地址所对应的主内核页全局目录项为空，即<code>if(!pud_present(*pud_k))</code>，则函数跳到标号为<code>no_context</code>处。否则，函数检查与错误线性地址相对应的主内核页上级目录项和主内核页中间目录项。如果它们中有一个为空，再次跳到标号为<code>no_context</code>处。</p>
<h2 id="创建和删除进程的地址空间"><a href="#创建和删除进程的地址空间" class="headerlink" title="创建和删除进程的地址空间"></a>创建和删除进程的地址空间</h2><p>重点关注<code>fork()</code>系统调用为子进程创建一个完整的新地址空间。相反，当进程结束时，内核撤消它的地址空间。</p>
<h3 id="创建进程的地址空间"><a href="#创建进程的地址空间" class="headerlink" title="创建进程的地址空间"></a>创建进程的地址空间</h3><p>当创建一个新的进程时内核调用<code>copy_mm()</code>函数。这个函数<strong>通过建立新进程的所有页表和内存描述符来创建进程的地址空间</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_mm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct * tsk)</span></span><br></pre></td></tr></table></figure></p>
<p>通常，每个进程都有自己的地址空间，但是轻量级进程可以通过调用<code>clone()</code>函数来创建。<strong>这些轻量级进程共享同一地址空间，也就是说，允许它们对同一组页进行寻址</strong>。</p>
<p>按照前面讲述的<strong>写时复制</strong>方法，传统的进程继承父进程的地址空间，只要页是只读的，就依然共享它们。<strong>当其中的一个进程试图对某个页进行写时，此时，这个页才被复制一份</strong>。一段时间之后，所创建的子进程通常会因为缺页异常而获得与父进程不一样的完全属于自己的地址空间。</p>
<p>另一方面，<strong>轻量级的进程使用父进程的地址空间</strong>。Linux实现轻量级进程很简单，即不复制父进程地址空间。创建轻量级的进程（clone）比创建普通进程相应要快得多，而且<strong>只要父进程和子进程谨慎地协调它们的访问，就可以认为页的共享是有益的</strong>。</p>
<p>如果通过<code>clone()</code>系统调用已经创建了新进程，并且<code>flag</code>参数的<code>CLONE_VM</code>标志被设置，则<code>copy_mm()</code>函数把父进程（<code>current</code>）地址空间给子进程（tsk）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;current-&gt;mm-&gt;mm_users);</span><br><span class="line">    spin_unlock_wait(&amp;current-&gt;mm-&gt;page_table_lock);</span><br><span class="line">    tsk-&gt;mm = current-&gt;mm;</span><br><span class="line">    tsk-&gt;active_mm = current-&gt;mm;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有设置<code>CLONE_VM</code>标志，<code>copy_mm()</code>函数就必须创建一个新的地址空间（在进程请求一个地址之前，即使在地址空间内没有分配内存）。函数分配一个新的内存描述符，把它的地址存放在新进程描述符<code>tsk</code>的<code>mm</code>字段中，并把<code>current-&gt;mm</code>的内容复制到<code>tsk-&gt;mm</code>中。然后改变新进程描述符的一些字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mm_struct *<span class="title function_">dup_mm</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    tsk-&gt;mm = kmem_cache_alloc(mm_cachep, SLAB_KERNEL);</span><br><span class="line">    <span class="built_in">memcpy</span>(tsk-&gt;mm, current-&gt;mm, <span class="keyword">sizeof</span>(*tsk-&gt;mm));</span><br><span class="line">    <span class="type">atomic_set</span>(&amp;mm-&gt;mm_users, <span class="number">1</span>);</span><br><span class="line">    <span class="type">atomic_set</span>(&amp;mm-&gt;mm_count, <span class="number">1</span>);</span><br><span class="line">    init_rwsem(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    tsk-&gt;mm-&gt;core_waiters = <span class="number">0</span>;</span><br><span class="line">    tsk-&gt;mm-&gt;page_table_lock = SPIN_LOCK_UNLOCKED;</span><br><span class="line">    tsk-&gt;mm-&gt;ioctx_list_lock = RW_LOCK_UNLOCKED;</span><br><span class="line">    tsk-&gt;mm-&gt;ioctx_list = <span class="literal">NULL</span>;</span><br><span class="line">    tsk-&gt;default_kioctx = INIT_KIOCTX(tsk-&gt;mm-&gt;default_kioctx, *tsk-&gt;mm);</span><br><span class="line">    tsk-&gt;mm-&gt;free_area_cache = (TASK_SIZE/<span class="number">3</span>+<span class="number">0xfff</span>)&amp;<span class="number">0xfffff000</span>;</span><br><span class="line">    tsk-&gt;mm-&gt;pgd = pgd_alloc(tsk-&gt;mm);</span><br><span class="line">    tsk-&gt;mm-&gt;def_flags = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>mm_alloc_pgd()</code>调用<code>pgd_alloc()</code>宏为新进程分配一个全新的页全局目录，随后调用依赖于体系结构的<code>init_new_context()</code>函数：对于80x86处理器，该函数检查当前进程是否拥有定制的局部描述符表，如果是，<code>init_new_context()</code>复制一份<code>current</code>的局部描述符表并把它插入<code>tsk</code>的地址空间。最后调用<code>dup_mmap()</code>函数既复制父进程的线性区，也复制父进程的页表，把新内存描述符<code>tsk-&gt;mm</code>插入到内存描述符的全局链表中。然后从<code>current-&gt;mm-&gt;mmap</code>所指向的线性区开始扫描父进程的线性区链表。它复制遇到的每个<code>vm_area_struct</code>线性区描述符，并把复制品插入到子进程的线性区链表和红-黑树中。</p>
<p>在插入一个新的线性区描述符之后，如果需要的话，<code>dup_mmap()</code>立即调用<code>copy_page_range()</code>创建必要的页表来映射这个线性区所包含的一组页，并且初始化新页表的表项。尤其是，与私有的、可写的页（<code>VM_SHARED</code>标志关闭，<code>VM_MAYWRITE</code>标志打开）所对应的任一页框都标记为对父子进程是只读的，以便这种页框能用写时复制机制进行处理：</p>
<h2 id="删除进程的地址空间"><a href="#删除进程的地址空间" class="headerlink" title="删除进程的地址空间"></a>删除进程的地址空间</h2><p>当进程结束时，内核调用<code>exit_mm()</code>函数释放进程的地址空间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mm_release(tsk, tsk-&gt;mm);</span><br><span class="line"><span class="keyword">if</span> (!(mm = tsk-&gt;mm)) <span class="comment">/* kernel thread ? */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">down_read(&amp;mm-&gt;mmap_sem);</span><br></pre></td></tr></table></figure></p>
<p><code>mm_release()</code>函数唤醒在<code>tsk-&gt;vfork_done</code>补充信号量上睡眠的任一进程。典型地，只有当现有进程通过<code>vfork()</code>系统调用被创建时，相应的等待队列才会为非空。如果正在被终止的进程不是内核线程，<code>exit_mm()</code>函数就必须释放内存描述符和所有相关的数据结构。首先，它检查<code>mm-&gt;core_waiters</code>标志是否被置位：如果是，进程就把内存的所有内容卸载到一个转储文件中。为了避免转储文件的混乱，函数利用<code>mm-&gt;core_done</code>和<code>mm-&gt;core_startup_done</code>补充原语使共享同一个内存描述符<code>mm</code>的轻量级进程的执行串行化。</p>
<p>接下来，函数递增内存描述符的主使用计数器，重新设置进程描述符的<code>mm</code>字段，并使处理器处于懒惰TLB模式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_inc</span>(&amp;mm-&gt;mm_count);</span><br><span class="line">spin_lock(tsk-&gt;alloc_lock);</span><br><span class="line">tsk-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">up_read(&amp;mm-&gt;map_sem);</span><br><span class="line">enter_lazy_tlb(mm, current);</span><br><span class="line">spin_unlock(tsk-&gt;alloc_lock);</span><br><span class="line">mmput(mm);</span><br></pre></td></tr></table></figure></p>
<p>最后，调用<code>mmput()</code>函数释放局部描述符表、线性区描述符和页表。不过，因为<code>exit_mm()</code>已经递增了主使用计数器，所以并不释放内存描述符本身。当要把正在被终止的进程从本地CPU撤消时，将由<code>finish_task_switch()</code>函数释放内存描述符。</p>
<h2 id="堆的管理"><a href="#堆的管理" class="headerlink" title="堆的管理"></a>堆的管理</h2><p>每个Unix进程都拥有一个特殊的线性区，这个线性区就是所谓的<strong>堆</strong>（heap），<strong>堆用于满足进程的动态内存请求</strong>。内存描述符的<code>start_brk</code>与<code>brk</code>字段分别限定了这个区的开始地址和结束地址。进程可以使用下面的API来请求和释放动态内存：</p>
<ul>
<li><code>malloc(size)</code>:请求size个字节的动态内存</li>
<li><code>calloc(n,size)</code>:请求含n个大小为size的元素的一个数组。</li>
<li><code>realloc(ptr,size)</code>:该表由前面的<code>malloc()</code>或<code>calloc()</code>分配内存区字段的大小。</li>
<li><code>free(addr)</code>:释放由<code>malloc()</code>和<code>calloc()</code>分配的其实地址为addr的线性区。</li>
<li><code>brk(addr)</code>:直接修改堆的大小。addr参数指定<code>current-&gt;mm-&gt;brk</code>的新值，返回值是线性区新的结束地址。</li>
<li><code>sbrk(incr)</code>:类似于<code>brk()</code>，其中的incr参数指定是增加还是减小以字节为单位的堆大小</li>
</ul>
<p><code>brk()</code>函数和以上列出的函数有所不同，因为它是唯一以系统调用的方式实现的函数，而其他所有的函数都是使用<code>brk()</code>和<code>mmap()</code>系统调用实现的C语言库函数。</p>
<p>当用户态的进程调用<code>brk()</code>系统调用时，内核执行<code>sys_brk(addr)</code>函数。该函数首先验证addr参数是否位干进程代码所在的线性区。如果是，则立即返回，因为堆不能与进程代码所在的线性区重叠：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mm = current-&gt;mm;</span><br><span class="line">down_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; mm-&gt;end_code) &#123;</span><br><span class="line">out:</span><br><span class="line">    up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="keyword">return</span> mm-&gt;brk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>brk()</code>系统调用作用于某一个非代码的线性区，它分配和释放完整的页。因此，该函数把addr的值调整为<code>PAGE_SIZE</code>的倍数，然后把调整的结果与内存描述符的brk字段的值进行比较：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">newbrk = (addr + <span class="number">0xfff</span>) &amp; <span class="number">0xfffff000</span>;</span><br><span class="line">oldbrk = (mm-&gt;brk + <span class="number">0xfff</span>) &amp; <span class="number">0xfffff000</span>;</span><br><span class="line"><span class="keyword">if</span> (oldbrk == newbrk) &#123;</span><br><span class="line">    mm-&gt;brk = addr;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果进程请求缩小堆，则<code>sys_brk()</code>调用<code>do_munmap()</code>函数完成这项任务，然后返回：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (addr &lt;= mm-&gt;brk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!do_munmap(mm, newbrk, oldbrk-newbrk))</span><br><span class="line">        mm-&gt;brk = addr;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果进程请求扩大堆，则<code>sys_brk()</code>首先检查是否允许进程这样做。如果进程企图分配在其跟制范围之外的内存，函数并不多分配内存，只简单地返回<code>mm-&gt;brk</code>的原有值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rlim = current-&gt;signal-&gt;rlim[RLIMIT_DATA].rlim_cur;</span><br><span class="line"><span class="keyword">if</span> (rlim &lt; RLIM_INFINITY &amp;&amp; addr - mm-&gt;start_data &gt; rlim)</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure></p>
<p>然后，函数检查扩大后的堆是否和进程的其他线性区相重叠，如果是，不做任何事情就返回：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure></p>
<p>如果一切都顺利，则调用<code>do_brk()</code>函数。如果它返回<code>oldbrk</code>，则分配成功且<code>sys_brt()</code>函数返回addr的值；否则，返回旧的<code>mm-&gt;brk</code>值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (do_brk(oldbrk, newbrk-oldbrk) == oldbrk)</span><br><span class="line">    mm-&gt;brk = addr;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure></p>
<p><code>do_brk()</code>函数实际上是仅处理匿名线性区的<code>do_mmap()</code>的简化版。可以认为它的调用等价于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">do_mmap(<span class="literal">NULL</span>, oldbrk, newbrk-oldbrk, PROT_READ|PROT_WRITE|PROT_EXEC,</span><br><span class="line">        MAP_FIXED|MAP_PRIVATE, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>当然，<code>do_brk()</code>比<code>do_mmap()</code>稍快，因为前者假定线性区不映射磁盘上的文件，从而避免了检查线性区对象的几个字段。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/02/%E5%AE%9A%E4%BD%8Dcpp%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/" rel="prev" title="通过wrap malloc定位CC++的内存泄漏问题">
      <i class="fa fa-chevron-left"></i> 通过wrap malloc定位CC++的内存泄漏问题
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B04/" rel="next" title="深入理解Linux内核10-12章">
      深入理解Linux内核10-12章 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E6%A1%86%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">页框管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.1.1.</span> <span class="nav-text">页描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E4%B8%80%E8%87%B4%E6%80%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%88NUMA%EF%BC%89"><span class="nav-number">1.1.2.</span> <span class="nav-text">非一致性内存访问（NUMA）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA"><span class="nav-number">1.1.3.</span> <span class="nav-text">内存管理区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E7%95%99%E7%9A%84%E9%A1%B5%E6%A1%86%E6%B1%A0"><span class="nav-number">1.1.4.</span> <span class="nav-text">保留的页框池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">1.1.5.</span> <span class="nav-text">分区页框分配器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%92%8C%E9%87%8A%E6%94%BE%E9%A1%B5%E6%A1%86"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">请求和释放页框</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%AB%AF%E5%86%85%E5%AD%98%E9%A1%B5%E6%A1%86%E7%9A%84%E5%86%85%E6%A0%B8%E6%98%A0%E5%B0%84"><span class="nav-number">1.1.6.</span> <span class="nav-text">高端内存页框的内核映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B0%B8%E4%B9%85%E5%86%85%E6%A0%B8%E6%98%A0%E5%B0%84"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">永久内核映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E5%86%85%E6%A0%B8%E6%98%A0%E5%B0%84"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">临时内核映射</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">伙伴系统算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E5%88%86%E9%85%8D"><span class="nav-number">1.2.2.</span> <span class="nav-text">块分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E9%87%8A%E6%94%BE"><span class="nav-number">1.2.3.</span> <span class="nav-text">块释放</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8FCPU%E9%A1%B5%E6%A1%86%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">1.3.</span> <span class="nav-text">每CPU页框高速缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%AF%8FCPU-%E9%A1%B5%E6%A1%86%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%88%86%E9%85%8D%E9%A1%B5%E6%A1%86"><span class="nav-number">1.3.2.</span> <span class="nav-text">通过每CPU 页框高速缓存分配页框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E9%A1%B5%E6%A1%86%E5%88%B0%E6%AF%8FCPU-%E9%A1%B5%E6%A1%86%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">1.3.3.</span> <span class="nav-text">释放页框到每CPU 页框高速缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%8C%BA%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">1.4.</span> <span class="nav-text">管理区分配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E4%B8%80%E7%BB%84%E9%A1%B5%E6%A1%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">释放一组页框</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">内存区管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.5.1.</span> <span class="nav-text">高速缓存描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slab%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.5.2.</span> <span class="nav-text">slab描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%92%8C%E4%B8%93%E7%94%A8%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">1.5.3.</span> <span class="nav-text">普通和专用高速缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slab%E5%88%86%E9%85%8D%E5%99%A8%E4%B8%8E%E5%88%86%E5%8C%BA%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.5.4.</span> <span class="nav-text">slab分配器与分区页框分配器的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%88%86%E9%85%8Dslab"><span class="nav-number">1.5.5.</span> <span class="nav-text">给高速缓存分配slab</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%AD%E9%87%8A%E6%94%BEslab"><span class="nav-number">1.5.6.</span> <span class="nav-text">从高速缓存中释放slab</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.5.7.</span> <span class="nav-text">对象描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E9%BD%90%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.5.8.</span> <span class="nav-text">对齐内存中的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slab%E7%9D%80%E8%89%B2"><span class="nav-number">1.5.9.</span> <span class="nav-text">slab着色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2slab%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E5%9C%B0%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">1.5.10.</span> <span class="nav-text">空闲slab对象的本地高速缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8Dslab%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.5.11.</span> <span class="nav-text">分配slab对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8A%E6%94%BESlab%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.5.12.</span> <span class="nav-text">释放Slab对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.5.13.</span> <span class="nav-text">通用对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="nav-number">1.5.14.</span> <span class="nav-text">内存池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="nav-number">1.6.</span> <span class="nav-text">非连续内存区管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80"><span class="nav-number">1.6.1.</span> <span class="nav-text">非连续内存的线性地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.6.2.</span> <span class="nav-text">非连续内存区的描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA"><span class="nav-number">1.6.3.</span> <span class="nav-text">分配非连续内存区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA"><span class="nav-number">1.6.4.</span> <span class="nav-text">释放非连续内存区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">2.</span> <span class="nav-text">进程地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4-1"><span class="nav-number">2.1.</span> <span class="nav-text">进程地址空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.2.</span> <span class="nav-text">内存描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0"><span class="nav-number">2.2.1.</span> <span class="nav-text">数据结构描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.2.2.</span> <span class="nav-text">内核线程的内存描述符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%8C%BA"><span class="nav-number">2.3.</span> <span class="nav-text">线性区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%8C%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.1.</span> <span class="nav-text">线性区数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%8C%BA%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">2.3.2.</span> <span class="nav-text">线性区访问权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%8C%BA%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">2.3.3.</span> <span class="nav-text">线性区的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%BB%99%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E6%9C%80%E9%82%BB%E8%BF%91%E5%8C%BA"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">查找给定地址的最邻近区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E4%B8%8E%E7%BB%99%E5%AE%9A%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8C%BA%E9%97%B4%E7%9B%B8%E9%87%8D%E5%8F%A0%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8C%BA"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">查找一个与给定的地址区间相重叠的线性区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%97%B2%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8C%BA%E9%97%B4"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">查找一个空闲的地址区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E5%86%85%E5%AD%98%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BA%BF%E6%80%A7%E5%8C%BA"><span class="nav-number">2.3.3.4.</span> <span class="nav-text">向内存描述符链表中插入一个线性区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">2.4.</span> <span class="nav-text">分配线性地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E5%8C%BA%E9%97%B4"><span class="nav-number">2.4.0.1.</span> <span class="nav-text">释放线性地址区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#split-vma-%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.0.2.</span> <span class="nav-text">split_vma()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unmap-region-%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.0.3.</span> <span class="nav-text">unmap_region()函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.5.</span> <span class="nav-text">缺页异常处理程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%BB%A5%E5%A4%96%E7%9A%84%E9%94%99%E8%AF%AF%E5%9C%B0%E5%9D%80"><span class="nav-number">2.5.1.</span> <span class="nav-text">处理地址空间以外的错误地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%86%85%E7%9A%84%E9%94%99%E8%AF%AF%E5%9C%B0%E5%9D%80"><span class="nav-number">2.5.2.</span> <span class="nav-text">处理地址空间内的错误地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5"><span class="nav-number">2.6.</span> <span class="nav-text">请求调页</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="nav-number">2.7.</span> <span class="nav-text">写时复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA%E8%AE%BF%E9%97%AE"><span class="nav-number">2.8.</span> <span class="nav-text">处理非连续内存区访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">2.9.</span> <span class="nav-text">创建和删除进程的地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">2.9.1.</span> <span class="nav-text">创建进程的地址空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">2.10.</span> <span class="nav-text">删除进程的地址空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">2.11.</span> <span class="nav-text">堆的管理</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuhao0102" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuhao0102" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuhhpc0203@gmail.com" title="E-Mail → mailto:yuhhpc0203@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
