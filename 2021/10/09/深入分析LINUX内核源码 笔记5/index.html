<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="设备驱动程序概述在Linux中输入&#x2F;输出设备被分为 3 类：块设备，字符设备和网络设备。 I&#x2F;O软件I&#x2F;O软件的总体目标就是将软件组织成一种层次结构，低层软件用来屏蔽具体设备细节，高层软件则为用户提供一个简洁规范的界面。这种层次结构很好地体现了I&#x2F;O设计的一个关键的概念：设备无关性，其含义就是程序员写的软件无需须修改就能读出软盘，硬盘以及CD-ROM等不同设备上的文件。 输入&#x2F;输出系统的层次结构及">
<meta property="og:type" content="article">
<meta property="og:title" content="深入分析Linux内核源码笔记5">
<meta property="og:url" content="http://yoursite.com/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B05/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="设备驱动程序概述在Linux中输入&#x2F;输出设备被分为 3 类：块设备，字符设备和网络设备。 I&#x2F;O软件I&#x2F;O软件的总体目标就是将软件组织成一种层次结构，低层软件用来屏蔽具体设备细节，高层软件则为用户提供一个简洁规范的界面。这种层次结构很好地体现了I&#x2F;O设计的一个关键的概念：设备无关性，其含义就是程序员写的软件无需须修改就能读出软盘，硬盘以及CD-ROM等不同设备上的文件。 输入&#x2F;输出系统的层次结构及">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1634118924.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634118955.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634176469.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634177274.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634178117.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634178398.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634178725.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634181153.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634181365.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634181427.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634181454.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634181502.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634181659.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634181696.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634181964.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634182062.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634197155.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634197233.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634199605.jpg">
<meta property="article:published_time" content="2021-10-09T08:00:00.000Z">
<meta property="article:modified_time" content="2021-10-14T09:05:39.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1634118924.jpg">

<link rel="canonical" href="http://yoursite.com/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B05/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>深入分析Linux内核源码笔记5 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">128</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yuhao0102" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入分析Linux内核源码笔记5
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-09 16:00:00" itemprop="dateCreated datePublished" datetime="2021-10-09T16:00:00+08:00">2021-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-14 17:05:39" itemprop="dateModified" datetime="2021-10-14T17:05:39+08:00">2021-10-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在<code>Linux</code>中输入/输出设备被分为 3 类：块设备，字符设备和网络设备。</p>
<h3 id="I-O软件"><a href="#I-O软件" class="headerlink" title="I/O软件"></a>I/O软件</h3><p>I/O软件的总体目标就是将软件组织成一种层次结构，低层软件用来屏蔽具体设备细节，高层软件则为用户提供一个简洁规范的界面。这种层次结构很好地体现了<code>I/O</code>设计的一个关键的概念：设备无关性，其含义就是程序员写的软件无需须修改就能读出软盘，硬盘以及CD-ROM等不同设备上的文件。</p>
<p>输入/输出系统的层次结构及各层次的功能如图 11.1 所示。<br><img src="/img/1634118924.jpg" alt=""></p>
<p>从图可以看出，用户进程的下层是设备无关的软件，在<code>Linux</code>中，设备无关软件的功能大部分由文件系统去完成，其基本功能就是执行适用于所有设备的常用的输入/输出功能，向用户软件提供一个一致的接口。其结构如图 11.2 所示。<br><img src="/img/1634118955.jpg" alt=""></p>
<p>设备无关的软件具有以下特点。</p>
<ul>
<li>文件和设备采用统一命名。设备无关软件负责将设备名映射到相应的驱动程序，一个设备名唯一地确定一个索引节点，索引节点中包含了主设备号和从设备号，通过主设备号可以找到相应的设备驱动程序，通过从设备号确定具体的物理设备。 </li>
<li>对设备提供的保护机制同文件系统一样都采用<code>rwx</code>权限。</li>
<li>数据块的大小可能对于不同的设备其大小不一样，但操作系统屏蔽这一事实，向高层软件提供了统一的逻辑块的大小。</li>
<li>为了解决数据交换速度的匹配问题，采用了缓冲技术，对于缓冲区的管理由文件系统去完成。</li>
<li>块设备的存储分配也是由文件系统去处理。</li>
<li>对于独占设备的分配和释放属于对临界资源的管理。</li>
</ul>
<h3 id="设备驱动程序-1"><a href="#设备驱动程序-1" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>设备管理的一个基本特征是设备处理的抽象性，即所有硬件设备都被看成普通文件，可以通过用操纵普通文件相同的系统调用来打开、关闭、读取和写入设备。系统中每个设备都用一种设备特殊文件来表示，例如系统中第一个IDE硬盘被表示成<code>/dev/hda</code>。</p>
<p>首先当用户进程发出输入输出时，系统把请求处理的权限放在文件系统，文件系统通过驱动程序提供的接口将任务下放到驱动程序，驱动程序根据需要对设备控制器进行操作，设备控制器再去控制设备本身。</p>
<p><code>Linux</code>设备驱动程序的主要功能有:</p>
<ul>
<li>对设备进行初始化；</li>
<li>使设备投入运行和退出服务；</li>
<li>从设备接收数据并将它们送回内核；</li>
<li>将数据从内核送到设备；</li>
<li>检测和处理设备出现的错误。</li>
</ul>
<p>在<code>Linux</code>中，设备驱动程序是一组相关函数的集合。它包含设备服务子程序和中断处理程序。设备服务子程序包含了所有与设备相关的代码，每个设备服务子程序只处理一种设备或者紧密相关的设备。其功能就是从与设备无关的软件中接受抽象的命令并执行之。当执行一条请求时，具体操作是根据控制器对驱动程序提供的接口(指的是控制器中的各种寄存器)，并利用中断机制去调用中断服务子程序配合设备来完成这个请求。设备驱动程序利用结构<code>file_operations</code>与文件系统联系起来，即设备的各种操作的入口函数存在<code>file_operation</code>中。对于特定的设备来说有一些操作是不必要的，其入口置为<code>NULL</code>。</p>
<p><code>Linux</code>内核中虽存在许多不同的设备驱动程序但它们具有一些共同的特性，如下所述。</p>
<ol>
<li>驱动程序属于内核代码：设备驱动程序是内核的一部分，它像内核中其他代码一样运行在内核模式，驱动程序如果出错将会使操作系统受到严重破坏，甚至能使系统崩溃并导致文件系统的破坏和数据丢失。</li>
<li>为内核提供统一的接口：设备驱动程序必须为<code>Linux</code>内核或其他子系统提供一个标准的接口。例如终端驱动程序为<code>Linux</code>内核提供了一个文件<code>I/O</code>接口。</li>
<li>驱动程序的执行属于内核机制并且使用内核服务：设备驱动可以使用标准的内核服务如内存分配、中断发送和等待队列等。</li>
<li>动态可加载：多数<code>Linux</code>设备驱动程序可以在内核模块发出加载请求时加载，而不再使用时将其卸载。这样内核能有效地利用系统资源。 </li>
<li>可配置：<code>Linux</code>设备驱动程序可以连接到内核中。当内核被编译时，被连入内核的设备驱动程序是可配置的。</li>
</ol>
<h2 id="设备驱动基础"><a href="#设备驱动基础" class="headerlink" title="设备驱动基础"></a>设备驱动基础</h2><h3 id="I-O端口"><a href="#I-O端口" class="headerlink" title="I/O端口"></a>I/O端口</h3><p>每个连接到<code>I/O</code>总线上的设备都有自己的<code>I/O</code>地址集，即所谓的<code>I/O</code>端口(I/O port)。在<code>IBM PC</code>体系结构中，<code>I/O</code>地址空间一共提供了 65,536 个 8 位的<code>I/O</code>端口。可以把两个连续的 8 位端口看成一个 16 位端口，但是这必须是从偶数地址开始。同理，也可以把两个连续的 16 位端口看成一个 32 位端口，但是这必须是从 4 的整数倍地址开始。有 4 条专用的汇编语言指令可以允许<code>CPU</code>对<code>I/O</code>端口进行读写：它们分别是<code>in</code>、<code>ins</code>、<code>out</code>和<code>outs</code>。在执行其中的一条指令时，<code>CPU</code>使用地址总线选择所请求的<code>I/O</code>端口，使用数据总线在<code>CPU</code>寄存器和端口之间传送数据。</p>
<p><code>I/O</code>端口还可以被映射到物理地址空间，因此，处理器和<code>I/O</code>设备之间的通信就可以直接使用对内存进行操作的汇编语言指令(例如，<code>mov</code>、<code>and</code>、<code>or</code>等等)。现代的硬件设备更倾向于映射<code>I/O</code>，因为这样处理的速度较快，并可以和<code>DMA</code>结合起来使用。系统设计者的主要目的是提供对<code>I/O</code>编程的统一方法，但又不牺牲性能。为了达到这个目的，每个设备的<code>I/O</code>端口都被组织成如图 11.4 所示的一组专用寄存器。<br><img src="/img/1634176469.jpg" alt=""></p>
<p><code>CPU</code>把要发给设备的命令写入控制寄存器(Control Register)，并从状态寄存器(Status Register)中读出表示设备内部状态的值。CPU`还可以通过读取输入寄存器(Input Register)的内容从设备<br>取得数据，也可以通过向输出寄存器(Output Register)中写入字节而把数据输出到设备。</p>
<p>那么如何访问<code>I/O</code>端口?<code>in</code>、<code>out</code>、<code>ins</code>和<code>outs</code>汇编语言指令都可以访问<code>I/O</code>端口。Linux内核中定义了以下辅助函数来简化这种访问。</p>
<ol>
<li><code>inb()</code>、<code>inw()</code>、<code>inl()</code>函数：分别从<code>I/O</code>端口读取 1、2 或 4 个连续字节。后缀<code>b</code>、<code>w</code>、<code>l</code>分别代表一个字节(8位)、一个字(16 位)以及一个长整型(32 位)。</li>
<li><code>inb_p()</code>、<code>inw_p()</code>、<code>inl_p()</code>：分别从<code>I/O</code>端口读取 1、2 或 4 个连续字节，然后执行一条“哑元(dummy，即空指令)”指令使<code>CPU</code>暂停。</li>
<li><code>outb()</code>、<code>outw()</code>、<code>outl()</code>：分别向一个<code>I/O</code>端口写入 1、2 或 4 个连续字节。</li>
<li><code>outb_p()</code>、<code>outw_p()</code>、<code>outl_p()</code>：分别向一个<code>I/O</code>端口写入 1、2 或 4 个连续字节，然后执行一条“哑元”指令使<code>CPU</code>暂停。</li>
<li><code>insb()、insw()</code>、<code>insl()</code>：分别从<code>I/O</code>端口读入以 1、2 或 4 个字节为一组的连续字节序列。字节序列的长度由该函数的参数给出。</li>
<li><code>outsb()</code>、<code>outsw()</code>、<code>outsl()</code>：分别向<code>I/O</code>端口写入以 1、2 或 4 个字节为一组的连续字节序列。</li>
</ol>
<p>虽然访问<code>I/O</code>端口非常简单，但是检测哪些<code>I/O</code>端口已经分配给<code>I/O</code>设备可能就不这么简单，特别是对基于<code>ISA</code>总线的系统来说更是如此。通常，<code>I/O</code>设备驱动程序为了侦探硬件设备，需要盲目地向某一<code>I/O</code>端口写入数据；但是，如果其他硬件设备已经使用这个端口，那么系统就会崩溃。为了防止这种情况的发生，内核必须使用<code>iotable</code>表来记录分配给每个硬件设备的<code>I/O</code>端口。任何设备驱动程序都可以使用下面 3 个函数。</p>
<ul>
<li><code>request_region()</code>：把一个给定区间的<code>I/O</code>端口分配给一个<code>I/O</code>设备。</li>
<li><code>check_region()</code>：检查一个给定区间的<code>I/O</code>端口是否空闲，或者其中一些是否已经分配给某个<code>I/O</code>设备。</li>
<li><code>release_region()</code>：释放以前分配给一个<code>I/O</code>设备的给定区间的<code>I/O</code>端口。</li>
</ul>
<p>当前分配给<code>I/O</code>设备的<code>I/O</code>地址可以从<code>/proc/ioports</code>文件中获得。 </p>
<h3 id="I-O接口及设备控制器"><a href="#I-O接口及设备控制器" class="headerlink" title="I/O接口及设备控制器"></a>I/O接口及设备控制器</h3><p><code>I/O</code>接口是处于一组<code>I/O</code>端口和对应的设备控制器之间的一种硬件电路。它起翻译器的作用，即把<code>I/O</code>端口中的值转换成设备所需要的命令和数据。从另一个角度来看，它检测设备状态的变化，并对起状态寄存器作用的<code>I/O</code>端口进行相应地更新。还可以通过一条<code>IRQ</code>线把这种电路连接到可编程中断控制器上，以使它代表相应的设备发出中断请求。</p>
<p>有两类类型的接口，如下所述。</p>
<h4 id="专用I-O接口"><a href="#专用I-O接口" class="headerlink" title="专用I/O接口"></a>专用I/O接口</h4><p>专门用于一个特定的硬件设备。在一些情况下，设备控制器与这种<code>I/O</code>接口处于同一块卡中，连接到专用<code>I/O</code>接口上的设备可以是内部设备(位于<code>PC</code>机箱内部的设备)，也可以是外部设备(位于<code>PC</code>机箱外部的设备)。例如键盘接口、图形接口、磁盘接口、总线鼠标接口及网络接口都属于专用<code>I/O</code>接口。</p>
<h4 id="通用I-O接口"><a href="#通用I-O接口" class="headerlink" title="通用I/O接口"></a>通用I/O接口</h4><p>用来连接多个不同的硬件设备。连接到通用<code>I/O</code>接口上的设备通常都是外部设备。例如并口、串口、通用串行总线(USB)、<code>PCMCIA</code>接口及<code>SCSI</code>接口都属于通用<code>I/O</code>接口。复杂的设备可能需要一个设备控制器来驱动。控制器具有两方面的作用，一是对从<code>I/O</code>接口接收到的高级命令进行解释，并通过向设备发送适当的电信号序列强制设备执行特定的操作；二是对从设备接收到的电信号进行转换和解释，并通过<code>I/O</code>接口修改状态寄存器的值。</p>
<h3 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h3><p>设备文件是用来表示<code>Linux</code>所支持的大多数设备的，每个设备文件除了设备名，还有 3个属性：即类型、主设备号、从设备号。</p>
<p>设备文件是通过<code>mknod</code>系统调用创建的。其原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod(<span class="type">const</span> <span class="type">char</span> * filename, <span class="type">int</span> mode, <span class="type">dev_t</span> dev)</span><br></pre></td></tr></table></figure></p>
<p>其参数有设备文件名、操作模式、主设备号及从设备号。最后两个参数合并成一个 16位的<code>dev_t</code>无符号短整数，高 8 位用于主设备号，低 8 位用于从设备号。内核中定义了 3 个宏来处理主、从设备号：<code>MAJOR</code>和<code>MINOR</code>宏可以从 16 位数中提取出主、从设备号，而<code>MKDEV</code>宏可以把主、从号合并为一个 16 位数。实际上，<code>dev_t</code>是专用于应用程序的一个数据类型；在内核中使用<code>kdev_t</code>数据类型。</p>
<p>分配给设备号的正式注册信息及<code>/dev</code>目录索引节点存放在<code>documentation/devices.txt</code>文件中。也可以在<code>include/linux/major.h</code>文件中找到所支持的主设备号。设备文件通常位于<code>/dev</code>目录下。表 11.1 显示了一些设备文件的属性。注意同一主设备号既可以标识字符设备，也可以标识块设备。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>设备名</th>
<th>类型</th>
<th>主设备号</th>
<th>从号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/dev/fd0</code></td>
<td>块设备</td>
<td>2</td>
<td>0</td>
<td>软盘</td>
</tr>
<tr>
<td><code>/dev/hda</code></td>
<td>块设备</td>
<td>3</td>
<td>0</td>
<td>第 1 个IDE磁盘</td>
</tr>
<tr>
<td><code>/dev/hda2</code></td>
<td>块设备</td>
<td>3</td>
<td>2</td>
<td>第 1 个IDE磁盘上的第 2 个主分区</td>
</tr>
<tr>
<td><code>/dev/hdb</code></td>
<td>块设备</td>
<td>3</td>
<td>64</td>
<td>第 2 个IDE磁盘</td>
</tr>
<tr>
<td><code>/dev/hdb3</code></td>
<td>块设备</td>
<td>3</td>
<td>67</td>
<td>第 2 个IDE磁盘上的第 3 个主分区</td>
</tr>
<tr>
<td><code>/dev/ttyp0</code></td>
<td>字符设备</td>
<td>3</td>
<td>0</td>
<td>终端</td>
</tr>
<tr>
<td><code>/dev/console</code></td>
<td>字符设备</td>
<td>5</td>
<td>1</td>
<td>控制台</td>
</tr>
<tr>
<td><code>/dev/lp1</code></td>
<td>字符设备</td>
<td>6</td>
<td>1</td>
<td>并口打印机</td>
</tr>
<tr>
<td><code>/dev/ttyS0</code></td>
<td>字符设备</td>
<td>4</td>
<td>64</td>
<td>第 1 个串口</td>
</tr>
<tr>
<td><code>/dev/rtc</code></td>
<td>字符设备</td>
<td>10</td>
<td>135</td>
<td>实时时钟</td>
</tr>
<tr>
<td><code>/dev/null</code></td>
<td>字符设备</td>
<td>1</td>
<td>3</td>
<td>空设备(黑洞)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="块设备和字符设备的比较"><a href="#块设备和字符设备的比较" class="headerlink" title="块设备和字符设备的比较"></a>块设备和字符设备的比较</h4><p>块设备具有以下特点。</p>
<ul>
<li>可以在一次<code>I/O</code>操作中传送固定大小的数据块。</li>
<li>可以随机访问设备中所存放的块：传送数据块所需要的时间独立于块在设备中的位置，也独立于当前设备的状态。</li>
</ul>
<p>字符设备具有以下特点。 </p>
<ul>
<li>可以在一次<code>I/O</code>操作中传送任意大小的数据。实际上，诸如打印机之类的字符设备可以一次传送一个字节，而诸如磁带之类的设备可以一次传送可变大小的数据块。</li>
<li>通常访问连续的字符。</li>
</ul>
<h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p>有些<code>I/O</code>设备没有对应的设备文件。最明显的一个例子是网卡。实际上，网卡把向外发送的数据放入通往远程计算机系统的一条线上，把从远程系统中接收到的报文装入内核内存。从<code>BSD</code>开始，所有的<code>UNIX</code>类系统为计算机中的每个网卡都分配一个不同的符号名。</p>
<p>由于没有使用文件系统，所以系统管理员必须建立设备名和网络地址之间的联系。因此，应用程序和网络接口之间的数据通信不是基于标准的有关文件的系统调用的，而是基于<code>socket()</code>、<code>bind()</code>、<code>listen()</code>、<code>accept()</code>和<code>connect()</code>系统调用的，这些系统调用对网络地址进行操作。这组系统调用是在<code>UNIX BSD</code>中首先引入的，现在已经成为网络设备的标准编程模型。</p>
<h3 id="VFS对设备文件的处理"><a href="#VFS对设备文件的处理" class="headerlink" title="VFS对设备文件的处理"></a>VFS对设备文件的处理</h3><p>虽然设备文件也在系统的目录树中，但是它们和普通文件以及目录有根本的不同。当进程访问普通文件(即磁盘文件)时，它会通过文件系统访问磁盘分区中的一些数据块。而在进程访问设备文件时，它只要驱动硬件设备就可以了。例如，进程可以访问一个设备文件以从连接到计算机的温度计读取房间的温度。VFS的责任是为应用程序隐藏设备文件与普通文件之间的差异。</p>
<p>为了做到这点，<code>VFS</code>改变打开的设备文件的缺省文件操作。因此，可以把对设备文件的任一系统调用转换成对设备相关的函数的调用，而不是对主文件系统相应函数的调用。设备相关的函数对硬件设备进行操作以完成进程所请求的操作。</p>
<p>控制<code>I/O</code>设备的一组设备相关的函数称为设备驱动程序。由于每个设备都有一个唯一的<code>I/O</code>控制器，因此也就有唯一的命令和唯一的状态信息，所以大部分<code>I/O</code>设备类型都有自己的驱动程序。</p>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><p>基于中断的设备驱动程序，指的是在硬件设备需要服务时向<code>CPU</code>发一个中断信号，引发中断服务子程序执行 。这样就大大地提高了系统资源的利用率，使内核不必一直等到设备执行完任务后才开始有事可干，而是在设备工作期间内核就可以转去处理其他的事务，收到中断请求信号时再回头响应设备。</p>
<h4 id="Linux对中断的管理"><a href="#Linux对中断的管理" class="headerlink" title="Linux对中断的管理"></a>Linux对中断的管理</h4><p><code>Linux</code>内核为了将来自硬件设备的中断传递到相应的设备驱动程序，在驱动程序初始化的时候就将其对应的中断程序进行了登记，即通过调用函数<code>request_irq ()</code>将其中断信息添加到结构为<code>irqaction</code>的数组中，从而使中断号和中断服务程序联系起来。</p>
<p><code>request_irq ()</code>函数原形如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="comment">/* 中断请求号 */</span></span></span><br><span class="line"><span class="params">	<span class="type">void</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *, <span class="keyword">struct</span> pt_regs *), <span class="comment">/* 指向中断服务子程序 */</span></span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">long</span> irqflags, <span class="comment">/* 中断类型 */</span></span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> * devname, <span class="comment">/* 设备的名字 */</span></span></span><br><span class="line"><span class="params">	<span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure></p>
<p>另外，<code>irqaction</code>的数据结构如下，其图示如图 11.5 所示。<br><img src="/img/1634177274.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *, <span class="keyword">struct</span> pt_regs *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mask;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">void</span> *dev_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">irq_action</span>[<span class="title">NR_IRQS</span>+1] </span></span><br></pre></td></tr></table></figure>
<p>根据设备的中断号可以在数组<code>irq_action</code>检索到设备的中断信息。对中断资源的请求在驱动程序初始化时就已经完成。</p>
<h4 id="Linux对中断的处理"><a href="#Linux对中断的处理" class="headerlink" title="Linux对中断的处理"></a>Linux对中断的处理</h4><p><code>Linux</code>中断处理子系统的一个基本任务是将中断正确联系到中断处理代码中的正确位置。这些代码必须了解系统的中断拓扑结构。例如在中断控制器上引脚 6 上发生的软盘控制器中断必须被辨认出的确来自软盘并同系统的软盘设备驱动的中断服务子程序联系起来。</p>
<p>中断发生时，<code>Linux</code>首先读取系统可编程中断控制器中中断状态寄存器，判断出中断源，将其转换成<code>irq_action</code>数组中偏移值，然后调用其相应的中断处理程序。当<code>Linux</code>内核调用设备驱动程序的中断服务子程序时，必须找出中断产生的原因以及相应的解决办法，这是通过读取设备上的状态寄存器的内容来完成的。</p>
<p>下面我们结合输入/输出系统的层次结构来看一下中断在驱动程序工作的过程中的作用。</p>
<ol>
<li>用户发出某种输入/输出请求。</li>
<li>调用驱动程序的<code>read()</code>函数或<code>request()</code>函数，将完成的输入/输出的指令送给设备控制器，现在设备驱动程序等待操作的发生。</li>
<li>一小段时间以后，硬设备准备好完成指令的操作，并产生中断信号标志事件的发生。</li>
<li>中断信号导致调用驱动程序的中断服务子程序，它将所要的数据从硬设备复制到设备驱动程序的缓冲区中，并通知正在等待的<code>read()</code>函数和<code>request()</code>函数，现在数据可供使用。</li>
<li>在数据可供使用时，<code>read()</code>或<code>request()</code>函数现在可将数据提供给用户进程。</li>
</ol>
<p>上述过程是经过了简化了的，但却反映了中断的主要过程的主要方面。</p>
<h3 id="驱动DMA工作"><a href="#驱动DMA工作" class="headerlink" title="驱动DMA工作"></a>驱动DMA工作</h3><p>所有的<code>PC</code>都包含一个称为直接内存访问控制器或<code>DMAC</code>的辅助处理器，它可以用来控制在<code>RAM</code>和<code>I/O</code>设备之间数据的传送。<code>DMAC</code>一旦被<code>CPU</code>激活，就可以自行传送数据；当数据传送完成之后，<code>DMAC</code>发出一个中断请求。当<code>CPU</code>和<code>DMAC</code>同时访问同一内存单元时，所产生的冲突由一个称为内存仲裁器的硬件电路来解决。</p>
<p>使用<code>DMAC</code>最多的是磁盘驱动器和其他需要一次传送大量字节的慢速设备。因为<code>DMAC</code>的设置时间相当长，所以在传送数量很少的数据时直接使用<code>CPU</code>效率更高。</p>
<p>到现在为止，我们已区分了 3 类内存地址：逻辑地址、线性地址以及物理地址，前两个在<code>CPU</code>内部使用，最后一个是<code>CPU</code>从物理上驱动数据总线所用的内存地址。但是，还有第 4种内存地址，称为总线地址：它是除<code>CPU</code>之外的硬件设备驱动数据总线所用的内存地址。</p>
<p>从根本上说，内核为什么应该关心总线地址呢？这是因为在<code>DMA</code>操作中数据传送不用<code>CPU</code>的参与：<code>I/O</code>设备和<code>DMAC</code>直接驱动数据总线。因此，在内核开始<code>DMA</code>操作时，必须把所涉及的内存缓冲区总线地址或写入<code>DMAC</code>适当的<code>I/O</code>端口、或写入<code>I/O</code>设备适当的<code>I/O</code>端口。 </p>
<p>很多<code>I/O</code>驱动程序都使用直接内存访问控制器(DMAC)来加快操作的速度。<code>DMAC</code>与设备的<code>I/O</code>控制器相互作用共同实现数据传送。后文中我们还会看到，内核中包含一组易用的例程来对<code>DMAC</code>进行编程。当数据传送完成时，<code>I/O</code>控制器通过<code>IRQ</code>向<code>CPU</code>发出信号。</p>
<p>当设备驱动程序为某个<code>I/O</code>设备建立<code>DMA</code>操作时，必须使用总线地址指定所用的内存缓冲区。内核提供两个宏<code>virt_to_bus</code>和<code>bus_to_virt</code>，分别把虚拟地址转换成总线地址或把总线地址转换成虚拟地址。</p>
<p>与<code>IRQ</code>一样，<code>DMAC</code>也是一种资源，必须把这种资源动态地分配给需要它的设备驱动程序。驱动程序开始和结束<code>DMA</code>操作的方法依赖于总线的类型。</p>
<h4 id="ISA总线的DMA"><a href="#ISA总线的DMA" class="headerlink" title="ISA总线的DMA"></a>ISA总线的DMA</h4><p>每个<code>ISA DMAC</code>只能控制有限个通道。每个通道都包括一组独立的内部寄存器，所以，<code>DMAC</code>就可以同时控制几个数据的传送。</p>
<p>设备驱动程序通常使用下面的方式来申请和释放<code>ISA DMAC</code>。设备驱动程序照样要靠一个引用计数器来检测什么时候任何进程都不再访问设备文件。驱动程序执行以下操作。</p>
<ul>
<li>在设备文件的<code>open()</code>方法中把设备的引用计数器加 1。如果原来的值是 0，那么，驱动程序执行以下操作：<ul>
<li>调用<code>request_irq()</code>来分配<code>ISA DMAC</code>所使用的<code>IRQ</code>中断号；</li>
<li>调用<code>request_dma()</code>来分配<code>DMA</code>通道；</li>
<li>通知硬件设备应该使用<code>DMA</code>并产生中断。</li>
<li>如果需要，为<code>DMA</code>缓冲区分配一个存储区域</li>
</ul>
</li>
<li>当必须启动<code>DMA</code>操作时，在设备文件的<code>read()</code>和<code>write()</code>方法中执行以下操作：<ul>
<li>调用<code>set_dma_mode()</code>把通道设置成读/写模式；</li>
<li>调用<code>set_dma_addr()</code>来设置<code>DMA</code>缓冲区的总线地址。(因为只有最低的 24 位地址会发给<code>DMAC</code>，所以缓冲区必须在<code>RAM</code>的前<code>16MB</code>中)；</li>
<li>调用<code>set_dma_count()</code>来设置要发送的字节数；</li>
<li>调用<code>set_dma_dma()</code>来启用<code>DMA</code>通道；</li>
<li>把当前进程加入该设备的等待队列，并把它挂起，当<code>DMAC</code>完成数据传送操作时，设备的<code>I/O</code>控制器就发出一个中断，相应的中断处理程序会唤醒正在睡眠的进程；</li>
<li>进程一旦被唤醒，就立即调用<code>disable_dma()</code>来禁用这个<code>DMA</code>通道；</li>
<li>调用<code>get_dma_residue()</code>来检查是否所有的数据都已被传送。</li>
</ul>
</li>
<li>在设备文件的<code>release</code>方法中，减少设备的引用计数器。如果该值变成 0，就执行以下操作：<ul>
<li>禁用<code>DMA</code>和对这个硬件设备上的相应中断；</li>
<li>调用<code>free_dma()</code>来释放<code>DMA</code>通道；</li>
<li>调用<code>free_irq()</code>来释放<code>DMA</code>所使用的<code>IRQ</code>线。</li>
</ul>
</li>
</ul>
<h4 id="PCI总线的DMA"><a href="#PCI总线的DMA" class="headerlink" title="PCI总线的DMA"></a>PCI总线的DMA</h4><p><code>PCI</code>总线对于<code>DMA</code>的使用要简单得多，因为<code>DMAC</code>是集成到<code>I/O</code>接口内部的。在<code>open()</code>方法中，设备驱动程序照样必须分配一条<code>IRQ</code>线来通知<code>DMA</code>操作的完成。但是，并没有必要分配一个<code>DMA</code>通道，因为每个硬件设备都直接控制<code>PCI</code>总线的电信号。要启动<code>DMA</code>操作，设备驱动程序在硬件设备的某个<code>I/O</code>端口中简单地写入<code>DMA</code>缓冲区的总线地址、传送方向以及数据大小，然后驱动程序就挂起当前进程。在最后一个进程关闭这个文件对象时，<code>release</code>方法负责释放这条<code>IRQ</code>线。</p>
<h3 id="I-O空间的映射"><a href="#I-O空间的映射" class="headerlink" title="I/O空间的映射"></a>I/O空间的映射</h3><p>很多硬件设备都有自己的内存，通常称之为<code>I/O</code>空间。</p>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><p>根据设备和总线类型的不同，<code>PC</code>体系结构中的<code>I/O</code>空间可以在 3 个不同的物理地址范围之间进行映射。</p>
<ol>
<li>对于连接到<code>ISA</code>总线上的大多数设备，<code>I/O</code>空间通常被映射到从<code>0xa0000</code>到<code>0xfffff</code>的物理地址范围，这就在<code>640K</code>和<code>1MB</code>之间留出了一段空间，这就是所谓的“洞”。</li>
<li>对于使用<code>VESA</code>本地总线(VLB)的一些老设备这主要是由图形卡使用的一条专用总线：<code>I/O</code>空间被映射到从<code>0xe00000</code>到<code>0xffffff</code>的地址范围中，也就是<code>14MB</code>到<code>16MB</code>之间。因为这些设备使页表的初始化更加复杂，因此已经不生产这种设备了。</li>
<li>对于连接到<code>PCI</code>总线的设备：<code>I/O</code>空间被映射到很大的物理地址区间，位于<code>RAM</code>物理地址的顶端。这种设备的处理比较简单。</li>
</ol>
<h4 id="访问I-O空间"><a href="#访问I-O空间" class="headerlink" title="访问I/O空间"></a>访问I/O空间</h4><p>内核驱动程序必须把<code>I/O</code>空间单元的物理地址转换成内核空间的虚拟地址。在<code>PC</code>体系结构中，这可以简单地把 32 位的物理地址和 0xc0000000 常量进行或运算得到。例如，假设内核需要把物理地址为 0x000b0fe4 的<code>I/O</code>单元的值存放在<code>t1</code>中，把物理地址为 0xfc000000的<code>I/O</code>单元的值存放在`t2 中，就可以使用下面的表达式来完成这项功能：</p>
<ul>
<li><code>t1 = *((unsigned char *)(0xc00b0fe4));</code></li>
<li><code>t2 = *((unsigned char *)(0xfc000000));</code></li>
</ul>
<p>在第六章我们已经介绍过，在初始化阶段，内核已经把可用的<code>RAM</code>物理地址映射到虚拟地址空间第<code>4GB</code>的最初部分。因此，分页机制把出现在第 1 个语句中的虚拟地址 0xc00b0fe4映射回到原来的<code>I/O</code>物理地址 0x000b0fe4，正好落在从<code>640K</code>到<code>1MB</code>的这段“ISA`洞”中。这正是我们所期望的。</p>
<p>但是，对于第 2 个语句来说，这里有一个问题，因为其<code>I/O</code>物理地址超过了系统<code>RAM</code>的最大物理地址。因此，虚拟地址 0xfc000000 就不需要与物理地址 0xfc000000 相对应。在这种情况下，为了在内核页表中包括对这个<code>I/O</code>物理地址进行映射的虚拟地址，必须对页表进行修改：这可以通过调用<code>ioremap()</code>函数来实现。<code>ioremap()</code>和<code>vmalloc()</code>函数类似，都调用<code>get_vm_area()</code>建立一个新的<code>vm_struct</code>描述符，其描述的虚拟地址区间为所请求<code>I/O</code>空间区的大小。然后，<code>ioremap()</code>函数适当地更新所有进程的对应页表项。</p>
<p>因此，第 2 个语句的正确形式应该为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io_mem = ioremap(<span class="number">0xfb000000</span>, <span class="number">0x200000</span>);</span><br><span class="line">t2 = *((<span class="type">unsigned</span> <span class="type">char</span> *)(io_mem + <span class="number">0x100000</span>));</span><br></pre></td></tr></table></figure></p>
<p>第 1 条语句建立一个<code>2MB</code>的虚拟地址区间，从 0xfb000000 开始；第 2 条语句读取地址0xfc000000 的内存单元。驱动程序以后要取消这种映射，就必须使用<code>iounmap()</code>函数。</p>
<h3 id="设备驱动程序框架"><a href="#设备驱动程序框架" class="headerlink" title="设备驱动程序框架"></a>设备驱动程序框架</h3><p><code>Linux</code>的设备驱动程序可以分为以下 3 部分。</p>
<ol>
<li>驱动程序与内核的接口，这是通过数据结构<code>file_operations</code>来完成的。</li>
<li>驱动程序与系统引导的接口，这部分利用驱动程序对设备进行初始化。</li>
<li>驱动程序与设备的接口，这部分描述了驱动程序如何与设备进行交互，这与具体设备密切相关。</li>
</ol>
<p>根据功能，驱动程序的代码可以分为如下几个部分。</p>
<ol>
<li>驱动程序的注册和注销。</li>
<li>设备的打开与释放。</li>
<li>设备的读和写操作。</li>
<li>设备的控制操作。</li>
<li>设备的中断和查询处理。</li>
</ol>
<p>与读写操作不同，<code>ioctl()</code>的用法与具体设备密切相关，例如，对于软驱的控制可以使用<code>floppy_ioctl()</code>，其调用形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">floppy_ioctl</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> param)</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>cmd</code>的取值及含义与软驱有关，例如，<code>FDEJECT</code>表示弹出软盘。</p>
<p>除了<code>ioctl()</code>，设备驱动程序还可能有其他控制函数，如<code>lseek()</code>等。</p>
<h2 id="块设备驱动程序"><a href="#块设备驱动程序" class="headerlink" title="块设备驱动程序"></a>块设备驱动程序</h2><p>对于块设备来说，读写操作是以数据块为单位进行的，为了使高速的<code>CPU</code>同低速块设备能够协调工作，提高读写效率，操作系统设置了缓冲机制。当进行读写的时候，首先对缓冲区读写，只有缓冲区中没有需要读的数据或是需要写的数据没有地方写时，才真正地启动设备控制器去控制设备本身进行数据交换，而对于设备本身的数据交换同样也是同缓冲区打交道。</p>
<h3 id="块设备驱动程序的注册"><a href="#块设备驱动程序的注册" class="headerlink" title="块设备驱动程序的注册"></a>块设备驱动程序的注册</h3><p>对于块设备来说，驱动程序的注册不仅在其初始化的时候进行而且在编译的时候也要进行注册。在初始化时通过<code>register_blkdev()</code>函数将相应的块设备添加到数组<code>blkdevs</code>中，该数组在<code>fs/block_dev.c</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> *<span class="title">bdops</span>;</span></span><br><span class="line">&#125; blkdevs[MAX_BLKDEV];</span><br></pre></td></tr></table></figure></p>
<p>从<code>Linux 2.4</code>开始，块设备表的定义与下一节要介绍的字符设备表的定义有所不同。因为每种具体的块设备都有一套具体的操作，因而各自有一个类似于<code>file_operations</code>那样的数据结构，称为<code>block_device_operations</code>结构，其定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*check_media_change) (<span class="type">kdev_t</span>);</span><br><span class="line">	<span class="type">int</span> (*revalidate) (<span class="type">kdev_t</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果说<code>file_operation</code>结构是连接虚拟的<code>VFS</code>文件的操作与具体文件系统的文件操作之间的枢纽，那么<code>block_device_operations</code>就是连接抽象的块设备操作与具体块设备操作之间的枢纽。</p>
<p>具体的块设备是由主设备号唯一确定的，因此，主设备号唯一地确定了一个具体的<code>block_device_operations</code>数据结构。</p>
<p>下面我们来看<code>register_blkdev()</code>函数的具体实现，其代码在<code>fs/block_dev.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_blkdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> * name, <span class="keyword">struct</span> block_device_operations</span></span><br><span class="line"><span class="params">*bdops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (major == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (major = MAX_BLKDEV<span class="number">-1</span>; major &gt; <span class="number">0</span>; major--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (blkdevs[major].bdops == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				blkdevs[major].name = name;</span><br><span class="line">				blkdevs[major].bdops = bdops;</span><br><span class="line">				<span class="keyword">return</span> major;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (major &gt;= MAX_BLKDEV)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (blkdevs[major].bdops &amp;&amp; blkdevs[major].bdops != bdops)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	blkdevs[major].name = name;</span><br><span class="line">	blkdevs[major].bdops = bdops;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的第 1 个参数是主设备号，第 2 个参数是设备名称的字符串，第 3 个参数是指向具体设备操作的指针。如果一切顺利则返回 0，否则返回负值。如果指定的主设备号为 0，此函数将会搜索空闲的主设备号分配给该设备驱动程序并将其作为返回值。</p>
<p>那么，块设备注册到系统以后，怎样与文件系统联系起来呢，也就是说，文件系统怎么调用已注册的块设备，这还得从<code>file_operations</code>结构说起。</p>
<p>我们先来看一下块设备的<code>file_operations</code>结构的定义，其位于<code>fs/block_dev.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">def_blk_fops</span> =</span> &#123;</span><br><span class="line">	open: blkdev_open,</span><br><span class="line">	release: blkdev_close,</span><br><span class="line">	llseek: block_llseek,</span><br><span class="line">	read: generic_file_read, </span><br><span class="line">	write: generic_file_write,</span><br><span class="line">	mmap: generic_file_mmap,</span><br><span class="line">	fsync: block_fsync,</span><br><span class="line">	ioctl: blkdev_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面以<code>open()</code>系统调用为例，说明用户进程中的一个系统调用如何最终与物理块设备的操作联系起来。在此，我们仅仅给出几个<code>open()</code>函数的调用关系，如图 11.6 所示。<br><img src="/img/1634178117.jpg" alt=""></p>
<p>当调用<code>open()</code>系统调用时，其最终会调用到<code>def_blk_fops</code>的<code>blkdev_open()</code>函数。<code>blkdev_open()</code>函数的任务就是根据主设备号找到对应的<code>block_device_operations</code>结构，然后再调用<code>block_device_operations</code>结构中的函数指针<code>open</code>所指向的函数，如果<code>open</code>所指向的函数非空，就调用该函数打开最终的物理块设备。</p>
<p>这就简单地说明了块设备注册以后，从最上层的系统调用到具体地打开一个设备的过程。另外要说明的是 , 如果选择了通过设备文件系统<code>DevFS</code>进行注册，则调用<code>devfs_register_blkdev()</code>函数，该函数的说明及代码在<code>fs/devfs/base.c</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* devfs_register_blkdev - Optionally register a conventional block driver.</span></span><br><span class="line"><span class="comment"> * @major: The major number for the driver.</span></span><br><span class="line"><span class="comment"> * @name: The name of the driver (as seen in /proc/devices).</span></span><br><span class="line"><span class="comment"> * @bdops: The &amp;block_device_operations structure pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will register a block driver provided the &quot;devfs=only&quot;</span></span><br><span class="line"><span class="comment"> * option was not provided at boot time.</span></span><br><span class="line"><span class="comment"> * Returns 0 on success, else a negative error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">devfs_register_blkdev</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> block_device_operations *bdops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (boot_options &amp; OPTION_ONLY) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> register_blkdev (major, name, bdops);</span><br><span class="line">&#125; <span class="comment">/* End Function devfs_register_blkdev */</span> </span><br></pre></td></tr></table></figure></p>
<h3 id="块设备基于缓冲区的数据交换"><a href="#块设备基于缓冲区的数据交换" class="headerlink" title="块设备基于缓冲区的数据交换"></a>块设备基于缓冲区的数据交换</h3><p>关于块缓冲区的管理在中已有所描述，在这里我们从交换数据的角度来看一下基于缓冲区的数据交换的实现。</p>
<h4 id="扇区及块缓冲区"><a href="#扇区及块缓冲区" class="headerlink" title="扇区及块缓冲区"></a>扇区及块缓冲区</h4><p>块设备的每次数据传送操作都作用于一组相邻字节，我们称之为扇区。在大部分磁盘设备中，扇区的大小是 512 字节，但是现在新出现的一些设备使用更大的扇区(1024 和 2014字节)。注意，应该把扇区作为数据传送的基本单元：不允许传送少于一个扇区的数据，而大部分磁盘设备都可以同时传送几个相邻的扇区。</p>
<p>在<code>Linux</code>中，块大小必须是 2 的幂，而且不能超过一个页面。此外，它必须是扇区大小的整数倍，因为每个块必须包含整数个扇区。因此，在<code>PC</code>体系结构中，允许块的大小为 512、1024、2048 和 4096 字节。同一个块设备驱动程序可以作用于多个块大小，因为它必须处理共享同一主设备号的一组设备文件，而每个块设备文件都有自己预定义的块大小。</p>
<p>内核在一个名为<code>blksize_size</code>的表中存放块的大小；表中每个元素的索引就是相应块设备文件的主设备号和从设备号。如果<code>blksize_size[M]为</code>NULL，那么共享主设备号<code>M</code>的所有块设备都使用标准的块大小，即 1024 字节。</p>
<p>每个块都需要自己的缓冲区，它是内核用来存放块内容的<code>RAM</code>内存区。当设备驱动程序从磁盘读出一个块时，就用从硬件设备中所获得的值来填充相应的缓冲区；同样，当设备驱动程序向磁盘中写入一个块时，就用相关缓冲区的实际值来更新硬件设备上相应的一组相邻字节。缓冲区的大小一定要与块的大小相匹配。</p>
<h4 id="块驱动程序的体系结构"><a href="#块驱动程序的体系结构" class="headerlink" title="块驱动程序的体系结构"></a>块驱动程序的体系结构</h4><p>下面我们说明通用块驱动程序的体系结构，以及在为缓冲区<code>I/O</code>操作时所涉及的主要成分。</p>
<p>块设备驱动程序通常分为两部分，即高级驱动程序和低级驱动程序，前者处理<code>VFS</code>层，后者处理硬件设备，如图 11.7 所示。<br><img src="/img/1634178398.jpg" alt=""></p>
<p>假设进程对一个设备文件发出<code>read()</code>或<code>write()</code>系统调用。<code>VFS</code>执行对应文件对象的<code>read</code>或<code>write</code>方法，由此就调用高级块设备处理程序中的一个过程。这个过程执行的所有操作都与对这个硬件设备的具体读写请求有关。内核提供两个名为<code>generic_file_read ()</code>和<code>generic_file_write ()</code>通用函数来留意所有事件的发生。因此，在大部分情况下，高级硬件设备驱动程序不必做什么，而设备文件的<code>read</code>和<code>write</code>方法分别指向<code>generic_file_read()</code>和<code>generic_file_write ()</code>方法。</p>
<p>即使高级设备驱动程序有自己的<code>read</code>和<code>write</code>方法，但是这两个方法通常最终还会调用<code>generic_file_read ()</code>和<code>generic_file_write ()</code>函数。这些函数把对<code>I/O</code>设备文件的访问请求转换成对相应硬件设备的块请求。所请求的块可能已在主存，因此<code>generic_file_read ()</code>和<code>generic_file_write ()</code>函数调用<code>getblk()</code>函数来检查缓冲区中是否已经预取了块，还是从上次访问以来缓冲区一直都没有改变。如果块不在缓冲区中，<code>getblk()</code>就必须调用<code>ll_rw_block()</code>继续从磁盘中读取这个块，后面这个函数激活操纵设备控制器的低级驱动程序，以执行对块设备所请求的操作。</p>
<p>在<code>VFS</code>直接访问某一块设备上的特定块时，也会触发缓冲区<code>I/O</code>操作。例如，如果内核必须从磁盘文件系统中读取一个索引节点，那么它必须从相应磁盘分区的块中传送数据 。对于特定块的直接访问是由<code>bread()</code>和<code>breada()</code>函数来执行的，这两个函数又会调用前面提到过的<code>getblk()</code>和<code>ll_rw_block()</code>函数。</p>
<h4 id="块设备请求"><a href="#块设备请求" class="headerlink" title="块设备请求"></a>块设备请求</h4><p>虽然块设备驱动程序可以一次传送一个单独的数据块，但是内核并不会为磁盘上每个被访问的数据块都单独执行一次<code>I/O</code>操作：这会导致磁盘性能的下降，因为确定磁盘表面块的物理位置是相当费时的。取而代之的是，只要可能，内核就试图把几个块合并在一起，并作为一个整体来处理，这样就减少了磁头的平均移动时间。</p>
<p>当进程、<code>VFS</code>层或者任何其他的内核部分要读写一个磁盘块时，就真正引起一个块设备请求。从本质上说，这个请求描述的是所请求的块以及要对它执行的操作类型(读还是写)。然而，并不是请求一发出，内核就满足它，实际上，块请求发出时<code>I/O</code>操作仅仅被调度，稍后才会被执行。这种人为的延迟有悖于提高块设备性能的关键机制。当请求传送一个新的数据块时，内核检查能否通过稍微扩大前一个一直处于等待状态的请求而满足这个新请求。由于磁盘的访问大都是顺序的，因此这种简单机制就非常高效。</p>
<p>每个块设备驱动程序都维护自己的请求队列；每个物理块设备都应该有一个请求队列，以提高磁盘性能的方式对请求进行排序。因此策略程序就可以顺序扫描这种队列，并以最少地移动磁头而为所有的请求提供服务。</p>
<p>每个块设备请求都是由一个<code>request</code>结构来描述的，其定义于<code>include/linux/blkdev.h</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ok, this is an expanded form so that we can use the same</span></span><br><span class="line"><span class="comment"> * request for paging requests.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>;</span></span><br><span class="line">	<span class="type">int</span> elevator_sequence;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> rq_status; <span class="comment">/* should split this into a few status bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RQ_INACTIVE (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RQ_ACTIVE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RQ_SCSI_BUSY 0xffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RQ_SCSI_DONE 0xfffe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RQ_SCSI_DISCONNECTING 0xffe0</span></span><br><span class="line">	<span class="type">kdev_t</span> rq_dev;</span><br><span class="line">	<span class="type">int</span> cmd; <span class="comment">/* READ or WRITE */</span></span><br><span class="line">	<span class="type">int</span> errors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sector;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_sectors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> hard_sector, hard_nr_sectors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nr_segments;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nr_hw_segments;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> current_nr_sectors; </span><br><span class="line">	<span class="type">void</span> * special;</span><br><span class="line">	<span class="type">char</span> * buffer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> * <span class="title">waiting</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bhtail</span>;</span></span><br><span class="line">	<span class="type">request_queue_t</span> *q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们把<code>struct request</code>叫做请求描述符。</p>
<p>数据传送的方向存放在<code>cmd</code>域中：该值可能是<code>READ</code>(把数据从块设备读到<code>RAM</code>中)或者<code>WRITE</code>(把数据从<code>RAM</code>写到块设备中)。<code>rq_status</code>域用来定义请求的状态：对于大部分块设备来说，这个域的值可能为<code>RQ_INACTIVE</code>(请求描述符还没有使用)或者<code>RQ_ACTIVE</code>(有效的请求，低级设备驱动程序要对其服务或正在对其服务)。</p>
<p>一次请求可能包括同一设备中的很多相邻块。<code>rq_dev</code>域指定块设备，而<code>sector</code>域说明请求中第一个块对应的第一个扇区的编号。<code>nr_sector</code>和<code>current_nr_sector</code>给出要传送数据的扇区数。<code>sector</code>、<code>nr_sector</code>和<code>current_nr_sector</code>域都可以在请求得到服务的过程中而被动态修改。</p>
<p>请求块的所有缓冲区首部都被集中在一个简单链表中。每个缓冲区首部的<code>b_reqnext</code>域指向链表中的下一个元素，而请求描述符的<code>bh</code>和<code>bhtail</code>域分别指向链表的第一个元素和最后一个元素。</p>
<p>请求描述符的<code>buffer</code>域指向实际数据传送所使用的内存区。如果只请求一个单独的块，那么缓冲区只是缓冲区首部的<code>b_data</code>域的一个拷贝。然而，如果请求了多个块，而这些块的缓冲区在内存中又不是连续的，那么就使用缓冲区首部的<code>b_reqnext</code>域把这些缓冲区链接在一起。对于读操作来说，低级设备驱动程序可以选择先分配一个大的内存区来立即读取请求的所有扇区，然后再把这些数据拷贝到各个缓冲区。同样，对于写操作来说。</p>
<p>另外，在严重负载和磁盘操作频繁的情况下，固定数目的请求描述符就可能成为一个瓶颈。空闲描述符的缺乏可能会强制进程等待直到正在执行的数据传送结束。因此，<code>request_queue_t</code>类型(见下面)中的<code>wait_for_request</code>等待队列就用来对正在等待空闲请求描述符的进程进行排队。<code>get_request_wait()</code>试图获取一个空闲的请求描述符，如果没有找到，就让当前进程在等待队列中睡眠；<code>get_request()</code>函数与之类似，但是如果没有可用的空闲请求描述符，它只是简单地返回<code>NULL</code>。</p>
<h4 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h4><p>请求队列只是一个简单的链表，其元素是请求描述符。每个请求描述符中的<code>next</code>域都指向请求队列的下一个元素，最后一个元素为空。这个链表的排序通常是：首先根据设备标识符，其次根据最初的扇区号。</p>
<p>如前所述，对于所服务的每个硬盘，设备驱动程序通常都有一个请求队列。然而，一些设备驱动程序只有一个请求队列，其中包括了由这个驱动器处理的所有物理设备的请求。这种方法简化了驱动程序的设计，但是损失了系统的整体性能，因为不能对队列强制使用简单排序的策略。请求队列定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* the queue request freelist, one for reads and one for writes</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_list</span> <span class="title">rq</span>[2];</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Together with queue_head for cacheline sharing</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue_head</span>;</span></span><br><span class="line">	<span class="type">elevator_t</span> elevator;</span><br><span class="line">	request_fn_proc * request_fn;</span><br><span class="line">	merge_request_fn * back_merge_fn;</span><br><span class="line">	merge_request_fn * front_merge_fn;</span><br><span class="line">	merge_requests_fn * merge_requests_fn;</span><br><span class="line">	make_request_fn * make_request_fn;</span><br><span class="line">	plug_device_fn * plug_device_fn;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* The queue owner gets to use this for whatever they like.</span></span><br><span class="line"><span class="comment">	* ll_rw_blk doesn&#x27;t touch it.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">void</span> * queuedata;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* This is used to remove the plug when tq_disk runs.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tq_struct</span> <span class="title">plug_tq</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Boolean that indicates whether this queue is plugged or not.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">char</span> plugged;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Boolean that indicates whether current_request is active or</span></span><br><span class="line"><span class="comment">	* not.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">char</span> head_active;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Is meant to protect the queue in the future instead of</span></span><br><span class="line"><span class="comment">	* io_request_lock</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">spinlock_t</span> queue_lock;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	* Tasks wait here for free request</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> wait_for_request;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> <span class="title">request_queue_t</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>request_list</code>为请求描述符组成的空闲链表，其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_list</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">free</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>有两个这样的链表，一个用于读，一个用于写。</p>
<p><code>elevator_t</code>结构描述的是为磁盘的电梯调度算法而设的数据结构。从<code>request_fn_proc</code>到<code>plug_device_fn</code>都是一些函数指针。例如<code>request_fn</code>是一个指针，指向类型为<code>request_fn_proc</code>的对象。而<code>request_fn_proc</code>则通过<code>#typedef</code>定义为一种函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(request_fn_proc)</span> <span class="params">(<span class="type">request_queue_t</span> *q)</span></span><br></pre></td></tr></table></figure></p>
<p>其余的函数也与此类似，这些指针(连同其他域)都是在相应设备初始化时设置好的。需要对一个块设备进行操作时，就为之设置好一个数据结构<code>request_queue</code>。并将其挂入相应的请求队列中。</p>
<p>这里要说明的是，<code>request_fn()</code>域包含驱动程序的策略程序的地址，策略程序是低级块设备驱动程序的关键函数，为了开始传送队列中的一个请求所指定的数据，它与物理块设备(通常是磁盘控制器)真正打交道。</p>
<h4 id="块设备驱动程序描述符"><a href="#块设备驱动程序描述符" class="headerlink" title="块设备驱动程序描述符"></a>块设备驱动程序描述符</h4><p>驱动程序描述符是一个<code>blk_dev_struct</code>类型的数据结构，其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* queue_proc has to be atomic</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">request_queue_t</span> request_queue;</span><br><span class="line">	queue_proc *<span class="built_in">queue</span>;</span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个结构中，其主体是请求队列<code>request_queue</code>；此外，还有一个函数指针<code>queue</code>，当这个指针为非 0 时，就调用这个函数来找到具体设备的请求队列，这是为考虑具有同一主设备号的多种同类设备而设的一个域。这个指针也在设备初始化时就设置好，另一个指针<code>data</code>是辅助<code>queue</code>函数找到特定设备的请求队列。</p>
<p>所有块设备的描述符都存放在<code>blk_dev</code>表中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> <span class="title">blk_dev</span>[<span class="title">MAX_BLKDEV</span>];</span></span><br></pre></td></tr></table></figure></p>
<p>每个块设备都对应着数组中的一项，可以用主设备号进行检索。每当用户进程对一个块设备发出一个读写请求时，首先调用块设备所公用的函数<code>generic_file_read ()</code>和<code>generic_file_write()</code>，如果数据存在缓冲区中或缓冲区还可以存放数据，就同缓冲区进行数据交换。否则，系统会将相应的请求队列结构添加到其对应项的<code>blk_dev_struct</code>中，如图 11.8 所示。如果在加入请求队列结构的时候该设备没有请求，则马上响应该请求，否则将其追加到请求任务队列尾顺序执行。</p>
<p>图 11.8 表示每个请求有指向一个或多个<code>buffer_hear</code>结构的指针，每个请求读写一块数据。如果系统对<code>buffer_head</code>结构上锁, 则进程会等待到对此缓冲区的块操作完成。一旦设备驱动程序完成了请求则它必须将每个<code>buffer_heard</code>结构从<code>request</code>结构中清除，将它们标记成已更新状态并对它们解锁。对<code>buffer_head</code>的解锁将唤醒所有等待此块操作完成的睡眠进程，然后<code>request</code>数据结构被标记成空闲以便被其他块请求使用。<br><img src="/img/1634178725.jpg" alt=""></p>
<h3 id="块设备驱动程序的几个函数"><a href="#块设备驱动程序的几个函数" class="headerlink" title="块设备驱动程序的几个函数"></a>块设备驱动程序的几个函数</h3><p>所有对块设备的读写都是调用<code>generic_file_read ()</code>和<code>generic_file_write ()</code>函数，这两个函数的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">generic_file_read</span><span class="params">(<span class="keyword">struct</span> file * filp, <span class="type">char</span> * buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">generic_file_write</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> *buf,<span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br></pre></td></tr></table></figure></p>
<p>其参数的含义如下。</p>
<ul>
<li><code>filp</code>：和这个设备文件相对应的文件对象的地址。</li>
<li><code>buf</code>：用户态地址空间中的缓冲区的地址。<code>generic_file_read()</code>把从块设备中读出的数据写入这个缓冲区；反之，<code>generic_file_write()</code>从这个缓冲区中读取要写入块设备的数据。</li>
<li><code>count</code>：要传送的字节数。</li>
<li><code>ppos</code>：设备文件中的偏移变量的地址；通常，这个参数指向<code>filp-&gt;f_pos</code>，也就是说，指向设备文件的文件指针。</li>
</ul>
<p>只要进程对设备文件发出读写操作，高级设备驱动程序就调用这两个函数。例如，<code>superformat</code>程序通过把块写入<code>/dev/fd0</code>设备文件来格式化磁盘，相应文件对象的<code>write</code>方法就调用<code>generic_file_write()</code>函数。这两个函数所做的就是对缓冲区进行读写，如果缓冲区不能满足操作要求则返回负值，否则返回实际读写的字节数。每个块设备在需要读写时都调用这两个函数。</p>
<p>下面介绍几个低层被频繁调用的函数。<br><code>bread()</code>和<code>breada()</code>函数：<code>bread()</code>函数检查缓冲区中是否已经包含了一个特定的块；如果还没有，该函数就从块设备中读取这个块。文件系统广泛使用<code>bread()</code>从磁盘位图、索引节点以及其他基于块的数据结构中读取数据(注意当进程要读块设备文件时是使用<code>generic_file_read()</code>函数，而不是使用<code>bread()</code>函数)。该函数接收设备标志符、块号和块大小作为参数，其代码在fs/buffer.c`中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bread() - reads a specified block and returns the bh</span></span><br><span class="line"><span class="comment"> * @block: number of block</span></span><br><span class="line"><span class="comment"> * @size: size (in bytes) to read</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Reads a specified block, and returns buffer head that</span></span><br><span class="line"><span class="comment"> * contains it. It returns NULL if the block was unreadable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">bread</span><span class="params">(<span class="type">kdev_t</span> dev, <span class="type">int</span> block, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	bh = getblk(dev, block, size);</span><br><span class="line">	touch_buffer(bh);</span><br><span class="line">	<span class="keyword">if</span> (buffer_uptodate(bh))</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">	ll_rw_block(READ, <span class="number">1</span>, &amp;bh);</span><br><span class="line">	wait_on_buffer(bh);</span><br><span class="line">	<span class="keyword">if</span> (buffer_uptodate(bh))</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对该函数解释如下。</p>
<ul>
<li>调用<code>getblk()</code>函数来查找缓冲区中的一个块；如果这个块不在缓冲区中，那么<code>getblk()</code>就为它分配一个新的缓冲区。</li>
<li>调用<code>buffer_uptodate()</code>宏来判断这个缓冲区是否已经包含最新数据，如果是，则<code>getblk()</code>结束。</li>
<li>如果缓冲区中没有包含最新数据，就调用<code>ll_rw_block()</code>函数启动读操作。</li>
<li>等待，直到数据传送完成为止。这是通过调用一个名为<code>wait_on_buffer()</code>的函数来实现的，该函数把当前进程插入<code>b_wait</code>等待队列中，并挂起当前进程直到这个缓冲区被开锁为止。</li>
</ul>
<p><code>breada()</code>和<code>bread()</code>十分类似，但是它除了读取所请求的块之外，还要另外预读一些其他块。注意不存在把块直接写入磁盘的函数。写操作永远都不会成为系统性能的瓶颈，因为写操作通常都会延时。</p>
<h4 id="ll-rw-block-函数"><a href="#ll-rw-block-函数" class="headerlink" title="ll_rw_block()函数"></a>ll_rw_block()函数</h4><p><code>ll_rw_block()</code>函数产生块设备请求；内核和设备驱动程序的很多地方都会调用这个函数。该函数的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ll_rw_block</span><span class="params">(<span class="type">int</span> rw, <span class="type">int</span> nr, <span class="keyword">struct</span> buffer_head * bhs[])</span></span><br></pre></td></tr></table></figure></p>
<p>其参数的含义如下。</p>
<ul>
<li>操作类型<code>rw</code>，其值可以是<code>READ</code>、<code>WRITE</code>、<code>READA</code>或者<code>WRITEA</code>。最后两种操作类型和前两种操作类型之间的区别在于，当没有可用的请求描述符时后两个函数不会阻塞。</li>
<li>要传送的块数<code>nr</code>。</li>
<li>一个<code>bhs</code>数组，有<code>nr</code>个指针，指向说明块的缓冲区首部(这些块的大小必须相同，而且必须处于同一个块设备)。</li>
</ul>
<p>该函数的代码在<code>block/ll_rw_blk.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ll_rw_block</span><span class="params">(<span class="type">int</span> rw, <span class="type">int</span> nr, <span class="keyword">struct</span> buffer_head * bhs[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> major;</span><br><span class="line">	<span class="type">int</span> correct_size;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (!nr)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	major = MAJOR(bhs[<span class="number">0</span>]-&gt;b_dev);</span><br><span class="line">	<span class="comment">/* Determine correct block size for this device. */</span></span><br><span class="line">	correct_size = get_hardsect_size(bhs[<span class="number">0</span>]-&gt;b_dev);</span><br><span class="line">	<span class="comment">/* Verify requested block sizes. */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span> =</span> bhs[i];</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_size % correct_size) &#123;</span><br><span class="line">			printk(KERN_NOTICE <span class="string">&quot;ll_rw_block: device %s: &quot;</span></span><br><span class="line">			<span class="string">&quot;only %d-char blocks implemented (%u)\n&quot;</span>,</span><br><span class="line">			kdevname(bhs[<span class="number">0</span>]-&gt;b_dev),</span><br><span class="line">			correct_size, bh-&gt;b_size);</span><br><span class="line">			<span class="keyword">goto</span> sorry;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((rw &amp; WRITE) &amp;&amp; is_read_only(bhs[<span class="number">0</span>]-&gt;b_dev)) &#123;</span><br><span class="line">		printk(KERN_NOTICE <span class="string">&quot;Can&#x27;t write to read-only device %s\n&quot;</span>,</span><br><span class="line">		kdevname(bhs[<span class="number">0</span>]-&gt;b_dev));</span><br><span class="line">		<span class="keyword">goto</span> sorry;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span> =</span> bhs[i];</span><br><span class="line">		<span class="comment">/* Only one thread can actually submit the I/O. */</span></span><br><span class="line">		<span class="keyword">if</span> (test_and_set_bit(BH_Lock, &amp;bh-&gt;b_state))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/* We have the buffer lock */</span></span><br><span class="line">		<span class="type">atomic_inc</span>(&amp;bh-&gt;b_count);</span><br><span class="line">		bh-&gt;b_end_io = end_buffer_io_sync;</span><br><span class="line">		<span class="keyword">switch</span>(rw) &#123;</span><br><span class="line">			<span class="keyword">case</span> WRITE:</span><br><span class="line">				<span class="keyword">if</span> (!atomic_set_buffer_clean(bh))</span><br><span class="line">				<span class="comment">/* Hmmph! Nothing to write */</span></span><br><span class="line">				<span class="keyword">goto</span> end_io;</span><br><span class="line">				__mark_buffer_clean(bh);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> READA:</span><br><span class="line">			<span class="keyword">case</span> READ:</span><br><span class="line">				<span class="keyword">if</span> (buffer_uptodate(bh))</span><br><span class="line">				<span class="comment">/* Hmmph! Already have it */</span></span><br><span class="line">				<span class="keyword">goto</span> end_io;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				BUG();</span><br><span class="line">end_io:</span><br><span class="line">			bh-&gt;b_end_io(bh, test_bit(BH_Uptodate, &amp;bh-&gt;b_state));</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		submit_bh(rw, bh);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">sorry:</span><br><span class="line">	<span class="comment">/* Make sure we don&#x27;t get infinite dirty retries.. */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr; i++)</span><br><span class="line">		mark_buffer_clean(bhs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面对该函数给予解释。<br>进入<code>ll_rw_block()</code>以后，先对块大小作一些检查；如果是写访问，则还要检查目标设备是否可写。内核中有个二维数组<code>ro_bits</code>，定义于<code>drivers/block/ll_rw_blk.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> ro_bits[MAX_BLKDEV][<span class="number">8</span>];</span><br></pre></td></tr></table></figure></p>
<p>每个设备在这个数组中都有个标志，通过系统调用<code>ioctl()</code>可以将一个标志位设置成 1或 0，表示相应设备为只读或可写，而<code>is_read_only()</code>就是检查这个数组中的标志位是否为 1。 </p>
<p>接下来，就通过第 2 个<code>for</code>循环依次处理对各个缓冲区的读写请求了。对于要读写的每个块，首先将其缓冲区加上锁，还要将其<code>buffer_head</code>结构中的函数指针<code>b_end_io</code>设置成指向<code>end_buffer_io_sync</code>，当完成对给定块的读写时，就调用该函数。此外，对于待写的缓冲区，其<code>BH_Dirty</code>标志位应该为 1，否则就不需要写了，而既然写了，就要把它清 0，并通过<code>__mark_buffer_clean(bh)</code>将缓冲区转移到干净页面的<code>LRU</code>队列中。反之，对于待读的缓冲区，其<code>buffer_uptodate()</code>标志位为 0，否则就不需要读了。每个具体的设备就好像是个服务器，所以最后具体的读写是通过<code>submit_bh()</code>将读写请求提交各“服务器”完成的，每次读写一个块，该函数的代码也在同一文件中，读者可以自己去读。</p>
<h3 id="RAM盘驱动程序的实现"><a href="#RAM盘驱动程序的实现" class="headerlink" title="RAM盘驱动程序的实现"></a>RAM盘驱动程序的实现</h3><h4 id="RAM盘的硬件"><a href="#RAM盘的硬件" class="headerlink" title="RAM盘的硬件"></a>RAM盘的硬件</h4><p>利用<code>RAM</code>盘的驱动程序可以访问内存的任何部分，它的主要用途是保留一部分内存并象普通磁盘一样来使用它。</p>
<p><code>RAM</code>盘的思想很简单，块设备是有两个操作的命令的存储介质：即写数据块和读数据块。通常这些数据存储于旋转存储设备上如软盘和硬盘，<code>RAM</code>盘则简单得多，它利用预先分配的主存来存储数据块。因此不存在像磁盘那样的寻道操作，其读写操作只是在内存间进行的。<code>RAM</code>盘具有快速存取的优点(没有寻道和旋转延迟的时间)，适合于存储需要频繁存取的数据。</p>
<h4 id="Linux中RAM盘的驱动程序"><a href="#Linux中RAM盘的驱动程序" class="headerlink" title="Linux中RAM盘的驱动程序"></a>Linux中RAM盘的驱动程序</h4><p><code>RAM</code>盘的驱动程序同其他所有的驱动程序一样都是由一组函数组成，对<code>RAM</code>盘的操作实际上是对内存的操作，它不需要中断机制，故<code>RAM</code>盘的驱动程序不包括中断服务子程序.。一般我们对于一个驱动程序的分析是在了解硬件的基础上从该设备所提供的操作入手的，相应的写驱动程序也应该是这样的。</p>
<p>下面是<code>RAM</code>盘操作的结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> <span class="title">rd_bd_op</span> =</span> &#123;</span><br><span class="line">	owner: THIS_MODULE,</span><br><span class="line">	open: rd_open,</span><br><span class="line">	ioctl: rd_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Linux</code>中，<code>RAM</code>盘的主设备号是 1。在<code>rd_open()</code>函数中，它首先检测设备号<code>INITRD_MINOR</code>，由于<code>INITRD</code>是在系统一启动的时候就已经创建，其中映像的是操作系统从偏移地址 0 开始的内容，即内核空间，如果是内核空间，其接口需要相应的发生变换即：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filp-&gt;f_op = &amp;initrd_fops。</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> file_operations initrd_fops = &#123; </span><br><span class="line">	read: initrd_read,</span><br><span class="line">	release: initrd_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于<code>INITRD</code>盘的操作用户只有读和释放的权限而无写的权限。<code>initrd_read()</code>函数执行的是从内核区进行的读操作，故而是利用<code>memcpy_tofs (buf，(char *)initrd_start+file-&gt;f_pos, count)</code>去完成的。</p>
<p><code>initrd_release()</code>函数在判断没有用户操作这个设备之后，以页的方式把<code>INITRD</code>盘所占的内存释放掉。</p>
<p>在普通<code>RAM</code>盘接口中的另一个函数为<code>rd_ioctl()</code>，同其他设备驱动程序一样是执行一些输入/输出的控制操作。</p>
<h3 id="硬盘驱动程序的实现"><a href="#硬盘驱动程序的实现" class="headerlink" title="硬盘驱动程序的实现"></a>硬盘驱动程序的实现</h3><h4 id="Linux中硬盘驱动程序的实现"><a href="#Linux中硬盘驱动程序的实现" class="headerlink" title="Linux中硬盘驱动程序的实现"></a>Linux中硬盘驱动程序的实现</h4><p>将要讨论的驱动程序在<code>drivers/ide/hd.c</code>中，在文件为<code>include/linux/hdreg.h</code>中，定义了控制器寄存器、状态位和命令、数据结构和原形。这些宏定义可以根据其名字并结合上面所说的硬件内容去理解。</p>
<p><code>Linux</code>中，硬盘被认为是计算机的最基本的配置，所以在装载内核的时候，硬盘驱动程序必须就被编译进内核，不能作为模块编译。硬盘驱动程序提供内核的接口为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> <span class="title">hd_fops</span> =</span> &#123;</span><br><span class="line">	open: hd_open,</span><br><span class="line">	release: hd_release,</span><br><span class="line">	ioctl: hd_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对硬盘的操作只有 3 个函数。我们来看一下<code>hd_open ()</code>和<code>hd_release ()</code>函数，打开操作首先检测了设备的有效性，接着测试了它的忙标志，最后对请求硬盘的总数加 1，来标识对硬盘的请求个数，<code>hd_release()</code>函数则将请求的总数减 1。</p>
<p>前面说过，对于块设备的读写操作是先对缓冲区操作，但是当需要真正同硬盘交换数据的时候，驱动程序又干了些什么？在<code>hd.c</code>中有一个函数<code>hd_out()</code>，可以说它在实际的数据交换中起着主要的作用。它的原形是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hd_out</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> drive,<span class="type">unsigned</span> <span class="type">int</span> nsect,<span class="type">unsigned</span> <span class="type">int</span> sect,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> head,<span class="type">unsigned</span> <span class="type">int</span> cyl,<span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> (*intr_addr)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure></p>
<p>其中参数<code>drive</code>是进行操作的设备号；<code>nsect</code>是每次读写的扇区数；<code>sect</code>是读写的开始扇区号；<code>head</code>是读写的磁头号；<code>cmd</code>是操作命令控制命令字。</p>
<p>通过这个函数向硬盘控制器的寄存器中写入数据，启动硬盘进行实际的操作。同时这个函数也配合完成<code>cmd</code>命令相应的中断服务子程序，通过<code>SET_INIT(intr_addr)</code>宏定义将其地址赋给<code>DEVICE_INTR</code>。</p>
<p><code>hd_request()</code>函数就是通过这个函数进行实际的数据交换，同其他驱动程序不同的是该函数还要根据每个命令的不同来确定一些参数，最基本的是读写方式的确定，关于硬盘的读写方式有两种，一种是单扇区的读写，另一种是多扇区的读写，单扇区的读写是指每次操作只对一个扇区操作，而多扇区则指每次对多个扇区进行操作，不同的方式其中断服务子程序不同，其相应的地址就作为参数传给<code>hd_out()</code>，由它设置<code>DEVICE_INIT</code>。<code>hd_request()</code>函数确定的其他参数也就是<code>hd_out()</code>所需要的参数。</p>
<p>我们知道块设备的实际数据交换需要中断服务子程序的配合，在本驱动程序中的中断服务子程序有以下几个主要函数。</p>
<ul>
<li><code>void unexpected_hd_interrupt(void)</code><ul>
<li>功能：对不期望的中断进行处理(设置<code>SET_TIMER</code>)。</li>
</ul>
</li>
<li><code>static void bad_rw_intr(void)</code><ul>
<li>功能：当硬盘的读写操作出现错误时进行处理。<ul>
<li>每重复 4 次磁头复位；</li>
<li>每重复 8 次控制器复位；</li>
<li>每重复 16 次放弃操作。</li>
</ul>
</li>
</ul>
</li>
<li><code>static void recal_intr(void)</code><ul>
<li>功能：重新进行硬盘的本次操作。</li>
</ul>
</li>
<li><code>static void read_intr(void)</code><ul>
<li>功能：从硬盘读数据到缓冲区。</li>
</ul>
</li>
<li><code>static void write_intr(void)</code><ul>
<li>功能：从缓冲区读数据到硬盘。</li>
</ul>
</li>
<li><code>static void hd_interupt(void)</code><ul>
<li>功能：决定硬盘中断所要调用的中断程序。</li>
</ul>
</li>
</ul>
<p>在注册的时候，同硬盘中断联系的是<code>hd_interupt()</code>，也就是说当硬盘中断到来的时候，执行的函数是<code>hd_interupt()</code>，在此函数中调用<code>DEVICE_INTR</code>所指向的中断函数，如果<code>DEVICE_INTR</code>为空，则执行<code>unexpected_hd_interrupt()</code>函数。</p>
<p>对硬盘的操作离不开控制寄存器，为了控制磁盘要经常去检测磁盘的运行状态，在本驱动程序中有一系列的函数是完成这项工作的，<code>check_status()</code>检测硬盘的运行状态，如果出现错误则进行处理。<code>contorller_ready()</code>检测控制器是否准备好。<code>drive_busy()</code>检测硬盘设备是否处于忙态。当出现错误的时候，由<code>dump_status()</code>函数去检测出错的原因。<code>wait_DRQ()</code>对数据请求位进行测试。</p>
<p>当硬盘的操作出现错误的时候，硬盘驱动程序会把它尽量在接近硬件的地方解决掉，其方法是进行重复操作，这些在<code>bad_rw_intr()</code>中进行，与其相关的函数有<code>reset_controller()</code>和<code>reset_hd()</code>。</p>
<p>函数<code>hd_init()</code>是对硬盘进行初始化的，这个函数的过程同其他块设备基本一致。</p>
<h2 id="字符设备驱动程序"><a href="#字符设备驱动程序" class="headerlink" title="字符设备驱动程序"></a>字符设备驱动程序</h2><h3 id="简单字符设备驱动程序"><a href="#简单字符设备驱动程序" class="headerlink" title="简单字符设备驱动程序"></a>简单字符设备驱动程序</h3><p>我们来看一个最简单的字符设备，即“空设备”<code>/dev/null</code>，这个设备的主设备号为 1。如前所述，主设备号为 1 的设备其实不是“设备”，而都是与内存有关，或是在内存中(不必通过外设)就可以提供的功能，所以其主设备号标识符为<code>MEM_MAJOR</code>，其定义于<code>include/linux/major.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_MAJOR 1</span></span><br></pre></td></tr></table></figure></p>
<p>其<code>file_operatins</code>结构为<code>memory_fops</code>，定义于<code>dreivers/char/mem.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">memory_fops</span> =</span> &#123;</span><br><span class="line">	open: memory_open, <span class="comment">/* just a selector for the real open */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因为主设备号为 1 的字符设备并不能唯一地确定具体的设备驱动程序，因此需要根据从设备号来进行进一步的区分，所以<code>memory_fops</code>还不是最终的<code>file_operations</code>结构，还需要由<code>memory_open()</code>进一步加以确定和设置，其代码在同一文件中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">memory_open</span><span class="params">(<span class="keyword">struct</span> inode * inode, <span class="keyword">struct</span> file * filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (MINOR(inode-&gt;i_rdev)) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		filp-&gt;f_op = &amp;mem_fops;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		filp-&gt;f_op = &amp;kmem_fops;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		filp-&gt;f_op = &amp;null_fops;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	…</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (filp-&gt;f_op &amp;&amp; filp-&gt;f_op-&gt;open)</span><br><span class="line">		<span class="keyword">return</span> filp-&gt;f_op-&gt;open(inode,filp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为<code>/dev/null</code>的从设备号为 3，所以其<code>file_operations</code>结构为<code>null_fops</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">null_fops</span> =</span> &#123;</span><br><span class="line">	llseek: null_lseek,</span><br><span class="line">	read: read_null,</span><br><span class="line">	write: write_null,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于这个结构中函数指针<code>open</code>为<code>NULL</code>，因此在打开这个文件时没有任何附加操作。当通过<code>write()</code>系统调用写这个文件时，相应的驱动函数为<code>write_null()</code>，其代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_null</span><span class="params">(<span class="keyword">struct</span> file * file, <span class="type">const</span> <span class="type">char</span> * buf,</span></span><br><span class="line"><span class="params">	<span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从中可以看出，这个函数什么也没做，仅仅返回<code>count</code>，假装要求写入的字节已经写好了，而实际把写的内容丢弃了。</p>
<p>再来看一下读操作又做了些什么，<code>read_null()</code>的代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_null</span><span class="params">(<span class="keyword">struct</span> file * file, <span class="type">char</span> * buf,</span></span><br><span class="line"><span class="params"> <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回 0 表示从这个文件读了 0 个字节，但是并没有到达(永远也不会到达)文件的末尾。当然，字符设备的驱动程序不会都这么简单，但是总的框架是一样的。 </p>
<h3 id="字符设备驱动程序的注册"><a href="#字符设备驱动程序的注册" class="headerlink" title="字符设备驱动程序的注册"></a>字符设备驱动程序的注册</h3><p>具有相同主设备号和类型的每类设备文件都是由<code>device_struct</code>数据结构来描述的，该结构定义于<code>fs/devices.c</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_struct</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> * <span class="title">fops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>name</code>是某类设备的名字，<code>fops</code>是指向文件操作表的一个指针。所有字符设备文件的<code>device_struct</code>描述符都包含在<code>chrdevs</code>表中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_struct</span> <span class="title">chrdevs</span>[<span class="title">MAX_CHRDEV</span>];</span></span><br></pre></td></tr></table></figure></p>
<p>该表包含有 255 个元素，每个元素对应一个可能的主设备号，其中主设备号 255 为将来的扩展而保留的。表的第一项为空，因为没有一个设备文件的主设备号是 0。</p>
<p><code>chrdevs</code>表最初为空。<code>register_chrdev()</code>函数用来向其中的一个表中插入一个新项，而<code>unregister_chrdev()</code>函数用来从表中删除一个项。我们来看一下<code>register_chrdev()</code>的具体实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> * name, <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (major == <span class="number">0</span>) &#123;</span><br><span class="line">		write_lock(&amp;chrdevs_lock);</span><br><span class="line">		<span class="keyword">for</span> (major = MAX_CHRDEV<span class="number">-1</span>; major &gt; <span class="number">0</span>; major--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (chrdevs[major].fops == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				chrdevs[major].name = name;</span><br><span class="line">				chrdevs[major].fops = fops;</span><br><span class="line">				write_unlock(&amp;chrdevs_lock);</span><br><span class="line">				<span class="keyword">return</span> major;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		write_unlock(&amp;chrdevs_lock);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (major &gt;= MAX_CHRDEV)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	write_lock(&amp;chrdevs_lock);</span><br><span class="line">	<span class="keyword">if</span> (chrdevs[major].fops &amp;&amp; chrdevs[major].fops != fops) &#123;</span><br><span class="line">		write_unlock(&amp;chrdevs_lock);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	chrdevs[major].name = name;</span><br><span class="line">	chrdevs[major].fops = fops;</span><br><span class="line">	write_unlock(&amp;chrdevs_lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码可以看出，如果参数<code>major</code>为 0，则由系统自动分配第 1 个空闲的主设备号，并把设备名和文件操作表的指针置于<code>chrdevs</code>表的相应位置。</p>
<p>例如，可以按如下方式把并口打印机驱动程序的相应结构插入到<code>chrdevs</code>表中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register_chrdev(<span class="number">6</span>, <span class="string">&quot;lp&quot;</span>, &amp;lp_fops); </span><br></pre></td></tr></table></figure></p>
<p>该函数的第 1 个参数表示主设备号，第 2 个参数表示设备类名，最后一个参数是指向文件操作表的一个指针。</p>
<p>如果设备驱动程序被静态地加入内核，那么，在系统初始化期间就注册相应的设备文件类。但是，如果设备驱动程序作为模块被动态装入内核，那么，对应的设备文件在装载模块时被注册，在卸载模块时被注销。</p>
<p>字符设备被注册以后，它所提供的接口，即<code>file_operations</code>结构在<code>fs/devices.c</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Dummy default file-operations: the only thing this does</span></span><br><span class="line"><span class="comment"> * is contain the open that then fills in the correct operations</span></span><br><span class="line"><span class="comment"> * depending on the special file...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">def_chr_fops</span> =</span> &#123;</span><br><span class="line">	open: chrdev_open,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于字符设备的多样性，因此，这个缺省的<code>file_operations</code>仅仅提供了打开操作，具体字符设备文件的<code>file_operations</code>由<code>chrdev_open()</code>函数决定：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called every time a character special file is opened</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode * inode, <span class="keyword">struct</span> file * filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = -ENODEV;</span><br><span class="line">	filp-&gt;f_op=get_chrfops(MAJOR(inode-&gt;i_rdev), MINOR(inode-&gt;i_rdev));</span><br><span class="line">	<span class="keyword">if</span> (filp-&gt;f_op) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (filp-&gt;f_op-&gt;open != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			lock_kernel();</span><br><span class="line">			ret = filp-&gt;f_op-&gt;open(inode,filp);</span><br><span class="line">			unlock_kernel();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先调用<code>MAJOR()</code>和<code>MINOR()</code>宏从索引节点对象的<code>i_rdev</code>域中取得设备驱动程序的主设备号和从设备号，然后调用<code>get_chrfops()</code>函数为具体设备文件安装合适的文件操作。如果文件操作表中定义了<code>open</code>方法，就调用它。</p>
<p>注意，最后一次调用的<code>open()</code>方法就是对实际设备操作，这个函数的工作是设置设备。通常，<code>open()</code>函数执行如下操作。</p>
<ul>
<li>如果设备驱动程序被包含在一个内核模块中，那么把引用计数器的值加 1，以便只有把设备文件关闭之后才能卸载这个模块。</li>
<li>如果设备驱动程序要处理多个同类型的设备，那么，就使用从设备号来选择合适的驱动程序，如果需要，还要使用专门的文件操作表选择驱动程序。 </li>
<li>检查该设备是否真正存在，现在是否正在工作。</li>
<li>如果必要，向硬件设备发送一个初始化命令序列。</li>
<li>初始化设备驱动程序的数据结构。</li>
</ul>
<h3 id="一个字符设备驱动程序的实例"><a href="#一个字符设备驱动程序的实例" class="headerlink" title="一个字符设备驱动程序的实例"></a>一个字符设备驱动程序的实例</h3><p>在<code>Linux</code>中, 驱动程序一般用<code>C</code>语言编写，有时也支持一些汇编和`C++语言。</p>
<h4 id="头文件、宏定义和全局变量"><a href="#头文件、宏定义和全局变量" class="headerlink" title="头文件、宏定义和全局变量"></a>头文件、宏定义和全局变量</h4><p>一个典型的设备驱动程序一般都包含有一个专用头文件，这个头文件中包含一些系统函数的声明、设备寄存器的地址、寄存器状态位和控制位的定义以及用于此设备驱动程序的全局变量的定义，另外大多数驱动程序还使用以下一些标准的头文件。</p>
<ul>
<li><code>param.h</code>包含一些内核参数</li>
<li><code>dir.h</code>包含一些目录参数</li>
<li><code>user.h</code>用户区域的定义</li>
<li><code>tty.h</code>终端和命令列表的定义</li>
<li><code>fs.h</code>其中包括<code>Buffer header</code>信息</li>
</ul>
<p>下面是一些必要的头文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_MODVERSIONS==1 <span class="comment">/* 处理`CONFIG_MODVERSIONS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODVERSIONS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/modversions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 下面是针对字符设备的头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wrapper.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 对于不同的版本我们需要做一些必要的事情*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KERNEL_VERSION</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_VERSION(a,b,c) ((a)*65536+(b)*256+(c))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,4,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span> <span class="comment">/* for copy_to_user */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="comment">/* 声明设备 */</span></span><br><span class="line"><span class="comment">/* 这是本设备的名字，它将会出现在 /proc/devices */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;char_dev&quot;</span></span></span><br><span class="line"><span class="comment">/* 定义此设备消息缓冲的最大长度 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 100</span></span><br><span class="line"><span class="comment">/* 为了防止不同的进程在同一个时间使用此设备，定义此静态变量跟踪其状态 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Device_Open = <span class="number">0</span>；</span><br><span class="line"><span class="comment">/* 当提出请求的时候，设备将读写的内容放在下面的数组中 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> Message[BUF_LEN]；</span><br><span class="line"><span class="comment">/* 在进程读取这个内容的时候，这个指针是指向读取的位置*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *Message_Ptr ；</span><br><span class="line"><span class="comment">/* 在这个文件中，主设备号作为全局变量以便于这个设备在注册和释放的时候使用*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Major;</span><br></pre></td></tr></table></figure></p>
<h4 id="open-函数"><a href="#open-函数" class="headerlink" title="open()函数"></a>open()函数</h4><p>功能：无论一个进程何时试图去打开这个设备都会调用这个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">	printk (<span class="string">&quot;device_open(%p,%p)\n&quot;</span>, inode, file);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	printk(<span class="string">&quot;Device: %d.%d\n&quot;</span>,</span><br><span class="line">	inode-&gt;i_rdev &gt;&gt; <span class="number">8</span>, inode-&gt;i_rdev &amp; <span class="number">0xFF</span>);</span><br><span class="line"><span class="comment">/* 这个设备是一个独占设备，为了避免同时有两个进程使用这一个设备我们需要采取一定的措施*/</span></span><br><span class="line">	<span class="keyword">if</span> (Device_Open)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	Device_Open++;</span><br><span class="line"><span class="comment">/* 下面是初始化消息，注意不要使读写内容的长度超出缓冲区的长度，特别是运行在内核模式时，否</span></span><br><span class="line"><span class="comment">则如果出现缓冲上溢则可能导致系统的崩溃*/</span></span><br><span class="line">	<span class="built_in">sprintf</span>(Message, <span class="string">&quot;If I told you once, I told you %d times - %s&quot;</span>, counter++, <span class="string">&quot;Hello, world\n&quot;</span>);</span><br><span class="line">	Message_Ptr = Message;</span><br><span class="line"><span class="comment">/*当这个文件被打开的时候，我们必须确认该模块还没有被移走并且增加此模块的用户数目(在移走</span></span><br><span class="line"><span class="comment">一个模块的时候会根据这个数字去决定可否移去，如果不是 0 则表明还有进程正在使用这个模块，不能移</span></span><br><span class="line"><span class="comment">走)*/</span></span><br><span class="line">	MOD_INC_USE_COUNT; </span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="release-函数"><a href="#release-函数" class="headerlink" title="release()函数"></a>release()函数</h4><p>功能：当一个进程试图关闭这个设备特殊文件的时候调用这个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> file *file)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> file *file)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"> printk (<span class="string">&quot;device_release(%p,%p)\n&quot;</span>, inode, file);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为下一个使用这个设备的进程做准备*/</span></span><br><span class="line">	Device_Open --;</span><br><span class="line"><span class="comment">/* 减少这个模块使用者的数目，否则一旦你打开这个模块以后，你永远都不能释放掉它*/</span></span><br><span class="line">	MOD_DEC_USE_COUNT;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="read-函数"><a href="#read-函数" class="headerlink" title="read()函数"></a>read()函数</h4><p>功能：当一个进程已经打开此设备文件以后并且试图去读它的时候调用这个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">	<span class="type">char</span> *buffer, <span class="comment">/* 把读出的数据放到这个缓冲区*/</span></span></span><br><span class="line"><span class="params">	<span class="type">size_t</span> length, <span class="comment">/* 缓冲区的长度*/</span></span></span><br><span class="line"><span class="params">	<span class="type">loff_t</span> *offset)</span> <span class="comment">/* 文件中的偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">	<span class="type">char</span> *buffer, <span class="type">int</span> length)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 实际上读出的字节数 */</span></span><br><span class="line">	<span class="type">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 如果读到缓冲区的末尾，则返回 0 ，类似文件的结束*/</span></span><br><span class="line">	<span class="keyword">if</span> (*Message_Ptr == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 将数据放入缓冲区中*/</span></span><br><span class="line">	<span class="keyword">while</span> (length &amp;&amp; *Message_Ptr) &#123;</span><br><span class="line">		<span class="comment">/* 由于缓冲区是在用户空间而不是内核空间，所以我们必须使用`copu_to_user()`函数将内核空间中的数据拷贝到用户空间*/</span></span><br><span class="line">		copy_to_user(buffer++,*(Message_Ptr++), length--);</span><br><span class="line">		bytes_read ++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">	printk (<span class="string">&quot;Read %d bytes, %d left\n&quot;</span>,</span><br><span class="line">	bytes_read, length);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Read函数返回一个真正读出的字节数*/</span></span><br><span class="line">	<span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="write-函数"><a href="#write-函数" class="headerlink" title="write()函数"></a>write()函数</h4><p>功能：当试图将数据写入这个设备文件的时侯，这个函数被调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> *buffer,</span></span><br><span class="line"><span class="params">	<span class="type">size_t</span> length,</span></span><br><span class="line"><span class="params">	<span class="type">loff_t</span> *offset)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> *buffer,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> length)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">	printk (<span class="string">&quot;device_write(%p,%s,%d)&quot;</span>, file, buffer, length);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)</span></span><br><span class="line">	copy_from_user(Message, buffer，`length);</span><br><span class="line">	Message_Ptr = Message;</span><br><span class="line">	<span class="comment">/* 返回写入的字节数 */</span></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="这个设备驱动程序提供给文件系统的接口"><a href="#这个设备驱动程序提供给文件系统的接口" class="headerlink" title="这个设备驱动程序提供给文件系统的接口"></a>这个设备驱动程序提供给文件系统的接口</h4><p>当一个进程试图对我们生成的设备进行操作的时候就利用下面这个结构，这个结构就是我们提供给操作系统的接口，它的指针保存在设备表中，在<code>init_module()</code>中被传递给操作系统。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">Fops</span> =</span> &#123;</span><br><span class="line">	read: device_read, </span><br><span class="line">	write: device_write,</span><br><span class="line">	open: device_open,</span><br><span class="line">	release: device_release</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="模块的初始化和模块的卸载"><a href="#模块的初始化和模块的卸载" class="headerlink" title="模块的初始化和模块的卸载"></a>模块的初始化和模块的卸载</h4><p><code>init_module</code>函数用来初始化这个模块—注册该字符设备。<code>init_module ()</code>函数调用<code>module_register_chrdev</code>，把设备驱动程序添加到内核的字符设备驱动程序表中，它返回这个驱动程序所使用的主设备号。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 试图注册设备*/</span></span><br><span class="line">	Major = module_register_chrdev(<span class="number">0</span>,</span><br><span class="line">	DEVICE_NAME,</span><br><span class="line">	&amp;Fops);</span><br><span class="line">	<span class="comment">/* 失败的时候返回负值*/</span></span><br><span class="line">	<span class="keyword">if</span> (Major &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk (<span class="string">&quot;%s device failed with %d\n&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Sorry, registering the character&quot;</span>,</span><br><span class="line">		Major);</span><br><span class="line">		<span class="keyword">return</span> Major;</span><br><span class="line">	&#125;</span><br><span class="line">	printk (<span class="string">&quot;%s The major device number is %d.\n&quot;</span>, <span class="string">&quot;Registeration is a success.&quot;</span>, Major);</span><br><span class="line">	printk (<span class="string">&quot;If you want to talk to the device driver,\n&quot;</span>);</span><br><span class="line">	printk (<span class="string">&quot;you&#x27;ll have to create a device file. \n&quot;</span>);</span><br><span class="line">	printk (<span class="string">&quot;We suggest you use:\n&quot;</span>);</span><br><span class="line">	printk (<span class="string">&quot;mknod &lt;name&gt; c %d &lt;minor&gt;\n&quot;</span>, Major);</span><br><span class="line">	printk (<span class="string">&quot;You can try different minor numbers %s&quot;</span>, <span class="string">&quot;and see what happens.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下这个函数的功能是卸载模块，主要是从<code>/proc</code>中取消注册的设备特殊文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">/* 取消注册的设备*/</span></span><br><span class="line">	ret = module_unregister_chrdev(Major, DEVICE_NAME);</span><br><span class="line">	<span class="comment">/* 如果出错则显示出错信息 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">	printk(<span class="string">&quot;Error in unregister_chrdev: %d\n&quot;</span>, ret);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h3 id="驱动程序的编译与装载"><a href="#驱动程序的编译与装载" class="headerlink" title="驱动程序的编译与装载"></a>驱动程序的编译与装载</h3><p>在<code>Linux</code>里，除了直接修改系统内核的源代码，把设备驱动程序加进内核外，还可以把设备驱动程序作为可加载的模块，由系统管理员动态地加载它，使之成为内核的一部分。也可以由系统管理员把已加载的模块动态地卸载下来。<code>Linux</code>中，模块可以用<code>C</code>语言编写，用<code>gcc</code>编译成目标文件(不进行链接，作为<code>*.o</code>文件存盘)，为此需要在<code>gcc</code>命令行里加上<code>-c</code>的参数。在编译时，还应该在<code>gcc</code>的命令行里加上这样的参数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D__KERNEL__ -DMODULE。</span><br></pre></td></tr></table></figure></p>
<p>由于在不链接时，<code>gcc</code>只允许一个输入文件，因此一个模块的所有部分都必须在一个文件里实现。编译好的模块<code>*.o</code>放在<code>/lib/modules/xxxx/misc</code>下(<code>xxxx</code>表示内核版本)，然后用<code>depmod -a</code>使此模块成为可加载模块。模块用<code>insmod</code>命令加载，用<code>rmmod</code>命令来卸载，并可以用<code>lsmod</code>命令来查看所有已加载的模块的状态。</p>
<p>编写模块程序的时候，必须提供两个函数，一个是<code>int init_module(void)</code>，供<code>insmod</code>在加载此模块的时候自动调用，负责进行设备驱动程序的初始化工作。<code>init_module</code>返回 0以表示初始化成功，返回负数表示失败。另一个函数是<code>void cleanup_module (void)</code>，在模块被卸载时调用，负责进行设备驱动程序的清除工作。</p>
<p>在成功地向系统注册了设备驱动程序后(调用<code>register_chrdev</code>成功后)，就可以用<code>mknod</code>命令来把设备映射为一个特别文件，其他程序使用这个设备的时候，只要对此特别文件进行操作就行了。 </p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><h3 id="网络参考模型"><a href="#网络参考模型" class="headerlink" title="网络参考模型"></a>网络参考模型</h3><p><code>OSI</code>参考模型和<code>TCP/IP</code>参考模型如表所示。<br><img src="/img/1634181153.jpg" alt=""></p>
<h3 id="TCP-IP工作原理及数据流"><a href="#TCP-IP工作原理及数据流" class="headerlink" title="TCP/IP工作原理及数据流"></a>TCP/IP工作原理及数据流</h3><p><code>TCP/IP</code>不是一个单独的协议，它是由一组协议组成的协议集，在<code>TCP/IP</code>参考模型中各层对应的协议如表所示。<br><img src="/img/1634181365.jpg" alt=""></p>
<p><code>IP</code>不仅是<code>TCP/IP</code>的一个重要组成部分，而且也是<code>OSI</code>模型的一个基本协议。<code>IP</code>定义了一个协议，而不是一个连接，因此与网络连接无关。<code>IP</code>主要负责数据报在计算机之间的寻址问题，并管理这些数据报的分段过程。该协议在信息数据报格式和由数据报信息组成的报头方面有规范的定义。<code>IP</code>负责数据报的路由，决定数据报发送到哪里以及在出现问题时更换路由。</p>
<p><code>IP</code>数据报的传输具有“不可靠性”，数据报的传输不能受到保障，因为数据报可能会遇到延迟或路由错误，或在数据报分解和重组时遭到破坏。<code>IP</code>没有能力证实发送的报文是否能被正确的接收，<code>IP</code>把验证和流量控制的任务交给了分层模型中的其他部件完成。<code>IP</code>是无连接的，它不管数据报沿途经过那些节点。它的这些特点都在<code>IP</code>报体现。如图 12.3 所示，数据经过<code>IP</code>层时，都会被加上<code>IP</code>的协议头，其输入/输出是从用户的角度来看的。<br><img src="/img/1634181427.jpg" alt=""></p>
<p><code>IP</code>的协议头，也可叫做<code>IP</code>数据报或<code>IP</code>报头，是<code>IP</code>的基本传输单元。IP`协议头的结构如图 12.4 所示。<br><img src="/img/1634181454.jpg" alt=""></p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p><code>TCP</code>是传输层中使用最为广泛的一协议，它可以向上层提供面向连接的协议，使上层启动应用程序，以确保网络上所发送的数据报被完整接收。就这种作用而言，<code>TCP</code>的作用是提供可靠通信的有效报文协议。一旦数据报被破坏或丢失，通常是<code>TCP</code>将其重新传输，而不是应用程序或<code>IP</code>。</p>
<p><code>TCP</code>必须与低层的<code>IP</code>(使用<code>IP</code>定义好的方法)和高层的应用程序(使用<code>TCP-ULP</code>元语)进行通信。<code>TCP</code>还必须通过网络与其他<code>TCP</code>软件进行通信。为此，它使用了协议数据单元(PDU)，在<code>TCP</code>用语中称为分段。TCP PDU(通常称为<code>TCP</code>报头)的分布如图 12.5 所示。</p>
<p><img src="/img/1634181502.jpg" alt=""></p>
<p>部分域含义如下。</p>
<ul>
<li>本机端口：标识本机<code>TCP</code>用户(通常为上层应用程序)的 16 位域。</li>
<li>远端端口：标识远程计算机<code>TCP</code>用户的 16 位域。</li>
<li>序号：指明当前时钟在全文中位置的序号。也可用在两个<code>TCP</code>之间以提供初始发送序号(ISS)。</li>
<li>确认号：指明下一个预计序列的序号。反过来，它还可以表示最后接收数据的序号，表示最后接收的序号加 1。</li>
<li>数据偏移：用于标识数据段的开始。</li>
<li>URG：如果打开(值为 1)，则指明紧急指针域有效。</li>
<li>ACK：如果打开，则指明确认域有效。</li>
<li>RST：如果打开，则指明要重复连接。</li>
<li>SYN：如果打开，则指明要同步的序号。</li>
<li>FIN：如果打开，则指明发送双方不再发送数据。这与传输结束标志是相同的。</li>
</ul>
<p>这些域在<code>TCP</code>连接和传输数据时会用到。</p>
<p><code>TCP</code>对如何通信有许多规则。这些规则以及<code>TCP</code>连接、传输要遵循的过程，通常都体现在状态数据报中(因为<code>TCP</code>是一个状态驱动协议，其行为取决于状态标志或类似结构)。要完全避免复杂的状态数据报是很困难的，所以流程图对理解<code>TCP</code>是一种很有效的方法。下面我们就以<code>TCP</code>连接的流程图为例，介绍<code>TCP</code>的工作原理。如图 12.6 所示。此过程以计算机<code>A</code>的<code>TCP</code>开始，<code>TCP</code>可从它的<code>ULP</code>接收连接请求，通过它向计算机<code>B</code>发送一个主动打开原语，所构成的分段应设置<code>SYN</code>标志(值为 1)，并分配一个序列号<code>M</code>。图12.6 用<code>SYN 50</code>表示，<code>SYN</code>标志打开，序号<code>M</code>用 50 表示，可任意选择。</p>
<p>计算机<code>B</code>上的应用程序将向它的<code>TCP</code>发送一个被动打开指令，当接收到<code>SYN M</code>分段时，计算机<code>B</code>上的<code>TCP</code>将序号<code>M+1</code>发回一个确认给计算机<code>A</code>，图 12.6 用<code>ACK 51</code>表示。计算机<code>B</code>也为自己设置一个初始发送序号<code>N</code>，图 12.6 用<code>SYN 200</code>表示。</p>
<p>计算机<code>A</code>根据接收到的内容，通过将序号设置为<code>N+1</code>，发回他自己的确认报文，图 12.6 用<code>ACK 201</code>表示。然后，打开并确认此次连接，计算机<code>A</code>和计算机<code>B</code>通过<code>ULP</code>将连接打开报文发送到请求的应用程序。至此两台计算机建立了连接，可以在<code>TCP</code>层传输数据。</p>
<p><img src="/img/1634181659.jpg" alt=""></p>
<h2 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h2><h3 id="套接字在网络中的地位和作用"><a href="#套接字在网络中的地位和作用" class="headerlink" title="套接字在网络中的地位和作用"></a>套接字在网络中的地位和作用</h3><p><code>socket</code>在所有的网络操作系统中都是必不可少的，而且在所有的网络应用程序中也是必不可少的。它是网络通信中应用程序对应的进程和网络协议之间的接口，如图 12.7 所示。<br><img src="/img/1634181696.jpg" alt=""></p>
<p><code>socket</code>在网络系统中的作用如下。</p>
<ol>
<li><code>socket</code>位于协议之上，屏蔽了不同网络协议之间的差异。 </li>
<li><code>socket</code>是网络编程的入口，它提供了大量的系统调用，构成了网络程序的主体。</li>
<li>在<code>Linux</code>系统中，<code>socket</code>属于文件系统的一部分，网络通信可以被看作是对文件的读取，使得我们对网络的控制和对文件的控制一样方便。</li>
</ol>
<h3 id="套接字接口的种类"><a href="#套接字接口的种类" class="headerlink" title="套接字接口的种类"></a>套接字接口的种类</h3><p><code>Linux</code>支持多种套接字种类，不同的套接字种类称为“地址族”，这是因为每种套接字种类拥有自己的通信寻址方法。</p>
<h3 id="套接字的工作原理"><a href="#套接字的工作原理" class="headerlink" title="套接字的工作原理"></a>套接字的工作原理</h3><p><code>INET</code>套接字就是支持<code>Internet</code>地址族的套接字，它位于<code>TCP</code>之上，<code>BSD</code>套接字之下。<code>INET</code>和<code>BSD</code>套接字之间的接口通过<code>Internet</code>地址族套接字操作集实现，这些操作集实际是一组协议的操作例程，在<code>include/linux/net.h</code>中定义为<code>proto_ops</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> family;</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> socket *sock);</span><br><span class="line">	<span class="type">int</span> (*bind) (<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *umyaddr,</span><br><span class="line">	<span class="type">int</span> sockaddr_len);</span><br><span class="line">	<span class="type">int</span> (*connect) (<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *uservaddr,</span><br><span class="line">	<span class="type">int</span> sockaddr_len, <span class="type">int</span> flags);</span><br><span class="line">	<span class="type">int</span> (*socketpair) (<span class="keyword">struct</span> socket *sock1, <span class="keyword">struct</span> socket *sock2);</span><br><span class="line">	<span class="type">int</span> (*accept) (<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> socket *newsock,</span><br><span class="line">	<span class="type">int</span> flags);</span><br><span class="line">	<span class="type">int</span> (*getname) (<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *uaddr,</span><br><span class="line">	<span class="type">int</span> *usockaddr_len, <span class="type">int</span> peer);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> poll_table_struct *wait)</span>;</span><br><span class="line">	<span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> socket *sock, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">	<span class="type">int</span> (*listen) (<span class="keyword">struct</span> socket *sock, <span class="type">int</span> len);</span><br><span class="line">	<span class="type">int</span> (*shutdown) (<span class="keyword">struct</span> socket *sock, <span class="type">int</span> flags);</span><br><span class="line">	<span class="type">int</span> (*setsockopt) (<span class="keyword">struct</span> socket *sock, <span class="type">int</span> level, <span class="type">int</span> optname,</span><br><span class="line">	<span class="type">char</span> *optval, <span class="type">int</span> optlen);</span><br><span class="line">	<span class="type">int</span> (*getsockopt) (<span class="keyword">struct</span> socket *sock, <span class="type">int</span> level, <span class="type">int</span> optname,</span><br><span class="line">	<span class="type">char</span> *optval, <span class="type">int</span> *optlen);</span><br><span class="line">	<span class="type">int</span> (*sendmsg) (<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> msghdr *m, <span class="type">int</span> total_len, <span class="keyword">struct</span> scm_cookie *scm);</span><br><span class="line">	<span class="type">int</span> (*recvmsg) (<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> msghdr *m, <span class="type">int</span> total_len, <span class="type">int</span> flags, <span class="keyword">struct</span> scm_cookie *scm);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> vm_area_struct * vma);</span><br><span class="line">	<span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> page *page, <span class="type">int</span> offset, <span class="type">size_t</span> size, <span class="type">int</span> flags);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个操作集类似于文件系统中的<code>file_operations</code>结构。<code>BSD</code>套接字层通过调用<code>proto_ops</code>结构中的相应函数执行任务。<code>BSD</code>套接字层向<code>INET</code>套接字层传递<code>socket</code>数据结构来代表一个<code>BSD</code>套接字，<code>socket</code>结构在<code>include/linux/net.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	socket_state state;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_list</span>;</span> <span class="comment">/* Asynchronous wake up list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">/* File back pointer for gc */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> wait;</span><br><span class="line">	<span class="type">short</span> type;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> passcred;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但在<code>INET</code>套接字层中，它利用自己的<code>sock</code>数据结构来代表该套接字，因此，这两个结构之间存在着链接关系，<code>sock</code>结构定义于<code>include/net/sock.h</code>。在<code>BSD</code>的<code>socket</code>数据结构中存在一个指向<code>sock</code>的指针<code>sk</code>，而在<code>sock</code>中又有一个指向<code>socket</code>的指针，这两个指针将<code>BSD socket</code>数据结构和<code>sock</code>数据结构链接了起来。通过这种链接关系，套接字调用就可以方便地检索到<code>sock</code>数据结构。实际上，<code>sock</code>数据结构可适用于不同的地址族，它也定义有自己的协议操作集<code>proto</code>。在建立套接字时，<code>sock</code>数据结构的协议操作集指针指向所请求的协议操作集。如果请求<code>TCP</code>，则<code>sock</code>数据结构的协议操作集指针将指向<code>TCP</code>的协议操作集。</p>
<p>进程在利用套接字进行通信时，采用客户/服务器模型。服务器首先创建一个套接字，并将某个名称绑定到该套接字上，套接字的名称依赖于套接字的底层地址族，但通常是服务器的本地地址。套接字的名称或地址通过<code>sockaddr</code>数据结构指定，该结构定义于<code>include/linux/socket.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family; <span class="comment">/* address family, AF_xxx */</span></span><br><span class="line">	<span class="type">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/* 14 bytes of protocol address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于<code>INET</code>套接字来说，服务器的地址由两部分组成，一个是服务器的<code>IP</code>地址，另一个是服务器的端口地址。已注册的标准端口可查看<code>/etc/services</code>文件。将地址绑定到套接字之后，服务器就可以监听请求链接该绑定地址的传入连接。连接请求由客户生成，它首先建立一个套接字，并指定服务器的目标地址以请求建立连接。传入的连接请求通过不同的协议层最终到达服务器的监听套接字。服务器接收到传入的请求后，如果能够接受该请求，服务器必须创建一个新的套接字来接受该请求并建立通信连接(用于监听的套接字不能用来建立通信连接)，这时，服务器和客户就可以利用建立好的通信连接传输数据。</p>
<p>内核负责在<code>BSD</code>套接字和底层的地址族之间建立联系。这种联系通过交叉链接数据结构以及地址族专有的支持例程表建立。</p>
<p>在内核中，地址族和协议信息保存在<code>inet_protos</code>向量中，其定义于<code>include/net/protocol.h</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protocol</span> *<span class="title">inet_protos</span>[<span class="title">MAX_INET_PROTOS</span>];</span></span><br><span class="line"><span class="comment">/* This is used to register protocols. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protocol</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> (*handler)(<span class="keyword">struct</span> sk_buff *skb);</span><br><span class="line">	<span class="type">void</span> (*err_handler)(<span class="keyword">struct</span> sk_buff *skb, u32 info);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_protocol</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> protocol;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> copy:<span class="number">1</span>;</span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每个地址族由其名称以及相应的初始化例程地址代表。在引导阶段初始化套接字接口时，内核调用每个地址族的初始化例程，这时，每个地址族注册自己的协议操作集。协议操作集实际是一个例程集合，其中每个例程执行一个特定的操作。</p>
<h3 id="socket的通信过程"><a href="#socket的通信过程" class="headerlink" title="socket的通信过程"></a>socket的通信过程</h3><p>请先看如图 12.9 所示的<code>socket</code>通信过程。<br><img src="/img/1634181964.jpg" alt=""></p>
<h4 id="建立套接字"><a href="#建立套接字" class="headerlink" title="建立套接字"></a>建立套接字</h4><p><code>Linux</code>在利用<code>socket()</code>系统调用建立新的套接字时，需要传递套接字的地址族标识符、套接字类型以及协议，其函数定义于<code>net/socket.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span><br><span class="line"> &#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">	retval = sock_create(family, type, protocol, &amp;sock);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	retval = sock_map_fd(sock);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_release;</span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/* It may be already another descriptor 8) Not kernel problem. */</span></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">out_release:</span><br><span class="line">	sock_release(sock);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上，套接字对于用户程序而言就是特殊的已打开的文件。内核中为套接字定义了一种特殊的文件类型，形成一种特殊的文件系统<code>sockfs</code>，其定义于<code>net/socket.c</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">sock_mnt</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_FSTYPE</span><span class="params">(sock_fs_type, <span class="string">&quot;sockfs&quot;</span>,sockfs_read_super, FS_NOMOUNT)</span>;</span><br></pre></td></tr></table></figure></p>
<p>在系统初始化时，要通过<code>kern_mount()</code>安装这个文件系统。安装时有个作为连接件的<code>vfsmount</code>数据结构，这个结构的地址就保存在一个全局的指针<code>sock_mnt</code>中。所谓创建一个套接字，就是在<code>sockfs</code>文件系统中创建一个特殊文件，或者说一个节点，并建立起为实现套接字功能所需的一整套数据结构。所以，函数<code>sock_create()</code>首先是建立一个<code>socket</code>数据结构，然后将其“映射”到一个已打开的文件中，进行<code>socket</code>结构和<code>sock</code>结构的分配和初始化。</p>
<p>新创建的<code>BSD socket</code>数据结构包含有指向地址族专有的套接字例程的指针，这一指针实际就是<code>proto_ops</code>数据结构的地址。<code>BSD</code>套接字的套接字类型设置为所请求的<code>SOCK_STREAM</code>或<code>SOCK_DGRAM</code>等。然后，内核利用<code>proto_ops</code>数据结构中的信息调用地址族专有的创建例程。</p>
<p>之后，内核从当前进程的<code>fd</code>向量中分配空闲的文件描述符，该描述符指向的<code>file</code>数据结构被初始化。初始化过程包括将文件操作集指针指向由<code>BSD</code>套接字接口支持的<code>BSD</code>文件操作集。所有随后的套接字(文件)操作都将定向到该套接字接口，而套接字接口则会进一步调用地址族的操作例程，从而将操作传递到底层地址族，如图 12.10 所示。<br><img src="/img/1634182062.jpg" alt=""></p>
<p>实际上，<code>socket</code>结构与<code>sock</code>结构是同一事物的两个方面。如果说<code>socket</code>结构是面向进程和系统调用界面的，那么<code>sock</code>结构就是面向底层驱动程序的。可是，为什么不把这两个数据结构合并成一个呢？</p>
<p>我们说套接字是一种特殊的文件系统，因此，<code>inode</code>结构内部的<code>union</code>的一个成分就用作<code>socket</code>结构，其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">…</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		…</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> <span class="title">socket_i</span>;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于套接字操作的特殊性，这个结构中需要大量的结构成分。可是，如果把这些结构成分全都放在<code>socket</code>结构中，则<code>inode</code>结构中的这个<code>union</code>就会变得很大，从而<code>inode</code>结构也会变得很大，而对于其他文件系统，这个<code>union</code>成分并不需要那么庞大。因此，就把套接字所需的这些结构成分拆成两部分，把与文件系统关系比较密切的那一部分放在<code>socket</code>结构中，把与通信关系比较密切的那一部分则单独组成一个数据结构，即<code>sock</code>结构。由于这两部分数据在逻辑上本来就是一体的，所以要通过指针互相指向对方，形成一对一的关系。</p>
<h4 id="在INET-BSD套接字上绑定-bind-地址"><a href="#在INET-BSD套接字上绑定-bind-地址" class="headerlink" title="在INET BSD套接字上绑定(bind)地址"></a>在INET BSD套接字上绑定(bind)地址</h4><p>为了监听传入的<code>Internet</code>连接请求，每个服务器都需要建立一个<code>INET BSD</code>套接字，并且将自己的地址绑定到该套接字。绑定操作主要在<code>INET</code>套接字层中进行，还需要底层<code>TCP</code>层和<code>IP</code>层的某些支持。将地址绑定到某个套接字上之后，该套接字就不能用来进行任何其他的通信，因此，该<code>socket</code>数据结构的状态必须为<code>TCP_CLOSE</code>。传递到绑定操作的<code>sockaddr</code>数据结构中包含要绑定的<code>IP</code>地址，以及一个可选的端口地址。通常而言，要绑定的地址应该是赋予某个网络设备的<code>IP</code>地址，而该网络设备应该支持<code>INET</code>地址族，并且该设备是可用的。利用<code>ifconfig</code>命令可查看当前活动的网络接口。被绑定的<code>IP</code>地址保存在<code>sock</code>数据结构的<code>rcv_saddr</code>和<code>saddr</code>域中，这两个域分别用于哈希查找和发送用的<code>IP</code>地址。端口地址是可选的，如果没有指定，底层的支持网络会选择一个空闲的端口。</p>
<p>当底层网络设备接收到数据包时，它必须将数据传递到正确的<code>INET</code>和<code>BSD</code>套接字以便进行处理，因此，<code>TCP</code>维护多个哈希表，用来查找传入<code>IP</code>消息的地址，并将它们定向到正确的<code>socket/sock</code>对。<code>TCP</code>并不在绑定过程中将绑定的<code>sock</code>数据结构添加到哈希表中，在这一过程中，它仅仅判断所请求的端口号当前是否正在使用。在监听操作中，该<code>sock</code>结构才被添加到<code>TCP</code>的哈希表中。</p>
<h4 id="监听-listen-INET-BSD套接字"><a href="#监听-listen-INET-BSD套接字" class="headerlink" title="监听(listen)INET BSD套接字"></a>监听(listen)INET BSD套接字</h4><p>当某个套接字被绑定了地址之后，该套接字就可以用来监听专属于该绑定地址的传入连接。网络应用程序也可以在未绑定地址之前监听套接字，这时，<code>INET</code>套接字层将利用空闲的端口编号并自动绑定到该套接字。套接字的监听函数将<code>socket</code>的状态改变为<code>TCP_LISTEN</code>。当接收到某个传入的<code>TCP</code>连接请求时，<code>TCP</code>建立一个新的<code>sock</code>数据结构来描述该连接。当该连接最终被接受时，新的<code>sock</code>数据结构将变成该<code>TCP</code>连接的内核<code>bottom_half</code>部分，这时，它要克隆包含连接请求的传入<code>sk_buff</code>中的信息，并在监听<code>sock</code>数据结构的<code>receive_queue</code>队列中将克隆的信息排队。克隆的<code>sk_buff</code>中包含有指向新<code>sock</code>数据结构的指针。</p>
<h4 id="接受连接请求-accept"><a href="#接受连接请求-accept" class="headerlink" title="接受连接请求(accept)"></a>接受连接请求(accept)</h4><p>接受操作在监听套接字上进行，从监听<code>socket</code>中克隆一个新的<code>socket</code>数据结构。其过程如下：接受操作首先传递到支持协议层，即<code>INET</code>中，以便接受任何传入的连接请求。相反，接受操作进一步传递到实际的协议，例如<code>TCP</code>上。接受操作可以是阻塞的，也可以是非阻塞的。接受操作为非阻塞的情况下，如果没有可接受的传入连接，则接受操作将失败，而新建立的<code>socket</code>数据结构被抛弃。接受操作为阻塞的情况下，执行阻塞操作的网络应用程序将添加到等待队列中，并保持挂起直到接收到一个<code>TCP</code>连接请求为至。当连接请求到达之后，包含连接请求的<code>sk_buff</code>被丢弃，而由<code>TCP</code>建立的新<code>sock</code>数据结构返回到<code>INET</code>套接字层，在这里，<code>sock</code>数据结构和先前建立的新<code>socket</code>数据结构建立链接。而新<code>socket</code>的文件描述符被返回到网络应用程序，此后，应用程序就可以利用该文件描述符在新建立的<code>INET BSD</code>套接字上进行套接字操作。</p>
<h3 id="socket为用户提供的系统调用"><a href="#socket为用户提供的系统调用" class="headerlink" title="socket为用户提供的系统调用"></a>socket为用户提供的系统调用</h3><p><code>socket</code>系统调用是<code>socket</code>最有价值的一部分，也是用户唯一能够接触到的一部分，它是我们进行网络编程的接口。如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统调用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Accept</code></td>
<td>接收套接字上连接请求</td>
</tr>
<tr>
<td><code>Bind</code></td>
<td>在套接字绑定地址信息</td>
</tr>
<tr>
<td><code>Connet</code></td>
<td>连接两个套接字</td>
</tr>
<tr>
<td><code>Getpeername</code></td>
<td>获取已连接端套接字的地址</td>
</tr>
<tr>
<td><code>Getsockname</code></td>
<td>获取套接字的地址</td>
</tr>
<tr>
<td><code>Getsockopt</code></td>
<td>获取套接字上的设置选项</td>
</tr>
<tr>
<td><code>Listen</code></td>
<td>监听套接字连接</td>
</tr>
<tr>
<td><code>Recv</code></td>
<td>从已连接套接字上接收消息</td>
</tr>
<tr>
<td><code>Recvfrom</code></td>
<td>从套接字上接收消息</td>
</tr>
<tr>
<td><code>Send</code></td>
<td>向已连接的套接字发送消息</td>
</tr>
<tr>
<td><code>Sendto</code></td>
<td>向套接字发送消息</td>
</tr>
<tr>
<td><code>Setdomainname</code></td>
<td>设置系统的域名</td>
</tr>
<tr>
<td><code>Sethostid</code></td>
<td>设置唯一的主机标识符</td>
</tr>
<tr>
<td><code>Sethostname</code></td>
<td>设置系统的主机名称</td>
</tr>
<tr>
<td><code>Setsockopt</code></td>
<td>修改套接字选项</td>
</tr>
<tr>
<td><code>Shutdown</code></td>
<td>关闭套接字</td>
</tr>
<tr>
<td><code>Socket</code></td>
<td>建立套接字通信的端点</td>
</tr>
<tr>
<td><code>Socketcall</code></td>
<td>套接字调用多路复用转换器</td>
</tr>
<tr>
<td><code>Socketpair</code></td>
<td>建立两个连接套接字</td>
</tr>
</tbody>
</table>
</div>
<h2 id="套接字缓冲区-sk-buff"><a href="#套接字缓冲区-sk-buff" class="headerlink" title="套接字缓冲区(sk_buff)"></a>套接字缓冲区(sk_buff)</h2><p>套接字缓冲区是网络部分一个重要的数据结构，它描述了内存中的一块数据区域，该数据区域存放着网络传输的数据包。</p>
<h3 id="套接字缓冲区的特点"><a href="#套接字缓冲区的特点" class="headerlink" title="套接字缓冲区的特点"></a>套接字缓冲区的特点</h3><p>当套接字缓冲区在协议层流动过程中，每个协议都需要对数据区的内容进行修改，也就是每个协议都需要在发送数据时向缓冲区添加自己的协议头和协议尾，而在接收数据时去掉这些协议头和协议尾，这样就存在一个问题，当缓冲区在不同的协议之间传递时，每层协议都要寻找自己特定的协议头和协议尾，从而导致数据缓冲区的传递非常困难。我们设置<code>sk_buff</code>数据结构的主要目的就是为网络部分提供一种统一有效的缓冲区操作方法，从而可让协议层以标准的函数或方法对缓冲区数据进行处理，这是<code>Linux</code>系统网络高效运行的关键。</p>
<h3 id="套接字缓冲区操作基本原理"><a href="#套接字缓冲区操作基本原理" class="headerlink" title="套接字缓冲区操作基本原理"></a>套接字缓冲区操作基本原理</h3><p>在传输过程中，存在着多个套接字缓冲区，这些缓冲区组成一个链表，每个链表都有一个链表头<code>sk_buff_head</code>，链表中每个节点分别对应内存中一块数据区。因此对它的操作有两种基本方式：第 1 种是对缓冲区链表进行操作；第 2 种是对缓冲区对应的数据区进行控制。</p>
<p>当我们向物理接口发送数据时或当我们从物理接口接收数据时，我们就利用链表操作；当我们要对数据区的内容进行处理时，我们就利用内存操作例程。这种操作机制对网络传输是非常有效的。</p>
<p>前面我们讲过，每个协议都要在发送数据时向缓冲区添加自己的协议头和协议尾，而在接收数据时去掉协议头和协议尾，那么具体的操作是怎样进行的呢？我们先看看对缓冲区操作的两个基本的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">append_frame</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>=</span>alloc_skb(len, GFP_ATOMIC); <span class="comment">/*创建一个缓冲区*/</span></span><br><span class="line">	<span class="keyword">if</span>(skb==<span class="literal">NULL</span>)</span><br><span class="line">		my_dropped++;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		kb_put(skb,len);</span><br><span class="line">		<span class="built_in">memcpy</span>(skb-&gt;data,data,len); <span class="comment">/*向缓冲区添加数据*/</span></span><br><span class="line">		skb_append(&amp;my_list, skb); <span class="comment">/*将该缓冲区加入缓冲区队列*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">process_frame</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">while</span>((skb=skb_dequeue(&amp;my_list))!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		process_data(skb); <span class="comment">/*将缓冲区的数据传递给协议层*/</span></span><br><span class="line">		kfree_skb(skb, FREE_READ); <span class="comment">/*释放缓冲区，缓冲区从此消失*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个非常简单的程序片段，虽然它们不是源程序，但是它们恰当地描述了处理数据包的工作原理，<code>append_frame()</code>描述了分配缓冲区。创建数据包过程<code>process_frame()</code>描述了传递数据包，释放缓冲区的的过程。关于它们的源程序，可以去参见<code>net/core/dev.c</code>中<code>netif_rx()</code>函数和<code>net_bh()</code>函数。你可以看出它们和上面我们提到的两个函数非常相似。</p>
<p>这两个函数非常复杂，因为他们必须保证数据能够被正确的协议接收并且要负责流程的控制，但是他们最基本的操作是相同的。</p>
<p>让我们再看看上面提到的函数<code>append_frame()</code>。当<code>alloc_skb()</code>函数获得一个长度为<code>len</code>字节的缓冲区(如图 12.12 (a)所示)后，该缓冲区包含以下内容：</p>
<ul>
<li>缓冲区的头部有零字节的头部空间；</li>
<li>零字节的数据空间；</li>
<li>缓冲区的尾部有零字节的尾部空间。</li>
</ul>
<p>再看<code>skb_put()</code>函数(如图 12.12 (d)所示)，它的作用是从数据区的尾部向缓冲区尾部不断扩大数据区大小，为后面的<code>memcpy()</code>函数分配空间。</p>
<p>当一个缓冲区创建以后，所有的可用空间都在缓冲区的尾部。在没有向其中添加数据之前，首先被执行的函数调用是<code>skb_reserve()</code>(如图 12.12 (b)所示)，它使你在缓冲区头部指定一定的空闲空间，因此许多发送数据的例程都是这样开头的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">skb=alloc_skb(len+headspace, GFP_KERNEL);</span><br><span class="line">skb_reserve(skb, headspace);</span><br><span class="line">skb_put(skb,len);</span><br><span class="line">memcpy_fromfs(skb-&gt;data,data,len);</span><br><span class="line">pass_to_m_protocol(skb);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1634197155.jpg" alt=""></p>
<h3 id="sk-buff数据结构的核心内容"><a href="#sk-buff数据结构的核心内容" class="headerlink" title="sk_buff数据结构的核心内容"></a>sk_buff数据结构的核心内容</h3><p><code>sk_buff</code>数据结构中包含了一些指针和长度信息，从而可让协议层以标准的函数或方法对应用程序的数据进行处理，其定义于<code>include/linux/skbuff.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">	<span class="comment">/* These two members must be first. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> * <span class="title">next</span>;</span> <span class="comment">/* Next buffer in list*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> * <span class="title">prev</span>;</span> <span class="comment">/* Previous buffer in list*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> * <span class="title">list</span>;</span> <span class="comment">/* List we are on */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span> <span class="comment">/* Socket we are owned by */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">stamp</span>;</span> <span class="comment">/* Time we arrived */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span> <span class="comment">/* Device we arrived on/are leaving by */</span></span><br><span class="line">	<span class="comment">/* Transport layer header */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span> *<span class="title">uh</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">icmphdr</span> *<span class="title">icmph</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">igmphdr</span> *<span class="title">igmph</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ipiph</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">spxhdr</span> *<span class="title">spxh</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">char</span> *raw;</span><br><span class="line">	&#125; h;</span><br><span class="line">	<span class="comment">/* Network layer header */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipv6hdr</span> *<span class="title">ipv6h</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">arphdr</span> *<span class="title">arph</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipxhdr</span> *<span class="title">ipxh</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">char</span> *raw;</span><br><span class="line">	&#125; nh;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Link layer header */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">ethernet</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">char</span> *raw;</span><br><span class="line">	&#125; mac;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dst_entry</span> *<span class="title">dst</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* This is the control buffer. It is free to use for every</span></span><br><span class="line"><span class="comment">	* layer. Please put your private variables there. If you</span></span><br><span class="line"><span class="comment">	* want to keep them across layers you have to do a skb_clone()</span></span><br><span class="line"><span class="comment">	* first. This is owned by whoever has the skb queued ATM.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">char</span> cb[<span class="number">48</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> len; <span class="comment">/* Length of actual data*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data_len;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> csum; <span class="comment">/* Checksum */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> __unused, <span class="comment">/* Dead field, may be reused */</span></span><br><span class="line">	cloned, <span class="comment">/* head may be cloned (check refcnt to be sure). */</span></span><br><span class="line">	pkt_type, <span class="comment">/* Packet class */</span></span><br><span class="line">	ip_summed; <span class="comment">/* Driver fed us an IP checksum */</span></span><br><span class="line">	__u32 priority; <span class="comment">/* Packet queueing priority */</span></span><br><span class="line">	<span class="type">atomic_t</span> users; <span class="comment">/* User count - see datagram.c,tcp.c */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> protocol; <span class="comment">/* Packet protocol from driver. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> security; <span class="comment">/* Security level of packet */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> truesize; <span class="comment">/* Buffer size */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *head; <span class="comment">/* Head of buffer */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *data; <span class="comment">/* Data head pointer</span></span><br><span class="line"><span class="comment">	unsigned char *tail; /* Tail pointer </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	unsigned char *end; /* End pointer */</span></span><br><span class="line">	<span class="type">void</span> (*destructor)(<span class="keyword">struct</span> sk_buff *); <span class="comment">/* Destruct function */</span></span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该结构的示意图如图 12.13 所示。<br><img src="/img/1634197233.jpg" alt=""></p>
<p>每个<code>sk_buff</code>均包含一个数据块、4 个数据指针以及两个长度字段。利用 4 个数据指针，各协议层可操纵和管理套接字缓冲区的数据，这 4 个指针的用途如下所述。</p>
<ul>
<li><code>head</code>：指向内存中数据区的起始地址。sk_buff`和相关数据块在分配之后，该指针的值是固定的。</li>
<li><code>data</code>：指向协议数据的当前起始地址。该指针的值随当前拥有<code>sk_buff</code>的协议层的变化而变化。</li>
<li><code>tail</code>：指向协议数据的当前结尾地址。和<code>data</code>指针一样，该指针的值也随当前拥有<code>sk_buff</code>的协议层的变化而变化。</li>
<li><code>end</code>：指向内存中数据区的结尾。和<code>head</code>指针一样，<code>sk_buff</code>被分配之后，该指针的值也固定不变。</li>
</ul>
<p><code>sk_buff</code>有两个非常重要长度字段，<code>len</code>和<code>truesize</code>，分别描述当前协议数据包的长度和数据缓冲区的实际长度。</p>
<h3 id="套接字缓冲区提供的函数"><a href="#套接字缓冲区提供的函数" class="headerlink" title="套接字缓冲区提供的函数"></a>套接字缓冲区提供的函数</h3><h4 id="操纵sk-buff链表的函数"><a href="#操纵sk-buff链表的函数" class="headerlink" title="操纵sk_buff链表的函数"></a>操纵sk_buff链表的函数</h4><p><code>sk_buff</code>链表是一个双向链表，它包括一个链表头而且每一个缓冲区都有一个<code>prev</code>和<code>next</code>指针，指向链表中前一个和后一个缓冲区节点。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">skb_dequeue</span><span class="params">(<span class="keyword">struct</span> skb_buff_head *<span class="built_in">list</span>)</span> </span><br></pre></td></tr></table></figure><br>这个函数作用是把第 1 个缓冲区从链表中移走。返回取出的<code>sk_buff</code>，如果队列为空，就返回空指针。添加缓冲区用到<code>skb_queue_head</code>和<code>skb_queue_tail</code>两个例程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">skb_peek</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>)</span></span><br></pre></td></tr></table></figure>
<p>返回指向缓冲区链表第 1 个节点的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">skb_queue_empty</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果链表为空，返回true 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skb_queue_head</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br></pre></td></tr></table></figure>
<p>这个函数在链表头部添加一个缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skb_queue_head_init</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>)</span></span><br></pre></td></tr></table></figure>
<p>初始化<code>sk_buff_head</code>结构 。该函数必须在所有的链表操作之前调用，而且它不能被重复执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__u32 <span class="title function_">skb_queue_len</span><span class="params">(<span class="keyword">struct</span> sk_buff_head *<span class="built_in">list</span>)</span></span><br></pre></td></tr></table></figure>
<p>返回队列中排队的缓冲区的数目。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skb_queue_tail</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br></pre></td></tr></table></figure>
<p>这个函数在链表的尾部添加一个缓冲区，这是在缓冲区操作函数中最常用的一个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skb_unlink</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br></pre></td></tr></table></figure>
<p>这个函数从链表中移去一个缓冲区。它只是将缓冲区从链表中移去，但并不释放它。</p>
<p>许多更复杂的协议，如<code>TCP</code>协议，当它接收到数据时，需要保持链表中数据帧的顺序或对数据帧进行重新排序。有两个函数完成这些工作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skb_append</span><span class="params">(<span class="keyword">struct</span> sk_buff *entry, <span class="keyword">struct</span> sk_buff *new_entry)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skb_insert</span><span class="params">(<span class="keyword">struct</span> sk_buff *entry, <span class="keyword">struct</span> sk_buff *new_entry)</span></span><br></pre></td></tr></table></figure><br>它们可以使用户把一个缓冲区放在链表中任何一个位置。</p>
<h4 id="创建或取消一个缓冲区结构的函数"><a href="#创建或取消一个缓冲区结构的函数" class="headerlink" title="创建或取消一个缓冲区结构的函数"></a>创建或取消一个缓冲区结构的函数</h4><p>这些操作用到内存处理方法，它们的正确使用对管理内存非常重要。<code>sk_buff</code>结构的数量和它们占用内存大小会对机器产生很大的影响，因为网络缓冲区的内存组合是最主要一种的系统内存组合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">alloc_skb</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> priority)</span></span><br></pre></td></tr></table></figure>
<p>创建一个新的<code>sk_buff</code>结构并将它初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> rw)</span></span><br></pre></td></tr></table></figure>
<p>释放一个<code>skb_buff</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">skb_clone</span><span class="params">(<span class="keyword">struct</span> sk_buff *old, <span class="type">int</span> priority)</span></span><br></pre></td></tr></table></figure>
<p>复制一个<code>sk_buff</code>，但不复制数据部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">skb_copy</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br></pre></td></tr></table></figure>
<p>完全复制一个<code>sk_buff</code>。</p>
<h4 id="对sk-buff结构数据区进行操作的操作"><a href="#对sk-buff结构数据区进行操作的操作" class="headerlink" title="对sk_buff结构数据区进行操作的操作"></a>对sk_buff结构数据区进行操作的操作</h4><p>这些函数用到了套接字结构体中两个域：缓冲区长度<code>skb-&gt;len</code>和缓冲区中数据包的实际起始地址<code>skb-&gt;data</code>。这些两个域对用户来说是可见的，而且它们具有只读属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_headroom</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br></pre></td></tr></table></figure><br>返回<code>sk_buff</code>结构头部空闲空间的字节数大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_pull</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> len)</span> </span><br></pre></td></tr></table></figure>
<p>该函数将<code>data</code>指针向数据区的末尾移动，减少了<code>len</code>字段的长度。该函数可用于从接收到的数据头上移去数据或协议头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_push</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> len)</span></span><br></pre></td></tr></table></figure>
<p>该函数将<code>data</code>指针向数据区的前端移动，增加了<code>len</code>字段的长度。在发送数据的过程中，利用该函数可在数据的前端添加数据或协议头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_put</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> len)</span></span><br></pre></td></tr></table></figure>
<p>该函数将<code>tail</code>指针向数据区的末尾移动，增加了<code>len</code>字段的长度。在发送数据的过程中，利用该函数可在数据的末端添加数据或协议尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_reserve</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> len)</span></span><br></pre></td></tr></table></figure>
<p>该函数在缓冲区头部创建一块额外的空间，这块空间在<code>skb_push</code>添加数据时使用。因为套接字建立时并没有为<code>skb_push</code>预留空间。它也可以用于在缓冲区的头部增加一块空白区域，从而调整缓冲区的大小，使缓冲区的长度统一。这个函数只对一个空的缓冲区才能使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_tailroom</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br></pre></td></tr></table></figure>
<p>返回<code>sk_buff</code>尾部空闲空间的字节数大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_trim</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> len)</span></span><br></pre></td></tr></table></figure>
<p>该函数和<code>put</code>函数的功能相反，它将<code>tail</code>指针向数据区的前端移动，减小了<code>len</code>字段的长度。该函数可用于从接收到的数据尾上移去数据或协议尾。如果缓冲区的长度比<code>len</code>还长，那么它就通过移去缓冲区尾部若干字节，把缓冲区的大小缩减到<code>len</code>长度。</p>
<h3 id="套接字缓冲区的上层支持例程"><a href="#套接字缓冲区的上层支持例程" class="headerlink" title="套接字缓冲区的上层支持例程"></a>套接字缓冲区的上层支持例程</h3><p>我们上面讲了套接字缓冲区基本的操作方法，利用它们就可以完成数据包的发送和接收工作。为了保证网络传输的高效和稳定，我们需要对整个过程进行流程控制，因此，我们又引进了两个支持例程。它们是利用信号的交互来完成任务的。<br><code>sock_queue_rcv_skb()</code>函数用来对数据的接收进行控制，通常调用它的的形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sk=my_find_socket(whatever);</span><br><span class="line"><span class="keyword">if</span>(sock_queue_rcv_skb(sk,skb)==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	myproto_stats.dropped++;</span><br><span class="line">	kfree_skb(skb,FREE_READ);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它利用套接字的读队列的计数器，从而避免了大量的数据包堆积在套接字层。一旦到达这个极限，其余的数据包就会被丢弃。这样做是为了保障高层的应用协议有足够快的读取速度，比如<code>TCP</code>，包含对该流程的控制，当接收端不能再接收数据时，<code>TCP</code>就告诉发送端的机器停止传输。</p>
<p>在数据传输方面，<code>sock_alloc_send_skb()</code>可以对发送队列进行控制, 我们不能把所有的缓冲区都填充数据，使得发送队列总有空余, 避免了数据堵塞。这个函数在具体应用时有很多微妙之处，所以推荐编写网络协议的作者尽可能使用它。</p>
<p>许多发送例程利用这个函数几乎可以做所有的工作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">skb=sock_alloc_send_skb(sk,....)</span><br><span class="line"><span class="keyword">if</span>(skb==<span class="literal">NULL</span>) </span><br><span class="line">	<span class="keyword">return</span> -err;</span><br><span class="line">skb-&gt;sk=sk;</span><br><span class="line">skb_reserve(skb, headroom);</span><br><span class="line">skb_put(skb,len);</span><br><span class="line"><span class="built_in">memcpy</span>(skb-&gt;data, data, len);</span><br><span class="line">protocol_do_something(skb);</span><br></pre></td></tr></table></figure></p>
<p>上面大部分代码我们前面已经见过。其中最重要的一句是<code>skb-&gt;sk=sk</code>。<code>sock_alloc_send_skb()</code>负责把缓冲区送到套接字层。通过设置<code>skb-&gt;sk</code>，告诉内核无论哪个例程对缓冲区进行<code>kfree_skb()</code>处理，都必须保证缓冲区已经成功地送到套接字层。因此一旦网络设备驱动程序发送一个缓冲区，并将之释放，我们就认为数据已经发送成功，这样我们就可以继续发送数据了 。 在源代码中我们看到<code>kfree_skb</code>操作一执行就会触发<code>sock_alloc_send_skb()</code>。</p>
<h2 id="网络设备接口"><a href="#网络设备接口" class="headerlink" title="网络设备接口"></a>网络设备接口</h2><p>文件<code>drivers/net/skeleton.c</code>包含了网络设备驱动程序的基本骨架。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>如图 12.14 是网络设备驱动程序的结构，从中我们可以看出，网络设备驱动程序的功能分为两部分：发送数据和接受数据。在发送数据时，设备驱动程序全权负责把来自协议层的网络缓冲区发送到物理介质，并且接收硬件产生的应答信号；在接收数据时，设备驱动程序接收来自网络介质上的数据帧，并把它转换成能被网络协议识别的网络缓冲区，然后把它传递给<code>netif_rx ()</code>函数。这个函数的功能是把数据帧传递到网络协议层进行进一步的处理。</p>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>所有的<code>Linux</code>网络设备都有唯一的名字，这个名字和文件系统所规定的设备的名字没有任何联系。事实上，网络设备并没有使用文件系统的表示方法。 传统上名字只表示设备类型而不代表生产厂商，如果同一类型的网络设备有多个，它们的名字就用从 0 开始的数字加以区别</p>
<h3 id="设备注册"><a href="#设备注册" class="headerlink" title="设备注册"></a>设备注册</h3><p>每一个设备的建立都需要在设备数据结构类型中添加一个设备对象，并将它传递给<code>register_netdev(struct device *)</code>函数。这样就把你的设备数据结构和内核中的网络设备表联系起来。如果你要传递的数据结构正被内核使用，就不能释放它们，直到你卸载该设备，卸载设备用到<code>unregister_netdev(struct device *)</code>函数。这些函数调用通常在系统启动时或网络模块安装或卸载时执行。</p>
<p>内核不允许用同一个名字安装多个设备。因此，如果你的设备是可安装的模块，就应该利用<code>struct device *dev_get(const char *name)</code>函数来确保名字没有被使用。如果名字已经被使用，那么就必须另选一个，否则新的设备将安装失败。如果发现有设备冲突，就可以使用<code>unregister_netdev()</code>注销一个使用该名字的设备。</p>
<p>下面是一个典型的设备注册的源代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_my_device</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(mydevice.name,<span class="string">&quot;mydev%d&quot;</span>,i);</span><br><span class="line">		<span class="keyword">if</span>(dev_get(mydevice.name)==<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(register_netdev(&amp;mydevice)!=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EIO;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;100 mydevs loaded. Unable to load more.&lt;\\&gt;n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> -ENFILE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="网络设备数据结构"><a href="#网络设备数据结构" class="headerlink" title="网络设备数据结构"></a>网络设备数据结构</h3><p>网络设备数据结构<code>device</code>，是网络驱动程序的最重要的部分，也是理解<code>Linux</code>网络接口的关键，它的源代码保存在<code>include/linux/netdevice.h</code>中。</p>
<h4 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h4><p><code>name</code>域指网络设备的名称，我们应该按上面讨论的命名方式为设备起名。该域也可以为空，这种情况下系统自动地分配一个<code>ethn</code>名字。在<code>Linux 2.0</code>版本以后，我们可以用<code>dev_make_name(&quot;eth&quot;)</code>函数来为设备命名。</p>
<h4 id="总线接口参数"><a href="#总线接口参数" class="headerlink" title="总线接口参数"></a>总线接口参数</h4><p>总线接口参数用来设置设备在设备地址空间的位置。</p>
<ul>
<li><code>irq</code>：指设备使用的中断请求号(IRQ)，它通常在启动时或被初始化函数时设置。如果设备没有分配中断请求号，该域可以置 0。中断请求号也可以设置为变量，由系统自动搜索一个空闲的中断请求号分配给该设备。 网络设备驱动程序通常使用一个全局整型变量<code>irq</code>表示中断号，因此用户可以使用<code>insmod mydevice irq=5</code>这样的命令装载一个网络设备。最后，<code>IRQ</code>域也可以利用<code>ifconfig</code>命令很方便地进行设置。</li>
<li><code>base_addr</code>(基地址)：指设备占用的基本输入输出(I/O)地址空间。如果设备没有被分配<code>I/O</code>地址或该设备运在一个没有<code>I/O</code>空间概念的系统上，该域就置 0。当该地址由用户设置时，它通常用一个全局变量<code>io</code>来表示。<code>I/O</code>接口地址也可以由<code>ifconfig</code>设置。</li>
<li>网络设备存在着两个硬件共享内存空间的情况，例如<code>ISA</code>总线和以太网卡共享内存空间。在网络设备的<code>device</code>数据结构中有 4 个相关的域。在共享内存时，<code>rmem_start</code>和<code>rmem_end</code>域就被舍弃，并且置 0；<code>mem_start</code>和<code>mem_end</code>两个域标识设备共享内存块的起始地址和结束地址。如果没有共享内存的情况，上面两个域就置 0。有一些设备允许用户设置内存地址，我们通常用一个全局变量<code>mem</code>表示。</li>
<li><code>dma</code>：标志设备正在使用的<code>DMA</code>通道。<code>Linux</code>允许<code>DMA</code>(像中断一样)被系统自动探测。如果没有使用<code>DMA</code>通道或<code>DMA</code>通道没有设置，该域就置 0。如果由用户设置<code>DMA</code>通道，通常使用一个全局变量<code>dma</code>来表示。</li>
<li><code>if_port</code>：标识一些多功能网络设备的类型，例如<code>combo Ethernet boards</code>。</li>
</ul>
<h4 id="协议层参数"><a href="#协议层参数" class="headerlink" title="协议层参数"></a>协议层参数</h4><ul>
<li><code>mtu</code>：指网络接口的最大负荷，也就是网络可以传输的最大的数据包尺寸，它不包括设备自身提供的低层数据头的大小，该值常被协议层(如`IP)使用，用来选择大小合适数据包进行发送。</li>
<li><code>family</code>：指该设备支持的地址族。常用的地址族是<code>AF_INET</code>。<code>Linux</code>允许一个设备同时使用多个地址族。</li>
<li><code>interface hardware type</code>：指设备所连接的物理介质的硬件接口类型，它的值来自物理介质类型表。支持<code>ARP</code>的物理介质，它们的接口类型被<code>ARP</code>使用；其他的接口类型是为其他物理层定义的。新的接口类型，只有当它对内核和<code>net-tools</code>都是必需时才会添加。包含像<code>ifconfig</code>这样的工具包可以对该域进行解码。该域的定义形式为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ARPHRD_NETROMARPHRD_ETHER <span class="number">10</span>mbit/s`和 <span class="number">100</span>mbit/s`以太网卡</span><br><span class="line">ARPHRD_EETHER`实验用网卡 (没有使用)</span><br><span class="line">ARPHRD_AX25 AX.<span class="number">25</span> <span class="number">2</span> 级接口</span><br><span class="line">ARPHRD_PRONET PROnet token <span class="title function_">ring</span> <span class="params">(没有使用)</span></span><br><span class="line">ARPHRD_CHAOS <span class="title function_">ChaosNET</span> <span class="params">(没有使用)</span></span><br><span class="line">ARPHRD_IEE802 802.2 networks notably token ring</span><br><span class="line">ARPHRD_ARCNET ARCnet`接口</span><br><span class="line">ARPHRD_DLCI Frame Relay DLCI</span><br></pre></td></tr></table></figure>
<p>由<code>Linux</code>定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ARPHRD_SLIP Serial Line IP protocol</span><br><span class="line">ARPHRD_CSLIP SLIP with VJ header compression</span><br><span class="line">ARPHRD_SLIP6 <span class="number">6b</span>it encoded SLIP</span><br><span class="line">ARPHRD_CSLIP6 <span class="number">6b</span>it encoded header compressed SLIP</span><br><span class="line">ARPHRD_ADAPT SLIP interface in adaptive mode</span><br><span class="line">ARPHRD_PPP PPP <span class="title function_">interfaces</span> <span class="params">(async and sync)</span></span><br><span class="line">ARPHRD_TUNNEL IPIP tunnels</span><br><span class="line">ARPHRD_TUNNEL6 IPv6 over IP tunnels</span><br><span class="line">ARPHRD_FRAD Frame Relay Access Device</span><br><span class="line">ARPHRD_SKIP SKIP encryption tunnel</span><br><span class="line">ARPHRD_LOOPBACK Loopback device</span><br><span class="line">ARPHRD_LOCALTLK Localtalk apple networking device</span><br><span class="line">ARPHRD_METRICOM Metricom Radio Network</span><br></pre></td></tr></table></figure></p>
<p>上面标注“没有使用”的接口，是因为它们虽然被定义了类型，但是目前还没有支持它们的<code>net-tools。Linux</code>内核为以太网和令环网提供了额外的支持例程。</p>
<ul>
<li>pa_addr：用来保持<code>IP</code>地址。</li>
<li>pa_brdaddr：网络广播地址。</li>
<li>pa_dstaddr：点对点连接中的目标地址。</li>
<li>pa_mask：网络掩码。</li>
<li>上面所有域都被初始化为 0。</li>
<li>pa_alen：保存一个地址的长度，就<code>IP</code>地址而言，应该初始化为 4。</li>
</ul>
<h3 id="支持函数"><a href="#支持函数" class="headerlink" title="支持函数"></a>支持函数</h3><h4 id="初始化设置-init"><a href="#初始化设置-init" class="headerlink" title="初始化设置(init)"></a>初始化设置(init)</h4><p><code>init</code>函数在设备初始化和注册时被调用，它执行的是底层的确认和检查工作。在初始化程序里可以完成对硬件资源的配置。如果设备没有就绪或设备不能注册或其他任何原因而导致初始化工作不能正常进行，该函数就返回出错信息。一旦初始化函数返回出错信息，<code>register_netdev()</code>也返回出错信息，这样该设备就不能安装。</p>
<h4 id="打开-open"><a href="#打开-open" class="headerlink" title="打开(open)"></a>打开(open)</h4><p><code>open</code>这个函数在网络设备驱动程序里是网络设备被激活的时候被调用(即设备状态由down—&gt;up)。所以实际上很多在<code>init</code>中的工作可以放到这里来做。比如资源的申请，硬件的激活。如果<code>dev-&gt;open</code>返回非零(error)，则硬件的状态还是<code>down</code>。<code>open</code>函数另一个作用是如果驱动程序作为一个模块被装入，则要防止模块卸载时设备处于打开状态。在<code>open</code>方法里要调用<code>MOD_INC_USE_COUNT</code>宏。</p>
<h4 id="关闭-stop"><a href="#关闭-stop" class="headerlink" title="关闭(stop)"></a>关闭(stop)</h4><p><code>close</code>函数做和<code>open</code>函数相反的工作。可以释放某些资源以减少系统负担。<code>close</code>是在设备状态由<code>up</code>转为<code>down</code>时被调用的。另外如果是作为模块装入的驱动程序，<code>close</code>里应调用<code>MOD_DEC_USE_COUNT</code>，减少设备被引用的次数，以使驱动程序可以被卸载。另外<code>close</code>方法必须返回成功(0==success)。</p>
<h4 id="数据帧传输例程"><a href="#数据帧传输例程" class="headerlink" title="数据帧传输例程"></a>数据帧传输例程</h4><p>所有的设备驱动程序都必须提供传输例程，如果一个设备不能传输，也就没有存在的必要性。事实上，设备的所谓的传输仅仅是释放传送给它的缓冲区，而真正实现传输功能是虚拟设备。</p>
<p><code>dev-&gt;hard_start_xmit()</code>：该函数的功能是将网络缓冲区，也就是<code>sk_buff</code>发送到硬件设备。如果设备不能接受缓冲区，它就会返回 1，并置<code>dev-&gt;tbusy</code>为非零值。这样缓冲区就排成队列，等待着<code>dev-&gt;tbusy</code>置零以后会再次发送。如果协议层决定释放被设备抛弃的缓冲区，那么缓冲区就不会再被送回设备；如果设备知道缓冲区短时间内不被能传送，例如设备严重堵塞，那么它就调用<code>dev_kfree_skb()</code>函数丢掉缓冲区，该函数返回零值标明缓冲区已经被处理完毕。</p>
<p>当缓冲区被传送到硬件以后，硬件应答信号标识传输已经完毕，驱动程序必须调用<code>dev_kfree_skb(skb, FREE_WRITE)</code>函数释放缓冲区，一旦该调用结束，缓冲区就会很自然地消失，这样，驱动程序就不能再涉及缓冲区了。该函数传送下来的<code>sk_buff</code>中的数据已经包含硬件需要的帧头。所以在发送方法里不需要再填充硬件帧头，数据可以直接提交给硬件发送。<code>sk_buff</code>是被锁住的(ocked)确保其他程序不会存取它。</p>
<h4 id="硬件帧头"><a href="#硬件帧头" class="headerlink" title="硬件帧头"></a>硬件帧头</h4><p>网络设备驱动程序提供了一个<code>dev-&gt;hard_header()</code>例程，来完成添加硬件帧头的工作。协议层在发送数据之前会在缓冲区的开始留下至少<code>dev-&gt;hard_header_len</code>长度字节的空闲空间。这样<code>dev-&gt;hard_header()</code>程序只要调用<code>skb_push()</code>，然后正确填入硬件帧头就可以了。</p>
<p>调用这个例程需要给出和缓冲区相关的信息：设备指针、协议类型、指向源地址和目标地址(指硬件地址)的指针、数据包的长度。源地址可以为“NULL”，这意味着“使用默认地址”；目标地址也可以为“NULL”，这意味着“目标未知”。如果目标地址“未知”，数据帧头的操作就不能完成，本来为硬件帧头预留的空间全部被其他信息占用，那么函数就返回填充硬件帧头空间的字节数的相反数(一定为负数)。当硬件帧头完全建立以后，函数返回所添加的数据帧头的字节数。</p>
<p>如果一个硬件帧头不能够完全建立，协议层必须试图解决地址问题，因为硬件地址对于数据的发送是必需的。一旦这种情况发生，<code>dev-&gt;rebuild_header()</code>函数就会被调用，通常是利用<code>ARP</code>(地址解析协议)来完成。如果硬件帧头还不能被解决，该函数就返回零，并且会再次尝试，协议层总是相信硬件帧头的解决是可能的。</p>
<h4 id="数据接收"><a href="#数据接收" class="headerlink" title="数据接收"></a>数据接收</h4><p>网络设备驱动程序没有关于接收的处理，当数据到来时，总是驱动程序通知系统。对一个典型的网络设备，当它收到数据后都会产生一个中断，中断处理程序调用<code>dev_alloc_skb()</code>，申请一个大小合适的缓冲区<code>sk_buff</code>，把从硬件传来的数据放入缓冲区。接着，设备驱动程序分析数据包的类型，把<code>skb-&gt;dev</code>设置为接收数据的设备类型，把<code>skb-&gt;protocol</code>设置为数据帧描述的协议类型，这样，数据帧就可以被发送到正确的协议层。</p>
<p>硬件帧头指针保存在<code>skb-&gt;mac.raw</code>中，并且硬件帧头通过调用<code>skb_pull()</code>被去掉，因此网络协议就不涉及硬件的信息。最后还要设置<code>skb-&gt;pkt_type</code>，标明链路层数据类型，设备驱动程序必须按以下类型设置<code>skb-&gt;pkt_type</code>：</p>
<ul>
<li><code>PACKET_BROADCAST</code>链接层广播地址</li>
<li><code>PACKET_MULTICAST</code>链接层多路地址</li>
<li><code>PACKET_SELF</code>发给自己的数据帧</li>
<li><code>PACKET_OTHERHOST</code>发向另一个主机的数据帧(监听模式时会收到)</li>
</ul>
<p>最后，设备驱动程序调用<code>netif_rx()</code>，把缓冲区向上传递给协议层。缓冲区首先排成一个队列，然后发出中断请求，中断请求响应后，缓冲区队列才被协议层进行处理。这种处理机制，延长了缓冲区等待处理的时间，但是减少了请求中断的次数，从而整体上提高了数据传输效率。一旦<code>netif_rx()</code>被调用，缓冲区就不在属设备驱动程序所有，它不能被修改，而且设备驱动程序也不能再涉及它了。</p>
<p>在协议层，接收数据包的流程控制分两个层次：首先，<code>netif_rx()</code>函数限制了从物理层到协议层的数据帧的数量。第二，每一个套接字都有一个队列，限制从协议层到套接字层的数据帧的数量。在传输方面，驱动程序的<code>dev-&gt;tx_queue_len</code>参数用来限制队列的长度。</p>
<p>队列的长度通常是 100 帧，在进行大量数据传输的高速连接中，它足以容纳下所有等待传输的缓冲区，不会出现大量缓冲区阻塞的情况。在低速连接中，例如<code>slip</code>连接，队列的长度长设为 10 帧左右，因为传输 10 帧的数据就要花费数秒的时间排列数据。</p>
<h1 id="Linux系统的启动"><a href="#Linux系统的启动" class="headerlink" title="Linux系统的启动"></a>Linux系统的启动</h1><h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><p>每一个操作系统都要有自己的初始化程序，Linux`也不例外。那么，怎样初始化？我们<br>首先看一下初始化的流程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加电或复位 -&gt; BIOS`的启动 -&gt; Boot Loader -&gt; 操作系统 -&gt; 初始化</span><br></pre></td></tr></table></figure></p>
<p>加电或复位这一项代表操作者按下电源开关或复位按钮那一瞬间计算机完成的工作。<code>BIOS</code>的启动是紧跟其后的基于硬件的操作，它的主要作用就是完成硬件的初始化。<code>BIOS</code>启动完成后，Boot Loader`将读操作系统代码，然后由操作系统来完成初始化剩下的所有工作。 </p>
<h3 id="系统加电或复位"><a href="#系统加电或复位" class="headerlink" title="系统加电或复位"></a>系统加电或复位</h3><p>当一台装有<code>Intel 386 CPU</code>的计算机系统的电源开关或复位按钮被按下时，通常所说的冷启动过程就开始了。中央处理器进入复位状态，它将内存中所有的数据清零，并对内存进行校验，如果没有错误，<code>CS</code>寄存器中将置入<code>FFFF[0]</code>，<code>IP</code>寄存器中将置入 0000[0]，其实，这个<code>CS:IP</code>组合指向的是<code>BIOS</code>的入口，它将作为处理器运行的第一条指令。系统就是通过这个方法进入<code>BIOS</code>启动过程的。</p>
<h3 id="BIOS-启动"><a href="#BIOS-启动" class="headerlink" title="BIOS`启动"></a>BIOS`启动</h3><p><code>BIOS</code>的全名是基本输入输出系统(Basic Input Output System)。它的主要任务是提供<code>CPU</code>所需的启动指令。刚才提到了，计算机进入复位状态后，内存被自动清零，<code>CPU</code>此时是无法获得指令的。计算机的设计者们当然考虑到了这一点，因此，他们预先编好了供系统启动使用的启动程序，把它们存放在<code>ROM</code>中，并安排它到一个固定的位置，即<code>FFFF:0000</code>，<code>CPU</code>就从<code>BIOS</code>中获得了启动所需的指令集。该指令集除了完成硬件的启动过程以外，还要将软盘或硬盘上的有关启动的系统软件调入内存。</p>
<p>首先是上电自检(POST Power-On Self Test)，然后是对系统内的硬件设备进行监测和连接，并把测试所得的数据存放到<code>BIOS</code>数据区，以便操作系统在启动时或启动后使用，最后，<code>BIOS</code>将从软盘或硬盘上读入<code>Boot Loader</code>，到底是从软盘还是从硬盘启动要看<code>BIOS</code>的设置，如果是从硬盘启动，<code>BIOS</code>将读入该盘的零柱面零磁道上的 1 扇区(MBR)，这个扇区上就存放着<code>Boot Loader</code>，该扇区的最后一个字存放着系统标志，如果该标志的值为<code>AA55</code>，<code>BIOS</code>在完成硬件监测后会把控制权交给<code>Boot Loader</code>。</p>
<p>除了启动程序以外，<code>BIOS</code>还提供一组中断以便对硬件设备的访问。我们知道，当键盘上的某一键被按下时，<code>CPU</code>就会产生一个中断并把这个键的信息读入，在操作系统没有被装入以前(如<code>Linux</code>的<code>Bootsect.S</code>还没有被读入)或操作系统没有专门提供另外的中断响应程序的情况下，中断的响应程序就是由<code>BIOS</code>提供的。</p>
<p>这里介绍一个具体的<code>BIOS</code>系统，它的上电自检(POST)程序包含 14 个项目，具体内容如表所示，执行过<code>POST</code>后，该系统将调入硬盘上的<code>Boot Loader</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>相应内容</th>
<th>序号</th>
<th>相应内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>CPU处理器内部寄存器测试</td>
<td>8</td>
<td>键盘复位和测试</td>
</tr>
<tr>
<td>2</td>
<td>32K RAM存储器测试</td>
<td>9</td>
<td>键盘复位和测试</td>
</tr>
<tr>
<td>3</td>
<td>DMA控制器测试</td>
<td>10</td>
<td>附加RAM存储器测试</td>
</tr>
<tr>
<td>4</td>
<td>32K RAM存储器测试</td>
<td>11</td>
<td>其他包含在系统中的BIOS测试</td>
</tr>
<tr>
<td>5</td>
<td>CRT视频接口测试</td>
<td>12</td>
<td>软盘设备测试</td>
</tr>
<tr>
<td>6</td>
<td>8259中断控制器测试</td>
<td>13</td>
<td>硬盘设备测试</td>
</tr>
<tr>
<td>7</td>
<td>8253 定时器测试</td>
<td>14</td>
<td>打印机接口和串行接口测试</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Boot-Loader"><a href="#Boot-Loader" class="headerlink" title="Boot Loader"></a>Boot Loader</h3><p><code>Boot Loader</code>通常是一段汇编代码，存放在<code>MBR</code>中，它的主要作用就是将系统启动代码读入内存。</p>
<h3 id="操作系统的初始化"><a href="#操作系统的初始化" class="headerlink" title="操作系统的初始化"></a>操作系统的初始化</h3><p>这部分实际上是初始化的关键。<code>Boot Loader</code>将控制权交给操作系统的初始化代码后，操作系统所要完成的存储管理、设备管理、文件管理、进程管理等任务的初始化必须马上进行，以便进入用户态。其实不管是单任务的<code>DOS</code>操作系统还是这里介绍的多任务<code>Linux</code>操作系统，当启动过程完成以后，系统都进入用户态，等待用户的操作命令。</p>
<h2 id="Linux的Boot-Loader"><a href="#Linux的Boot-Loader" class="headerlink" title="Linux的Boot Loader"></a>Linux的Boot Loader</h2><h3 id="Boot-Loader-1"><a href="#Boot-Loader-1" class="headerlink" title="Boot Loader"></a>Boot Loader</h3><p>实际上<code>Boot Loader</code>的来源有多种，最常见的一种是你的操作系统就是<code>DOS</code>，而<code>Boot Loader</code>是<code>DOS</code>系统提供的<code>MS-Boot Loader</code>。这种情况下比较简单：如果是软盘启动，<code>Boot Loader</code>会检查盘上是否存在两个隐含的系统文件(IBMBIO.COM、IBMDOS.COM)，若有，读出并送至内存中指定的区域，把控制权转移给<code>IBMBIO</code>这个模块，否则显示出错信息。如果是硬盘启动，<code>Boot Loader</code>将查找主分区表中标记为活动分区的表项，把该表项对应的分区的引导扇区读入，然后把控制权交给该扇区内的引导程序，这段程序也可以被看作是<code>Boot Loader</code>的一部分，它完成的工作与软盘的<code>Boot Loader</code>大致相同。</p>
<h3 id="LILO"><a href="#LILO" class="headerlink" title="LILO"></a>LILO</h3><p><code>LILO</code>是一个在<code>Linux</code>环境编写的<code>Boot Loader</code>程序(所以安装和配置它都要在<code>Linux</code>下)。它不但可以作为<code>Linux</code>分区的引导扇区内的启动程序，还可以放入<code>MRB</code>中完全控制<code>Boot Loadr</code>的全过程。</p>
<p><code>LILO</code>的功能实际上是由几个程序共同实现的，它们是:</p>
<ul>
<li>Map Installer：这是<code>LILO</code>用于管理启动文件的程序。它可以将<code>LILO</code>启动时所需的文件放置到合适的位置(这些文件的位置由<code>LILO</code>本身决定)并且记录下这些位置，以便<code>LILO</code>访问。其实，当运行<code>/sbin/lilo</code>这个程序时，<code>Map installer</code>就已经工作了，它将<code>Boot Loader</code>写入引导分区(原来的<code>Boot Loader</code>将被备份)，创建记录文件<code>map file</code>以映射内核的启动文件。每当内核发生变化时(比如说内核升级了)，你必须运行<code>/sbin/lilo</code>来保证系统的正常运行。</li>
<li>Boot Loader：这就是由<code>BIOS</code>读入内存的那部分<code>LILO</code>的程序，它负责把<code>Linux</code>的内核或其他操作系统的引导分区读入内存。另外，Linux<code>的</code>Boot Loader`还提供一个命令行接口，可以让用户选择从哪个操作系统启动和加入启动参数。</li>
<li>其他文件：这些文件主要包括用于存放<code>Map installer</code>记录的<code>map</code>文件(<code>/boot/map</code>)和存放<code>LILO</code>配置信息的配置文件(<code>/etc/lilo.conf</code>)，这些文件都是<code>LILO</code>启动时必需的，它们一般存放在<code>/boot</code>目录下。</li>
</ul>
<h3 id="LILO的运行分析"><a href="#LILO的运行分析" class="headerlink" title="LILO的运行分析"></a>LILO的运行分析</h3><h4 id="从软盘启动"><a href="#从软盘启动" class="headerlink" title="从软盘启动"></a>从软盘启动</h4><p><code>Linux</code>内核可以存入一张<code>1.44MB</code>的软盘中，这样做的前提是对“Linux`内核映像”进行压缩，压缩是在编译内核时进行的，而解压是由装入程序在引导时进行的。</p>
<p>当从软盘引导<code>Linux</code>时，<code>Boot Loader</code>比较简单，其代码在<code>arch/i386/boot/bootsect.S</code>汇编语言文件中。当编译<code>Linux</code>内核源码时，就获得一个新的内核映像，这个汇编语言文件所产生的可执行代码就放在内核映像文件的开始处。因此，制作一个包含<code>Linux</code>内核的软磁盘并不是一件困难的事。</p>
<p>把内核映像的开始处拷贝到软盘的第 1 个扇区就创建了一张启动软盘。当<code>BIOS</code>装入软盘的第 1 个扇区时，实际上就是拷贝<code>Boot Loader</code>的代码。<code>BIOS</code>将<code>Boot Loader</code>读入至内存中物理地址 0x07c00 处，控制权转给<code>Boot Loader</code>，<code>Boot Loader</code>执行如下操作。 </p>
<ul>
<li>把自己从地址 0x07c00 移到 0x90000。</li>
<li>利用地址 0x03ff，建立“实模式”栈。</li>
<li>建立磁盘参数表，这个表由<code>BIOS</code>用来处理软盘设备驱动程序。</li>
<li>通过调用<code>BIOS</code>的一个过程显示“Loading”信息。</li>
<li>然后，调用<code>BIOS</code>的一个过程从软盘装入内核映像的<code>setup()</code>代码，并把这段代码放入从地址 0x90200 开始的地方。</li>
<li>最后再调用<code>BIOS</code>的一个过程。这个过程从软盘装入内核映像的其余部分，并把映像放在内存中从地址 0x10000 开始的地方，或者从地址 0x100000 开始的地方，前者叫做“低地址”的小内核映像(以“make zImage”进行的编译)，后者叫做“高地址”的大内核映像(以“make bzImage”)进行的编译。</li>
</ul>
<h4 id="从硬盘启动"><a href="#从硬盘启动" class="headerlink" title="从硬盘启动"></a>从硬盘启动</h4><p>一般情况下，<code>Linux</code>内核都是从硬盘装入的。<code>BIOS</code>照样将引导扇区读入至内存中的0x00007c00处，控制权转给<code>Boot Loader</code>，<code>Boot Loader</code>把自身移动至 0x90000处，并在 0x9B000处建立堆栈(从 0x9B000 处向 0x9A200 增长)，将第 2 级的引导扇区读入至内存的 0x9B000处，把控制权交给它。在引导扇区移动之后，将显示一个大写的<code>L</code>字符，而在启动第 2 级的引导扇区之前，将显示一个大写的<code>I</code>字符。如果读入第 2 级的引导扇区的过程有错误，屏幕上的<code>LI</code>之后会显示一个十六进制的错误号。</p>
<p>二级引导扇区内的代码将把描述符表读入至内存中的 0x9D200 处，把包含有命令行解释程序的扇区读入至内存的 0x9D600 处。接着，二级引导扇区将等待用户的输入，不管这时用户输入了一个选择还是使用缺省配置，都将把对应的扇区读入至内存的 0x9D600(覆盖命令行解释程序的空间)，把生成的启动参数保存在 0x9D800 处。</p>
<p>如果用户定义了用于启动的<code>RAM</code>盘的话，这部分文件将被读入到物理内存的末尾。如果你的内存大于<code>16MB</code>的话，它会被读入至<code>16MB</code>内存的结尾，这是因为<code>BIOS</code>程序不支持对 16MB以上内存的访问(它用于寻址的指令中只有 24 位的地址描述位)。并且它开始于一个新的页，以便于启动后系统把它所占的内存回收到内存池。</p>
<p>接下来，操作系统的初始化代码将被读入到内存的 0x90200 处。而系统的内核将被读入到 0x10000 处。如果该内核是以<code>make bzImage</code>方式编译的，它将被读入到内存的 0x100000处。在读入的过程中，存放<code>map</code>文件的扇区被读入至内存的 0x9D000 处。如果读入的<code>image</code>是<code>Linux</code>的内核，控制权将交给处于 0x90200 的<code>Setup.S</code>。如果读入的是另外的操作系统，过程要稍微麻烦一点:<code>chain loader</code>被读入到内存的 0x90200 处。该系统用于启动的扇区被读入到 0x90400。<code>chain loader</code>将把它所包含的分区表移到 0x00600处，把引导扇区读入到 0x07c00。做完这一切，它把控制权交给引导扇区。</p>
<p>第 2 级引导扇区在得到控制权以后马上显示一个大写的<code>L</code>字符。读入命令行解释程序后显示一个大写的<code>O</code>字符。</p>
<p>图 13.11 是<code>LILO</code>运行完后，内存的分布情况。<br><img src="/img/1634199605.jpg" alt=""></p>
<h2 id="进入操作系统"><a href="#进入操作系统" class="headerlink" title="进入操作系统"></a>进入操作系统</h2><p><code>Boot Loader</code>作了这么多工作，一言以蔽之，只是把操作系统的代码调入内存，所以，当它执行完后，自然该把控制权交给操作系统，由操作系统的启动程序来完成剩下的工作。上面已经提到了，<code>LILO</code>此时把控制权交给了<code>Setup.S</code>这段程序。该程序是用汇编语言编写的16 位启动程序，它作了些什么呢？</p>
<h3 id="Setup-S"><a href="#Setup-S" class="headerlink" title="Setup.S"></a>Setup.S</h3><p>首先，<code>Setup.S</code>对已经调入内存的操作系统代码进行检查，如果没有错误(所有的代码都已经被调入，并放至合适的位置), 它会通过<code>BIOS</code>中断获取内存容量信息，设置键盘的响应速度，设置显示器的基本模式，获取硬盘信息，检测是否有<code>PS/2</code>鼠标，这些操作，都是在386 的实模式下进行的，这时，操作系统就准备让<code>CPU</code>进入保护模式了。当然，要先屏蔽中断信号，否则，系统可能会因为一个中断信号的干扰而陷入不可知状态，然后再次设置 32位启动代码的位置，这是因为虽然预先对 32 位启动程序的存储位置有规定，但是<code>Boot Loader</code>(通常是<code>LILO</code>)有可能把 32 位的启动代码读入一个与预先定义的位置不同的内存区域，为了保证下一个启动过程能顺利进行，这一步是必不可少的。</p>
<p>完成上面的工作后，操作系统指令<code>lidt</code>和<code>lgdt</code>被调用了，中断向量表(idt)和全局描述符表(gdt)终于浮出水面了，此时的中断描述符表放置的就是开机时由<code>BIOS</code>设定的那张表，<code>gdt</code>虽不完善，但它也有了 4 项确定的内容，也就是说，这里已经定义了下面 4 个保护模式下的段。</p>
<p>(1) .word 0，0，0，0 ! 系统所定义的<code>NULL</code>段</p>
<p>(2) .word 0，0，0，0 ! 空段，未使用</p>
<p>(3)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.word 0xFFFF ! 4Gb (0x100000*0x1000 = 4Gb)大小的系统代码段</span><br><span class="line">.word 0x0000 !base address=0</span><br><span class="line">.word 0x9A00 ! 可执行代码段</span><br><span class="line">.word 0x00CF !粒度=4096</span><br></pre></td></tr></table></figure></p>
<p>(4)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.word 0xFFFF ! 4Gb(0x100000*0x1000 = 4Gb)大小的系统数据段</span><br><span class="line">.word 0x0000 ! base address=0</span><br><span class="line">.word 0x9200 !可读写段</span><br><span class="line">.word 0x00CF !粒度=4096</span><br></pre></td></tr></table></figure></p>
<p>此外，协处理器也需要重新复位。这几件事做完以后，<code>Setup.S</code>设置保护模式的标志位，重新取指令以后，再用一条跳转指令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmpi 0x100000，KERNEL_CS</span><br></pre></td></tr></table></figure><br>进入保护模式下的启动阶段，同时把控制权交给<code>Head.S</code>这段纯 32 位汇编代码。</p>
<h2 id="main-c中的初始化"><a href="#main-c中的初始化" class="headerlink" title="main.c中的初始化"></a>main.c中的初始化</h2><p><code>head.s</code>在最后部分调用<code>main.c</code>中的<code>start_kernel()</code>函数，从而把控制权交给了它。所以启动程序从<code>start_kernel()</code>函数继续执行。这个函数是<code>main.c</code>乃至整个操作系统初始化的最重要的函数，一旦它执行完了，整个操作系统的初始化也就完成了。</p>
<p>如前所述，计算机在执行<code>start_kernel()</code>前处已经进入了 386 的保护模式，设立了中断向量表并部分初始化了其中的几项，建立了段和页机制，设立了 9 个段，把线性空间中用于存放系统数据和代码的地址映射到了物理空间的头 4MB，可以说我们已经使 386 处理器完全进入了全面执行操作系统代码的状态。</p>
<p><code>start_kernel()</code>执行后，你就可以以一个用户的身份登录和使用<code>Linux</code>了。让我们来看看<code>start_kernel</code>到底做了些什么。<code>start_kernel()</code>这个函数是在<code>/init/main.c</code>中，这里也只是将<code>main.c</code>中较为重要的函数列举出来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_kernel()<span class="comment">/*定义于`init/main.c */</span></span><br><span class="line">&#123;</span><br><span class="line">	……</span><br><span class="line">	setup_arch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它主要用于对处理器、内存等最基本的硬件相关部分的初始化，初始化<code>RAM</code>盘所占用的空间等。其中，<code>setup_arch()</code>给系统分配了<code>intel</code>系列芯片统一使用的几个<code>I/O</code>端口的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paging_init(); <span class="comment">/*该函数定义于arch/i386/mm/init.c */</span></span><br></pre></td></tr></table></figure>
<p>它的具体作用是把线性地址中尚未映射到物理地址上的部分通过页机制进行映射。当<code>paging_init()</code>函数调用完后，页的初始化就整个完成了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap_init(); <span class="comment">/*该函数在arch/i386/kernel/traps.c中定义*/</span></span><br></pre></td></tr></table></figure>
<p>这个初始化程序是对中断向量表进行初始化，详见第四章。它通过调用<code>set_trap_gate</code>(或<code>set_system_gate</code>等)宏对中断向量表的各个表项填写相应的中断响应程序的偏移地址。事实上，<code>Linux</code>操作系统仅仅在运行<code>trap_init()</code>函数前使用<code>BIOS</code>的中断响应程序。一旦真正进入了<code>Linux</code>操作系统，<code>BIOS</code>的中断向量将不再使用。</p>
<p>另外，在<code>trap_init()</code>函数里，还要初始化第一个任务的<code>LDT</code>和<code>TSS</code>，把它们填入<code>Gdt</code>相应的表项中。第一个任务就是<code>init_task</code>这个进程，填写完后，还要把<code>init_task</code>的<code>TSS</code>和<code>LDT</code>描述符分别读入系统的<code>TSS</code>和<code>LDT</code>寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_IRQ()<span class="comment">/* 在arch/i386/kernel/irq.c中定义*/</span></span><br></pre></td></tr></table></figure>
<p>这个函数也是与中断有关的初始化函数。不过这个函数与硬件设备的中断关系更密切一些。</p>
<p>我们知道<code>intel</code>的 80386 系列采用两片 8259 作为它的中断控制器。这两片级连的芯片一共可以提供 16 个引脚，其中 15 个与外部设备相连，一个用于级连。可是，从操作系统的角度来看，怎么知道这些引脚是否已经使用;如果一个引脚已被使用，<code>Linux</code>操作系统又怎么知道这个引脚上连的是什么设备呢?在内核中，同样是一个数组(静态链表)来纪录这些信息的。这个数组的结构在<code>irq.h</code>中定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*handler)(<span class="type">int</span>， <span class="type">void</span> *， <span class="keyword">struct</span> pt_regs *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mask;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">void</span> *dev_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看一个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">math_error_irq</span><span class="params">(<span class="type">int</span> cpl， <span class="type">void</span> *dev_id， <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	outb(<span class="number">0</span>，<span class="number">0xF0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ignore_irq13 || !hard_math)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	math_error();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> <span class="title">irq13</span> =</span> &#123; math_error_irq, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;math error&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br></pre></td></tr></table></figure><br>该例子就是这个数组结构的一个应用，这个中断是用于协处理器的。在<code>init_irq()</code>这个函数中，除了协处理器所占用的引脚，只初始化另外一个引脚，即用于级连的 2 引脚。不过，这个函数并不仅仅做这些，它还为两片 8259 分配了<code>I/O</code>地址，对应于连接在管脚上的硬中断，它初始化了从 0x20 开始的中断向量表的 15 个表项(386 中断门)，不过，这时的中断响应程序由于中断控制器的引脚还未被占用，自然是空程序了。当我们确切地知道了一个引脚到底连接了什么设备，并知道了该设备的驱动程序后，使用<code>setup_x86_irq</code>这个函数填写该引脚对应的 386 的中断门时，中断响应程序的偏移地址才被填写进中断向量表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sched_init()<span class="comment">/*在/kernel/sched.c`中定义*/</span></span><br></pre></td></tr></table></figure>
<p>这个程序是名副其实的初始化程序：仅仅为进程调度程序的执行做准备。它所做的具体工作是调用<code>init_bh</code>函数(在<code>kernel/softirq.c</code>中)把<code>timer</code>、<code>tqueue</code>、<code>immediate</code>三个任务队列加入下半部分的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time_init()<span class="comment">/*在`arch/i386/kernel/time.c`中定义*/</span></span><br></pre></td></tr></table></figure>
<p>时间在操作系统中是个非常重要的概念。特别是在<code>Linux</code>、<code>UNIX</code>这些多任务的操作系统中它更是作为主线索贯穿始终，之所以这样说，是因为无论进程调度(特别是时间片轮转算法)还是各种守护进程(也可以称为系统线程，如页表刷新的守护进程)都是根据时间运作的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parse_options()<span class="comment">/*在main.c中定义*/</span></span><br></pre></td></tr></table></figure>
<p>这个函数把启动时得到的参数如<code>debug</code>、<code>init</code>等从命令行的字符串中分离出来，并把这些参数赋给相应的变量。这其实是一个简单的词法分析程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console_init()<span class="comment">/*在linux/drivers/char/tty_io.c中定义*/</span></span><br></pre></td></tr></table></figure>
<p>这个函数用于对终端的初始化。在这里定义的终端并不是一个完整意义上的<code>TTY</code>设备，它只是一个用于打印各种系统信息和有可能发生错误的出错信息的终端。真正的<code>TTY</code>设备以后还会进一步定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kmalloc_init()<span class="comment">/*在linux/mm/kmalloc.c中定义*/</span></span><br></pre></td></tr></table></figure>
<p><code>kmalloc</code>代表的是<code>kernel_malloc</code>的意思，它是用于内核的内存分配函数。而这个针对<code>kmalloc</code>的初始化函数用来对内存中可用内存的大小进行检查，以确定<code>kmalloc</code>所能分配的内存的大小。所以，这种检查只是检测当前在系统段内可分配的内存块的大小。</p>
<p>下面的几个函数是用来对<code>Linux</code>的文件系统进行初始化的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inode_init()<span class="comment">/*在Linux/fs/inode.c中定义*/</span></span><br></pre></td></tr></table></figure><br>这个函数是对<code>VFS</code>的索引节点管理机制进行初始化。这个函数非常简单：把用于索引节点查找的哈希表置入内存，再把指向第一个索引节点的全局变量置为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_cache_init()<span class="comment">/*在linux/fs/dcache.c中定义*/</span></span><br></pre></td></tr></table></figure>
<p>这个函数用来对<code>VFS</code>的目录缓存机制进行初始化。先初始化<code>LRU1</code>链表，再初始化<code>LRU2</code>链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer_init()<span class="comment">/*在linux/fs/buffer.c中定义*/</span></span><br></pre></td></tr></table></figure>
<p>这个函数用来对用于指示块缓存的<code>buffer free list</code>初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem_init()<span class="comment">/* 在arch/i386/mm/init.c中定义*/</span></span><br></pre></td></tr></table></figure>
<p>启动到了目前这种状态，只剩下运行<code>/etc</code>下的启动配置文件。这些文件一旦运行，启动的全过程就结束了，系统也最终将进入我们所期待的用户态。</p>
<h2 id="建立init进程"><a href="#建立init进程" class="headerlink" title="建立init进程"></a>建立init进程</h2><p>在完成了上面所有的初始化工作后，<code>Linux</code>的运行环境已经基本上完备了。此时，<code>Linux</code>开始逐步建立进程了。</p>
<h3 id="init进程的建立"><a href="#init进程的建立" class="headerlink" title="init进程的建立"></a>init进程的建立</h3><p><code>Linux</code>将要建立的第一个进程是<code>init</code>进程，建立该进程是以调用<code>kernel_thread(init, NULL，0)</code>这个函数的形式进行的。<code>init</code>是<code>Linux</code>的第 1 个进程，也是其他所有进程的父进程。让我们来看一下它是怎样产生的。</p>
<p>在调用<code>kernel_thread(init, NULL, 0)</code>函数时，会调用<code>main.c</code>中的另外一个函数——<code>init()</code>。请注意<code>init()</code>函数和<code>init</code>进程是不同的概念。通过执行<code>inin()</code>函数，系统完成了下述工作。</p>
<ul>
<li>建立<code>dbflush</code>、<code>kswapd</code>两个新的内核线程。</li>
<li>初始化<code>tty1</code>设备。该设备对应了多个终端(concole)，用户登录时，就是登录在这些终端上的。</li>
<li>启动<code>init</code>进程。<code>Linux</code>首先寻找<code>/etc/init</code>文件，如果找不到，就接着找<code>/bin/init</code>文件，若仍找不到，再去找<code>/sbin/init</code>。如果仍无法找到，启动将无法进行下去。否则，便执行<code>init</code>文件，从而建立<code>init</code>进程。</li>
</ul>
<p>当<code>etc/init</code>(假定它存在)执行时，建立好的<code>init</code>进程将根据启动脚本文件的内容创建其它必要的进程去完成一些重要的操作。</p>
<ol>
<li>文件系统检查。</li>
<li>启动系统的守护进程。</li>
<li>对每个联机终端建立一个<code>getty</code>进程。</li>
<li>执行<code>/etc/rc</code>下的命令文件。</li>
</ol>
<p>此后，<code>getty</code>会在每个终端上显示<code>login</code>提示符，以等待用户的登录。此时<code>getty</code>会调用<code>exec</code>执行<code>login</code>程序，<code>login</code>将核对用户帐户和密码，如果密码正确，<code>login</code>调用<code>exec</code>执行<code>shell</code>的命令行解释程序。<code>shell</code>接着去执行用户默认的系统环境配置脚本文件(通常是用户的<code>home</code>目录下的<code>profile</code>文件)。</p>
<p><code>init</code>还有另外一个任务，当某个终端或虚拟控制台上的用户注销之后，<code>init</code>进程要为该终端或虚拟控制台重新启动一个<code>getty</code>，以便能够让其他用户登录。你应该发现，当用户登录时，<code>getty</code>用的是<code>exec</code>而不是<code>fork</code>系统调用来执行<code>login</code>，这样，<code>login</code>在执行的时候会覆盖<code>getty</code>的执行环境(同理，用户注册成功后，<code>login</code>的执行环境也会被<code>shell</code>占用)。所以，如果想再次使用同一终端，必须再启动一个<code>getty</code>。</p>
<p>此外，<code>init</code>进程还负责管理系统中的“孤儿”进程。如果某个进程创建子进程之后，在子进程终止之前终止，则子进程成为孤儿进程。<code>init</code>进程负责“收养”该进程，即孤儿进程会立即成为<code>init</code>进程的子进程。这是为了保持进程树的完整性。</p>
<h3 id="启动所需的Shell脚本文件"><a href="#启动所需的Shell脚本文件" class="headerlink" title="启动所需的Shell脚本文件"></a>启动所需的Shell脚本文件</h3><p>在启动的过程中，多次用到了<code>Shell</code>的脚本文件——Shell Script，如<script type="math/tex">HOME/profile`、`/etc/inittab`等等。这里有必要把它们的格式和作用稍加说明。我们把启动所需要的脚本文件分为两部分，一部分是`Linux`系统启动所必需的，也就是从`/etc/inittab`开始直到出现`Login:`提示符时要用到的所用脚本，另外一部分是用户登录后自己设定的用于支持个性化的操作环境的脚本。在后者中，我们可以设定提示符用`</script>或是其他什么任意你喜欢的字符，可以设所用的<code>Shell</code>是<code>bash</code>、<code>ksh，还是</code>zsh`。显然，这部分不是我们的重点，我们要重点描述的是前一部分——系统启动所必需的脚本。</p>
<p>系统启动所必需的脚本存放在系统默认的配置文件目录<code>/etc</code>下。用一条<code>ls</code>指令你可以看到所用的配置文件。不过，<code>/etc</code>下面还有一些子目录，比如说，<code>rc.d</code>就是启动中非常重要的一部分。我们主要介绍的是<code>/etc/inittab</code>和<code>rc.d</code>下的一些文件，我们还是按启动时<code>init</code>进程调用它们的顺序来一一介绍。</p>
<p>首先调用的是<code>/etc/inittab</code>。<code>init</code>进程将会读取它并依据其中所记载的内容进入不同的启动级别，从而启动不同的进程。所谓运行级别就是系统中定义了许多不同的级别，根据这些级别，系统在启动时给用户分配资源。比如说，以系统管理员级别登录的用户，就拥有使用几乎所有系统资源的权力，而一般用户显然不会被赋予如此大的特权。</p>
<p>下面是系统的 7 个启动级别。</p>
<ul>
<li><code>0</code> 系统停止。如果在启动时选择该级别，系统每次运行到<code>inittab</code>就会自动停止，无法启动。 </li>
<li><code>1</code> 单用户模式。该模式只允许一个用户从本地计算机上登录，该模式主要用于系统管理员检查和修复系统错误。</li>
<li><code>2</code> 多用户模式。与 3 级别的区别在于用于网络的时候，该模式不支持<code>NFS</code>(网络文件系统)。</li>
<li><code>3</code> 完全多用户模式。可以支持<code>Linux</code>的所有功能，是<code>Linux</code>安装的默认选项。</li>
<li><code>4</code> 未使用的模式。</li>
<li><code>5</code> 启动后自动进入<code>X Windwos</code>。</li>
<li><code>6</code> 重新启动模式。如果在启动时选择该级别，系统每次运行到<code>inittab</code>就会自动重新启动，无法进入系统。</li>
</ul>
<p>让我们看一个<code>inittab</code>文件的实例。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">id:3:initdefault:                  系统默认模式为 3。</span><br><span class="line">#System initialization.</span><br><span class="line">si::sysinit:/etc/rc.d/rc.sysinit   无论从哪个级别启动，都执行/etc/rc.d/rd.sysinit。</span><br><span class="line">10:0:wait:/etc/rc.d/rc.0           从 0 级别启动，将运行rc.0。</span><br><span class="line">11:1:wait:/etc/rc.d/rc.1           从 1 级别启动，将运行rc.1。</span><br><span class="line">12:2:wait:/etc/rc.d/rc.2           从 2 级别启动，将运行rc.2。</span><br><span class="line">13:3:wait:/etc/rc.d/rc.3           从 3 级别启动，将运行rc.3。</span><br><span class="line">14:4:wait:/etc/rc.d/rc.4           从 4 级别启动，将运行rc.4。</span><br><span class="line">15:5:wait:/etc/rc.d/rc.5           从 5 级别启动，将运行rc.5。</span><br><span class="line">16:6:wait:/etc/rc.d/rc.6           从 6 级别启动，将运行rc.6。</span><br><span class="line">#Things to run in every runlevel   任何级别都执行的配置文件。</span><br><span class="line">ud::once:/sbin/update</span><br><span class="line">#Run gettys in standard runlevels   对虚拟终端的初始化。</span><br><span class="line">1:12345:respqwn:/sbin/mingetty tty1 tty1 运行于 1、2、3、4、5 五个级别。</span><br><span class="line">2:2345:respqwn:/sbin/mingetty tty2  tty2 运行于 2、3、4、5 四个级别。</span><br><span class="line">3:2345:respqwn:/sbin/mingetty tty3  tty3 运行于 2、3、4、5 四个级别。</span><br><span class="line">4:2345:respqwn:/sbin/mingetty tty4  tty4 运行于 2、3、4、5 四个级别。</span><br><span class="line">5:2345:respqwn:/sbin/mingetty tty5  tty5 运行于 2、3、4、5 四个级别。</span><br><span class="line">6:2345:respqwn:/sbin/mingetty tty6  tty6 运行于 2、3、4、5 四个级别。</span><br><span class="line">#Run xdm in runlevel 5              在级别 5 启动X Window。</span><br><span class="line">x:5:respawn:/usr/bin/X11/xdm -nodaemon</span><br></pre></td></tr></table></figure></p>
<p>现在详细解释一些<code>inittab</code>的内容。<br>从上面的文件可以看出，<code>inittab</code>的每一行分成 4 个部分，这 4 个部分的格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id:runleveld:action:process</span><br></pre></td></tr></table></figure></p>
<p>它们代表的意义分别如下。</p>
<ul>
<li><code>id</code>：代表有几个字符所组成的标识符。在<code>inittab</code>中任意两行的标识符不能相同。</li>
<li><code>runlevels</code>：指出本行中第 3 部分的<code>action</code>以及第 4 部分的进程会在哪些<code>runlevel</code>中被执行，这一栏的合法值有 0、1、2……6，s以及S。</li>
<li><code>action</code>：这个部分记录<code>init</code>进程在启动过程中调用进程时，对进程所采取的应答方式，合法的应答方式有下面几项。</li>
<li><code>initdefault</code>：指出系统在启动时预设的运行级别。上例中的第 1 行就用了这个方式。<ul>
<li>所以系统将在启动时，进入<code>runlevel</code>为 3 的模式。当然，可以把 3 改为 5，那将会执行<code>/etc/rc.d/rc.5</code>，也就是X Window。</li>
</ul>
</li>
<li><code>sysinit</code>：在系统启动时，这个进程肯定会被执行。而所有的<code>inittab</code>的行中，如果它的<code>action</code>中有<code>boot</code>及<code>bootwait</code>，则该行必须等到这些<code>action</code>为<code>sysinit</code>的进程执行完之后才能够执行。</li>
<li><code>wait</code>：在启动一个进程之后，若要再启动另一个进程，则必须等到这个进程结束之后才能继续。</li>
<li><code>respawn</code>：代表这个<code>process</code>即使在结束之后，也可能会重新被启动，最典型的例子就是<code>getty</code>。</li>
</ul>
<p>明白了<code>inittab</code>的意思，让我们回过头来看看启动过程。</p>
<ul>
<li>首先，执行的是<code>/etc/rd.c/rc.sysinit</code>。这里不再给出它的程序清单，只给出它的主要功能：<ul>
<li>检查文件系统：包括启用系统交换分区，检查根文件系统的情况，使用磁盘定额程序<code>quato</code>(可选项)，安装内核映像文件系统<code>proc</code>，安装其他文件系统。</li>
<li>设置硬件设备：设定主机名，检查并设置<code>PNP</code>设备，初始化串行接口，初始化其他设备。</li>
<li>检查并载入模块</li>
</ul>
</li>
<li>执行完<code>rc.sysinit</code>并返回<code>inittab</code>后，<code>init</code>进程会根据<code>inittab</code>所设定的运行级别去执行<code>/etc/rc.d</code>目录下的相应的<code>rc</code>文件。比如说运行级别为 3，相应的<code>rc</code>文件即为<code>rc.3</code>。这些文件将运行不同的启动程序去初始化各个运行级别下的系统环境，这部分启动程序最重要的作用之一是启动系统的守护进程，如在<code>rc.3 中</code>，就要启动<code>cron</code>、<code>sendmial</code>等守护进程。</li>
<li>做完这一步，<code>init</code>进程将执行<code>getty</code>进程从而等待用户的登录，也就是说，<code>Linux</code>的启动全过程已经结束了，剩下的部分，就是整个系统等待用户需求，并为用户提供服务了。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/07/cache%E7%BC%93%E5%AD%98%E5%99%A8%E4%BB%8B%E7%BB%8D/" rel="prev" title="Cache 缓存器介绍">
      <i class="fa fa-chevron-left"></i> Cache 缓存器介绍
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B04/" rel="next" title="深入分析Linux内核源码笔记4">
      深入分析Linux内核源码笔记4 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">设备驱动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E8%BD%AF%E4%BB%B6"><span class="nav-number">1.1.1.</span> <span class="nav-text">I&#x2F;O软件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F-1"><span class="nav-number">1.1.2.</span> <span class="nav-text">设备驱动程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.</span> <span class="nav-text">设备驱动基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.2.1.</span> <span class="nav-text">I&#x2F;O端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E6%8E%A5%E5%8F%A3%E5%8F%8A%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">I&#x2F;O接口及设备控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%93%E7%94%A8I-O%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">专用I&#x2F;O接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8I-O%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">通用I&#x2F;O接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.3.</span> <span class="nav-text">设备文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E5%92%8C%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">块设备和字符设备的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E5%8D%A1"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">网卡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VFS%E5%AF%B9%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">1.2.4.</span> <span class="nav-text">VFS对设备文件的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-number">1.2.5.</span> <span class="nav-text">中断处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E5%AF%B9%E4%B8%AD%E6%96%AD%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">Linux对中断的管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E5%AF%B9%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">Linux对中断的处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8DMA%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.2.6.</span> <span class="nav-text">驱动DMA工作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ISA%E6%80%BB%E7%BA%BF%E7%9A%84DMA"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">ISA总线的DMA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PCI%E6%80%BB%E7%BA%BF%E7%9A%84DMA"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">PCI总线的DMA</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E7%A9%BA%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-number">1.2.7.</span> <span class="nav-text">I&#x2F;O空间的映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">地址映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AEI-O%E7%A9%BA%E9%97%B4"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">访问I&#x2F;O空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6"><span class="nav-number">1.2.8.</span> <span class="nav-text">设备驱动程序框架</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.3.</span> <span class="nav-text">块设备驱动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-number">1.3.1.</span> <span class="nav-text">块设备驱动程序的注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E5%9F%BA%E4%BA%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.3.2.</span> <span class="nav-text">块设备基于缓冲区的数据交换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%87%E5%8C%BA%E5%8F%8A%E5%9D%97%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">扇区及块缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">块驱动程序的体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E8%AF%B7%E6%B1%82"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">块设备请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">请求队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">块设备驱动程序描述符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.3.</span> <span class="nav-text">块设备驱动程序的几个函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ll-rw-block-%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">ll_rw_block()函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAM%E7%9B%98%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.4.</span> <span class="nav-text">RAM盘驱动程序的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RAM%E7%9B%98%E7%9A%84%E7%A1%AC%E4%BB%B6"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">RAM盘的硬件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E4%B8%ADRAM%E7%9B%98%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">Linux中RAM盘的驱动程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.5.</span> <span class="nav-text">硬盘驱动程序的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E4%B8%AD%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">Linux中硬盘驱动程序的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.4.</span> <span class="nav-text">字符设备驱动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">简单字符设备驱动程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-number">1.4.2.</span> <span class="nav-text">字符设备驱动程序的注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.4.3.</span> <span class="nav-text">一个字符设备驱动程序的实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E3%80%81%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">头文件、宏定义和全局变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#open-%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">open()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#release-%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">release()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">read()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write-%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">write()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%99%E4%B8%AA%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8F%90%E4%BE%9B%E7%BB%99%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">这个设备驱动程序提供给文件系统的接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="nav-number">1.4.3.7.</span> <span class="nav-text">模块的初始化和模块的卸载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A3%85%E8%BD%BD"><span class="nav-number">1.4.4.</span> <span class="nav-text">驱动程序的编译与装载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">2.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.</span> <span class="nav-text">网络协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">网络参考模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">2.1.2.</span> <span class="nav-text">TCP&#x2F;IP工作原理及数据流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP"><span class="nav-number">2.1.3.</span> <span class="nav-text">TCP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97-socket"><span class="nav-number">2.2.</span> <span class="nav-text">套接字(socket)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%9C%B0%E4%BD%8D%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">套接字在网络中的地位和作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">2.2.2.</span> <span class="nav-text">套接字接口的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.3.</span> <span class="nav-text">套接字的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.4.</span> <span class="nav-text">socket的通信过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">建立套接字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8INET-BSD%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8A%E7%BB%91%E5%AE%9A-bind-%E5%9C%B0%E5%9D%80"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">在INET BSD套接字上绑定(bind)地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E5%90%AC-listen-INET-BSD%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">监听(listen)INET BSD套接字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82-accept"><span class="nav-number">2.2.4.4.</span> <span class="nav-text">接受连接请求(accept)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket%E4%B8%BA%E7%94%A8%E6%88%B7%E6%8F%90%E4%BE%9B%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.2.5.</span> <span class="nav-text">socket为用户提供的系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%93%E5%86%B2%E5%8C%BA-sk-buff"><span class="nav-number">2.3.</span> <span class="nav-text">套接字缓冲区(sk_buff)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">2.3.1.</span> <span class="nav-text">套接字缓冲区的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%93%E5%86%B2%E5%8C%BA%E6%93%8D%E4%BD%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">2.3.2.</span> <span class="nav-text">套接字缓冲区操作基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sk-buff%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9"><span class="nav-number">2.3.3.</span> <span class="nav-text">sk_buff数据结构的核心内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%93%E5%86%B2%E5%8C%BA%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.4.</span> <span class="nav-text">套接字缓冲区提供的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E7%BA%B5sk-buff%E9%93%BE%E8%A1%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">操纵sk_buff链表的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%88%96%E5%8F%96%E6%B6%88%E4%B8%80%E4%B8%AA%E7%BC%93%E5%86%B2%E5%8C%BA%E7%BB%93%E6%9E%84%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">创建或取消一个缓冲区结构的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9sk-buff%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">对sk_buff结构数据区进行操作的操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%B8%8A%E5%B1%82%E6%94%AF%E6%8C%81%E4%BE%8B%E7%A8%8B"><span class="nav-number">2.3.5.</span> <span class="nav-text">套接字缓冲区的上层支持例程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.4.</span> <span class="nav-text">网络设备接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.1.</span> <span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">2.4.2.</span> <span class="nav-text">命名规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C"><span class="nav-number">2.4.3.</span> <span class="nav-text">设备注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.4.</span> <span class="nav-text">网络设备数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8D%E7%A7%B0"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">总线接口参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%B1%82%E5%8F%82%E6%95%B0"><span class="nav-number">2.4.4.3.</span> <span class="nav-text">协议层参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.5.</span> <span class="nav-text">支持函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE-init"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">初始化设置(init)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80-open"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">打开(open)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%97%AD-stop"><span class="nav-number">2.4.5.3.</span> <span class="nav-text">关闭(stop)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%B8%A7%E4%BC%A0%E8%BE%93%E4%BE%8B%E7%A8%8B"><span class="nav-number">2.4.5.4.</span> <span class="nav-text">数据帧传输例程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%B8%A7%E5%A4%B4"><span class="nav-number">2.4.5.5.</span> <span class="nav-text">硬件帧头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6"><span class="nav-number">2.4.5.6.</span> <span class="nav-text">数据接收</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">3.</span> <span class="nav-text">Linux系统的启动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">初始化流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%8A%A0%E7%94%B5%E6%88%96%E5%A4%8D%E4%BD%8D"><span class="nav-number">3.1.1.</span> <span class="nav-text">系统加电或复位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIOS-%E5%90%AF%E5%8A%A8"><span class="nav-number">3.1.2.</span> <span class="nav-text">BIOS&#96;启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Boot-Loader"><span class="nav-number">3.1.3.</span> <span class="nav-text">Boot Loader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.1.4.</span> <span class="nav-text">操作系统的初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E7%9A%84Boot-Loader"><span class="nav-number">3.2.</span> <span class="nav-text">Linux的Boot Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Boot-Loader-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">Boot Loader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LILO"><span class="nav-number">3.2.2.</span> <span class="nav-text">LILO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LILO%E7%9A%84%E8%BF%90%E8%A1%8C%E5%88%86%E6%9E%90"><span class="nav-number">3.2.3.</span> <span class="nav-text">LILO的运行分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E8%BD%AF%E7%9B%98%E5%90%AF%E5%8A%A8"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">从软盘启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E7%A1%AC%E7%9B%98%E5%90%AF%E5%8A%A8"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">从硬盘启动</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.3.</span> <span class="nav-text">进入操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Setup-S"><span class="nav-number">3.3.1.</span> <span class="nav-text">Setup.S</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main-c%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.4.</span> <span class="nav-text">main.c中的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8Binit%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.5.</span> <span class="nav-text">建立init进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#init%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">3.5.1.</span> <span class="nav-text">init进程的建立</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%89%80%E9%9C%80%E7%9A%84Shell%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="nav-number">3.5.2.</span> <span class="nav-text">启动所需的Shell脚本文件</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuhao0102" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuhao0102" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuhhpc0203@gmail.com" title="E-Mail → mailto:yuhhpc0203@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
