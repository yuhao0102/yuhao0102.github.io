<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zn-ch">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux," />










<meta name="description" content="系统调用一般情况下进程不能访问内核所占内存空间也不能调用内核函数。为了和用户空间上运行的进程进行交互，内核提供了一组接口。透过该接口，应用程序可以访问硬件设备和其他操作系统资源。这组接口在应用程序和内核之间扮演了使者的角色，应用程序发送各种请求，而内核负责满足这些请求(或者让应用程序暂时搁置)。系统调用就是用户空间应用程序和内核提供的服务之间的一个接口。 系统调用在用户空间进程和硬件设备之间添加了">
<meta property="og:type" content="article">
<meta property="og:title" content="把握Linux内核设计思想">
<meta property="og:url" content="http://yoursite.com/2019/05/14/%E6%8A%8A%E6%8F%A1linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="系统调用一般情况下进程不能访问内核所占内存空间也不能调用内核函数。为了和用户空间上运行的进程进行交互，内核提供了一组接口。透过该接口，应用程序可以访问硬件设备和其他操作系统资源。这组接口在应用程序和内核之间扮演了使者的角色，应用程序发送各种请求，而内核负责满足这些请求(或者让应用程序暂时搁置)。系统调用就是用户空间应用程序和内核提供的服务之间的一个接口。 系统调用在用户空间进程和硬件设备之间添加了">
<meta property="og:locale" content="zn_CH">
<meta property="article:published_time" content="2019-05-14T02:46:53.000Z">
<meta property="article:modified_time" content="2022-01-02T03:06:13.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/14/把握linux内核设计思想/"/>





  <title>把握Linux内核设计思想 | Hao Yu's blog</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/14/%E6%8A%8A%E6%8F%A1linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">把握Linux内核设计思想</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-14T10:46:53+08:00">
                2019-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>一般情况下进程不能访问内核所占内存空间也不能调用内核函数。为了和用户空间上运行的进程进行交互，内核提供了一组接口。透过该接口，应用程序可以访问硬件设备和其他操作系统资源。这组接口在应用程序和内核之间扮演了使者的角色，应用程序发送各种请求，而内核负责满足这些请求(或者让应用程序暂时搁置)。系统调用就是用户空间应用程序和内核提供的服务之间的一个接口。</p>
<p>系统调用在用户空间进程和硬件设备之间添加了一个中间层，其为用户空间提供了一种统一的硬件的抽象接口，保证了系统的稳定和安全，使用户程序具有可移植性。例如<code>fork()</code>，<code>read()</code>，<code>write()</code>等用户程序可以使用的函数都是系统调用。</p>
<p>用户空间的程序无法直接执行内核代码。它们不能直接调用内核空间中的函数，因为内核驻留在受保护的地址空间上。所以，应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，希望系统切换到内核态，这样内核就可以代表应用程序来执行该系统调用了。那么应用程序应该以何种方式通知系统，系统如何切换到内核态？</p>
<p>其实这种改变是通过软中断来实现。首先，用户程序为系统调用设置参数。其中一个参数是系统调用编号。参数设置完成后，程序执行“系统调用”指令。x86系统上的软中断由<code>int</code>产生。这个指令会导致一个异常：产生一个事件，这个事件会致使处理器切换到内核态并执行0x80号异常处理程序。此时的异常处理程序实际上就是系统调用处理程序，该处理程序的名字为<code>system_call</code>，它与硬件体系结构紧密相关。对于x86-32<code>系统来说，该处理程序位于</code>arch/x86/kernel/entry_32.S`文件中，代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"> <span class="meta"># system call handler stub</span></span><br><span class="line">ENTRY(system_call)</span><br><span class="line"> RING0_INT_FRAME <span class="meta"># can<span class="string">&#x27;t unwind into user space anyway</span></span></span><br><span class="line"><span class="string"><span class="meta"> pushl %eax # save orig_eax</span></span></span><br><span class="line"><span class="string"><span class="meta"> CFI_ADJUST_CFA_OFFSET 4</span></span></span><br><span class="line"><span class="string"><span class="meta"> SAVE_ALL</span></span></span><br><span class="line"><span class="string"><span class="meta"> GET_THREAD_INFO(%ebp)</span></span></span><br><span class="line"><span class="string"><span class="meta">     # system call tracing in operation / emulation</span></span></span><br><span class="line"><span class="string"><span class="meta"> testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp)</span></span></span><br><span class="line"><span class="string"><span class="meta"> jnz syscall_trace_entry</span></span></span><br><span class="line"><span class="string"><span class="meta"> cmpl $(nr_syscalls), %eax</span></span></span><br><span class="line"><span class="string"><span class="meta"> jae syscall_badsys</span></span></span><br><span class="line"><span class="string"><span class="meta">syscall_call:</span></span></span><br><span class="line"><span class="string"><span class="meta"> call *sys_call_table(,%eax,4) //此处执行相应的系统调用</span></span></span><br><span class="line"><span class="string"><span class="meta"> movl %eax,PT_EAX(%esp) # store the return value</span></span></span><br><span class="line"><span class="string"><span class="meta">syscall_exit:</span></span></span><br><span class="line"><span class="string"><span class="meta"> LOCKDEP_SYS_EXIT</span></span></span><br><span class="line"><span class="string"><span class="meta"> DISABLE_INTERRUPTS(CLBR_ANY) # make sure we don&#x27;</span>t miss an interrupt</span></span><br><span class="line">     <span class="meta"># setting need_resched or sigpending</span></span><br><span class="line">     <span class="meta"># between sampling and the iret</span></span><br><span class="line"> TRACE_IRQS_OFF</span><br><span class="line"> movl <span class="title function_">TI_flags</span><span class="params">(%ebp)</span>, %ecx</span><br><span class="line"> testl $_TIF_ALLWORK_MASK, %ecx <span class="meta"># current-&gt;work</span></span><br><span class="line"> jne syscall_exit_work</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure><br>在Linux中，每个系统调用被赋予一个系统调用号。这样，通过这个独一无二的号就可以关联系统调用。当用户空间的进程执行一个系统调用的时候，这个系统调用号就被用来指明到底是要执行哪个系统调用。进程不会提及系统调用的名称。系统调用号定义文件以及形式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat ./arch/x86/include/<span class="keyword">asm</span>/unistd.h</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __KERNEL__                                                                                                                      </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&quot;unistd_32.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&quot;unistd_64.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __i386__</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&quot;unistd_32.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&quot;unistd_64.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat arch/x86/include/asm/unistd_32.h</span></span><br><span class="line"><span class="comment">#ifndef _ASM_X86_UNISTD_32_H</span></span><br><span class="line"><span class="comment">#define _ASM_X86_UNISTD_32_H</span></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * This file contains the system call numbers.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">#define __NR_restart_syscall      0</span></span><br><span class="line"><span class="comment">#define __NR_exit                 1</span></span><br><span class="line"><span class="comment">#define __NR_fork                 2</span></span><br><span class="line"><span class="comment">#define __NR_read                 3</span></span><br><span class="line"><span class="comment">#define __NR_write                4</span></span><br><span class="line"><span class="comment">#define __NR_open                 5</span></span><br><span class="line"><span class="comment">#define __NR_close                6</span></span><br><span class="line"><span class="comment">#define __NR_waitpid              7</span></span><br><span class="line"><span class="comment">#define __NR_creat                8</span></span><br><span class="line"><span class="comment">#define __NR_link                 9</span></span><br><span class="line"><span class="comment">#define __NR_unlink              10</span></span><br><span class="line"><span class="comment">#define __NR_execve              11</span></span><br><span class="line"><span class="comment">#define __NR_chdir               12</span></span><br><span class="line"><span class="comment">#define __NR_time                13</span></span><br><span class="line"><span class="comment">#define __NR_mknod               14</span></span><br><span class="line"><span class="comment">#define __NR_chmod               15</span></span><br><span class="line"><span class="comment">#define __NR_lchown              16</span></span><br><span class="line"><span class="comment">#define __NR_break               17</span></span><br><span class="line"><span class="comment">#define __NR_oldstat             18</span></span><br><span class="line"><span class="comment">#define __NR_lseek               19</span></span><br><span class="line"><span class="comment">#define __NR_getpid              20</span></span><br><span class="line"><span class="comment">#define __NR_mount               21</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>系统调用号相当关键，一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃。Linux有一个“未实现”系统调用<code>sys_ni_syscall()</code>，它除了返回一<code>ENOSYS</code>外不做任何其他工作，这个错误号就是专门针对无效的系统调用而设的。</p>
<p>因为所有的系统调用陷入内核的方式都一样，所以仅仅是陷入内核空间是不够的。因此必须把系统调用号一并传给内核。在x86上，系统调用号是通过<code>eax</code>寄存器传递给内核的。在陷人内核之前，用户空间就把相应系统调用所对应的号放入<code>eax</code>中了。这样系统调用处理程序一旦运行，就可以从<code>eax</code>中得到数据。其他体系结构上的实现也都类似。</p>
<p>内核记录了系统调用表中的所有已注册过的系统调用的列表，存储在<code>sys_call_table</code>中。它与体系结构有关，32位x86一般定义在<code>arch/x86/kernel/syscall_table_32.s</code>文件中。这个表中为每一个有效的系统调用指定了惟一的系统调用号。<code>sys_call_table</code>是一张由指向实现各种系统调用的内核函数的函数指针组成的表。<code>syscall_table_32.s</code>文件如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(sys_call_table)</span><br><span class="line"> .<span class="type">long</span> sys_restart_syscall <span class="comment">/* 0 - old &quot;setup()&quot; system call, used for restarting */</span></span><br><span class="line"> .<span class="type">long</span> sys_exit</span><br><span class="line"> .<span class="type">long</span> ptregs_fork</span><br><span class="line"> .<span class="type">long</span> sys_read</span><br><span class="line"> .<span class="type">long</span> sys_write</span><br><span class="line"> .<span class="type">long</span> sys_open <span class="comment">/* 5 */</span></span><br><span class="line"> .<span class="type">long</span> sys_close</span><br><span class="line"> .<span class="type">long</span> sys_waitpid</span><br><span class="line"> .<span class="type">long</span> sys_creat</span><br><span class="line"> .<span class="type">long</span> sys_link</span><br><span class="line"> .<span class="type">long</span> sys_unlink <span class="comment">/* 10 */</span></span><br><span class="line"> .<span class="type">long</span> ptregs_execve</span><br><span class="line"> ......</span><br><span class="line"> .<span class="type">long</span> sys_timerfd_settime <span class="comment">/* 325 */</span></span><br><span class="line"> .<span class="type">long</span> sys_timerfd_gettime</span><br><span class="line"> .<span class="type">long</span> sys_signalfd4</span><br><span class="line"> .<span class="type">long</span> sys_eventfd2</span><br><span class="line"> .<span class="type">long</span> sys_epoll_create1</span><br><span class="line"> .<span class="type">long</span> sys_dup3 <span class="comment">/* 330 */</span></span><br><span class="line"> .<span class="type">long</span> sys_pipe2</span><br><span class="line"> .<span class="type">long</span> sys_inotify_init1</span><br><span class="line"> .<span class="type">long</span> sys_preadv</span><br><span class="line"> .<span class="type">long</span> sys_pwritev</span><br><span class="line"> .<span class="type">long</span> sys_rt_tgsigqueueinfo <span class="comment">/* 335 */</span></span><br><span class="line"> .<span class="type">long</span> sys_perf_event_open</span><br></pre></td></tr></table></figure></p>
<p><code>system_call()</code>函数通过将给定的系统调用号与<code>NR_syscalls</code>做比较来检查其有效性。如果它大于或者等于<code>NR syscalls</code>，该函数就返回一<code>ENOSYS</code>。否则，就执行相应的系统调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call *<span class="title function_">sys_call_table</span><span class="params">(，%eax, <span class="number">4</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>由于系统调用表中的表项是以32位(4字节)类型存放的，所以内核需要将给定的系统调用号乘以4，然后用所得的结果在该表中查询其位置。</p>
<p>除了系统调用号以外，大部分系统调用都还需要一些外部的参数输入。所以，在发生异常的时候，应该把这些参数从用户空间传给内核。最简单的办法就是像传递系统调用号一样把这些参数也存放在寄存器里。在x86系统上，<code>ebx</code>，<code>ecx</code>，<code>edx</code>，<code>esi</code>和<code>edi</code>按照顺序存放前五个参数。需要六个或六个以上参数的情况不多见，此时，应该用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针。给用户空间的返回值也通过寄存器传递。在x86系统上，它存放在<code>eax</code>寄存器中。</p>
<p>下面我们看看用中断的方式如何完成系统调用功能：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span>   pid;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">            <span class="string">&quot;mov $0, %%ebx\n\t&quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;mov $20, %%eax\n\t&quot;</span>    <span class="comment">//把系统调用号20放入`eax`寄存器中，20对应于`SYS_getpid()系统调用</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;int $0x80\n\t&quot;</span>    <span class="comment">//0x80中断</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;mov %%eax, %0\n\t&quot;</span>    <span class="comment">//将执行结果存放在`pid`变量中</span></span></span><br><span class="line"><span class="params">            :<span class="string">&quot;=m&quot;</span>(pid)</span></span><br><span class="line"><span class="params">            )</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int PID: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;api PID: %d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此处没有传递参数，因为<code>getpid</code>不需要参数。本实例执行结果为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./target_bin</span><br><span class="line">int PID: 4911</span><br><span class="line">api PID: 4911</span><br></pre></td></tr></table></figure></p>
<p>一般情况下，应用程序通过在用户空间实现的应用编程接口（API）而不是系统调用来编程。API是一个函数定义，说明了如何获得一个给定的服务，比如<code>read()</code>、<code>malloc()</code>、<code>free()</code>、<code>abs()</code>等。它有可能和系统调用形式上一致，比如<code>read()</code>接口就和<code>read</code>系统调用对应，但这种对应并非一一对应，往往会出现几种不同的API内部用到统一个系统调用，比如<code>malloc()</code>、<code>free()</code>内部利用<code>brk()</code>系统调用来扩大或缩小进程的堆；或一个API利用了好几个系统调用组合完成服务。更有些API甚至不需要任何系统调用——因为它不必需要内核服务，如计算整数绝对值的<code>abs()</code>接口。</p>
<p>Linux的用户编程接口遵循了在Unix世界中最流行的应用编程界面标准——POSIX标准，这套标准定义了一系列API。在Linux中（Unix也如此）这些API主要是通过C库（libc）实现的，它除了定义的一些标准的C函数外，一个很重要的任务就是提供了一套封装例程将系统调用在用户空间包装后供用户编程使用。不过封装并非必须的，如果你愿意直接调用，内核也提供了一个<code>syscall()</code>函数来实现调用。如下示例为使用C库调用和直接调用分别来获取当前进程ID：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span>     pid, pidt;</span><br><span class="line">    pid = getpid();</span><br><span class="line">    pidt = syscall(SYS_getpid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getpid: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SYS_getpid: %d\n&quot;</span>, pidt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>系统调用在内核有一个实现函数，以<code>getpid</code>为例，其在内核实现为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_getpid - return the thread group id of the current process</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note, despite the name, this returns the tgid not the pid.  The tgid and</span></span><br><span class="line"><span class="comment"> * the pid are identical unless CLONE_THREAD was specified on clone() in</span></span><br><span class="line"><span class="comment"> * which case the tgid is the same in all threads of the same group.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is SMP safe as current-&gt;tgid does not change.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE0(getpid)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> task_tgid_vnr(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中<code>SYSCALL_DEFINE0</code>为一个宏，它定义一个无参数（尾部数字代表参数个数）的系统调用，展开后代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;tpid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中<code>asmlinkage</code>是一个编译指令，通知编译器仅从栈中提取该函数参数，所有系统调用都需要这个限定词。系统调用<code>getpid()</code>在内核中被定义成<code>sys_getpid()</code>，这是Linux所有系统调用都应该遵守的命名规则。</p>
<p>Linux中实现系统调用利用了0x86体系结构中的软件中断，也就是调用<code>int $0x80</code>汇编指令，这条汇编指令将产生向量为128的编程异常，此时处理器切换到内核态并执行0x80号异常处理程序。此时的异常处理程序实际上就是系统调用处理程序，该处理程序的名字为<code>system_call()</code>，对于x86-32系统来说，该处理程序位于<code>arch/x86/kernel/entry_32.S</code>文件中，使用汇编语言编写。那么所有的系统调用都会转到这里。在执行<code>int 0x80</code>前，系统调用号被装入<code>eax</code>寄存器（相应参数也会传递到其它寄存器中），这个系统调用号被用来指明到底是要执行哪个系统调用，这样系统调用处理程序一旦运行，就从<code>eax</code>中得到系统调用号，然后根据系统调用号在系统调用表中寻找相应服务例程（例如<code>sys_getpid()</code>函数）。当服务例程结束时，<code>system_call()</code>从<code>eax</code>获得系统调用的返回值，并把这个返回值存放在曾保存用户态<code>eax</code>寄存器栈单元的那个位置上，最后该函数再负责切换到用户空间，使用户进程继续执行。</p>
<h1 id="硬中断及中断处理"><a href="#硬中断及中断处理" class="headerlink" title="硬中断及中断处理"></a>硬中断及中断处理</h1><p>操作系统负责管理硬件设备，为了使系统和硬件设备的协同工作不降低机器性能，系统和硬件的通信使用中断的机制，也就是让硬件在需要的时候向内核发出信号，这样使得内核不用去轮询设备而导致做很多无用功。</p>
<p>中断使得硬件可以发出通知给处理器，硬件设备生成中断的时候并不考虑与处理器的时钟同步，中断可以随时产生。也就是说，内核随时可能因为新到来的中断而被打断。当接收到一个中断后，中断控制器会给处理器发送一个电信号，处理器检测到该信号便中断自己当前工作而处理中断。</p>
<p>在响应一个中断时，内核会执行一个函数，该函数叫做中断处理程序或中断服务例程（ISR）。中断处理程序运行与中断上下文，中断上下文中执行的代码不可阻塞，应该快速执行，这样才能保证尽快恢复被中断的代码的执行。中断处理程序是管理硬件驱动的驱动程序的组成部分，如果设备使用中断，那么相应的驱动程序就注册一个中断处理程序。</p>
<p>在驱动程序中，通常使用<code>request_irq()</code>来注册中断处理程序。该函数在文件<code>&lt;include/linux/interrupt.h&gt;</code>中声明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></table></figure><br>第一个参数为要分配的中断号；第二个参数为指向中断处理程序的指针；第三个参数为中断处理标志。该函数实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">                         <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">                         <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * handle_IRQ_event() always ignores IRQF_DISABLED except for</span></span><br><span class="line"><span class="comment">     * the _first_ irqaction (sigh).  That can cause oopsing, but</span></span><br><span class="line"><span class="comment">     * the behavior is classified as &quot;will not fix&quot; so we need to</span></span><br><span class="line"><span class="comment">     * start nudging drivers away from using that idiom.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((irqflags &amp; (IRQF_SHARED|IRQF_DISABLED)) == (IRQF_SHARED|IRQF_DISABLED)) &#123;</span><br><span class="line">        pr_warning(<span class="string">&quot;IRQ %d/%s: IRQF_DISABLED is not guaranteed on shared IRQs\n&quot;</span>,</span><br><span class="line">                irq, devname);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Lockdep wants atomic interrupt handlers:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    irqflags |= IRQF_DISABLED;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Sanity-check: shared interrupts must pass in a real dev-ID,</span></span><br><span class="line"><span class="comment">     * otherwise we&#x27;ll have trouble later trying to figure out</span></span><br><span class="line"><span class="comment">     * which interrupt is which (messes up the interrupt freeing</span></span><br><span class="line"><span class="comment">     * logic etc).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    desc = irq_to_desc(irq);</span><br><span class="line">    <span class="keyword">if</span> (!desc)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (desc-&gt;status &amp; IRQ_NOREQUEST)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!thread_fn)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        handler = irq_default_primary_handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分配一个irqaction</span></span><br><span class="line">    action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!action)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    action-&gt;handler = handler;</span><br><span class="line">    action-&gt;thread_fn = thread_fn;</span><br><span class="line">    action-&gt;flags = irqflags;</span><br><span class="line">    action-&gt;name = devname;</span><br><span class="line">    action-&gt;dev_id = dev_id;</span><br><span class="line">    chip_bus_lock(irq, desc);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将创建并初始化完在的action加入desc</span></span><br><span class="line">    retval = __setup_irq(irq, desc, action);</span><br><span class="line">    chip_bus_sync_unlock(irq, desc);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        kfree(action);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ</span></span><br><span class="line">    <span class="keyword">if</span> (irqflags &amp; IRQF_SHARED) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * It&#x27;s a shared IRQ -- the driver ought to be prepared for it</span></span><br><span class="line"><span class="comment">         * to happen immediately, so let&#x27;s make sure....</span></span><br><span class="line"><span class="comment">         * We disable the irq to make sure that a &#x27;real&#x27; IRQ doesn&#x27;t</span></span><br><span class="line"><span class="comment">         * run in parallel with our fake.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">        disable_irq(irq);</span><br><span class="line">        local_irq_save(flags);</span><br><span class="line">        handler(irq, dev_id);</span><br><span class="line">        local_irq_restore(flags);</span><br><span class="line">        enable_irq(irq);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面看一下中断处理程序的实例，以<code>rtc</code>驱动程序为例，代码位于<code>&lt;drivers/char/rtc.c&gt;</code>中。当<code>RTC</code>驱动装载时，<code>rtc_init()</code>函数会被调用来初始化驱动程序，包括注册中断处理函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * XXX Interrupt pin #7 in Espresso is shared between RTC and</span></span><br><span class="line"><span class="comment"> * PCI Slot 2 INTA# (and some INTx# in Slot 1).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (request_irq(rtc_irq, rtc_interrupt, IRQF_SHARED, <span class="string">&quot;rtc&quot;</span>,</span><br><span class="line">        (<span class="type">void</span> *)&amp;rtc_port)) &#123;</span><br><span class="line">    rtc_has_irq = <span class="number">0</span>;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;rtc: cannot register IRQ %d\n&quot;</span>, rtc_irq);</span><br><span class="line">    <span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>处理程序函数<code>rtc_interrupt()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  A very tiny interrupt handler. It runs with IRQF_DISABLED set,</span></span><br><span class="line"><span class="comment"> *  but there is possibility of conflicting with the set_rtc_mmss()</span></span><br><span class="line"><span class="comment"> *  call (the rtc irq and the timer irq can easily run at the same</span></span><br><span class="line"><span class="comment"> *  time in two different CPUs). So we need to serialize</span></span><br><span class="line"><span class="comment"> *  accesses to the chip with the rtc_lock spinlock that each</span></span><br><span class="line"><span class="comment"> *  architecture should implement in the timer code.</span></span><br><span class="line"><span class="comment"> *  (See ./arch/XXXX/kernel/time.c for the set_rtc_mmss() function.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">rtc_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Can be an alarm interrupt, update complete interrupt,</span></span><br><span class="line"><span class="comment">     *  or a periodic interrupt. We store the status in the</span></span><br><span class="line"><span class="comment">     *  low byte and the number of interrupts received since</span></span><br><span class="line"><span class="comment">     *  the last read in the remainder of rtc_irq_data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    spin_lock(&amp;rtc_lock);    <span class="comment">//保证`rtc_irq_data`不被`SMP`机器上其他处理器同时访问</span></span><br><span class="line">    rtc_irq_data += <span class="number">0x100</span>;</span><br><span class="line">    rtc_irq_data &amp;= ~<span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_hpet_enabled()) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * In this case it is HPET RTC interrupt handler</span></span><br><span class="line"><span class="comment">         * calling us, with the interrupt information</span></span><br><span class="line"><span class="comment">         * passed as arg1, instead of irq.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rtc_irq_data |= (<span class="type">unsigned</span> <span class="type">long</span>)irq &amp; <span class="number">0xF0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rtc_irq_data |= (CMOS_READ(RTC_INTR_FLAGS) &amp; <span class="number">0xF0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rtc_status &amp; RTC_TIMER_ON)</span><br><span class="line">        mod_timer(&amp;rtc_irq_timer, jiffies + HZ/rtc_freq + <span class="number">2</span>*HZ/<span class="number">100</span>);</span><br><span class="line">    spin_unlock(&amp;rtc_lock);</span><br><span class="line">    <span class="comment">/* Now do the rest of the actions */</span></span><br><span class="line">    spin_lock(&amp;rtc_task_lock);    <span class="comment">//避免`rtc_callback`出现系统情况，RTC`驱动允许注册一个回调函数在每个`RTC`中断到来时执行。</span></span><br><span class="line">    <span class="keyword">if</span> (rtc_callback)</span><br><span class="line">        rtc_callback-&gt;func(rtc_callback-&gt;private_data);</span><br><span class="line">    spin_unlock(&amp;rtc_task_lock);</span><br><span class="line">    wake_up_interruptible(&amp;rtc_wait);</span><br><span class="line">    kill_fasync(&amp;rtc_async_queue, SIGIO, POLL_IN);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在内核中，中断的旅程开始于预定义入口点，这类似于系统调用。对于每条中断线，处理器都会跳到对应的一个唯一的位置。这样，内核就可以知道所接收中断的<code>IRQ</code>号了。初始入口点只是在栈中保存这个号，并存放当前寄存器的值(这些值属于被中断的任务)；然后，内核调用函数<code>do_IRQ()</code>。从这里开始，大多数中断处理代码是用C写的。<code>do_IRQ()</code>的声明如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">do_IRQ</span><span class="params">(<span class="keyword">struct</span> pt_regs regs)</span></span><br></pre></td></tr></table></figure><br>因为C的调用惯例是要把函数参数放在栈的顶部，因此<code>pt_regs</code>结构包含原始寄存器的值，这些值是以前在汇编入口例程中保存在栈上的。中断的值也会得以保存，所以，<code>do_IRQ()</code>可以将它提取出来，X86的代码为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int irq = regs.orig_eax &amp; 0xff</span><br></pre></td></tr></table></figure></p>
<p>计算出中断号后，<code>do_IRQ()</code>对所接收的中断进行应答，禁止这条线上的中断传递。在普通的PC机器上，这些操作是由<code>mask_and_ack_8259A()</code>来完成的，该函数由<code>do_IRQ()</code>调用。接下来，<code>do_IRQ()</code>需要确保在这条中断线上有一个有效的处理程序，而且这个程序已经启动但是当前没有执行。如果这样的话，<code>do_IRQ()</code>就调用<code>handle_IRQ_event()</code>来运行为这条中断线所安装的中断处理程序，函数位于<code>&lt;kernel/irq/handle.c&gt;</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * handle_IRQ_event - irq action chain handler</span></span><br><span class="line"><span class="comment"> * @irq:    the interrupt number</span></span><br><span class="line"><span class="comment"> * @action: the interrupt action chain for this irq</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> * Handles the action chain of an irq event</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">handle_IRQ_event</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irqreturn_t</span> ret, retval = IRQ_NONE;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果没有设置`IRQF_DISABLED，将CPU中断打开，应该尽量避免中断关闭情况，本地中断关闭情况下会导致中断丢失。</span></span><br><span class="line">    <span class="keyword">if</span> (!(action-&gt;flags &amp; IRQF_DISABLED))</span><br><span class="line">        local_irq_enable_in_hardirq();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span> &#123;    <span class="comment">//遍历运行中断处理程序</span></span><br><span class="line">        trace_irq_handler_entry(irq, action);</span><br><span class="line">        ret = action-&gt;handler(irq, action-&gt;dev_id);</span><br><span class="line">        trace_irq_handler_exit(irq, action, ret);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">        <span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Set result to handled so the spurious check</span></span><br><span class="line"><span class="comment">             * does not trigger.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ret = IRQ_HANDLED;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Catch drivers which return WAKE_THREAD but</span></span><br><span class="line"><span class="comment">             * did not set up a thread function</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(!action-&gt;thread_fn)) &#123;</span><br><span class="line">                warn_no_thread(irq, action);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Wake up the handler thread for this</span></span><br><span class="line"><span class="comment">             * action. In case the thread crashed and was</span></span><br><span class="line"><span class="comment">             * killed we just pretend that we handled the</span></span><br><span class="line"><span class="comment">             * interrupt. The hardirq handler above has</span></span><br><span class="line"><span class="comment">             * disabled the device interrupt, so no irq</span></span><br><span class="line"><span class="comment">             * storm is lurking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (likely(!test_bit(IRQTF_DIED,</span><br><span class="line">                         &amp;action-&gt;thread_flags))) &#123;</span><br><span class="line">                set_bit(IRQTF_RUNTHREAD, &amp;action-&gt;thread_flags);</span><br><span class="line">                wake_up_process(action-&gt;thread);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Fall through to add to randomness */</span></span><br><span class="line">        <span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">            status |= action-&gt;flags;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        retval |= ret;</span><br><span class="line">        action = action-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (action);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (status &amp; IRQF_SAMPLE_RANDOM)</span><br><span class="line">        add_interrupt_randomness(irq);</span><br><span class="line">    local_irq_disable();<span class="comment">//关中断</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>前面说到中断应该尽快执行完，以保证被中断代码可以尽快的恢复执行。但事实上中断通常有很多工作要做，包括应答、重设硬件、数据拷贝、处理请求、发送请求等。为了求得平衡，内核把中断处理工作分成两半，中断处理程序是上半部——接收到中断就开始执行。能够稍后完成的工作推迟到下半部操作，下半部在合适的时机被开中段执行。例如网卡收到数据包时立即发出中断，内核执行网卡已注册的中断处理程序，此处工作就是通知硬件拷贝最新的网络数据包到内存，然后将控制权交换给系统之前被中断的任务，其他的如处理和操作数据包等任务被放到随后的下半部中去执行。下一节我们将了解中断处理的下半部。</p>
<h1 id="下半部机制之软中断"><a href="#下半部机制之软中断" class="headerlink" title="下半部机制之软中断"></a>下半部机制之软中断</h1><p>中断处理程序以异步方式执行，其会打断其他重要代码，其运行时该中断同级的其他中断会被屏蔽，并且当前处理器上所有其他中断都有可能会被屏蔽掉，还有中断处理程序不能阻塞，所以中断处理需要尽快结束。由于中断处理程序的这些缺陷，导致了中断处理程序只是整个硬件中断处理流程的一部分，对于那些对时间要求不高的任务，留给中断处理流程的另外一部分，也就是本节要讲的中断处理流程的下半部。</p>
<p>那哪些工作由中断处理程序完成，哪些工作留给下半部来执行呢？其实上半部和下半部的工作划分不存在某种严格限制，这主要取决于驱动程序开发者自己的判断，一般最好能将中断处理程序执行时间缩短到最小。中断处理程序几乎都需要通过操作硬件对中断的到达进行确认，有时还会做对时间非常敏感的工作（如拷贝数据），其余的工作基本上留给下半部来处理，下半部就是执行与中断处理密切相关但中断处理程序本身不执行的工作。一般对时间非常敏感、和硬件相关、要保证不被其它中断(特别是相同的中断)打断的这些任务放在中断处理程序中执行，其他任务考虑放在下半部执行。</p>
<p>那下半部什么时候执行呢？下半部不需要指定明确执行时间，只要把任务推迟一点，让它们在系统不太忙且中断恢复后执行就可以了，而且执行期间可以相应所有中断。</p>
<p>上半部只能通过中断处理程序实现，而下半部可以有多种机制来实现，在2.6.32版本中，有三种不同形式的下半部实现机制：软中断、tasklet、工作队列。下面来看一下这三种下半部的实现。</p>
<p>软中断<br>在<code>start_kernerl()</code>函数中，系统初始化软中断。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * command_line;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">kernel_param</span> __<span class="title">start___param</span>[], __<span class="title">stop___param</span>[];</span></span><br><span class="line"> </span><br><span class="line">    smp_setup_processor_id();</span><br><span class="line">......</span><br><span class="line">    softirq_init();<span class="comment">//初始化软中断</span></span><br><span class="line">......</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">    rest_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在<code>softirq_init()</code>中会注册两个常用类型的软中断，具体代码如下（位于<code>kernel/softirq.c</code>）:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">softirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line"> </span><br><span class="line">    for_each_possible_cpu(cpu) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">        per_cpu(tasklet_vec, cpu).tail =</span><br><span class="line">            &amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line">        per_cpu(tasklet_hi_vec, cpu).tail =</span><br><span class="line">            &amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_SOFTIRQS; i++)</span><br><span class="line">            INIT_LIST_HEAD(&amp;per_cpu(softirq_work_list[i], cpu));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    register_hotcpu_notifier(&amp;remote_softirq_cpu_notifier);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//此处注册两个软中断</span></span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, tasklet_action);     </span><br><span class="line">    open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注册函数<code>open_softirq()</code>参数含义:</p>
<ul>
<li><code>nr</code>：软中断类型</li>
<li><code>action</code>：软中断处理函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span></span><br><span class="line">&#123;</span><br><span class="line">    softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>softirq_action</code>结构表示软中断，定义在<code>&lt;include/linux/interrupt.h&gt;</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span>    (*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文件<code>&lt;kernel/softirq.c&gt;</code>中定义了32个该结构体的数组：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>] __<span class="title">cacheline_aligned_in_smp</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>每注册一个软中断都会占该数组一个位置，因此系统中最多有32个软中断。从上面的代码中，我们可以看到<code>open_softirq()</code>中。其实就是对<code>softirq_vec</code>数组的<code>nr</code>项赋值。<code>softirq_vec</code>是一个32元素的数组，实际上Linux内核只使用了几项：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PLEASE, avoid to allocate new softirqs, if you need not _really_ high</span></span><br><span class="line"><span class="comment">   frequency threaded job scheduling. For almost all the purposes</span></span><br><span class="line"><span class="comment">   tasklets are more than enough. F.e. all serial device BHs et</span></span><br><span class="line"><span class="comment">   al. should be converted to tasklets, not to softirqs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">    TIMER_SOFTIRQ,</span><br><span class="line">    NET_TX_SOFTIRQ,</span><br><span class="line">    NET_RX_SOFTIRQ,</span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,</span><br><span class="line">    SCHED_SOFTIRQ,</span><br><span class="line">    HRTIMER_SOFTIRQ,</span><br><span class="line">    RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"> </span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么软中断注册完成之后，什么时候触发软中断处理函数执行呢？通常情况下，软中断会在中断处理程序返回前标记它，使其在稍后合适的时候被执行。在下列地方，待处理的软中断会被检查和执行：</p>
<ol>
<li>处理完一个硬件中断以后；</li>
<li>在<code>ksoftirqd</code>内核线程中；</li>
<li>在那些显示检查和执行待处理的软中断的代码中，如网络子系统中。</li>
</ol>
<p>无论如何，软中断会在<code>do_softirq()</code>（位于<code>&lt;kernel/softirq.c&gt;</code>中）中执行，如果有待处理的软中断，<code>do_softirq</code>会循环遍历每一个，调用他们的软中断处理程序。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> <span class="title function_">do_softirq</span><span class="params">(<span class="type">void</span>)</span> &#123;     </span><br><span class="line">	__u32 pending;     </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;     </span><br><span class="line">	<span class="comment">//如果在硬件中断环境中就退出，软中断不可以在硬件中断上下文或者是在软中断环境中使用，使用`in_interrupt()来防止软中断嵌套，和抢占硬中断环境。     </span></span><br><span class="line">	<span class="keyword">if</span> (in_interrupt())         </span><br><span class="line">		<span class="keyword">return</span>;     <span class="comment">//禁止本地中断     </span></span><br><span class="line">	local_irq_save(flags);     </span><br><span class="line">	pending = local_softirq_pending();</span><br><span class="line">    <span class="comment">//如果有软中断要处理，则进入__do_softirq()</span></span><br><span class="line">    <span class="keyword">if</span> (pending)         </span><br><span class="line">    	__do_softirq();     </span><br><span class="line">    local_irq_restore(flags);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面看一下<code>__do_softirq()</code>的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __do_softirq(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> *<span class="title">h</span>;</span></span><br><span class="line">    __u32 pending;   </span><br><span class="line">    <span class="type">int</span> max_restart = MAX_SOFTIRQ_RESTART;</span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line"> </span><br><span class="line">    pending = local_softirq_pending();    <span class="comment">//pending`用于保留待处理软中断32位位图</span></span><br><span class="line">    account_system_vtime(current);</span><br><span class="line"> </span><br><span class="line">    __local_bh_disable((<span class="type">unsigned</span> <span class="type">long</span>)__builtin_return_address(<span class="number">0</span>));</span><br><span class="line">    lockdep_softirq_enter();</span><br><span class="line"> </span><br><span class="line">    cpu = smp_processor_id();</span><br><span class="line">restart:</span><br><span class="line">    <span class="comment">/* Reset the pending bitmask before enabling irqs */</span></span><br><span class="line">    set_softirq_pending(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    local_irq_enable();</span><br><span class="line"> </span><br><span class="line">    h = softirq_vec;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pending &amp; <span class="number">1</span>) &#123;    <span class="comment">//如果`pending`第`n`位被设置为1，那么处理第`n`位对应类型的软中断</span></span><br><span class="line">            <span class="type">int</span> prev_count = preempt_count();</span><br><span class="line">            kstat_incr_softirqs_this_cpu(h - softirq_vec);</span><br><span class="line"> </span><br><span class="line">            trace_softirq_entry(h, softirq_vec);</span><br><span class="line">            h-&gt;action(h);    <span class="comment">//执行软中断处理函数</span></span><br><span class="line">            trace_softirq_exit(h, softirq_vec);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(prev_count != preempt_count())) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;huh, entered softirq %td %s %p&quot;</span></span><br><span class="line">                       <span class="string">&quot;with preempt_count %08x,&quot;</span></span><br><span class="line">                       <span class="string">&quot; exited with %08x?\n&quot;</span>, h - softirq_vec,</span><br><span class="line">                       softirq_to_name[h - softirq_vec],</span><br><span class="line">                       h-&gt;action, prev_count, preempt_count());</span><br><span class="line">                preempt_count() = prev_count;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            rcu_bh_qs(cpu);</span><br><span class="line">        &#125;</span><br><span class="line">        h++;</span><br><span class="line">        pending &gt;&gt;= <span class="number">1</span>;    <span class="comment">//pending`右移一位，循环检查其每一位</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (pending);    <span class="comment">//直到`pending`变为0，pending`最多32位，所以循环最多执行32次。</span></span><br><span class="line"> </span><br><span class="line">    local_irq_disable();</span><br><span class="line"> </span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line">    <span class="keyword">if</span> (pending &amp;&amp; --max_restart)</span><br><span class="line">        <span class="keyword">goto</span> restart;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (pending)</span><br><span class="line">        wakeup_softirqd();</span><br><span class="line"> </span><br><span class="line">    lockdep_softirq_exit();</span><br><span class="line"> </span><br><span class="line">    account_system_vtime(current);</span><br><span class="line">    _local_bh_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用软中断必须要在编译期间静态注册，一般只有像网络这样对性能要求高的情况才使用软中断，文章前面我们也看到，系统中注册的软中断就那么几个。大部分时候，使用下半部另外一种机制<code>tasklet</code>的情况更多一些，<code>tasklet</code>可以动态的注册，可以被看作是一种性能和易用性之间寻求平衡的一种产物。事实上，大部分驱动程序都是用<code>tasklet</code>来实现他们的下半部。</p>
<h1 id="下半部机制之tasklet"><a href="#下半部机制之tasklet" class="headerlink" title="下半部机制之tasklet"></a>下半部机制之tasklet</h1><p><code>tasklet</code>是利用软中断实现的一种下半部机制。<code>tasklet</code>相比于软中断，其接口更加简单方便，锁保护要求较低。<code>tasklet</code>由<code>tasklet_struct</code>结构体表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span>    <span class="comment">//链表中下一个tasklet</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;        <span class="comment">//tasklet状态</span></span><br><span class="line">    <span class="type">atomic_t</span> count;        <span class="comment">//引用计数</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);    <span class="comment">//tasklet处理函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;    <span class="comment">//给tasklet处理函数的参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>tasklet</code>还分为了高优先级<code>tasklet</code>与一般<code>tasklet</code>，前面分析软中断时<code>softirq_init()</code>注册的两个<code>tasklet</code>软中断。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">softirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//此处注册两个软中断</span></span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">    open_softirq(HI_SOFTIRQ, tasklet_hi_action);    </span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其处理函数分别为<code>tasklet_action()</code>和<code>tasklet_hi_action()</code>。</p>
<p><code>tasklet_action()</code>函数实现为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tasklet_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line"> </span><br><span class="line">    local_irq_disable();</span><br><span class="line">    <span class="built_in">list</span> = __get_cpu_var(tasklet_vec).head;</span><br><span class="line">    __get_cpu_var(tasklet_vec).head = <span class="literal">NULL</span>;</span><br><span class="line">    __get_cpu_var(tasklet_vec).tail = &amp;__get_cpu_var(tasklet_vec).head;</span><br><span class="line">    local_irq_enable();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> =</span> <span class="built_in">list</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (tasklet_trylock(t)) &#123;    </span><br><span class="line">            <span class="keyword">if</span> (!<span class="type">atomic_read</span>(&amp;t-&gt;count)) &#123;        <span class="comment">//t-&gt;count`为零才会调用`task_struct`里的函数</span></span><br><span class="line">                <span class="keyword">if</span> (!test_and_clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">                    BUG();</span><br><span class="line"> </span><br><span class="line">                 t-&gt;func(t-&gt;data);    <span class="comment">//设置了`TASKLET_STATE_SCHED`标志才会被遍历到链表上对应的函数</span></span><br><span class="line">                tasklet_unlock(t);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasklet_unlock(t);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        local_irq_disable();</span><br><span class="line">        t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        *__get_cpu_var(tasklet_vec).tail = t;</span><br><span class="line">        __get_cpu_var(tasklet_vec).tail = &amp;(t-&gt;next);</span><br><span class="line">        __raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">        local_irq_enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>tasklet_hi_action</code>函数实现类似<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tasklet_hi_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line"> </span><br><span class="line">    local_irq_disable();</span><br><span class="line">    <span class="built_in">list</span> = __get_cpu_var(tasklet_hi_vec).head;</span><br><span class="line">    __get_cpu_var(tasklet_hi_vec).head = <span class="literal">NULL</span>;</span><br><span class="line">    __get_cpu_var(tasklet_hi_vec).tail = &amp;__get_cpu_var(tasklet_hi_vec).head;</span><br><span class="line">    local_irq_enable();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> =</span> <span class="built_in">list</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (tasklet_trylock(t)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="type">atomic_read</span>(&amp;t-&gt;count)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!test_and_clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">                    BUG();</span><br><span class="line">                t-&gt;func(t-&gt;data);</span><br><span class="line">                tasklet_unlock(t);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasklet_unlock(t);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        local_irq_disable();</span><br><span class="line">        t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        *__get_cpu_var(tasklet_hi_vec).tail = t;</span><br><span class="line">        __get_cpu_var(tasklet_hi_vec).tail = &amp;(t-&gt;next);</span><br><span class="line">        __raise_softirq_irqoff(HI_SOFTIRQ);</span><br><span class="line">        local_irq_enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个函数主要是做了如下动作：</p>
<ol>
<li>禁止中断，并为当前处理器检索<code>tasklet_vec</code>或<code>tasklet_hi_vec</code>链表。</li>
<li>将当前处理器上的该链表设置为`NULL,达到清空的效果。</li>
<li>运行相应中断。</li>
<li>循环遍历获得链表上的每一个待处理的`tasklet。</li>
<li>如果是多处理器系统，通过检查<code>TASKLET_STATE_RUN</code>来判断这个<code>tasklet</code>是否正在其他处理器上运行。如果它正在运行，那么现在就不要执行，跳到下一个待处理的<code>tasklet</code>去。</li>
<li>如果当前这个<code>tasklet</code>没有执行，将其状态设置为<code>TASKLETLET_STATE_RUN</code>，这样别的处理器就不会再去执行它了。</li>
<li>检查<code>count</code>值是否为0，确保<code>tasklet</code>没有被禁止。如果<code>tasklet</code>被禁止，则跳到下一个挂起的<code>tasklet</code>去。</li>
<li>现在可以确定这个<code>tasklet</code>没有在其他地方执行，并且被我们设置为执行状态，这样它在其他部分就不会被执行，并且引用计数器为0，现在可以执行<code>tasklet</code>的处理程序了。</li>
<li>重复执行下一个<code>tasklet</code>，直至没有剩余的等待处理的<code>tasklets</code>。</li>
</ol>
<p>一般情况下，都是用<code>tasklet</code>来实现下半部，<code>tasklet</code>可以动态创建、使用方便、执行速度快。下面来看一下如何创建自己的<code>tasklet</code>呢？</p>
<p>第一步，声明自己的<code>tasklet</code>。既可以静态也可以动态创建，这取决于选择是想有一个对<code>tasklet</code>的直接引用还是间接引用。静态创建方法(直接引用)，可以使用下列两个宏的一个(在<code>Linux/interrupt.h</code>中定义)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET(name,func,data)</span><br><span class="line">DECLARE_TASKLET_DISABLED(name,func,data)</span><br></pre></td></tr></table></figure><br>这两个宏的实现为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET(name, func, data) \</span></span><br><span class="line"><span class="meta">struct tasklet_struct name = &#123; NULL, 0, ATOMIC_INIT(0), func, data &#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET_DISABLED(name, func, data) \</span></span><br><span class="line"><span class="meta">struct tasklet_struct name = &#123; NULL, 0, ATOMIC_INIT(1), func, data &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这两个宏之间的区别在于引用计数器的初始值不同，前面一个把创建的<code>tasklet</code>的引用计数器设置为0，使其处于激活状态，另外一个将其设置为1，处于禁止状态。而动态创建(间接引用)的方式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklet_init(t,tasklet_handler,dev);</span><br></pre></td></tr></table></figure><br>其实现代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t,</span></span><br><span class="line"><span class="params">          <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;state = <span class="number">0</span>;</span><br><span class="line">    <span class="type">atomic_set</span>(&amp;t-&gt;count, <span class="number">0</span>);</span><br><span class="line">    t-&gt;func = func;</span><br><span class="line">    t-&gt;data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步，编写<code>tasklet</code>处理程序。<code>tasklet</code>处理函数类型是<code>void tasklet_handler(unsigned long data)</code>。因为是靠软中断实现，所以<code>tasklet</code>不能休眠，也就是说不能在<code>tasklet</code>中使用信号量或者其他什么阻塞式的函数。由于<code>tasklet</code>运行时允许响应中断，所以必须做好预防工作，如果新加入的<code>tasklet</code>和中断处理程序之间共享了某些数据额的话。两个相同的<code>tasklet</code>绝不能同时执行，如果新加入的<code>tasklet</code>和其他的<code>tasklet</code>或者软中断共享了数据，就必须要进行适当地锁保护。</p>
<p>第三步，调度自己的<code>tasklet</code>。调用<code>tasklet_schedule()</code>（或<code>tasklet_hi_schedule()</code>）函数，<code>tasklet</code>就会进入挂起状态以便执行。如果在还没有得到运行机会之前，如果有一个相同的<code>tasklet</code>又被调度了，那么它仍然只会运行一次。如果这时已经开始运行，那么这个新的<code>tasklet</code>会被重新调度并再次运行。一种优化策略是一个<code>tasklet</code>总在调度它的处理器上执行。</p>
<p>调用<code>tasklet_disable()</code>来禁止某个指定的<code>tasklet</code>，如果该<code>tasklet</code>当前正在执行，这个函数会等到它执行完毕再返回。调用<code>tasklet_disable_nosync()</code>也是来禁止的，只是不用在返回前等待<code>tasklet</code>执行完毕，这么做不太安全，因为没法估计该<code>tasklet</code>是否仍在执行。<code>tasklet_enable()</code>激活一个<code>tasklet</code>。可以使用<code>tasklet_kill()</code>函数从挂起的对列中去掉一个<code>tasklet</code>。这个函数会首先等待该<code>tasklet</code>执行完毕，然后再将其移去。当然，没有什么可以阻止其他地方的代码重新调度该<code>tasklet</code>。由于该函数可能会引起休眠，所以禁止在中断上下文中使用它。</p>
<p>下面来看一下函数<code>tasklet_schedule</code>的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检查tasklet的状态是否为TASKLET_STATE_SCHED.如果是，说明tasklet已经被调度过了，函数返回。</span></span><br><span class="line">    <span class="keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">		__tasklet_schedule(t);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> __tasklet_schedule(<span class="keyword">struct</span> tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//保存中断状态，然后禁止本地中断。在执行tasklet代码时，这么做能够保证处理器上的数据不会弄乱。</span></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//把需要调度的tasklet加到每个处理器一个的tasklet_vec链表或task_hi_vec链表的表头上去。</span></span><br><span class="line">    t-&gt;next = <span class="literal">NULL</span>;    *__get_cpu_var(tasklet_vec).tail = t;</span><br><span class="line">    __get_cpu_var(tasklet_vec).tail = &amp;(t-&gt;next);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//唤起TASKLET_SOFTIRQ或HI_SOFTIRQ软中断，这样在下一次调用do_softirq()时就会执行该tasklet。</span></span><br><span class="line">    raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//恢复中断到原状态并返回。</span></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>tasklet_hi_schedule()</code>函数的实现细节类似。</p>
<p>对于软中断，内核会选择几个特殊的实际进行处理(常见的是中 断处理程序返回时)。软中断被触发的频率有时会很好，而且还可能会自行重复触发，这带来的结果就是用户空间的进程无法获得足够的处理器时间，因为处于饥饿 状态。同时，如果单纯的对重复触发的软中断采取不立即处理的策略也是无法接受的。</p>
<p>内核选中的方案是不会立即处理重新触发的软中断，作为改进，当大量软中断出现的时候，内核会唤醒一组内核线程来处理这些负载。这些线程在最低优先级上运行(nice值为19)。这种这种方案能够保证在软中断负担很 重的时候用户程序不会因为得不到处理时间而处理饥饿状态。相应的，也能保证“过量”的软中断终究会得到处理。最后，在空闲系统上，这个方案同样表现良好，软中断处理得非常迅速(因为仅存的内存线程肯定会马上调度)。为了保证只要有空闲的处理器，它们就会处理软中断，所以给每个处理器都分配一个这样的线程。 所有线程的名字都叫做<code>ksoftirad/n</code>，区别在于<code>n</code>，它对应的是处理器的编号。一旦该线程被初始化，它就会执行类似下面这样的死循环：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!softirq_pending(cpu))<span class="comment">//softirq_pending()负责发现是否有待处理的软中断</span></span><br><span class="line">        schedule();    <span class="comment">//没有待处理软中断就唤起调度程序选择其他可执行进程投入运行</span></span><br><span class="line">    set_current_state(TASK_RUNNING);</span><br><span class="line">    <span class="keyword">while</span>(softirq_pending(cpu))&#123;</span><br><span class="line">        do_softirq();<span class="comment">//有待处理的软中断，ksoftirq调用do_softirq()去处理他。</span></span><br><span class="line">        <span class="keyword">if</span>(need_resched())    <span class="comment">//如果有必要的话，每次软中断完成之后调用schedule函数让其他重要进程得到处理机会</span></span><br><span class="line">            schedule();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//当所有需要执行的操作都完成以后，该内核线程将自己设置为 TASK_INTERRUPTIBLE状态</span></span><br><span class="line">    set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="下半部机制之工作队列及几种机制的选择"><a href="#下半部机制之工作队列及几种机制的选择" class="headerlink" title="下半部机制之工作队列及几种机制的选择"></a>下半部机制之工作队列及几种机制的选择</h1><p>工作队列是下半部的另外一种将工作推后执行形式。和软中断、<code>tasklet</code>不同，工作队列将工作推后交由一个内核线程去执行，并且该下半部总会在进程上下文中执行。这样，工作队列允许重新调度甚至是睡眠。</p>
<p>所以，如果推后执行的任务需要睡眠，就选择工作队列。如果不需要睡眠，那就选择软中断或`tasklet。工作队列是唯一能在进程上下文中运行的下半部实现机制，也只有它才可以睡眠。</p>
<p>工作队列子系统是一个用于创建内核线程的接口，通过它创建的进程负责执行由内核其他部分排到队列里的任务。它创建的这些内核线程称作工作者线程。工作队列可以让你的驱动程序创建一个专门的工作者线程来处理需要推后的工作。不过，工作队列子系统提供了一个缺省的工作者线程来处理这些工作。因此，工作队列最基本的表现形式就转变成一个把需要推后执行的任务交给特定的通用线程这样一种接口。缺省的工作线程叫做<code>event/n</code>。每个处理器对应一个线程，这里的<code>n</code>代表了处理器编号。除非一个驱动程序或者子系统必须建立一个属于自己的内核线程，否则最好还是使用缺省线程。</p>
<p>使用下面命令可以看到默认<code>event</code>工作者线程，每个处理器对应一个线程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ps x | grep event | grep -v grep</span><br><span class="line">    9 ?        S      0:00 [events/0]</span><br><span class="line">   10 ?        S      0:00 [events/1]</span><br></pre></td></tr></table></figure></p>
<p>工作者线程使用<code>workqueue_struct</code>结构表示（位于<code>&lt;kernel/workqueue.c&gt;</code>中）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> *<span class="title">cpu_wq</span>;</span>    <span class="comment">//该数组每一项对应系统中的一个处理器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> singlethread;</span><br><span class="line">    <span class="type">int</span> freezeable;     <span class="comment">/* Freeze threads during suspend */</span></span><br><span class="line">    <span class="type">int</span> rt;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个处理器，每个工作者线程对应对应一个<code>cpu_workqueue_struct</code>结构体（位于<code>&lt;kernel/workqueue.c&gt;</code>中）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;    <span class="comment">//保护该结构</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">worklist</span>;</span>    <span class="comment">//工作列表</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> more_work;    <span class="comment">//等待队列，其中的工作者线程因等待而处于睡眠状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">current_work</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span>    <span class="comment">//关联工作队列结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>;</span>    <span class="comment">// 关联线程，指向结构中工作者线程的进程描述符指针</span></span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure></p>
<p>每个工作者线程类型关联一个自己的<code>workqueue_struct</code>，在该结构体里面，给每个线程分配一个<code>cpu_workqueue_struct</code>，因而也就是给每个处理器分配一个，因为每个处理器都有一个该类型的工作者线程。</p>
<p>所有的工作者线程都是使用普通的内核线程实现的，他们都要执行<code>worker_thread()</code>函数。在它初始化完以后，这个函数执行一个死循环执行一个循环并开始休眠，当有操作被插入到队列的时候，线程就会被唤醒，以便执行这些操作。当没有剩余的时候，它又会继续休眠。工作由<code>work_struct</code>（位于<code>&lt;kernel/workqueue.c&gt;</code>中）结构表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> data;</span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span><span class="comment">//连接所有链表</span></span><br><span class="line">    <span class="type">work_func_t</span> func;</span><br><span class="line">.....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当一个工作线程被唤醒时，它会执行它的链表上的所有工作。工作一旦执行完毕，它就将相应的<code>work_struct</code>对象从链表上移去，当链表不再有对象时，它就继续休眠。<code>woker_thread()</code>函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *__cwq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> *<span class="title">cwq</span> =</span> __cwq;</span><br><span class="line">    DEFINE_WAIT(wait);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (cwq-&gt;wq-&gt;freezeable)</span><br><span class="line">        set_freezable();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//线程将自己设置为休眠状态并把自己加入等待队列</span></span><br><span class="line">        prepare_to_wait(&amp;cwq-&gt;more_work, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">        <span class="keyword">if</span> (!freezing(current) &amp;&amp;</span><br><span class="line">            !kthread_should_stop() &amp;&amp;</span><br><span class="line">            list_empty(&amp;cwq-&gt;worklist))</span><br><span class="line">            schedule();<span class="comment">//如果工作对列是空的，线程调用`schedule()函数进入睡眠状态</span></span><br><span class="line">        finish_wait(&amp;cwq-&gt;more_work, &amp;wait);</span><br><span class="line"> </span><br><span class="line">        try_to_freeze();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果链表有对象，线程就将自己设为运行态，脱离等待队列</span></span><br><span class="line">        <span class="keyword">if</span> (kthread_should_stop())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//再次调用`run_workqueue()执行推后的工作</span></span><br><span class="line">        run_workqueue(cwq);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后由<code>run_workqueue()</code>函数来完成实际推后到此的工作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_workqueue</span><span class="params">(<span class="keyword">struct</span> cpu_workqueue_struct *cwq)</span> </span><br><span class="line">&#123;</span><br><span class="line">    spin_lock_irq(&amp;cwq-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;cwq-&gt;worklist)) &#123;</span><br><span class="line">        <span class="comment">//链表不为空时，选取下一个节点对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span> list_entry(cwq-&gt;worklist.next,</span><br><span class="line">                        <span class="keyword">struct</span> work_struct, entry);</span><br><span class="line">        <span class="comment">//获取希望执行的函数`func`及其参数`data</span></span><br><span class="line">        <span class="type">work_func_t</span> f = work-&gt;func;</span><br><span class="line">......</span><br><span class="line">        trace_workqueue_execution(cwq-&gt;thread, work);</span><br><span class="line">        cwq-&gt;current_work = work;</span><br><span class="line">        <span class="comment">//把该结点从链表上解下来</span></span><br><span class="line">        list_del_init(cwq-&gt;worklist.next);</span><br><span class="line">        spin_unlock_irq(&amp;cwq-&gt;lock);</span><br><span class="line"> </span><br><span class="line">        BUG_ON(get_wq_data(work) != cwq);</span><br><span class="line">        <span class="comment">//将待处理标志位`pending`清0</span></span><br><span class="line">        work_clear_pending(work);</span><br><span class="line">        lock_map_acquire(&amp;cwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">        lock_map_acquire(&amp;lockdep_map);</span><br><span class="line">        <span class="comment">//执行函数</span></span><br><span class="line">        f(work);</span><br><span class="line">        lock_map_release(&amp;lockdep_map);</span><br><span class="line">        lock_map_release(&amp;cwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line">        spin_lock_irq(&amp;cwq-&gt;lock);</span><br><span class="line">        cwq-&gt;current_work = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;cwq-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>系统允许有多种类型工作者线程存在，默认情况下内核只有<code>event</code>这一种类型的工作者线程，每个工作者线程都由一个<code>cpu_workqueue_struct</code>结构体表示，大部分情况下，驱动程序都使用现存的默认工作者线程。</p>
<p>工作队列的使用很简单。可以使用缺省的<code>events</code>任务队列，也可以创建新的工作者线程。<br>第一步、创建需要推后完成的工作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WORK(name,<span class="type">void</span> (*func)(<span class="type">void</span> *),<span class="type">void</span> *data);        <span class="comment">//编译时静态创建</span></span><br><span class="line">INIT_WORK(<span class="keyword">struct</span> work_struct *work, <span class="type">void</span> (*func)(<span class="type">void</span> *));    <span class="comment">//运行时动态创建</span></span><br></pre></td></tr></table></figure></p>
<p>第二步、编写队列处理函数，处理函数会由工作者线程执行，因此，函数会运行在进程上下文中，默认情况下，允许相应中断，并且不持有锁。如果需要，函数可以睡眠。需要注意的是，尽管处理函数运行在进程上下文中，但它不能访问用户空间，因为内核线程在用户空间没有相应的内存映射。函数原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">work_hander</span><span class="params">(<span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure></p>
<p>第三步、调度工作队列。调用<code>schedule_work(&amp;work)</code>；<code>work</code>马上就会被调度，一旦其所在的处理器上的工作者线程被唤醒，它就会被执行。当然如果不想快速执行，而是想延迟一段时间执行，调用<code>schedule_delay_work(&amp;work,delay)</code>，<code>delay</code>是要延迟的时间节拍。</p>
<p>默认工作者线程的调度函数其实就是做了一层封装，减少了 默认工作者线程的参数输入，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> queue_work(keventd_wq, work);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">schedule_delayed_work</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork, <span class="type">unsigned</span> <span class="type">long</span> delay)</span>                                             </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> queue_delayed_work(keventd_wq, dwork, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第四步、刷新操作，插入队列的工作会在工作者线程下一次被唤醒的时候执行。有时，在继续下一步工作之前，你必须保证一些操作已经执行完毕等等。由于这些原因，内核提供了一个用于刷新指定工作队列的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">flush_scheduled_work</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><br>这个函数会一直等待，直到队列中所有的对象都被执行后才返回。在等待所有待处理的工作执行的时候，该函数会进入休眠状态，所以只能在进程上下文中使用它。需要说明的是，该函数并不取消任何延迟执行的工作。取消延迟执行的工作应该调用：<code>int cancel_delayed_work(struct work_struct *work)</code>;这个函数可以取消任何与<code>work_struct</code>相关挂起的工作。<br>下面为一个示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span> <span class="comment">//work_strcut</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//struct work_struct      ws;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>     <span class="title">dw</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">workqueue_func</span><span class="params">(<span class="keyword">struct</span> work_struct *ws)</span>    <span class="comment">//处理函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Hello, this is shallnet!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kwq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//INIT_WORK(&amp;ws, workqueue_func);    //建需要推后完成的工作</span></span><br><span class="line">    <span class="comment">//schedule_work(&amp;ws);    //调度工作</span></span><br><span class="line"> </span><br><span class="line">    INIT_DELAYED_WORK(&amp;dw, workqueue_func);</span><br><span class="line">    schedule_delayed_work(&amp;dw, <span class="number">10000</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kwq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line"> </span><br><span class="line">    flush_scheduled_work();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(kwq_init);</span><br><span class="line">module_exit(kwq_exit);</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;shallnet&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;blog.csdn.net/shallnet&quot;</span>);</span><br></pre></td></tr></table></figure><br>上面的操作是使用缺省的工作队列，下面来看一下创建一个新的工作队列是如何操作的？</p>
<p>创建一个新的工作队列和与之相应的工作者线程，方法很简单，使用如下函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> workqueue_struct *<span class="title function_">create_workqueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>name</code>是新内核线程的名字。比如缺省<code>events</code>队列的创建是这样使用的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span>    *<span class="title">keventd_wq</span>；</span></span><br><span class="line"><span class="class"><span class="title">kevent_wq</span> =</span> create_workqueue(<span class="string">&quot;event&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样就创建了所有的工作者线程，每个处理器都有一个。然后调用如下函数进行调度：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">queue_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq, <span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">queue_delayed_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,<span class="keyword">struct</span> delayed_work *work,<span class="type">unsigned</span> <span class="type">long</span> delay)</span>;</span><br></pre></td></tr></table></figure></p>
<p>最后可以调用<code>flush_workqueue(struct workqueue_struct *wq);</code>刷新指定工作队列。</p>
<p>下面为自定义新的工作队列的示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span> <span class="comment">//work_strcut</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">sln_wq</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//struct work_struct      ws;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>     <span class="title">dw</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">workqueue_func</span><span class="params">(<span class="keyword">struct</span> work_struct *ws)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Hello, this is shallnet!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kwq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line"> </span><br><span class="line">    sln_wq = create_workqueue(<span class="string">&quot;sln_wq&quot;</span>);    <span class="comment">//创建名为`sln_wq`的工作队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//INIT_WORK(&amp;ws, workqueue_func);</span></span><br><span class="line">    <span class="comment">//queue_work(sln_wq, &amp;ws);</span></span><br><span class="line"> </span><br><span class="line">    INIT_DELAYED_WORK(&amp;dw, workqueue_func);    <span class="comment">//</span></span><br><span class="line">    queue_delayed_work(sln_wq, &amp;dw, <span class="number">10000</span>);    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kwq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line"> </span><br><span class="line">    flush_workqueue(sln_wq);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(kwq_init);</span><br><span class="line">module_exit(kwq_exit);</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;shallnet&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;blog.csdn.net/shallnet&quot;</span>);</span><br></pre></td></tr></table></figure><br>使用<code>ps</code>可以查看到名为<code>sln_wq</code>的工作者线程。</p>
<p>在当前2.6.32版本中，我们讲了三种下半部机制：软中断、tasklet、工作队列。其中<code>tasklet</code>基于软中断，而工作队列靠内核线程实现。</p>
<p>使用软中断必须要确保共享数据的安全，因为相同类别的软中断可能在不同处理器上同时执行。在对于时间要求是否严格和执行频率很高的应用，或准备利用每一处理器上的变量或类型情形，可以考虑使用软中断，如网络子系统。</p>
<p><code>tasklet</code>接口简单，可以动态创建，且两个通知类型的<code>tasklet</code>不能同时执行，所以实现起来较简单。驱动程序应该尽量选择<code>tasklet</code>而不是软中断。</p>
<p>工作队列工作于进程上下文，易于使用。由于牵扯到内核线程或上下文的切换，可能开销较大。如果你需要把任务推后到进程上下文中，或你需要休眠，那就只有使用工作队列了。</p>
<h1 id="内核时钟中断"><a href="#内核时钟中断" class="headerlink" title="内核时钟中断"></a>内核时钟中断</h1><p>内核中很多函数是基于时间驱动的，其中有些函数需要周期或定期执行。比如有的每秒执行100次，有的在等待一个相对时间之后执行。除此之外，内核还必须管理系统运行的时间日期。 </p>
<p>周期性产生的时间都是有系统定时器驱动的，系统定时器是一种可编程硬件芯片，它可以以固定频率产生中断，该中断就是所谓的定时器中断，其所对应的中断处理程序负责更新系统时间，也负责执行需要周期性运行的任务。</p>
<p>系统定时器以某种频率自行触发时钟中断，该频率可以通过编程预定，称作节拍率。当时钟中断发生时，内核就通过一种特殊的中断处理器对其进行处理。内核知道连续两次时钟中断的间隔时间，该间隔时间就称为节拍。内核就是靠这种已知的时钟中断间隔来计算实际时间和系统运行时间的。内核通过控制时钟中断维护实际时间，另外内核也为用户提供一组系统调用获取实际日期和实际时间。时钟中断对才操作系统的管理来说十分重要，系统更新运行时间、更新实际时间、均衡调度程序中个处理器上运行队列、检查进程是否用尽时间片等工作都利用时钟中断来周期执行。</p>
<p>内核有一个全局变量<code>jiffies</code>，该变量用来记录系统起来以后产生的节拍总数。系统启动是，该变量被设置为0，此后每产生一次时钟中断就增加该变量的值。<code>jiffies</code>每一秒增加的值就是<code>HZ</code>。<code>jiffies</code>定义于头文件<code>&lt;include/linux/jiffies.h&gt;</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">volatile</span> __jiffy_data jiffies;</span><br></pre></td></tr></table></figure></p>
<p>对于32位<code>unsigned long</code>，可以存放最大值为4294967295，所以当节拍数达到最大值后还要继续增加的话，它的值就会回到0值。内核提供了四个宏（位于文件<code>&lt;include/linux/jiffies.h&gt;</code>中）来比较节拍数，这些宏可以正确处理节拍计数回绕情况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> time_after(a,b)         \</span></span><br><span class="line"><span class="meta">        (typecheck(unsigned long, a) &amp;&amp; \</span></span><br><span class="line"><span class="meta">         typecheck(unsigned long, b) &amp;&amp; \</span></span><br><span class="line"><span class="meta">         ((long)(b) - (long)(a) &lt; 0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> time_before(a,b)        time_after(b,a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> time_after_eq(a,b)      \</span></span><br><span class="line"><span class="meta">        (typecheck(unsigned long, a) &amp;&amp; \</span></span><br><span class="line"><span class="meta">         typecheck(unsigned long, b) &amp;&amp; \</span></span><br><span class="line"><span class="meta">         ((long)(a) - (long)(b) &gt;= 0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> time_before_eq(a,b)     time_after_eq(b,a) </span></span><br></pre></td></tr></table></figure></p>
<p>下面示例来打印出当前系统启动后经过的<code>jiffies</code>以及秒数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/jiffies.h&gt;</span> <span class="comment">//jiffies</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/param.h&gt;</span> <span class="comment">//HZ</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">jiffies_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Current ticks is: %lu, seconds: %lu\n&quot;</span>, jiffies, jiffies/HZ);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">jiffies_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line">module_init(jiffies_init);</span><br><span class="line">module_exit(jiffies_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;shallnet&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;blog.csdn.net/shallnet&quot;</span>); </span><br></pre></td></tr></table></figure></p>
<p>执行输出结果为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># insmod jfs.ko</span><br><span class="line">===jiffies_init===</span><br><span class="line">Current ticks is: 10106703, seconds: 10106</span><br></pre></td></tr></table></figure></p>
<p>时钟中断发生时，会触发时钟中断处理程序，始终中断处理程序部分和体系结构相关，下面简单分析一下x86体系的处理：</p>
<p>时钟的初始化在<code>time_init()</code>中，在<code>start_kernel()</code>中调用<code>time_init()</code>，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    time_init();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面分析一下<code>time_init()</code>的实现，该函数位于文件<code>&lt;arch/x86/kernel/time.c&gt;</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">time_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    late_time_init = x86_late_time_init;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> __init <span class="type">void</span> <span class="title function_">x86_late_time_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    x86_init.timers.timer_init();        <span class="comment">//</span></span><br><span class="line">    tsc_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结构体<code>x86_init</code>位于<code>arch/x86/kernel/x86_init.c</code>中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x86_init_ops</span> <span class="title">x86_init</span> __<span class="title">initdata</span> =</span> &#123; </span><br><span class="line">......</span><br><span class="line">    .timers = &#123;</span><br><span class="line">        .setup_percpu_clockev&gt;--= setup_boot_APIC_clock,</span><br><span class="line">        .tsc_pre_init       = x86_init_noop,</span><br><span class="line">        .timer_init     = hpet_time_init,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>默认<code>timer</code>初始化函数为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">hpet_time_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hpet_enable())</span><br><span class="line">        setup_pit_timer();</span><br><span class="line">    setup_default_timer_irq();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>setup_default_timer_irq();</code>注册中断处理函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_default_timer_irq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setup_irq(<span class="number">0</span>, &amp;irq0);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> <span class="title">irq0</span>  =</span> &#123;</span><br><span class="line">    .handler = timer_interrupt,</span><br><span class="line">    .flags = IRQF_DISABLED | IRQF_NOBALANCING | IRQF_IRQPOLL | IRQF_TIMER,</span><br><span class="line">    .name = <span class="string">&quot;timer&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对应的中断处理函数为:<code>timer_interrupt()</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">timer_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Keep nmi watchdog up to date */</span></span><br><span class="line">    inc_irq_stat(irq0_irqs);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Optimized out for !IO_APIC and x86_64 */</span></span><br><span class="line">    <span class="keyword">if</span> (timer_ack) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Subtle, when I/O APICs are used we have to ack timer IRQ</span></span><br><span class="line"><span class="comment">         * manually to deassert NMI lines for the watchdog if run</span></span><br><span class="line"><span class="comment">         * on an 82489DX-based system.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        spin_lock(&amp;i8259A_lock);</span><br><span class="line">        outb(<span class="number">0x0c</span>, PIC_MASTER_OCW3);</span><br><span class="line">        <span class="comment">/* Ack the IRQ; AEOI will end it automatically. */</span></span><br><span class="line">        inb(PIC_MASTER_POLL);</span><br><span class="line">        spin_unlock(&amp;i8259A_lock);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在此处调用体系无关的时钟处理例程</span></span><br><span class="line">    global_clock_event-&gt;event_handler(global_clock_event);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* MCA bus quirk: Acknowledge irq0 by setting bit 7 in port 0x61 */</span></span><br><span class="line">    <span class="keyword">if</span> (MCA_bus)</span><br><span class="line">        outb_p(inb_p(<span class="number">0x61</span>)| <span class="number">0x80</span>, <span class="number">0x61</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>时钟例程在系统启动时<code>start_kernel()</code>函数中调用<code>tick_init()</code>初始化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">tick_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    clockevents_register_notifier(&amp;tick_notifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>tick_notifier</code>定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">tick_notifier</span> =</span> &#123;</span><br><span class="line">    .notifier_call = tick_notify,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tick_notify</span><span class="params">(<span class="keyword">struct</span> notifier_block *nb, <span class="type">unsigned</span> <span class="type">long</span> reason, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (reason) &#123;</span><br><span class="line">    <span class="keyword">case</span> CLOCK_EVT_NOTIFY_RESUME:</span><br><span class="line">        tick_resume();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tick_resume</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tick_device</span> *<span class="title">td</span> =</span> &amp;__get_cpu_var(tick_cpu_device);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> broadcast = tick_resume_broadcast();</span><br><span class="line"> </span><br><span class="line">    spin_lock_irqsave(&amp;tick_device_lock, flags);</span><br><span class="line">    clockevents_set_mode(td-&gt;evtdev, CLOCK_EVT_MODE_RESUME);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!broadcast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (td-&gt;mode == TICKDEV_MODE_PERIODIC)</span><br><span class="line">            tick_setup_periodic(td-&gt;evtdev, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tick_resume_oneshot();</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irqrestore(&amp;tick_device_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup the device for a periodic tick</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tick_setup_periodic</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev, <span class="type">int</span> broadcast)</span></span><br><span class="line">&#123;</span><br><span class="line">    tick_set_periodic_handler(dev, broadcast);</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据broadcast设置周期性的处理函数（kernel/time/tick-broadcast.c）,这里就设置了始终中断函数timer_interrupt中调用的时钟处理例程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tick_set_periodic_handler</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev, <span class="type">int</span> broadcast)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!broadcast)</span><br><span class="line">        dev-&gt;event_handler = tick_handle_periodic;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dev-&gt;event_handler = tick_handle_periodic_broadcast;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ，以tick_handle_periodic为例，每一个始终节拍都调用该处理函数，而该处理过程中，主要处理工作处于tick_periodic()函数中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tick_handle_periodic</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line">    <span class="type">ktime_t</span> next;</span><br><span class="line"> </span><br><span class="line">    tick_periodic(cpu);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;mode != CLOCK_EVT_MODE_ONESHOT)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    next = ktime_add(dev-&gt;next_event, tick_period);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!clockevents_program_event(dev, next, ktime_get()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (timekeeping_valid_for_hres())</span><br><span class="line">            tick_periodic(cpu);</span><br><span class="line">        next = ktime_add(next, tick_period);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>tick_periodic()</code>函数主要有以下工作：<br>下面来看分析一下该函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Periodic tick</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tick_periodic</span><span class="params">(<span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tick_do_timer_cpu == cpu) &#123;</span><br><span class="line">        write_seqlock(&amp;xtime_lock);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 记录下一个节拍事件 */</span></span><br><span class="line">        tick_next_period = ktime_add(tick_next_period, tick_period);</span><br><span class="line"> </span><br><span class="line">        do_timer(<span class="number">1</span>);</span><br><span class="line">        write_sequnlock(&amp;xtime_lock);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    update_process_times(user_mode(get_irq_regs()));<span class="comment">//更新所耗费的各种节拍数</span></span><br><span class="line">    profile_tick(CPU_PROFILING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中函数<code>do_timer()</code>（位于<code>kernel/timer.c</code>中）对<code>jiffies_64</code>做增加操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_timer</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> ticks)</span></span><br><span class="line">&#123;</span><br><span class="line">    jiffies_64 += ticks;</span><br><span class="line">    update_wall_time();    <span class="comment">//更新墙上时钟</span></span><br><span class="line">    calc_global_load();    <span class="comment">//更新系统平均负载统计值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>update_process_times</code>更新所耗费的各种节拍数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update_process_times</span><span class="params">(<span class="type">int</span> user_tick)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> current;</span><br><span class="line">    <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Note: this timer irq context must be accounted for as well. */</span></span><br><span class="line">    account_process_tick(p, user_tick);</span><br><span class="line">    run_local_timers();</span><br><span class="line">    rcu_check_callbacks(cpu, user_tick);</span><br><span class="line">    printk_tick();</span><br><span class="line">    scheduler_tick();</span><br><span class="line">    run_posix_cpu_timers(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数<code>run_local_timers()</code>会标记一个软中断去处理所有到期的定时器。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">run_local_timers</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    hrtimer_run_queues();</span><br><span class="line">    raise_softirq(TIMER_SOFTIRQ);</span><br><span class="line">    softlockup_tick();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在时钟中断处理函数<code>time_interrupt()</code>函数调用体系结构无关的时钟处理例程完成之后，返回到与体系结构的相关的中断处理函数中。以上所有的工作每一次时钟中断都会运行，也就是说如果HZ=100，那么时钟中断处理程序每一秒就会运行100次。</p>
<h1 id="内核定时器和定时执行"><a href="#内核定时器和定时执行" class="headerlink" title="内核定时器和定时执行"></a>内核定时器和定时执行</h1><p>前面章节说到了把工作推后到除现在以外的时间执行的机制是下半部机制，但是当你需要将工作推后到某个确定的时间段之后执行，使用定时器是很好的选择。</p>
<p>上一节内核时间管理中讲到内核在始终中断发生执行定时器，定时器作为软中断在下半部上下文中执行。时钟中断处理程序会执行<code>update_process_times</code>函数，在该函数中运行<code>run_local_timers()</code>函数来标记一个软中断去处理所有到期的定时器。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update_process_times</span><span class="params">(<span class="type">int</span> user_tick)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> current;</span><br><span class="line">    <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line">    <span class="comment">/* Note: this timer irq context must be accounted for as well. */</span></span><br><span class="line">    account_process_tick(p, user_tick);</span><br><span class="line">    run_local_timers();</span><br><span class="line">    rcu_check_callbacks(cpu, user_tick);</span><br><span class="line">    printk_tick();</span><br><span class="line">    scheduler_tick();</span><br><span class="line">    run_posix_cpu_timers(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run_local_timers</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    hrtimer_run_queues();</span><br><span class="line">    raise_softirq(TIMER_SOFTIRQ);</span><br><span class="line">    softlockup_tick();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在分析定时器的实现之前我们先来看一看使用内核定时器的一个实例，示例如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>   <span class="title">sln_timer</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sln_timer_do</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> l)</span></span><br><span class="line">&#123;</span><br><span class="line">    mod_timer(&amp;sln_timer, jiffies + HZ);</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;param: %ld, jiffies: %ld\n&quot;</span>, l, jiffies);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sln_timer_set</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init_timer(&amp;sln_timer);</span><br><span class="line">    sln_timer.expires = jiffies + HZ;   <span class="comment">//1s</span></span><br><span class="line">    sln_timer.function = sln_timer_do;</span><br><span class="line">    sln_timer.data = <span class="number">9527</span>;</span><br><span class="line">    add_timer(&amp;sln_timer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sln_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">    sln_timer_set();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">sln_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">    del_timer(&amp;sln_timer);</span><br><span class="line">&#125;</span><br><span class="line">module_init(sln_init);</span><br><span class="line">module_exit(sln_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;allen&quot;</span>);</span><br></pre></td></tr></table></figure><br>该示例作用是每秒钟打印出当前系统<code>jiffies</code>的值。</p>
<p>内核定时器由结构<code>timer_list</code>表示，定义在文件<code>&lt;include/linux/timer.h&gt;</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires;</span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TIMER_STATS</span></span><br><span class="line">    <span class="type">void</span> *start_site;</span><br><span class="line">    <span class="type">char</span> start_comm[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> start_pid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如示例，内核提供部分操作接口来简化管理定时器，<br>第一步、定义一个定时器：<code>struct timer_list   sln_timer;</code></p>
<p>第二步、初始化定时器数据结构的内部值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_timer(&amp;sln_timer);<span class="comment">//初始化定时器</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> init_timer(timer)\</span></span><br><span class="line"><span class="meta">    init_timer_key((timer), NULL, NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer_key</span><span class="params">(<span class="keyword">struct</span> timer_list *timer,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> lock_class_key *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    debug_init(timer);</span><br><span class="line">    __init_timer(timer, name, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init_timer(<span class="keyword">struct</span> timer_list *timer,</span><br><span class="line">             <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">             <span class="keyword">struct</span> lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">    timer-&gt;entry.next = <span class="literal">NULL</span>;</span><br><span class="line">    timer-&gt;base = __raw_get_cpu_var(tvec_bases);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TIMER_STATS</span></span><br><span class="line">    timer-&gt;start_site = <span class="literal">NULL</span>;</span><br><span class="line">    timer-&gt;start_pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(timer-&gt;start_comm, <span class="number">0</span>, TASK_COMM_LEN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    lockdep_init_map(&amp;timer-&gt;lockdep_map, name, key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步、填充<code>timer_list</code>结构中需要的值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sln_timer.expires = jiffies + HZ;   <span class="comment">//1s`后执行  </span></span><br><span class="line">sln_timer.function = sln_timer_do;    <span class="comment">//执行函数</span></span><br><span class="line">sln_timer.data = <span class="number">9527</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>sln_timer.expires</code>表示超时时间，它以节拍为单位的绝对计数值。如果当前<code>jiffies</code>计数等于或大于<code>sln_timer.expires</code>的值，那么<code>sln_timer.function</code>所指向的处理函数<code>sln_timer_do</code>就会执行，并且该函数还要使用长整型参数<code>sln_timer.dat</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sln_timer_do</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> l)</span>；</span><br></pre></td></tr></table></figure></p>
<p>第四步、激活定时器：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_timer(&amp;sln_timer);    <span class="comment">//向内核注册定时器</span></span><br></pre></td></tr></table></figure><br>这样定时器就可以运行了。</p>
<p><code>add_timer()</code>的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line">&#123;</span><br><span class="line">    BUG_ON(timer_pending(timer));</span><br><span class="line">    mod_timer(timer, timer-&gt;expires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>add_timer()</code>调用了<code>mod_timer()</code>。<code>mod_timer()</code>用于修改定时器超时时间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mod_timer(&amp;sln_timer, jiffies + HZ);</span><br></pre></td></tr></table></figure><br>由于<code>add_timer()</code>是通过调用<code>mod_timer()</code>来激活定时器，所以也可以直接使用<code>mod_timer()</code>来激活定时器，如果定时器已经初始化但没有激活，<code>mod_timer()</code>也会激活它。</p>
<p>如果需要在定时器超时前停止定时器，使用<code>del_timer()</code>函数来完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del_timer(&amp;sln_timer);</span><br></pre></td></tr></table></figure></p>
<p>该函数实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    timer_stats_timer_clear_start_info(timer);</span><br><span class="line">    <span class="keyword">if</span> (timer_pending(timer)) &#123;</span><br><span class="line">        base = lock_timer_base(timer, &amp;flags);</span><br><span class="line">        <span class="keyword">if</span> (timer_pending(timer)) &#123;</span><br><span class="line">            detach_timer(timer, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires == base-&gt;next_timer &amp;&amp;</span><br><span class="line">                !tbase_get_deferrable(timer-&gt;base))</span><br><span class="line">                base-&gt;next_timer = base-&gt;timer_jiffies;</span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock_irqrestore(&amp;base-&gt;lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">detach_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> clear_pending)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">entry</span> =</span> &amp;timer-&gt;entry;</span><br><span class="line">    debug_deactivate(timer);</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (clear_pending)</span><br><span class="line">        entry-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当使用<code>del_timer()</code>返回后，定时器就不会再被激活，但在多处理器机器上定时器上定时器中断可能已经在其他处理器上运行了，所以删除定时器时需要等待可能在其他处理器上运行的定时器处理<code>I</code>程序都退出，这时就要使用<code>del_timer_sync()</code>函数执行删除工作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del_timer_sync(&amp;sln_timer);</span><br></pre></td></tr></table></figure><br>该函数不能在中断上下文中使用。</p>
<p>该函数详细实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer_sync</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    local_irq_save(flags);</span><br><span class="line">    lock_map_acquire(&amp;timer-&gt;lockdep_map);</span><br><span class="line">    lock_map_release(&amp;timer-&gt;lockdep_map);</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">//一直循环，直到删除`timer`成功再退出</span></span><br><span class="line">        <span class="type">int</span> ret = try_to_del_timer_sync(timer);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        cpu_relax();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">try_to_del_timer_sync</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    base = lock_timer_base(timer, &amp;flags);</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;running_timer == timer)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer_pending(timer)) &#123;</span><br><span class="line">        detach_timer(timer, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (timer-&gt;expires == base-&gt;next_timer &amp;&amp;</span><br><span class="line">            !tbase_get_deferrable(timer-&gt;base))</span><br><span class="line">            base-&gt;next_timer = base-&gt;timer_jiffies;</span><br><span class="line">        ret = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    spin_unlock_irqrestore(&amp;base-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下应该使用<code>del_timer_sync()</code>函数代替<code>del_timer()</code>函数，因为无法确定在删除定时器时，他是否在其他处理器上运行。为了防止这种情况的发生，应该调用<code>del_timer_sync()</code>函数而不是<code>del_timer()</code>函数。否则，对定时器执行删除操作后，代码会继续执行，但它有可能会去操作在其它处理器上运行的定时器正在使用的资源，因而造成并发访问，所有优先使用删除定时器的同步方法。</p>
<p>除了使用定时器来推迟任务到指定时间段运行之外，还有其他的方法处理延时请求。有的方法会在延迟任务时挂起处理器，有的却不会。实际上也没有方法能够保证实际的延迟时间刚好等于指定的延迟时间。</p>
<ol>
<li>最简单的 延迟方法是忙等待，该方法实现起来很简单，只需要在循环中不断旋转直到希望的时钟节拍数耗尽。比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> delay = jiffies+<span class="number">10</span>;   <span class="comment">//延迟10个节拍</span></span><br><span class="line"><span class="keyword">while</span>(time_before(jiffies,delay))</span><br><span class="line">        ；</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这种方法当代码等待时，处理器只能在原地旋转等待，它不会去处理其他任何任务。最好在任务等待时，允许内核重新调度其它任务执行。将上面代码修改如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> delay = jiffies+<span class="number">10</span>;   <span class="comment">//10个节拍</span></span><br><span class="line"><span class="keyword">while</span>(time_before(jiffies,delay))</span><br><span class="line">    cond_resched();</span><br></pre></td></tr></table></figure></p>
<p>看一下<code>cond_resched()</code>函数具体实现代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> cond_resched() (&#123;           \</span></span><br><span class="line"><span class="meta">    __might_sleep(__FILE__, __LINE__, 0);   \</span></span><br><span class="line"><span class="meta">    _cond_resched();            \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> __sched _cond_resched(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (should_resched()) &#123;</span><br><span class="line">        __cond_resched();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __cond_resched(<span class="type">void</span>)                                                                 </span><br><span class="line">&#123;</span><br><span class="line">    add_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line">    schedule(); <span class="comment">//最终还是调用`schedule()函数来重新调度其它程序运行</span></span><br><span class="line">    sub_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>cond_resched()</code>将重新调度一个新程序投入运行，但它只有在设置完<code>need_resched</code>标志后才能生效。换句话说，就是系统中存在更重要的任务需要运行。再由于该方法需要调用调度程序，所以它不能在中断上下文中使用——只能在进程上下文中使用。事实上，所有延迟方法在进程上下文中使用，因为中断处理程序都应该尽可能快的执行。另外，延迟执行不管在哪种情况下都不应该在持有锁时或者禁止中断时发生。</p>
<ol>
<li><p>有时内核需要更短的延迟，甚至比节拍间隔还要短。这时可以使用内核提供的<code>ms、ns、us</code>级别的延迟函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">udelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span>;    <span class="comment">//arch/x86/include/asm/delay.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ndelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nsecs)</span>;    <span class="comment">//arch/x86/include/asm/delay.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>;    </span><br></pre></td></tr></table></figure>
<p><code>udelay()</code>使用忙循环将任务延迟指定的<code>ms</code>后执行，其依靠执行数次循环达到延迟效果，<code>mdelay()</code>函数是通过<code>udelay()</code>函数实现，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mdelay(n) (\ </span></span><br><span class="line">    (__builtin_constant_p(n) &amp;&amp; (n)&lt;=MAX_UDELAY_MS) ? udelay((n)*<span class="number">1000</span>) : \</span><br><span class="line">    (&#123;<span class="type">unsigned</span> <span class="type">long</span> __ms=(n); <span class="keyword">while</span> (__ms--) udelay(<span class="number">1000</span>);&#125;))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>udelay()</code>函数仅能在要求的延迟时间很短的情况下执行，而在高速机器中时间很长的延迟会造成溢出。对于较长的延迟，mdelay()工作良好。</p>
</li>
<li><p><code>schedule_timeout()</code>函数是更理想的延迟执行方法。该方法会让需要延迟执行的任务睡眠到指定的延迟时间耗尽后再重新运行。但该方法也不能保证睡眠时间正好等于指定的延迟时间，只能尽量是睡眠时间接近指定的延迟时间。当指定的时间到期后，内核唤醒被延迟的任务并将其重新放回运行队列。用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_current_state(TASK_INTERRUPTIBLE);    <span class="comment">//将任务设置为可中断睡眠状态</span></span><br><span class="line">schedule_timeout(s*HZ);    <span class="comment">//小睡一会儿，“s”秒后唤醒</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>唯一的参数是延迟的相对时间，单位是<code>jiffies</code>，上例中将相应的任务推入可中断睡眠队列，睡眠<code>s</code>秒。在调用函数<code>schedule_timeout</code>之前，不要要将任务设置成可中断或不和中断的一种，否则任务不会休眠。这个函数需要调用调度程序，所以调用它的代码必须保证能够睡眠，简而言之，调用代码必须处于进程上下文中，并且不能持有锁。</p>
<p>事实上<code>schedule_timeout()</code>函数的实现就是内核定时器的一个简单应用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">long</span> __sched <span class="title function_">schedule_timeout</span><span class="params">(<span class="type">signed</span> <span class="type">long</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expire;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (timeout)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> MAX_SCHEDULE_TIMEOUT:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * These two special cases are useful to be comfortable</span></span><br><span class="line"><span class="comment">         * in the caller. Nothing more. We could take</span></span><br><span class="line"><span class="comment">         * MAX_SCHEDULE_TIMEOUT from one of the negative value</span></span><br><span class="line"><span class="comment">         * but I&#x27; d like to return a valid offset (&gt;=0) to allow</span></span><br><span class="line"><span class="comment">         * the caller to do everything it want with the retval.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        schedule();</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Another bit of PARANOID. Note that the retval will be</span></span><br><span class="line"><span class="comment">         * 0 since no piece of kernel is supposed to do a check</span></span><br><span class="line"><span class="comment">         * for a negative retval of schedule_timeout() (since it</span></span><br><span class="line"><span class="comment">         * should never happens anyway). You just have the printk()</span></span><br><span class="line"><span class="comment">         * that will tell you if something is gone wrong and where.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            printk(KERN_ERR <span class="string">&quot;schedule_timeout: wrong timeout &quot;</span></span><br><span class="line">                <span class="string">&quot;value %lx\n&quot;</span>, timeout);</span><br><span class="line">            dump_stack();</span><br><span class="line">            current-&gt;state = TASK_RUNNING;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    expire = timeout + jiffies;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//下一行代码设置了超时执行函数`process_timeout()。</span></span><br><span class="line">    setup_timer_on_stack(&amp;timer, process_timeout, (<span class="type">unsigned</span> <span class="type">long</span>)current);</span><br><span class="line">    __mod_timer(&amp;timer, expire, <span class="literal">false</span>, TIMER_NOT_PINNED);    <span class="comment">//激活定时器</span></span><br><span class="line">    schedule();    <span class="comment">//调度其他新任务</span></span><br><span class="line">    del_singleshot_timer_sync(&amp;timer);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Remove the timer from the object tracker */</span></span><br><span class="line">    destroy_timer_on_stack(&amp;timer);</span><br><span class="line"> </span><br><span class="line">    timeout = expire - jiffies;</span><br><span class="line"> </span><br><span class="line"> out:</span><br><span class="line">    <span class="keyword">return</span> timeout &lt; <span class="number">0</span> ? <span class="number">0</span> : timeout;</span><br><span class="line">&#125;</span><br><span class="line">当定时器超时时，process_timeout()函数被调用：</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">process_timeout</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> __data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    wake_up_process((<span class="keyword">struct</span> task_struct *)__data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当任务被重新调度时，将返回代码进入睡眠前的位置继续执行，位置正好在<code>schedule()</code>处。</p>
<p>进程上下文的代码为了等待特定时间发生，可以将自己放入等待队列。但是，等待队列上的某个任务可能既在等待一个特定事件到来，又在等待一个特定时间到期，就看谁来得更快。这种情况下，代码可以简单的使用<code>scedule_timeout()</code>函数代替<code>schedule()</code>函数，这样一来，当希望指定时间到期后，任务都会被唤醒，当然，代码需要检查被唤醒的原因，有可能是被事件唤醒，也有可能是因为延迟的时间到期，还可能是因为接收到了信号，然后执行相应的操作。</p>
<h1 id="进程管理分析"><a href="#进程管理分析" class="headerlink" title="进程管理分析"></a>进程管理分析</h1><p>进程其实就是程序的执行时的实例，是处于执行期的程序。在Linux内核中，进程列表被存放在一个双向循环链表中，链表中每一项都是类型为<code>task_struct</code>的结构，该结构称作进程描述符，进程描述符包含一个具体进程的所有信息，这个结构就是我们在操作系统中所说的PCB（Process Control Block）。该结构定义于<code>&lt;include/linux/sched.h&gt;</code>文件中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> state;    <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="type">atomic_t</span> usage;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags; <span class="comment">/* per process flags, defined below */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ptrace;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> lock_depth;     <span class="comment">/* BKL lock depth */</span></span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> prio, static_prio, normal_prio;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rt_priority;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> <span class="comment">/* recipient of SIGCHLD, wait4() reports */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>  <span class="comment">/* list of my children */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>   <span class="comment">/* linkage in my parent&#x27;s children list */</span></span><br><span class="line">    ......</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>该结构体中包含的数据可以完整的描述一个正在执行的程序：打开的文件、进程的地址空间、挂起的信号、进程的状态、以及其他很多信息。</p>
<p>在系统运行过程中，进程频繁切换，所以我们需要一种方式能够快速获得当前进程的<code>task_struct</code>，于是进程内核堆栈底部存放着<code>struct thread_info</code>。该结构中有一个成员指向当前进程的<code>task_struct</code>。在x86上，<code>struct thread_info</code>在文件<code>&lt;arch/x86/include/asm/thread_info.h&gt;</code>中定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">task</span>;</span>      <span class="comment">/* 该指针存放的是指向该任务实际`task_struct`的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>  *<span class="title">exec_domain</span>;</span>   <span class="comment">/* execution domain */</span></span><br><span class="line">    __u32           flags;      <span class="comment">/* low level flags */</span></span><br><span class="line">    __u32           status;     <span class="comment">/* thread synchronous flags */</span></span><br><span class="line">    __u32           cpu;        <span class="comment">/* current CPU */</span></span><br><span class="line">    <span class="type">int</span>         preempt_count;  <span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span></span><br><span class="line">    <span class="type">mm_segment_t</span>        addr_limit;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>    <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="type">void</span> __user     *sysenter_return;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>           previous_esp;   <span class="comment">/* ESP of the previous stack in</span></span><br><span class="line"><span class="comment">                           case of nested (IRQ) stacks</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">    __u8            supervisor_stack[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span>         uaccess_err;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><br>使用<code>current</code>宏就可以获得当前进程的进程描述符。</p>
<p>每一个进程都有一个父进程，每个进程管理自己的子进程。每个进程都是<code>init</code>进程的子进程，<code>init</code>进程在内 核系统启动的最后阶段启动<code>init</code>进程，该进程读取系统的初始化脚本并执行其他相关程序，最终完成系统启动的整个过程。每个进程有0个或多个子进程，进程间的关系存放在进程描述符中。<code>task_struct</code>中有一个<code>parent</code>的指针，指向其父进程；还有个<code>children</code>的指针指向其子进程的链表。所以，对于当前进程，可以通过<code>current</code>宏来获得父进程和子进程的进程描述符。</p>
<p>下面程序打印当前进程、父进程信息和所有子进程信息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">sln_taskstruct_do</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">cur</span>,</span></span><br><span class="line"><span class="class">                        *<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">                        *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    *<span class="title">first_child</span>,</span></span><br><span class="line"><span class="class">                        *<span class="title">child_list</span>,</span></span><br><span class="line"><span class="class">                        *<span class="title">cur_chd</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取当前进程信息</span></span><br><span class="line">    cur = current;</span><br><span class="line"> </span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Current: %s[%d]\n&quot;</span>,</span><br><span class="line">            cur-&gt;comm, cur-&gt;pid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取父进程信息</span></span><br><span class="line">    parent = current-&gt;parent;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Parent: %s[%d]\n&quot;</span>,</span><br><span class="line">            parent-&gt;comm, parent-&gt;pid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取所有祖先进程信息</span></span><br><span class="line">    <span class="keyword">for</span> (task = cur; task != &amp;init_task; task = task-&gt;parent) &#123;</span><br><span class="line">        printk(KERN_ALERT<span class="string">&quot;ancestor: %s[%d]\n&quot;</span>,                                          </span><br><span class="line">            task-&gt;comm, task-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取所有子进程信息</span></span><br><span class="line">    child_list = &amp;cur-&gt;children;</span><br><span class="line">    first_child = &amp;cur-&gt;children;</span><br><span class="line">    <span class="keyword">for</span> (cur_chd = child_list-&gt;next;</span><br><span class="line">            cur_chd != first_child;</span><br><span class="line">            cur_chd = cur_chd-&gt;next) &#123;</span><br><span class="line">        task = list_entry(child_list, <span class="keyword">struct</span> task_struct, sibling);</span><br><span class="line"> </span><br><span class="line">        printk(KERN_ALERT<span class="string">&quot;Children: %s[%d]\n&quot;</span>,</span><br><span class="line">            task-&gt;comm, task-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sln_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line"> </span><br><span class="line">    sln_taskstruct_do();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">sln_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(sln_init);</span><br><span class="line">module_exit(sln_exit);</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;shallnet&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;blog.csdn.net/shallnet&quot;</span>);</span><br></pre></td></tr></table></figure><br>执行结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># insmod task.ko</span></span><br><span class="line">===sln_init===</span><br><span class="line">Current: insmod[4315]</span><br><span class="line">Parent: bash[4032]</span><br><span class="line">ancestor: insmod[4315]</span><br><span class="line">ancestor: bash[4032]</span><br><span class="line">ancestor: login[2563]</span><br><span class="line">ancestor: init[1]</span><br></pre></td></tr></table></figure></p>
<p>Linux操作系统提供产生进程的机制，在Linux下的<code>fork()</code>使用<strong>写时拷贝(copy-on-write)</strong>页实现。这种技术原理是：内存并不复制整个进程地址空间，而是让父进程和子进程共享同一拷贝，只有在需要写入的时候，数据才会被复制。也就是资源的复制只是发生在需要写入的时候才进行，在此之前都是以只读的方式共享。</p>
<p>Linux通过<code>clone()</code>系统调用实现<code>fork()</code>，然后<code>clone()</code>去调用<code>do_fork()</code>，<code>do_fork()</code>完成创建中大部分工作。库函数<code>vfork()</code>、<code>__clone()</code>都根据各自需要的参数标志去调用<code>clone()</code>。<code>fork()</code>的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。<br>用户空间的<code>fork()</code>经过系统调用进入内核，在内核中对应的处理函数为<code>sys_fork()</code>，定义于<code>&lt;arch/x86/kernel/process.c&gt;</code>文件中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sys_fork</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">do_fork</span>(SIGCHLD, regs-&gt;sp, regs, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">do_fork</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> pt_regs *regs,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> __user *child_tidptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *p;</span><br><span class="line">    <span class="type">int</span> trace = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> nr;</span><br><span class="line">    ......</span><br><span class="line">    p = <span class="built_in">copy_process</span>(clone_flags, stack_start, regs, stack_size,</span><br><span class="line">       child_tidptr, <span class="literal">NULL</span>, trace);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">task_struct</span> *<span class="built_in">copy_process</span>(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span><br><span class="line">                    <span class="keyword">struct</span> pt_regs *regs,</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span><br><span class="line">                    <span class="type">int</span> __user *child_tidptr,</span><br><span class="line">                    <span class="keyword">struct</span> pid *pid,</span><br><span class="line">                    <span class="type">int</span> trace)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *p;</span><br><span class="line">    <span class="type">int</span> cgroup_callbacks_done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(-EINVAL);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread groups must share signals as well, and detached threads</span></span><br><span class="line"><span class="comment">     * can only be started up within the thread group.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; CLONE_THREAD) &amp;&amp; !(clone_flags &amp; CLONE_SIGHAND))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(-EINVAL);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Shared signal handlers imply shared VM. By way of the above,</span></span><br><span class="line"><span class="comment">     * thread groups also imply shared VM. Blocking this case allows</span></span><br><span class="line"><span class="comment">     * for various simplifications in other code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; CLONE_SIGHAND) &amp;&amp; !(clone_flags &amp; CLONE_VM))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(-EINVAL);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Siblings of global init remain as zombies on exit since they are</span></span><br><span class="line"><span class="comment">     * not reaped by their parent (swapper). To solve this and to avoid</span></span><br><span class="line"><span class="comment">     * multi-rooted process trees, prevent global and container-inits</span></span><br><span class="line"><span class="comment">     * from creating siblings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; CLONE_PARENT) &amp;&amp;</span><br><span class="line">                current-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(-EINVAL);</span><br><span class="line">    retval = <span class="built_in">security_task_create</span>(clone_flags);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    p = <span class="built_in">dup_task_struct</span>(current);</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="built_in">ftrace_graph_init_task</span>(p);</span><br><span class="line">    <span class="built_in">rt_mutex_init_task</span>(p);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROVE_LOCKING</span></span><br><span class="line">    <span class="built_in">DEBUG_LOCKS_WARN_ON</span>(!p-&gt;hardirqs_enabled);</span><br><span class="line">    <span class="built_in">DEBUG_LOCKS_WARN_ON</span>(!p-&gt;softirqs_enabled);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    retval = -EAGAIN;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">atomic_read</span>(&amp;p-&gt;real_cred-&gt;user-&gt;processes) &gt;=</span><br><span class="line">            p-&gt;signal-&gt;rlim[RLIMIT_NPROC].rlim_cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">capable</span>(CAP_SYS_ADMIN) &amp;&amp; !<span class="built_in">capable</span>(CAP_SYS_RESOURCE) &amp;&amp;</span><br><span class="line">            p-&gt;real_cred-&gt;user != INIT_USER)</span><br><span class="line">            <span class="keyword">goto</span> bad_fork_free;</span><br><span class="line">    &#125;</span><br><span class="line">    retval = <span class="built_in">copy_creds</span>(p, clone_flags);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_free;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If multiple threads are within copy_process(), then this check</span></span><br><span class="line"><span class="comment">     * triggers too late. This doesn&#x27;t hurt, the check is only there</span></span><br><span class="line"><span class="comment">     * to stop root fork bombs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    retval = -EAGAIN;</span><br><span class="line">    <span class="keyword">if</span> (nr_threads &gt;= max_threads)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_count;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">try_module_get</span>(<span class="built_in">task_thread_info</span>(p)-&gt;exec_domain-&gt;<span class="keyword">module</span>))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_count;</span><br><span class="line">    p-&gt;did_exec = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">delayacct_tsk_init</span>(p);  <span class="comment">/* Must remain after dup_task_struct() */</span></span><br><span class="line">    <span class="built_in">copy_flags</span>(clone_flags, p);</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;children);</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;sibling);</span><br><span class="line">    <span class="built_in">rcu_copy_process</span>(p);</span><br><span class="line">    p-&gt;vfork_done = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">spin_lock_init</span>(&amp;p-&gt;alloc_lock);</span><br><span class="line">    <span class="built_in">init_sigpending</span>(&amp;p-&gt;pending);</span><br><span class="line">    p-&gt;utime = cputime_zero;</span><br><span class="line">    p-&gt;stime = cputime_zero;</span><br><span class="line">    p-&gt;gtime = cputime_zero;</span><br><span class="line">    p-&gt;utimescaled = cputime_zero;</span><br><span class="line">    p-&gt;stimescaled = cputime_zero;</span><br><span class="line">    p-&gt;prev_utime = cputime_zero;</span><br><span class="line">    p-&gt;prev_stime = cputime_zero;</span><br><span class="line">    p-&gt;default_timer_slack_ns = current-&gt;timer_slack_ns;</span><br><span class="line">    <span class="built_in">task_io_accounting_init</span>(&amp;p-&gt;ioac);</span><br><span class="line">    <span class="built_in">acct_clear_integrals</span>(p);</span><br><span class="line">    <span class="built_in">posix_cpu_timers_init</span>(p);</span><br><span class="line">    p-&gt;lock_depth = <span class="number">-1</span>;     <span class="comment">/* -1 = no lock */</span></span><br><span class="line">    <span class="built_in">do_posix_clock_monotonic_gettime</span>(&amp;p-&gt;start_time);</span><br><span class="line">    p-&gt;real_start_time = p-&gt;start_time;</span><br><span class="line">    <span class="built_in">monotonic_to_bootbased</span>(&amp;p-&gt;real_start_time);</span><br><span class="line">    p-&gt;io_context = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;audit_context = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cgroup_fork</span>(p);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    p-&gt;mempolicy = <span class="built_in">mpol_dup</span>(p-&gt;mempolicy);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(p-&gt;mempolicy)) &#123;</span><br><span class="line">        retval = <span class="built_in">PTR_ERR</span>(p-&gt;mempolicy);</span><br><span class="line">        p-&gt;mempolicy = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_cgroup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mpol_fix_fork_child_flag</span>(p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">    p-&gt;irq_events = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARCH_WANT_INTERRUPTS_ON_CTXSW</span></span><br><span class="line">    p-&gt;hardirqs_enabled = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    p-&gt;hardirqs_enabled = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    p-&gt;hardirq_enable_ip = <span class="number">0</span>;</span><br><span class="line">    p-&gt;hardirq_enable_event = <span class="number">0</span>;</span><br><span class="line">    p-&gt;hardirq_disable_ip = _THIS_IP_;</span><br><span class="line">    p-&gt;hardirq_disable_event = <span class="number">0</span>;</span><br><span class="line">    p-&gt;softirqs_enabled = <span class="number">1</span>;</span><br><span class="line">    p-&gt;softirq_enable_ip = _THIS_IP_;</span><br><span class="line">    p-&gt;softirq_enable_event = <span class="number">0</span>;</span><br><span class="line">    p-&gt;softirq_disable_ip = <span class="number">0</span>;</span><br><span class="line">    p-&gt;softirq_disable_event = <span class="number">0</span>;</span><br><span class="line">    p-&gt;hardirq_context = <span class="number">0</span>;</span><br><span class="line">    p-&gt;softirq_context = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    p-&gt;lockdep_depth = <span class="number">0</span>; <span class="comment">/* no locks held yet */</span></span><br><span class="line">    p-&gt;curr_chain_key = <span class="number">0</span>;</span><br><span class="line">    p-&gt;lockdep_recursion = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    p-&gt;blocked_on = <span class="literal">NULL</span>; <span class="comment">/* not blocked yet */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    p-&gt;bts = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;stack_start = stack_start;</span><br><span class="line">    <span class="comment">/* Perform scheduler related setup. Assign this task to a CPU. */</span></span><br><span class="line">    <span class="built_in">sched_fork</span>(p, clone_flags);</span><br><span class="line">    retval = <span class="built_in">perf_event_init_task</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_policy;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">audit_alloc</span>(p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_policy;</span><br><span class="line">    <span class="comment">/* copy all the process information */</span></span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_semundo</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_audit;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_files</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_semundo;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_fs</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_files;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_sighand</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_signal</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_sighand;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_mm</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_signal;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_namespaces</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_mm;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_io</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_namespaces;</span><br><span class="line">    retval = <span class="built_in">copy_thread</span>(clone_flags, stack_start, stack_size, p, regs);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_io;</span><br><span class="line">    <span class="keyword">if</span> (pid != &amp;init_struct_pid) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        pid = <span class="built_in">alloc_pid</span>(p-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">        <span class="keyword">if</span> (!pid)</span><br><span class="line">            <span class="keyword">goto</span> bad_fork_cleanup_io;</span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_NEWPID) &#123;</span><br><span class="line">            retval = <span class="built_in">pid_ns_prepare_proc</span>(p-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">            <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> bad_fork_free_pid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;pid = <span class="built_in">pid_nr</span>(pid);</span><br><span class="line">    p-&gt;tgid = p-&gt;pid;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">        p-&gt;tgid = current-&gt;tgid;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;nsproxy != p-&gt;nsproxy) &#123;</span><br><span class="line">        retval = <span class="built_in">ns_cgroup_clone</span>(p, pid);</span><br><span class="line">        <span class="keyword">if</span> (retval)</span><br><span class="line">            <span class="keyword">goto</span> bad_fork_free_pid;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;set_child_tid = (clone_flags &amp; CLONE_CHILD_SETTID) ? child_tidptr : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Clear TID on mm_release()?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;clear_child_tid = (clone_flags &amp; CLONE_CHILD_CLEARTID) ? child_tidptr: <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FUTEX</span></span><br><span class="line">    p-&gt;robust_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">    p-&gt;compat_robust_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;pi_state_list);</span><br><span class="line">    p-&gt;pi_state_cache = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * sigaltstack should be cleared when sharing the same VM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; (CLONE_VM|CLONE_VFORK)) == CLONE_VM)</span><br><span class="line">        p-&gt;sas_ss_sp = p-&gt;sas_ss_size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Syscall tracing should be turned off in the child regardless</span></span><br><span class="line"><span class="comment">     * of CLONE_PTRACE.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">clear_tsk_thread_flag</span>(p, TIF_SYSCALL_TRACE);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIF_SYSCALL_EMU</span></span><br><span class="line">    <span class="built_in">clear_tsk_thread_flag</span>(p, TIF_SYSCALL_EMU);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">clear_all_latency_tracing</span>(p);</span><br><span class="line">    <span class="comment">/* ok, now we should be set up.. */</span></span><br><span class="line">    p-&gt;exit_signal = (clone_flags &amp; CLONE_THREAD) ? <span class="number">-1</span> : (clone_flags &amp; CSIGNAL);</span><br><span class="line">    p-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line">    p-&gt;exit_state = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ok, make it visible to the rest of the system.</span></span><br><span class="line"><span class="comment">     * We dont wake it up yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;group_leader = p;</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;thread_group);</span><br><span class="line">    <span class="comment">/* Now that the task is set up, run cgroup callbacks if</span></span><br><span class="line"><span class="comment">     * necessary. We need to run them before the task is visible</span></span><br><span class="line"><span class="comment">     * on the tasklist. */</span></span><br><span class="line">    <span class="built_in">cgroup_fork_callbacks</span>(p);</span><br><span class="line">    cgroup_callbacks_done = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Need tasklist lock for parent etc handling! */</span></span><br><span class="line">    <span class="built_in">write_lock_irq</span>(&amp;tasklist_lock);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The task hasn&#x27;t been attached yet, so its cpus_allowed mask will</span></span><br><span class="line"><span class="comment">     * not be changed, nor will its assigned CPU.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The cpus_allowed mask of the parent may have changed after it was</span></span><br><span class="line"><span class="comment">     * copied first time - so re-copy it here, then check the child&#x27;s CPU</span></span><br><span class="line"><span class="comment">     * to ensure it is on a valid CPU (and if not, just force it back to</span></span><br><span class="line"><span class="comment">     * parent&#x27;s CPU). This avoids alot of nasty races.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;cpus_allowed = current-&gt;cpus_allowed;</span><br><span class="line">    p-&gt;rt.nr_cpus_allowed = current-&gt;rt.nr_cpus_allowed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(!<span class="built_in">cpu_isset</span>(<span class="built_in">task_cpu</span>(p), p-&gt;cpus_allowed) ||</span><br><span class="line">            !<span class="built_in">cpu_online</span>(<span class="built_in">task_cpu</span>(p))))</span><br><span class="line">        <span class="built_in">set_task_cpu</span>(p, <span class="built_in">smp_processor_id</span>());</span><br><span class="line">    <span class="comment">/* CLONE_PARENT re-uses the old parent */</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD)) &#123;</span><br><span class="line">        p-&gt;real_parent = current-&gt;real_parent;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;parent_exec_id;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;real_parent = current;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;self_exec_id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spin_lock</span>(¤t-&gt;sighand-&gt;siglock);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Process group and session signals need to be delivered to just the</span></span><br><span class="line"><span class="comment">     * parent before the fork or both the parent and the child after the</span></span><br><span class="line"><span class="comment">     * fork. Restart if a signal comes in before we add the new process to</span></span><br><span class="line"><span class="comment">     * it&#x27;s process group.</span></span><br><span class="line"><span class="comment">     * A fatal signal pending means that current will exit, so the new</span></span><br><span class="line"><span class="comment">     * thread can&#x27;t slip out of an OOM kill (or normal SIGKILL).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">recalc_sigpending</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal_pending</span>(current)) &#123;</span><br><span class="line">        <span class="built_in">spin_unlock</span>(¤t-&gt;sighand-&gt;siglock);</span><br><span class="line">        <span class="built_in">write_unlock_irq</span>(&amp;tasklist_lock);</span><br><span class="line">        retval = -ERESTARTNOINTR;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_free_pid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">        <span class="built_in">atomic_inc</span>(¤t-&gt;signal-&gt;count);</span><br><span class="line">        <span class="built_in">atomic_inc</span>(¤t-&gt;signal-&gt;live);</span><br><span class="line">        p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">        <span class="built_in">list_add_tail_rcu</span>(&amp;p-&gt;thread_group, &amp;p-&gt;group_leader-&gt;thread_group);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">likely</span>(p-&gt;pid)) &#123;</span><br><span class="line">        <span class="built_in">list_add_tail</span>(&amp;p-&gt;sibling, &amp;p-&gt;real_parent-&gt;children);</span><br><span class="line">        <span class="built_in">tracehook_finish_clone</span>(p, clone_flags, trace);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">thread_group_leader</span>(p)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clone_flags &amp; CLONE_NEWPID)</span><br><span class="line">                p-&gt;nsproxy-&gt;pid_ns-&gt;child_reaper = p;</span><br><span class="line">            p-&gt;signal-&gt;leader_pid = pid;</span><br><span class="line">            <span class="built_in">tty_kref_put</span>(p-&gt;signal-&gt;tty);</span><br><span class="line">            p-&gt;signal-&gt;tty = <span class="built_in">tty_kref_get</span>(current-&gt;signal-&gt;tty);</span><br><span class="line">            <span class="built_in">attach_pid</span>(p, PIDTYPE_PGID, <span class="built_in">task_pgrp</span>(current));</span><br><span class="line">            <span class="built_in">attach_pid</span>(p, PIDTYPE_SID, <span class="built_in">task_session</span>(current));</span><br><span class="line">            <span class="built_in">list_add_tail_rcu</span>(&amp;p-&gt;tasks, &amp;init_task.tasks);</span><br><span class="line">            __get_cpu_var(process_counts)++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">attach_pid</span>(p, PIDTYPE_PID, pid);</span><br><span class="line">        nr_threads++;</span><br><span class="line">    &#125;</span><br><span class="line">    total_forks++;</span><br><span class="line">    <span class="built_in">spin_unlock</span>(¤t-&gt;sighand-&gt;siglock);</span><br><span class="line">    <span class="built_in">write_unlock_irq</span>(&amp;tasklist_lock);</span><br><span class="line">    <span class="built_in">proc_fork_connector</span>(p);</span><br><span class="line">    <span class="built_in">cgroup_post_fork</span>(p);</span><br><span class="line">    <span class="built_in">perf_event_fork</span>(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">bad_fork_free_pid:</span><br><span class="line">    <span class="keyword">if</span> (pid != &amp;init_struct_pid)</span><br><span class="line">        <span class="built_in">free_pid</span>(pid);</span><br><span class="line">bad_fork_cleanup_io:</span><br><span class="line">    <span class="built_in">put_io_context</span>(p-&gt;io_context);</span><br><span class="line">bad_fork_cleanup_namespaces:</span><br><span class="line">    <span class="built_in">exit_task_namespaces</span>(p);</span><br><span class="line">bad_fork_cleanup_mm:</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;mm)</span><br><span class="line">        <span class="built_in">mmput</span>(p-&gt;mm);</span><br><span class="line">bad_fork_cleanup_signal:</span><br><span class="line">    <span class="keyword">if</span> (!(clone_flags &amp; CLONE_THREAD))</span><br><span class="line">        __cleanup_signal(p-&gt;signal);</span><br><span class="line">bad_fork_cleanup_sighand:</span><br><span class="line">    __cleanup_sighand(p-&gt;sighand);</span><br><span class="line">bad_fork_cleanup_fs:</span><br><span class="line">    <span class="built_in">exit_fs</span>(p); <span class="comment">/* blocking */</span></span><br><span class="line">bad_fork_cleanup_files:</span><br><span class="line">    <span class="built_in">exit_files</span>(p); <span class="comment">/* blocking */</span></span><br><span class="line">bad_fork_cleanup_semundo:</span><br><span class="line">    <span class="built_in">exit_sem</span>(p);</span><br><span class="line">bad_fork_cleanup_audit:</span><br><span class="line">    <span class="built_in">audit_free</span>(p);</span><br><span class="line">bad_fork_cleanup_policy:</span><br><span class="line">    <span class="built_in">perf_event_free_task</span>(p);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="built_in">mpol_put</span>(p-&gt;mempolicy);</span><br><span class="line">bad_fork_cleanup_cgroup:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cgroup_exit</span>(p, cgroup_callbacks_done);</span><br><span class="line">    <span class="built_in">delayacct_tsk_free</span>(p);</span><br><span class="line">    <span class="built_in">module_put</span>(<span class="built_in">task_thread_info</span>(p)-&gt;exec_domain-&gt;<span class="keyword">module</span>);</span><br><span class="line">bad_fork_cleanup_count:</span><br><span class="line">    <span class="built_in">atomic_dec</span>(&amp;p-&gt;cred-&gt;user-&gt;processes);</span><br><span class="line">    <span class="built_in">exit_creds</span>(p);</span><br><span class="line">bad_fork_free:</span><br><span class="line">    <span class="built_in">free_task</span>(p);</span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面执行完以后，回到<code>do_fork()</code>函数，如果<code>copy_process()</code>函数成功返回。新创建的子进程被唤醒并让其投入运行。内核有意选择子进程先运行。因为一般子进程都会马上调用<code>exec()</code>函数，这样可以避免写时拷贝的额外开销。如果父进程首先执行的话，有可能会开始向地址空间写入。</p>
<p>线程机制提供了在同一程序内共享内存地址空间运行的一组线程。线程机制支持并发程序设计技术，可以共享打开的文件和其他资源。如果你的系统是多核心的，那多线程技术可保证系统的真正并行。在Linux中，并没有线程这个概念，Linux中所有的线程都当作进程来处理，换句话说就是在内核中并没有什么特殊的结构和算法来表示线程。在Linux中，线程仅仅是一个使用共享资源的进程。每个线程都拥有一个隶属于自己的<code>task_struct</code>。所以说线程本质上还是进程，只不过该进程可以和其他一些进程共享某些资源信息。</p>
<p>内核有时需要在后台执行一些操作，这种任务可以通过内核线程完成，内核线程独立运行在内核空间的标准进程。内核线程和普通的进程间的区别在于内核线程没有独立的地址空间。它们只在讷河空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度，也可以被抢占。内核线程也只能由其它内核线程创建，内核是通过从<code>kthreadd</code>内核进程中衍生出所有新的内核线程来自动处理这一点的。在内核中创建一个的内核线程方法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_create</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">char</span> namefmt[], ...)</span></span><br></pre></td></tr></table></figure><br>该函数实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_create</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">char</span> namefmt[],</span></span><br><span class="line"><span class="params">                   ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> <span class="title">create</span>;</span></span><br><span class="line">    create.threadfn = threadfn;</span><br><span class="line">    create.data = data;</span><br><span class="line">    init_completion(&amp;create.done);</span><br><span class="line">    spin_lock(&amp;kthread_create_lock);</span><br><span class="line">    list_add_tail(&amp;create.<span class="built_in">list</span>, &amp;kthread_create_list);</span><br><span class="line">    spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">    wake_up_process(kthreadd_task);</span><br><span class="line">    wait_for_completion(&amp;create.done);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(create.result)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> =</span> &#123; .sched_priority = <span class="number">0</span> &#125;;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, namefmt);</span><br><span class="line">        vsnprintf(create.result-&gt;comm, <span class="keyword">sizeof</span>(create.result-&gt;comm),</span><br><span class="line">              namefmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">         * root may have changed our (kthreadd&#x27;s) priority or CPU mask.</span></span><br><span class="line"><span class="comment">         * The kernel thread should not inherit these properties.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sched_setscheduler_nocheck(create.result, SCHED_NORMAL, ¶m);</span><br><span class="line">        set_cpus_allowed_ptr(create.result, cpu_all_mask);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure></p>
<p>新的任务是由<code>kthread</code>内核进程通过<code>clone()</code>系统调用而创建的。新的进程将运行<code>threadfn</code>函数，给其传递参数<code>data</code>，新的进程名称为<code>namefmt</code>，新创建的进程处于不可运行状态，需要调用<code>wake_up_process()</code>明确的唤醒它，否则它不会主动运行。也可以通过调用<code>kthread_run()</code>来创建一个进程并让它运行起来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_run(threadfn, data, namefmt, ...)              \                        </span></span><br><span class="line">(&#123;                                     \</span><br><span class="line">    <span class="keyword">struct</span> task_struct *__k                        \</span><br><span class="line">        = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(__k))                          \</span><br><span class="line">        wake_up_process(__k);                      \</span><br><span class="line">    __k;                                   \</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></p>
<p><code>kthread_run</code>其实就是创建了一个内核线程并且唤醒了。内核线程启动后就一直运行直到调用<code>do_exit()</code>退出或者内核的其他部分调用<code>kthread_stop()</code>退出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthread_stop</span><span class="params">(<span class="keyword">struct</span> task_struct *k)</span>; </span><br></pre></td></tr></table></figure><br>下面为一个使用内核线程的示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span>  <span class="comment">//schdule_timeout()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">sln_task</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sln_kthread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!kthread_should_stop()) &#123;</span><br><span class="line">        printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">        set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        schedule_timeout(<span class="number">2</span>*HZ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sln_init_do</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">9527</span>;</span><br><span class="line">    sln_task = kthread_create(sln_kthread_func,</span><br><span class="line">            &amp;data,</span><br><span class="line">            <span class="string">&quot;sln_kthread_task&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(sln_task)) &#123;</span><br><span class="line">        printk(KERN_ALERT<span class="string">&quot;kthread_create() failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wake_up_process(sln_task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sln_exit_do</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != sln_task) &#123;</span><br><span class="line">        kthread_stop(sln_task);</span><br><span class="line">        sln_task = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sln_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">    sln_init_do();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">sln_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">    sln_exit_do();</span><br><span class="line">&#125;</span><br><span class="line">module_init(sln_init);</span><br><span class="line">module_exit(sln_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;shallnet&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;blog.csdn.net/shallnet&quot;</span>); </span><br></pre></td></tr></table></figure></p>
<p>既然有进程的创建，那就有进程的终结，终结时内核必须释放它所占有的资源。内核终结时，大部分任务都是靠<code>do_exit()</code>来完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">NORET_TYPE <span class="type">void</span> <span class="title function_">do_exit</span><span class="params">(<span class="type">long</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line">    <span class="type">int</span> group_dead;</span><br><span class="line">    profile_task_exit(tsk);</span><br><span class="line">    WARN_ON(<span class="type">atomic_read</span>(&amp;tsk-&gt;fs_excl));</span><br><span class="line">   <span class="comment">//不可在中断上下文中使用该函数</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(in_interrupt()))</span><br><span class="line">        panic(<span class="string">&quot;Aiee, killing interrupt handler!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!tsk-&gt;pid))</span><br><span class="line">        panic(<span class="string">&quot;Attempted to kill the idle task!&quot;</span>);</span><br><span class="line">    tracehook_report_exit(&amp;code);</span><br><span class="line">    validate_creds_for_do_exit(tsk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We&#x27;re taking recursive faults here in do_exit. Safest is to just</span></span><br><span class="line"><span class="comment">     * leave this task alone and wait for reboot.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(tsk-&gt;flags &amp; PF_EXITING)) &#123;</span><br><span class="line">        printk(KERN_ALERT</span><br><span class="line">            <span class="string">&quot;Fixing recursive fault but reboot is needed!\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//设置PF_EXITING:表示进程正在退出</span></span><br><span class="line">        tsk-&gt;flags |= PF_EXITPIDONE;</span><br><span class="line">        set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    exit_irq_thread();</span><br><span class="line">    exit_signals(tsk);  <span class="comment">/* sets PF_EXITING */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * tsk-&gt;flags are checked in the futex code to protect against</span></span><br><span class="line"><span class="comment">     * an exiting task cleaning up the robust pi futexes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_mb();</span><br><span class="line">    spin_unlock_wait(&amp;tsk-&gt;pi_lock);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(in_atomic()))</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;note: %s[%d] exited with preempt_count %d\n&quot;</span>,</span><br><span class="line">                current-&gt;comm, task_pid_nr(current),</span><br><span class="line">                preempt_count());</span><br><span class="line">    acct_update_integrals(tsk);</span><br><span class="line">    group_dead = atomic_dec_and_test(&amp;tsk-&gt;signal-&gt;live);</span><br><span class="line">    <span class="keyword">if</span> (group_dead) &#123;</span><br><span class="line">        hrtimer_cancel(&amp;tsk-&gt;signal-&gt;real_timer);</span><br><span class="line">        exit_itimers(tsk-&gt;signal);</span><br><span class="line">        <span class="keyword">if</span> (tsk-&gt;mm)</span><br><span class="line">            setmax_mm_hiwater_rss(&amp;tsk-&gt;signal-&gt;maxrss, tsk-&gt;mm);</span><br><span class="line">    &#125;</span><br><span class="line">    acct_collect(code, group_dead);</span><br><span class="line">    <span class="keyword">if</span> (group_dead)</span><br><span class="line">        tty_audit_exit();</span><br><span class="line">    <span class="keyword">if</span> (unlikely(tsk-&gt;audit_context))</span><br><span class="line">        audit_free(tsk);</span><br><span class="line">    tsk-&gt;exit_code = code;</span><br><span class="line">    taskstats_exit(tsk, group_dead);</span><br><span class="line">       <span class="comment">//调用__exit_mm()函数放弃进程占用的mm_struct,如果没有别的进程使用它们即没被共享，就彻底释放它们</span></span><br><span class="line">    exit_mm(tsk);</span><br><span class="line">    <span class="keyword">if</span> (group_dead)</span><br><span class="line">        acct_process();</span><br><span class="line">    trace_sched_process_exit(tsk);</span><br><span class="line">    exit_sem(tsk);    <span class="comment">//调用sem_exit()函数。如果进程排队等候IPC信号，它则离开队列</span></span><br><span class="line">     <span class="comment">//分别递减文件描述符，文件系统数据等的引用计数。当引用计数的值为0时，就代表没有进程在使用这些资源，此时就释放</span></span><br><span class="line">    exit_files(tsk);</span><br><span class="line">    exit_fs(tsk);</span><br><span class="line">    check_stack_usage();</span><br><span class="line">    exit_thread();</span><br><span class="line">    cgroup_exit(tsk, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (group_dead &amp;&amp; tsk-&gt;signal-&gt;leader)</span><br><span class="line">        disassociate_ctty(<span class="number">1</span>);</span><br><span class="line">    module_put(task_thread_info(tsk)-&gt;exec_domain-&gt;module);</span><br><span class="line">    proc_exit_connector(tsk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Flush inherited counters to the parent - before the parent</span></span><br><span class="line"><span class="comment">     * gets woken up by child-exit notifications.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    perf_event_exit_task(tsk);</span><br><span class="line"><span class="comment">//调用exit_notify()向父进程发送信号，将子进程的父进程重新设置为线程组中的其他线程或init进程，并把进程状态设为TASK_ZOMBIE.</span></span><br><span class="line">    exit_notify(tsk, group_dead);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    mpol_put(tsk-&gt;mempolicy);</span><br><span class="line">    tsk-&gt;mempolicy = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FUTEX</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(current-&gt;pi_state_cache))</span><br><span class="line">        kfree(current-&gt;pi_state_cache);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Make sure we are holding no locks:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    debug_check_no_locks_held(tsk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We can do this unlocked here. The futex code uses this flag</span></span><br><span class="line"><span class="comment">     * just to verify whether the pi state cleanup has been done</span></span><br><span class="line"><span class="comment">     * or not. In the worst case it loops once more.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tsk-&gt;flags |= PF_EXITPIDONE;</span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;io_context)</span><br><span class="line">        exit_io_context();</span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;splice_pipe)</span><br><span class="line">        __free_pipe_info(tsk-&gt;splice_pipe);</span><br><span class="line">    validate_creds_for_do_exit(tsk);</span><br><span class="line">    preempt_disable();</span><br><span class="line">    exit_rcu();</span><br><span class="line">    <span class="comment">/* causes final put_task_struct in finish_task_switch(). */</span></span><br><span class="line">    tsk-&gt;state = TASK_DEAD;</span><br><span class="line">    schedule();    <span class="comment">//调用`schedule()切换到其他进程</span></span><br><span class="line">    BUG();</span><br><span class="line">    <span class="comment">/* Avoid &quot;noreturn function does return&quot;.  */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        cpu_relax();    <span class="comment">/* For when BUG is null */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进程终结时所需的清理工作和进程描述符的删除被分开执行，这样尽管在调用了<code>do_exit()</code>之后，线程已经僵死不能允许情况下，系统还是保留了它的进程描述符。在父进程获得已经终结的子进程信息后，子进程的<code>task_struct</code>结构才被释放。Linux中有一系列<code>wait()</code>函数，这些函数都是基于系统调用<code>wait4()</code>实现的。它的动作就是挂起调用它的进程直到其中的一个子进程退出，此时函数会返回该退出子进程的PID。 最终释放进程描述符时，会调用<code>release_task()</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">release_task</span><span class="params">(<span class="keyword">struct</span> task_struct * p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">leader</span>;</span></span><br><span class="line">    <span class="type">int</span> zap_leader;</span><br><span class="line">repeat:</span><br><span class="line">    tracehook_prepare_release_task(p);</span><br><span class="line">    <span class="comment">/* don&#x27;t need to get the RCU readlock here - the process is dead and</span></span><br><span class="line"><span class="comment">     * can&#x27;t be modifying its own credentials */</span></span><br><span class="line">    <span class="type">atomic_dec</span>(&amp;__task_cred(p)-&gt;user-&gt;processes);</span><br><span class="line">    proc_flush_task(p);</span><br><span class="line">    write_lock_irq(&amp;tasklist_lock);</span><br><span class="line">    tracehook_finish_release_task(p);</span><br><span class="line">    __exit_signal(p);    <span class="comment">//释放目前僵死进程所使用的所有剩余资源，并进行统计记录</span></span><br><span class="line">    </span><br><span class="line">    zap_leader = <span class="number">0</span>;</span><br><span class="line">    leader = p-&gt;group_leader;</span><br><span class="line">    <span class="comment">//如果进程是线程组最后一个进程，并且领头进程已经死掉，那么就通知僵死的领头进程的父进程</span></span><br><span class="line">    <span class="keyword">if</span> (leader != p &amp;&amp; thread_group_empty(leader) &amp;&amp; leader-&gt;exit_state == EXIT_ZOMBIE)</span><br><span class="line">&#123;</span><br><span class="line">        BUG_ON(task_detached(leader));</span><br><span class="line">        do_notify_parent(leader, leader-&gt;exit_signal);</span><br><span class="line">        zap_leader = task_detached(leader);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (zap_leader)</span><br><span class="line">            leader-&gt;exit_state = EXIT_DEAD;</span><br><span class="line">    &#125;</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    release_thread(p);</span><br><span class="line">    call_rcu(&amp;p-&gt;rcu, delayed_put_task_struct);</span><br><span class="line">    p = leader;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(zap_leader))</span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子进程不一定能保证在父进程前边退出，所以必须要有机制来保证子进程在这种情况下能找到一个新的父进程。否则的话，这些成为孤儿的进程就会在退出时永远处于僵死状态，白白的耗费内存。解决这个问题的办法，就是给子进程在当前线程组内找一个线程作为父亲。一旦系统给进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了，<code>init</code>进程会例行调用<code>wait()</code>来等待子进程，清除所有与其相关的僵死进程。</p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>Linux为多任务系统，正常情况下都存在成百上千个任务。由于Linux提供抢占式的多任务模式，所以Linux能同时并发地交互执行多个进程，而调度程序将决定哪一个进程投入运行、何时运行、以及运行多长时间。调度程序是像Linux这样的多任务操作系统的基础，只有通过调度程序的合理调度，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。当系统中可运行的进程数目比处理器的个数多，就注定在某一时刻有一些进程不能执行，这些不能执行的进程在等待执行。调度程序的基本工作就是停止一个进程的运行，再在这些等待执行的进程中选择一个来执行。</p>
<p>调度程序停止一个进程的运行，再选择一个另外进程的动作开始运行的动作被称作抢占（preemption）。一个进程在被抢占之前能够运行的时间是预先设置好的，这个预先设置好的时间就是进程的的时间片（timeslice）。时间片就是分配给每个可运行进程的处理器时间段，它表明进程在被抢占前所能持续运行时间。</p>
<p>处理器的调度策略决定调度程序在何时让什么进程投入运行。调度策略通常需要在进程响应迅速(相应时间短)和进程吞吐量高之间寻找平衡。所以调度程序通常采用一套非常复杂的算法来决定最值得运行的进程投入运行。调度算法中最基本的一类当然就是基于优先级的调度，也就是说优先级高的先运行，相同优先级的按轮转式进行调度。优先级高 的进程使用的时间片也长。调度程序总是选择时间片未用尽且优先级最高的进程运行。这句话就是说用户和系统可以通过设置进程的优先级来响应系统的调度。基于此，Linux设计上一套动态优先级的调度方法。一开始，先为进程设置一个基本的优先级，然而它允许调度程序根据需要来加减优先级。Linux内核提供了两组独立的优先级范围。第一种是<code>nice</code>值，范围从-20到19，默认为0。<code>nice</code>值越大优先级越小。另外<code>nice</code>值也用来决定分配给进程时间片的长短。Linux下通过命令可以查看进程对应<code>nice</code>值，如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ps -el</span><br><span class="line"></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD </span><br><span class="line">4 S     0     1     0  0  80   0 -   725 ?      ?        00:00:01 init </span><br><span class="line">1 S     0     2     0  0  80   0 -     0 ?      ?        00:00:00 kthreadd </span><br><span class="line">1 S     0     3     2  0 -40   - -     0 ?      ?        00:00:01 migration/0 </span><br><span class="line">1 S     0     4     2  0  80   0 -     0 ?      ?        00:00:00 ksoftirqd/0 </span><br><span class="line">1 S     0     9     2  0  80   0 -     0 ?      ?        00:00:00 ksoftirqd/1</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">1 S     0    39     2  0  85   5 -     0 ?      ?        00:00:00 ksmd </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">1 S     0   156     2  0  75  -5 -     0 ?      ?        00:00:00 kslowd000 </span><br><span class="line">1 S     0   157     2  0  75  -5 -     0 ?      ?        00:00:00 kslowd001 </span><br><span class="line">...... </span><br><span class="line">4 S   499  2951     1  0  81   1 -  6276 ?      ?        00:00:00 rtkit-daemon </span><br><span class="line">...... </span><br></pre></td></tr></table></figure><br>第二种范围是实时优先级，默认范围是从0到99。任何实时的优先级都高于普通优先级。</p>
<p>进程执行时，它会根据具体情况改变状态，进程状态是调度和对换的依据。Linux 将进程状态分为五种： <code>TASK_RUNNING</code> 、<code>TASK_INTERRUPTIBLE</code> 、<code>TASK_UNINTERRUPTIBLE</code>、<code>TASK_STOPPED</code>和<code>TASK_ZOMBILE</code>。进程的状态随着进程的调度发生改变 。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>TASK_RUNNING</td>
<td>可运行</td>
</tr>
<tr>
<td>TASK_INTERRUPTIBLE</td>
<td>可中断的等待状态</td>
</tr>
<tr>
<td>TASK_UNINTERRUPTIBLE</td>
<td>不可中断的等待状态</td>
</tr>
<tr>
<td>TASK_STOPPED</td>
<td>停止状态</td>
</tr>
<tr>
<td>TASK_TRACED</td>
<td>被跟踪状态</td>
</tr>
</tbody>
</table>
</div>
<p>TASK_RUNNING （运行）：无论进程是否正在占用 CPU ，只要具备运行条件，都处于该状态。 Linux 把处于该状态的所有 PCB 组织成一个可运行队列 run_queue ，调度程序从这个队列中选择进程运行。事实上，Linux 是将就绪态和运行态合并为了一种状态。</p>
<p>TASK_INTERRUPTIBLE （可中断阻塞）： Linux 将阻塞态划分成 TASK_INTERRUPTIBLE 、 TASK_UNINTERRUPTIBLE 、 TASK_STOPPED 三种不同的状态。处于 TASK_INTERRUPTIBLE 状态的进程在资源有效时被唤醒，也可以通过信号或定时中断唤醒。</p>
<p>TASK_UNINTERRUPTIBLE （不可中断阻塞）：另一种阻塞状态，处于该状态的进程只有当资源有效时被唤醒，不能通过信号或定时中断唤醒。在执行<code>ps</code>命令时，进程状态为<code>D</code>且不能被杀死。</p>
<p>TASK_STOPPED （停止）：第三种阻塞状态，处于该状态的进程只能通过其他进程的信号才能唤醒。</p>
<p>TASK_TRACED （被跟踪）：进程正在被另一个进程监视，比如在调试的时候。</p>
<p>我们在设置这些状态的时候是可以直接用语句进行的比如：<code>p—&gt;state = TASK_RUNNING</code>。同时内核也会使用<code>set_task_state()</code>和<code>set_current_state()</code>函数来进行。</p>
<p>Linux调度器是以模块方式提供的，这样允许不同类型的进程可以有针对性地选择调度算法。完全公平调度（CFS）是针对普通进程的调度类，CFS采用的方法是对时间片分配方式进行根本性的重新设计，完全摒弃时间片而是分配给进程一个处理器使用比重。通过这种方式，CFS确保了进程调度中能有恒定的公平性，而将切换频率置于不断变动之中。</p>
<p>与Linux 2.6之前调度器不同，2.6版本内核的CFS没有将任务维护在链表式的运行队列中，它抛弃了<code>active/expire</code>数组，而是对每个CPU维护一个以时间为顺序的红黑树。该树方法能够良好运行的原因在于：</p>
<ul>
<li>红黑树可以始终保持平衡，这意味着树上没有路径比任何其他路径长两倍以上。</li>
<li>由于红黑树是二叉树，查找操作的时间复杂度为`O(log n)。但是除了最左侧查找以外，很难执行其他查找，并且最左侧的节点指针始终被缓存。</li>
<li>对于大多数操作（插入、删除、查找等），红黑树的执行时间为<code>O(log n)</code>，而以前的调度程序通过具有固定优先级的优先级数组使用<code>O(1)</code>。<code>O(log n)</code>行为具有可测量的延迟，但是对于较大的任务数无关紧要。</li>
<li>红黑树可通过内部存储实现，即不需要使用外部分配即可对数据结构进行维护。</li>
</ul>
<p>要实现平衡，CFS使用“虚拟运行时”表示某个任务的时间量。任务的虚拟运行时越小，意味着任务被允许访问服务器的时间越短，其对处理器的需求越高。CFS还包含睡眠公平概念以便确保那些目前没有运行的任务（例如，等待 I/O）在其最终需要时获得相当份额的处理器。</p>
<p>对于实时进程，Linux 采用了两种调度策略，即先来先服务调度（ First-In, First-Out ， FIFO ）和时间片轮转调度（ Round Robin ， RR ）。因为实时进程具有一定程度的紧迫性，所以衡量一个实时进程是否应该运行，Linux 采用了一个比较固定的标准。</p>
<p>下面是调度相关的一些数据结构：调度实体：<code>struct sched_entity</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>  <span class="title">load</span>;</span>       <span class="comment">/* for load-balancing */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>      <span class="title">run_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">group_node</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        on_rq;</span><br><span class="line"> </span><br><span class="line">    u64         exec_start;</span><br><span class="line">    u64         sum_exec_runtime;</span><br><span class="line">    u64         vruntime;</span><br><span class="line">    u64         prev_sum_exec_runtime;</span><br><span class="line"> </span><br><span class="line">    u64         last_wakeup;</span><br><span class="line">    u64         avg_overlap;</span><br><span class="line"> </span><br><span class="line">    u64         nr_migrations;</span><br><span class="line"> </span><br><span class="line">    u64         start_runtime;</span><br><span class="line">    u64         avg_wakeup;</span><br><span class="line"> </span><br><span class="line">    u64         avg_running;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line">    u64         wait_start;</span><br><span class="line">    u64         wait_max;</span><br><span class="line">    u64         wait_count;</span><br><span class="line">    u64         wait_sum;</span><br><span class="line">    u64         iowait_count;</span><br><span class="line">    u64         iowait_sum;</span><br><span class="line"> </span><br><span class="line">    u64         sleep_start;</span><br><span class="line">    u64         sleep_max;</span><br><span class="line">    s64         sum_sleep_runtime;</span><br><span class="line"> </span><br><span class="line">    u64         block_start;</span><br><span class="line">    u64         block_max;</span><br><span class="line">    u64         exec_max;</span><br><span class="line">    u64         slice_max;</span><br><span class="line"> </span><br><span class="line">    u64         nr_migrations_cold;</span><br><span class="line">    u64         nr_failed_migrations_affine;</span><br><span class="line">    u64         nr_failed_migrations_running;</span><br><span class="line">    u64         nr_failed_migrations_hot;</span><br><span class="line">    u64         nr_forced_migrations;</span><br><span class="line">    u64         nr_forced2_migrations;</span><br><span class="line"> </span><br><span class="line">    u64         nr_wakeups;</span><br><span class="line">    u64         nr_wakeups_sync;</span><br><span class="line">    u64         nr_wakeups_migrate;</span><br><span class="line">    u64         nr_wakeups_local;</span><br><span class="line">    u64         nr_wakeups_remote;</span><br><span class="line">    u64         nr_wakeups_affine;</span><br><span class="line">    u64         nr_wakeups_affine_attempts;</span><br><span class="line">    u64         nr_wakeups_passive;</span><br><span class="line">    u64         nr_wakeups_idle;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">/* rq on which this entity is (to be) queued: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>       *<span class="title">cfs_rq</span>;</span></span><br><span class="line">    <span class="comment">/* rq &quot;owned&quot; by this entity/group: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>       *<span class="title">my_q</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该结构在<code>./linux/include/linux/sched.h</code>中，表示一个可调度实体（进程，进程组，等等）。它包含了完整的调度信息，用于实现对单个任务或任务组的调度。调度实体可能与进程没有关联。这里包括负载权重<code>load</code>、对应的红黑树结点<code>run_node</code>、虚拟运行时<code>vruntime</code>（表示进程的运行时间，并作为红黑树的索引）、开始执行时间、最后唤醒时间、各种统计数据、用于组调度的CFS运行队列信息<code>cfs_rq</code>，等等。</p>
<p>调度类：<code>struct sched_class</code>。该调度类也在<code>sched.h</code>中，是对调度器操作的面向对象抽象，协助内核调度程序的各种工作。调度类是调度器管理器的核心，每种调度算法模块需要实现<code>struct sched_class</code>建议的一组函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> (*enqueue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> wakeup);</span><br><span class="line">    <span class="type">void</span> (*dequeue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> sleep);</span><br><span class="line">    <span class="type">void</span> (*yield_task) (<span class="keyword">struct</span> rq *rq);</span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> (*check_preempt_curr) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * (*<span class="title">pick_next_task</span>) (<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="type">void</span> (*put_prev_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="type">int</span>  (*select_task_rq)(<span class="keyword">struct</span> task_struct *p, <span class="type">int</span> sd_flag, <span class="type">int</span> flags);</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*load_balance)</span> <span class="params">(<span class="keyword">struct</span> rq *this_rq, <span class="type">int</span> this_cpu,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> rq *busiest, <span class="type">unsigned</span> <span class="type">long</span> max_load_move,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> sched_domain *sd, <span class="keyword">enum</span> cpu_idle_type idle,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> *all_pinned, <span class="type">int</span> *this_best_prio)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> (*move_one_task) (<span class="keyword">struct</span> rq *this_rq, <span class="type">int</span> this_cpu,</span><br><span class="line">                  <span class="keyword">struct</span> rq *busiest, <span class="keyword">struct</span> sched_domain *sd,</span><br><span class="line">                  <span class="keyword">enum</span> cpu_idle_type idle);</span><br><span class="line">    <span class="type">void</span> (*pre_schedule) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line">    <span class="type">void</span> (*post_schedule) (<span class="keyword">struct</span> rq *this_rq);</span><br><span class="line">    <span class="type">void</span> (*task_wake_up) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> (*set_cpus_allowed)(<span class="keyword">struct</span> task_struct *p,</span><br><span class="line">                 <span class="type">const</span> <span class="keyword">struct</span> cpumask *newmask);</span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> (*rq_online)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line">    <span class="type">void</span> (*rq_offline)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> (*set_curr_task) (<span class="keyword">struct</span> rq *rq);</span><br><span class="line">    <span class="type">void</span> (*task_tick) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> queued);</span><br><span class="line">    <span class="type">void</span> (*task_new) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p);</span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> (*switched_from) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task,</span><br><span class="line">                   <span class="type">int</span> running);</span><br><span class="line">    <span class="type">void</span> (*switched_to) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task,</span><br><span class="line">                 <span class="type">int</span> running);</span><br><span class="line">    <span class="type">void</span> (*prio_changed) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task,</span><br><span class="line">                 <span class="type">int</span> oldprio, <span class="type">int</span> running);</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*get_rr_interval)</span> <span class="params">(<span class="keyword">struct</span> task_struct *task)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="type">void</span> (*moved_group) (<span class="keyword">struct</span> task_struct *p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>其中的主要函数：</p>
<ul>
<li><code>enqueue_task</code>：当某个任务进入可运行状态时，该函数将得到调用。它将调度实体（进程）放入红黑树中，并对<code>nr_running</code>变量加 1。从前面“Linux进程管理”的分析中可知，进程创建的最后会调用该函数。</li>
<li><code>dequeue_task</code>：当某个任务退出可运行状态时调用该函数，它将从红黑树中去掉对应的调度实体，并从<code>nr_running</code>变量中减 1。</li>
<li><code>yield_task</code>：在<code>compat_yield sysctl</code>关闭的情况下，该函数实际上执行先出队后入队；在这种情况下，它将调度实体放在红黑树的最右端。</li>
<li><code>check_preempt_curr</code>：该函数将检查当前运行的任务是否被抢占。在实际抢占正在运行的任务之前，CFS 调度程序模块将执行公平性测试。这将驱动唤醒式（wakeup）抢占。</li>
<li><code>pick_next_task</code>：该函数选择接下来要运行的最合适的进程。</li>
<li><code>load_balance</code>：每个调度程序模块实现两个函数，<code>load_balance_start()</code>和<code>load_balance_next()</code>，使用这两个函数实现一个迭代器，在模块的<code>load_balance</code>例程中调用。内核调度程序使用这种方法实现由调度模块管理的进程的负载平衡。</li>
<li><code>set_curr_task</code>：当任务修改其调度类或修改其任务组时，将调用这个函数。</li>
<li><code>task_tick</code>：该函数通常调用自 time tick 函数；它可能引起进程切换。这将驱动运行时（running）抢占。</li>
</ul>
<p>调度类的引入是接口和实现分离的设计典范，你可以实现不同的调度算法（例如普通进程和实时进程的调度算法就不一样），但由于有统一的接口，使得调度策略 被模块化，一个Linux调度程序可以有多个不同的调度策略。调度类显著增强了内核调度程序的可扩展性。每个任务都属于一个调度类，这决定了任务将如何调 度。 调度类定义一个通用函数集，函数集定义调度器的行为。例如，每个调度器提供一种方式，添加要调度的任务、调出要运行的下一个任务、提供给调度器等等。每个 调度器类都在一对一连接的列表中彼此相连，使类可以迭代（例如，要启用给定处理器的禁用）。注意，将任务函数加入队列或脱离队列只需从特定调度结构中加入或移除任务。 核心函数 pick_next_task 选择要执行的下一个任务（取决于调度类的具体策略）。</p>
<p><code>sched_rt.c</code>，<code>sched_fair.c</code>，<code>sched_idletask.c</code>等（都在<code>kernel/</code>目录下）就是不同的调度算法实现。不要忘了调度类是任务结构本身的一部分（参见 task_struct）。这一点简化了任务的操作，无论其调度类如何。因为进程描述符中有<code>sched_class</code>引用，这样就可以直接通过进程描述符来 调用调度类中的各种操作。在调度类中，随着调度域的增加，其功能也在增加。 这些域允许您出于负载平衡和隔离的目的将一个或多个处理器按层次关系分组。 一个或多个处理器能够共享调度策略（并在其之间保持负载平衡），或实现独立的调度策略。</p>
<p>可运行队列：<code>struct rq</code>。调度程序每次在进程发生切换时，都要从可运行队列中选取一个最佳的进程来运行。Linux内核使用<code>rq</code>数据结构（以前的内核中该结构为 runqueue）表示一个可运行队列信息（也就是就绪队列），每个CPU都有且只有一个这样的结构。该结构在<code>kernel/sched.c</code>中，不仅描述了每个处理器中处于可运行状态（<code>TASK_RUNNING</code>），而且还描述了该处理器的调度信息。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line">    <span class="comment">/* runqueue lock: */</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_running;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CPU_LOAD_IDX_MAX 5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cpu_load[CPU_LOAD_IDX_MAX];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* capture load from *all* tasks on this cpu: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_load_updates;</span><br><span class="line">    u64 nr_switches;</span><br><span class="line">    u64 nr_migrations_in;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> <span class="title">cfs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> <span class="title">rt</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_uninterruptible;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span>, *<span class="title">idle</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> next_balance;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">prev_mm</span>;</span></span><br><span class="line"> </span><br><span class="line">    u64 clock;</span><br><span class="line"> </span><br><span class="line">    <span class="type">atomic_t</span> nr_iowait;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* calc_load related fields */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> calc_load_update;</span><br><span class="line">    <span class="type">long</span> calc_load_active;</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>进程调度的入口点是函数<code>schedule()</code>，该函数调用<code>pick_next_task()</code>，<code>pick_next_task()</code>会以优先级为序，从高到低，一次检查每一个调度类，且从最高优先级的调度类中，选择最高优先级的进程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __sched <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *switch_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line"> </span><br><span class="line">need_resched:</span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">	rcu_sched_qs(cpu);</span><br><span class="line">	prev = rq-&gt;curr;</span><br><span class="line">	switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line"> </span><br><span class="line">	release_kernel_lock(prev);</span><br><span class="line">need_resched_nonpreemptible:</span><br><span class="line"> </span><br><span class="line">	schedule_debug(prev);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (sched_feat(HRTICK))</span><br><span class="line">		hrtick_clear(rq);</span><br><span class="line"> </span><br><span class="line">	spin_lock_irq(&amp;rq-&gt;lock);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (prev-&gt;state &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal_pending_state(prev-&gt;state, prev)))</span><br><span class="line">			prev-&gt;state = TASK_RUNNING;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			deactivate_task(rq, prev, <span class="number">1</span>);</span><br><span class="line">		switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	pre_schedule(rq, prev);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (unlikely(!rq-&gt;nr_running))</span><br><span class="line">		idle_balance(cpu, rq);</span><br><span class="line"> </span><br><span class="line">	put_prev_task(rq, prev);</span><br><span class="line">	&lt;strong&gt;next = pick_next_task(rq);    <span class="comment">//&lt;span&gt;&lt;span&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;//挑选最高优先级别的任务&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		sched_info_switch(prev, next);</span><br><span class="line">		perf_event_task_sched_out(prev, next, cpu);</span><br><span class="line"> </span><br><span class="line">		rq-&gt;nr_switches++;</span><br><span class="line">		rq-&gt;curr = next;</span><br><span class="line">		++*switch_count;</span><br><span class="line"> </span><br><span class="line">		context_switch(rq, prev, next); <span class="comment">/* unlocks the rq */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * the context switch might have flipped the stack from under</span></span><br><span class="line"><span class="comment">		 * us, hence refresh the local variables.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		cpu = smp_processor_id();</span><br><span class="line">		rq = cpu_rq(cpu);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		spin_unlock_irq(&amp;rq-&gt;lock);</span><br><span class="line"> </span><br><span class="line">	post_schedule(rq);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (unlikely(reacquire_kernel_lock(current) &lt; <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">goto</span> need_resched_nonpreemptible;</span><br><span class="line"> </span><br><span class="line">	preempt_enable_no_resched();</span><br><span class="line">	<span class="keyword">if</span> (need_resched())</span><br><span class="line">		<span class="keyword">goto</span> need_resched;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *</span><br><span class="line"><span class="title function_">pick_next_task</span><span class="params">(<span class="keyword">struct</span> rq *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Optimization: we know that if all tasks are in</span></span><br><span class="line"><span class="comment">	 * the fair class we can call that function directly:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(rq-&gt;nr_running == rq-&gt;cfs.nr_running)) &#123;</span><br><span class="line">		p = fair_sched_class.pick_next_task(rq);</span><br><span class="line">		<span class="keyword">if</span> (likely(p))</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//从最高优先级类开始，遍历每一个调度类。每一个调度类都实现了pick_next_task，他会返回指向下一个可运行进程的指针，没有时返回NULL。</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> =</span> sched_class_highest;</span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		p = class-&gt;pick_next_task(rq);</span><br><span class="line">		<span class="keyword">if</span> (p)</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Will never be NULL as the idle class always</span></span><br><span class="line"><span class="comment">		 * returns a non-NULL p:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> =</span> <span class="class"><span class="keyword">class</span>-&gt;</span>next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>被阻塞（休眠）的进程处于不可执行状态，是不能被调度的。进程休眠一般是由于等待一些事件，内核首先把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用<code>schedule()</code>选择和执行一个其他进程。唤醒的过程刚好相反，进程设置为可执行状态，然后从等待队列中移到可执行红黑树中。    </p>
<p>等待队列是由等待某些事件发生的进程组成的简单链表。内核用<code>wake_queue_head_t</code>来代表队列。进程把自己放入等待队列中并设置成不可执状态。当等待队列相关事件发生时，队列上进程会被唤醒。函数<code>inotify_read()</code>是实现等待队列的一个典型用法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">inotify_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">                <span class="type">size_t</span> count, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_group</span> *<span class="title">group</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_event</span> *<span class="title">kevent</span>;</span></span><br><span class="line">    <span class="type">char</span> __user *start;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    DEFINE_WAIT(wait);</span><br><span class="line"> </span><br><span class="line">    start = buf;</span><br><span class="line">    group = file-&gt;private_data;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//进程的状态变更为`TASK_INTERRUPTIBLE`或`TASK_UNINTERRUPTIBLE。</span></span><br><span class="line">        prepare_to_wait(&amp;group-&gt;notification_waitq, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line"> </span><br><span class="line">        mutex_lock(&amp;group-&gt;notification_mutex);</span><br><span class="line">        kevent = get_one_event(group, count);</span><br><span class="line">        mutex_unlock(&amp;group-&gt;notification_mutex);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (kevent) &#123;</span><br><span class="line">            ret = PTR_ERR(kevent);</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(kevent))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ret = copy_event_to_user(group, kevent, buf);</span><br><span class="line">            fsnotify_put_event(kevent);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            buf += ret;</span><br><span class="line">            count -= ret;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ret = -EAGAIN;</span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ret = -EINTR;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (start != buf)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    finish_wait(&amp;group-&gt;notification_waitq, &amp;wait);</span><br><span class="line">    <span class="keyword">if</span> (start != buf &amp;&amp; ret != -EFAULT)</span><br><span class="line">        ret = buf - start;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>唤醒是通过<code>wake_up()</code>进行。她唤醒指定的等待队列上 的所有进程。它调用<code>try_to_wake_up</code>，该函数负责将进程设置为<code>TASK_RUNNING</code>状态，调用<code>active_task()</code>将此进程放入可 执行队列，如果被唤醒进程的优先级比当前正在执行的进程的优先级高，还要设置<code>need_resched</code>标志。</p>
<p>上下文切换，就是从一个可执行进程切换到另一个可执行进程，由定义在<code>kernel/sched.c</code>的<code>context_switch</code>函数负责处理。每当一个新的进程被选出来准备投入运行的时候，schedule`就会调用该函数。它主要完成如下两个工作：</p>
<ol>
<li>调用定义在<code>include/asm/mmu_context.h</code>中的<code>switch_mm()</code>。该函数负责把虚拟内存从上一个进程映射切换到新进程中。</li>
<li>调用定义在<code>include/asm/system.h</code>的<code>switch_to()</code>，该函数负责从上一个进程的处理器状态切换到新进程的处理器状态，这包括保存，恢复栈信息和寄存器信息。</li>
</ol>
<p>内核也必须知道什么时候调用<code>schedule()</code>，单靠用户代码显示调用<code>schedule()</code>，他们可能就会永远地执行下去，相反，内核提供了一个<code>need_resched</code>标志来表明是否需要重新执行一次调度。当 某个进程耗尽它的时间片时，<code>scheduler_tick()</code>就会设置这个标志，当一个优先级高的进程进入可执行状态的时候，<code>try_to_wake_up()</code>也会设置这个标志。内核检查该标志，确认其被设置，调用<code>schedule()</code>来切换到一个新的进程。该标志对内核来讲是一个信息，它表示应当有其他进程应当被运行了。</p>
<p>用于访问和操作<code>need_resched</code>的函数：</p>
<ul>
<li><code>set_tsk_need_resched(task)</code>：设置指定进程中的<code>need_resched</code>标志</li>
<li><code>clear_tsk_need_resched(task)</code>：清除指定进程中的<code>nedd_resched</code>标志</li>
<li><code>need_resched()</code>：检查<code>need_resched</code>标志的值，如果被设置就返回真，否则返回</li>
</ul>
<p>在返回用户空间以及从中断返回的时候，内核也会检查<code>need_resched</code>标志，如果已被设置，内核会在继续执行之前调用该调度程序。最后，每个进程都包含一个<code>need_resched</code>标志，这是因为访 问进程描述符内的数值要比访问一个全局变量要快(因为<code>current</code>宏速度很快并且描述符通常都在高速缓存中)。在2.6内核中，他被移到了<code>thread_info</code>结构体里。</p>
<p>用户抢占发生在：</p>
<ol>
<li>从系统调用返回时；</li>
<li>从终端处理程序返回用户空间时。</li>
</ol>
<p>内核抢占发生在:</p>
<ol>
<li>中断处理正在执行，且返回内核空间前；</li>
<li>内核代码再一次具有可抢占性的时候；</li>
<li>内核任务显式调用<code>schedule()</code>函数；</li>
<li>内核中的任务阻塞的时候。</li>
</ol>
<h1 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h1><p>如同Linux应用一样，内核的共享资源也要防止并发，因为如果多个执行线程同时访问和操作数据有可能发生各个线程之间相互覆盖共享数据的情况。</p>
<p>在Linux只是单一处理器的时候，只有在中断发生或内核请求重新调度执行另一个任务时，数据才可能会并发访问。但自从内核开始支持对称多处理器之后，内核代码可以同时运行在多个处理器上，如果此时不加保护，运行在多个处理器上的代码完全可能在同一时刻并发访问共享数据。</p>
<p>一般把访问和操作共享数据的代码段称作临界区，为了避免在临界区中发生并发访问，程序员必须保证临界区代码原子执行，也就是要么全部执行，要么不执行。如果两个执行线程在同一个临界区同时执行，就发生了竞态（race conditions），避免并发防止竞态就是所谓的同步。</p>
<p>在Linux内核中造成并发的原因主要有如下:</p>
<ul>
<li>中断 — 中断几乎可以在任何时刻异步发生，也就可能随时打断当前正在执行的代码。</li>
<li>软中断和<code>tasklet</code> — 内核能在任何时刻唤醒或调度软中断和<code>tasklet</code>，打断当前正在执行的代码。</li>
<li>内核抢占 — 因为内核具有抢占性，所以内核中的任务可能会被另一任务抢占。</li>
<li>睡眠及与用户空间的同步 — 在内核执行的进程可能会睡眠，这就会唤醒调度程序，从而导致调度一个新的用户进程执行。</li>
<li>对称多处理 —  两个或多个处理器可以同时执行代码。（真并发）</li>
</ul>
<p>通过锁可以防止并发执行，并且保护临界区不受竞态影响。任何执行线程要访问临界区代码时首先先获得锁，这样当后面另外的执行线程要访问临界区时就不能再获得该锁，这样临界区就禁止后来执行线程访问。Linux自身实现了多种不同的锁机制，各种锁各有差别，区别主要在于当锁被争用时，有些会简单地执行等待，而有些锁会使当前任务睡眠直到锁可用为止。本节将会分析各锁的使用和实现。但是使用锁也会带来副作用，锁使得线程按串行方式对资源进行访问，所以使用锁无疑会降低系统性能；并且锁使用不当还会造成死锁。</p>
<p>下面来看一下Linux下同步的方法，包括原子操作、自旋锁、信号量等方式。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>该操作是其它同步方法的基础，原子操作可以保证指令以原子的方式执行，执行过程不会被打断。Linux内核提供了两组原子操作接口：原子整数操作和原子位操作。</p>
<p>针对整数的原子操作只能对<code>atomic_t</code>类型的数据进行处理。该类类型定义与文件<code>&lt;include/linux/types.h&gt;</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> counter;</span><br><span class="line">&#125; <span class="type">atomic_t</span>;</span><br></pre></td></tr></table></figure><br>下面举例说明原子操作的用法：<br>定义一个<code>atomic_c</code>类型的数据很简单，还可以定义时给它设定初值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_t</span> u;</span><br><span class="line">     </span><br><span class="line"><span class="comment">/* 定义 u */</span></span><br><span class="line"><span class="type">atomic_t</span> v = ATOMIC_INIT(<span class="number">0</span>)     <span class="comment">/*定义 v 并把它初始化为0*/</span></span><br></pre></td></tr></table></figure></p>
<p>对其操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_set</span>(&amp;v,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* v = 4 ( 原子地)*/</span></span><br><span class="line"><span class="type">atomic_add</span>(<span class="number">2</span>,&amp;v)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* v = v + 2 = 6 (原子地) */</span></span><br><span class="line"><span class="type">atomic_inc</span>(&amp;v)</span><br><span class="line">   </span><br><span class="line"><span class="comment">/* v = v + 1 =7（原子地)*/</span></span><br></pre></td></tr></table></figure></p>
<p>如果需要将<code>atomic_t</code>转换成<code>int</code>型，可以使用<code>atomic_read()</code>来完成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(<span class="string">&quot;%d\n&quot;</span>, <span class="type">atomic_read</span>(&amp;v));    <span class="comment">/* 会打印7*/</span></span><br></pre></td></tr></table></figure></p>
<p>原子整数操作最常见的用途就是实现计数器。使用复杂的锁机制来保护一个单纯的计数器是很笨拙的，所以，开发者最好使用<code>atomic_inc()</code>和<code>atomic_dec()</code>这两个相对来说轻便一点的操作。</p>
<p>还可以用原子整数操作原子地执行一个操作并检查结果。一个常见的例子是原子的减操作和检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atomic_dec_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span></span><br></pre></td></tr></table></figure></p>
<p>这个函数让给定的原子变量减1，如果结果为0，就返回1；否则返回0。特定体系结构的所有原子整数操作可以在文件<code>&lt;arch/x86/include/asm/atomic.h&gt;</code>中找到。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_ATOMIC_32_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_ATOMIC_32_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/compiler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/processor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/cmpxchg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_INIT(i)    &#123; (i) &#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">atomic_read</span><span class="params">(<span class="type">const</span> <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> v-&gt;counter;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_set</span><span class="params">(<span class="type">atomic_t</span> *v, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    v-&gt;counter = i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_add</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;addl %1,%0&quot;</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span></span><br><span class="line"><span class="params">             : <span class="string">&quot;ir&quot;</span> (i))</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_sub</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;subl %1,%0&quot;</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span></span><br><span class="line"><span class="params">             : <span class="string">&quot;ir&quot;</span> (i))</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">atomic_sub_and_test</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;subl %2,%0; sete %1&quot;</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;+m&quot;</span> (v-&gt;counter), <span class="string">&quot;=qm&quot;</span> (c)</span></span><br><span class="line"><span class="params">             : <span class="string">&quot;ir&quot;</span> (i) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>除了原子整数之外，内核还提供了一组针对位操作的函数，这些操作也是和体系结构相关的。例如在x86下<code>set_bit</code>实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">set_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr, <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IS_IMMEDIATE(nr)) &#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;orb %1,%0&quot;</span></span></span><br><span class="line"><span class="params">            : CONST_MASK_ADDR(nr, addr)</span></span><br><span class="line"><span class="params">            : <span class="string">&quot;iq&quot;</span> ((u8)CONST_MASK(nr))</span></span><br><span class="line"><span class="params">            : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="keyword">volatile</span>(LOCK_PREFIX <span class="string">&quot;bts %1,%0&quot;</span></span><br><span class="line">            : BITOP_ADDR(addr) : <span class="string">&quot;Ir&quot;</span> (nr) : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>原子操作是对普通内存地址指针进行的操作，只要指针指向了任何你希望的数据，你就可以对它进行操作。原子位操作(以x86为例)相关函数定义在文件<code>&lt;arch/x86/include/asm/bitops.h&gt;</code>中。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>不是所有的临界区都是像增加或减少变量这么简单，有的时候临界区可能会跨越多个函数，这这时就需要使用更为复杂的同步方法——锁。Linux内核中最常见的锁是自旋锁，自旋锁最多只能被一个可执行线程持有，如果一个可执行线程视图获取一个已经被持有的锁，那么该线程将会一直进行忙循环等待锁重新可用。在任意时候，自旋锁都可以防止多余一个执行线程同时进入临界区。由于自旋忙等过程是很费时间的，所以自旋锁不应该被长时间持有。</p>
<p>自旋锁相关方法如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>spinlock中的定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义<code>spin lock</code>并初始化</td>
<td>DEFINE_SPINLOCK()</td>
</tr>
<tr>
<td>动态初始化<code>spin lock</code></td>
<td>spin_lock_init()</td>
</tr>
<tr>
<td>获取指定的<code>spin lock</code></td>
<td>spin_lock()</td>
</tr>
<tr>
<td>获取指定的<code>spin lock</code>同时<code>disable</code>本CPU中断</td>
<td>spin_lock_irq()</td>
</tr>
<tr>
<td>保存本CPU当前的<code>irq</code>状态，disable本CPU中断并获取指定的<code>spin lock</code></td>
<td>spin_lock_irqsave()</td>
</tr>
<tr>
<td>获取指定的<code>spin lock</code>同时disable本CPU的`bottom half</td>
<td>spin_lock_bh()</td>
</tr>
<tr>
<td>释放指定的<code>spin lock</code></td>
<td>spin_unlock()</td>
</tr>
<tr>
<td>释放指定的<code>spin lock</code>同时enable本CPU中断</td>
<td>spin_lock_irq()</td>
</tr>
<tr>
<td>释放指定的<code>spin lock</code>同时恢复本CPU的中断状态</td>
<td>spin_lock_irqsave()</td>
</tr>
<tr>
<td>获取指定的<code>spin lock</code>同时enable本CPU的bottom half</td>
<td>spin_unlock_bh()</td>
</tr>
<tr>
<td>尝试去获取<code>spin lock</code>，如果失败，不会spin，而是返回非零值</td>
<td>spin_trylock()</td>
</tr>
<tr>
<td>判断<code>spin lock</code>是否是locked，如果其他的thread已经获取了该lock，那么返回非零值，否则返回0</td>
<td>spin_is_locked()</td>
</tr>
</tbody>
</table>
</div>
<p>自旋锁的实现和体系结构密切相关，代码通常通过汇编实现。与体系结构相关的部分定义在<code>&lt;asm/spinlock.h&gt;</code>,实际需要用到的接口定义在文件<code>&lt;linux/spinlock.h&gt;</code>中。一个实际的锁的类型为<code>spinlock_t</code>，定义在文件<code>&lt;include/linux/spinlock_types.h&gt;</code>中:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_LOCKBREAK</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> break_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> magic, owner_cpu;</span><br><span class="line">    <span class="type">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br></pre></td></tr></table></figure><br>自旋锁基本使用形式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SPINLOCK(lock);</span><br><span class="line">spin_lock(&amp;lock);</span><br><span class="line"><span class="comment">/* 临界区 */</span></span><br><span class="line">spin_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><br>实际上有 4 个函数可以加锁一个自旋锁:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock_irq</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;    <span class="comment">//相当于`spin_lock() + local_irq_disable()。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock_irqsave</span><span class="params">(<span class="type">spinlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="comment">//禁止中断(只在本地处理器)在获得自旋锁之前; 之前的中断状态保存在flags里。相当于spin_lock() + local_irq_save()。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock_bh</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;    <span class="comment">//获取锁之前禁止软件中断，但是硬件中断留作打开的，相当于spin_lock() + local_bh_disable()。</span></span><br></pre></td></tr></table></figure></p>
<p>也有 4 个方法来释放一个自旋锁; 你用的那个必须对应你用来获取锁的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock_irqrestore</span><span class="params">(<span class="type">spinlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock_irq</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock_bh</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure><br>下面看一下<code>DEFINE_SPINLOCK()</code>、<code>spin_lock_init()</code>、<code>spin_lock()</code>、<code>spin_lock_irqsave()</code>的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_SPINLOCK(x)    spinlock_t x = __SPIN_LOCK_UNLOCKED(x)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> spin_lock_init(lock)                    \</span></span><br><span class="line"><span class="meta">    do &#123; *(lock) = SPIN_LOCK_UNLOCKED; &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>spin_lock:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> spin_lock(lock)            _spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __lockfunc _spin_lock(<span class="type">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    __spin_lock(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __spin_lock(<span class="type">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    preempt_disable();</span><br><span class="line">    spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">    LOCK_CONTENDED(lock, _raw_spin_trylock, _raw_spin_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>spin_lock_irqsave:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> spin_lock_irqsave(lock, flags)            \</span></span><br><span class="line"><span class="meta">    do &#123;                        \</span></span><br><span class="line"><span class="meta">        typecheck(unsigned long, flags);    \</span></span><br><span class="line"><span class="meta">        flags = _spin_lock_irqsave(lock);    \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __lockfunc _spin_lock_irqsave(<span class="type">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __spin_lock_irqsave(lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __spin_lock_irqsave(<span class="type">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line">    local_irq_save(flags);    <span class="comment">//spin_lock的实现没有禁止本地中断这一步</span></span><br><span class="line">    preempt_disable();</span><br><span class="line">    spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    LOCK_CONTENDED(lock, _raw_spin_trylock, _raw_spin_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    _raw_spin_lock_flags(lock, &amp;flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>读写自旋锁一种比自旋锁粒度更小的锁机制，它保留了“自旋”的概念，但是在写操作方面，只能最多有1个写进程，在读操作方面，同时可以有多个读执行单元。当然，读和写也不能同时进行。读者写者锁有一个类型<code>rwlock_t</code>，在<code>&lt;linux/spinlokc.h&gt;</code>中定义。 它们可以以 2 种方式被声明和被初始化:<br>静态方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rwlock_t</span> my_rwlock = RW_LOCK_UNLOCKED;</span><br></pre></td></tr></table></figure><br>动态方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rwlock_t</span> my_rwlock;</span><br><span class="line">rwlock_init(&amp;my_rwlock);</span><br></pre></td></tr></table></figure><br>可用函数的列表现在应当看来相当类似。 对于读者，有下列函数可用:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_lock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_lock_irqsave</span><span class="params">(<span class="type">rwlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_lock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_lock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock_irqrestore</span><span class="params">(<span class="type">rwlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure></p>
<p>对于写存取的函数是类似的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_lock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_lock_irqsave</span><span class="params">(<span class="type">rwlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_lock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_lock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write_trylock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock_irqrestore</span><span class="params">(<span class="type">rwlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure><br>在与下半部配合使用时，锁机制必须要小心使用。由于下半部可以抢占进程上下文的代码，所以当下半部和进程上下文共享数据时，必须对进程上下文的共享数据进行保护，所以需要加锁的同时还要禁止下半部执行。同样的，由于中断处理器可以抢占下半部，所以如果中断处理器程序和下半部共享数据，那么就必须在获取恰当的锁的同时还要禁止中断。 同类的<code>tasklet</code>不可能同时运行，所以对于同类<code>tasklet</code>中的共享数据不需要保护，但是当数据被两个不同种类的<code>tasklet</code>共享时，就需要在访问下半部中的数据前先获得一个普通的自旋锁。由于同种类型的两个软中断也可以同时运行在一个系统的多个处理器上，所以被软中断共享的数据必须得到锁的保护。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>一个被占有的自旋锁使得请求它的线程循环等待而不会睡眠，这很浪费处理器时间，所以自旋锁使用段时间占有的情况。Linux提供另外的同步方式可以在锁争用时让请求线程睡眠，直到锁重新可用时在唤醒它，这样处理器就不必循环等待，可以去执行其它代码。这种方式就是即将讨论的信号量。</p>
<p>信号量是一种睡眠锁，如果有一个任务试图获得一个已经被占用的信号量时，信号量会将其放入一个等待队列，然后睡眠。当持有的信号量被释放后，处于等待队列中的那个任务将被唤醒，并获得信号量。信号量比自旋锁提供了更好的处理器利用率，因为没有把时间花费在忙等带上。但是信号量也会有一定的开销，被阻塞的线程换入换出有两次明显的上下文切换，这样的开销比自旋锁要大的多。</p>
<p>如果需要在自旋锁和信号量中做出选择，应该根据锁被持有的时间长短做判断，如果加锁时间不长并且代码不会休眠，利用自旋锁是最佳选择。相反，如果加锁时间可能很长或者代码在持有锁有可能睡眠，那么最好使用信号量来完成加锁功能。信号量一个有用特性就是它可以同时允许任意数量的锁持有者，而自旋锁在一个时刻最多允许一个任务持有它。信号量同时允许的持有者数量可以在声明信号量时指定，当为1时，成为互斥信号量，否则成为计数信号量。</p>
<p>信号量的实现与体系结构相关，信号量使用<code>struct semaphore</code>类型用来表示信号量，定义于文件<code>&lt;include/linux/semaphore.h&gt;</code>中:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">     <span class="type">spinlock_t</span>        lock;</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span>        count;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>信号量初始化方法有如下:</p>
<p>方法一:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span>  </span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span>;<span class="comment">//初始化信号量，并设置信号量 sem 的值为 val。 </span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span></span><br><span class="line">	*sem = (<span class="keyword">struct</span> semaphore) __SEMAPHORE_INITIALIZER(*sem, val);</span><br><span class="line">	lockdep_init_map(&amp;sem-&gt;lock.dep_map, <span class="string">&quot;semaphore-&gt;lock&quot;</span>, &amp;__key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_MUTEX(name);</span><br></pre></td></tr></table></figure><br>定义一个名为 name 的信号量并初始化为1。<br>其实现为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_MUTEX(name)    \</span></span><br><span class="line"><span class="meta">    struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)</span></span><br></pre></td></tr></table></figure></p>
<p>方法三:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> init_MUTEX(sem)        sema_init(sem, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以不加锁状态动态创建信号量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> init_MUTEX_LOCKED(sem)    sema_init(sem, 0)    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以加锁状态动态创建信号量 </span></span><br></pre></td></tr></table></figure><br>信号量初始化后就可以使用了，使用信号量主要有如下方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore * sem)</span>;</span><br><span class="line"><span class="comment">//该函数用于获得信号量 sem，它会导致睡眠，因此不能在中断上下文使用;  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_interruptible</span><span class="params">(<span class="keyword">struct</span> semaphore * sem)</span>;</span><br><span class="line"><span class="comment">//该函数功能与 down 类似，不同之处为，因为 down()而进入睡眠状态的进程不能被信号打断，但因为 down_interruptible()而进入睡眠状态的进程能被信号打断，信号也会导致该函数返回，这时候函数的返回值非 0;  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_trylock</span><span class="params">(<span class="keyword">struct</span> semaphore * sem)</span>;</span><br><span class="line"><span class="comment">//该函数尝试获得信号量`sem，如果能够立刻获得，它就获得该信号量并返回0， 否则，返回非0值。它不会导致调用者睡眠，可以在中断上下文使用。</span></span><br><span class="line"></span><br><span class="line">up(<span class="keyword">struct</span> semaphore * sem); </span><br><span class="line"><span class="comment">//释放指定信号量，如果睡眠队列不空，则唤醒其中一个队列。</span></span><br></pre></td></tr></table></figure></p>
<p>信号量一般这样使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义信号量  </span></span><br><span class="line"><span class="comment">DECLARE_MUTEX(mount_sem);  </span></span><br><span class="line"><span class="comment">//down(&amp;mount_sem);/* 获取信号量，保护临界区，信号量被占用之后进入不可中断睡眠状态</span></span><br><span class="line"><span class="comment">down_interruptible(&amp;mount_sem);/* 获取信号量，保护临界区，信号量被占用之后进入不可中断睡眠状态</span></span><br><span class="line"><span class="comment">. . .  </span></span><br><span class="line"><span class="comment">critical section /* 临界区  </span></span><br><span class="line"><span class="comment">. . .  </span></span><br><span class="line"><span class="comment">up(&amp;mount_sem);/* 释放信号量  </span></span><br></pre></td></tr></table></figure><br>下面看一下这些函数的实现：</p>
<p>down():<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line">    spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">        sem-&gt;count--;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __down(sem);</span><br><span class="line">    spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __down(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    __down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>down_interruptible():<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">down_interruptible</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">        sem-&gt;count--;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = __down_interruptible(sem);</span><br><span class="line">    spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> noinline <span class="type">int</span> __sched __down_interruptible(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>down_trylock():<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">down_trylock</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line">    spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">    count = sem-&gt;count - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (likely(count &gt;= <span class="number">0</span>))</span><br><span class="line">        sem-&gt;count = count;</span><br><span class="line">    spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (count &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>up():<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line">    spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (likely(list_empty(&amp;sem-&gt;wait_list)))</span><br><span class="line">        sem-&gt;count++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __up(sem);</span><br><span class="line">    spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __up(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> *<span class="title">waiter</span> =</span> list_first_entry(&amp;sem-&gt;wait_list,</span><br><span class="line">                        <span class="keyword">struct</span> semaphore_waiter, <span class="built_in">list</span>);</span><br><span class="line">    list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">    waiter-&gt;up = <span class="number">1</span>;</span><br><span class="line">    wake_up_process(waiter-&gt;task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正如自旋锁一样，信号量也有区分读写访问的可能，读写信号量在内核中使用<code>rw_semaphore</code>结构表示，x86体系结构定义在<code>&lt;arch/x86/include/asm/rwsem.h&gt;</code>文件中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span>        count;</span><br><span class="line">    <span class="type">spinlock_t</span>        wait_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>读写信号量的使用方法和信号量类似，其操作函数有如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_RWSEM(name)  <span class="comment">//声明名为name的读写信号量，并初始化它。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_rwsem</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;  <span class="comment">//对读写信号量`sem`进行初始化。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down_read</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;   <span class="comment">//读者用来获取`sem，若没获得时，则调用者睡眠等待。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up_read</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;     <span class="comment">//读者释放`sem。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_read_trylock</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>; <span class="comment">//读者尝试获取sem，如果获得返回1，如果没有获得返回0。可在中断上下文使用。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down_write</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;  <span class="comment">//写者用来获取`sem，若没获得时，则调用者睡眠等待。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_write_trylock</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;   <span class="comment">//写者尝试获取sem，如果获得返回1，如果没有获得返回0。可在中断上下文使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up_write</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;    <span class="comment">//写者释放sem。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">downgrade_write</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>; <span class="comment">//把写者降级为读者。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h2><p>除了信号量之外，内核拥有一个更简单的且可睡眠的锁，那就是互斥体。互斥体的行为和计数是1的信号量类似，其接口简单，实现更高效。 互斥体在内核中使用<code>mutex</code>表示，定义于<code>&lt;include/linux/mutex.h&gt;</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line">    <span class="type">atomic_t</span>        count;</span><br><span class="line">    <span class="type">spinlock_t</span>        wait_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>静态定义<code>mutex</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_MUTEX(name);</span><br></pre></td></tr></table></figure><br>实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_MUTEX(mutexname) \</span></span><br><span class="line"><span class="meta">    struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MUTEX_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">        &#123; .count = ATOMIC_INIT(1) \</span></span><br><span class="line"><span class="meta">        , .wait_lock = __SPIN_LOCK_UNLOCKED(lockname.wait_lock) \</span></span><br><span class="line"><span class="meta">        , .wait_list = LIST_HEAD_INIT(lockname.wait_list) \</span></span><br><span class="line"><span class="meta">        __DEBUG_MUTEX_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">        __DEP_MAP_MUTEX_INITIALIZER(lockname) &#125;</span></span><br></pre></td></tr></table></figure><br>动态定义<code>mutex</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mutex_init(&amp;mutex);</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> mutex_init(mutex) \</span></span><br><span class="line"><span class="meta">do &#123;                            \</span></span><br><span class="line"><span class="meta">    static struct lock_class_key __key;        \</span></span><br><span class="line"><span class="meta">                            \</span></span><br><span class="line"><span class="meta">    __mutex_init((mutex), #mutex, &amp;__key);        \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span></span><br><span class="line">__mutex_init(<span class="keyword">struct</span> mutex *lock, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">atomic_set</span>(&amp;lock-&gt;count, <span class="number">1</span>);</span><br><span class="line">    spin_lock_init(&amp;lock-&gt;wait_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;lock-&gt;wait_list);</span><br><span class="line">    mutex_clear_owner(lock);</span><br><span class="line"> </span><br><span class="line">    debug_mutex_init(lock, name, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>锁定和解锁如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">/* 临界区 */</span></span><br><span class="line">mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">mutex_lock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The locking fastpath is the 1-&gt;0 transition from</span></span><br><span class="line"><span class="comment">     * &#x27;unlocked&#x27; into &#x27;locked&#x27; state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __mutex_fastpath_lock(&amp;lock-&gt;count, __mutex_lock_slowpath);</span><br><span class="line">    mutex_set_owner(lock);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">mutex_unlock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The unlocking fastpath is the 0-&gt;1 transition from &#x27;locked&#x27;</span></span><br><span class="line"><span class="comment">     * into &#x27;unlocked&#x27; state:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When debugging is enabled we must not clear the owner before time,</span></span><br><span class="line"><span class="comment">     * the slow path will always be taken, and that clears the owner field</span></span><br><span class="line"><span class="comment">     * after verifying that it was indeed current.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mutex_clear_owner(lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    __mutex_fastpath_unlock(&amp;lock-&gt;count, __mutex_unlock_slowpath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其他<code>mutex</code>方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mutex_trylock</span><span class="params">(<span class="keyword">struct</span> mutex *)</span>;    <span class="comment">//视图获取指定互斥体，成功返回1；否则返回0。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mutex_is_locked</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span>;    <span class="comment">//判断锁是否被占用，是返回1，否则返回0。</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>mutex</code>时，要注意一下：</p>
<ul>
<li><code>mutex</code>的使用技术永远是1；在同一上下文中上锁解锁；</li>
<li>当进程持有一个<code>mutex</code>时，进程不可退出；</li>
<li><code>mutex</code>不能在中断或下半部中使用。</li>
</ul>
<h2 id="抢占禁止"><a href="#抢占禁止" class="headerlink" title="抢占禁止"></a>抢占禁止</h2><p>在前面章节讲进程管理的时候听到过内核抢占，由于内核可抢占，内核中的进程随时都可能被另外一个具有更高优先权的进程打断，这也就意味着一个任务与被抢占的任务可能会在同一个临界区运行。所以才有本节前面自旋锁来避免竞态的发生，自旋锁有禁止内核抢占的功能。但像每CPU变量的数据只能被一个处理器访问，可以不需要使用锁来保护，如果没有使用锁，内核又是抢占式的，那么新调度的任务就可能访问同一个变量。这个时候就可以通过禁止内核抢占来避免竞态的发生，禁止内核抢占使用<code>preetmpt_disable()</code>函数，这是一个可以嵌套调用的函数，可以使用任意次。每次调用都必须有一个相应的<code>preempt_enable()</code>调用，当最后一次<code>preempt_enable()</code>被调用时，内核抢占才重新启用。内核抢占相关函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">preempt_enable() </span><br><span class="line"><span class="comment">//内核抢占计数preempt_count减1</span></span><br><span class="line">preempt_disable() </span><br><span class="line"><span class="comment">//内核抢占计数preempt_count加1，当该值降为0时检查和执行被挂起的需要调度的任务</span></span><br><span class="line">preempt_enable_no_resched()</span><br><span class="line"><span class="comment">//内核抢占计数preempt_count减1，但不立即抢占式调度</span></span><br><span class="line">preempt_check_resched () </span><br><span class="line"><span class="comment">//如果必要进行调度</span></span><br><span class="line">preempt_count() </span><br><span class="line"><span class="comment">//返回抢占计数</span></span><br><span class="line">preempt_schedule() </span><br><span class="line"><span class="comment">//内核抢占时的调度程序的入口点 </span></span><br></pre></td></tr></table></figure></p>
<p>以<code>preempt_enable()</code>为例，看一下其实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> preempt_enable() \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">    preempt_enable_no_resched(); \</span></span><br><span class="line"><span class="meta">    barrier(); \</span></span><br><span class="line"><span class="meta">    preempt_check_resched(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> preempt_enable_no_resched() \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">    barrier(); \</span></span><br><span class="line"><span class="meta">    dec_preempt_count(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec_preempt_count() sub_preempt_count(1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sub_preempt_count(val)    do &#123; preempt_count() -= (val); &#125; while (0)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> preempt_check_resched() \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (unlikely(test_thread_flag(TIF_NEED_RESCHED))) \</span></span><br><span class="line"><span class="meta">        preempt_schedule(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line">asmlinkage <span class="type">void</span> __sched <span class="title function_">preempt_schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span> =</span> current_thread_info();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If there is a non-zero preempt_count or interrupts are disabled,</span></span><br><span class="line"><span class="comment">     * we do not want to preempt the current task. Just return..</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (likely(ti-&gt;preempt_count || irqs_disabled()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        add_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line">        schedule();</span><br><span class="line">        sub_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Check again in case we missed a preemption opportunity</span></span><br><span class="line"><span class="comment">         * between schedule and now.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        barrier();</span><br><span class="line">    &#125; <span class="keyword">while</span> (need_resched());</span><br></pre></td></tr></table></figure></p>
<h1 id="内存管理之页的分配与回收"><a href="#内存管理之页的分配与回收" class="headerlink" title="内存管理之页的分配与回收"></a>内存管理之页的分配与回收</h1><p>内存管理单元（MMU）负责将管理内存，在把虚拟地址转换为物理地址的硬件的时候是按页为单位进行处理，从虚拟内存的角度来看，页就是内存管理中的最小单位。页的大小与体系结构有关，在 x86 结构中一般是4KB（32位）或者8KB（64位）。<br>通过 getconf 命令可以查看系统的<code>page</code>的大小：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># getconf -a | grep PAGE</span><br><span class="line">PAGESIZE                           4096</span><br><span class="line">PAGE_SIZE                          4096</span><br><span class="line">_AVPHYS_PAGES                      230873</span><br><span class="line">_PHYS_PAGES                        744957 </span><br></pre></td></tr></table></figure><br>内核中的每个物理页用<code>struct page</code>结构表示，结构定义于文件<code>&lt;include/linux/mm_types.h&gt;</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;        <span class="comment">/*页的状态*/</span></span><br><span class="line">    <span class="type">atomic_t</span> _count;        <span class="comment">/* 页引用计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">atomic_t</span> _mapcount; <span class="comment">/* 已经映射到mms的pte的个数*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>        <span class="comment">/* */</span></span><br><span class="line">            u16 inuse;</span><br><span class="line">            u16 objects;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> private;     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_SPLIT_PTLOCKS</span></span><br><span class="line">        <span class="type">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span>    <span class="comment">/* 指向slab层 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">first_page</span>;</span>    <span class="comment">/* Compound tail pages */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">pgoff_t</span> index;      <span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">        <span class="type">void</span> *freelist;     <span class="comment">/* SLUB: freelist req. slab lock */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>       <span class="comment">/* 将页关联起来的链表项 */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="type">void</span> *virtual;          <span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">                       not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WANT_PAGE_DEBUG_FLAGS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> debug_flags;  <span class="comment">/* Use atomic bitops on this */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">    <span class="type">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>内核使用这一结构来管理系统中所有的页，因为内核需要知道一个该页是否被分配，是被谁拥有的等信息。</p>
<p>由于ISA总线的DMA处理器有严格的限制，只能对物理内存前16M寻址，内核线性地址空间只有1G，CPU不能直接访问所有的物理内存。这样就导致有一些内存不能永久地映射在内核空间上。所以在Linux中，把页分为不同的区，使用区来对具有相似特性的页进行分组。分组如下（以x86-32为例）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>区域</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZONE_DMA</td>
<td>小于16M内存页框，这个区包含的页用来执行DMA操作。</td>
</tr>
<tr>
<td>ZONE_NORMAL</td>
<td>16M~896M内存页框，个区包含的都是能正常映射的页。</td>
</tr>
<tr>
<td>ZONE_HIGHMEM</td>
<td>大于896M内存页框，这个区包”高端内存”，其中的页能不永久地映射到内核地址空间。</td>
</tr>
</tbody>
</table>
</div>
<p>linux 把系统的页划分区，形成不同的内存池，这样就可以根据用途进行分配了。</p>
<p>每个区都用<code>struct zone</code>表示，定义于<code>&lt;include/linux/mmzone.h&gt;</code>中。该结构体较大，详细结构体信息可以查看源码文件。</p>
<p>Linux提供了几个以页为单位分配释放内存的接口，定义于<code>&lt;include/linux/gfp.h&gt;</code>中。分配内存主要有以下方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc_page(gfp_mask)</td>
<td>只分配一页，返回指向页结构的指针</td>
</tr>
<tr>
<td>alloc_pages(gfp_mask, order)</td>
<td>分配 2^order 个页，返回指向第一页页结构的指针</td>
</tr>
<tr>
<td>__get_free_page(gfp_mask)</td>
<td>只分配一页，返回指向其逻辑地址的指针</td>
</tr>
<tr>
<td>__get_free_pages(gfp_mask, order)</td>
<td>分配 2^order 个页，返回指向第一页逻辑地址的指针</td>
</tr>
<tr>
<td>get_zeroed_page(gfp_mask)</td>
<td>只分配一页，让其内容填充为0，返回指向其逻辑地址的指针</td>
</tr>
</tbody>
</table>
</div>
<p><code>alloc_*</code>函数返回的是内存的物理地址，<code>get_*</code>函数返回内存物理地址映射后的逻辑地址。如果无须直接操作物理页结构体的话，一般使用 <code>get_*</code>函数。</p>
<p>释放页的函数有：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __free_pages( <span class="keyword">struct</span> page *page, unsignedintorder); </span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">free_pages</span><span class="params">(<span class="type">unsigned</span> longaddr, <span class="type">unsigned</span> intorder)</span>; </span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">free_hot_page</span><span class="params">( <span class="keyword">struct</span> page *page)</span>;</span><br></pre></td></tr></table></figure><br>当需要以页为单位的连续物理页时，可以使用上面这些分配页的函数，对于常用以字节为单位的分配来说，内核提供来<code>kmalloc()</code>函数。</p>
<p><code>kmalloc()</code>函数和用户空间一族函数类似，它可以以字节为单位分配内存，对于大多数内核分配来说，<code>kmalloc</code>函数用得更多。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> gfp_mask)</span>；</span><br></pre></td></tr></table></figure></p>
<p>参数中有个<code>gfp_mask</code>标志，这个标志是控制分配内存时必须遵守的一些规则。</p>
<p><code>gfp_mask</code>标志有3类：</p>
<ul>
<li>行为标志 ：控制分配内存时，分配器的一些行为，如何分配所需内存。</li>
<li>区标志   ：控制内存分配在那个区(ZONE_DMA, ZONE_NORMAL, ZONE_HIGHMEM 之类)。</li>
<li>类型标志 ：由上面2种标志组合而成的一些常用的场景。</li>
</ul>
<p>行为标志主要有以下几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>行为标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>__GFP_WAIT</td>
<td>分配器可以睡眠</td>
</tr>
<tr>
<td>__GFP_HIGH</td>
<td>分配器可以访问紧急事件缓冲池</td>
</tr>
<tr>
<td>__GFP_IO</td>
<td>分配器可以启动磁盘`I/O</td>
</tr>
<tr>
<td>__GFP_FS</td>
<td>分配器可以启动文件系统`I/O</td>
</tr>
<tr>
<td>__GFP_COLD</td>
<td>分配器应该使用高速缓存中快要淘汰出去的页</td>
</tr>
<tr>
<td>__GFP_NOWARN</td>
<td>分配器将不打印失败警告</td>
</tr>
<tr>
<td>__GFP_REPEAT</td>
<td>分配器在分配失败时重复进行分配，但是这次分配还存在失败的可能</td>
</tr>
<tr>
<td>__GFP_NOFALL</td>
<td>分配器将无限的重复进行分配。分配不能失败</td>
</tr>
<tr>
<td>__GFP_NORETRY</td>
<td>分配器在分配失败时不会重新分配</td>
</tr>
<tr>
<td>__GFP_NO_GROW</td>
<td>由slab层内部使用</td>
</tr>
<tr>
<td>__GFP_COMP</td>
<td>添加混合页元数据，在 hugetlb 的代码内部使用</td>
</tr>
</tbody>
</table>
</div>
<p>标志主要有以下3种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>区标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__GFP_DMA</code></td>
<td>从 ZONE_DMA 分配</td>
</tr>
<tr>
<td><code>__GFP_DMA32</code></td>
<td>只在 ZONE_DMA32 分配 ，和 ZONE_DMA 类似，该区包含的页也可以进行<code>DMA</code>操作</td>
</tr>
<tr>
<td><code>__GFP_HIGHMEM</code></td>
<td>从 ZONE_HIGHMEM 或者 ZONE_NORMAL 分配，优先从 ZONE_HIGHMEM 分配，如果 ZONE_HIGHMEM 没有多余的页则从ZONE_NORMAL 分配</td>
</tr>
</tbody>
</table>
</div>
<p>类型标志是编程中最常用的，在使用标志时，应首先看看类型标志中是否有合适的，如果没有，再去自己组合 行为标志和区标志。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型标志</th>
<th>描述</th>
<th>实际标志</th>
</tr>
</thead>
<tbody>
<tr>
<td>GFP_ATOMIC</td>
<td>这个标志用在中断处理程序，下半部，持有自旋锁以及其他不能睡眠的地方</td>
<td><code>__GFP_HIGH</code></td>
</tr>
<tr>
<td>GFP_NOWAIT</td>
<td>与 GFP_ATOMIC 类似，不同之处在于，调用不会退给紧急内存池。这就增加了内存分配失败的可能性</td>
<td><code>0</code></td>
</tr>
<tr>
<td>GFP_NOIO</td>
<td>这种分配可以阻塞，但不会启动磁盘<code>I/O</code>。这个标志在不能引发更多磁盘<code>I/O</code>时能阻塞<code>I/O</code>代码，可能会导致递归</td>
<td><code>__GFP_WAIT</code></td>
</tr>
<tr>
<td>GFP_NOFS</td>
<td>这种分配在必要时可能阻塞，也可能启动磁盘<code>I/O</code>，但不会启动文件系统操作。这个标志在你不能再启动另一个文件系统的操作时，用在文件系统部分的代码中</td>
<td><code>(__GFP_WAIT｜ __GFP_IO)</code></td>
</tr>
<tr>
<td>GFP_KERNEL</td>
<td>这是常规的分配方式，可能会阻塞。这个标志在睡眠安全时用在进程上下文代码中。为了获得调用者所需的内存，内核会尽力而为。这个标志应当为首选标志</td>
<td><code>(__GFP_WAIT｜ __GFP_IO ｜ __GFP_FS )</code></td>
</tr>
<tr>
<td>GFP_USER</td>
<td>这是常规的分配方式，可能会阻塞。用于为用户空间进程分配内存时</td>
<td><code>(__GFP_WAIT｜ __GFP_IO ｜ __GFP_FS )</code></td>
</tr>
<tr>
<td>GFP_HIGHUSER</td>
<td>从 ZONE_HIGHMEM 进行分配，可能会阻塞。用于为用户空间进程分配内存</td>
<td><code>(__GFP_WAIT｜ __GFP_IO ｜ __GFP_FS ｜__GFP_HIGHMEM)</code></td>
</tr>
<tr>
<td>GFP_DMA</td>
<td>从 ZONE_DMA 进行分配。需要获取能供<code>DMA</code>使用的内存的设备驱动程序使用这个标志。通常与以上的某个标志组合在一起使用。</td>
<td><code>__GFP_DMA</code></td>
</tr>
</tbody>
</table>
</div>
<p>以上各种类型标志的使用场景总结：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>场景</th>
<th>相应标志</th>
</tr>
</thead>
<tbody>
<tr>
<td>进程上下文，可以睡眠</td>
<td>使用 GFP_KERNEL</td>
</tr>
<tr>
<td>进程上下文，不可以睡眠</td>
<td>使用 GFP_ATOMIC，在睡眠之前或之后以 GFP_KERNEL 执行内存分配</td>
</tr>
<tr>
<td>中断处理程序</td>
<td>使用 GFP_ATOMIC</td>
</tr>
<tr>
<td>软中断</td>
<td>使用 GFP_ATOMIC</td>
</tr>
<tr>
<td>tasklet</td>
<td>使用 GFP_ATOMIC</td>
</tr>
<tr>
<td>需要用于<code>DMA</code>的内存，可以睡眠</td>
<td>使用 (GFP_DMA｜GFP_KERNEL)</td>
</tr>
<tr>
<td>需要用于<code>DMA</code>的内存，不可以睡眠</td>
<td>使用 (GFP_DMA｜GFP_ATOMIC)，或者在睡眠之前执行内存分配</td>
</tr>
</tbody>
</table>
</div>
<p>kmalloc 所对应的释放内存的方法为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>；</span><br></pre></td></tr></table></figure><br>vmalloc()也可以按字节来分配内存。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *vmalloc(unsigned long size)</span><br></pre></td></tr></table></figure><br>和<code>kmalloc</code>是一样的作用，不同在于前者分配的内存虚拟地址是连续的，而物理地址则无需连续。<code>kmalloc()</code>可以保证在物理地址上都是连续的，虚拟地址当然也是连续的。<code>vmalloc()</code>函数只确保页在虚拟机地址空间内是连续的。它通过分配非联系的物理内存块，再“修正”页表，把内存映射到逻辑地址空间的连续区域中，就能做到这点。但很显然这样会降低处理性能，因为内核不得不做“拼接”的工作。所以这也是为什么不得已才使用<code>vmalloc()</code>的原因 。<code>vmalloc()</code>可能睡眠，不能从中断上下文中进行调用，也不能从其他不允许阻塞的情况下进行调用。释放时必须使用<code>vfree()</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>；</span><br></pre></td></tr></table></figure></p>
<p>对于内存页面的管理，通常是先在虚存空间中分配一个虚存区间，然后才根据需要为此区间分配相应的物理页面并建立起映射，也就是说，虚存区间的分配在前，而物理页面的分配在后。但由于频繁的请求和释放不同大小的连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框，由此产生的问题是：即使有足够的空闲页框可以满足请求，但当要分配一个大块的连续页框时，无法满足请求。这就是著名的内存管理问题：外碎片问题。Linux采用著名的伙伴（Buddy）系统算法来解决外碎片问题。</p>
<p>把所有的空闲页框分组为11个块链表。每个块链表包含大小为1,2,4,8,16,32,64,128,256,512，1024个的页框。伙伴系统算法原理为：</p>
<p>假设请求一个256个页框的块，先在256个页框的链表内检查是否有一个空闲的块。如果没有这样的块，算法会查找下一个更大的块，在512个页框的链表中找一个空闲块。如果存在这样的块，内核就把512的页框分成两半，一半用作满足请求，另一半插入256个页框的链表中。如果512个页框的块链表也没有空闲块，就继续找更大的块，1024个页框的块。如果这样的块存在，内核把1024个页框的256个页框用作请求，然后从剩余的768个中拿出512个插入512个页框的链表中，把最后256个插入256个页框的链表中。</p>
<p>页框块的释放过程如下：</p>
<p>如果两个块具有相同的大小：a，并且他们的物理地址连续那么这两个块成为伙伴，内核就会试图把大小为<code>a</code>的一对空闲伙伴块合并为一个大小为<code>2a</code>的单独块。该算法还是迭代的，如果合并成功的话，它还会试图合并<code>2a</code>的块。</p>
<p>管理分区数据结构<code>struct zone_struct</code>中，涉及到空闲区数据结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span>        nr_free; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>采用伙伴算法分配内存时，每次至少分配一个页面。但当请求分配的内存大小为几十个字节或几百个字节时应该如何处理？如何在一个页面中分配小的内存区，小内存区的分配所产生的内碎片又如何解决？slab的分配模式可以解决该问题。</p>
<h1 id="内存管理之slab分配器"><a href="#内存管理之slab分配器" class="headerlink" title="内存管理之slab分配器"></a>内存管理之slab分配器</h1><p>上一节最后说到对于小内存区的请求，如果采用伙伴系统来进行分配，则会在页内产生很多空闲空间无法使用，因此产生slab分配器来处理对小内存区（几十或几百字节）的请求。Linux中引入slab的主要目的是为了减少对伙伴算法的调用次数。</p>
<p>内核经常反复使用某一内存区。例如，只要内核创建一个新的进程，就要为该进程相关的数据结构（task_struct、打开文件对象等）分配内存区。当进程结束时，收回这些内存区。因为进程的创建和撤销非常频繁，Linux把那些频繁使用的页面保存在高速缓存中并重新使用。</p>
<p>slab分配器基于对象进行管理，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就分配一个空闲对象出去，而当要释放时，将其重新保存在slab分配器中，而不是直接返回给伙伴系统。对于频繁请求的对象，创建适当大小的专用对象来处理。对于不频繁的对象，用一系列几何分布大小的对象来处理（详见通用对象）。</p>
<p>slab分配模式把对象分组放进缓冲区，为缓冲区的组织和管理与硬件高速缓存的命中率密切相关，因此，slab缓冲区并非由各个对象直接构成，而是由一连串的“大块（Slab）”构成，而每个大块中则包含了若干个同种类型的对象，这些对象或已被分配，或空闲。实际上，缓冲区就是主存中的一片区域，把这片区域划分为多个块，每块就是一个slab，每个slab由一个或多个页面组成，每个slab中存放的就是对象。</p>
<p>slab相关数据结构：</p>
<p>缓冲区数据结构使用<code>kmem_cache</code>结构来表示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"><span class="comment">/* 1) per-cpu data, touched during every alloc/free */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">array</span>[<span class="title">NR_CPUS</span>];</span></span><br><span class="line"><span class="comment">/* 2) Cache tunables. Protected by cache_chain_mutex */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> batchcount;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shared;</span><br><span class="line"> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> buffer_size;</span><br><span class="line">	u32 reciprocal_buffer_size;</span><br><span class="line"><span class="comment">/* 3) touched by every alloc &amp; free from the backend */</span></span><br><span class="line"> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;		<span class="comment">/* constant flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num;		<span class="comment">/* # of objs per slab */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 4) cache_grow/shrink */</span></span><br><span class="line">	<span class="comment">/* order of pgs per slab (2^n) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> gfporder;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* force GFP flags, e.g. GFP_DMA */</span></span><br><span class="line">	<span class="type">gfp_t</span> gfpflags;</span><br><span class="line"> </span><br><span class="line">	<span class="type">size_t</span> colour;			<span class="comment">/* cache colouring range */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> colour_off;	<span class="comment">/* colour offset */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slabp_cache</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> slab_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> dflags;		<span class="comment">/* dynamic flags */</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* constructor func */</span></span><br><span class="line">	<span class="type">void</span> (*ctor)(<span class="type">void</span> *obj);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 5) cache creation/removal */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">next</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 6) statistics */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SLAB</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> num_active;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> num_allocations;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> high_mark;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> grown;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> reaped;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> errors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> max_freeable;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_allocs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_frees;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_overflow;</span><br><span class="line">	<span class="type">atomic_t</span> allochit;</span><br><span class="line">	<span class="type">atomic_t</span> allocmiss;</span><br><span class="line">	<span class="type">atomic_t</span> freehit;</span><br><span class="line">	<span class="type">atomic_t</span> freemiss;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If debugging is enabled, then the allocator can add additional</span></span><br><span class="line"><span class="comment">	 * fields and/or padding to every object. buffer_size contains the total</span></span><br><span class="line"><span class="comment">	 * object size including these internal fields, the following two</span></span><br><span class="line"><span class="comment">	 * variables contain the offset to the user object and its size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> obj_offset;</span><br><span class="line">	<span class="type">int</span> obj_size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEBUG_SLAB */</span></span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We put nodelists[] at the end of kmem_cache, because we want to size</span></span><br><span class="line"><span class="comment">	 * this array to nr_node_ids slots instead of MAX_NUMNODES</span></span><br><span class="line"><span class="comment">	 * (see kmem_cache_init())</span></span><br><span class="line"><span class="comment">	 * We still use [MAX_NUMNODES] and not [1] or [0] because cache_cache</span></span><br><span class="line"><span class="comment">	 * is statically defined, so we reserve the max number of nodes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_list3</span> *<span class="title">nodelists</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do not add fields after nodelists[]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其中<code>struct kmem_list3</code>结构体链接slab，共享高速缓存，其定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The slab lists for all objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_list3</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span>	<span class="comment">/* partial list first, better asm code */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> colour_next;	<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line">	<span class="type">spinlock_t</span> list_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span>	<span class="comment">/* shared per node */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> **<span class="title">alien</span>;</span>	<span class="comment">/* on other nodes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> next_reap;	<span class="comment">/* updated without locking */</span></span><br><span class="line">	<span class="type">int</span> free_touched;		<span class="comment">/* updated without locking */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该结构包含三个链表：<code>slabs_partial</code>、<code>slabs_full</code>、<code>slabs_free</code>，这些链表包含缓冲区所有slab，slab描述符<code>struct slab</code>用于描述每个slab：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * struct slab</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Manages the objs in a slab. Placed either at the beginning of mem allocated</span></span><br><span class="line"><span class="comment"> * for a slab, or allocated from an general cache.</span></span><br><span class="line"><span class="comment"> * Slabs are chained into three list: fully used, partial, fully free slabs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> colouroff;</span><br><span class="line">	<span class="type">void</span> *s_mem;		<span class="comment">/* including colour offset */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inuse;	<span class="comment">/* num of objs active in slab */</span></span><br><span class="line">	<span class="type">kmem_bufctl_t</span> <span class="built_in">free</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> nodeid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一个新的缓冲区使用如下函数创建：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kmem_cache *<span class="title function_">kmem_cache_create</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">size_t</span> size, <span class="type">size_t</span> align, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">void</span> (*ctor)(<span class="type">void</span> *))</span>; </span><br></pre></td></tr></table></figure><br>函数创建成功会返回一个指向所创建缓冲区的指针；撤销一个缓冲区调用如下函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_destroy</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep)</span>；</span><br></pre></td></tr></table></figure><br>上面两个函数都不能在中断上下文中使用，因为它可能睡眠。<br>在创建来缓冲区之后，可以通过下列函数获取对象：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmem_cache_alloc - Allocate an object</span></span><br><span class="line"><span class="comment"> * @cachep: The cache to allocate from.</span></span><br><span class="line"><span class="comment"> * @flags: See kmalloc().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocate an object from this cache.  The flags are only relevant</span></span><br><span class="line"><span class="comment"> * if the cache has no available objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmem_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = __cache_alloc(cachep, flags, __builtin_return_address(<span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line">	trace_kmem_cache_alloc(_RET_IP_, ret,</span><br><span class="line">			       obj_size(cachep), cachep-&gt;buffer_size, flags);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数从给点缓冲区<code>cachep</code>中返回一个指向对象的指针。如果缓冲区的所有slab中都没有空闲对象，那么slab层必须通过<code>kmem_getpages()</code>获取新的页，参数<code>flags</code>传递给<code>_get_free_pages()</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">kmem_getpages</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags, <span class="type">int</span> nodeid)</span>；</span><br></pre></td></tr></table></figure><br>释放对象使用如下函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmem_cache_free - Deallocate an object</span></span><br><span class="line"><span class="comment"> * @cachep: The cache the allocation was from.</span></span><br><span class="line"><span class="comment"> * @objp: The previously allocated object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Free an object which was previously allocated from this</span></span><br><span class="line"><span class="comment"> * cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	debug_check_no_locks_freed(objp, obj_size(cachep));</span><br><span class="line">	<span class="keyword">if</span> (!(cachep-&gt;flags &amp; SLAB_DEBUG_OBJECTS))</span><br><span class="line">		debug_check_no_obj_freed(objp, obj_size(cachep));</span><br><span class="line">	__cache_free(cachep, objp);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line"> </span><br><span class="line">	trace_kmem_cache_free(_RET_IP_, objp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果你要频繁的创建很多相同类型的对象，就要当考虑使用slab高速缓存区。</p>
<p>实际上上一节所讲<code>kmalloc()</code>函数也是使用slab分配器分配的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cachep</span>;</span></span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (!size)</span><br><span class="line">			<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE(x) \</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span> (size &lt;= x) \</span></span><br><span class="line"><span class="meta">			goto found; \</span></span><br><span class="line"><span class="meta">		<span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">			i++;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmalloc_sizes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CACHE</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">found:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; GFP_DMA)</span><br><span class="line">			cachep = malloc_sizes[i].cs_dmacachep;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			cachep = malloc_sizes[i].cs_cachep;</span><br><span class="line"> </span><br><span class="line">		ret = kmem_cache_alloc_notrace(cachep, flags);</span><br><span class="line"> </span><br><span class="line">		trace_kmalloc(_THIS_IP_, ret,</span><br><span class="line">			      size, slab_buffer_size(cachep), flags);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>kfree</code>函数实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfree - free previously allocated memory</span></span><br><span class="line"><span class="comment"> * @objp: pointer returned by kmalloc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @objp is NULL, no operation is performed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Don&#x27;t free memory not originally allocated by kmalloc()</span></span><br><span class="line"><span class="comment"> * or you will run into trouble.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *objp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line">	trace_kfree(_RET_IP_, objp);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(objp)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	kfree_debugcheck(objp);</span><br><span class="line">	c = virt_to_cache(objp);</span><br><span class="line">	debug_check_no_locks_freed(objp, obj_size(c));</span><br><span class="line">	debug_check_no_obj_freed(objp, obj_size(c));</span><br><span class="line">	__cache_free(c, (<span class="type">void</span> *)objp);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，结合上一节，看看分配函数的选择：</p>
<ul>
<li>如果需要连续的物理页，就可以使用某个低级页分配器或<code>kmalloc()</code>。</li>
<li>如果想从高端内存进行分配，使用<code>alloc_pages()</code>。</li>
<li>如果不需要物理上连续的页，而仅仅是虚拟地址上连续的页，那么就是用<code>vmalloc</code>。</li>
<li>如果要创建和销毁很多大的数据结构，那么考虑建立slab高速缓存。</li>
</ul>
<h1 id="内存管理之进程地址空间"><a href="#内存管理之进程地址空间" class="headerlink" title="内存管理之进程地址空间"></a>内存管理之进程地址空间</h1><p>进程地址空间由进程可寻址的虚拟内存组成，Linux 的虚拟地址空间为0~4G字节（注：本节讲述均以32为为例）。Linux内核将这 4G 字节的空间分为两部分。将最高的 1G 字节(从虚拟地址0xC0000000到0xFFFFFFFF)，供内核使用，称为“内核空间”。而将较低的 3G 字节(从虚拟地址 0x00000000 到 0xBFFFFFFF)，供各个进程使用，称为“用户空间” 。因为每个进程可以通过系统调用进入内核。因此，Linux 内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有 4G 字节的虚拟空间。</p>
<p>尽管一个进程可以寻址4G的虚拟内存，但就不代表它就有权限访问所有的地址空间，虚拟内存空间必须映射到某个物理存储空间(内存或磁盘空间)，才真正地可以被使用。进程只能访问合法的地址空间，如果一个进程访问了不合法的地址空间，内核就会终止该进程，并返回“段错误”。虚拟内存的合法地址空间在哪而呢？我们先来看看进程虚拟地址空间的划分：</p>
<p>其中堆栈安排在虚拟地址空间顶部，数据段和代码段分布在虚拟地址空间底部，空洞部分就是进程运行时可以动态分布的空间，包括映射内核地址空间内容、动态申请地址空间、共享库的代码或数据等。在虚拟地址空间中，只有那些映射到物理存储空间的地址才是合法的地址空间。每一片合法的地址空间片段都对应一个独立的虚拟内存区域（VMA，virtual memory areas ），而进程的进程地址空间就是由这些内存区域组成。</p>
<p>Linux 采用了复杂的数据结构来跟踪进程的虚拟地址，进程地址空间使用内存描述符结构体来表示，内存描述符由<code>mm_struct</code>结构体表示，该结构体表示在<code>&lt;include/linux/mm_types.h&gt;</code>文件中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span>        <span class="comment">/* list of VMAs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span>    <span class="comment">/* last find_vma result */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line">    <span class="type">void</span> (*unmap_area) (<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_base;        <span class="comment">/* base of mmap area */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> task_size;        <span class="comment">/* size of task vm space */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cached_hole_size;     <span class="comment">/* if non-zero, the largest hole below free_area_cache */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> free_area_cache;        <span class="comment">/* first hole of size cached_hole_size or larger */</span></span><br><span class="line">    <span class="type">pgd_t</span> * pgd;</span><br><span class="line">    <span class="type">atomic_t</span> mm_users;            <span class="comment">/* How many users with user space? */</span></span><br><span class="line">    <span class="type">atomic_t</span> mm_count;            <span class="comment">/* How many references to &quot;struct mm_struct&quot; (users count as 1) */</span></span><br><span class="line">    <span class="type">int</span> map_count;                <span class="comment">/* number of VMAs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> page_table_lock;        <span class="comment">/* Protects page tables and some counters */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>        <span class="comment">/* List of maybe swapped mm&#x27;s.    These are globally strung together off init_mm.mmlist, and are protected by mmlist_lock */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Special counters, in some configurations protected by the</span></span><br><span class="line"><span class="comment">    * page_table_lock, in other configurations by being atomic.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">mm_counter_t</span> _file_rss;</span><br><span class="line">    <span class="type">mm_counter_t</span> _anon_rss;</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hiwater_rss;    <span class="comment">/* High-watermark of RSS usage */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hiwater_vm;    <span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_vm, locked_vm, shared_vm, exec_vm;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">cpumask_t</span> cpu_vm_mask;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="type">mm_context_t</span> context;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Swap token stuff */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Last value of global fault stamp as seen by this process.</span></span><br><span class="line"><span class="comment">     * In other words, this value gives an indication of how long</span></span><br><span class="line"><span class="comment">     * it has been since this task got the token.</span></span><br><span class="line"><span class="comment">     * Look at mm/thrash.c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> faultstamp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> token_priority;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> last_interval;</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">core_state</span>;</span> <span class="comment">/* coredumping support */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AIO</span></span><br><span class="line">    <span class="type">spinlock_t</span>        ioctx_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>    <span class="title">ioctx_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MM_OWNER</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &quot;owner&quot; points to a task that is regarded as the canonical</span></span><br><span class="line"><span class="comment">     * user/owner of this mm. All of the following must be true in</span></span><br><span class="line"><span class="comment">     * order for it to be changed:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * current == mm-&gt;owner</span></span><br><span class="line"><span class="comment">     * current-&gt;mm != mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;mm == mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;alloc_lock is held</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">    <span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">exe_file</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num_exe_file_vmas;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_mm</span> *<span class="title">mmu_notifier_mm</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该结构体中第一行成员<code>mmap</code>就是内存区域，用结构体<code>struct vm_area_struct</code>来表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct defines a memory VMM memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task.  A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span>    <span class="comment">/* The address space we belong to. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start;        <span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end;        <span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">                       within vm_mm. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot;        <span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags;        <span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">     * linkage into the address_space-&gt;i_mmap prio tree, or</span></span><br><span class="line"><span class="comment">     * linkage to the list of like vmas hanging off its node, or</span></span><br><span class="line"><span class="comment">     * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">            <span class="type">void</span> *parent;    <span class="comment">/* aligns with prio_tree_node parent */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">        &#125; vm_set;</span><br><span class="line"> </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">    &#125; shared;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">     * list, after a COW of one of the file pages.    A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">     * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span>    <span class="comment">/* Serialized by anon_vma-&gt;lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>    <span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Information about our backing store: */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;        <span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">                       units, *not* PAGE_CACHE_SIZE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>        <span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">    <span class="type">void</span> * vm_private_data;        <span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_truncate_count;<span class="comment">/* truncate_count or restart_addr */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>    <span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>    <span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>vm_area_struct</code>结构体描述了进程地址空间内连续区间上的一个独立内存范围，每一个内存区域都使用该结构体表示，每一个结构体以双向链表的形式连接起来。除链表结构外，Linux 还利用红黑树<code>mm_rb</code>来组织 vm_area_struct。通过这种树结构，Linux 可以快速定位某个虚拟内存地址。</p>
<p>该结构体中成员<code>vm_start</code>和<code>vm_end</code>表示内存区间的首地址和尾地址，两个值相减就是内存区间的长度。</p>
<p>成员<code>vm_mm</code>则指向其属于的进程地址空间结构体。所以两个不同的进程将同一个文件映射到自己的地址空间中，他们分别都会有一个<code>vm_area_struct</code>结构体来标识自己的内存区域。两个共享地址空间的线程则只有一个<code>vm_area_struct</code>结构体来标识，因为他们使用的是同一个进程地址空间。</p>
<p><code>vm_flags</code>标识内存区域所包含的页面的行为和信息，反映内核处理页面所需要遵守的行为准则。</p>
<p>可以使用<code>cat /proc/PID/maps</code>命令和<code>pmap</code>命令查看给定进程空间和其中所含的内存区域。以笔者系统上进程号为17192的进程为例。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/17192/maps     //显示该进程地址空间中全部内存区域</span></span><br><span class="line">001e3000-00201000 r-xp 00000000 fd:00 789547     /lib/ld-2.12.so</span><br><span class="line">00201000-00202000 r--p 0001d000 fd:00 789547     /lib/ld-2.12.so</span><br><span class="line">00202000-00203000 rw-p 0001e000 fd:00 789547     /lib/ld-2.12.so</span><br><span class="line">00209000-00399000 r-xp 00000000 fd:00 789548     /lib/libc-2.12.so</span><br><span class="line">00399000-0039a000 ---p 00190000 fd:00 789548     /lib/libc-2.12.so</span><br><span class="line">0039a000-0039c000 r--p 00190000 fd:00 789548     /lib/libc-2.12.so</span><br><span class="line">0039c000-0039d000 rw-p 00192000 fd:00 789548     /lib/libc-2.12.so</span><br><span class="line">0039d000-003a0000 rw-p 00000000 00:00 0</span><br><span class="line">08048000-08049000 r-xp 00000000 fd:00 1191771    /home/allen/Myprojects/blog/conn_user_kernel/test/a.out</span><br><span class="line">08049000-0804a000 rw-p 00000000 fd:00 1191771    /home/allen/Myprojects/blog/conn_user_kernel/test/a.out</span><br><span class="line">b7755000-b7756000 rw-p 00000000 00:00 0</span><br><span class="line">b776d000-b776e000 rw-p 00000000 00:00 0</span><br><span class="line">b776e000-b776f000 r-xp 00000000 00:00 0          [vdso]</span><br><span class="line">bfc9f000-bfcb4000 rw-p 00000000 00:00 0          [stack]</span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pmap 17192</span></span><br><span class="line">17192:   ./a.out</span><br><span class="line">001e3000    120K r-x--  /lib/ld-2.12.so    //本行和下面两行为动态链接程序ld.so的代码段、数据段、bss段</span><br><span class="line">00201000      4K r----  /lib/ld-2.12.so</span><br><span class="line">00202000      4K rw---  /lib/ld-2.12.so</span><br><span class="line">00209000   1600K r-x--  /lib/libc-2.12.so    //本行和下面为C库中libc.so的代码段、数据段和bss段</span><br><span class="line">00399000      4K -----  /lib/libc-2.12.so</span><br><span class="line">0039a000      8K r----  /lib/libc-2.12.so</span><br><span class="line">0039c000      4K rw---  /lib/libc-2.12.so</span><br><span class="line">0039d000     12K rw---    [ anon ]</span><br><span class="line">08048000      4K r-x--  /home/allen/Myprojects/blog/conn_user_kernel/test/a.out    //可执行对象的代码段</span><br><span class="line">08049000      4K rw---  /home/allen/Myprojects/blog/conn_user_kernel/test/a.out    //可执行对象的数据段</span><br><span class="line">b7755000      4K rw---    [ anon ]</span><br><span class="line">b776d000      4K rw---    [ anon ]</span><br><span class="line">b776e000      4K r-x--    [ anon ]</span><br><span class="line">bfc9f000     84K rw---    [ stack ]    //堆栈段</span><br><span class="line"> total     1860K</span><br></pre></td></tr></table></figure></p>
<p>结构体中<code>vm_ops</code>域指定内存区域相关操作函数表，内核使用表中方法操作VMA，操作函数表由<code>vm_operations_struct</code>结构体表示，定义在<code>&lt;include/linux/mm.h&gt;</code>文件中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are the virtual MM functions - opening of an area, closing and</span></span><br><span class="line"><span class="comment"> * unmapping it (needed to keep files on disk up-to-date etc), pointer</span></span><br><span class="line"><span class="comment"> * to the functions called when a no-page or a wp-page exception occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*open)(<span class="keyword">struct</span> vm_area_struct * area);    <span class="comment">//指定内存区域被加载到一个地址空间时函数被调用</span></span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> vm_area_struct * area);    <span class="comment">//指定内存区域从地址空间删除时函数被调用</span></span><br><span class="line">    <span class="type">int</span> (*fault)(<span class="keyword">struct</span> vm_area_struct *vma, <span class="keyword">struct</span> vm_fault *vmf); <span class="comment">//没有出现在物理内存中的页面被访问时，页面故障处理调用该函数</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* notification that a previously read-only page is about to become</span></span><br><span class="line"><span class="comment">     * writable, if an error is returned it will cause a SIGBUS */</span></span><br><span class="line">    <span class="type">int</span> (*page_mkwrite)(<span class="keyword">struct</span> vm_area_struct *vma, <span class="keyword">struct</span> vm_fault *vmf);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* called by access_process_vm when get_user_pages() fails, typically</span></span><br><span class="line"><span class="comment">     * for use by special VMAs that can switch between memory and hardware</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*access)(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> addr,</span><br><span class="line">              <span class="type">void</span> *buf, <span class="type">int</span> len, <span class="type">int</span> write);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    ......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在内核中，给定一个属于某个进程的虚拟地址，要求找到其所属的区间以及<code>vma_area_struct</code>结构，这通过<code>find_vma()</code>来实现，这种搜索通过红-黑树进行。该函数定义于<code>&lt;mm/mmap.c&gt;</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */</span></span><br><span class="line"><span class="keyword">struct</span> vm_area_struct *<span class="title function_">find_vma</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        <span class="comment">/* 首先检查最近使用的内存区域，看缓存的VMA是否包含所需地址 */</span></span><br><span class="line">        <span class="comment">/* (命中率接近35%.) */</span></span><br><span class="line">        vma = mm-&gt;mmap_cache;</span><br><span class="line">        <span class="comment">//如果缓存中不包含未包含希望的VMA，该函数搜索红-黑树。</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123;</span><br><span class="line">             <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> * <span class="title">rb_node</span>;</span></span><br><span class="line"> </span><br><span class="line">            rb_node = mm-&gt;mm_rb.rb_node;</span><br><span class="line">            vma = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">while</span> (rb_node) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vma_tmp</span>;</span></span><br><span class="line"> </span><br><span class="line">                vma_tmp = rb_entry(rb_node, <span class="keyword">struct</span> vm_area_struct, vm_rb);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;</span><br><span class="line">                    vma = vma_tmp;</span><br><span class="line">                    <span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    rb_node = rb_node-&gt;rb_left;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    rb_node = rb_node-&gt;rb_right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vma)</span><br><span class="line">                mm-&gt;mmap_cache = vma;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当某个程序的映像开始执行时，可执行映像必须装入到进程的虚拟地址空间。如果该进程用到了任何一个共享库，则共享库也必须装入到进程的虚拟地址空间。由此可看出，Linux并不将映像装入到物理内存，相反，可执行文件只是被连接到进程的虚拟地址空间中。随着程序的运行，被引用的程序部分会由操作系统装入到物理内存，这种将映像链接到进程地址空间的方法被称为“内存映射”。</p>
<p>当可执行映像映射到进程的虚拟地址空间时，将产生一组<code>vm_area_struct</code>结构来描述虚拟内存区间的起始点和终止点，每个<code>vm_area_struct</code>结构代表可执行映像的一部分，可能是可执行代码，也可能是初始化的变量或未初始化的数据，这些都是在函数<code>do_mmap()</code>中来实现的。随着<code>vm_area_struct</code>结构的生成，这些结构所描述的虚拟内存区间上的标准操作函数也由 Linux 初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">do_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> prot,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> flag, <span class="type">unsigned</span> <span class="type">long</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> ((offset + PAGE_ALIGN(len)) &lt; offset)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!(offset &amp; ~PAGE_MASK))</span><br><span class="line">        ret = do_mmap_pgoff(file, addr, len, prot, flag, offset &gt;&gt; PAGE_SHIFT);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数会将一个新的地址区间加入到进程的地址空间中。定义于<code>&lt;include/linux/mm.h&gt;</code>。<br>函数中参数的含义：</p>
<ul>
<li><code>file</code>：表示要映射的文件。</li>
<li><code>offset</code>：文件内的偏移量，因为我们并不是一下子全部映射一个文件，可能只是映射文件的一部分，off 就表示那部分的起始位置。</li>
<li><code>len</code>：要映射的文件部分的长度。</li>
<li><code>addr</code>：虚拟空间中的一个地址，表示从这个地址开始查找一个空闲的虚拟区。</li>
<li><code>prot</code>：这个参数指定对这个虚拟区所包含页的存取权限。可能的标志有<code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_EXEC</code>、<code>PROT_NONE</code>。前 3 个标志与标志<code>VM_READ</code>、<code>VM_WRITE</code>、<code>VM_EXEC</code>的意义一样。<code>PROT_NONE</code>表示进程没有以上 3 个存取权限中的任意一个。</li>
<li>flag`：这个参数指定虚拟区的其他标志。</li>
</ul>
<p>该函数调用<code>do_mmap_pgoff()</code>函数，该函数做内存映射的主要工作，该函数比较长，详细实现可查看<code>&lt;mm/mmap.c&gt;</code>文件。</p>
<p>由于文件到虚存的映射仅仅是建立了一种映射关系，虚存页面到物理页面之间的映射还没有建立。当某个可执行映象映射到进程虚拟内存中并开始执行时，因为只有很少一部分虚拟内存区间装入到了物理内存，很可能会遇到所访问的数据不在物理内存。这时，处理器将向 Linux 报告一个页故障及其对应的故障原因，</p>
<p>内核必须从磁盘映像或交换文件(此页被换出)中将其装入物理内存，这就是请页机制。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/14/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="next" title="23种设计模式总结">
                <i class="fa fa-chevron-left"></i> 23种设计模式总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E4%B8%8EBCNF/" rel="prev" title="数据库设计三大范式与BCNF">
                数据库设计三大范式与BCNF <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">130</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A1%AC%E4%B8%AD%E6%96%AD%E5%8F%8A%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">硬中断及中断处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8B%E5%8D%8A%E9%83%A8%E6%9C%BA%E5%88%B6%E4%B9%8B%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-number">3.</span> <span class="nav-text">下半部机制之软中断</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8B%E5%8D%8A%E9%83%A8%E6%9C%BA%E5%88%B6%E4%B9%8Btasklet"><span class="nav-number">4.</span> <span class="nav-text">下半部机制之tasklet</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8B%E5%8D%8A%E9%83%A8%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%8F%8A%E5%87%A0%E7%A7%8D%E6%9C%BA%E5%88%B6%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">5.</span> <span class="nav-text">下半部机制之工作队列及几种机制的选择</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="nav-number">6.</span> <span class="nav-text">内核时钟中断</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="nav-number">7.</span> <span class="nav-text">内核定时器和定时执行</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">8.</span> <span class="nav-text">进程管理分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">9.</span> <span class="nav-text">进程调度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5"><span class="nav-number">10.</span> <span class="nav-text">内核同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">10.1.</span> <span class="nav-text">原子操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">10.2.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">10.3.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93"><span class="nav-number">10.4.</span> <span class="nav-text">互斥体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0%E7%A6%81%E6%AD%A2"><span class="nav-number">10.5.</span> <span class="nav-text">抢占禁止</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E9%A1%B5%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-number">11.</span> <span class="nav-text">内存管理之页的分配与回收</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8Bslab%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">12.</span> <span class="nav-text">内存管理之slab分配器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">13.</span> <span class="nav-text">内存管理之进程地址空间</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
