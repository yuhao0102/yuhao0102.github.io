<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zn-ch">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux," />










<meta name="description" content="访问文件访问基于磁盘的文件是一种复杂的活动，既涉及VFS抽象层、块设备的处理，也涉及磁盘高速缓存的使用。将磁盘文件系统的普通文件和块设备文件都简单地统称为“文件”。 访问文件的模式有多种：  规范模式：规范模式下文件打开后，标志O_SYNC和O_DIRECT清0，且它的内容由read()和write()存取。read()阻塞调用进程，直到数据被拷贝进用户态地址空间。但write()在数据被拷贝到页">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Linux内核16-17章">
<meta property="og:url" content="http://yoursite.com/2020/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B06/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="访问文件访问基于磁盘的文件是一种复杂的活动，既涉及VFS抽象层、块设备的处理，也涉及磁盘高速缓存的使用。将磁盘文件系统的普通文件和块设备文件都简单地统称为“文件”。 访问文件的模式有多种：  规范模式：规范模式下文件打开后，标志O_SYNC和O_DIRECT清0，且它的内容由read()和write()存取。read()阻塞调用进程，直到数据被拷贝进用户态地址空间。但write()在数据被拷贝到页">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1604132638.png">
<meta property="og:image" content="http://yoursite.com/img/1604156377.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604160114.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604237045.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604317095.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604396278.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604396533.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604396534.png">
<meta property="og:image" content="http://yoursite.com/img/1604497477.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604505066.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604505540.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604570227.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604396536.png">
<meta property="og:image" content="http://yoursite.com/img/1604641504.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604396537.png">
<meta property="og:image" content="http://yoursite.com/img/1604745493.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604746260.jpg">
<meta property="og:image" content="http://yoursite.com/img/1604838117.jpg">
<meta property="article:published_time" content="2020-10-31T08:00:00.000Z">
<meta property="article:modified_time" content="2020-11-08T12:49:06.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1604132638.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/10/31/深入理解Linux内核 笔记6/"/>





  <title>深入理解Linux内核16-17章 | Hao Yu's blog</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解Linux内核16-17章</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-31T16:00:00+08:00">
                2020-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="访问文件"><a href="#访问文件" class="headerlink" title="访问文件"></a>访问文件</h1><p>访问基于磁盘的文件是一种复杂的活动，既涉及<strong>VFS抽象层</strong>、<strong>块设备的处理</strong>，也涉及<strong>磁盘高速缓存的使用</strong>。将磁盘文件系统的普通文件和块设备文件都简单地统称为“文件”。</p>
<p>访问文件的模式有多种：</p>
<ul>
<li><strong>规范模式</strong>：规范模式下文件打开后，标志<code>O_SYNC</code>和<code>O_DIRECT</code>清0，且它的内容由<code>read()</code>和<code>write()</code>存取。<code>read()</code>阻塞调用进程，直到数据被拷贝进用户态地址空间。但<code>write()</code>在数据被拷贝到页高速缓存（延迟写）后马上结束。</li>
<li><strong>同步模式</strong>：同步模式下文件打开后，标志<code>O_SYNC</code>置1或稍后由系统调用<code>fcntl()</code>对其置1。该标志只影响写操作（读操作总是会阻塞），它将阻塞系统调用，直到数据写入磁盘。</li>
<li><strong>内存映射模式</strong>：内存映射模式下文件打开后，应用程序发出系统调用<code>mmap()</code>将文件映射到内存中。因此，文件就成为RAM中的一个字节数组，应用程序就可直接访问数组元素，而不需要调用<code>read()、write()</code>或<code>lseek()</code>。</li>
<li><strong>直接I/O模式</strong>：直接I/O模式下文件打开后，标志<code>O_DIRECT</code>置1。任何读写操作都将数据在用户态地址空间与磁盘间直接传送而不通过页高速缓存。</li>
<li><strong>异步模式</strong>：异步模式下，文件的访问可以有两种方法，即通过一组POSIX API或Linux特有的系统调用实现。所谓异步模式就是<strong>数据传输请求并不阻塞调用进程，而是在后台执行，同时应用程序继续它的正常执行</strong>。</li>
</ul>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p><code>read()</code>和<code>write()</code>的服务例程最终会调用文件对象的<code>read</code>和<code>write</code>方法，这两个方法可能依赖文件系统。对于磁盘文件系统，这些方法能确定被访问的数据所在物理块的位置，并激活块设备驱动程序开始数据传送。</p>
<p>读文件是基于页的，内核总是一次传送几个完整的数据页。如果进程发出<code>read()</code>后，数据不在RAM中，内核就<strong>分配一个新页框，并使用文件的适当部分填充该页，把该页加入页高速缓存，最后把请求的字节拷贝到进程地址空间中</strong>。对于大部分文件系统，从文件中读取一个数据页等同于在磁盘上查找所请求的数据存放在哪些块上。大多数磁盘文件系统<code>read</code>方法由<code>generic_file_read()</code>通用函数实现。</p>
<p>对基于磁盘的文件，写操作比较复杂，因文件大小可改变，因此内核可能会分配磁盘上的一些物理块。很多磁盘文件系统通过<code>generic_file_write()</code>实现<code>write</code>方法。</p>
<h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><p><code>generic_file_read()</code>参数：</p>
<ul>
<li><code>filp</code>，文件对象的地址</li>
<li><code>buf</code>，用户态线性区的线性地址，从文件中读出的数据必须存在这里</li>
<li><code>count</code>，要读取的字符个数</li>
<li><p><code>ppos</code>，指向一个变量的指针，该变量存放读操作开始处的文件偏移量</p>
</li>
<li><p>第一步，初始化两个描述符。</p>
<ul>
<li>第一个描述符存放在类型为<code>iovec</code>局部变量<code>local_iov</code>中，它包含用户态缓冲区的地址（buf）和长度（count），缓冲区存放待读文件中的数据。</li>
<li>第二个描述符存放在类型为<code>kiocb</code>的局部变量<code>kiocb</code>中，它用来跟踪正在运行的同步和异步I/O操作的完成状态。</li>
</ul>
</li>
</ul>
<p><img src="/img/1604132638.png" alt=""></p>
<ul>
<li><code>generic_file_read()</code>通过执行宏<code>init_sync_kiocb</code>来初始化描述符<code>kiocb</code>，并设置<code>ki_key</code>字段为<code>KIOCB_SYNC_KEY、ki_flip</code>字段为<code>filp</code>、<code>ki_obj</code>字段为<code>current</code>。</li>
<li>然后，调用<code>__generic_file_aio_read()</code>并将刚填完<code>iovec</code>和<code>kiocb</code>描述符地址传给它。</li>
<li>最后该函数返回一个值，该值通常就是从文件有效读入的字节数。</li>
</ul>
<p><code>__generic_file_aio_read()</code>是所有文件系统实现同步和异步操作所使用的通用例程。参数：<code>kiocb</code>描述符的地址<code>iocb</code>、<code>iovec</code>描述符数组的地址<code>iov</code>、数组的长度和存放文件当前指针的一个变量的地址<code>ppos</code>。<code>iovec</code>描述符数组被函数<code>generic_file_read()</code>调用时只有一个元素，描述待接收数据的用户态缓冲区。</p>
<p><code>__generic_file_aio_read()</code>执行步骤：</p>
<ol>
<li>调用<code>access_ok()</code>检查<code>iovec</code>描述符所描述的用户态缓冲区是否有效。因为起始地址和长度已经从<code>sys_read()</code>服务例程得到，因此在使用前需要对它们进行检查，无效时返回错误代码-EFAULT。</li>
<li>建立一个读操作描述符，即一个<code>read_descriptor_t</code>类型的数据结构。该结构存放<strong>单个用户态缓冲相关的文件读操作的当前状态</strong>。</li>
<li>调用<code>do_generic_file_read()</code>，传送给它文件对象指针<code>filp</code>、文件偏移量指针<code>ppos</code>、刚分配的读操作描述符的地址和函数<code>file_read_actor()</code>的地址。</li>
<li>返回拷贝到用户态缓冲区的字节数，即<code>read_descriptor_t</code>中<code>written</code>字段值。</li>
</ol>
<p><img src="/img/1604156377.jpg" alt=""></p>
<p><code>do_generic_file_read()</code>从磁盘读入所请求的页并把它们拷贝到用户态缓冲区。步骤如下：</p>
<ol>
<li>获得要读取的文件对应的<code>address_space</code>对象，它的地址存放在<code>filp-&gt;f_mapping</code>。</li>
<li>获得地址空间对象的所有者，即索引节点对象，它将拥有填充了文件数据的页面。它的地址存放在<code>address_space</code>对象的<code>host</code>字段。如果所读文件是块设备文件，那么所有者就不是由<code>filp-&gt;f_dentry-&gt;d_inode</code>所指向的索引节点对象，而是<code>bdev</code>特殊文件系统中的索引节点对象。</li>
<li>把文件看作细分的数据页（每页4096字节），并从文件指针<code>*ppos</code>导出一个请求字节所在页的逻辑号，即地址空间中的页索引，并存放在<code>index</code>局部变量中。把第一个请求字节在页内的偏移量存放在<code>offset</code>局部变量中。</li>
<li>开始一个循环来读入包含请求字节的所有页，要读数据的字节数存放在<code>read_descriptor_t</code>描述符的<code>count</code>字段中。每次循环中，通过下述步骤传送一个数据页：<ol>
<li>如果<code>index*4096+offset</code>超过索引节点对象的<code>i_size</code>字段中的文件大小，则从循环退出，并跳到第5步。</li>
<li>调用<code>cond_resched()</code>检查当前进程的标志<code>TIF_NEED_RESCHED</code>。如果标志置位，则调用<code>schedule()</code>。</li>
<li>如果有预读的页，则调用<code>page_cache_readahead()</code>读入这些页。</li>
<li>调用<code>find_get_page()</code>，参数为指向<code>address_space</code>对象的指针及索引值；它将查找页高速缓存已找到包含所请求数据的页描述符。</li>
<li>如果<code>find_get_page()</code>返回NULL指针，则所请求的页不在页高速缓存中，则执行如下步骤：<ol>
<li>调用<code>handle_ra_miss()</code>来调用预读系统的参数。</li>
<li>分配一个新页。</li>
<li>调用<code>add_to_page_cache()</code>将该新页描述符插入到页高速缓存，该函数将新页的<code>PG_locked</code>标志置位。</li>
<li>调用<code>lru_cache_add()</code>将新页描述符插入到LRU链表。</li>
<li>跳到第4j步，开始读文件数据。</li>
</ol>
</li>
<li>如果函数已运行至此，说明页已经位于页高速缓存中。检查标志<code>PG_uptodate</code>，如果置位，则页中的数据是最新的，因此无需从磁盘读数据，跳到第4m步。</li>
<li>页中的数据是无效的，因此必须从磁盘读取。函数通过调用<code>lock_page()</code>获取对页的互斥访问。如果<code>PG_locked</code>已经置位，则<code>lock_page()</code>阻塞当前进程直到标志被清0。</li>
<li>现在页已由当前进程锁定。但另一个进程也许会在上一步之前已从页高速缓存中删除该页，那么，它就要检查页描述符的<code>mapping</code>字段是否为NULL。如果是，调用<code>unlock_page()</code>解锁页，并减少它的引用计数（<code>find_get_page()</code>增加计数），并跳到第4a步重读同一页。</li>
<li>至此，页已经被锁定且在高速缓存中。再次检查标志<code>PG_uptodate</code>，因为另一个内核控制路径可能已经完成第4f步和第4g步的必要读操作。如果标志置位，则调用<code>unlock_page()</code>并跳到第4m来跳过读操作。</li>
<li>现在真正的I/O操作可以开始了，调用文件的<code>address_space</code>对象的<code>readpage</code>方法。相应的函数会负责激活磁盘到页之间的I/O数据传输。</li>
<li>如果<code>PG_uptodate</code>还没有置位，则它会等待直到调用<code>lock_page()</code>后页被有效读入。该页在第4g步中锁定，一旦读操作完成就被解锁，因此当前进程在I/O数据传输完成时停止睡眠。</li>
<li>如果<code>index</code>超出文件包含的页数（通过将<code>inode</code>对象的<code>i_size</code>字段的值除以4096得到），那么它将减少页的引用计数器，并跳出循环到第5步。这种情况发生在这个正被本进程读的文件同时有其他进程正在删减它时。</li>
<li>将应该拷入用户态缓冲区的页中的字节数存放在局部变量<code>nr</code>中。该值的大小等于页的大小（4096字节），除非<code>offset</code>非0或请求数据不全在该文件中。</li>
<li>调用<code>mark_page_accessed()</code>将标志<code>PG_referenced</code>或<code>PG_active</code>置位，从而表示该页正被访问且不应该被换出。如果同一文件在<code>do_generic_file_read()</code>的后续执行中要读几次，则该步骤只在第一次读时执行。</li>
<li>把页中的数据拷贝到用户态缓冲区。调用<code>file_read_actor()</code>执行下列步骤：<ol>
<li>调用<code>kmap()</code>，该函数为处于高端内存中的页建立永久的内核映射。</li>
<li>调用<code>__copy_to_user()</code>把页中的数据拷贝到用户态地址空间。该操作在访问用户态地址空间时如果有缺页异常将会阻塞进程。</li>
<li>调用<code>kunmap()</code>释放页的任一永久内核映射。</li>
<li>更新<code>read_descriptor_t</code>描述符的<code>count</code>、<code>written</code>和<code>buf</code>字段。</li>
</ol>
</li>
<li>根据传入用户态缓冲区的有效字节数更新局部变量<code>index</code>和<code>count</code>。一般，如果页的最后一个字节已拷贝到用户态缓冲区，则<code>index</code>的值加1而<code>offset</code>的值清0；否则，<code>index</code>的值不变而<code>offset</code>的值被设为已拷贝到用户态缓冲区的字节数。</li>
<li>减少页描述符的引用计数器。</li>
<li>如果<code>read_descriptor_t</code>描述符的<code>count</code>字段不为0，则文件中还有其他数据要读，跳到第4a步继续循环读文件的下一页数据。</li>
</ol>
</li>
<li>所请求的或可以读到的数据已读完。函数更新预读数据结构<code>filp-&gt;f_ra</code>来标记数据已被顺序从文件读入。</li>
<li>把<code>index*4096+offset</code>值赋给<code>*ppos</code>，从而保存以后调用<code>read()</code>和<code>write()</code>进行顺序访问的位置。</li>
<li>调用<code>update_atime()</code>把当前时间存放在文件的索引节点对象<code>i_atime</code>字段，并把它标记为脏后返回。</li>
</ol>
<p>总结：创建读操作请求；检查是否已读完、重新调度、预读页、在页高速缓存中、页被锁定、页中的数据是否为最新，并进行相应处理；把页中的数据拷贝到用户态缓冲区；更新读操作相关</p>
<h4 id="普通文件的readpage方法"><a href="#普通文件的readpage方法" class="headerlink" title="普通文件的readpage方法"></a>普通文件的readpage方法</h4><p><code>do_generic_file_read()</code>反复使用<code>readpage</code>方法把一个个页从磁盘读到内存。</p>
<p><code>address_space</code>对象的<code>readpage</code>方法存放的是函数地址，有效激活从物理磁盘到页高速缓存的I/O数据传送。对于普通文件，该字段通常指向<code>mpage_readpage()</code>的封装函数。如Ext3文件系统的<code>readpage</code>方法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">exit3_readpage</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> mpage_readpage(page, ext3_get_block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mpage_readpage()</code>参数为待填充页的页描述符<code>page</code>及有助于<code>mpage_readpage()</code>找到正确块的函数的地址<code>get_block</code>。该函数把相对于文件开始位置的块号转换为相对于磁盘分区中块位置的逻辑块号。所传递的<code>get_block</code>函数总是用缓冲区首部来存放有关重要信息，如块设备（<code>b_dev</code>字段）、设备上请求数据的位置（<code>b_blocknr</code>字段）和块状态（<code>b_state</code>字段）。</p>
<p><code>mpage_readpage()</code>在从磁盘读入一页时可选择两种不同的策略：</p>
<ul>
<li>如果包含请求数据的块在磁盘上是连续的，就用单个<code>bio</code>描述符向通用块城发出读I/O操作。</li>
<li>如果不连续，就对页上的每一块用不同的<code>bio</code>描述符来读。</li>
</ul>
<p><code>get_block</code>依赖文件系统，它的一个重要作用是：<strong>确定文件中的下一块在磁盘上是否也是下一块</strong>。</p>
<p><code>mpage_readpage()</code>执行下列步骤：</p>
<ol>
<li>检查页描述符的<code>PG_private</code>字段：如果置位，则该页是缓冲区页，即该页与描述组成该页的块的缓冲区首部链表相关。这意味着该页已从磁盘读入过，且页中的块在磁盘上不是相邻的。跳到第11步，用一次读一块的方式读该页。</li>
<li>得到块的大小（存放在<code>page-&gt;mapping-&gt;host-&gt;i_blkbits</code>索引节点字段），然后计算出访问该页的所有块所需要的两个值，即页中的块数和页中第一块的文件块号（相对于文件起始位置页中第一块的索引）。</li>
<li>对于页中的每一块，调用依赖于文件系统的<code>get_block</code>函数，得到逻辑块号，即相对于磁盘或分区开始位置的块索引。页中所有块的逻辑块号存放在一个本地数组中。</li>
<li>在执行上一步的同时，检查可能发生的异常条件。<ol>
<li>当一些块在磁盘上不相邻时，</li>
<li>某块落入“文件洞”内时，</li>
<li>一个块缓冲区已经由<code>get_block</code>函数写入时，</li>
<li>跳到第11步，用一次读一块的方式读该页。</li>
</ol>
</li>
<li>至此，说明页中的所有块在磁盘上是相邻的。但它可能是文件中的最后一页，因此，页中的一些块可能在磁盘上没有映像。如果这样，它将页中相应块缓冲区填上0；如果不是，将页描述符的标志<code>PG_mappedtodisk</code>置位。</li>
<li>调用<code>bio_alloc()</code>分配包含单一段的一个新<code>bio</code>描述符，并分别用块设备描述符地址和页中第一个块的逻辑块号来初始化<code>bi_bdev</code>字段和<code>bi_sector</code>字段。这两个信息已在第3步中得到。</li>
<li>用页的起始地址、所读数据的首字节偏移量（0）和所读字节总数设置<code>bio</code>段的<code>bio_vec</code>描述符。</li>
<li><code>bio-&gt;bi_end_io</code>的值为<code>mpage_end_io_read()</code>的地址。</li>
<li>调用<code>submit_bio()</code>将数据传输的方向设定<code>bi_rw</code>标志，更新每<code>CPU</code>变量<code>page_states</code>来跟踪所读扇区数，并在<code>bio</code>描述符上调用<code>generic_make_request()</code>。</li>
<li>返回0（成功）。</li>
<li>如果函数跳到这里，则页中含有的块在磁盘上不连续。如果页是最新的（<code>PG_uptodate</code>置位），函数就调用<code>unlock_page()</code>对该页解锁；否则调用<code>block_read_full_page()</code>用一次读一块的方式读该页。</li>
<li>返回0（成功）。</li>
</ol>
<p><code>mapge_end_io_read()</code>是<code>bio</code>的完成方法，一旦I/O数据传输结束它就开始执行。假定没有I/O错误，将页描述符的标志<code>PG_uptodate</code>置位，调用<code>unlock_page()</code>解锁该页并唤醒相应睡眠的进程，然后调用<code>bio_put()</code>清除<code>bio</code>描述符。</p>
<h4 id="块设备文件的readpage方法"><a href="#块设备文件的readpage方法" class="headerlink" title="块设备文件的readpage方法"></a>块设备文件的readpage方法</h4><p>在<code>bdev</code>特殊文件系统中，块设备使用<code>address_space</code>对象，该对象存放在对应块设备索引节点的<code>i_data</code>字段。块设备文件的<code>readpage</code>方法总是相同的，由<code>blkdev_readpage()</code>实现，该函数调用<code>block_read_full_page()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">blkdev_readpage</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> *page page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> block_read_full_page(page, blkdev_get_block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>block_read_full_page()</code>的第二个参数也指向一个函数，该函数把相对于文件开始出的文件块号转换为相对于块设备开始处的逻辑块号。但对于块设备文件来说，这两个数是一致的。<code>blkdev_get_block()</code>执行下列步骤：</p>
<ol>
<li>检查页中第一个块的块号是否超过块设备的最后一块的索引值（<code>bdev-&gt;bd_inode-&gt;i_size/bdev-&gt;bd_block_size</code>得到索引值，<code>bdev</code>指向块设备描述符）。如果超过，则对于写操作它将返回-EIO，而对于读操作它将返回0。</li>
<li>设置缓冲区首部的<code>bdev</code>字段为<code>b_dev</code>。</li>
<li>设置缓冲区首部的<code>b_blocknr</code>字段为文件块号，它将作为参数传递给本函数。</li>
<li>把缓冲区首部的<code>BH_Mapped</code>标志置位，以表明缓冲区首部的<code>b_dev</code>和<code>b_blocknr</code>字段是有效的。</li>
</ol>
<p><code>block_read_full_page()</code>以一次读一块的方式读一页数据。</p>
<ol>
<li>检查页描述符的标志<code>PG_private</code>，如果置位，则该页与描述组成该页的块的缓冲区首部链表相关；否则，调用<code>create_empty_buffers()</code>为该页所含的所有块缓冲区分配缓冲区首部。页中第一个缓冲区的缓冲区首部地址存放在<code>page-&gt;private</code>字段中。每个缓冲区首部的<code>b_this_page</code>字段指向该页中下一个缓冲区的缓冲区首部。</li>
<li>从相对于页的文件偏移量（<code>page-&gt;index</code>字段）计算出页中第一块的文件块号。</li>
<li>对该页中的每个缓冲区的缓冲区首部，执行如下步骤：<ol>
<li>如果标志<code>BH_Uptodate</code>置位，则跳过该缓冲区继续处理该页的下一个缓冲区。</li>
<li>如果标志<code>BH_Mapped</code>未置位，且该块未超过文件尾，则调用<code>get_block</code>。<ol>
<li>对于普通文件，该函数在文件系统的磁盘数据结构中查找，得到相对于磁盘或分区开始处的缓冲区逻辑块号。</li>
<li>对于块设备文件，该函数把文件块号当作逻辑块号。</li>
<li>对这两种情形，函数都将逻辑块号存放在相应缓冲区首部的<code>b_blocknr</code>字段中，并将标志<code>BH_Mapped</code>置位。</li>
</ol>
</li>
<li>再检查标志<code>BH_Uptodate</code>，因为依赖于文件系统的<code>get_block</code>可能已触发块I/O操作而更新了缓冲区。如果<code>BH_Uptodate</code>置位，则继续处理该页的下一个缓冲区。</li>
<li>将缓冲区首部的地址存放在局部数组<code>arr</code>中，继续该页的下一个缓冲区。</li>
</ol>
</li>
<li>假如上一步中没有遇到“文件洞”，则将该页的标志<code>PG_mappedtodisk</code>置位。</li>
<li>现在局部变量<code>arr</code>中存放了一些缓冲区首部的地址，与其对应的缓冲区的内容不是最新的。如果数组为空，那么页中的所有缓冲区都是有效的，因此，该函数设置页描述符的<code>PG_uptodate</code>标志，调用<code>unlock_page()</code>对该页解锁并返回。</li>
<li>局部数组<code>arr</code>非空。对数组中的每个缓冲区首部，执行下述步骤：<ol>
<li>将<code>BH_Lock</code>标志置位。该标志一旦置位，就一直等待该缓冲区释放。</li>
<li>将缓冲区首部的<code>b_end_io</code>字段设置为<code>end_buffer_async_read()</code>的地址，并将缓冲区首部的<code>BH_Async_Read</code>标志置位。</li>
</ol>
</li>
<li>对局部数组<code>arr</code>中的每个缓冲区首部调用<code>submit_bh()</code>，将操作类型设为<code>READ</code>，该函数触发了相应块的I/O数据传输。</li>
<li>返回0。</li>
</ol>
<p><code>end_buffer_async_read()</code>在对缓冲区的I/O数据传输结束后就执行。假定没有I/O错误，将缓冲区首部的<code>BH_Uptodate</code>标志置位而将<code>BH_Async_Read</code>标志置0。那么，函数就得到包含块缓冲区的缓冲区页描述符，同时检测页中所有块是否是最新的，如果是，将该页的<code>PG_uptodate</code>标志置位并调用<code>unlock_page()</code>。</p>
<h3 id="文件的预读"><a href="#文件的预读" class="headerlink" title="文件的预读"></a>文件的预读</h3><p>预读在实际请求前读普通文件或块设备文件的几个相邻的数据页。预读能使磁盘控制器处理较少的命令，提高系统的响应能力。但是对随机访问的文件没有用，甚至是有害的，因为浪费了页高速缓存的空间。</p>
<p>文件的预读需要复杂的算法，原因如下：</p>
<ul>
<li>由于数据是逐页读取的，因此预读算法不必考虑页内偏移量，只要考虑所访问的页在文件内部的位置就可以了。</li>
<li>只要进程持续地顺序访问一个文件，预读就会逐渐增加。</li>
<li>当前的访问与上一次访问不是顺序时，预读就会逐渐减少乃至禁止。</li>
<li>当一个进程重复地访问同一页，或当几乎所有的页都已在页高速缓存时，预读必须停止。</li>
<li>低级I/O设备驱动程序必须在合适的时候激活，这样当将来进程需要时，页已传送完毕。</li>
</ul>
<p>当访问给定文件时，预读算法使用两个页面集，<strong>当前窗</strong>和<strong>预读窗</strong>，各自对应文件的一个连续区域。<strong>当前窗内的页是进程请求的页和内核预读的页，且位于页高速缓存内</strong>（当前窗内的页不必是最新的，因为I/O数据传输仍可能在运行）。<strong>当前窗包含进程顺序访问的最后一页，且可能由内核预读但进程未请求的页</strong>。</p>
<p><strong>预读窗内的页紧接着当前窗内的页，它们是内核正在预读的页</strong>。预读窗内的页都不是进程请求的，但内核假定进程迟早会请求。当内核认为是顺序访问且第一页在当前窗内时，它就检测是否建立了预读窗。如果没有，内核就创建一个预读窗并触发相应页的读操作。理想情况下，进程继续从当前窗请求页，同时预读窗的页则正在传送。当进程请求的页在预读窗，则预读窗就成为当前窗。</p>
<p>预读算法使用的主要数据结构是<code>file_ra_state</code>描述符，存放于每个文件对象的<code>f_ra</code>字段。<br><img src="/img/1604160114.jpg" alt=""></p>
<p>当一个文件被打开时，在它的<code>file_ra_state</code>描述符中，除了<code>prev_page</code>和<code>ra_pages</code>这两个字段，其他的所有字段都置为0。<code>prev_page</code>存放进程上一次读操作中所请求页的最后一页的索引。初值为-1。</p>
<p><code>ra_pages</code>表示当前窗的最大页数，即对该文件允许的最大预读量。初值在该文件所在块设备的<code>backing_dev_info</code>描述符。可以修改一个打开文件的<code>ra_pages</code>从而调整预读算法，具体实现为调用<code>posix_fadvise()</code>，并传送给<code>POSIX_FADV_NORMAL</code>（最大预读量为缺省值32页），<code>POSIX_FADV_SEQUENTIAL</code>（最大预读量为缺省值的2倍），<code>POSIX_FADV_RAMDOM</code>（最大预读量为0）。</p>
<p><code>flags</code>字段内有两个重要的字段<code>RA_FLAG_MISS</code>和<code>RA_FLAG_INCACHE</code>。如果已被预读的页不在页高速缓存内，则第一个标志置位，这时下一个要创建的预读窗大小将被缩小。当内核确定进程请求的最后256页都在页高速缓存内时（连续高速缓存命中数存放在<code>ra-&gt;cache_hit</code>字段中），第二个标志置位，这时内核认为所有的页都已在高速缓存内，关闭预读。</p>
<p>执行预读算法的时机：</p>
<ul>
<li>当内核用用户态请求读文件数据页时。触发<code>page_cache_readahead()</code>。</li>
<li>当内核为文件内存映射分配一页时。</li>
<li>当用户态应用执行<code>readahead()</code>系统调用时，对某个文件描述符显式触发某预读活动。</li>
<li>当用户态应用使用<code>POSIX_FADV_NOREUSE</code>或<code>POSIX_FADV_WILLNEED</code>命令执行<code>posix_fadvise()</code>系统调用时，它会通知内核，某个范围的文件页不久将要被访问。</li>
<li>当用户态应用使用<code>MADV_WILLNEED</code>命令执行<code>madvise()</code>系统调用时，它会通知内核，某个文件内存映射区域中的给定范围的文件页不久将要被访问。</li>
</ul>
<h4 id="page-cache-readahead"><a href="#page-cache-readahead" class="headerlink" title="page_cache_readahead()"></a>page_cache_readahead()</h4><p><strong>处理没有被特殊系统调用显式触发的所有预读操作</strong>。它填写当前窗和预读窗，根据预读命中数更新当前窗和预读窗的大小，即根据过去对文件访问预读策略的成功程度调整。</p>
<p>当内核必须满足对某个文件一页或多页的读请求时，函数就被调用，参数如下：</p>
<ul>
<li><code>mapping</code>，描述页所有者的<code>address_space</code>对象指针</li>
<li><code>ra</code>，包含该页的文件<code>file_ra_state</code>描述符指针</li>
<li><code>filp</code>，文件对象地址</li>
<li><code>offset</code>，文件内页的偏移量</li>
<li><code>req_size</code>，完成当前读操作还需读的页数</li>
</ul>
<p><img src="/img/1604237045.jpg" alt=""></p>
<p><code>page_cache_readahead()</code>作用于<code>file_ra_state</code>描述符的字段。</p>
<p>当进程第一次访问一个文件，且其第一个请求页是文件中偏移量为0的页时，函数假定进程要进行顺序访问。那么，从第一页创建一个新的当前窗。初始当前窗的长度与进程第一个读操作所请求的页数有关。请求的页数越大，当前窗就越大，一直到最大值，即<code>ra-&gt;ra_pages</code>。反之，当进程第一次访问文件，但第一个请求页在文件中的偏移量不为0时，函数假定进程不是执行顺序读。那么，禁止预读（<code>ra-&gt;size=-1</code>）。但当预读暂时被禁止而函数又认为需要顺序读时，将建立一个新的当前窗。</p>
<p>预读窗总是从当前窗的最后一页开始。但它的长度与当前窗的长度相关：如果<code>RA_FLAG_MISS</code>标志置位，则预读窗长度为当前窗长度减2，小于4时设为4；否则，预读窗长度为当前窗长度的4倍或2倍。如果进程继续顺序访问文件，最终预读窗会成为新的当前窗，新的预读窗被创建。</p>
<p>一旦函数认识到对文件的访问相对于上一次不是顺序的，当前窗与预读窗就被清空，预读被暂时禁止。当进程的读操作相对于上一次文件访问为顺序时，预读将重新开始。</p>
<p>每次<code>page_cache_readahead()</code>创建一个新窗，它就开始对所包含页的读操作。为了读一大组页，<code>page_cache_readahead()</code>调用<code>blockable_page_cache_readahead()</code>。为了减少内核开销，<code>blockable_page_cache_readahead()</code>采用下面灵活的方法：</p>
<ul>
<li>如果服务于块设备的请求队列是读拥塞的，就不进行读操作。</li>
<li>将要读的页与页高速缓存进行比较，如果该页已在页高速缓存内，跳过即可。</li>
<li>在从磁盘读前，读请求所需的全部页框是一次性分配的。如果不能一次性得到全部页框，预读操作就只在可以得到的页上进行。</li>
<li>只要可能，通过使用多段<code>bio</code>描述符向通用块层发出读操作。这通过<code>address_space</code>对象专用的<code>readpages</code>方法实现；如果没有定义，就通过反复调用<code>readpage</code>方法实现。</li>
</ul>
<h4 id="handle-ra-miss"><a href="#handle-ra-miss" class="headerlink" title="handle_ra_miss()"></a>handle_ra_miss()</h4><p>当预读策略不是十分有效，内核就必须修正预读参数。</p>
<p>如果进程<code>do_generic_file_read()</code>在第4c步调用<code>page_cache_readahead()</code>，有两种情形：</p>
<ul>
<li>请求页在当前窗或预读窗表明它已经被预先读入了；</li>
<li>或者还没有，则调用<code>blockable_page_cache_readahead()</code>来读入。</li>
</ul>
<p>在这两种情形下，<code>do_generic_file_read()</code>在第4d步中就在页高速缓存中找到了该页，如果没有，就表示该页框已经被收回算法从高速缓存中删除。这种情形下，<code>do_generic_file_read()</code>调用<code>handle_ra_miss()</code>，通过将<code>RA_FLAG_MISS</code>标志置位与<code>RA_FLAG_INCACHE</code>标志清0来调整预读算法。</p>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p><code>write()</code>涉及<strong>把数据从进程的用户态地址空间中移动到内核数据结构中，然后再移动到磁盘上</strong>。文件对象的<code>write</code>方法允许每种文件类型都定义一个专用的操作。Linux 2.6中，每个磁盘文件系统的<code>write</code>方法都是一个过程，主要表示<strong>写操作所涉及的磁盘块，把数据从用户态地址空间拷贝到页高速缓存的某些页中，然后把这些页中的缓冲区标记成脏</strong>。</p>
<p>许多文件系统通过<code>generic_file_write()</code>来实现文件对象的<code>write</code>方法，参数：</p>
<ul>
<li><code>file</code>，文件对象指针</li>
<li><code>buf</code>，用户态地址空间中的地址，必须从该地址获取要写入文件的字符</li>
<li><code>count</code>，要写入的字符个数</li>
<li><code>ppos</code>，存放文件偏移量的变量地址，必须从这个偏移量处开始写入</li>
</ul>
<p>执行以下操作：</p>
<ol>
<li>初始化<code>iovec</code>类型的一个局部变量，它包含用户态缓冲区的地址与长度。</li>
<li>确定所写文件索引节点对象的地址<code>inode</code>（<code>file-&gt;f_mapping-&gt;host</code>），获得信号量（<code>inode-&gt;i_sem</code>）。有了该信号量，一次只能有一个进程对某个文件发出<code>write()</code>系统调用。</li>
<li>调用<code>init_sync_kiocb</code>初始化<code>kiocb</code>类型的局部变量。将<code>ki_key</code>字段设置为<code>KIOCB_SYNC_KEY</code>、<code>ki_filp</code>字段设置为<code>filp</code>、<code>ki_obj</code>字段设置为<code>current</code>。</li>
<li>调用<code>__generic_file_aio_write_nolock()</code>将涉及的页标记为脏，并传递相应的参数：<code>iovec</code>和<code>kiocb</code>类型的局部变量地址、用户态缓冲区的段数和<code>ppos</code>。</li>
<li>释放<code>inode-&gt;i_sem</code>信号量。</li>
<li>检查文件的<code>O_SYNC</code>标志、索引节点的<code>S_SYNC</code>标志及超级块的<code>MS_SYNCHRONOUS</code>标志。如果至少一个标志置位，则调用<code>sync_page_range()</code>强制内核将页高速缓存中第4步涉及的所有页刷新，阻塞当前进程直到I/O数据传输结束。<code>sync_page_range()</code>先执行<code>address_space</code>对象的<code>writepage</code>方法或<code>mpage_writepages()</code>开始这些脏页的I/O传输，然后调用<code>generic_osync_inode()</code>将索引节点和相关缓冲区刷新到磁盘，最后调用<code>wait_on_page_bit()</code>挂起当前进程直到全部所刷新页的<code>PG_writeback</code>标志清0。</li>
<li>将<code>__generic_file_aio_write_nolock()</code>的返回值返回，通常是写入的有效字节数。</li>
</ol>
<p><code>__generic_file_aio_write_nolock()</code>参数：<code>kiocb</code>描述符的地址<code>iocb</code>、<code>iovec</code>描述符数组的地址<code>iov</code>、该数组的长度及存放文件当前指针的变量的地址<code>ppos</code>。当被<code>generic_file_write()</code>调用时，<code>iovec</code>描述符数组只有一个元素，该元素描述待写数据的用户态缓冲区。</p>
<p>仅讨论最常见的情形，对有页高速缓存的文件进行<code>write()</code>调用的一般情况。<code>__generic_file_aio_write_nolock()</code>执行如下步骤：</p>
<ol>
<li>调用<code>access_ok()</code>确定<code>iovec</code>描述符所描述的用户态缓冲区是否有效。无效时返回错误码-EFAULT。</li>
<li>确定待写文件（<code>file-&gt;f_mapping-&gt;host</code>）索引节点对象的地址<code>inode</code>。如果文件是一个块设备文件，这就是一个<code>bdev</code>特殊文件系统的索引节点。</li>
<li>将文件（<code>file-&gt;f_mapping-&gt;backing_dev_info</code>）的<code>backing_dev_info</code>描述符的地址设为<code>current-&gt;backing_dev_info</code>。实际上，即使相应请求队列是拥塞的，该设置也会允许当前进程写回<code>file-&gt;f_mapping</code>拥有的脏页。</li>
<li>如果<code>file-&gt;flags</code>的<code>O_APPEND</code>标志置位且文件是普通文件（非块设备文件），它将<code>*ppos</code>设为文件尾，从而新数据都将追加到文件的后面。</li>
<li>对文件大小进行几次检查。如，写操作不能把一个普通文件增大到超过每用户的上限或文件系统的上限，每用户上限存放在<code>current-&gt;signal-&gt;rlim[RLIMIT_FSIZE]</code>，文件系统上限存放在<code>inode-&gt;i_sb-&gt;s_maxbytes</code>。另外，如果文件不是“大型文件”（当<code>file-&gt;f_flags</code>的<code>O_LARGEFILE</code>标志清0时），则其大小不能超过2GB。如果没有设定上述限制，它就减少待写字节数。</li>
<li>如果设定，则将文件的<code>suid</code>标志清0，如果是可执行文件的话就将<code>sgid</code>标志也清0。</li>
<li>将当前时间存放在<code>inode-&gt;mtime</code>字段（文件写操作的最新时间）中，也存放在<code>inode-&gt;ctime</code>字段（修改索引节点的最新时间）中，且将索引节点对象标记为脏。</li>
<li>开始循环以更新写操作中涉及的所有文件页。每次循环期间，执行下列子步骤：<ol>
<li>调用<code>find_lock_page()</code>在页高速缓存中搜索该页。如果找到，则增加引用计数并将<code>PG_locked</code>标志置位。</li>
<li>如果该页不在页高速缓存中，则分配一个新页框并调用<code>add_to_page_cache()</code>在页高速缓存内插入此页。增加引用计数并将<code>PG_locked</code>标志置位。在内存管理区的非活动链表中插入一页。</li>
<li>调用索引节点（<code>file-&gt;f_mapping</code>）中<code>address_space</code>对象的<code>prepare_write</code>方法。为该页分配和初始化缓冲区首部。</li>
<li>如果缓冲区在高端内存中，则建立用户态缓冲区的内核映射，然后调用<code>__copy_from_user()</code>把用户态缓冲区中的字符拷贝到页中，并释放内核映射。</li>
<li>调用索引节点（<code>file-&gt;f_mapping</code>）中<code>address_space</code>对象的<code>commit_write</code>方法，把基础缓冲区标记为脏。</li>
<li>调用<code>unlock_page()</code>清<code>PG_locked</code>标志，并唤醒等待该页的任何进程。</li>
<li>调用<code>mark_page_accessed()</code>为内存回收算法更新页状态。</li>
<li>减少页引用计数来撤销第8a或8b步中的增加值。</li>
<li>在这一步，还有一页被标记为脏，检查页高速缓存中脏页比例是否超过一个固定的阈值（通常为系统中页的40%)。如果是，调用<code>writeback_inodes()</code>刷新几十页到磁盘。</li>
<li>调用<code>cond_resched()</code>检查当前进程的<code>TIF_NEED_RESCHED</code>标志。如果该标志置位，则调用<code>schedule()</code>。</li>
</ol>
</li>
<li>现在，写操作中所涉及的文件的所有页都已处理。更新<code>*ppos</code>的值，让它正好指向最后一个被写入的字符之后的位置。</li>
<li>设置<code>current-&gt;backing_dev_info</code>为NULL。</li>
<li>返回写入文件的有效字符数后结束。</li>
</ol>
<p>总结：检查；判断是写入还是追加；如果页不在缓存中则添加到缓存中，并标记为脏；如果脏页过多则刷新到磁盘；返回写入字符数。</p>
<h4 id="普通文件的prepare-write和commit-write方法"><a href="#普通文件的prepare-write和commit-write方法" class="headerlink" title="普通文件的prepare_write和commit_write方法"></a>普通文件的prepare_write和commit_write方法</h4><p><code>address_space</code>对象的<code>prepare_write</code>和<code>commit_write</code>方法专门用于由<code>generic_file_write()</code>实现的通用写操作，适用于普通文件和块设备文件。</p>
<p>每个磁盘文件系统都定义了自己的<code>prepare_write</code>方法。Ext2文件系统：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ext2_prepare_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> page *page, <span class="type">unsigned</span> from, <span class="type">unsigned</span> to)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> block_prepare_write(page, from, to, ext2_get_block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ext2_get_block()</code>把相对于文件的块号转换为逻辑块号。</p>
<p><code>block_prepare_write()</code>为文件页的缓冲区和缓冲区首部做准备：</p>
<ol>
<li>检查某页是否是一个缓冲区页（如果是则<code>PG_Private</code>标志置位）；如果该标志清0，则调用<code>create_empty_buffers()</code>为页中所有的缓冲区分配缓冲区首部。</li>
<li>对于页中包含的缓冲区对应的每个缓冲区首部，及受写操作影响下每个缓冲区首部，执行下列操作：<ol>
<li>如果<code>BH_New</code>标志置位，则将它清0。</li>
<li>如果<code>BH_New</code>标志已清0，则执行下列子步骤：<ol>
<li>调用依赖于文件系统的函数，该函数的地址<code>get_block</code>以参数形式传递过来。查看这个文件系统磁盘数据结构并查找缓冲区的逻辑块号（相对于磁盘分区的起始位置）。与文件系统相关的函数把这个数存放在对应缓冲区首部的<code>b_blocknr</code>字段，并设置它的<code>BH_Mapped</code>标志。与文件系统相关的函数可能为文件分配一个新的物理块，这种情况下，设置<code>BH_New</code>标志。</li>
<li>检查<code>BH_New</code>标志的值；如果被置位，则调用<code>unmap_underlying_metadata()</code>检查页高速缓存内的某个块设备缓冲区是否包含指向磁盘同一块的一个缓冲区。实际上调用<code>__find_get_block()</code>在页高速缓存内查找一个旧块。如果找到一块，将<code>BH_Dirty</code>标志清0并等待直到该缓冲区的I/O数据传输完毕。此外，如果写操作不对整个缓冲区进行重写，则用0填充未写区域，然后考虑页中的下一个缓冲区。</li>
</ol>
</li>
<li>如果写操作不对整个缓冲区进行重写且它的<code>BH_Delay</code>和<code>BH_Uptodate</code>标志未置位（已在磁盘文件系统数据结构中分配了块，但RAM中的缓冲区没有有效的数据映射），函数对该块调用<code>ll_rw_block()</code>从磁盘读取它的内容。</li>
</ol>
</li>
<li>阻塞当前进程，直到在第2c步触发的所有读操作全部完成。</li>
<li>返回0。</li>
</ol>
<p>一旦<code>prepare_write</code>方法返回，<code>generic_file_write()</code>就用存放在用户态地址空间中的数据更新页。接下来，调用<code>address_space</code>对象的<code>commit_write</code>方法。该方法由<code>generic_commit_write()</code>实现，几乎适用于所有非日志型磁盘文件系统。</p>
<p><code>generic_commit_write()</code>执行下列步骤：</p>
<ol>
<li>调用<code>__block_commit_write()</code>，然后依次执行如下步骤：<ol>
<li>考虑页中受写操作影响的所有缓冲区；对于其中的每个缓冲区，将对应缓冲区首部的<code>BH_Uptodate</code>和<code>BH_Dirty</code>标志置位。</li>
<li>标记相应索引节点为脏，这需要将索引节点加入超级块脏的索引节点链表。</li>
<li>如果缓冲区页中的所有缓冲区是最新的，则将<code>PG_uptodate</code>标志置位。</li>
<li>将页的<code>PG_dirty</code>标志置位，并在基树中将页标记成脏。</li>
</ol>
</li>
<li>检查写操作是否将文件增大。如果增大，则更新文件索引节点对象的<code>i_size</code>字段。</li>
<li>返回0。</li>
</ol>
<h4 id="块设备文件的prepare-write和commit-write方法"><a href="#块设备文件的prepare-write和commit-write方法" class="headerlink" title="块设备文件的prepare_write和commit_write方法"></a>块设备文件的prepare_write和commit_write方法</h4><p>写入块设备文件的操作类似于对普通文件的相应操作。块设备文件的<code>address_space</code>对象的<code>prepare_write</code>方法通常由下列函数实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">blkdev_prepare_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> page *page, <span class="type">unsigned</span> from, <span class="type">unsigned</span> to)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> block_prepare_write(page, from, to, blkdev_get_block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>与之前的<code>block_prepare_write()</code>唯一的差异在第二个参数，它是一个指向函数的指针，该函数必须把相对于文件开始处的文件块号转换为相对与块设备开始处的逻辑块号。对于块设备文件，这两个数是一致的。</p>
<p>块设备文件的<code>commit_write()</code>方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">blkdev_commit_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> page *page, <span class="type">unsigned</span> from, <span class="type">unsigned</span> to)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> block_commit_write(page, from, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用于块设备的<code>commit_write</code>方法与用于普通文件的<code>commit_write</code>方法本质上做同样的事情。唯一的差异是这个方法不检查写操作是否扩大了文件，因为不可能在块设备文件的末尾追加字符。</p>
<h3 id="把脏页写到磁盘"><a href="#把脏页写到磁盘" class="headerlink" title="把脏页写到磁盘"></a>把脏页写到磁盘</h3><p>通常I/O数据传输是延迟进行的。</p>
<p>当内核要启动有效I/O数据传输时，就调用文件<code>address_space</code>对象的<code>writepages</code>方法，它在基树中寻找脏页，并把它们刷新到磁盘。如Ext2文件系统：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ext2_writepages</span><span class="params">(<span class="keyword">struct</span> address_space *mapping, <span class="keyword">struct</span> writeback_control *wbc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> mpage_writepages(mapping, wbc, ext2_get_block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<code>mpage_writepages()</code>，如果没有定义<code>writepages</code>方法，内核直接调用<code>mpage_writepages()</code>并把NULL传给第三个参数。<code>ext2_get_block()</code>将文件块号转换成逻辑块号。</p>
<p><code>writeback_control</code>数据结构是一个描述符，它控制<code>writeback</code>写操作如何执行。</p>
<p><code>mpage_writepages()</code>执行下列步骤：</p>
<ol>
<li>如果请求队列写拥塞，但进程不希望阻塞，则不向磁盘写任何页就返回。</li>
<li>确定文件的首页，如果<code>writeback_control</code>描述符给定一个文件内的初始位置，将它转换成索引。否则，如果<code>writeback_control</code>描述符指定进程无需等待I/O数据传输结束，它将<code>mapping-&gt;writeback_index</code>的值设为初始页索引。最后，如果进程必须等待数据传输完毕，则从文件的第一页开始扫描。</li>
<li>调用<code>find_get_pages_tag()</code>在页高速缓存中查找脏页描述符。</li>
<li>对上一步得到的每个页描述符，执行下述步骤：<ol>
<li>调用<code>lock_page()</code>锁定该页。</li>
<li>确认页是有效的并在页高速缓存内。</li>
<li>检查页的<code>PG_writeback</code>标志。如果置位，表明页已被刷新到磁盘。如果进程必须等待I/O数据传输完毕，则调用<code>wait_on_page_bit()</code>在<code>PG_writeback</code>清0前一直阻塞当前进程；函数结束时，以前运行的任何<code>writeback</code>操作都被终止。否则，如果进程无需等待，它将检查<code>PG_dirty</code>标志，如果清0，则正在运行的写回操作将处理该页，将它解锁并跳回第4a步继续下一页。</li>
<li>如果<code>get_block</code>参数是NULL，它将调用文件<code>address_space</code>对象的<code>mapping-&gt;writepage</code>方法将页刷新到磁盘。否则，如果<code>get_block</code>参数不是NULL，就调用<code>mpage_writepage()</code>。详见第8步。</li>
</ol>
</li>
<li>调用<code>cond_resched()</code>检查当前进程的<code>TIF_NEED_RESCHED</code>标志，如果置位就调用<code>schedule()</code>。</li>
<li>如果函数没有扫描完给定范围内的所有页，或写到磁盘的有效页数小于<code>writeback_control</code>描述符中原先的给定值，则跳回第3步。</li>
<li>如果<code>writeback_control</code>描述符没有给定文件内的初始位置，它将最后一个扫描页的索引值赋给<code>mapping-&gt;writeback_index</code>字段。</li>
<li>如果在第4d步中调用了<code>mpage_writepage()</code>，且返回了<code>bio</code>描述符地址，则调用<code>mpage_bio_submit()</code>。</li>
</ol>
<p>像Ext2这样的典型文件系统的<code>writepage</code>方法是一个通用的<code>block_write_full_page()</code>的封装函数。并将依赖于文件系统的<code>get_block()</code>传给它.</p>
<p><code>block_write_full_page()</code>分配页缓冲区首部（如果还不在缓冲区页中），对每页调用<code>submit_bh()</code>指定<code>WRITE</code>操作。对于块设备文件，<code>block_write_full_page()</code>的封装函数为<code>blkdev_writepage()</code>，来实现<code>writepage</code>方法。</p>
<p>许多非日志文件系统依赖于<code>mpage_writepage()</code>而不是自定义的<code>writepage</code>方法。这样能改善性能，因为<code>mpage_writepage()</code>在I/O传输中可将尽可能多的页聚集在一个<code>bio</code>描述符。有利于块设备驱动程序利用硬盘控制器的DMA分散-聚集能力。</p>
<p><code>mpage_writepage()</code>将检查：<strong>待写页包含的块在磁盘上是否不相邻</strong>，<strong>该页是否包含文件洞</strong>，<strong>页上的某块是否没有脏或不是最新的</strong>。如果以上至少一条成立，就仍然用依赖于文件系统的<code>writepage</code>方法；否则，将页追加为<code>bio</code>描述符的一段。<code>bio</code>描述符的地址将作为参数被传给函数；如果为NULL，<code>mpage_writepage()</code>将初始化一个新的<code>bio</code>描述符并将地址返回给调用函数，调用函数未来调用<code>mpage_writepage()</code>时再将该地址传回。这样，同一个<code>bio</code>可加载几个页。如果<code>bio</code>中某页与上一个加载页不相邻，<code>mpage_writepage()</code>就调用<code>mpage_bio_submit()</code>开始该<code>bio</code>的I/O数据传输，并为该页分配一个新的<code>bio</code>。</p>
<p><code>mpage_bio_submit()</code>将<code>bio</code>的<code>bi_end_io</code>方法设为<code>mpage_end_io_write()</code>的地址，然后调用<code>submit_bio()</code>开始传输。一旦数据传输成功结束，<code>mpage_end_io_write()</code>就唤醒那些等待传输结束的进程，并消除<code>bio</code>描述符。</p>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内核把对线性区中页内某个字节的访问转换成对文件中相应字节的操作的技术为<strong>内存映射</strong>。两种类型的内存映射：</p>
<ul>
<li><strong>共享型</strong>，在线性区页上的任何写操作都会修改磁盘上的文件；而且，如果进程读共享映射中的一个页进行写，那么这种修改对于其他映射了这同一文件的所有进程来说都是可见的。</li>
<li><strong>私有型</strong>，当进程创建的映射只是为读文件，而不是写文件时才会使用此种映射。私有映射的效率比共享映射高。但对私有映射页的任何写操作都会使内核停止映射该文件中的页。因此，写操作既不会改变磁盘上的文件，对访问相同文件的其他进程也不可见。但私有内存映射中还没有被进程改变的页会因为其他进程对文件的更新而更新。</li>
</ul>
<p><code>mmap()</code>创建一个新的内存映射，必须指定要给<code>MAP_SHARED</code>标志或<code>MAP_PRIVATE</code>标志作为参数。一旦创建映射，进程就可以从这个新线性区的内存单元读取数据，等价于读取了文件中存放的数据。</p>
<p><code>munmap()</code>撤销或缩小一个内存映射。</p>
<p>如果一个内存映射是共享的，相应的线性区就设置了<code>VM_SHARED</code>标志；如果一个内存映射是私有的，相应的线性区就清除了<code>VM_SHARED</code>标志。</p>
<h3 id="内存映射的数据结构"><a href="#内存映射的数据结构" class="headerlink" title="内存映射的数据结构"></a>内存映射的数据结构</h3><p>内存映射可以用下列数据结构的组合表示：</p>
<ul>
<li>所映射的文件相关的索引节点对象</li>
<li>所映射文件的<code>address_space</code>对象</li>
<li>不同进程对一个文件进行不同映射所使用的文件对象</li>
<li>对文件进行每一不同映射所使用的<code>vm_area_struct</code>描述符</li>
<li>对文件进行映射的线性区所分配的每个页框所对应的页描述符</li>
</ul>
<p><img src="/img/1604317095.jpg" alt=""></p>
<p>图的左边给出了标识文件的索引节点。每个索引节点对象的<code>i_mapping</code>字段指向文件的<code>address_space</code>对象。每个<code>address_space</code>对象的<code>page_tree</code>字段又指向该地址空间的页的基树，而<code>i_mmap</code>字段指向第二棵树，叫做<strong>radix优先级搜索树</strong>（PST），这种树由地址空间的线性区组成。PST的主要作用是为了执行<strong>反向映射</strong>，这是为了快速标识共享一页的所有进程。</p>
<p>每个线性区描述符都有一个<code>vm_file</code>字段，与所映射文件的文件对象链接（如果为NULL，则线性区没有用于内存映射）。第一个映射的位置存放线性区描述符的<code>vm_pgoff</code>字段，它表示以页大小为单位的偏移量。所映射的文件那部分的长度就是线性区的大小，可以从<code>vm_start</code>和<code>vm_end</code>字段计算出来。</p>
<p><strong>共享内存映射的页通常都包含在页高速缓存中</strong>；私有内存映射的页只要还没有被修改，也包含在页高速缓存。当进程试图修改一个私有内存映射的页时，内核就把该页进行复制，并在进程页表中用复制的页替换原来的页框。虽然原来的页框还在页高速缓存，但不再属于这个内存映射。该复制的页框不会被插入页高速缓存，因为其中包含的数据不再是磁盘上表示那个文件的有效数据。</p>
<p>对每个不同的文件系统，内核提供了几个钩子函数来定制其内存映射机制。内存映射实现的核心委托给文件对象的<code>mmap</code>方法。对于大多数磁盘文件系统和块设备文件，该方法由<code>generic_file_mmap()</code>通用函数实现。</p>
<p><strong>文件内存映射依赖于请求调用机制</strong>。事实上一个新建立的内存映射就是一个不包含任何页的线性区，当进程引用线性区中的一个地址时，缺页异常发生，缺页异常中断处理程序检查线性区的<code>nopage</code>方法是否被定义，如果没有则说明线性区不映射磁盘上的文件。几乎所有的磁盘文件通过<code>filemap_nopage()</code>实现<code>nopage</code>方法。</p>
<h3 id="创建内存映射"><a href="#创建内存映射" class="headerlink" title="创建内存映射"></a>创建内存映射</h3><p><code>mmap()</code>参数：</p>
<ul>
<li>文件描述符，标识要映射的文件</li>
<li>文件内的偏移量，指定要映射的文件部分的第一个字符</li>
<li>要映射的文件部分的长度</li>
<li>一组标志，进程必须显式地设置<code>MAP_SHARED</code>标志或<code>MAP_PRIVATE</code>标志来指定所请求的内存映射的种类。</li>
<li>一组权限，指定对线性区进行访问的一种或多种权限：读访问（<code>PROT_READ</code>）、写访问（<code>PROT_WRITE</code>）或执行访问（<code>PROT_EXEC</code>）。</li>
<li>一个可选的的线性地址，内核把该地址作为新线性区应该从哪里开始的一个线索。如果指定了<code>MAP_FIXED</code>标志，且内核不能从指定的线性地址开始分配新线性区，那么这个系统调用失败。</li>
</ul>
<p><code>mmap()</code>系统调用返回新线性区中第一个单元位置的线性地址。主要调用<code>do_mmap_pgoff()</code>函数。</p>
<ul>
<li>检查要映射的文件是否定义了<code>mmap</code>文件操作。如果没有，就返回一个错误码。文件操作表中的<code>mmap</code>值为NULL说明相应的文件不能被映射。</li>
<li><code>get_unmapped_area()</code>调用文件对象的<code>get_unmapped_area</code>方法，如果已定义，就为文件的内存映射分配一个合适的线性地址区间。磁盘文件系统不定义这个方法，需调用内存描述符的<code>get_unmapped_area</code>方法。</li>
<li>除了进行正常的一致性检查外，还要对所请求的内存映射的种类（存放在<code>mmap()</code>的参数<code>flags</code>中）与在打开文件时所指定的标志（存放在<code>file-&gt;f_mode</code>字段中）进行比较。根据这两个消息源，执行以下的检查：<ul>
<li>如果请求一个共享可写的内存映射，文件应该是为写入而打开的，而不是以追加模式打开的（<code>open()</code>的<code>O_APPEND</code>标志）。</li>
<li>如果请求一个共享内存映射，文件上应该没有强制锁。</li>
<li>对于任何种类的内存映射，文件都应该是为读操作而打开的。<br>初始化<code>vm_flags</code>时，要根据文件的访问权限和所请求的内存映射的种类设置<code>VM_READ</code>、<code>VM_MAYWRITE</code>、<code>VM_MAYEXEC</code>和<code>VM_MAYSHARE</code>标志。</li>
</ul>
</li>
<li>用文件对象的地址初始化线性区描述符的<code>vm_file</code>字段，并增加文件的引用计数器。对映射的文件调用<code>mmap</code>方法，将文件对象地址和线性区描述符地址作为参数传给它。大多数文件系统由<code>generic_file_mmap()</code>实现<ul>
<li>将当前时间赋给文件索引节点对象的<code>i_atime</code>字段，并将该索引节点标记为脏。</li>
<li>用<code>generic_file_vm_ops</code>表的地址初始化线性区描述符的<code>vm_ops</code>字段。在这个表中的方法，除了<code>nopage</code>和<code>populate</code>方法外，其他都为空。<code>nopage</code>方法由<code>filemap_nopage()</code>实现，而<code>populate</code>方法由<code>filemap_poplate()</code>实现。</li>
</ul>
</li>
<li>增加文件索引节点对象<code>i_writecount</code>字段的值，该字段就是写进程的引用计数器。</li>
</ul>
<h3 id="撤销内存映射"><a href="#撤销内存映射" class="headerlink" title="撤销内存映射"></a>撤销内存映射</h3><p><code>munmap()</code>还可用于减少每种内存区的大小。参数：</p>
<ul>
<li>要删除的线性地址区间中第一个单元的地址</li>
<li>要删除的线性地址区间的长度</li>
</ul>
<p><code>sys_munmap()</code>服务例程实际上调用<code>do_munmap()</code>。不需要将待撤销可写共享内存映射中的页刷新到磁盘。实际上，这些页仍然在页高速缓存内，因此继续起磁盘高速缓存的作用。</p>
<h3 id="内存映射的请求调页"><a href="#内存映射的请求调页" class="headerlink" title="内存映射的请求调页"></a>内存映射的请求调页</h3><p>内存映射创建后，页框的分配尽可能推迟。</p>
<p>内核先验证缺页所在地址是否包含在某个进程的线性区内，如果是，内核就检查该地址所对应的页表项，如果表项为空，就调用<code>do_no_page()</code>。</p>
<p><code>do_no_page()</code>执行对请求调页的所有类型都通用的操作，如分配页框和更新页表。它还检查所涉及的线性区是否定义了<code>nopage</code>方法，当定义时，<code>do_no_page()</code>执行的主要操作：</p>
<ol>
<li>调用<code>nopage</code>方法，返回包含所请求页的页框的地址。</li>
<li>如果进程试图对页进行写入，而该内存映射是私有的，则通过把刚读取的页拷贝一份并插入页的非活动链表中来避免进一步的“写时复制”异常。如果私有内存映射区域还没有一个包含新页的被动匿名线性区，它要么追加一个新的被动匿名线性区，要么增大现有的。在下面步骤中，该函数使用新页而不是<code>nopage</code>方法返回的页，所以后者不会被用户态进程修改。</li>
<li>如果某个其他进程删改或作废了该页（<code>address_space</code>描述符的<code>truncate_count</code>字段就是用于这种检查的），函数将跳回第1步，尝试再次获得该页。</li>
<li>增加进程内存描述符的<code>rss</code>字段，表示一个新页框已分配给进程。</li>
<li>用新页框的地址及线性区的<code>vm_page_prot</code>字段中所包含的页访问权来设置缺页所在的地址对应的页表项。</li>
<li>如果进程试图对该页进行写入，则把页表项的<code>Read/Write</code>和<code>Dirty</code>位强制置为1。这种情况下，或者把该页框互斥地分配给进程，或者让页成为共享；这两种情况下，都应该允许对该页进行写入。</li>
</ol>
<p>请求调页算法的核心在于线性区的<code>nopage</code>方法。一般，该方法必须返回进程所访问页所在的页框地址。其实现依赖于页所在线性区的种类。</p>
<p>在处理对磁盘文件进行映射的线性区时，<code>nopage</code>方法必须首先在页高速缓存中查找所请求的页。如果没有找到相应的页，就必须从磁盘读入。大部分文件系统都是由<code>filemap_nopage</code>实现<code>nopage</code>方法。参数：</p>
<ul>
<li><code>area</code>，所请求页所在线性区的描述符地址。</li>
<li><code>address</code>，所请求页的线性地址。</li>
<li><code>type</code>，存放函数侦测到的缺页类型（<code>VM_FAULT_MAJOR</code>或<code>VM_FAULT_MINOR</code>）的变量的指针。</li>
</ul>
<p>filemap_nopage()`执行以下步骤：</p>
<ol>
<li>从<code>area-&gt;vm_file</code>字段得到文件对象地址<code>file</code>；从<code>file-&gt;f_mapping</code>得到<code>address_space</code>对象地址；从<code>address_space</code>对象的<code>host</code>字段得到索引节点对象地址。</li>
<li>用<code>area</code>的<code>vm_start</code>和<code>vm_pgoff</code>字段来确定从<code>address</code>开始的页对应的数据在文件中的偏移量。</li>
<li>检查文件偏移量是否大于文件大小。如果是，就返回NULL，这意味着分配新页失败，除非缺页是由调试程序通过<code>ptrace()</code>跟踪另一个进程引起的。</li>
<li>如果线性区的<code>VM_RAND_READ</code>标志置位，假定进程以随机方式读内存映射中的页，那么它忽略预读，跳到第10步。</li>
<li>如果线性区的<code>VM_SEQ_READ</code>标志置位，假定进程以严格顺序读内存映射中的页，则调用<code>page_cache_readahead()</code>从缺页处开始预读。</li>
<li>调用<code>find_get_page()</code>，在页高速缓存内寻找由<code>address_space</code>对象和文件偏移量标识的页。如果没有找到，跳到第11步。</li>
<li>此时，说明没有在页高速缓存中找到页，检查内存区的<code>VM_SEQ_READ</code>标志：<ol>
<li>如果标志置位，内核将强行预读线性区中的页，预读算法失败，就调用<code>handle_ra_miss()</code>来调整预读参数，并跳到第10步。</li>
<li>否则，如果标志未置位，将文件<code>file_ra_state</code>描述符中的<code>mmap_miss</code>计数器加1。如果失败数远大于命中数（存放在<code>mmap_hit</code>计数器内），将忽略预读，跳到第10步。</li>
</ol>
</li>
<li>如果预读没有永久禁止（<code>file_ra_state</code>描述符的<code>ra_pages</code>字段大于0），将调用<code>do_page_cache_readahead()</code>读入包含请求页的一组页。</li>
<li>调用<code>find_get_page()</code>检查请求页是否在页高速缓存中，如果在，跳到第11步。</li>
<li>调用<code>page_cache_read()</code>检查请求页是否在页高速缓存中，如果不在，则分配一个新页框，把它追加到页高速缓存，执行<code>mapping-&gt;a_ops-&gt;readpage</code>方法，安排一个I/O操作从磁盘读入该页内容。</li>
<li>调用<code>grab_swap_token()</code>，尽可能为当前进程分配一个交换标记。</li>
<li>请求页已在页高速缓存中，将文件<code>file_ra_state</code>描述符的<code>mmap_hit</code>计数器加1。</li>
<li>如果页不是最新的（标志<code>PG_uptodate</code>未置位），就调用<code>lock_page()</code>锁定该页，执行<code>mapping-&gt;a_ops-&gt;readpage</code>方法触发I/O数据传输，调用<code>wait_on_page_bit()</code>后睡眠，一直等到该页被解锁，即等待数据传输完成。</li>
<li>调用<code>mark_page_accessed()</code>来标记请求页为访问过。</li>
<li>如果在页高速缓存内找到该页的最新版，将<code>*type</code>设为<code>VM_FAULT_MINOR</code>，否则设为<code>VM_FAULT_MAJOR</code>。</li>
<li>返回请求页地址。</li>
</ol>
<p>用户态进程可通过<code>madvise()</code>来调整<code>filemap_nopage()</code>的预读行为。<code>MADV_RANDOM</code>命令将线性区的<code>VM_RAND_READ</code>标志置位，从而指定以随机方式访问线性区的页。<code>MADV_SEQUNTIAL</code>命令将线性区的<code>VM_SEQ_READ</code>标志置位，从而指定以严格顺序方式访问页。<code>MADV_NORMAL</code>命令将复位<code>VM_RAND_READ</code>和<code>VM_SEQ_READ</code>标志，从而指定以不确定的顺序访问页。</p>
<h3 id="把内存映射的脏页刷新到磁盘"><a href="#把内存映射的脏页刷新到磁盘" class="headerlink" title="把内存映射的脏页刷新到磁盘"></a>把内存映射的脏页刷新到磁盘</h3><p>进程可是由<code>msync()</code>把属于共享内存映射的脏页刷新到磁盘。参数：<strong>一个线性地址区间的起始地址</strong>、<strong>区间的长度即具有下列含义的一组标志</strong>。</p>
<ul>
<li><code>MS_SYNC</code>，挂起进程，直到I/O操作完成。调用进程可假设当系统调用完成时，该内存映射中的所有页都已经被刷新到磁盘。</li>
<li><code>MS_ASYNC</code>（对<code>MS_SYNC</code>的补充），要求系统调用立即返回，而不用挂起调用进程。</li>
<li><code>MS_INVALIDATE</code>，使同一文件的其他内存映射无效。</li>
</ul>
<p>对线性地址区间中所包含的每个线性区，<code>sys_msync()</code>服务例程都调用<code>msync_interval()</code>执行以下操作：</p>
<ol>
<li>如果线性区描述符的<code>vm_file</code>字段为NULL，或者如果<code>VM_SHARED</code>标志清0，就返回0（该线性区不是文件的可写共享内存映射）。</li>
<li>调用<code>filemap_sync()</code>扫描包含在线性区地址区间所对应的页表项。对于找到的每个页，重设对应页表项的<code>Dirty</code>标志，调用<code>flush_tlb_page()</code>刷新相应的快表（TLB）。然后设置页描述符的<code>PG_dirty</code>标志，把页标记为脏。</li>
<li>如果<code>MS_ASYNC</code>标志置位，返回。<code>MS_ASYNC</code>标志的实际作用就是将线性区的页标志<code>PG_dirty</code>置位。该系统调用没有实际开始I/O数据传输。</li>
<li>至此，<code>MS_SYNC</code>标志置位，必须将内存区的页刷新到磁盘，且当前进程必须睡眠直到所有I/O数据传输结束。为此，要得到文件索引节点的信号量<code>i_sem</code>。</li>
<li>调用<code>filemap_fdatawrite()</code>，参数为文件的<code>address_space</code>对象的地址。必须用<code>WB_SYNC_ALL</code>同步模式建立一个<code>writeback_control</code>描述符，且要检查地址空间是否有内置的<code>writepage</code>方法。如果有，则返回；没有，则执行<code>mapge_writepages()</code>将脏页写到磁盘。</li>
<li>检查文件对象的<code>fsync</code>方式是否定义，如果是，则执行。对于普通文件，该方法仅把文件的索引节点对象刷新到磁盘。然而，对于块设备文件，该方法调用<code>sync_blockdev()</code>激活该设备所有脏缓冲区的I/O数据传输。</li>
<li>执行<code>filemap_fdatawait()</code>。页高速缓存中的基树标识了所有通过<code>PAGECACHE_TAG_SRITEBACK</code>标记正在往磁盘写的页。函数快速扫描覆盖给定线性地址区间的这一部分基树来寻找<code>PG_writeback</code>标志置位的页。调用<code>wait_on_page_bit()</code>使其中每一页睡眠，直到<code>PG_writeback</code>标志清0，即等到正在进行的该页的I/O数据传输结束。</li>
<li>释放文件的信号量<code>i_sem</code>并返回。</li>
</ol>
<h3 id="非线性内存映射"><a href="#非线性内存映射" class="headerlink" title="非线性内存映射"></a>非线性内存映射</h3><p><strong>非线性映射</strong>中，每一内存页都映射文件数据中的随机页。</p>
<p>为实现非线性映射，内核使用了另外一些数据结构。首先，线性区描述符的<code>VM_NONLINERAR</code>标志用于表示线性区存在一个非线性映射。给定文件的所有非线性映射线性区描述符都存放在一个双向循环链表，该链表位于<code>address_space</code>对象的<code>i_mmap_nonlinear</code>字段。</p>
<p>为创建一个非线性内存映射，用户态进程首先以<code>mmap()</code>系统调用创建一个常规的共享内存映射。然后调用<code>remap_file_pages()</code>来重写映射内存映射中的一些页。该系统调用的<code>sys_remap_file_pages()</code>服务例程参数：</p>
<ul>
<li><code>start</code>，调用进程共享文件内存映射区域内的线性地址。</li>
<li><code>size</code>，文件重写映射部分的字节数。</li>
<li><code>prot</code>，未用（必须为0）。</li>
<li><code>pgoff</code>，待映射文件初始页的页索引。</li>
<li><code>flags</code>，控制非线性映射的标志。</li>
</ul>
<p><code>sys_remap_file_pages()</code>用线性地址<code>start</code>、页索引<code>pgoff</code>和映射尺寸<code>size</code>所确定的文件数据部分进行重写映射。如果线性区非共享或不能容纳要映射的所有页，则失败并返回错误码。实际上，该服务例程把线性区插入文件的<code>i_mmap_nonlinear</code>链表，并调用该线性区的<code>populate</code>方法。</p>
<p>对于所有普通文件，<code>populate</code>方法是由<code>filemap_populate()</code>实现的：</p>
<ol>
<li>检查<code>remap_file_pages()</code>的<code>flags</code>参数中<code>MAP_NONBOCK</code>标志是否清0。如果是，则调用<code>do_page_cache_readahead()</code>预读待映射文件的页。</li>
<li>对重写映射的每一页：<ol>
<li>检查页描述符是否已在页高速缓存内，如果不在且<code>MAP_NONBLOCK</code>未置位，则从磁盘读入该页。</li>
<li>如果页描述符在页高速缓存内，它将更新对应线性地址的页表项来指向该页框，并更新线性区描述符的页引用计数器。</li>
<li>否则，如果没有在页高速缓存内找到该页描述符，它将文件页的偏移量存放在该线性地址对应的页表项的最高32位，并将页表项的<code>Present</code>位清0、<code>Dirty</code>位置位。</li>
</ol>
</li>
</ol>
<p>当处理请求调页错误时，<code>handle_pte_fault()</code>检查页表项的<code>Present</code>和<code>Dirty</code>位。如果它们的值对应一个非线性内存映射，则<code>handle_pte_falut()</code>调用<code>do_file_page()</code>从页表项的高位中取出所请求文件页的索引，然后，<code>do_file_page()</code>调用线性区的<code>populate</code>方法从磁盘读入页并更新页表项本身。</p>
<p>因为非线性内存映射的内存页是按照相对于文件开始处的页索引存放在页高速缓存中，而不是按照相对于线性区开始处的索引存放的，所以非线性内存映射刷新到磁盘的方式与线性内存映射一样。</p>
<h2 id="直接I-O传送"><a href="#直接I-O传送" class="headerlink" title="直接I/O传送"></a>直接I/O传送</h2><p><strong>直接I/O传送</strong>绕过了页高速缓存，在每次I/O直接传送中，内核对磁盘控制器进行编程，以便<strong>在应用程序的用户态地址空间中自缓存的页与磁盘之间直接传送数据</strong>。</p>
<p>当应用程序直接访问文件时，它以<code>O_DIRECT</code>标志置位的方式打开文件。调用<code>open()</code>时，<code>dentry_open()</code>检查打开文件的<code>address_space</code>对象是否已实现<code>direct_IO</code>方法，没有则返回错误码。对一个已打开的文件也可由<code>fcntl()</code>的<code>F_SETFL</code>命令把<code>O_DIRECT</code>置位。</p>
<p>第一种情况中，应用程序对一个以<code>O_DIRECT</code>标志置位打开的文件调用<code>read()</code>。文件的<code>read</code>方法通常由<code>generic_file_read()</code>实现，它初始化<code>iovec</code>和<code>kiocb</code>描述符并调用<code>__genenric_file_aio_read()</code>。<code>__genenric_file_aio_read()</code>检查<code>iovec</code>描述符描述的用户态缓冲区是否有效，文件的<code>O_DIRECT</code>标志是否置位。当被<code>read()</code>调用时，等效于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(filp-&gt;f_flags &amp; O_DIRECT)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(count ==<span class="number">0</span> || *ppos &gt; file-&gt;f_mapping-&gt;host-&gt;i_size)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	retval = generic_file_direct_IO(READ, iocb, iov, **ppos, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(retval &gt;<span class="number">0</span>)</span><br><span class="line">		*ppos += retval;</span><br><span class="line"></span><br><span class="line">	file_accessed(filp);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数检查文件指针的当前值是否大于文件大小，然后调用<code>generic_file_direct_IO()</code>，传给它<code>READ</code>操作类型、<code>iocb</code>描述符、<code>iovec</code>描述符、文件指针的当前值和<code>io_vec</code>中指定的用户态缓冲区号。<code>__generic_file_aio_read()</code>更新文件指针，设置对文件索引节点的访问时间戳，然后返回。</p>
<p>对一个以<code>O_DIRECT</code>标志位打开的文件调用<code>write()</code>时，情况类似。文件的<code>write</code>方法就是调用<code>generic_file_aio_write_nolock()</code>。函数检查<code>O_DIRECT</code>标志是否置位，如果置位，则调用<code>generic_file_direct_IO()</code>，这次限定的是<code>WRITE</code>操作类型。</p>
<p><code>generic_file_direct_IO()</code>参数：</p>
<ul>
<li><code>rw</code>，操作类型：<code>READ</code>或<code>WRITE</code></li>
<li><code>iocb</code>，<code>kiocb</code>描述符指针</li>
<li><code>iov</code>，<code>iove</code>描述符数组指针</li>
<li><code>offset</code>，文件偏移量</li>
<li><code>nr_segs</code>，<code>iov</code>数组中<code>iovec</code>描述符数</li>
</ul>
<p><code>generic_file_direct_IO()</code>步骤：</p>
<ol>
<li>从<code>kiocb</code>描述符的<code>ki_filp</code>字段得到文件对象的地址<code>file</code>，从<code>file-&gt;f_mapping</code>字段得到<code>address_space</code>对象的地址<code>mapping</code>。</li>
<li>如果操作类型为<code>WRITE</code>，且一个或多个进程已创建了与文件的某个部分关联的内存映射，则调用<code>unmap_mapping_range()</code>取消文件所有页的内存映射。如果任何取消映射的页所对应的页表项，其<code>Dirty</code>位置位，则确保它在页高速缓存内的相应页被标记为脏。</li>
<li>如果存于<code>mapping</code>的基树不为空（<code>mapping-&gt;nrpages</code>大于0），则调用<code>filemap_fdatawrite()</code>和<code>filemap_fdatawait()</code>刷新所有脏页到磁盘，并等待I/O操作结束。</li>
<li>调用<code>mapping</code>地址空间的<code>direct_IO</code>方法。</li>
<li>如果操作类型为<code>WRITE</code>，则调用<code>invalidate_inode_pages2()</code>扫描<code>mapping</code>基树中的所有页并释放它们。该函数同时也清空指向这些页的用户态表项。</li>
</ol>
<p>大多数情况下，<code>direct_IO</code>方法都是<code>__blockdev_direct_IO()</code>的封装函数：</p>
<ul>
<li>对存放在相应块中要读或写的数据进行拆分，确定数据在磁盘上的位置，并添加一个或多个用于描述要进行的I/O操作的<code>bio</code>描述符。</li>
<li>数据将被直接从<code>iov</code>数组中<code>iovec</code>描述符确定的用户态缓冲区读写。</li>
<li>调用<code>submit_bio()</code>将<code>bio</code>描述符提交给通用层。</li>
</ul>
<p>通常，<code>__blockdev_direct_IO()</code>不立即返回，而是等待所有的直接I/O传送都已完成才返回。因此，一旦<code>read()</code>或<code>write()</code>返回，应用程序就可以访问含有文件数据的缓冲区。</p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>当用户态进程调用库函数读写文件时，一旦读写操作进入队列函数就结束。甚至有可能真正的I/O数据传输还没开始。这样调用进程可在数据正在传输时继续自己的运行。<br><img src="/img/1604396278.jpg" alt=""></p>
<p>使用异步IO很简单，应用程序通过<code>open()</code>打开文件，然后用描述请求操作的信息填充<code>struct aiocb</code>类型的控制块。<code>struct aiocb</code>最常用的字段：</p>
<ul>
<li><code>aio_fildes</code>，文件的文件描述符</li>
<li><code>aio_buf</code>，文件数据的用户态缓冲区</li>
<li><code>aio_nbytes</code>，待传输的字节数</li>
<li><code>aio_offset</code>，读写操作在文件中的起始位置</li>
</ul>
<p>最后，应用程序将控制块地址传给<code>aio_read()</code>或<code>aio_write()</code>。一旦请求的I/O数据传输已由系统库或内核送进队列，这两个函数就结束。应用程序可调用<code>aio_error()</code>检查正在运行的I/O操作的状态：如果数据传输仍在进行，则返回<code>EINPROGRESS</code>；完成则返回0；失败则返回一个错误码。</p>
<p><code>aio_return()</code>返回已完成异步I/O操作的有效读写字节数；失败则返回-1。</p>
<h3 id="Linux2-6中的异步I-O"><a href="#Linux2-6中的异步I-O" class="headerlink" title="Linux2.6中的异步I/O"></a>Linux2.6中的异步I/O</h3><p>异步I/O可由系统库实现而不完全需要内核支持，实际上<code>aio_read()</code>和<code>aio_write()</code>克隆当前进程，子进程调用同步的<code>read()</code>和<code>write()</code>，然后父进程结束<code>aio_read()</code>和<code>aio_write()</code>并继续执行。Linux 2.6内核版运用一组系统调用实现异步I/O。<br><img src="/img/1604396533.jpg" alt=""></p>
<h4 id="异步I-O环境"><a href="#异步I-O环境" class="headerlink" title="异步I/O环境"></a>异步I/O环境</h4><p>如果一个用户态进程调用<code>io_submit()</code>开始异步I/O操作，它必须预先创建一个异步I/O环境。</p>
<p>基本上，一个异步I/O环境（简称<code>AIO</code>环境）就是一组数据结构，该数据结构用于跟踪进程请求的异步I/O操作的运行情况。每个<code>AIO</code>环境与一个<code>kioctx</code>对象关联，<code>kioctx</code>对象存放了与该环境有关的所有信息。一个应用可创建多个<code>AIO</code>环境。一个给定进程的所有<code>kioctx</code>描述符存放在一个单向链表中，该链表位于内存描述符的<code>ioctx_list</code>字段。</p>
<p><strong><code>AIO</code>环</strong>是被<code>kioctx</code>对象使用的重要的数据结构。<code>AIO</code>环是<strong>用户态进程中地址空间的内存缓冲区</strong>，它可以由内核态的所有进程访问。<code>kioctx</code>对象的<code>ring_info.mmap_base</code>和<code>ring_info.mmap_size</code>字段分别存放<code>AIO</code>环的用户态起始地址和长度。<code>ring_info.ring_pages</code>字段存放一个数组指针，该数组存放含有<code>AIO</code>环的页框的描述符。</p>
<p><code>AIO</code>环实际上一个环形缓冲区，<strong>内核用它来写正运行的异步I/O操作的完成报告</strong>。<code>AIO</code>环的第一个字节有一个首部（<code>struct aio_ring</code>数据结构），后面的所有字节是<code>io_event</code>数据结构，每个表示一个已完成的异步I/O操作。因为<code>AIO</code>环的页映射到进程的用户态地址空间，应用可以直接检查正运行的异步I/O操作的情况，从而避免使用相对较慢的系统调用。</p>
<p><code>io_setup()</code>为调用进程创建一个新的<code>AIO</code>环境。参数：正在运行的异步I/O操作的最大数目（确定<code>AIO</code>环的大小）和一个存放环境局部的变量指针（<code>AIO</code>环的基地址）。</p>
<p><code>sys_io_setup()</code>服务例程实际上调用<code>do_mmap()</code>为进程分配一个存放<code>AIO</code>环的新匿名线性区，然后创建和初始化该<code>AIO</code>环境的<code>kioctx</code>对象。</p>
<p><code>io_destroy()</code>删除<code>AIO</code>环境和含有对应<code>AIO</code>环的匿名线性区。该系统调用阻塞当前进程直到所有正在运行的异步I/O操作结束。</p>
<h4 id="提交异步I-O操作"><a href="#提交异步I-O操作" class="headerlink" title="提交异步I/O操作"></a>提交异步I/O操作</h4><p><code>io_submit()</code>参数：</p>
<ul>
<li><code>ctx_id</code>，由<code>io_setup()</code>（标识<code>AIO</code>环境）返回的句柄</li>
<li><code>iocbpp</code>，<code>iocb</code>类型描述符的指针数组的地址，每项元素描述一个异步I/O操作。</li>
<li><code>nr</code>，<code>iocbpp</code>指向的数组的长度</li>
</ul>
<p><code>iocb</code>数据结构与<code>POSIX aiocb</code>描述符有同样的字段<code>aio_fildes</code>、<code>aio_buf</code>、<code>aio_nbytes</code>、<code>aio_offset</code>。<code>aio_lio_opcode</code>字段存放请求操作的类型（如<code>read</code>、<code>write</code>或<code>sync</code>）。</p>
<p><code>sys_io_submit()</code>服务例程执行下列步骤：</p>
<ol>
<li>验证<code>iocb</code>描述符数组的有效性。</li>
<li>在内存描述符的<code>ioctx_list</code>字段所对应的链表中查找<code>ctx_id</code>句柄对应的<code>kioctx</code>对象。</li>
<li>对数组中的每个<code>iocb</code>描述符，执行下列步骤：<ol>
<li>获得<code>aio_fildes</code>字段中的文件描述符对应的文件对象地址。</li>
<li>为该I/O操作分配和初始化一个新的<code>kiocb</code>描述符。</li>
<li>检查<code>AIO</code>环中是否有空闲位置来存放操作的完成情况。</li>
<li>根据操作类型设置<code>kiocb</code>描述符的<code>ki_retry</code>方法。</li>
<li>执行<code>aio_run_iocb()</code>，实际上调用<code>ki_retry</code>方法为相应的异步I/O操作启动数据传输。如果<code>ki_retry</code>方法返回<code>-EIOCBRETRY</code>，则表示异步I/O操作已提交但还没有完全成功：稍后在这个<code>kiocb</code>上，<code>aio_run_iocb()</code>会被再次调用；否则，调用<code>aio_complete()</code>为异步I/O操作在<code>AIO</code>环中追加完成事件。</li>
</ol>
</li>
</ol>
<p>如果异步I/O操作是一个读请求，那么对应<code>kiocb</code>描述符的<code>ki_retry</code>方法由<code>aio_pread()</code>实现。该函数实际上执行文件对象的<code>aio_read</code>方法，然后按照<code>aio_read</code>方法的返回值更新<code>kiocb</code>描述符的<code>ki_buf</code>和<code>ki_left</code>字段。最后，<code>aio_pread()</code>返回从文件读入的有效字节数，或者，如果函数确定请求的字节没有传输完，则返回<code>-EIOCBRETRY</code>。</p>
<p>对于大部分文件系统，文件对象的<code>aio_read</code>方法就是调用<code>__generic_file_aio_read()</code>。如果文件的<code>O_DIRECT</code>标志置位，函数就调用<code>generic_file_aio_read()</code>。但这种情况下，<code>__blockdev_direct_IO()</code>不阻塞当前进程使之等待I/O数据传输完毕，而是立即返回。因为异步I/O操作仍在运行，<code>aio_run_iocb()</code>会被再次调用，调用者是<code>aio_wq</code>工作队列的<code>aio</code>内核线程。<code>kiocb</code>描述符跟踪I/O数据传输的运行。所有数据传输完毕后，将完成结果追加到<code>AIO</code>环。</p>
<p>如果异步I/O操作是一个写请求，则对应<code>kiocb</code>描述符的<code>ki_retry</code>方法由<code>aio_pwrite()</code>实现。该函数实际上执行文件对象的<code>aio_write</code>方法，然后按照<code>aio_write</code>方法的返回值更新<code>kiocb</code>描述符的<code>ki_buf</code>和<code>ki_left</code>字段。最后<code>aio_pwrite()</code>返回写入文件的有效字节数，或者，如果函数确定请求的字节没有传输完，则返回<code>-EIOCBRETRY</code>。对于大部分文件系统，文件对象的<code>aio_write</code>方法就是调用<code>generic_file_aio_write_nolock()</code>。如果文件的<code>O_DIRECT</code>标志置位，就调用<code>generic_file_direct_IO()</code>。</p>
<h1 id="回收页框"><a href="#回收页框" class="headerlink" title="回收页框"></a>回收页框</h1><h2 id="页框回收算法"><a href="#页框回收算法" class="headerlink" title="页框回收算法"></a>页框回收算法</h2><p>Linux 内核的<strong>页框回收算法</strong>（page frame reclaiming algorithm, PFRA）采取<strong>从用户态进程和内核高速缓存“窃取”页框的办法补充伙伴系统的空闲块列表</strong>。</p>
<p>页框回收算法的目标之一就是<strong>保存最少的空闲页框池以便内核可以安全地从“内存紧缺”的情形中恢复过来</strong>。</p>
<h3 id="选择目标页"><a href="#选择目标页" class="headerlink" title="选择目标页"></a>选择目标页</h3><p>PFRA 的目标是获得页框并使之空闲。PFRA选取的页框肯定不是空闲的，这些页框原本不在伙伴系统的任何一个<code>free_area</code>中。PFRA 按照页框所含的内容，以不同的方式处理页框：<br><img src="/img/1604396534.png" alt=""></p>
<p>表中所谓“映射页”是指<strong>该页映射了一个文件的某个部分</strong>。比如，属于文件内存映射的用户态地址空间中所有页都是映射页，页高速缓存中的任何其他页也是映射页。映射页差不多都是可同步的：<strong>为回收页框，内核必须检査页是否为脏，而且必要时将页的内容写到相应的磁盘文件中</strong>。</p>
<p>相反，所谓的“匿名页”是指它<strong>属于一个进程的某匿名线性区</strong>。为回收页框，内核必须将页中内容保存到一个专门的磁盘分区或磁盘文件，叫做<strong>交换区</strong>。因此，所有匿名页都是可交换的。通常，特殊文件系统中的页是不可回收的。</p>
<p>当PFRA必须回收属于某进程用户态地址空间的页框时，它必须考虑页框是否为共享的。共享页框属于多个用户态地址空间，而非共享页框属于单个用户态地址空间。注意，非共享页框可能属干几个轻量级进程，这些进程使用同一个内存描述符。</p>
<p>当进程创建子进程时，就建立了共享页框。正如第九章“写时复制”一节所述，子进程页表都从父进程中复制过来的，父子进程因此共享同一个页框。共享页框的另一个常见情形是：一个或多个进程以共享内存映射的方式访问同一个文件。</p>
<h3 id="PFRA设计"><a href="#PFRA设计" class="headerlink" title="PFRA设计"></a>PFRA设计</h3><p>确定回收内存的候选页可能是内核设计中最精巧的问题，需要同时满足系统响应和对内存需求量大的要求。</p>
<p>PFRA 采用的几个总的原则：</p>
<ul>
<li><strong>首先释放“无害”页</strong>。先回收没有被任何进程使用的磁盘与内存高速缓存中的页，不需要修改任何页表项。</li>
<li><strong>将用户态进程的所有页定为可回收页</strong>。除了锁定页，PFRA 必须能窃得任何用户态进程页，包括匿名页。这样，睡眠时间较长的进程将逐渐失去所有页框。</li>
<li><strong>同时取消引用一个共享页框的所有页表项的映射</strong>，清空引用该页框的所有页表项，就可以回收该共享页框。</li>
<li><strong>只回收“未用”页</strong>。使用简化的最近最少使用（LRU）置换算法，PFRA 将页分为<strong>在用</strong>与<strong>未用</strong>。如果某页很长时间没有被访问，那么它将来被访问的可能性较小，可被看作未用；另一方面，如果某页最近被访问过，那么它将来被访问的可能性较大，被看作在用。PFRA 只回收未用页。</li>
</ul>
<p>LRU算法的主要思想是<strong>用一个计数器来存放RAM中每一页的页年龄，即上次访问该页到现在已经过去的时间，PFRA只回收任何进程的最旧页</strong>。但Linux内核没有计数器这样的硬件，而是使用每个页表项中的<strong>访问标志位</strong>，在页被访问时，该标志位由硬件自动置位；而且，页年龄由页描述符在链表中的位置表示。</p>
<p>页框回收算法是几种启发式方法的混合：</p>
<ul>
<li>谨慎选择检查高速缓存的顺序。</li>
<li>基于页年龄的变化排序。</li>
<li>区别对待不同状态的页。</li>
</ul>
<h2 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h2><p>PFRA的目标之一是<strong>能释放共享页框</strong>。为此，Linux 2.6要能快速定位指向同一页框的所有页表项，该过程为<strong>反向映射</strong>。</p>
<p>反向映射解决的简单方式是<strong>在页描述符中引入附加字段，从而将某页描述符所确定的页框中对应的所有页表项连接起来</strong>。为方便更新该链表，Linux 2.6 采用<strong>面向对象的反向映射</strong>技术。对任何可回收的用户态页，内核保留系统中该页所在所有线性区（对象）的反向链接，每个线性区描述符存放一个指向一个描述符的指针，而该内存描述符又包含一个指向一个页全局目录的指针。因此，这些反向链接使得PFRA能够检索引用某页的所有页表项。因为线性区描述符比页描述符少，所以更新共享页的反向链接就比较省时间。</p>
<p>首先，PFRA 必须要确定待回收页是共享的或非共享的，以及是映射页或匿名页。为此，内核要查看页描述符的两个字段：<code>_mapcount</code>和<code>mapping</code>。<code>_mapcount</code>字段存放引用页框的页表项数目，初值为-1，表示没有页表项引用该页框；如果为0，表示页是非共享的；如果大于0，表示页是共享的。<br><code>page_mapcount</code>函数接收页描述符地址，返回值为<code>_mapcount+1</code>（这样，如果返回值为 1，表明是某个进程的用户态地址控件存放的一个非共享页）。</p>
<p><code>mapping</code>字段用于确定页是映射的或匿名映射的。</p>
<ul>
<li>如果<code>mapping</code>字段空，则该页属于交换高速缓存。</li>
<li>如果<code>mapping</code>字段非空，且最低位是1，表示该页是匿名页；同时<code>mapping</code>字段中存放指向<code>anon_vma</code>描述符的指针。</li>
<li>如果<code>mapping</code>字段非空，且最低位是0，表示该页是映射页；同时<code>mapping</code>字段指向对应文件的<code>address_space</code>对象。</li>
</ul>
<p>Linux的<code>address_space</code>对象在RAM中是对齐的，所以其起始地址是4的倍数。因此其<code>mapping</code>字段的最低位可以用一个标志位来表示该字段的指针是指向<code>address_space</code>对象还是<code>anon_vma</code>描述符。<code>PageAnon()</code>参数为页描述符，如果<code>mapping</code>字段的最低位置位，则函数返回1；否则返回0。</p>
<p><code>try_to_unmap()</code>参数为页描述符指针，它尝试<strong>清空所有引用该页描述符对应页框的页表项</strong>。如果从页表项中成功清除所有对该页框的应用，函数返回<code>SWAP_SUCCESS(0)</code>；否则返回<code>SWAP_AGAIN(1)</code>；出错返回<code>SWAP_FAIL(2)</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">try_to_unmap</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">if</span>(PageAnon(page))  <span class="comment">// mapping 字段指向 aon_vma</span></span><br><span class="line">		ret = try_to_unmap_anon(page);  <span class="comment">// 清空对页框的引用，处理匿名页</span></span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">// mapping 字段指向 address_space</span></span><br><span class="line">		ret = try_to_unmap_file(page);   <span class="comment">// 清空对页框的引用，处理映射页</span></span><br><span class="line">	<span class="keyword">if</span>(!page_mapped(page))</span><br><span class="line">		ret = SWAP_SUCCESS;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="匿名页的反向映射"><a href="#匿名页的反向映射" class="headerlink" title="匿名页的反向映射"></a>匿名页的反向映射</h3><p>匿名页经常由几个进程共享。最常见的情形：<strong>创建新进程</strong>，父进程的所有页框，包括匿名页，同时也分配给子进程。另外（不常见），进程创建线性区时使用两个标志<code>MAP_ANONYMOUS</code>和<code>MAP_SHARED</code>，表明这个区域内的也将由该进程后面的子进程共享。</p>
<p>将引用同一页框的所有匿名页链接起来的策略：<strong>将该页框所在的匿名线性区存放在一个双向循环链表中</strong>。注意：即使一个匿名线性区存有不同的页，也始终只有一个反向映射链表用于该区域中的所有页框。</p>
<p>当为一个匿名线性区分配第一页时，内核创建一个新的<code>anon_vma</code>数据结构，它只有两个字段：</p>
<ul>
<li><code>lock</code>，竞争条件下保护链表的自旋锁。</li>
<li><code>head</code>，线性区描述符双向循环链表的头部。</li>
</ul>
<p>然后，内核将匿名线性区的<code>vm_area_struct</code>描述符插入<code>anon_vma</code>链表。<code>vm_area_struct</code>中对应链表的两个字段：</p>
<ul>
<li><code>anon_vma_node</code>，存放指向链表中前一个和后一个元素的指针。</li>
<li><code>anon_vma</code>，指向<code>anon_vma</code>数据结构。</li>
</ul>
<p>最后，内核将<code>anon_vma</code>数据结构的地址存放在匿名页描述符的<code>mapping</code>字段。<br><img src="/img/1604497477.jpg" alt=""></p>
<p>当已被一个进程引用的页框插入另一个进程的页表项时（如调用<code>fork()</code>时），内核只是将第二个进程的匿名线性区插入<code>anon_vma</code>数据结构的双向循环链表，而第一个进程线性区的<code>anon_vma</code>字段指向该<code>anon_vma</code>数据结构。因此，每个<code>anon_vma</code>链表通常包含不同进程的线性区。</p>
<p>借助<code>anon_vma</code>链表，内核可快速定位引用同一匿名页框的所有页表项。每个区域描述符在<code>vm_mm</code>字段中存放内存描述符地址，而该内存描述符又有一个<code>pgd</code>字段，其中存有进程的页全局目录。这样，页表项就可以从匿名页的起始线性地址得到，该线性地址可以由线性区描述符及页描述符的<code>index</code>字段得到。</p>
<h3 id="try-to-unmap-anon"><a href="#try-to-unmap-anon" class="headerlink" title="try_to_unmap_anon()"></a>try_to_unmap_anon()</h3><p>当回收匿名页框时，PFRA必须扫描<code>anon_vma</code>链表中的所有线性区，检查是否每个区域都存有一个匿名页，而其对应的页框就是目标页框。该工作通过<code>try_to_unmap_anon()</code>实现，参数为目标页框描述符，步骤：</p>
<ol>
<li>获得<code>anon_vma</code>数据结构的自旋锁，页描述符的<code>mapping</code>字段指向该数据结构。</li>
<li>扫描线性区描述符的<code>anon_vma</code>链表。对该链表中的每个<code>vma</code>线性区描述符调用<code>try_to_unmap_one()</code>，参数为<code>vma</code>和页描述符。如果返回<code>SWAP_FAIL</code>，或如果页描述符的<code>_mapcount</code>字段表明已找到所有引用该页框的页表项，停止扫描。</li>
<li>释放第1步得到的自旋锁。</li>
<li>返回最后调用<code>try_to_unmap_one()</code>得到的值：<code>SWAP_AGAIN</code>（部分成功）或<code>SWAP_FAIL</code>（失败）。</li>
</ol>
<h3 id="try-to-unmap-one"><a href="#try-to-unmap-one" class="headerlink" title="try_to_unmap_one()"></a>try_to_unmap_one()</h3><p>被<code>try_to_unmap_anon()</code>和<code>try_to_unmap_file()</code>调用。参数：</p>
<ul>
<li><code>page</code>，指向目标页描述符的指针。</li>
<li><code>vma</code>，指向线性区描述符的指针。</li>
</ul>
<ol>
<li>计算出待回收页的线性地址。依据参数：<strong>线性区的起始线性地址</strong>（<code>vma-&gt;vm_start</code>）、<strong>被映射文件的线性区偏移量</strong>（<code>vm-&gt;vm_pgoff</code>）和<strong>被映射文件内的页偏移量</strong>（<code>page-&gt;index</code>）。对于匿名页，<code>vma-&gt;vm_pgoff</code>字段是0或者<code>vm_start/PAGE_SIZE</code>；<code>page-&gt;index</code>字段是区域内的页索引或页的线性地址除以<code>PAGE_SIZE</code>。</li>
<li>如果目标页是匿名页，则检查页的线性地址是否在线性区内。如果不是，则结束并返回<code>SWAP_AGAIN</code>。</li>
<li>从<code>vma-&gt;vm_mm</code>得到内存描述符地址，并获得保护页表的自旋锁<code>vma-&gt;vm_mm-&gt;page_table_lock</code>。</li>
<li>成功调用<code>pgd_offset()</code>、<code>pud_offset()</code>、<code>pmd_offset()</code>和<code>pte_offset_map()</code>以获得对应目标页线性地址的页表项地址。</li>
<li>执行一些检查来验证目标页可有效回收。以下检查中，如果任何一项失败，跳到第12步，结束并返回一个有关的错误码：<code>SWAP_AGAIN</code>或<code>SWAP_FAIL</code>。<ol>
<li>检查指向目标页的页表项，失败时返回<code>SWAP_AGAIN</code>，可能失败的情形：<ol>
<li>指向页框的页表项与COW关联，而<code>vma</code>标识的匿名线性地址仍然属于原页框的<code>anon_vma</code>链表。</li>
<li><code>mremap()</code>可重新映射线性区，并通过直接修改页表项将页移到用户态地址空间。这种特殊情况下，因为页描述符的<code>index</code>字段不能用于确定页的实际线性地址，所以面向对象的反向映射不能使用了。</li>
<li>文件内存映射是非线性的。</li>
</ol>
</li>
<li>验证线性区不是锁定（<code>VM_LOCKED</code>）或保留（<code>VM_RESERVED</code>）的。如果有锁定（<code>VM_LOCKED</code>）或保留情况之一出现，就返回<code>SWAP_FAIL</code>。</li>
<li>验证页表项中的访问标志位被清0。如果没有，将它清0，并返回<code>SWAP_FAIL</code>。访问标志置位表示页在用，因此不能被回收。</li>
<li>检查页是否始于交换高速缓存，此时它正由<code>get_user_pages()</code>处理。在这种情形下，为避免恶性竞争条件，返回<code>SWAP_FAIL</code>。</li>
</ol>
</li>
<li>页可以被回收。如果页表项的<code>Dirty</code>标志置位，则将页的<code>PG_dirty</code>标志置位。</li>
<li>清空页表项，刷新相应的`TLB。</li>
<li>如果是匿名页，将换出页标识符插入页表项，以便将来访问时将该页换入。而且，递减存放在内存描述符<code>anon_rss</code>字段中的匿名页计数器。</li>
<li>递减存放在内存描述符<code>rss</code>字段中的页框计数器。</li>
<li>递减页描述符的<code>_mapcount</code>字段，因为对用户态页表项中页框的引用已被删除。</li>
<li>递减存放在页描述符<code>_count</code>字段中的页框使用计数器。如果计数器变为负数，则从活动或非活动链表中删除页描述符，且调用<code>free_hot_page()</code>释放页框。</li>
<li>调用<code>pte_unmap()</code>释放临时内核映射，因为第4步中的<code>pte_offset_map()</code>可能分配了一个这样的映射。</li>
<li>释放第3步中获得的自旋锁<code>vma-&gt;vm_mm-&gt;page_table_lock</code>。</li>
<li>返回相应的错误码（成功时返回<code>SWAP_AGAIN</code>）。</li>
</ol>
<h2 id="映射页的反向映射"><a href="#映射页的反向映射" class="headerlink" title="映射页的反向映射"></a>映射页的反向映射</h2><p>映射页的面向对象对象反向映射所基于的思想：<strong>总是可以获得指向一个给定页框的页表项，方式就是访问相应映射页所在的线性区描述符</strong>。因此，反向映射的关键是一个精巧的数据结构，该数据结构可存放与给定页框有关的所有线性区描述符。</p>
<p>与匿名页相反，映射页经常是共享的，因为不同的进程常会共享同一个程序代码。因此，Linux 2.6采用<strong>优先搜索树</strong>的结构快速定义引用同一页框的所有线性区。</p>
<p>每个文件对应一个优先搜索树。它存放在<code>address_space</code>对象的<code>i_mmap</code>字段，该对象包含在文件的索引节点对象中。因为映射页描述符的<code>mapping</code>字段指向<code>address_space</code>对象，所以总能快速检索搜索树的根。</p>
<h3 id="优先搜索树PST"><a href="#优先搜索树PST" class="headerlink" title="优先搜索树PST"></a>优先搜索树PST</h3><p><code>PST</code>用于表示一组相互重叠的区间，也叫做McCreight树。PST的每个区间相当于一个树的节点，由<strong>基索引</strong>和<strong>堆索引</strong>两个索引标识。基索引表示区间的起始点，堆索引表示终点。PST实际上是一个依赖于基索引的搜索树，并附加一个类堆属性，即一个节点的堆索引不会小于其子节点的堆索引。</p>
<p>Linux中的PST的不同之处：<strong>不对称</strong>；<strong>被修改程存放线性区而不是线性区间</strong>。每个线性区可被看作是文件页的一个区间，并由在文件中的起始位置（基索引）和终点位置（堆索引）所确定。但是，线性区通常是从同一页开始，为此，PST的每个节点还附带一个<strong>大小索引</strong>，值为线性区大小（页数）减1。该大小索引使搜索程序能区分同一起始文件位置的不同线性区。</p>
<p>但大小索引会大大增加不同的节点数，会使PST溢出。为此，PST可以包括<strong>溢出子树</strong>，该子树以PST的叶为根，且包含具有相同基索引的节点。</p>
<p>此外，不同进程拥有的线性区可能是映射了相同文件的相同部分。当必须在PST中插入一个与现存某个节点具有相同索引值的线性区时，内核将该线性区描述符插入一个以原PST节点为根的双向循环列表。<br><img src="/img/1604505066.jpg" alt=""></p>
<p>上图的左侧有七个线性区覆盖着一个文件的前六页。每个区间标有基索引、堆索引和大小索引。图的右侧则是对应的PST。子节点的堆索引都不大于相应父节点的堆索引，任意一个节点的左子节点基索引也都不大于右子节点基索引，如果基索引相等则按照大小索引排序。</p>
<p>讨论由<code>prio_tree_node</code>数据结构表示的一个PST节点。该数据结构在每个线性区描述符的<code>shared.prio_tree_node</code>字段中。<code>shared.vm_set</code>数据结构作为<code>shared.prio_tree_node</code>的替代品，可将线性区描述符插入一个PST节点的链表副本。可用<code>vma_prio_tree_insert()</code>和<code>vma_prio_tree_remove()</code>分别插入和删除PST节点。两个函数的参数都是线性区描述符地址与PST根地址。对PST的搜索可调用<code>vma_prio_tree_foreach</code>宏实现，该宏循环搜索所有线性区描述符，这些描述符在给定范围的线性地址中包含至少一页。</p>
<h3 id="try-to-unmap-file"><a href="#try-to-unmap-file" class="headerlink" title="try_to_unmap_file()"></a>try_to_unmap_file()</h3><p>被<code>try_to_unmap()</code>调用，指向映射页的反向映射。执行步骤如下：</p>
<ol>
<li>获得<code>page-&gt;mapping-&gt;i_mmap_lock</code>自旋锁。</li>
<li>对搜索树应用<code>vma_prio_tree_foreach()</code>宏，搜索树的根存放在<code>page-&gt;mapping-&gt;i_mmap</code>字段。对宏发现的每个<code>vm_area_struct</code>描述符，调用<code>try_to_unmap_one()</code>对该页所在的线性区页表项清0。失败时返回<code>SWAP_FAIL</code>，或者如果页描述符的<code>_mapcount</code>字段表明引用该页框的所有页表项都已找到，则搜索过程结束。</li>
<li>释放<code>page-&gt;mapping-&gt;i_mmap_lock</code>自旋锁。</li>
<li>根据所有的页表项清0与否，返回<code>SWAP_AGAIN</code>或<code>SWAP_FAIL</code>。</li>
</ol>
<p>如果映射是非线性的，则<code>try_to_unmap_one()</code>可能无法清0某些页表项，因为页描述符的<code>index</code>不再对应线性区中的页位置，<code>try_to_unmap_one()</code>就无法确定页的线性地址，也就无法得到页表项地址。</p>
<p>唯一的解决方法是<strong>对文件非线性区的穷尽搜索</strong>。双向链表以文件的所有非线性区的描述符所在的<code>page-&gt;mapping</code>文件的<code>address_space</code>对象的<code>i_mmap_nonlinear</code>字段为根。对每个这样的线性区，<code>try_to_unmap_file()</code>调用<code>try_to_unmap_cluster()</code>扫描该线性区地址所对应的所有页表项，并尝试将它们清0。</p>
<p>因为搜索可能很费时，所以执行有限扫描，而且通过试探法决定扫描线性区的哪一部分，<code>vma_area_struct</code>描述符的<code>vm_private_data</code>字段存有当前扫描的指针。因此<code>try_to_unmap_fie()</code>在某些清空下可能会找不到待停止映射的页，这时，<code>try_to_umap()</code>发现页仍然是映射的，则返回<code>SWAP_AGAIN</code>，而不是<code>SWAP_SUCCESS</code>。</p>
<h2 id="PFRA实现"><a href="#PFRA实现" class="headerlink" title="PFRA实现"></a>PFRA实现</h2><p>页框回收算法必须处理多种属于用户态进程、磁盘高速缓存和内存高速缓存的页，且必须遵照几条试探法则，函数较多。<br><img src="/img/1604505540.jpg" alt=""></p>
<p>PFRA有几个入口。实际上，页框回收算法的执行有三种基本情形：</p>
<ul>
<li><strong>内存紧缺回收</strong>，内核发现内存紧缺。</li>
<li><strong>睡眠回收</strong>，在进入<code>suspend_to_disk</code>状态时，内核必须释放内存。</li>
<li><strong>周期回收</strong>，必要时，周期性激活内核线程执行内存回收算法。</li>
</ul>
<p>内存紧缺回收激活情形：</p>
<ul>
<li><code>grow_buffers()</code>无法获得新的缓冲区页。</li>
<li><code>alloc_page_buffers()</code>无法获得页临时缓冲区首部。</li>
<li><code>__alloc_pages()</code>无法在给定的内存管理区中分配一组连续页框。</li>
</ul>
<p>周期回收由两种不同的内核线程激活：</p>
<ul>
<li><code>kswapd</code>内核线程，它检查某个内存管理区中空闲页框数是否已低于<code>pages_high</code>值。</li>
<li><code>events</code>内核线程，它是预定义工作队列的工作者线程；PFRA周期性地调度预定义工作队列中的一个任务执行，从而回收slab分配器处理的位于内存高速缓存中的所有空闲slab。</li>
</ul>
<h3 id="最近最少使用（LRU）链表"><a href="#最近最少使用（LRU）链表" class="headerlink" title="最近最少使用（LRU）链表"></a>最近最少使用（LRU）链表</h3><p>属于进程用户态地址和空间或页高速缓存的所有页被分成两组：<strong>活动链表和非活动链表</strong>，它们被统称为<strong>LRU链表</strong>。活动链表存放最近被访问过的页；非活动链表存放有一段时间没有被访问过的页。显然，页必须从非活动链表窃取。</p>
<p>两个双向链表的头分别存放在每个<code>zone</code>描述符的<code>active_list</code>和<code>inactive_list</code>字段，<code>nr_active</code>和<code>nr_inactive</code>字段表示存放在两个链表中的页数。<code>lru_lock</code>字段是一个自旋锁，保护两个链表免受SMP系统上的并发访问。</p>
<p>如果页属于LRU链表，则设置页描述符的<code>PG_lru</code>标志。如果页属于活动链表，则设置<code>PG_active</code>标志，如果页属于非活动链表，则清<code>PG_active</code>标志。页描述符的<code>lru</code>字段存放指向LRU链表中下一个元素和前一个元素的指针。</p>
<p>常用辅助函数处理LRU链表：</p>
<ul>
<li><code>add_page_to_active_list()</code>:将页加入管理区的活动链表头部并递增管理区描述符的<code>nr_active</code>字段</li>
<li><code>add_page_to_inactive_list()</code>:将页加入管理区的非活动链表头部并递增管理区描述符的<code>nr_inactive</code>字段</li>
<li><code>del_page_from_active_list()</code>:从管理区的活动链表中删除页并递减管理区描述符的<code>nr_active</code>字段</li>
<li><code>del_page_from_inactive_list()</code>:从管理区的非活动链表中删除页并递减管理区描述符的<code>nr_inactive</code>字段</li>
<li><code>del_page_from_lru()</code>:检查页的<code>PG_active</code>标识。根据检查结果，将页从活动或非活动链表中删除，递减管理区描述符的<code>nr_active</code>或者<code>nr_inactive</code>字段，且如有必要，将<code>PG_active</code>清0</li>
<li><code>activate_page()</code>:检查<code>PG_active</code>标识，如果没置位，将页移到活动链表中，依次调用<code>del_page_from_inactive_list()</code>和<code>add_page_to_active_lsit()</code>，最后将<code>PG_active</code>置位。</li>
<li><code>lru_cache_add()</code> 如果页不在LRU链表中，将<code>PG_lru</code>标志置位，得到管理区的<code>lru_lock</code>自旋锁，调用<code>add_page_to_inactive_list()</code>把页插入管理区的非活动链表</li>
<li><code>lru_cache_add_active()</code>:如果页不在LRU链表中，将<code>PG_lru</code>和<code>PG_active</code>标志置位，得到管理区的<code>lru_lock</code>自旋锁，调用<code>add_page_to_active_list()</code>把页插入管理区的活动链表</li>
</ul>
<h3 id="在LRU链表之间移动页"><a href="#在LRU链表之间移动页" class="headerlink" title="在LRU链表之间移动页"></a>在LRU链表之间移动页</h3><p>PFRA将最近访问过的页集中放在活动链表上，<strong>将很长时间没有访问过的页集中放在非活动链表上</strong>。但是，两个状态不足以描述页的所有情况，因为PFRA不能预测用户的行为。</p>
<p>页描述符中的<code>PG_referenced</code>标志用来<strong>把一个页从非活动链表移到活动链表所需的访问次数加倍</strong>，也把一个页从活动链表移动到非活动链表所需的“丢失访问”次数加倍。例如：如果非活动链表的<code>PG_referenced</code>为0，第一次访问把这个标志置为1，但这一页仍然留在非活动链表；第二次访问这个标志为1时，才移动到活动链表。<strong>偶尔一次的访问并不能说明这个页是“活动的”</strong>。但如果第一次访问后在给定时间间隔内没有再次访问，则页框回收算法可能重置<code>PG_referenced</code>标志。</p>
<p><img src="/img/1604570227.jpg" alt="">\</p>
<p>PFRA使用<code>mark_page_accessed()</code>、<code>page_referenced()</code>、<code>refill_inactive_zone()</code>函数在LRU链表之间移动页。</p>
<h4 id="mark-page-accessed"><a href="#mark-page-accessed" class="headerlink" title="mark_page_accessed()"></a>mark_page_accessed()</h4><p><code>mark_page_accessed()</code>把页标记为访问过。每当内核决定一个页是被用户态进程、文件系统层还是设备驱动程序引用时，该情况就会发生。调用<code>mark_page_accessed()</code>的情况：</p>
<ul>
<li>当按需装入进程的一个匿名页时。（<code>do_anonymous_page()</code>）</li>
<li>当按需装入内存映射文件的一个页时。（<code>filemap_nopage()</code>）</li>
<li>当按需装入 IPC 共享内存区的一个页时。（<code>sheme_nopage()</code>）</li>
<li>当从文件读取数据页时。（<code>do_generic_file_read()</code>）</li>
<li>当换入一个页时。（<code>do_swap_page()</code>）</li>
<li>当在页高速缓存中搜索一个缓冲区页时。（<code>__fild_get_block()</code>）</li>
</ul>
<p><code>mark_page_accessed()</code>执行下列代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(!PageActive(page) &amp;&amp; PageReferenced(page) &amp;&amp; PageLRU(page))</span><br><span class="line">&#123;</span><br><span class="line">	activate_page(page);</span><br><span class="line">	ClearPageReferenced(page);</span><br><span class="line">&#125;</span><br><span class="line">else if(!PageReferenced(page))</span><br><span class="line">	SetPageReferenced(page);</span><br></pre></td></tr></table></figure></p>
<h4 id="page-referenced"><a href="#page-referenced" class="headerlink" title="page_referenced()"></a>page_referenced()</h4><p>PFRA扫描一页调用一次<code>page_referenced()</code>，如果<code>PG_referenced</code>标志或页表项中的某些<code>Accessed</code>标志置位，则返回1；否则返回0。</p>
<ul>
<li>首先检查页描述符的<code>PG_referenced</code>标志，如果该标志置位则清0。</li>
<li>然后使用面向对象的反向映射方法，对引用该页的所有用户态页表项中的<code>Accessed</code>标志位进行检查并清0。</li>
</ul>
<p>从活动链表到非活动链表移动页不是由<code>page_referenced()</code>实施，而是<code>refile_inactive_zone()</code>。</p>
<h4 id="refile-inactive-zone"><a href="#refile-inactive-zone" class="headerlink" title="refile_inactive_zone()"></a>refile_inactive_zone()</h4><p>被<code>shrink_zone()</code>调用，<code>shrink_zone()</code><strong>对页高速缓存和用户态地址空间进行页回收</strong>。两个参数：</p>
<ul>
<li><code>zone</code>：指向内存管理区描述符</li>
<li><code>sc</code>：指向一个<code>scan_control</code>结构</li>
</ul>
<p><img src="/img/1604396536.png" alt=""></p>
<p><code>refile_inactive_zone()</code>的工作很重要，因为从活动链表移到非活动链表就意味着页迟早被PFRA捕获。如果该函数过激，就会由过多的页从活动链表移动到非活动链表，PFRA就会回收大量的页框，系统性能就会受到影响。但如果该函数太懒，就没有足够的未用页来补充非活动链表，PFRA就不能回收内存。因此，该函数可调整自己的行为：开始时，对每次调用，扫描非活动链表中少量的页，但当PFRA很难回收内存时，就在每次被调用时增加扫描的活动页数。</p>
<p>还有一个试探法可调整该函数的行为。LRU 链表中有两类页：属于用户态地址空间的页、不属于任何用户态进程且在页高速缓存中的页。PFRA倾向于压缩页高速缓存，而将用户态进程的页留在RAM中。该函数使用<strong>交换倾向经验值</strong>确定是移动所有的页还是只移动不属于用户态地址空间的页。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换倾向值 = 映射比率 / 2 + 负荷值 + 交换值</span><br></pre></td></tr></table></figure></p>
<p>映射比率是<strong>用户态地址空间所有内存管理区的页（<code>sc-&gt;nr_mapped</code>）占有可分配页框数的百分比</strong>。映射比率值大时表示动态内存大部分用于用户态进程，小则表示大部分用于页高速缓存。</p>
<p>负荷值用于<strong>表示PFRA在管理区中回收页框的效率</strong>。依据是前一次PFRA运行时管理区的扫描优先级，该优先级存放在管理区描述符的<code>prev_priority</code>字段。</p>
<p><strong>交换值</strong>是一个用户定义常数，通常为60。系统管理员可在<code>/proc/sys/vm/swappiness</code>文件内修改该值，或用相应的<code>sysctl()</code>调整该值。</p>
<p>当管理区交换倾向值大于等于100时，页才从进程地址空间回收。<br>当系统管理员将交换值设为0时，PFRA就不会从用户态地址空间回收页，除非管理区的前一次优先级为0（不太可能）。如果管理员将交换值设为100，则PFRA每次调用该函数时都会从用户态地址空间回收页。</p>
<p><code>refill_inactive_zone()</code>：</p>
<ol>
<li>调用<code>lru_add_drain()</code>把仍留在<code>pagevec</code>中的所有页移入活动与非活动链表。</li>
<li>获得<code>zone-&gt;lru_lock</code>自旋锁。</li>
<li>首次扫描<code>zone-&gt;active_list</code>中的页，从链表的底部开始向上，直到链表为空或<code>sc-&gt;nr_to_scan</code>的页扫描完毕。每扫描一页，就将引用计数器加1，从<code>zone-&gt;active_list</code>中删除页描述符，把它放在临时局部链表<code>l_hold</code>中。但是如果页框引用计数器是0，则把该页放回活动链表。<br>实际上，引用计数器为0的页框一定属于管理区的伙伴系统，但释放页框时，首先递减使用计数器，然后将页框从LRU链表删除并插入伙伴系统链表。因此在一个很小的时间段，PFRA可能会发现LRU链表中的空闲页。</li>
<li>把已扫描的活动页数追加到<code>zone-&gt;pages_scanned</code>。</li>
<li>从<code>zone-&gt;nr_active</code>中减去移入局部链表<code>l_load</code>中的页数。</li>
<li>释放<code>zone-&gt;lru_lock</code>自旋锁。</li>
<li>计算交换倾向值。</li>
<li>扫描局部链表<code>l_hold</code>中的页。目的：把其中的页分到两个子链表<code>l_active</code>和<code>l_inactive</code>中。属于某个进程用户态地址空间的页（即<code>page-&gt;_mapcount</code>为负数的页）被加入<code>l_active</code>的条件是：<ol>
<li>交换倾向值小于100</li>
<li>匿名页但又没有激活的交换区</li>
<li>应用于该页的<code>page_referenced()</code>返回正数（该页最近被访问过）</li>
<li>而在其他情形下，页被加入<code>l_incative</code>链表。</li>
</ol>
</li>
<li>获得<code>zone-&gt;lru_lock</code>自旋锁。</li>
<li>扫描链表<code>l_inactive</code>中的页。把页移入<code>zone-&gt;inactive_list</code>链表，更新<code>zone-&gt;nr_inactive</code>字段，同时递减被移页框的使用计数器，从而抵消第3步中增加的值。</li>
<li>扫描局部链表<code>l_active</code>中的页。把页移入<code>zone-&gt;active_list</code>链表，更新<code>zone-&gt;nr_active</code>字段，同时递减被移页框的使用计数器，从而抵消第3步中增加的值。</li>
<li>释放自旋锁<code>zone-&gt;lru_lock</code>并返回。</li>
</ol>
<h3 id="内存紧缺回收"><a href="#内存紧缺回收" class="headerlink" title="内存紧缺回收"></a>内存紧缺回收</h3><p>当内存分配失败时激活内存紧缺回收。在分配VFS缓冲区或缓冲区首部时，内核调用<code>free_more_memory()</code>；而当从伙伴系统分配一个或多个页框时，调用<code>try_to_free_pages()</code>。</p>
<h4 id="free-more-memory"><a href="#free-more-memory" class="headerlink" title="free_more_memory()"></a>free_more_memory()</h4><ol>
<li>调用<code>wakeup_bdflush()</code>唤醒一个<code>pdflush</code>内核线程，并触发页高速缓存中1024个脏页的写操作。写脏页到磁盘的操作将最终包含缓冲区、缓冲区首部和其他VFS数据结构的页框变为可释放的。</li>
<li>调用<code>sched_yield()</code>的服务例程为<code>pdflush</code>内核线程提供执行机会。</li>
<li>对系统的所有内存节点，启动一个循环。对每一个节点，调用<code>try_to_free_pages()</code>，参数为一个“紧缺”内存管理区链表。</li>
</ol>
<h4 id="try-to-free-pages"><a href="#try-to-free-pages" class="headerlink" title="try_to_free_pages()"></a>try_to_free_pages()</h4><p>参数：</p>
<ul>
<li><code>zones</code>，要回收的页所在的内存管理区链表。</li>
<li><code>gfp_mask</code>，用于识别的内存分配的一组分配标志。</li>
<li><code>order</code>，没有使用。</li>
</ul>
<p>函数的目标是通过重复调用<code>shrink_caches()</code>和<code>shrink_slab()</code>释放至少32个页框，每次调用后优先级会比前一次提高。有关的辅助函数可获得<code>scan_control</code>类型描述符中的优先级，以及正在进行的扫描操作的其他参数。如果<code>try_to_free_pages()</code>没能在某次调用<code>shrink_caches()</code>和<code>shrink_slab()</code>时成功回收至少32个页框，PFRA就无策了。最后一招：<strong><code>out_of_memory()</code>删除一个进程，释放它的所有页框</strong>。</p>
<p>try_to_free_pages()：</p>
<ol>
<li>分配和初始化一个<code>scan_control</code>描述符，具体说就是把分配掩码<code>gfp_mask</code>存入<code>gfp_mask</code>字段。</li>
<li>对<code>zones</code>链表中的每个管理区，将管理区描述符的<code>temp_priority</code>字段设为初始优先级12，而且计算管理区LRU链表中的总页数。</li>
<li>从优先级12到0，执行最多13次循环，每次迭代执行如下子步骤：<ol>
<li>更新<code>scan_control</code>描述符的一些字段。<code>nr_mapped</code>为用户态进程的总页数；<code>priority</code>为本次迭代的当前优先级；<code>nr_scanned</code>和<code>nr_relcaimed</code>字段设为0。</li>
<li>调用<code>shrink_caches()</code>，参数为<code>zones</code>链表和<code>scan_control</code>描述符，扫描管理区的非活动页。</li>
<li>调用<code>shrink_slab()</code>从可压缩内核高速缓存中回收页。</li>
<li>如果<code>current-&gt;reclaim_state</code>非空，则将slab分配器高速缓存中回收的页数追加到<code>scan_control</code>描述符的<code>nr_reclaimed</code>字段。在调用<code>try_to_free_pages()</code>前，<code>__alloc_pages()</code>建立<code>current-&gt;reclaim_state</code>字段，并在结束后马上清除该字段。</li>
<li>如果已达到目标，则跳出循环到第4步。</li>
<li>如果未达目标，但已扫描完成至少49页，则调用<code>wakeup_bdflush()</code>激活<code>pdflush</code>内核线程，并将页高速缓存中的一些脏页写入磁盘。</li>
<li>如果函数已完成4次迭代而又未达目标，则调用<code>blk_congestion_wait()</code>挂起进程，一直到没有拥塞的<code>WRITE</code>请求队列或100ms超时已到。</li>
</ol>
</li>
<li>把每个管理区描述符的<code>prev_priority</code>字段设为上一次调用<code>shrink_caches()</code>使用的优先级，该值存放在管理区描述符的<code>temp_priority</code>字段。</li>
<li>如果成功回收则返回1，否则返回0。</li>
</ol>
<h4 id="shrink-caches"><a href="#shrink-caches" class="headerlink" title="shrink_caches()"></a>shrink_caches()</h4><p>被<code>try_to_free_pages()</code>调用，参数：内存管理区链表<code>zones</code>和<code>scan_control</code>描述符地址<code>sc</code>。</p>
<p>该函数的目的只是对<code>zones</code>链表中的每个管理区调用<code>shrink_zone()</code>。但对给定管理区调用<code>shrink_zone()</code>前，<code>shrink_caches()</code>用<code>sc-&gt;priority</code>字段的值更新管理区描述符的<code>temp_priority</code>字段，这就是扫描操作的当前优先级。而且如果PFRA的上一次调用优先级高于当前优先级，即该管理区进行页框回收变得更难了，在<code>shrink_caches()</code>把当前优先级拷贝到管理区描述符的<code>prev_priority</code>。最后，如果管理区描述符中的<code>all_unreclaimable</code>标志置位，且当前优先级小于12，则<code>shrink_caches()</code>不调用<code>shrink_zone()</code>，即在<code>try_to_free_pages()</code>的第一次迭代中不调用<code>shrink_caches()</code>。当PFRA确定一个管理区都是不可回收页，扫描该管理区的页纯粹是浪费时间时，则将<code>all_unreclaimable</code>标志置位。</p>
<h4 id="shrink-zone"><a href="#shrink-zone" class="headerlink" title="shrink_zone()"></a>shrink_zone()</h4><p>两个参数：<code>zone</code>和<code>sc</code>。<code>zone</code>是指向<code>struct_zone</code>描述符的指针；<code>sc</code>是指向<code>scan_control</code>描述符的指针。目标是<strong>从管理区非活动链表回收32页</strong>。它每次在更大的一段管理区非活动链表上重复调用辅助函数<code>shrink_cache()</code>。而且<code>shrink_zone()</code>重复调用<code>refill_incative_zone()</code>来补充管理区非活动链表。</p>
<p>管理区描述符的<code>nr_scan_active</code>和<code>nr_scan_inactive</code>字段在这里起到很重要的作用。为提高效率，函数每批处理32页。因此，如果函数在低优先级运行（对应<code>sc-&gt;priority</code>的高值），且某个LRU链表中没有足够的页，函数就跳过对它的扫描。但因此跳过的活动或不活动页数存放在<code>nr_scan_active</code>或<code>nr_scan_inactive</code>中，这样函数下次执行时再处理这些跳过的页。</p>
<p><code>shrink_zone()</code>具体执行步骤如下：</p>
<ol>
<li>递增<code>zone-&gt;nr_scan_active</code>，增量是活动链表（<code>zone-&gt;nr_active</code>）的一小部分。实际增量取决于当前优先级，其范围是：<code>zone-&gt;nr_active/2^&#123;12&#125;</code>到<code>zone-&gt;nr_active/2^&#123;0&#125;</code>（即管理区的总活动页数）。</li>
<li>递增<code>zone-&gt;nr_scan_inactive</code>，增量是非活动链表（<code>zone-&gt;nr_inactive</code>）的一小部分。实际增量取决于当前优先级，其范围是：<code>zone-&gt;nr_active/2^&#123;12&#125;</code>到<code>zone-&gt;nr_inactive</code>。</li>
<li>如果<code>zone-&gt;nr_scan_active</code>字段大于等于32，函数就把该值赋给局部变量<code>nr_active</code>，并把该字段设为0，否则把<code>nr_active</code>设为0。</li>
<li>如果<code>zone-&gt;nr_scan_inactive</code>字段大于等于32，函数就把该值赋给局部变量<code>nr_inactive</code>，并把该字段设为0，否则把<code>nr_inactive</code>设为0。</li>
<li>设定<code>scan_control</code>描述符的<code>sc-&gt;nr_to_recalim</code>字段为32。</li>
<li>如果<code>nr_active</code>和<code>nr_inactiv</code>都为0，则无事可做，函数结束。这不常见，用户态进程没有被分配到任何页时才可能出现这种情形。</li>
<li>如果<code>nr_active</code>为正，则补充管理区非活动链表： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc-&gt;nr_to_scan = min(nr_active, 32)</span><br><span class="line">nr_active -= sc-&gt;nr_to_scan</span><br><span class="line">refill_inactive_zone(zone, sc)</span><br></pre></td></tr></table></figure></li>
<li>如果<code>nr_inactive</code>为正，则尝试从非活动链表回收最多32页： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc-&gt;nr_to_scan = min(nr_inactive, 32)</span><br><span class="line">nr_inactive -= sc-&gt;nr_to_scan</span><br><span class="line">shrink_cache(zone, sc)</span><br></pre></td></tr></table></figure></li>
<li>如果<code>shrink_zone()</code>成功回收32页，则结束；否则，跳回第6步。</li>
</ol>
<h4 id="shrink-cache"><a href="#shrink-cache" class="headerlink" title="shrink_cache()"></a>shrink_cache()</h4><p><code>shrink_cache()</code>是一个辅助函数，其目的是<strong>从管理区非活动链表取出一组页，把它们放入一个临时链表，然后调用<code>shrink_list()</code>对该链表中的每个页进行有效的页框回收操作</strong>。参数与<code>shrink_zones()</code>一样，都是<code>zone</code>和<code>sc</code>，执行的主要步骤：</p>
<ol>
<li>调用<code>lru_add_drain()</code>，把仍然在<code>pagevec</code>数据结构中的页移入活动与非活动链表。</li>
<li>获得<code>zone-&gt;lru_lock</code>自旋锁。</li>
<li>处理非活动链表的页（最多32页），对于每一页，函数递增使用计数器；检查该页是否不会被释放到伙伴系统；把页从管理区非活动链表移入一个局部链表。</li>
<li>把<code>zone-&gt;nr_inactive</code>计数器的值减去从非活动链表中删除的页数。</li>
<li>递增<code>zone-&gt;pages_scanned</code>计数器的值，增量为在非活动链表中有效检查的页数。</li>
<li>释放<code>zone-&gt;lru_lock</code>自旋锁。</li>
<li>调用<code>shrink_list()</code>，参数为第3步中搜集的页（在局部链表中）。</li>
<li>把<code>sc-&gt;nr_to_reclaim</code>字段的值减去由<code>shrink_list()</code>实际回收的页数。</li>
<li>再次获取<code>zone-&gt;lru_lock</code>自旋锁。</li>
<li>把局部链表中<code>shrink_list()</code>没有成功释放的页放回非活动或活动来链表。<code>shrink_list()</code>有可能置位<code>PG_active</code>标志，从而将某页标记为活动页。该操作使用<code>pagevec</code>数据结构对一组页进行处理。</li>
<li>如果函数扫描的页数至少是<code>sc-&gt;nr_to_scan</code>，且如果没有成功回收目标页数（`sc-&gt;nr_to_reclaim&gt;0），则跳回第3步。</li>
<li>释放<code>zone-&gt;lru_lock</code>自旋锁并结束。</li>
</ol>
<h4 id="shrink-list"><a href="#shrink-list" class="headerlink" title="shrink_list()"></a>shrink_list()</h4><p><code>shrink_list()</code>为页框回收算法的核心部分。从<code>try_to_free_pages</code>到<code>shrink_cache()</code>的目的就是找到一组适合回收的候选页。<code>shrink_list()</code>则从参数<code>page_list</code>链表中尝试回收这些页，第二个参数<code>sc</code>是指向<code>scan_control</code>描述符的指针。当<code>shrink_list()</code>返回时，<code>page_list</code>中剩下的是无法回收的页。</p>
<ol>
<li>如果当前进程的<code>need_resched</code>字段置位，则调用<code>schedule()</code>。</li>
<li>执行一个循环，处理<code>page_list</code>中的每一页。对其中的每个元素，从链表中删除页描述符并尝试回收该页框。如果由于某种原因页框不能释放，则把该页描述符插入一个局部链表。</li>
<li>现在<code>page_list</code>已空，函数在把页描述符从局部链表移回<code>page_list</code>链表。</li>
<li>递增<code>sc-&gt;nr_reclaimed</code>字段，增量为第2步中回收的页数，并返回该数。</li>
</ol>
<p><img src="/img/1604641504.jpg" alt=""><br>上图是代码流程图。</p>
<p><code>shrink_list()</code>处理的每个页框只能有三种结果：</p>
<ul>
<li>调用`free_cold_page()，把页释放到管理区伙伴系统，因此被有效回收。</li>
<li>页没有被回收，因此被重新插入<code>page_list</code>链表。但是，<code>shrink_list</code>假设不久还能回收该页。因此函数让页描述符的<code>PG_active</code>标志保持清0，这样页将被放回内存管理区的非活动链表。</li>
<li>页没有被回收，因此被重新插入<code>page_list</code>链表。但是，或是页正被使用，或是<code>shrink_list()</code>假设近期无法回收该页。函数将页描述符的<code>PG_active</code>标志置位，这样页框将被放回内存管理区的活动链表。</li>
</ul>
<p><code>shrink_list()</code>不会回收锁定页（<code>PG_locked</code>置位）与写回页（<code>PG_writeback</code>置位）。<code>shrink_list()</code>调用<code>page_referenced()</code>检查该页是否最近被引用过。</p>
<p>要回收匿名页，就必须把它加入交换高速缓存，那么就必须在交换区为它保留一个新页槽（<code>slot</code>）。</p>
<p>如果页在某个进程的用户态地址空间（页描述符的<code>_mapcount</code>字段大于等于0），则<code>shrink_list()</code>调用<code>try_to_unmap()</code>寻找引用该页框的所有页表项。当然，只有当该函数返回<code>SWAP_SUCCESS</code>时，回收才可继续。</p>
<p>如果是脏页，则写回磁盘前不能回收，为此，<code>shrink_list()</code>使用<code>pageout()</code>。只有当<code>pageout()</code>不必进行写操作或写操作不久将结束时，回收才可继续。</p>
<p>如果页包含VFS缓冲区，则<code>shrink_list()</code>调用<code>try_to_release_page()</code>释放关联的缓冲区首部。</p>
<p>最后，如果一切顺利，<code>shrink_list()</code>就检查页的引用计数器。如果等于2，则这两个拥有者就是：<strong>页高速缓存</strong>（如果是匿名页，则为交换高速缓存）和<strong>PFRA自己</strong>（<code>shrink_cache()</code>第3步会递增引用计数器）。这种情况下，如果页仍然不为脏，则页可以回收。为此，首先根据页描述符的<code>PG_swapcache</code>标志的值，从页高速缓存或交换高速缓存删除该页，然后，执行函数<code>free_cold_page()</code>。</p>
<h4 id="pageout"><a href="#pageout" class="headerlink" title="pageout()"></a>pageout()</h4><p>当一个脏页必须写回磁盘时，<code>shrink_list()</code>调用<code>pageout()</code>。</p>
<ol>
<li>检查页存放在页高速缓存还是交换高速缓存中。进一步检查该页是否由页高速缓存与PFRA拥有。如果检查失败，则返回<code>PAGE_KEEP</code>。</li>
<li>检查<code>address_space</code>对象的<code>writepage</code>方法是否已定义。如果没有，则返回<code>PAGE_ACTIVATE</code>。</li>
<li>检查当前进程是否可以向块设备（与<code>address_space</code>对象对应）请求队列发出写请求。实际上，<code>kswapd</code>和<code>pdflush</code>内核线程总会发出写请求；<br>而普通进程只有在请求对象不拥塞时才会发出写请求，除非<code>current-&gt;bacing_dev_info</code>字段指向块设备的<code>backing_dev_info</code>数据结构。</li>
<li>检查是否仍然是脏页。如果不是则返回<code>PAGE_CLEAN</code>。</li>
<li>建立一个<code>writeback_control</code>描述符，调用<code>address_space</code>对象的<code>writepage</code>方法以启动一个写回操作。</li>
<li>如果<code>writepage</code>方法返回错误码，则函数返回<code>PAGE_ACTIVATE</code>。</li>
<li>返回<code>PAGE_SUCCCESS</code>。</li>
</ol>
<h4 id="回收可压缩磁盘高速缓存的页"><a href="#回收可压缩磁盘高速缓存的页" class="headerlink" title="回收可压缩磁盘高速缓存的页"></a>回收可压缩磁盘高速缓存的页</h4><p>内核在页高速缓存之外还使用其他磁盘高速缓存，例如目录项耗时缓存与索引节点高速缓存。当要回收其中的页框时，PFRA就必须检查这些磁盘高速缓存是否可压缩。</p>
<p>PFRA处理的每个磁盘高速缓存在初始化时必须注册一个<code>shrinker</code>函数。<code>shrinker</code>函数有两个参数：待回收页框数和一组GFP分配标志。函数按照要求从磁盘高速缓存回收页，然后返回仍然留在高速缓存内的可回收页数。</p>
<p><code>set_shrinker()</code>向PFRA注册一个<code>shrinker</code>函数。该函数分配一个<code>shrinker</code>类型的描述符，在该描述符中存放<code>shrinker</code>函数的地址，然后把描述符插入一个全局链表，该链表存放在<code>shrinker_list</code>全局变量中。<code>set_shrinker()</code>还初始化<code>shrinker</code>描述符的<code>seeks</code>字段，通俗地说，该字段表示：在高速缓存中的元素一旦被删除后重建一个所需的代价。</p>
<p>在Linux 2.6中，向PFRA注册的磁盘高速缓存很少。除了目录项高速缓存和索引节点高速缓存外，注册<code>shrinker</code>函数的只有<strong>磁盘限额层</strong>、<strong>文件系统源信息块高速缓存</strong>和<strong>XFS日志文件系统</strong>。</p>
<p>从可压缩磁盘高速缓存回收页的PFRA函数叫做<code>shrink_slab()</code>。它由<code>try_to_free_pages()</code>和<code>balance_pgdat()</code>调用。</p>
<p>对于从可压缩磁盘高速缓存回收的代价与从LRU链表回收的代价之间，<code>shrink_slab()</code>试图作出一种权衡。实际上，函数扫描<code>shrinker</code>描述符的链表，调用这些<code>shrinker</code>函数并得到磁盘高速缓存中总的可回收页数。然后，函数再一次扫描<code>shrinker</code>描述符的链表，对于每个可压缩磁盘高速缓存，函数推算出待回收页框数。推算考虑的因素：磁盘高速缓存中总的可回收页数、在磁盘高速缓存中重建一页的相关代价、LRU链表中的页数。然后再调用<code>shrinker</code>函数尝试回收一组页（至少128页）。</p>
<h4 id="从目录项高速缓存回收页框"><a href="#从目录项高速缓存回收页框" class="headerlink" title="从目录项高速缓存回收页框"></a>从目录项高速缓存回收页框</h4><p><code>shrink_dcache_memory()</code>是目录项高速缓存的<code>shrinker</code>函数。它<strong>搜索高速缓存中的未用目录项对象，即没有被任何进程引用的目录项对象，然后将它们释放</strong>。</p>
<p>由于目录项高速缓存对象是通过slab分配器分配的，因此<code>shrink__dcache_memory()</code>可能导致一些slab变成空闲的，这样有些页框就可以被<code>cache_reap()</code>回收。此外，目录项高速缓存索引节点起高速缓存控制器的作用，因此，当一个目录项对象被释放时，存放相应索引节点对象的页就可以变为未用，而最终被释放。</p>
<p><code>shrink_dcache_memory()</code>接收两个参数：待回收页框数和<code>GFP</code>掩码。一开始，它检查<code>GFP</code>掩码中的<code>__GFP_FS</code>标志是否清0，如果是则返回-1，因为释放目录项可能触发基于磁盘文件系统的操作。通过调用<code>prune_dcache()</code>，就可以有效地进行页框回收。该函数扫描未用目录项链表，一直获得请求数量的释放对象或整个链表扫描完毕。对每个最近未被引用的对象，函数执行如下步骤：</p>
<ol>
<li>把目录项对象从目录项散列表、从其父目录中的目录项对象链表、从拥有者索引节点的目录项对象链表中删除。</li>
<li>调用<code>d_iput</code>目录项方法或者<code>iput()</code>函数减少目录项的索引节点的引用计数器。</li>
<li>调用目录项对象的<code>d_release</code>方法。</li>
<li>调用<code>call_rcu()</code>函数以注册一个会删除目录项对象的回调函数，该回调函数又调用<code>kmem_cache_free()</code>把对象释放给slab分配器。</li>
<li>减少父目录的引用计数器。</li>
</ol>
<p>最后，依据仍然留在目录项高速缓存中的未用目录项数，<code>shrink_dcache_memory()</code>返回一个值：<strong>未用目录项数乘以100除以<code>sysctl_vfs_cache_pressure</code>全局变量的值</strong>。该变量的系统默认值是100，因此返回值实际就是未用目录项数。但通过修改文件<code>/proc/sys/vm/vfs_cache_pressure</code>或通过有关的<code>sysctl()</code>系统调用，系统管理员可以改变该值。把值改为小于100，则使<code>shrink_slab()</code>从目录项高速缓存回收的页少于从 LRU 链表中回收的页。反之，如果把值改为大于100，则使<code>shrink_slab()</code>从目录项高速缓存回收的页多于从 LRU 链表中回收的页。</p>
<h4 id="从索引节点高速缓存回收页框"><a href="#从索引节点高速缓存回收页框" class="headerlink" title="从索引节点高速缓存回收页框"></a>从索引节点高速缓存回收页框</h4><p><code>shrink_icache_memory()</code>被调用从索引节点高速缓存中删除未用索引节点对象。“未用”是指<strong>索引节点不再有一个控制目录对象</strong>。该函数非常类似于<code>shrink_dcache_memory()</code>。它检查<code>gfp_mask</code>参数的<code>__GFP_FS</code>位，然后调用<code>prune_icache()</code>，依据仍然留在索引节点高速缓存中的未用索引节点数和<code>sysctl_vfs_cache_pressure</code>变量的值，返回一个值。</p>
<p><code>prune_icache()</code>又扫描<code>inode_unsed</code>链表。要释放一个索引节点，函数必须释放与该索引节点管理的任何私有缓冲区，它使页高速缓存内的不再使用的干净页框无效，然后通过调用<code>clear_inode()</code>和<code>destroy_inode()</code>删除索引节点对象。</p>
<h4 id="周期回收"><a href="#周期回收" class="headerlink" title="周期回收"></a>周期回收</h4><p>PFRA用两种机制进行周期回收：<code>kswapd</code>内核线程和<code>cache_reap</code>函数。前者调用<code>shrink_zone()</code>和<code>shrink_slab()</code>从LRU链表中回收页；<br>后者则被周期性地调用以便从slab分配器中回收未用的slab。</p>
<h4 id="kswapd-内核线程"><a href="#kswapd-内核线程" class="headerlink" title="kswapd 内核线程"></a>kswapd 内核线程</h4><p><code>kswapd</code>内核线程是激活内存回收的另外一种机制。<code>kswapd</code><strong>利用机器空闲的时间保持内存空闲页</strong>也对系统性能有良好的影响，进程因此能很快获得自己的页。</p>
<p>每个内存节点对应各自的<code>kswapd</code>内核线程。每个这样的线程通常睡眠在等待队列中，该等待队列以节点描述符的<code>kswapd_wait</code>字段为头部。但是，如果<code>__alloc_pages()</code>发现所有适合内存分配的内存管理区包含的空闲页框数低于“警告”阈值时，那么相应内存节点的<code>kswapd</code>内核线程被激活。从本质上，为了避免更多紧张的“内存紧缺”的情形，内核才开始回收页框。</p>
<p>每个管理区描述符还包括字段<code>pages_min</code>和<code>pages_high</code>。前者表示必须保留的最小空闲页框数阈值；后者表示“安全”空闲页框数阈值，即空闲页框数大于该阈值时，应该停止页框回收。</p>
<p><code>kswapd</code>内核线程执行<code>kswapd()</code>。内核线程被初始化的内容是：</p>
<ul>
<li>把线程绑定到访问内存节点的CPU。</li>
<li>把<code>reclaim_state</code>描述符地址存入进程描述符的<code>current-&gt;reclaim_state</code>字段。</li>
<li>把<code>current-&gt;flags</code>字段的<code>PF_MEMALLOC</code>和<code>PF_KSWAP</code>标志置位，其含义是进程将回收内存，运行时允许使用全部可用空闲内存。</li>
</ul>
<p><code>kswapd()</code>执行下列操作：</p>
<ol>
<li>调用<code>finish_wait()</code>从节点的<code>kswad_wait</code>等待队列删除内核线程。</li>
<li>调用<code>balance_pgdat()</code>对<code>kswapd</code>的内存节点进行内存回收。</li>
<li>调用<code>prepare_to_wait()</code>把进程设成<code>TASK_INTERRUPTIBLE</code>状态，并让它在节点的<code>kswapd_wait</code>等待队列中睡眠。</li>
<li>调用<code>schedule()</code>让CPU处理一些其他可运行进程。</li>
</ol>
<p><code>balance_pgdat()</code>执行下面步骤：</p>
<ol>
<li>建立<code>scan_control</code>描述符。</li>
<li>把内存节点的每个管理区描述符中的<code>temp_priority</code>字段设为12（最低优先级）。</li>
<li>执行一个循环，从12到0最多13次迭代，每次迭代执行下列步骤：<ol>
<li>扫描内存管理区，寻找空闲页框数不足的最高管理区（从<code>ZONE_DMA</code>到<code>ZONE_HIGHMEM</code>）。由<code>zone_watermark_ok()</code>进行每次的检测。如果所有管理区都有大量空闲页框，则跳到第4步。</li>
<li>对一部分管理区再一次进行扫描，范围是从<code>ZONE_DMA</code>到第3.1步找到的管理区。对每个管理区，必要时用当前优先级更新管理区描述符的<code>prev_priority</code>字段，且连续调用<code>shrink_zone()</code>以回收管理区中的页。然后，调用<code>shrink_slab()</code>从可压缩磁盘高速缓存回收页。</li>
<li>如果已有至少32页被回收，则跳出循环至第4步</li>
</ol>
</li>
<li>用各自<code>temp_priority</code>字段的值更新每个管理区描述符的<code>prev_priority</code>字段。</li>
<li>如果仍有“内存紧缺”管理区存在，且如果进程的<code>need_resched</code>字段置位，则调用<code>schedule()</code>。当再一次执行时，跳到第1步。</li>
<li>返回回收的页数。</li>
</ol>
<h4 id="cache-reap"><a href="#cache-reap" class="headerlink" title="cache_reap()"></a>cache_reap()</h4><p>PFRA使用<code>cache_reap()</code>回收slab分配器高速缓存的页。<code>cache_reap()</code>周期性（大约每两秒一次）地在预定事件工作队列中被调度。它的地址存放在每CPU变量<code>reap_work</code>的<code>func</code>字段，该变量为<code>work_struct</code>类型。</p>
<p>`cache_reap() 执行下列步骤：</p>
<ol>
<li>尝试获得<code>cache_chain_sem</code>信号量，该信号量保护slab高速缓存描述符链表。如果信号量已取得，就调用<code>schedule_delayed_work()</code>去调度该函数的下一次执行，然后结束。</li>
<li>否则，扫描存放在<code>cache_chain</code>链表中的<code>kmem_cache_t</code>描述符。对找到的每个高速缓存描述符，执行下列步骤：<ol>
<li>如果高速缓存描述符的<code>SLAB_NO_REAP</code>标志置位，则页框回收被禁止，因此处理链表中的下一个高速缓存。</li>
<li>清空局部slab高速缓存，则会有新的slab被释放。</li>
<li>每个高速缓存都有“收割时间”，该值存放在高速缓存描述符中<code>kmem_list3</code>结构的<code>next_reap</code>字段。如果<code>jiffies</code>值仍然小于<code>next_reap</code>，则继续处理链表中的下一个高速缓存。</li>
<li>把存放在<code>next_reap</code>字段的下一次“收割时间”设为：从现在起的4s。</li>
<li>在多处理器系统中，函数清空slab共享高速缓存，那么会有新的slab被释放。</li>
<li>如果有新的slab最近被加入高速缓存，即高速缓存描述符中<code>kmem_list3</code>结构的<code>free_touched</code>标志置位，则跳过该高速缓存，继续处理链表中的下一个高速缓存。</li>
<li>根据经验公式计算要释放的slab数量。基本上，该数取决于高速缓存中空闲对象数的上限和能装入单个slab的对象数。</li>
<li>对高速缓存空闲slab链表中的每个slab，重复调用<code>slab_destroy()</code>，直到链表为空或者已回收目标数量的空闲slab。</li>
<li>调用<code>cond_resched()</code>检查当前进程的<code>TIF_NEED_RESCHED</code>标志，如果该标志置位，则调用<code>schedule()</code>。</li>
</ol>
</li>
<li>释放<code>cache_chain_sem</code>信号量。</li>
<li>调用<code>schedule_delayed_work()</code>去调度该函数的下一次执行，然后结束。</li>
</ol>
<h4 id="内存不足删除程序"><a href="#内存不足删除程序" class="headerlink" title="内存不足删除程序"></a>内存不足删除程序</h4><p>当所有可用内存耗尽，PFRA使用所谓的<strong>内存不足删除程序</strong>，该程序选择系统中的一个进程，强行删除它并释放页框。当空闲内存十分紧缺且PFRA又无法成功回收任何页时，<code>__alloc_pages()</code>调用<code>out_of_memory()</code>。<code>out_of_memory()</code>调用<code>select_bad_process()</code>在现有进程中选择一个“牺牲品”，然后调用<code>oom_kill_process()</code>删除该进程。</p>
<p><code>select_bad_process()</code>挑选满足下列条件的进程：</p>
<ul>
<li>它必须拥有大量页框，从而可以释放出大量内存。</li>
<li>删除它只损失少量工作结果（删除一个工作了几个小时或几天的批处理进程就不是个好主意）。</li>
<li>它应具有较低的静态优先级，用户通常给不太重要的进程赋予较低的优先级。</li>
<li>它不应是有root特权的进程，特权进程的工作通常比较重要。</li>
<li>它不应直接访问硬件设备，因为硬件不能处在一个无法预知的状态。</li>
<li>它不能是<code>swapper</code>（进程0）、<code>init</code>（进程1）和任何其它内核线程。</li>
</ul>
<p><code>select_bad_process()</code>扫描系统中的每个进程，根据以上准则用经验公式计算一个值，该值表示选择该进程的有利程度，然后返回最有利的被选进程描述符的地址。<code>out_of_memory()</code>再调用<code>oom_kill_process()</code>并发出死亡信号（通常是<code>SIGKILL</code>），该信号发给该进程的一个子进程，或如果做不到，就发给进程进程本身。<code>oom_kill_process()</code>同时也删除与被选进程共享内存描述符的所有克隆进程。</p>
<h3 id="交换标记"><a href="#交换标记" class="headerlink" title="交换标记"></a>交换标记</h3><p>交换失效：内存不足时PFRA全力把页写入磁盘以释放内存并从一些进程窃取相应的页框，而同时这些进程要继续执行也全力访问它们的页。结果就是页无休止地写入磁盘再读出来。</p>
<p>为减少交换失效的发生，Jiang和Zhang将<strong>交换标记赋给系统中的单个进程，该标记可避免该进程的页框被回收，所以进程可继续运行，而且即使内存十分稀少，也有希望运行至结束</strong>。</p>
<p>交换标记的具体形式是<code>swap_token_mm</code>内存描述符指针。当进程拥有交换标记时，<code>swap_token_mm</code>被设为进程内存描述符的地址。</p>
<p>页框回收算法的免除以该简洁的方式实现了。在“最近最少使用（LRU）链表”中可知，只有一页最近没有被引用时，才可从活动链表移入非活动链表。<code>page_referenced()</code>进行这一检查。如果该页属于一个线性区，该区域所在进程拥有交换标记，则认可该交换标记并返回1（被引用）。实际上，交换标记在几种情形下不予考虑：</p>
<ul>
<li>PFRA代表一个拥有交换标记的进程在运行。</li>
<li>PFRA达到页框回收的最难优先级（0级）。</li>
</ul>
<p><code>grab_swap_token()</code>决定是否将交换标记赋给当前进程。在以下两种情形下，对每个<strong>主缺页</strong>调用该函数：</p>
<ul>
<li>当<code>filemap_nopage()</code>发现请求页不在页高速缓存中时。</li>
<li>当<code>do_swap_page()</code>从交换区读入一个新页时。</li>
</ul>
<p><code>grap_swap_token()</code>在分配交换标记前要进行一些检查，满足以下条件时才分配：</p>
<ul>
<li>上次调用<code>grab_swap_token()</code>后，至少已过了2s。</li>
<li>在上次调用<code>grab_swap_token()</code>后，当前拥有交换标记的进程没再提出主缺页，或该进程拥有交换标记的时间超出<code>swap_token_default_timeout</code>个节拍。</li>
<li>当进程最近没有获得过交换标记。</li>
</ul>
<p>交换标记的持有时间最好长一些，甚至以分钟为单位，因为其目标就是允许进程完成其执行。在Linux 2.6中，交换标记的持有时间默认值很小，即一个节拍。但通过编辑<code>/proc/sys/vm/swap_token_defaut_timeout</code>文件或发出相应的<code>sysctl()</code>系统调用，系统管理员可修改<code>swap_token_default_timeout</code>变量的值。</p>
<p>当删除一个进程时，内核调用<code>mmput()</code>检查该进程是否拥有交换标记，如果是则放开它。</p>
<h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><p>交换用来<strong>为非映射页在磁盘上提供备份</strong>。有三类页必须由交换子系统处理：</p>
<ul>
<li>属于进程匿名线性区（例如，用户态堆栈和堆）的页。</li>
<li>属于进程私有内存映射的脏页。</li>
<li>属于 IPC 共享内存区的页。</li>
</ul>
<p>交换对于程序是透明的，不需要在代码中嵌入与交换有关的特别指令。Linux利用页表项中的其他位存放<strong>换出页标识符</strong>。该标识符用于编码换出页在磁盘上的位置。</p>
<p>交换子系统的主要功能总结如下：</p>
<ul>
<li>在磁盘上建立交换区，用于存放没有磁盘映像的页。</li>
<li>管理交换区空间。当需求发生时，分配与释放页槽。</li>
<li>提供函数用于从RAM中把页换出到交换区或从交换区换入到RAM中。</li>
<li>利用页表项（现已被换出的换出页页表项）中的换出页标识符跟踪数据在交换区中的位置。</li>
</ul>
<p>交换是页框回收的一个最高级特性。如果需要确保进程的所有页框都能被PFRA随意回收，而不仅仅是回收有磁盘映像的页，就必须使用交换。可以用<code>swapoff</code>命令关闭交换，但随着磁盘系统负载增加，很快磁盘系统就会瘫痪。</p>
<p><strong>交换可以用来扩展内存地址空间</strong>，使之被用户态进程有效地使用，但性能比RAM慢几个数量级。</p>
<h3 id="交换区"><a href="#交换区" class="headerlink" title="交换区"></a>交换区</h3><p>从内存中换出的页存放在<strong>交换区</strong>中，交换区的实现可以使用自己的磁盘分区，也可以使用包含在大型分区中的文件。可定义几种不同的交换区，最大个数由<code>MAX_SWAPFILES</code>宏确定。</p>
<p>如果有多个交换区，就允许系统管理员把大的交换空间分布在几个磁盘上，以使硬件可以并发操作这些交换区；这一处理还允许在系统运行时不用重新启动系统就可以扩大交换空间的大小。</p>
<p>每个交换区都由一组<strong>页槽</strong>组成，即一组4096字节大小的块组成，每块中包含一个换出的页。交换区的第一个页槽用来永久存放有关交换区的信息，其格式由<code>swap_header</code>联合体描述。<code>magic</code>结构提供了一个字符串，用来把磁盘某部分明确地标记为交换区，它只含有一个字段<code>magic.magic</code>，该字段含有一个10字符的<strong>magic</strong>字符串。<code>maginc</code>结构从根本上允许内核明确地把一个文件或分区标记成交换区，该字符串的内容就是<strong>SWAPSPACE2</strong>，通常位于<strong>第一个页槽的末尾</strong>。</p>
<p><code>info</code>结构包含以下字段：</p>
<ul>
<li><code>bootbits</code>：交换算法不使用该字段，该字段对应交换区的第一个1024字节，可存放分区数据、磁盘标签等。</li>
<li><code>version</code>：交换算法的版本</li>
<li><code>last_page</code>：可有效使用的最后一个页槽</li>
<li><code>nr_badpages</code>：有缺陷页的页槽的个数</li>
<li><code>padding[125]</code>：填充字节</li>
<li><code>badpages[1]</code>：一共637个数字，用来指定有缺陷页槽的位置</li>
</ul>
<h4 id="创建与激活交换区"><a href="#创建与激活交换区" class="headerlink" title="创建与激活交换区"></a>创建与激活交换区</h4><p>交换区包含很少的控制信息，包括交换区类型和有缺陷页槽的链表，存放在一个单独的4KB页中。</p>
<p>通常，系统管理员在创建Linux系统中的其它分区时都创建一个交换区，然后使用<code>mkswap</code>命令把这个磁盘区设置成一个新的交换区。该命令对刚才介绍的第一个页槽中的字段进行初始化。由于磁盘中可能会有一些坏块，该程序还可以对其它所有的页槽进行检查从而确定有缺陷页槽的位置。但是执行<code>mkswap</code>命令会把交换区设置成非激活的状态。每个交换区都可以在系统启动时在脚本文件中被激活，也可以在系统运行之后动态激活。</p>
<p>每个交换区由一个或多个交换子区组成，每个交换子区由一个<code>swap_extent</code>描述符表示，每个子区对应一组页，它们在磁盘上是物理相邻的。<code>swap_extent</code>描述符由几部分组成：<strong>交换区的子区首页索引</strong>、<strong>子区的页数</strong>和<strong>子区的起始磁盘扇区号</strong>。当激活交换区自身的同时，组成交换区的有序子区链表也被创建。存放在磁盘分区中的交换区只有一个子区；但是，存放在普通文件中的交换区可能有多个子区，这是因为文件系统有可能没把该文件全部分配在磁盘的一组连续块中。</p>
<h4 id="如何在交换区中分布页"><a href="#如何在交换区中分布页" class="headerlink" title="如何在交换区中分布页"></a>如何在交换区中分布页</h4><p>内核尽力把换出的页放在相邻的页槽中，从而减少在访问交换区时磁盘的寻道时间。如果系统使用了多个交换区，快速交换区（也就是存放在快速磁盘中的交换区）可以获得比较高的优先级。当查找一个空闲页槽时，要从优先级最高的交换区中开始搜索。</p>
<h3 id="交换区描述符"><a href="#交换区描述符" class="headerlink" title="交换区描述符"></a>交换区描述符</h3><p>每个活动的交换区在内存中都有自己的<code>swap_info_struct</code>描述符。<br><img src="/img/1604396537.png" alt=""></p>
<p><code>flags</code>字段包含三个重叠的子字段：</p>
<ul>
<li><code>SWP_USED</code>：如果交换区是活动的，就是1，否则就是0</li>
<li><code>SWP_WRITEOK</code>：如果交换区是可写的，就是1，否则就是0</li>
<li><code>SWP_ACTIVE</code>：如果前边两个字段置位，那么<code>SWP_ACTIVE</code>置位</li>
</ul>
<p><code>swap_map</code>字段指向一个计数器数组，交换区的每个页槽对应一个元素。如果计数器值等于0，则该页槽就是空闲的；如果计数器为正数，那么换出页就填充了这个页槽。实际上，<strong>页槽计数器的值就表示共享换出页的进程数</strong>。如果计数器的值为<code>SWAP_MAP_MAX</code>（32767），那么存放在该页槽中的页就是“永久”的，并且不能从相应的页槽中删除。如果计数器的值是<code>SWAP_MAP_BAD</code>（32768），那么就认为该页槽是有缺陷的，不可用。</p>
<p><code>prio</code>字段是一个有符号的整数，表示交换子系统依据该值考虑每个交换区的次序。</p>
<p><code>sdev_lock</code>字段是一个自旋锁，它防止SMP系统上对交换区数据结构的并发访问。<code>swap_info</code>数组包括<code>MAX_SWAPFILES</code>个交换区描述符。只有那些设置了<code>SWP_USED</code>标志的交换区才被使用，因为它们是活动区域。图说明了<code>swap_info</code>数组、一个交换区和相应的计数器数组的情况。<br><img src="/img/1604745493.jpg" alt=""></p>
<p><code>nr_swapfiles</code>变量存放数组中包含或已包含所使用交换区描述符的最后一个元素的索引。这个变量有些名不符实，它并没有包含活动交换区的个数。</p>
<p><strong>活动交换区描述符也被插入按交换区优先级排序的链表中</strong>。该链表是通过交换区描述符的<code>next</code>字段实现的，<code>next</code>字段存放的是<code>swap_info</code>数组中下一个描述符的索引。</p>
<p><code>swap_list_t</code>类型的<code>swap_list</code>变量包括以下字段：</p>
<ul>
<li><code>head</code>，第一个链表元素在<code>swap_info</code>数组中的下标。</li>
<li><code>next</code>，为换出页所选中的下一个交换区的描述符在<code>swap_info</code>数组中的下标。该字段用于在具有空闲页槽的最大优先级的交换区之间实现轮询算法。</li>
</ul>
<p>交换区描述符的<code>max</code>字段存放以页为单位交换区的大小，而<code>pages</code>字段存放可用页槽的数目。这两个数字之所以不同是因为<code>pages</code>字段并没有考虑第一个页槽和有缺陷的页槽。</p>
<p>最后，<code>nr_swap_pages</code>变量包含所有活动交换区中可用的（空闲并且无缺陷）页槽数目，而<code>total_swap_pages</code>变量包含无缺陷页槽的总数。</p>
<h3 id="换出页标识符"><a href="#换出页标识符" class="headerlink" title="换出页标识符"></a>换出页标识符</h3><p>通过在<code>swap_info</code>数组中指定交换区的索引和在交换区内指定页槽的索引，可简单而又唯一地标识一个换出页。由于交换区的第一个页（索引为0）留给<code>swap_header</code>联合体，第一个可用页槽的索引就为1。<br><img src="/img/1604746260.jpg" alt=""></p>
<p><code>swp_entry(type, offset)</code>宏负责从交换区索引<code>type</code>和页槽索引<code>offset</code>中构造出页标识符。<code>swp_type</code>和<code>swp_offset</code>宏正好相反，它们分别从换出页标识符中提取出交换区区索引和页索引。</p>
<p>当页被换出时，其标识符就作为页的表项插入页表中，这样在需要时就可以在找到该页。要注意这种标识符的最低位与<code>Present</code>标志对应，通常被清除来说明该页目前不在RAM中。但是，剩余31位中至少一位被置位，因为没有页存放在交换区0的页槽0中。这样就可以从一个页表项中区分三种不同的情况：</p>
<ul>
<li>空项，该页不属于进程的地址空间，或相应的页框还没有分配给进程（请求调页）。</li>
<li>前31个最高位不全等于0，最后一位等于0，该页被换出。</li>
<li>最低位等于1，该页包含在RAM中。</li>
</ul>
<p>注意，交换区的最大值由表示页槽的可用位数决定。在80x86体系结构结构上，有24位可用，这就限制了交换区的大小为2^{24}个页槽。</p>
<p>由于一页可以属于几个进程的地址空间，所以它可能从一个进程的地址空间被换出，但仍旧保留在主存中；因此<strong>可能把同一个页换出多次</strong>。当然，一个页在物理上只被换出并存储一次，但后来每次试图换出该页都会增加<code>swap_map</code>计数器的值。</p>
<p>在试图换出一个已经换出的页时就会调用<code>swap_duplicate()</code>。该函数只是验证以参数传递的换出页标识符是否有效，并增加相应的<code>swap_map</code>计数器的值。执行下列操作：</p>
<ol>
<li>使用<code>swp_type</code>和<code>swp_offset</code>宏从参数中提取出交换区号<code>type</code>和页槽索引<code>offset</code>。</li>
<li>检查交换区是否被激活；如果不是，则返回0（无效的标识符）。</li>
<li>检查页槽是否有效且是否不为空闲（<code>swap_map</code>计数器大于0且小于<code>SWAP_MAP_BAD</code>）；如果不是，则返回0（无效的标识符）。</li>
<li>否则，换出页的标识符确定出一个有效页的位置。如果页槽的<code>swap_map</code>计数器还没有达到<code>SWAP_MAP_MAX</code>，则增加它的值。</li>
<li>返回1（有效的标识符）。</li>
</ol>
<h3 id="激活和禁用交换区"><a href="#激活和禁用交换区" class="headerlink" title="激活和禁用交换区"></a>激活和禁用交换区</h3><p>一旦交换区被初始化，超级用户（任何具有<code>CAP_SYS_ADMIN</code>权能的用户）就可以分别使用<code>swapon</code>和<code>swapoff</code>程序激活和禁用交换区。这两个程序分别使用了<code>swapon()</code>和<code>swapoff()</code>系统调用。</p>
<h4 id="sys-swapon-服务例程"><a href="#sys-swapon-服务例程" class="headerlink" title="sys_swapon()服务例程"></a>sys_swapon()服务例程</h4><p><code>sys_swapon()</code>服务例程参数：</p>
<ul>
<li><code>specialfile</code>，指向设备文件（或分区）的路径名（在用户态地址空间），或指向实现交换区的普通文件的路径名。</li>
<li><code>swap_flags</code>，由一个单独的<code>SWAP_FLAG_PREFER</code>位加上交换区优先级的31位组成（只有在<code>SWAP_FLAG_PREFER</code>位置位时，优先级位才有意义）。</li>
</ul>
<p><code>sys_swapon()</code>对创建交换区时放入第一个页槽中的<code>swap_header</code>联合体字段进行检查，执行下列步骤：</p>
<ol>
<li>检查当前进程是否具有<code>CAP_SYS_ADMIN</code>权能。</li>
<li>在交换区描述符<code>swap_info</code>数组的前<code>nr_swapfiles</code>个元素中查找<code>SWP_USED</code>标志为0（即对应的交换区不是活动的）的第一个描述符。如果找到一个不活动交换区，则跳到第4步。</li>
<li>新交换区数组索引等于<code>nr_swapfiles</code>：它检查保留给交换区索引的位数是否足够用于编码新索引。如果不够，则返回错误代码；如果足够，就将<code>nr_swapfiles</code>的值增加1。</li>
<li>找到未用交换区索引：它初始化这个描述符的字段，即把<code>flags</code>置为<code>SWP_USED</code>，把<code>lowest_bit</code>和<code>highest_bit</code>置为0。</li>
<li>如果<code>swap_flags</code>参数为新交换区指定了优先级，则设置描述符的<code>prio</code>字段。否则，就把所有活动交换区中最低位的优先级减1后赋给这个字段（这样就假设最后一个被激活的交换区在最慢的块设备上）。如果没有其它交换区是活动的，就把该字段设置为-1。</li>
<li>从用户态地址空间复制由<code>specialfile</code>参数所指向的字符串。</li>
<li>调用<code>filp_open()</code>打开由<code>specialfile</code>参数指定的文件。</li>
<li>把<code>filp_open()</code>返回的文件对象地址存放在交换区描述符的<code>swap_file</code>字段。</li>
<li>检查<code>swap_info</code>中其它的活动交换区，以确认该交换区还未被激活。具体为，检查交换区描述符的<code>swap_file-&gt;f_mapping</code>字段中存放的<code>address_space</code>对象地址。如果交换区已被激活，则返回错误码。</li>
<li>如果<code>specialfile</code>参数标识一个块设备文件，则执行下列子步骤：<ol>
<li>调用<code>bd_claim()</code>把交换子系统设置为块设备的占有者。如果块设备已有一个占有者，则返回错误码。</li>
<li>把<code>block_device</code>描述符地址存入交换区描述符的<code>bdev</code>字段。</li>
<li>把设备的当前块大小存放在交换区描述符的<code>old_block_size</code>字段，然后把设备的块大小设成4096字节（即页的大小）。</li>
</ol>
</li>
<li>如果<code>specialfile</code>参数标识一个普通文件，则执行下列子步骤：<ol>
<li>检查文件索引节点<code>i_flags</code>字段中的<code>S_SWAPFILE</code>字段。如果该标志置位，说明文件已被用作交换区，返回错误码。</li>
<li>把该文件所在块设备的描述符地址存入交换区描述符的<code>bdev</code>字段。</li>
</ol>
</li>
<li>调用<code>read_cache_page()</code>读入存放在交换区页槽0的<code>swap_header</code>描述符。参数为：<code>swap_file-&gt;f_mapping</code>指向的<code>address_space</code>对象、页索引0、文件<code>readpage</code>方法的地址（存放在<code>swap_file-&gt;f_mapping-&gt;a_ops-&gt;readpage</code>）和指向文件对象<code>swap_file</code>的指针。然后等待直到页被读入内存。</li>
<li>检查交换区中第一页的最后10个字符中的魔术字符串是否等于<strong>SWAPSPACE2</strong>。如果不是，返回一个错误码。</li>
<li>根据存放在<code>swap_header</code>联合体的<code>info.last_page</code>字段中的交换区大小，初始化交换区描述符的<code>lowest_bit</code>和<code>hightest_bit</code>字段。</li>
<li>调用<code>vmalloc()</code>创建与新交换区相关的计数器数组，并把它的地址存放在交换区描述符的<code>swap_map</code>字段中。还要根据<code>swap_header</code>联合体的<code>info.bad_pages</code>字段中存放的有缺陷的页槽链表把该数组的元素初始化为0或<code>SWAP_MAP_BAD</code>。</li>
<li>通过访问第一个页槽中的<code>info.last_page</code>和<code>info.nr_badpages</code>字段计算可用页槽的个数，并把它存入交换区描述符的<code>pages</code>字段。而且把交换区中的总页数赋给<code>max</code>字段。</li>
<li>为新交换区建立子区链表<code>extent_list</code>（如果交换区建立在磁盘分区上，则只有一个子区），并相应地设定交换区描述符的<code>nr_extents</code>和<code>curr_swap_extent</code>字段。</li>
<li>把交换区描述符的<code>flags</code>字段设为<code>SWP_ACTIVE</code>。</li>
<li>更新<code>nr_good_pages、nr_swap_pages</code>和<code>total_swap_pages</code>三个全局变量。</li>
<li>把新交换区描述符插入<code>swap_list</code>变量所指向的链表中。</li>
<li>返回0（成功）。</li>
</ol>
<h4 id="sys-swapoff-服务例程"><a href="#sys-swapoff-服务例程" class="headerlink" title="sys_swapoff()服务例程"></a>sys_swapoff()服务例程</h4><p><code>sys_swapoff()</code>服务例程使<code>specialfile</code>参数所指定的交换区无效。<code>sys_swapoff()</code>比<code>sys_swapon()</code>复杂，因为<strong>使之无效的这个分区可能仍然还包含几个进程的页</strong>。因此，<strong>强制该函数扫描交换区并把所有现有的页都换入</strong>。由于每个换入操作都需要一个新的页框，因此如果现在没有空闲页框，该操作就可能失败，函数返回一个错误码。</p>
<p><code>sys_swapoff()</code>执行下列步骤。</p>
<ol>
<li>验证当前进程是否具有<code>CAP_SYS_ADMIN</code>权能。</li>
<li>拷贝内核空间中<code>specialfile</code>所指向的字符串。</li>
<li>调用<code>filp_open()</code>打开<code>specialfile</code>参数确定的文件，返回文件对象的地址。</li>
<li>扫描交换区描述符链表<code>swap_list</code>，比较由<code>filp_open()</code>返回的文件对象地址与活动交换区描述符的<code>swap_file</code>字段中的地址，如果不一致，说明传给函数的是一个无效参数，返回一个错误码。</li>
<li>调用<code>cap_vm_enough_memory()</code>检查是否由足够的空闲页框把交换区上存放的所有页换入。如果不够，交换区就不能禁用，然后释放文件对象，返回错误码。当执行该项检查时，<code>cap_vm_enough_memory()</code>要考虑由slab高速缓存分配且<code>SLAB_RECLAIM_ACCOUNT</code>标志置位的页框，这样的页（可回收的页）的数量存放在<code>slab_reclaim_pages</code>变量中。</li>
<li>从<code>swap_list</code>链表中删除该交换区描述符。</li>
<li>从<code>nr_swap_pages</code>和<code>total_swap_pages</code>的值中减去存放在交换区描述符的<code>pages</code>字段的值。</li>
<li>把交换区描述符<code>flags</code>字段中的<code>SWAP_WRITEOK</code>标志清0。这可禁止PFRA向交换区换出更多的页。</li>
<li>调用<code>try_to_unuse()</code>强制把该交换区中剩余的所有页都移到RAM中，并相应地修改使用这些页的进程的页表。当执行该函数时，当前进程的<code>PF_SWAPOFF</code>标志置位。该标志置位只有一个结果：如果页框严重不足，<code>select_bad_process()</code>就会强制选中并删除该进程。</li>
<li>一直等待交换区所在的块设备驱动器被卸载。这样在交换区被禁用之前，<code>try_to_unuse()</code>发出的读请求会被驱动器处理。</li>
<li>如果在分配所有请求的页框时<code>try_to_unuse()</code>失败，那么就不能禁用该交换区。因此，<code>sys_swapoff()</code>执行下列步骤：<ol>
<li>把该交换区描述符重新插入<code>swap_listl</code>链表，并把它的<code>flags</code>字段设置为<code>SWP_WRITEOK</code>。</li>
<li>把交换区描述符中<code>pages</code>字段的值加到<code>nr_swap_pages</code>和<code>total_swap_pages</code>变量以恢复其原址。</li>
<li>调用<code>filp_close()</code>关闭在第3步中打开的文件，并返回错误码。</li>
</ol>
</li>
<li>否则，所有已用的页槽都已经被成功传送到RAM中。因此，执行下列步骤：<ol>
<li>释放存有<code>swap_map</code>数组和子区描述符的内存区域。</li>
<li>如果交换区存放在磁盘分区，则把块大小恢复到原值，该原值存放在交换区描述符的<code>old_block_size</code>字段。而且，调用<code>bd_release()</code>使交换子系统不再占有该块设备。</li>
<li>如果交换区存放再普通文件中，则把文件索引节点的<code>S_SWAPFILE</code>标志清0。</li>
<li>调用<code>filp_close()</code>两次，第一次针对<code>swap_file</code>文件对象，第二次针对第3步中<code>filep_open()</code>返回的对象。</li>
<li>返回0（成功）。</li>
</ol>
</li>
</ol>
<h4 id="try-to-unuse"><a href="#try-to-unuse" class="headerlink" title="try_to_unuse()"></a>try_to_unuse()</h4><p><code>try_to_unuse()</code>使用一个索引参数，该参数标识待清空的交换区。该函数<strong>换入页并更新已换出页的进程的所有页表</strong>。因此，该函数从<code>init_mm</code>内存描述符开始，访问所有内核线程和进程的地址空间。这是一个比较耗时的函数，通常以开中断运行。因此，与其它进程的同步也是关键。</p>
<p><code>try_to_unuse()</code>扫描交换区的<code>swap_map</code>数组。当它找到一个“在用”页槽时，首先换入其中的页，然后开始查找引用该页的进程。这两个操作顺序对避免竞争条件至关重要。当I/O数据传送正在进行时，页被加锁，因此没有进程可以访问它。一旦I/O数据传输完成，页又被<code>try_tu_unuse()</code>加锁，以使它不会被另一个内核控制路径再次换出。因为每个进程在开始换入或换出操作前查找页高速缓存，所以这也可以避免竞争条件。最后，由<code>try_to_unuse()</code>所考虑的交换区被标记为不可写（<code>SWP_WRITEOK</code>标志被清0），因此，没有进程可对该交换区的页槽执行换出。</p>
<p>但是，可能强迫<code>try_to_unuse()</code>对交换区引用计数器的<code>swap_map</code>数组扫描几次。这是因为对换出页引用的线性区可能在一次扫描中消失，而在随后又出现在进程链表中。</p>
<p>因此，<code>try_to_unuse()</code>对引用给定页槽的进程进行查找时可能失败，因为相应的线性区暂时没有包含在进程链表中。为了处理该情况，<code>try_to_unuse()</code>一直对<code>swap_map</code>数组进行扫描，直到所有的引用计数器都变为空。引用了换出页的线性区最终会重新出现在进程链表中，因此，<code>try_to_unuse()</code>中将会成功释放所有页槽。</p>
<p><code>try_to_unuse()</code>的参数为交换区<code>swap_map</code>数组的引用计数器。该函数在引用计数器上执行连续循环，如果当前进程接收到一个信号，则循环中断，函数返回错误码。对于数组中的每个引用计数器，<code>try_to_unuse()</code>执行下列步骤：</p>
<ol>
<li>如果计数器等于0（没有页存放在这里）或等于<code>SWAP_MAP_BAD</code>，则对下一个页槽继续处理。</li>
<li>否则，调用<code>read_swap_cache_async()</code>换入该页。这包括分配一个新页框（如果必要），用存放在页槽中的数据填充新页框并把该页存放在交换高速缓存。</li>
<li>等待，直到用磁盘中的数据适当地更新了该新页，然后锁住它。</li>
<li>当正在执行前一步时，进程有可能被挂起。因此，还要检查该页槽的引用计数器是否变为空，如果是，说明该交换页可能被另一个内核控制路径释放，然后继续处理下一个页槽。</li>
<li>对于以<code>init_mm</code>为头部的双向链表中的每个进程描述符，调用<code>unuse_process()</code>。该耗时的函数扫描拥有内存描述符的进程的所有页表项，并用该新页框的物理地址替换页表中每个出现的换出页标识符。为了反映这种移动，还要把<code>swap_map</code>数组中的页槽计数器减1（触发计数器等于<code>SWAP_MAP_MAX</code>），并增加该页框的引用计数器。</li>
<li>调用<code>shmem_unuse()</code>检查换出的页是否用于IPC共享内存资源，并适当地处理该种情况。</li>
<li>检查页的引用计数器。如果它的值等于<code>SWAP_MAP_MAX</code>，则页槽是<strong>永久的</strong>。为了释放它，则把引用计数器强制置为1。</li>
<li>交换高速缓存可能页拥有该页（它对应计数器的值起作用）。如果页属于交换高速缓存，就调用<code>swap_writepage()</code>把页的内容刷新到磁盘（如果页为脏），调用<code>delete_from_swap_cache()</code>从交换高速缓存删去页，并把页的引用计数减1。</li>
<li>设置页描述符的<code>PG_dirty</code>标志，并打开页框的锁，递减它的引用计数器（取消第5步的增量）。</li>
<li>检查当前进程的<code>need_resched</code>字段；如果它被设置，则调用<code>schedule()</code>放弃CPU。只要该进程再次被调度程序选中，<code>try_to_unuse()</code>就从该步继续执行。</li>
<li>继续到下一个页槽，从第1步开始。</li>
</ol>
<p><code>try_to_unuse()</code>继续执行，直到<code>swap_map</code>数组中的每个引用计数器都为空。即使该函数已经开始检查下一个页槽，但前一个页槽的引用计数器有可能仍然为正。事实上，一个进程可能还在引用该页，典型的原因是某些线性区已经被临时从第5步所扫描的进程链表中删除。<code>try_to_unuse()</code>最终会捕获到每个引用。但是，在此期间，页不再位于交换高速缓存，它的锁被打开，并且页的一个拷贝仍然包含在要禁用的交换区的页槽中。</p>
<p>当禁用交换区时该问题不会发生，因为只有在换出的页属于私有匿名内存映射时，才会受到“幽灵”进程的干扰。在这种情况下，用“写时复制”机制处理页框，所以，把不同的页框分配给引用了该页的进程是完全合法的。但是，<code>try_to_unuse()</code>将页标记为“脏”，否则，<code>shrink_list()</code>可能随后从某个进程的页表中删除该页，而并不把它保存在另一个交换区中。</p>
<h3 id="分配和释放页槽"><a href="#分配和释放页槽" class="headerlink" title="分配和释放页槽"></a>分配和释放页槽</h3><p>搜索空闲页槽的第一种方法可以选择下列两种既简单又有些极端的策略之一：</p>
<ul>
<li><strong>总是从交换区的开头开始</strong>。这种方法在换出操作过程中可能会增加平均寻道时间，因为空闲页槽可能已经被弄得凌乱不堪。</li>
<li><strong>总是从最后一个已分配的页槽开始</strong>。如果交换区的大部分空间都是空闲的（通常如此），那么这种方法在换入操作过程中会增加平均寻道时间，因为所占用的为数不多的页槽可能是零散存放的。</li>
</ul>
<p>Linux采用了一种混合的方法。除非发生以下条件，否则Linux总是从最后一个已分配的页槽开始查找。</p>
<ul>
<li>已经到达交换区的末尾。</li>
<li>上次从交换区的开头重新开始后，已经分配了<code>SWAPFILE_CLUSTER</code>（通常是256）个空闲页槽。</li>
</ul>
<p><code>swap_info_struct</code>描述符的<code>cluster_nr</code>字段存放已分配的空闲页槽数。当函数从交换区的开头重新分配时该字段被重置为0。<code>cluster_next</code>字段存放在下一次分配时要检查的第一个页槽的索引。</p>
<p>为加速对空闲页槽的搜索，内核要保证每个交换区描述符的<code>lowest_bit</code>和<code>hightest_bit</code>字段是最新的。这两个字段定义了第一个和最后一个可能为空的页槽，换言之，所有低于<code>lowest_bit</code>和高于<code>hightest_bit</code>的页槽都被认为已经分配过。</p>
<h4 id="scan-swap-map"><a href="#scan-swap-map" class="headerlink" title="scan_swap_map()"></a>scan_swap_map()</h4><p>在给定的交换区中查找一个空闲页槽并返回其索引。参数指向交换区描述符。如果交换区不含有任何空闲页槽，就返回0。</p>
<p><code>scan_swap_map()</code>：</p>
<ol>
<li>首先试图使用当前的簇。如果交换区描述符的<code>cluster_nr</code>字段是正数，就从<code>cluster_next</code>索引处的元素开始对计数器的<code>swap_map</code>数组进行扫描，查找一个空项。如果找到，就减少<code>cluster_nr</code>字段的值并转到第4步。</li>
<li>执行到该步，或者<code>cluster_nr</code>字段为空，或者从<code>cluster_next</code>开始搜索后没有在<code>swap_map</code>数组中找到空项。现在开始第二阶段的混合查找。把<code>cluster_nr</code>重新初始化成<code>SWAPFILE_CLUSTER</code>，并从<code>lowest_bit</code>索引处开始重新扫描该数组，以便试图找到有<code>SWAPFILE_CLUSTER</code>个空闲槽的一个组。如果找到，转第4步。</li>
<li>不存在<code>SWAPFILE_CLUSTER</code>个空闲页槽的组。从<code>lowest_bit</code>索引处开始重新开始扫描该数组，以便试图找到一个单独的空闲页槽。如果没有找到空项，就把<code>lowest_bit</code>字段设置为数组的最大索引，<code>hightest_bit</code>字段设置为0，并返回0（交换区已满）。</li>
<li>已经找到空项。把1放在空项中，减少<code>nr_swap_pages</code>的值，如果需要就修改<code>lowest_bit</code>和<code>highest_bit</code>字段，把<code>inuse_page</code>字段的值加1，并把<code>cluster_next</code>字段设置成刚才分配的页槽的索引加1。</li>
<li>返回刚才分配的页槽的索引。</li>
</ol>
<h4 id="get-swap-page"><a href="#get-swap-page" class="headerlink" title="get_swap_page()"></a>get_swap_page()</h4><p><strong>通过搜索所有活动的交换区来查找一个空闲页槽</strong>。返回一个新近分配页槽的换出页标识符，如果所有的交换区都填满，就返回0，该函数要考虑活动交换区的不同优先级。</p>
<p>该函数需要经过两遍扫描，在容易发现页槽时可以节约运行时间。第一遍是部分的，只适用于只有相同优先级的交换区。该函数以轮询的方式在这种交换区中查找一个空闲页槽。如果没有找空闲页槽，就从交换区链表的起始位置开始第二遍扫描。在第二遍扫描中，要对所有的交换区都进行检查。</p>
<p><code>get_swap_page()</code>：</p>
<ol>
<li>如果<code>nr_swap_pages</code>为空或者如果没有活动的交换区，就返回0。</li>
<li>首先考虑<code>swap_list.next</code>所指向的交换区（交换区链表是按优先级排序的）。</li>
<li>如果交换区是活动的，就调用<code>scan_swap_map()</code>获得一个空闲页槽。如果<code>scan_swap_map()</code>返回一个页槽索引，该函数的任务基本就完成了，但还要准备下一次被调用。因此，如果下一个交换区的优先级和这个交换区的优先级相同（即轮询使用这些交换区），该函数就把<code>swap_list.next</code>修改成指向交换区链表中的下一个交换区。如果下一个交换区的优先级和当前交换区的优先级不同，该函数就把<code>swap_list.next</code>设置成交换区链表中的第一个交换区（下次搜索时从优先级最高的交换区开始）。该函数最终返回刚才分配的页槽所对应的换出页标识符。</li>
<li>或者交换区是不可写的，或者交换区中没有空闲页槽。如果交换区链表中的下一个交换区的优先级和当前交换区的优先级相同，就把下一个交换区设置成当前交换区并跳到第3步。</li>
<li>此时，交换区链表的下一个交换区的优先级小于前一个交换区的优先级。下一步操作取决于该函数正在进行哪一遍扫描。<ol>
<li>如果只是第一遍（局部）扫描，就考虑链表中的第一个交换区并跳转到第3步，这样就开始第二遍扫描。</li>
<li>否则，就检查交换区链表中是否有下一个元素。如果有，就考虑这个元素并跳到第3步。</li>
</ol>
</li>
<li>此时，第二遍对链表的扫描已经完成，并没有发现空闲页槽，返回0。</li>
</ol>
<h4 id="swap-free"><a href="#swap-free" class="headerlink" title="swap_free()"></a>swap_free()</h4><p>当换入页时，调用<code>swap_free()</code>以对相应的<code>swap_map</code>计数器减1。当相应的计数器达到0时，由于页槽的标识符不再包含在任何页表项中，因此页槽变为空闲。交换高速缓存页也记录页槽拥有者的个数。</p>
<p>该函数只作用于一个参数<code>entry</code>，<code>entry</code>表示换出页标识符。函数执行下列步骤：</p>
<ol>
<li>从<code>entry</code>参数导出交换区索引和页槽索引<code>offset</code>，并获得交换区描述符的地址。</li>
<li>检查交换区是否是活动的。如果不是，就立即返回。</li>
<li>如果正在释放的页槽对应的<code>swap_map</code>计数器小于<code>SWAP_MAP_MAX</code>，就减少该计数器的值。值为<code>SWAP_MAP_MAX</code>的项都被认为是永久的（不可删除的）。</li>
<li>如果<code>swap_map</code>计数器变为0，就增加<code>nr_swap_pages</code>的值，减少<code>inuse_pages</code>字段的值，如果需要就修改该交换区描述符的<code>lowest_bit</code>和<code>hightest_bit</code>字段。</li>
</ol>
<h4 id="交换高速缓存"><a href="#交换高速缓存" class="headerlink" title="交换高速缓存"></a>交换高速缓存</h4><p>向交换区来回传送页会引发很多竞争条件，具体说，交换子系统必须仔细处理如下情形：</p>
<ul>
<li><strong>多重换入</strong>。两个进程可能同时换入同一个共享匿名页。</li>
<li><strong>同时换入换出</strong>。一个进程可能换入正由PFRA换出的页。</li>
</ul>
<p>交换高速缓存的引入就是为了解决这类同步问题。关键的原则是，<strong>没有检查交换高速缓存是否包括了所涉及的页，就不能进行换入或换出操作</strong>。有了交换高速缓存，涉及同一页的并发交换操作总是作用于同一个页框的。因此，内核可以安全地依赖页描述符的<code>PG_locked</code>标志，以避免任何竞争条件。</p>
<p>考虑一下共享同一换出页的两个进程这种情形。当第一个进程试图访问页时，内核开始换入页操作，第一步就是检查页框是否在交换高速缓存中，假定页框不在交换高速缓存中，内核会分配一个新页框并把它插入交换高速缓存，然后开始I/O操作，从交换区读入页的数据；同时，第二个进程访问该匿名页，与上面相同，内核开始换入操作，检查涉及的页框是否在交换高速缓存中。现在页框在交换高速缓存，因此内核只是访问页框描述符，在<code>PG_locked</code>标志清0之前（即I/O数据传输完毕之前），让当前进程睡眠。</p>
<p>当换入换出操作同时出现时，交换高速缓存起着至关重要的作用。<code>shrink_list()</code>要开始换出一个匿名页，就必须当<code>try_to_unmap()</code>从进程（所拥有该页的进程）的用户态页表中成功删除了该页后才可以。但是当换出的写入操作还在执行时，可能有某个进程要访问该页，而产生换入操作。</p>
<p>在写入磁盘前，待换出页由<code>shrink_list()</code>存放在交换高速缓存。考虑页P由两个进程（A和B）共享。最初，两个进程的页表项都引用该页框，该页有2个拥有者，如图a所示。当PFRA选择回收页时，<code>shrink_list()</code>把页框插入交换高速缓存，如图b所示，现在页框有3个拥有者，而交换区中的页槽只被交换高速缓存引用。然后PFRA调用<code>try_to_unmap()</code>从这两个进程的页表项中删除对该页框的引用。一旦该函数结束，该页框就只有交换高速缓存引用它，而引用页槽的为这两个进程和交换高速缓存，如图c所示。假定：当页中的数据写入磁盘时，进程B访问该页，即它要用该页内部的线性地址访问内存单元。那么，缺页异常处理程序发现页框在交换高速缓存，并把物理地址放回B的页表项，如图d所示。</p>
<p>相反，如果缓存操作结束，而没有并发换入操作，<code>shrink_list()</code>则从交换高速缓存删除该页框并把它释放到伙伴系统，如图e所示。<br><img src="/img/1604838117.jpg" alt=""></p>
<p>交换高速缓存可被视为一个临时区域，该区域存有正在被换入后缓存的匿名页描述符。当换入或缓存结束时（对于共享匿名页，换入换出操作必须对共享该页的所有进程进行），匿名页描述符就可以从交换高速缓存删除。</p>
<h4 id="交换高速缓存的实现"><a href="#交换高速缓存的实现" class="headerlink" title="交换高速缓存的实现"></a>交换高速缓存的实现</h4><p>页高速缓存的核心就是一组基树，借助基树，算法就可以从<code>address_space</code>对象地址（即该页的拥有者）和偏移量值推算出页描述符的地址。在交换高速缓存中页的存放方式是隔页存放，并有下列特征：</p>
<ul>
<li>页描述符的<code>mapping</code>字段为NULL。</li>
<li>页描述符的<code>PG_swapcache</code>标志置位。</li>
<li><code>private</code>字段存放与该页有关的换出页标识符。</li>
</ul>
<p>此外，当页被放入交换高速缓存时，页描述符的<code>count</code>字段和页槽引用计数器的值都增加，因为交换高速缓存既使用页框，也使用页槽。</p>
<p>最后，交换高速缓存的所有页只使用一个<code>swapper_space</code>地址空间，因此只有一个基树（有<code>swapper_space.page_tree</code>指向）对交换高速缓存中的页进行寻址。<code>swapper_space</code>地址空间的<code>nrpages</code>字段存放交换高速缓存中的页数。</p>
<h4 id="交换高速缓存的辅助函数"><a href="#交换高速缓存的辅助函数" class="headerlink" title="交换高速缓存的辅助函数"></a>交换高速缓存的辅助函数</h4><p>处理交换高速缓存的函数主要有：</p>
<ul>
<li><code>lookup_swap_cache()</code>：通过传递来的参数（换出页标识符）在交换高速缓存中查找页并返回页描述符的地址。如果该页不在交换高速缓存中，就返回0。该函数调用<code>radix_tree_lookup()</code>函数，把指向<code>swapper_space.page_tree</code>的指针（用于交换高速缓存中页的基树）和换出页标识符作为参数传递，以查找所需要的页。</li>
<li><code>add_to_swap_cache()</code>：把页插入交换高速缓存中。它本质上调用<code>swap_duplicate()</code>检查作为参数传递来的页槽是否有效，并增加页槽引用计数器；然后调用<code>radix_tree_insert()</code>把页插入高速缓存；最后递增页引用计数器并将<code>PG_swapcache</code>和<code>PG_locked</code>标志置位。</li>
<li><code>add_to_swap_cache()</code>：与<code>add_to_swap_cache()</code>类似，但是，在把页框插入交换高速缓存前，这个函数不调用<code>swap_duplicate()</code>。</li>
<li><code>delete_from_swap_cache()</code>：调用<code>radix_tree_delete()</code>从交换高速缓存中删除页，递减<code>swap_map</code>中相应的使用计数器，递减页引用计数器。</li>
<li><code>free_page_and_swap_cache()</code>：如果除了当前进程外，没有其它用户态进程正在引用相应的页槽，则从交换高速缓存中删除该页，并递减页使用计数器。</li>
<li><code>free_pages_and_swap_cache()</code>：与<code>free_page_and_swap_cache()</code>相似，但它是对一组页操作。</li>
<li><code>free_swap_and_cache()</code>：释放一个交换表项，并检查该表项引用的页是否在交换高速缓存。如果没有用户态进程（除了当前进程之外）引用该页，或者超过50％的交换表项在用，则从交换高速缓存中释放该页。</li>
</ul>
<h3 id="换出页"><a href="#换出页" class="headerlink" title="换出页"></a>换出页</h3><h4 id="向交换高速缓存插入页框"><a href="#向交换高速缓存插入页框" class="headerlink" title="向交换高速缓存插入页框"></a>向交换高速缓存插入页框</h4><p>换出操作的第一步就是准备交换高速缓存。如果<code>shrink_list()</code>确认某页为匿名页，且交换高速缓存中没有相应的页框（页描述符的<code>PG_swapcache</code>标志清0），内核就调用<code>add_to_swap()</code>。</p>
<p><code>add_to_swap()</code>在交换区中分配一个新页槽，并把一个页框（其页描述符地址作为参数传递）插入交换高速缓存。函数执行下述步骤。</p>
<ol>
<li>调用<code>get_swap_page()</code>分配一个新页槽，失败（如没有发现空闲页槽）则返回0。</li>
<li>调用<code>__add_to_page_cache()</code>，参数为页槽索引、页描述符地址和一些分配标志。</li>
<li>将页描述符中的<code>PG_uptodate</code>和<code>PG_dirty</code>标志置位，从而强制<code>shrink_list()</code>把页写入磁盘。</li>
<li>返回1（成功）。</li>
</ol>
<h4 id="更新页表项"><a href="#更新页表项" class="headerlink" title="更新页表项"></a>更新页表项</h4><p>一旦<code>add_to_swap()</code>结束，<code>shrink_list()</code>就调用<code>try_to_unmap()</code>，它确定引用匿名页的每个用户态页表项地址，然后将换出页标识符写入其中。</p>
<h4 id="将页写入交换区"><a href="#将页写入交换区" class="headerlink" title="将页写入交换区"></a>将页写入交换区</h4><p>为完成换出操作需执行的下一个步骤是<strong>将页的数据写入交换区</strong>。这一I/O传输由<code>shrink_list()</code>激活，它检查页框的<code>PG_dirty</code>标志是否置位，然后执行<code>pageout()</code>。</p>
<p><code>pageout()</code>建立一个<code>writeback_control</code>描述符，且调用页<code>address_space</code>对象的<code>writepage</code>方法。而<code>swapper_state</code>对象的<code>writepage</code>方法是<code>swap_writepage()</code>实现。</p>
<p><code>swap_writepage()</code>执行如下步骤。</p>
<ol>
<li>检查是否至少有一个用户态进程引用该页。如果没有，则从交换高速缓存删除该页，并返回0。这一检查之所以必须做，是因为一个进程可能会与PFRA发生竞争并在<code>shrink_list()</code>检查后释放一页。</li>
<li>调用<code>get_swap_bio()</code>分配并初始化一个<code>bio</code>描述符。函数从换出页标识符算出交换区描述符地址，然后搜索交换子区链表，以找到页槽的初始磁盘扇区。<code>bio</code>描述符将包含一个单页数据请求（页槽），其完成方法设为<code>end_swap_bio_write()</code>。</li>
<li>置位页描述符的<code>PG_writeback</code>标志和交换高速缓存基树的<code>writeback</code>标记，并将<code>PG_locked</code>标志清0。</li>
<li>调用<code>submit_bio()，参数为</code>WRITE<code>命令和</code>bio`描述符地址。</li>
<li>返回0。</li>
</ol>
<p>一旦I/O数据传输结束，就执行<code>end_swap_bio_write()</code>。该函数唤醒正等待页<code>PG_writeback</code>标志清0的所有进程，清除<code>PG_writeback</code>标志和基树中的相关标记，并释放用于I/O传输的<code>bio</code>描述符。</p>
<h4 id="从交换高速缓存中删除页框"><a href="#从交换高速缓存中删除页框" class="headerlink" title="从交换高速缓存中删除页框"></a>从交换高速缓存中删除页框</h4><p>缓存操作的最后一步还是由<code>shrink_list()</code>执行。如果它验证在I/O数据传输时没有进程试图访问该页框，就调用<code>delete_from_swap_cache()</code>从交换高速缓存中删除该页框。因为交换高速缓存是该页的唯一拥有者，该页框被释放到伙伴系统。</p>
<h3 id="换入页"><a href="#换入页" class="headerlink" title="换入页"></a>换入页</h3><p>当进程试图对一个已缓存到磁盘的页进行寻址时，必然会发生页的换入。在以下条件发生时，缺页异常处理程序就会触发一个换入操作：</p>
<ul>
<li>引起异常的地址所在的页是一个有效的页，即它属于当前进程的一个线性区。</li>
<li>页不在内存中，即页表项中的<code>Present</code>标志被清除。</li>
<li>与页有关的页表项不为空，但<code>Dirty</code>位清0，这意味着页表项包含一个换出页标识符。</li>
</ul>
<p>如果上面的所有条件都满足，则<code>handle_pte_fault()</code>调用相对建议的<code>do_swap_page()</code>换入所需页。</p>
<h4 id="do-swap-page"><a href="#do-swap-page" class="headerlink" title="do_swap_page()"></a>do_swap_page()</h4><p>参数：</p>
<ul>
<li><code>mm</code>，引起缺页异常的进程的内存描述符地址。</li>
<li><code>vma</code>，<code>address</code>所在的线性区的线性区描述符地址。</li>
<li><code>address</code>，引起异常的线性地址。</li>
<li><code>page_table</code>，映射<code>address</code>的页表项的地址。</li>
<li><code>pmd</code>，映射<code>address</code>的页中间目录的地址。</li>
<li><code>orig_pte</code>，映射<code>address</code>的页表项的内容。</li>
<li><code>write_access</code>，一个标志，表示试图执行的访问是读操作还是写操作。</li>
</ul>
<p>与其他函数相反，<code>do_swap_page()</code>不返回0。如果页已经在交换高速缓存中就返回1（次错误），如果页已经从交换区读入就返回2（主错误），如果在进行换入时发生错误就返回-1。函数执行下述步骤：</p>
<ol>
<li>从<code>orig_pte</code>获得换出页标识符。</li>
<li>调用<code>pte_unmap()</code>释放任何页表的临时内核映射，该页表由<code>handle_mm_fault()</code>建立。访问高端内存页表需要进行内核映射。</li>
<li>释放内存描述符的<code>page_table_lock</code>自旋锁。</li>
<li>调用<code>lookup_swap_cache()</code>检查交换高速缓存是否已经含有换出页标识符对应的页；如果页已经在交换高速缓存中，就跳到第6步。</li>
<li>调用<code>swapin_readhead()</code>从交换区读取至多<code>2n</code>个页的一组页，其中包括所请求的页。值<code>n</code>存放在<code>page_cluster</code>变量中，通常等于3。其中每个页是通过调用<code>read_swap_cache_async()</code>读入的。</li>
<li>再一次调用<code>read_swap_cache_async()</code>换入由引起缺页异常的进程所访问的页。<code>swapin_readahead()</code>可能在读取请求的页时失败，如，因为<code>page_cluster</code>被置为0，或者该函数试图读取一组含空闲或有缺陷页槽（<code>SWAP_MAP_BAD</code>）的页。另一方面，如果<code>swapin_readahead()</code>成功，这次对<code>read_swap_cache_async()</code>的调用就会很快结束，因为它在交换高速缓存找到了页。</li>
<li>尽管如此，如果请求的页还是没有被加到交换高速缓存，那么，另一个内核控制路径可能已经代表这个进程的一个子进程换入了所请求的页。这种情况的检查可通过临时获取<code>page_table_lock</code>自旋锁，并把<code>page_table</code>所指向的表项与<code>orig_pte</code>进行比较来实现。如果二者有差异，则说明这一页已经被某个其它的内核控制路径换入，因此，函数返回1（次错误）；否则，返回-1（失败）。</li>
<li>至此，页已经在高速缓存中。如果页已经被换入（主错误），函数就调用<code>grab_swap_token()</code>试图获得一个交换标记。</li>
<li>调用<code>mark_page_accessed()</code>并对页加锁。</li>
<li>获取<code>page_table_lock</code>自旋锁。</li>
<li>检查另一个内核控制路径是否代表这个进程的一个子进程换入了所请求的页。如果是，就释放<code>page_table_lock</code>自旋锁，打开页上的锁，并返回1（次错误）。</li>
<li>调用<code>swap_free()</code>减少<code>entry</code>对应的页槽的引用计数器。</li>
<li>检查交换高速缓存是否至少占满50%（<code>nr_swap_pages</code>小于<code>total_swap_pages</code>的一半）。如果是，则检查页是否被引起异常的进程（或其一个子进程）拥有；如果是，则从交换高速缓存中删除该页。</li>
<li>增加进程的内存描述符的<code>rss</code>字段。</li>
<li>更新页表项以便进程能找到该页。这一操作的实现是通过把所请求的页的物理地址和在线性区的<code>vm_page_prot</code>字段所找到的保护位写入<code>page_table</code>所指向的页表中完成。此外，如果引起缺页的访问是一个写访问，且造成缺页的进程页的唯一拥有者，则函数还要设置<code>Dirty</code>和<code>Read/Write</code>标志以防无用的写时复制错误。</li>
<li>打开页上的锁。</li>
<li>调用<code>page_add_anon_rmap()</code>把匿名页插入面向对象的反向映射数据结构。</li>
<li>如果<code>write_access</code>参数等于1，则函数调用<code>do_wp_page()</code>复制一份页框。</li>
<li>释放<code>mm-&gt;page_table_lock</code>自旋锁，并返回1（次错误）或2（主错误）。</li>
</ol>
<h4 id="read-swap-cache-async"><a href="#read-swap-cache-async" class="headerlink" title="read_swap_cache_async()"></a>read_swap_cache_async()</h4><p>换入一个页，就调用这个函数。参数：</p>
<ul>
<li><code>entry</code>，换出页标识符。</li>
<li><code>vma</code>，指向该页所在线性区的指针。</li>
<li><code>addr</code>，页的线性地址。</li>
</ul>
<p>在访问交换分区前，该函数必须检查交换高速缓存是否已经包含了所要的页框。该函数本质上执行下列操作：</p>
<ol>
<li>调用<code>radix_tree_lookup()</code>，搜索<code>swapper_sapce</code>对象的基树，寻找由换出页标识符<code>entry</code>给出位置的页框。如果找到该页，递增它的引用计数器，返回它的描述符地址。</li>
<li>页不在交换高速缓存。调用<code>alloc_page()</code>分配一个新的页框。如果没有空闲的页框可用，则返回0（表示系统没有足够的内存）。</li>
<li>调用<code>add_to_swap_cache()</code>把新页框的页描述符插入交换高速缓存，并对页加锁。</li>
<li>如果<code>add_to_swap_cache()</code>在交换高速缓存找到页的一个副本，则前一步可能失败。如，进程可能在第2步阻塞，因此允许另一个进程在同一个页槽上开始换入操作。这种情况下，该函数释放在第2步分配的页框，并从第1步重新开始。</li>
<li>调用<code>lru_cache_add_active()</code>把页插入LRU的活动链表。</li>
<li>新页框的页描述符现在已在交换高速缓存。调用<code>swap_readpage()</code>从交换区读入该页数据。该函数与<code>swap_writepage()</code>相似，将页描述符的<code>PG_uptodate</code>标志清0，调用<code>get_swap_bio()</code>为I/O传输分配与初始化一个<code>bio</code>描述符，再调用<code>submit_bio()</code>向块设备子系统层发出I/O请求。</li>
<li>返回页描述符的地址。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B05/" rel="next" title="深入理解Linux内核13-15章">
                <i class="fa fa-chevron-left"></i> 深入理解Linux内核13-15章
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/11/06/Boost_cpp%E8%B5%84%E6%96%99/" rel="prev" title="Boost C++库">
                Boost C++库 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">130</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6"><span class="nav-number">1.</span> <span class="nav-text">访问文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.</span> <span class="nav-text">读写文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.1.</span> <span class="nav-text">从文件中读取数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E7%9A%84readpage%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">普通文件的readpage方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84readpage%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">块设备文件的readpage方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%A2%84%E8%AF%BB"><span class="nav-number">1.1.2.</span> <span class="nav-text">文件的预读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#page-cache-readahead"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">page_cache_readahead()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#handle-ra-miss"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">handle_ra_miss()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.3.</span> <span class="nav-text">写入文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E7%9A%84prepare-write%E5%92%8Ccommit-write%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">普通文件的prepare_write和commit_write方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84prepare-write%E5%92%8Ccommit-write%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">块设备文件的prepare_write和commit_write方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E8%84%8F%E9%A1%B5%E5%86%99%E5%88%B0%E7%A3%81%E7%9B%98"><span class="nav-number">1.1.4.</span> <span class="nav-text">把脏页写到磁盘</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">1.2.</span> <span class="nav-text">内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">内存映射的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">1.2.2.</span> <span class="nav-text">创建内存映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%A4%E9%94%80%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">1.2.3.</span> <span class="nav-text">撤销内存映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5"><span class="nav-number">1.2.4.</span> <span class="nav-text">内存映射的请求调页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E8%84%8F%E9%A1%B5%E5%88%B7%E6%96%B0%E5%88%B0%E7%A3%81%E7%9B%98"><span class="nav-number">1.2.5.</span> <span class="nav-text">把内存映射的脏页刷新到磁盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">1.2.6.</span> <span class="nav-text">非线性内存映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5I-O%E4%BC%A0%E9%80%81"><span class="nav-number">1.3.</span> <span class="nav-text">直接I&#x2F;O传送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5I-O"><span class="nav-number">1.4.</span> <span class="nav-text">异步I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux2-6%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5I-O"><span class="nav-number">1.4.1.</span> <span class="nav-text">Linux2.6中的异步I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5I-O%E7%8E%AF%E5%A2%83"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">异步I&#x2F;O环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E5%BC%82%E6%AD%A5I-O%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">提交异步I&#x2F;O操作</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E9%A1%B5%E6%A1%86"><span class="nav-number">2.</span> <span class="nav-text">回收页框</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E6%A1%86%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">页框回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E7%9B%AE%E6%A0%87%E9%A1%B5"><span class="nav-number">2.1.1.</span> <span class="nav-text">选择目标页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PFRA%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.1.2.</span> <span class="nav-text">PFRA设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E6%98%A0%E5%B0%84"><span class="nav-number">2.2.</span> <span class="nav-text">反向映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E9%A1%B5%E7%9A%84%E5%8F%8D%E5%90%91%E6%98%A0%E5%B0%84"><span class="nav-number">2.2.1.</span> <span class="nav-text">匿名页的反向映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-to-unmap-anon"><span class="nav-number">2.2.2.</span> <span class="nav-text">try_to_unmap_anon()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-to-unmap-one"><span class="nav-number">2.2.3.</span> <span class="nav-text">try_to_unmap_one()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E9%A1%B5%E7%9A%84%E5%8F%8D%E5%90%91%E6%98%A0%E5%B0%84"><span class="nav-number">2.3.</span> <span class="nav-text">映射页的反向映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91PST"><span class="nav-number">2.3.1.</span> <span class="nav-text">优先搜索树PST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-to-unmap-file"><span class="nav-number">2.3.2.</span> <span class="nav-text">try_to_unmap_file()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PFRA%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.4.</span> <span class="nav-text">PFRA实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%EF%BC%88LRU%EF%BC%89%E9%93%BE%E8%A1%A8"><span class="nav-number">2.4.1.</span> <span class="nav-text">最近最少使用（LRU）链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8LRU%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%A7%BB%E5%8A%A8%E9%A1%B5"><span class="nav-number">2.4.2.</span> <span class="nav-text">在LRU链表之间移动页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mark-page-accessed"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">mark_page_accessed()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#page-referenced"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">page_referenced()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#refile-inactive-zone"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">refile_inactive_zone()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%B4%A7%E7%BC%BA%E5%9B%9E%E6%94%B6"><span class="nav-number">2.4.3.</span> <span class="nav-text">内存紧缺回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#free-more-memory"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">free_more_memory()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#try-to-free-pages"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">try_to_free_pages()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shrink-caches"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">shrink_caches()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shrink-zone"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">shrink_zone()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shrink-cache"><span class="nav-number">2.4.3.5.</span> <span class="nav-text">shrink_cache()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shrink-list"><span class="nav-number">2.4.3.6.</span> <span class="nav-text">shrink_list()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pageout"><span class="nav-number">2.4.3.7.</span> <span class="nav-text">pageout()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E5%8F%AF%E5%8E%8B%E7%BC%A9%E7%A3%81%E7%9B%98%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E9%A1%B5"><span class="nav-number">2.4.3.8.</span> <span class="nav-text">回收可压缩磁盘高速缓存的页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E7%9B%AE%E5%BD%95%E9%A1%B9%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%9B%9E%E6%94%B6%E9%A1%B5%E6%A1%86"><span class="nav-number">2.4.3.9.</span> <span class="nav-text">从目录项高速缓存回收页框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%9B%9E%E6%94%B6%E9%A1%B5%E6%A1%86"><span class="nav-number">2.4.3.10.</span> <span class="nav-text">从索引节点高速缓存回收页框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%A8%E6%9C%9F%E5%9B%9E%E6%94%B6"><span class="nav-number">2.4.3.11.</span> <span class="nav-text">周期回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kswapd-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.4.3.12.</span> <span class="nav-text">kswapd 内核线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cache-reap"><span class="nav-number">2.4.3.13.</span> <span class="nav-text">cache_reap()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E5%88%A0%E9%99%A4%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.4.3.14.</span> <span class="nav-text">内存不足删除程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%A0%87%E8%AE%B0"><span class="nav-number">2.4.4.</span> <span class="nav-text">交换标记</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2"><span class="nav-number">2.5.</span> <span class="nav-text">交换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E5%8C%BA"><span class="nav-number">2.5.1.</span> <span class="nav-text">交换区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%BF%80%E6%B4%BB%E4%BA%A4%E6%8D%A2%E5%8C%BA"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">创建与激活交换区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BA%A4%E6%8D%A2%E5%8C%BA%E4%B8%AD%E5%88%86%E5%B8%83%E9%A1%B5"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">如何在交换区中分布页</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E5%8C%BA%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.5.2.</span> <span class="nav-text">交换区描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%A2%E5%87%BA%E9%A1%B5%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">2.5.3.</span> <span class="nav-text">换出页标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BF%80%E6%B4%BB%E5%92%8C%E7%A6%81%E7%94%A8%E4%BA%A4%E6%8D%A2%E5%8C%BA"><span class="nav-number">2.5.4.</span> <span class="nav-text">激活和禁用交换区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sys-swapon-%E6%9C%8D%E5%8A%A1%E4%BE%8B%E7%A8%8B"><span class="nav-number">2.5.4.1.</span> <span class="nav-text">sys_swapon()服务例程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sys-swapoff-%E6%9C%8D%E5%8A%A1%E4%BE%8B%E7%A8%8B"><span class="nav-number">2.5.4.2.</span> <span class="nav-text">sys_swapoff()服务例程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#try-to-unuse"><span class="nav-number">2.5.4.3.</span> <span class="nav-text">try_to_unuse()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%92%8C%E9%87%8A%E6%94%BE%E9%A1%B5%E6%A7%BD"><span class="nav-number">2.5.5.</span> <span class="nav-text">分配和释放页槽</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#scan-swap-map"><span class="nav-number">2.5.5.1.</span> <span class="nav-text">scan_swap_map()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-swap-page"><span class="nav-number">2.5.5.2.</span> <span class="nav-text">get_swap_page()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#swap-free"><span class="nav-number">2.5.5.3.</span> <span class="nav-text">swap_free()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">2.5.5.4.</span> <span class="nav-text">交换高速缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.5.5.5.</span> <span class="nav-text">交换高速缓存的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.5.6.</span> <span class="nav-text">交换高速缓存的辅助函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%A2%E5%87%BA%E9%A1%B5"><span class="nav-number">2.5.6.</span> <span class="nav-text">换出页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E4%BA%A4%E6%8D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E6%8F%92%E5%85%A5%E9%A1%B5%E6%A1%86"><span class="nav-number">2.5.6.1.</span> <span class="nav-text">向交换高速缓存插入页框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E9%A1%B5%E8%A1%A8%E9%A1%B9"><span class="nav-number">2.5.6.2.</span> <span class="nav-text">更新页表项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E9%A1%B5%E5%86%99%E5%85%A5%E4%BA%A4%E6%8D%A2%E5%8C%BA"><span class="nav-number">2.5.6.3.</span> <span class="nav-text">将页写入交换区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E4%BA%A4%E6%8D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%AD%E5%88%A0%E9%99%A4%E9%A1%B5%E6%A1%86"><span class="nav-number">2.5.6.4.</span> <span class="nav-text">从交换高速缓存中删除页框</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%A2%E5%85%A5%E9%A1%B5"><span class="nav-number">2.5.7.</span> <span class="nav-text">换入页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#do-swap-page"><span class="nav-number">2.5.7.1.</span> <span class="nav-text">do_swap_page()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-swap-cache-async"><span class="nav-number">2.5.7.2.</span> <span class="nav-text">read_swap_cache_async()</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
