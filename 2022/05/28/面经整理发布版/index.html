<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1. 语言基础 (C&#x2F;C++)（0） 指针和引用的区别 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作 指针可以有多级，引用只有一级 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改 指针的大小一般是4个字节，引用的大小取决于被引用对象的大小 指针可以为空，引用不可以。">
<meta property="og:type" content="article">
<meta property="og:title" content="面经整理">
<meta property="og:url" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="1. 语言基础 (C&#x2F;C++)（0） 指针和引用的区别 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作 指针可以有多级，引用只有一级 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改 指针的大小一般是4个字节，引用的大小取决于被引用对象的大小 指针可以为空，引用不可以。">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.jpg">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/DNS%E6%9F%A5%E8%AF%A2%E5%9B%BE%E8%A7%A3.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/Bptree.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/select.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/epoll.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png">
<meta property="og:image" content="https://img-blog.csdn.net/20140904215636015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd6aGVianV0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/%E4%B8%83%E6%80%81%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/bitmap1.png">
<meta property="og:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png">
<meta property="article:published_time" content="2022-05-28T09:00:00.000Z">
<meta property="article:modified_time" content="2022-12-27T06:16:05.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="积累">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/fig/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png">

<link rel="canonical" href="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>面经整理 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面经整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-28 17:00:00" itemprop="dateCreated datePublished" datetime="2022-05-28T17:00:00+08:00">2022-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-27 14:16:05" itemprop="dateModified" datetime="2022-12-27T14:16:05+08:00">2022-12-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-语言基础-C-C"><a href="#1-语言基础-C-C" class="headerlink" title="1. 语言基础 (C/C++)"></a>1. 语言基础 (C/C++)</h1><h4 id="（0）-指针和引用的区别"><a href="#（0）-指针和引用的区别" class="headerlink" title="（0） 指针和引用的区别"></a>（0） 指针和引用的区别</h4><ul>
<li>指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作</li>
<li>指针可以有多级，引用只有一级</li>
<li>传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改</li>
<li>指针的大小一般是4个字节，引用的大小取决于被引用对象的大小</li>
<li>指针可以为空，引用不可以。</li>
</ul>
<h4 id="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"><a href="#（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？" class="headerlink" title="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"></a>（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？</h4><ul>
<li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li>
<li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li>
<li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li>
</ul>
<h4 id="（2）-堆和栈有什么区别"><a href="#（2）-堆和栈有什么区别" class="headerlink" title="（2） 堆和栈有什么区别"></a>（2） 堆和栈有什么区别</h4><ul>
<li>从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。</li>
<li>堆空间因为会有频繁的分配释放操作，会产生内存碎片</li>
<li>堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小</li>
</ul>
<h4 id="（3）堆快一点还是栈快一点？（字节提前批一面）"><a href="#（3）堆快一点还是栈快一点？（字节提前批一面）" class="headerlink" title="（3）堆快一点还是栈快一点？（字节提前批一面）"></a>（3）堆快一点还是栈快一点？（字节提前批一面）</h4><p>栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p>
<h4 id="（4）-new和delete是如何实现的，new-与-malloc的异同处"><a href="#（4）-new和delete是如何实现的，new-与-malloc的异同处" class="headerlink" title="（4） new和delete是如何实现的，new 与 malloc的异同处"></a>（4） new和delete是如何实现的，new 与 malloc的异同处</h4><p>在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。</p>
<p>new与malloc都会分配空间，但是new还会调用对象的构造函数进行初始化，malloc需要给定空间大小，而new只需要对象名</p>
<h4 id="（5）既然有了malloc-free，C-中为什么还需要new-delete呢？"><a href="#（5）既然有了malloc-free，C-中为什么还需要new-delete呢？" class="headerlink" title="（5）既然有了malloc/free，C++中为什么还需要new/delete呢？"></a>（5）既然有了malloc/free，C++中为什么还需要new/delete呢？</h4><p><a href="https://blog.csdn.net/leikun153/article/details/80612130">https://blog.csdn.net/leikun153/article/details/80612130</a></p>
<ul>
<li>malloc/free和new/delete都是用来申请内存和回收内存的。</li>
<li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。</li>
</ul>
<h4 id="（6）-C和C-的区别"><a href="#（6）-C和C-的区别" class="headerlink" title="（6） C和C++的区别"></a>（6） C和C++的区别</h4><p>包括但不限于：</p>
<ul>
<li>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码模块化。继承通过子类继承父类的方法和属性，实现了代码重用。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了接口重用。</li>
<li>C和C++内存管理的方法不一样，C使用malloc/free，C++除此之外还用new/delete</li>
<li>C++中还有函数重载和引用等概念，C中没有</li>
</ul>
<h4 id="（7）delete和delete-的区别"><a href="#（7）delete和delete-的区别" class="headerlink" title="（7）delete和delete[]的区别"></a>（7）delete和delete[]的区别</h4><ul>
<li><p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数</p>
</li>
<li><p>用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p>
</li>
</ul>
<h4 id="（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"><a href="#（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）" class="headerlink" title="（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"></a>（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h4><p>包括但不限于：</p>
<ul>
<li>C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。</li>
<li>C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法</li>
<li>C++有指针，Java没有指针，只有引用</li>
<li>JAVA和C++都有构造函数，但是C++有析构函数但是Java没有</li>
</ul>
<h4 id="（9）C-和python的区别"><a href="#（9）C-和python的区别" class="headerlink" title="（9）C++和python的区别"></a>（9）C++和python的区别</h4><p>包括但不限于：</p>
<ol>
<li>python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li>
<li>python使用缩进来区分不同的代码块，C++使用花括号来区分</li>
<li>C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li>
<li>python的库函数比C++的多，调用起来很方便</li>
</ol>
<h4 id="（10）-Struct和class的区别"><a href="#（10）-Struct和class的区别" class="headerlink" title="（10） Struct和class的区别"></a>（10） Struct和class的区别</h4><ul>
<li>使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的</li>
<li>struct的继承默认是public继承，而class的继承默认是private继承</li>
<li>class可以用作模板，而struct不能</li>
</ul>
<h4 id="（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）"><a href="#（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）" class="headerlink" title="（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）"></a>（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）</h4><p>联系：它们都是定义常量的一种方法。</p>
<p>区别：</p>
<ul>
<li>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。</li>
<li>define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</li>
<li>define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。</li>
<li>const可以定义函数而define不可以。</li>
</ul>
<h4 id="（12）-在C-中const的用法（定义，用途）"><a href="#（12）-在C-中const的用法（定义，用途）" class="headerlink" title="（12） 在C++中const的用法（定义，用途）"></a>（12） 在C++中const的用法（定义，用途）</h4><ul>
<li>const修饰类的成员变量时，表示常量不能被修改</li>
<li>const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</li>
</ul>
<h4 id="（13）-C-中的static用法和意义"><a href="#（13）-C-中的static用法和意义" class="headerlink" title="（13） C++中的static用法和意义"></a>（13） C++中的static用法和意义</h4><p>static的意思是静态的，可以用来修饰变量，函数和类成员。</p>
<ul>
<li><p>变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。</p>
</li>
<li><p>函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。</p>
</li>
<li><p>类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。</p>
</li>
</ul>
<p>【note】静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。</p>
<p>注意和const的区别。const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用。</p>
<h4 id="（14）-计算下面几个类的大小："><a href="#（14）-计算下面几个类的大小：" class="headerlink" title="（14） 计算下面几个类的大小："></a>（14） 计算下面几个类的大小：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p>
<p>空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节<br><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">static</span> <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">static</span> <span class="type">int</span> a; <span class="type">int</span> b; &#125;;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p>
<h4 id="（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><a href="#（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等" class="headerlink" title="（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"></a>（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h4><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p>
<ul>
<li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li>
<li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li>
<li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li>
</ul>
<h4 id="（16）-STL源码中的hash表的实现"><a href="#（16）-STL源码中的hash表的实现" class="headerlink" title="（16） STL源码中的hash表的实现"></a>（16） STL源码中的hash表的实现</h4><p>STL中的hash表就unordered_map。使用的是哈希进行实现（注意与map的区别）。它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。</p>
<p>unordered_map的底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过8时，就自动转为红黑树进行组织。</p>
<h4 id="（17）解决哈希冲突的方式？"><a href="#（17）解决哈希冲突的方式？" class="headerlink" title="（17）解决哈希冲突的方式？"></a>（17）解决哈希冲突的方式？</h4><ol>
<li>线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。</li>
<li>二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找1^2,2^2,3^2,4^2…..i^2个位置。</li>
<li>双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。</li>
<li>开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，STL的hashtable就是采用这种实现方式。</li>
<li>建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。</li>
</ol>
<h4 id="（18）-STL中unordered-map和map的区别"><a href="#（18）-STL中unordered-map和map的区别" class="headerlink" title="（18） STL中unordered_map和map的区别"></a>（18） STL中unordered_map和map的区别</h4><ul>
<li>unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现==操作符。</li>
<li>map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。</li>
</ul>
<h4 id="（19）-STL中vector的实现"><a href="#（19）-STL中vector的实现" class="headerlink" title="（19） STL中vector的实现"></a>（19） STL中vector的实现</h4><p>STL中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。</p>
<p>在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。</p>
<h4 id="（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><a href="#（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。" class="headerlink" title="（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。"></a>（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h4><p>如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。这种情况可以考虑使用list。</p>
<h4 id="（21）C-中vector和list的区别"><a href="#（21）C-中vector和list的区别" class="headerlink" title="（21）C++中vector和list的区别"></a>（21）C++中vector和list的区别</h4><p>vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</p>
<p>list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。</p>
<p>vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+=”，“&lt;”等操作符。</p>
<p>list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+=”、“&lt;”等</p>
<p>vector::iterator和list::iterator都重载了“++”运算符。</p>
<p>总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</p>
<p>如果需要大量的插入和删除，而不关心随机存取，则应使用list。</p>
<h4 id="（22）-C-中的重载和重写的区别："><a href="#（22）-C-中的重载和重写的区别：" class="headerlink" title="（22） C++中的重载和重写的区别："></a>（22） C++中的重载和重写的区别：</h4><ul>
<li>重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。</li>
<li>重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。</li>
</ul>
<p>详见：<a href="https://blog.csdn.net/weixin_30379911/article/details/99497160">https://blog.csdn.net/weixin_30379911/article/details/99497160</a></p>
<h4 id="（23）-C-内存管理（热门问题）"><a href="#（23）-C-内存管理（热门问题）" class="headerlink" title="（23） C ++内存管理（热门问题）"></a>（23） C ++内存管理（热门问题）</h4><p><a href="https://blog.csdn.net/qq_43152052/article/details/98889139">https://blog.csdn.net/qq_43152052/article/details/98889139</a></p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、全局/静态存储区和常量存储区和代码区。</p>
<ul>
<li>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</li>
<li>全局/静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。</li>
<li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。</li>
<li>代码区，存放程序的二进制代码</li>
</ul>
<p>关于这个有很多种说法，有的会增加一个自由存储区，存放malloc分配得到的内存，与堆相似。</p>
<h4 id="（24）-介绍面向对象的三大特性，并且举例说明每一个。"><a href="#（24）-介绍面向对象的三大特性，并且举例说明每一个。" class="headerlink" title="（24） 介绍面向对象的三大特性，并且举例说明每一个。"></a>（24） 介绍面向对象的三大特性，并且举例说明每一个。</h4><p>面向对象的三大特性是：封装，继承和多态。</p>
<ul>
<li>封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public；</li>
<li>继承使得子类可以复用父类的成员和方法，实现了代码重用；</li>
<li>多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。</li>
</ul>
<h4 id="（25）-多态的实现（和下个问题一起回答）"><a href="#（25）-多态的实现（和下个问题一起回答）" class="headerlink" title="（25） 多态的实现（和下个问题一起回答）"></a>（25） 多态的实现（和下个问题一起回答）</h4><p>C++ 多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。</p>
<ul>
<li>虚函数：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.</li>
</ul>
<h4 id="（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><a href="#（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）" class="headerlink" title="（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"></a>（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h4><p>C++的虚函数是实现多态的机制。它是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。</p>
<p>详见：<a href="https://blog.csdn.net/lihao21/article/details/50688337">C++虚函数表剖析</a></p>
<ul>
<li>如果多重继承和多继承的话，子类的虚函数表长什么样子？<br>多重继承的情况下越是祖先的父类的虚函数更靠前，多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前。详见：<a href="https://blog.csdn.net/qq_36359022/article/details/81870219">https://blog.csdn.net/qq_36359022/article/details/81870219</a></li>
</ul>
<h4 id="（27）-实现编译器处理虚函数表应该如何处理"><a href="#（27）-实现编译器处理虚函数表应该如何处理" class="headerlink" title="（27） 实现编译器处理虚函数表应该如何处理"></a>（27） 实现编译器处理虚函数表应该如何处理</h4><p>编译器处理虚函数的方法是：<br>如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。<br>为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。<br>详见：<a href="https://blog.csdn.net/iFuMI/article/details/51088091">虚函数的作用及其底层实现机制</a></p>
<h4 id="（28）-基类的析构函数一般写成虚函数的原因"><a href="#（28）-基类的析构函数一般写成虚函数的原因" class="headerlink" title="（28） 基类的析构函数一般写成虚函数的原因"></a>（28） 基类的析构函数一般写成虚函数的原因</h4><p>首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。</p>
<p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。</p>
<h4 id="（29）-构造函数为什么一般不定义为虚函数"><a href="#（29）-构造函数为什么一般不定义为虚函数" class="headerlink" title="（29） 构造函数为什么一般不定义为虚函数"></a>（29） 构造函数为什么一般不定义为虚函数</h4><p>1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，<strong>由于对象还未创建成功，编译器无法知道对象的实际类型</strong>，是类本身还是类的派生类等等</p>
<p>2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了</p>
<h4 id="（30）-构造函数或者析构函数中调用虚函数会怎样"><a href="#（30）-构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="（30） 构造函数或者析构函数中调用虚函数会怎样"></a>（30） 构造函数或者析构函数中调用虚函数会怎样</h4><p>在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。</p>
<p>在析构函数中调用虚函数，此时调用的是子类的函数实现方式。</p>
<h4 id="（31）-纯虚函数"><a href="#（31）-纯虚函数" class="headerlink" title="（31） 纯虚函数"></a>（31） 纯虚函数</h4><p>纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承</p>
<p>包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象</p>
<p>使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。</p>
<h4 id="（32）-静态绑定和动态绑定的介绍"><a href="#（32）-静态绑定和动态绑定的介绍" class="headerlink" title="（32） 静态绑定和动态绑定的介绍"></a>（32） 静态绑定和动态绑定的介绍</h4><p><a href="https://www.cnblogs.com/lizhenghn/p/3657717.html">C++中的静态绑定和动态绑定</a></p>
<p>静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。</p>
<p>动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。</p>
<h4 id="（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h4><p>浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。</p>
<p>而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。</p>
<p>深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。</p>
<h4 id="（34）-对象复用的了解，零拷贝的了解"><a href="#（34）-对象复用的了解，零拷贝的了解" class="headerlink" title="（34） 对象复用的了解，零拷贝的了解"></a>（34） 对象复用的了解，零拷贝的了解</h4><p>对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。</p>
<p>零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。</p>
<blockquote>
<p>用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</p>
</blockquote>
<h4 id="（35）-介绍C-所有的构造函数"><a href="#（35）-介绍C-所有的构造函数" class="headerlink" title="（35） 介绍C++所有的构造函数"></a>（35） 介绍C++所有的构造函数</h4><p>C++中的构造函数主要有三种类型：默认构造函数、重载构造函数和拷贝构造函数</p>
<ul>
<li>默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。</li>
<li>重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。</li>
<li>拷贝构造函数是在发生对象复制的时候调用的。 <h4 id="（36）-什么情况下会调用拷贝构造函数（三种情况）"><a href="#（36）-什么情况下会调用拷贝构造函数（三种情况）" class="headerlink" title="（36） 什么情况下会调用拷贝构造函数（三种情况）"></a>（36） 什么情况下会调用拷贝构造函数（三种情况）</h4></li>
<li><p>对象以值传递的方式传入函数参数 </p>
<blockquote>
<p>如 <code>void func(Dog dog)&#123;&#125;;</code></p>
</blockquote>
</li>
<li><p>对象以值传递的方式从函数返回</p>
<blockquote>
<p>如 <code>Dog func()&#123; Dog d; return d;&#125;</code></p>
</blockquote>
</li>
<li>对象需要通过另外一个对象进行初始化</li>
</ul>
<p>详见：<a href="https://blog.csdn.net/lwbeyond/article/details/6202256">C++拷贝构造函数详解</a></p>
<h4 id="（37）-结构体内存对齐方式和为什么要进行内存对齐？"><a href="#（37）-结构体内存对齐方式和为什么要进行内存对齐？" class="headerlink" title="（37） 结构体内存对齐方式和为什么要进行内存对齐？"></a>（37） 结构体内存对齐方式和为什么要进行内存对齐？</h4><p>因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。</p>
<p>对齐规则：</p>
<ul>
<li>第一个成员在与结构体变量偏移量为0的地址</li>
<li>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</li>
<li>对齐数=编译器默认的一个对齐数 与 该成员大小的较小值。</li>
<li>linux 中默认为4</li>
<li>vs 中的默认值为8<br>结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）</li>
</ul>
<h4 id="（38）-内存泄露的定义，如何检测与避免？"><a href="#（38）-内存泄露的定义，如何检测与避免？" class="headerlink" title="（38） 内存泄露的定义，如何检测与避免？"></a>（38） 内存泄露的定义，如何检测与避免？</h4><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。</p>
<p>造成内存泄漏的几种原因：</p>
<p>1）类的构造函数和析构函数中new和delete没有配套</p>
<p>2）在释放对象数组时没有使用delete[]，使用了delete</p>
<p>3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</p>
<p>4）没有正确的清楚嵌套的对象指针</p>
<p>避免方法：</p>
<ol>
<li>malloc/free要配套</li>
<li>使用智能指针；</li>
<li>将基类的析构函数设为虚函数；<h4 id="（39）-C-的智能指针有哪些"><a href="#（39）-C-的智能指针有哪些" class="headerlink" title="（39） C++的智能指针有哪些"></a>（39） C++的智能指针有哪些</h4>C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记释放指针指向的内存地址造成内存泄漏。</li>
</ol>
<ul>
<li>auto_ptr是较早版本的智能指针，在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题。</li>
<li>unique_ptr是auto_ptr的一个改良版，不能赋值也不能拷贝，保证一个对象同一时间只有一个智能指针。</li>
<li>shared_ptr可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。（内部使用计数机制进行维护）</li>
<li>weak_ptr是为了协助shared_ptr而出现的。它不能访问对象，只能观测shared_ptr的引用计数，防止出现死锁。<h4 id="（40）-调试程序的方法"><a href="#（40）-调试程序的方法" class="headerlink" title="（40） 调试程序的方法"></a>（40） 调试程序的方法</h4></li>
<li>通过设置断点进行调试</li>
<li>打印log进行调试</li>
<li><p>打印中间结果进行调试</p>
<h4 id="（41）-遇到coredump要怎么调试"><a href="#（41）-遇到coredump要怎么调试" class="headerlink" title="（41） 遇到coredump要怎么调试"></a>（41） 遇到coredump要怎么调试</h4><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
</li>
<li><p>使用gdb命令对core文件进行调试</p>
</li>
</ul>
<p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir coredumpTest</span><br><span class="line">vim coredumpTest.cpp</span><br></pre></td></tr></table></figure><br>在编辑器内键入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int i;</span><br><span class="line">    scanf(&quot;%d&quot;,i);//正确的应该是&amp;i,这里使用i会导致segment fault</span><br><span class="line">    printf(&quot;%d\n&quot;,i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>编译<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ coredumpTest.cpp -g -o coredumpTest</span><br></pre></td></tr></table></figure><br>运行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./coredumpTest</span><br></pre></td></tr></table></figure><br>使用gdb调试coredump<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [可执行文件名] [core文件名]</span><br></pre></td></tr></table></figure></p>
<h4 id="（42）-inline关键字说一下-和宏定义有什么区别"><a href="#（42）-inline关键字说一下-和宏定义有什么区别" class="headerlink" title="（42） inline关键字说一下 和宏定义有什么区别"></a>（42） inline关键字说一下 和宏定义有什么区别</h4><p>inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</p>
<p>1、内联函数在编译时展开，而宏在预编译时展开</p>
<p>2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</p>
<p>3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。</p>
<p>4、宏不是函数，而inline是函数</p>
<p>5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。</p>
<p>6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</p>
<p>7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p>
<h4 id="（43）-模板的用法与适用场景-实现原理"><a href="#（43）-模板的用法与适用场景-实现原理" class="headerlink" title="（43） 模板的用法与适用场景 实现原理"></a>（43） 模板的用法与适用场景 实现原理</h4><p>用template \<typename T\>关键字进行声明，接下来就可以进行模板函数和模板类的编写了</p>
<p>编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，这次编译只会进行一个语法检查，并不会生成具体的代码。在运行时对代码进行参数替换后再进行编译，生成具体的函数代码。</p>
<h4 id="（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><a href="#（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？" class="headerlink" title="（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"></a>（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h4><p>成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    FaceImage face;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>&amp; inputID,string&amp; inputName,FaceImage&amp; inputFace):<span class="built_in">id</span>(inputID),<span class="built_in">name</span>(inputName),<span class="built_in">face</span>(inputFace)&#123;&#125; <span class="comment">// 成员初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。<br><br>另外，有三种情况是必须使用成员初始化列表进行初始化的：</p>
<ul>
<li>常量成员的初始化，因为常量成员只能初始化不能赋值</li>
<li>引用类型</li>
<li>没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化</li>
</ul>
<p>详见<a href="https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html">C++ 初始化列表</a></p>
<h4 id="（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><a href="#（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）" class="headerlink" title="（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"></a>（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h4><ul>
<li>自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作</li>
<li><p>nullptr：nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的</p>
</li>
<li><p>lambda表达式：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：<br><code>[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型&#123;函数体&#125;</code></p>
</li>
<li>thread类和mutex类</li>
<li>新的智能指针 unique_ptr和shared_ptr</li>
</ul>
<ul>
<li>更多详见：<a href="https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279">https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279</a></li>
</ul>
<h4 id="（46）-C-的调用惯例（简单一点C-函数调用的压栈过程）"><a href="#（46）-C-的调用惯例（简单一点C-函数调用的压栈过程）" class="headerlink" title="（46） C++的调用惯例（简单一点C++函数调用的压栈过程）"></a>（46） C++的调用惯例（简单一点C++函数调用的压栈过程）</h4><p>函数的调用过程：</p>
<p>1）从栈空间分配存储空间</p>
<p>2）从实参的存储空间复制值到形参栈空间</p>
<p>3）进行运算</p>
<p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p>
<p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p>
<p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。</p>
<h4 id="（47）-C-的四种强制转换"><a href="#（47）-C-的四种强制转换" class="headerlink" title="（47） C++的四种强制转换"></a>（47） C++的四种强制转换</h4><p>四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast</p>
<ul>
<li>1）static_cast ：<br>用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。<blockquote>
<p>特性与要点：</p>
<ol>
<li>它没有运行时类型检查，所以是有安全隐患的。</li>
<li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li>
<li>static_cast不能转换const，volatile等属性</li>
</ol>
</blockquote>
</li>
<li>2）dynamic_cast：<br>用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。<br>dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。<br>dynamic_cast如果不能转换返回NULL。</li>
<li>3）const_cast：<br>用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</li>
<li>4）reinterpret_cast<br>几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。<h4 id="（48）string的底层实现"><a href="#（48）string的底层实现" class="headerlink" title="（48）string的底层实现"></a>（48）string的底层实现</h4>string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。</li>
</ul>
<p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p>
<h4 id="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"><a href="#（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的" class="headerlink" title="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"></a>（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的</h4><p>预处理，编译，汇编，链接</p>
<ul>
<li>预处理： 对预处理命令进行替换等预处理操作</li>
<li>编译：代码优化和生成汇编代码</li>
<li>汇编：将汇编代码转化为机器语言</li>
<li>链接：将目标文件彼此链接起来<h4 id="（50）set，map和vector的插入复杂度"><a href="#（50）set，map和vector的插入复杂度" class="headerlink" title="（50）set，map和vector的插入复杂度"></a>（50）set，map和vector的插入复杂度</h4>set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。</li>
</ul>
<p>unordered_set,unordered_map的插入复杂度是常数，最坏是O(N).</p>
<p>vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝</p>
<h4 id="（51）定义和声明的区别"><a href="#（51）定义和声明的区别" class="headerlink" title="（51）定义和声明的区别"></a>（51）定义和声明的区别</h4><ul>
<li><p>声明是告诉编译器变量的类型和名字，不会为变量分配空间</p>
</li>
<li><p>定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次</p>
<h4 id="（52）typdef和define区别"><a href="#（52）typdef和define区别" class="headerlink" title="（52）typdef和define区别"></a>（52）typdef和define区别</h4></li>
</ul>
<p>define是预处理命令，在预处理是执行简单的替换，不做正确性的检查</p>
<p>typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名</p>
<h4 id="（53）被free回收的内存是立即返还给操作系统吗？为什么"><a href="#（53）被free回收的内存是立即返还给操作系统吗？为什么" class="headerlink" title="（53）被free回收的内存是立即返还给操作系统吗？为什么"></a>（53）被free回收的内存是立即返还给操作系统吗？为什么</h4><p><a href="https://blog.csdn.net/YMY_mine/article/details/81180168">https://blog.csdn.net/YMY_mine/article/details/81180168</a></p>
<p>不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p>
<h4 id="（54）引用作为函数参数以及返回值的好处"><a href="#（54）引用作为函数参数以及返回值的好处" class="headerlink" title="（54）引用作为函数参数以及返回值的好处"></a>（54）引用作为函数参数以及返回值的好处</h4><p>对比值传递，引用传参的好处：</p>
<p>1）在函数内部可以对此参数进行修改</p>
<p>2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</p>
<p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p>
<p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</p>
<p>但是有以下的限制：</p>
<p>1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</p>
<p>2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</p>
<p>3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 </p>
<h4 id="（55）友元函数和友元类"><a href="#（55）友元函数和友元类" class="headerlink" title="（55）友元函数和友元类"></a>（55）友元函数和友元类</h4><p><a href="https://www.cnblogs.com/zhuguanhao/p/6286145.html">https://www.cnblogs.com/zhuguanhao/p/6286145.html</a></p>
<p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p>
<p>1）友元函数</p>
<p>有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span></span>;      <span class="comment">//该函数是友元函数的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span>  <span class="comment">//友元函数定义，为了访问类A中的成员</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</p>
<p>2）友元类</p>
<p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。<br>但是另一个类里面也要相应的进行声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">C</span>;                         <span class="comment">//这是友元类的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>             <span class="comment">//友元类定义，为了访问类A中的成员</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span> </span>&#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span> c;</span><br><span class="line"></span><br><span class="line">    c.<span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用友元类时注意： </p>
<p>(1) 友元关系不能被继承。 </p>
<p>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 </p>
<p>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p>
<h4 id="（56）-说一下volatile关键字的作用"><a href="#（56）-说一下volatile关键字的作用" class="headerlink" title="（56） 说一下volatile关键字的作用"></a>（56） 说一下volatile关键字的作用</h4><p>volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。</p>
<h4 id="（57）-STL中的sort-算法是用什么实现的，stable-sort-呢"><a href="#（57）-STL中的sort-算法是用什么实现的，stable-sort-呢" class="headerlink" title="（57） STL中的sort()算法是用什么实现的，stable_sort()呢"></a>（57） STL中的sort()算法是用什么实现的，stable_sort()呢</h4><p>STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。</p>
<h4 id="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"><a href="#（58）vector会迭代器失效吗？什么情况下会迭代器失效？" class="headerlink" title="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"></a>（58）vector会迭代器失效吗？什么情况下会迭代器失效？</h4><p><a href="https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html">https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html</a></p>
<ul>
<li>会</li>
<li>当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效</li>
<li>当vector在插入的时候，end迭代器肯定会失效</li>
<li>当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。</li>
</ul>
<h4 id="（58）为什么C-没有实现垃圾回收？"><a href="#（58）为什么C-没有实现垃圾回收？" class="headerlink" title="（58）为什么C++没有实现垃圾回收？"></a>（58）为什么C++没有实现垃圾回收？</h4><ul>
<li>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。  </li>
<li>垃圾回收会使得C++不适合进行很多底层的操作。</li>
</ul>
<h1 id="2-计网相关"><a href="#2-计网相关" class="headerlink" title="2. 计网相关"></a>2. 计网相关</h1><h4 id="（1）-建立TCP服务器的各个系统调用"><a href="#（1）-建立TCP服务器的各个系统调用" class="headerlink" title="（1） 建立TCP服务器的各个系统调用"></a>（1） 建立TCP服务器的各个系统调用</h4><p>建立TCP服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。<br>详见：<a href="https://blog.csdn.net/qq_37964547/article/details/81429627">建立TCP 服务器的系统调用</a></p>
<h4 id="（2）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"><a href="#（2）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？" class="headerlink" title="（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"></a>（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？</h4><pre><code>socket()    创建套接字   
bind()      绑定本机端口    
connect()   建立连接     （TCP三次握手在调用这个函数时进行）
listen()    监听端口
accept()    接受连接
recv(), read(), recvfrom()  数据接收
send(), write(), sendto()   数据发送
close(), shutdown() 关闭套接字
</code></pre><p>使用close()时，只有当套接字的引用计数为0的时候才会终止连接，而用shutdown()就可以直接关闭连接</p>
<p>详见：<a href="https://blog.csdn.net/junjun150013652/article/details/37994907">网络编程Socket之TCP之close/shutdown详解</a></p>
<p>TCP连接与断开详解： <a href="https://www.cnblogs.com/felixzh/p/8359066.html">https://www.cnblogs.com/felixzh/p/8359066.html</a></p>
<h4 id="（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP"><a href="#（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP" class="headerlink" title="（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP."></a>（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP.</h4><ul>
<li><p>RIP“路由信息协议(Route Information Protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。RIP是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。</p>
</li>
<li><p>OSPF：详见：<a href="https://zhuanlan.zhihu.com/p/41341540">https://zhuanlan.zhihu.com/p/41341540</a></p>
</li>
</ul>
<h4 id="（4）-UDP如何实现可靠传输"><a href="#（4）-UDP如何实现可靠传输" class="headerlink" title="（4） UDP如何实现可靠传输"></a>（4） UDP如何实现可靠传输</h4><p>因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq/ack机制，重传机制和窗口确认机制。</p>
<p>就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。</p>
<p>作者：姚冬<br>链接：<a href="https://www.zhihu.com/question/283995548/answer/661809748">https://www.zhihu.com/question/283995548/answer/661809748</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h4 id="（5）-TCP和UDP的区别"><a href="#（5）-TCP和UDP的区别" class="headerlink" title="（5） TCP和UDP的区别"></a>（5） TCP和UDP的区别</h4><ul>
<li>TCP是面向连接的协议，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ACK对收发的数据进行正确性检验。而UDP是无连接的协议，不管对方有没有收到或者收到的数据是否正确。</li>
<li>TCP提供流量控制和拥塞控制，而UDP没有。</li>
<li>TCP对系统资源的要求高于UDP，所以速度也比UDP慢。</li>
<li>TCP数据包是没有边界的，会出现粘包的问题，UDP包是独立的，不会出现粘包问题。</li>
<li>所以在应用方面，如果强调数据的完整性和正确性用TCP，当要求性能和速度的时候，使用UDP更加合适。</li>
</ul>
<p>注：单凭TCP是不能保证完整性的，要是有黑客伪造TCP包，是无法识别的。</p>
<h4 id="（6）-TCP和UDP相关的协议与端口号"><a href="#（6）-TCP和UDP相关的协议与端口号" class="headerlink" title="（6） TCP和UDP相关的协议与端口号"></a>（6） TCP和UDP相关的协议与端口号</h4><p>TCP族的协议有HTTP，HTTPS，SMTP，TelNet，FTP等，UDP族的协议有DNS，DHCP等等。<br>详见：<a href="https://blog.csdn.net/qq_22080999/article/details/81105051">https://blog.csdn.net/qq_22080999/article/details/81105051</a></p>
<h4 id="（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）"><a href="#（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）" class="headerlink" title="（7） TCP（UDP，IP）等首部的认识（http请求报文构成）"></a>（7） TCP（UDP，IP）等首部的认识（http请求报文构成）</h4><p>TCP的头部大致包括：源端口，目的端口，序号，确认号，偏移位，标志位，校验和等等</p>
<p>UDP的头部则包括：源端口，目的端口，长度，校验和。</p>
<p>IP数据包的头部包括：源IP地址，目的IP地址，协议，校验和，总长度等等</p>
<p>详见：<a href="https://blog.csdn.net/zhangliangzi/article/details/52554439">https://blog.csdn.net/zhangliangzi/article/details/52554439</a></p>
<h4 id="（8）-网页解析的过程与实现方法"><a href="#（8）-网页解析的过程与实现方法" class="headerlink" title="（8） 网页解析的过程与实现方法"></a>（8） 网页解析的过程与实现方法</h4><p>这里仅展示浏览器解析服务器响应的过程，URL解析和交互的完整过程在(9)</p>
<ul>
<li>首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它由dom元素以及属性节点组成。</li>
<li>然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。</li>
<li>不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。</li>
<li>然后是css解析，将css文件解析为样式表对象来渲染DOM树。<h4 id="（9）-在浏览器中输入URL后执行的全部过程（如www-baidu-com）"><a href="#（9）-在浏览器中输入URL后执行的全部过程（如www-baidu-com）" class="headerlink" title="（9）    在浏览器中输入URL后执行的全部过程（如www.baidu.com）"></a>（9）    在浏览器中输入URL后执行的全部过程（如www.baidu.com）</h4></li>
</ul>
<ol>
<li>首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址；</li>
<li>然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接；</li>
<li>接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送）</li>
<li>服务器对客户端发来的http请求进行处理，并返回响应；</li>
<li>客户端接收到http响应，将结果渲染展示给用户。<h4 id="（10）-网络层分片的原因与具体实现"><a href="#（10）-网络层分片的原因与具体实现" class="headerlink" title="（10） 网络层分片的原因与具体实现"></a>（10） 网络层分片的原因与具体实现</h4>因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（MTU）就是1500字节。如果IP数据包加上头部后大小超过1500字节，就需要分片。</li>
</ol>
<p>IP分片和完整IP报文差不多拥有相同的IP头，16位ID域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了IP分片的所有信息(将在后面介绍)，接受方就可以利用这些信息对IP数据进行重新组织。<br>详见：<a href="https://blog.csdn.net/gettogetto/article/details/72851734">https://blog.csdn.net/gettogetto/article/details/72851734</a></p>
<h4 id="（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"><a href="#（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）" class="headerlink" title="（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"></a>（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）</h4><ul>
<li>三次握手</li>
</ul>
<p>第一次握手：首先client给server发送连接请求报文，在这个报文中，包含了SYN=1，client_seq=任意值i，发送之后处于SYN-SENT状态，这是第一次握手</p>
<p>第二次握手：server端接收到了这个请求，并分配资源，同时给client返回一个ACK报文，这个报文中呢包含了这些字段，标志位SYN和ACK都为1，而小ack为i+1，此时位于SYN-RCVD状态，这是第二次握手</p>
<p>第三次握手：client收到server发来的ACK信息后呢，他会看到server发过来的小ack是i+1，这时他知道了server收到了消息，也给server回一个ACK报文，报文中同样包含了ACK=1这样的消息，同时呢，还包括了client_ack=k+1这样的字段，这样呢三次握手之后，连接就建立了，client进入established（已建立连接）状态<br><img src="fig/三次握手.png" alt="三次握手.png"></p>
<ul>
<li>四次挥手断开连接：</li>
</ul>
<p>TCP断开连接通常是由一方主动，一方被动的，这里我们假设client主动，server被动<br>第一次挥手：当client没有数据要发送给server了，他会给server发送一个FIN报文，告诉server：“我已经没有数据要发给你了，但是你要是还想给我发数据的话，你就接着发，但是你得告诉我你收到我的关闭信息了”，这是第一次挥手，挥手之后client进入FIN_WAIT_1的第一阶段</p>
<p>第二次挥手：当server收到client发来的FIN报文后，告诉client：“我收到你的FIN消息了，但是你等我发完的”此时给client返回一个ACK信息，并且呢ack=seq+1，这是第二次挥手，挥手之后呢server进入CLOSE_WAIT阶段，而client收到之后处于FIN_WAIT_2第二阶段</p>
<p>第三次挥手：当server发完所有数据时，他会给client发送一个FIN报文，告诉client说“我传完数据了，现在要关闭连接了”，然后呢server变成LAST_ACK状态，等着client最后的ACK信息，这是第三次挥手</p>
<p>第四次挥手：当client收到这个FIN报文时，他会对这个消息进行确认，即给server发ACK信息，但是它不相信网络，怕server收不到信息，它会进入TIME_WAIT状态，万一server没收到ACK消息它可以可以重传，而当server收到这个ACK信息后，就正式关闭了tcp连接，处于CLOSED状态，而client等待了2MSL这样长时间后还没等到消息，它知道server已经关闭连接了，于是乎他自己也断开了，这是第四次挥手，这样tcp连接就断开了<br><img src="fig/四次挥手.png" alt="fig/四次挥手.png"></p>
<h4 id="（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态"><a href="#（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态" class="headerlink" title="（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态"></a>（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态</h4><p>见上</p>
<h4 id="（13）-为什么使用三次握手，两次握手可不可以？"><a href="#（13）-为什么使用三次握手，两次握手可不可以？" class="headerlink" title="（13） 为什么使用三次握手，两次握手可不可以？"></a>（13） 为什么使用三次握手，两次握手可不可以？</h4><p>如果使用两次握手的话，三次握手中的最后一次缺失，服务器不能确认客户端的接收能力。</p>
<p>举两个例子，第一种是黑客会伪造大量SYN请求发送给服务器，服务器立即确认并建立连接，分配资源，但是这一系列连接并不是真实存在的，这大大浪费了服务器的资源并且阻塞了正常用户的连接，这种也叫SYN洪泛攻击。第二种是服务器返回给客户端的ACK数据包可能会在传输的过程中丢失，而客户端没有收到该ACK数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁。</p>
<h4 id="（14）-TIME-WAIT的意义（为什么要等于2MSL）"><a href="#（14）-TIME-WAIT的意义（为什么要等于2MSL）" class="headerlink" title="（14） TIME_WAIT的意义（为什么要等于2MSL）"></a>（14） TIME_WAIT的意义（为什么要等于2MSL）</h4><p>TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。如果客户端发送的ACK发生丢失，服务器会再次发送FIN报文给客户端，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<h4 id="（15）-超时重传机制（不太高频）"><a href="#（15）-超时重传机制（不太高频）" class="headerlink" title="（15） 超时重传机制（不太高频）"></a>（15） 超时重传机制（不太高频）</h4><h4 id="（16）-TCP怎么保证可靠性？"><a href="#（16）-TCP怎么保证可靠性？" class="headerlink" title="（16） TCP怎么保证可靠性？"></a>（16） TCP怎么保证可靠性？</h4><p><strong>（校序重流拥）</strong></p>
<ul>
<li><p>校验和<br>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p>
</li>
<li><p>确认应答+序列号<br>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p>
</li>
<li><p>超时重传<br>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </p>
</li>
<li><p>流量控制<br>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。<br>接收方有即时窗口（滑动窗口），随ACK报文发送</p>
</li>
<li><p>拥塞控制<br>当网络拥塞时，减少数据的发送。<br>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</p>
</li>
</ul>
<p>慢启动、拥塞避免、快速重传、快速恢复 </p>
<h4 id="（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"><a href="#（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？" class="headerlink" title="（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"></a>（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？</h4><p>所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用TCP报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。</p>
<p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。</p>
<p>解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。</p>
<h4 id="（18）-tcp滑动窗口协议"><a href="#（18）-tcp滑动窗口协议" class="headerlink" title="（18） tcp滑动窗口协议"></a>（18） tcp滑动窗口协议</h4><p>详见 <a href="https://blog.csdn.net/wdscq1234/article/details/52444277">TCP-IP详解：滑动窗口SlidingWindow</a>和<a href="https://www.cnblogs.com/alifpga/p/7675850.html">TCP滑动窗口</a></p>
<p>TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。</p>
<p>接收方会在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。</p>
<h4 id="（19）-拥塞控制和流量控制的区别"><a href="#（19）-拥塞控制和流量控制的区别" class="headerlink" title="（19） 拥塞控制和流量控制的区别"></a>（19） 拥塞控制和流量控制的区别</h4><p>拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。</p>
<h4 id="（20）-TCP拥塞控制，算法名字？（极其重要）"><a href="#（20）-TCP拥塞控制，算法名字？（极其重要）" class="headerlink" title="（20） TCP拥塞控制，算法名字？（极其重要）"></a>（20） TCP拥塞控制，算法名字？（极其重要）</h4><p><img src="fig/拥塞控制.png" alt="拥塞控制"><br>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制自然也是控制发送者的流量，拥塞控制有四种算法，<strong>慢启动、拥塞避免，快速重传和快速恢复</strong></p>
<p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口和接受窗口的较小值。</p>
<p>（1）<strong>慢启动</strong>。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16<br>*为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd &gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法</p>
<p>（2）<strong>拥塞避免</strong>。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p>
<p>（3）<strong>快速重传</strong>。当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为原来一半，拥塞窗口cwnd变为ssth+3，然后+1+1的发（每一轮rtt+1）</p>
<p>（4）<strong>快速恢复</strong>。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd=1，进入慢启动阶段</p>
<h4 id="（21）-http协议与TCP的区别与联系"><a href="#（21）-http协议与TCP的区别与联系" class="headerlink" title="（21） http协议与TCP的区别与联系"></a>（21） http协议与TCP的区别与联系</h4><p>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</p>
<p>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。<br>建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。</p>
<h4 id="（22）-http-1-0和http-1-1的区别"><a href="#（22）-http-1-0和http-1-1的区别" class="headerlink" title="（22） http/1.0和http/1.1的区别"></a>（22） http/1.0和http/1.1的区别</h4><p>HTTP 协议老的标准是 HTTP/1.0 ，目前最通用的标准是 HTTP/1.1 。<br>HTTP1.0 只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http/1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive<br>HTTP 1.1 支持持久连接，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p>
<h4 id="（23）-http的请求方法有哪些？get和post的区别。"><a href="#（23）-http的请求方法有哪些？get和post的区别。" class="headerlink" title="（23） http的请求方法有哪些？get和post的区别。"></a>（23） http的请求方法有哪些？get和post的区别。</h4><p>HTTP的请求方法包括GET，POST，PUT，DELETE四种基本方法。（四种方法中只有POST不是操作幂等性的）</p>
<p>get和post的区别：</p>
<ol>
<li>get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源</li>
<li>get可以保存为书签，可以用缓存来优化，而post不可以</li>
<li>get把请求附在url上，而post把参数附在http包的包体中</li>
<li>浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等</li>
<li>post可以传输二进制编码的信息，get的参数一般只支持ASCII<h4 id="（24）-http的状态码-403-201等等是什么意思"><a href="#（24）-http的状态码-403-201等等是什么意思" class="headerlink" title="（24） http的状态码 403 201等等是什么意思"></a>（24） http的状态码 403 201等等是什么意思</h4>详见 <a href="https://blog.csdn.net/u011630575/article/details/46636535">HTTP状态码的含义</a></li>
</ol>
<p>常见的状态码有：</p>
<blockquote>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
<li>400 - 请求无效 </li>
<li>403 - 禁止访问 <h4 id="（25）-http和https的区别，由http升级为https需要做哪些操作"><a href="#（25）-http和https的区别，由http升级为https需要做哪些操作" class="headerlink" title="（25） http和https的区别，由http升级为https需要做哪些操作"></a>（25） http和https的区别，由http升级为https需要做哪些操作</h4>http 是超文本传输协议，信息是明文传输， https 则是具有安全性的 ssl 加密传输协议<br>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ，后者是 443<br>http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全。<br>https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用<br><a href="https://www.cnblogs.com/wqhwe/p/5407468.html">https://www.cnblogs.com/wqhwe/p/5407468.html</a></li>
</ul>
</blockquote>
<h4 id="（26）-https的具体实现，怎么确保安全性"><a href="#（26）-https的具体实现，怎么确保安全性" class="headerlink" title="（26） https的具体实现，怎么确保安全性"></a>（26） https的具体实现，怎么确保安全性</h4><p><strong>SSL是传输层的协议</strong></p>
<p>https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。</p>
<ol>
<li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接</li>
<li>Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。</li>
<li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li>
<li>Web服务器利用自己的私钥解密出会话密钥。</li>
<li>Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li>
</ol>
<p>服务器第一次传给客户端的公钥其实是CA对网站信息进行加密的数字证书</p>
<p>客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）</p>
<h4 id="（27）-TCP三次握手时的第一次的seq序号是怎样产生的"><a href="#（27）-TCP三次握手时的第一次的seq序号是怎样产生的" class="headerlink" title="（27） TCP三次握手时的第一次的seq序号是怎样产生的"></a>（27） TCP三次握手时的第一次的seq序号是怎样产生的</h4><p>第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。</p>
<p>seq = C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。</p>
<h4 id="（28）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"><a href="#（28）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？" class="headerlink" title="（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"></a>（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</h4><p>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16=65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p>
<p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p>
<h4 id="（29）-对称密码和非对称密码体系"><a href="#（29）-对称密码和非对称密码体系" class="headerlink" title="（29） 对称密码和非对称密码体系"></a>（29） 对称密码和非对称密码体系</h4><p><a href="https://blog.csdn.net/qq_29689487/article/details/81634057">https://blog.csdn.net/qq_29689487/article/details/81634057</a></p>
<ul>
<li>对称加密：加密和解密使用的密钥是同一个<ul>
<li>优点：计算量小，算法速度快，加密效率高  缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲</li>
<li>常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES</li>
</ul>
</li>
<li>非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密<ul>
<li>优点：安全，不怕泄漏  缺点：速度慢</li>
<li>常用算法：RSA，ECC，DSA<h4 id="（30）-数字证书的了解（高频）"><a href="#（30）-数字证书的了解（高频）" class="headerlink" title="（30） 数字证书的了解（高频）"></a>（30） 数字证书的了解（高频）</h4><img src="fig/数字证书.jpg" alt="fig/数字证书.jpg"></li>
</ul>
</li>
</ul>
<p>权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。公钥给客户端。</p>
<p>网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。</p>
<h4 id="（31）-服务器出现大量close-wait的连接的原因以及解决方法"><a href="#（31）-服务器出现大量close-wait的连接的原因以及解决方法" class="headerlink" title="（31） 服务器出现大量close_wait的连接的原因以及解决方法"></a>（31） 服务器出现大量close_wait的连接的原因以及解决方法</h4><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p>
<ul>
<li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li>
<li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li>
</ul>
<p>处理方法：</p>
<ul>
<li>停止应用程序</li>
<li>修改程序里的bug<h4 id="（32）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"><a href="#（32）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）" class="headerlink" title="（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"></a>（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）</h4></li>
<li><p>消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等</p>
</li>
<li><p>MD5算法介绍：<br>MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，算法输出由四个散列值（32位分组组成的128位散列值。）</p>
</li>
</ul>
<ol>
<li>MD5首先将输入的信息分成若干个512字节长度的分组，如果不够就填充1和若干个0。</li>
<li>对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。</li>
<li>接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。</li>
<li>遍历所有分组后得到的四个变量即为结果。</li>
</ol>
<p>详见：<a href="https://blog.csdn.net/weixin_39640298/article/details/84555814">https://blog.csdn.net/weixin_39640298/article/details/84555814</a></p>
<ul>
<li><p>为什么不可逆：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，所以不能由结果进行恢复。</p>
</li>
<li><p>加强安全性：加盐（加随机数）</p>
<h4 id="（33）-单条记录高并发访问的优化"><a href="#（33）-单条记录高并发访问的优化" class="headerlink" title="（33） 单条记录高并发访问的优化"></a>（33） 单条记录高并发访问的优化</h4><p>服务器端：</p>
</li>
<li>使用缓存，如redis等</li>
<li>使用分布式架构进行处理</li>
<li>将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回</li>
<li>将静态资源尽可能在客户端进行缓存</li>
<li>采用ngnix进行负载均衡 （nginx读作恩静埃克斯 = Engine X）</li>
</ul>
<p>数据库端：</p>
<ul>
<li>数据库采用主从赋值，读写分离措施</li>
<li>建立适当的索引</li>
<li>分库分表<h4 id="（34）-介绍一下ping的过程，分别用到了哪些协议"><a href="#（34）-介绍一下ping的过程，分别用到了哪些协议" class="headerlink" title="（34） 介绍一下ping的过程，分别用到了哪些协议"></a>（34） 介绍一下ping的过程，分别用到了哪些协议</h4>详见：<a href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html">Ping原理与ICMP协议</a></li>
</ul>
<p>ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议</p>
<ul>
<li>首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。</li>
<li>然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。</li>
<li>然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。</li>
</ul>
<p>目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。</p>
<h4 id="（35）-TCP-IP的粘包与避免介绍一下"><a href="#（35）-TCP-IP的粘包与避免介绍一下" class="headerlink" title="（35） TCP/IP的粘包与避免介绍一下"></a>（35） TCP/IP的粘包与避免介绍一下</h4><p>因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。</p>
<p>导致TCP粘包的原因有三方面：</p>
<ul>
<li>发送端等待缓冲区满才进行发送，造成粘包</li>
<li>接收方来不及接收缓冲区内的数据，造成粘包</li>
<li>由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</li>
</ul>
<p>避免粘包的措施：</p>
<ul>
<li>通过编程，强制使TCP发生数据传送，不必等到缓冲区满</li>
<li>优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等</li>
<li>设置固定长度的报文或者设置报文头部指示报文的长度。</li>
</ul>
<h4 id="（36）-说一下TCP的封包和拆包"><a href="#（36）-说一下TCP的封包和拆包" class="headerlink" title="（36） 说一下TCP的封包和拆包"></a>（36） 说一下TCP的封包和拆包</h4><p>因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul>
<li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li>
<li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。<h4 id="（37）-一个ip配置多个域名，靠什么识别？"><a href="#（37）-一个ip配置多个域名，靠什么识别？" class="headerlink" title="（37） 一个ip配置多个域名，靠什么识别？"></a>（37） 一个ip配置多个域名，靠什么识别？</h4></li>
<li>靠host主机名区分</li>
<li>靠端口号区分<h4 id="（38）-服务器攻击（DDos攻击）"><a href="#（38）-服务器攻击（DDos攻击）" class="headerlink" title="（38） 服务器攻击（DDos攻击）"></a>（38） 服务器攻击（DDos攻击）</h4><h4 id="（39）DNS的工作过程和原理"><a href="#（39）DNS的工作过程和原理" class="headerlink" title="（39）DNS的工作过程和原理"></a>（39）DNS的工作过程和原理</h4><img src="fig/DNS查询图解.png" alt=""><br>DNS解析有两种方式：递归查询和迭代查询</li>
<li>递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。</li>
<li>迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果<h4 id="（41）OSA七层协议和五层协议，分别有哪些"><a href="#（41）OSA七层协议和五层协议，分别有哪些" class="headerlink" title="（41）OSA七层协议和五层协议，分别有哪些"></a>（41）OSA七层协议和五层协议，分别有哪些</h4>OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</li>
</ul>
<p>五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。</p>
<p><img src="fig/网络协议层.png" alt="(fig/网络协议层.png"></p>
<h4 id="（42）IP寻址和MAC寻址有什么不同，怎么实现的"><a href="#（42）IP寻址和MAC寻址有什么不同，怎么实现的" class="headerlink" title="（42）IP寻址和MAC寻址有什么不同，怎么实现的"></a>（42）IP寻址和MAC寻址有什么不同，怎么实现的</h4><p>通过MAC地址寻找主机是MAC地址寻址，通过IP地址寻找主机叫IP地址寻址。它们适用于不同的协议层，IP寻址是网络层，Mac寻址是数据链路层。</p>
<p><a href="http://c.biancheng.net/view/6388.html">http://c.biancheng.net/view/6388.html</a></p>
<p><a href="https://blog.csdn.net/wxy_nick/article/details/9190693">https://blog.csdn.net/wxy_nick/article/details/9190693</a></p>
<p>IP寻址的过程（ARP协议）：主机A想通过IP地址寻找到目标主机，首先分析IP地址确定目标主机与自己是否为同一网段。如果是则查看ARP缓存，或者使用ARP协议发送广播。如果不是，则寻找网关发送ARP数据包</p>
<h1 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3. 数据库"></a>3. 数据库</h1><h4 id="（1）-关系型和非关系型数据库的区别（低频）"><a href="#（1）-关系型和非关系型数据库的区别（低频）" class="headerlink" title="（1） 关系型和非关系型数据库的区别（低频）"></a>（1） 关系型和非关系型数据库的区别（低频）</h4><ul>
<li>关系型数据库的优点<ol>
<li>容易理解。因为它采用了关系模型来组织数据。</li>
<li>可以保持数据的一致性。</li>
<li>数据更新的开销比较小。</li>
<li>支持复杂查询（带where子句的查询）</li>
</ol>
</li>
<li>非关系型数据库的优点<ol>
<li>不需要经过sql层的解析，读写效率高。</li>
<li>基于键值对，数据的扩展性很好。</li>
<li>可以支持多种类型数据的存储，如图片，文档等等。<h4 id="（2）-什么是非关系型数据库（低频）"><a href="#（2）-什么是非关系型数据库（低频）" class="headerlink" title="（2） 什么是非关系型数据库（低频）"></a>（2） 什么是非关系型数据库（低频）</h4>非关系型数据库也叫nosql，采用键值对的形式进行存储。它的读写性能很高，易于扩展。例如Redis,Mongodb,hbase等等。</li>
</ol>
</li>
</ul>
<p>适合使用非关系型数据库的场景：</p>
<ul>
<li>日志系统</li>
<li>地理位置存储</li>
<li>数据量巨大</li>
<li>高可用<h4 id="（3）-说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#（3）-说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="（3） 说一下 MySQL 执行一条查询语句的内部执行过程？"></a>（3） 说一下 MySQL 执行一条查询语句的内部执行过程？</h4></li>
<li>连接器：客户端先通过连接器连接到 MySQL 服务器。</li>
<li>缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</li>
<li>分析器：分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</li>
<li>优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</li>
<li>执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。<h4 id="（4）-数据库的索引类型"><a href="#（4）-数据库的索引类型" class="headerlink" title="（4） 数据库的索引类型"></a>（4） 数据库的索引类型</h4>数据库的索引类型分为逻辑分类和物理分类<br><br>逻辑分类：</li>
<li>主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。</li>
<li>唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。</li>
<li>普通索引 一张表可以有多个普通索引，可以重复可以为空值</li>
<li>全文索引 可以加快模糊查询，不常用</li>
</ul>
<p>物理分类：</p>
<ul>
<li>聚集索引（聚簇索引） 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。</li>
<li>非聚集索引 数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据。<h4 id="（5）-说一下事务是怎么实现的"><a href="#（5）-说一下事务是怎么实现的" class="headerlink" title="（5） 说一下事务是怎么实现的"></a>（5） 说一下事务是怎么实现的</h4><a href="https://blog.csdn.net/u013256816/article/details/103966510">https://blog.csdn.net/u013256816/article/details/103966510</a></li>
</ul>
<p><a href="https://www.cnblogs.com/takumicx/p/9998844.html">https://www.cnblogs.com/takumicx/p/9998844.html</a></p>
<p>事务就是一组逻辑操作的集合。实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的。</p>
<ul>
<li>日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的<strong>持久性</strong>。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的<strong>原子性</strong>。</li>
<li>并发控制：并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的<strong>隔离性</strong>。MVCC通过为数据添加时间戳来实现。</li>
</ul>
<h4 id="（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"><a href="#（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？" class="headerlink" title="（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"></a>（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</h4><p>MySQL建立索引有两种方式：用alter table或者create index。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add primary key(column_list) #添加一个主键索引</span><br><span class="line">alter table table_name add index (column_list)      #添加一个普通索引</span><br><span class="line">alter table table_name add unique (column_list)     #添加一个唯一索引</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name (column_list)   #创建一个普通索引</span><br><span class="line">create unique index_name on table_name (column_list)  #创建一个唯一索引</span><br></pre></td></tr></table></figure></p>
<p>Mysql删除索引同样也有两种方式：alter table 和 drop index<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name drop index index_name    #删除一个普通索引</span><br><span class="line">alter table table_name drop primary key         #删除一个主键索引</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name on table table_name</span><br></pre></td></tr></table></figure></p>
<h4 id="（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"><a href="#（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）" class="headerlink" title="（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"></a>（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</h4><p><a href="https://www.cnblogs.com/wezheng/p/8399305.html">https://www.cnblogs.com/wezheng/p/8399305.html</a></p>
<ul>
<li>经常搜索的列上建索引</li>
<li>作为主键的列上要建索引</li>
<li>经常需要连接（where子句）的列上</li>
<li>经常需要排序的列</li>
<li>经常需要范围查找的列</li>
</ul>
<p>哪些列不适合建索引？</p>
<ul>
<li>很少查询的列</li>
<li>更新很频繁的列</li>
<li>数据值的取值比较少的列（比如性别）<h4 id="（8）-索引的底层实现（重点）"><a href="#（8）-索引的底层实现（重点）" class="headerlink" title="（8） 索引的底层实现（重点）"></a>（8） 索引的底层实现（重点）</h4>数据库的索引是使用B+树来实现的。</li>
</ul>
<p>（为什么要用B+树，为什么不用红黑树和B树）<br><br>B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。</p>
<p>而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。</p>
<h4 id="（9）-B树和B-树的区别（重点）"><a href="#（9）-B树和B-树的区别（重点）" class="headerlink" title="（9） B树和B+树的区别（重点）"></a>（9） B树和B+树的区别（重点）</h4><p><img src="./fig/Bptree.png" alt="./fig/Bptree.png"></p>
<p>这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。</p>
<ol>
<li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。</li>
<li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li>
<li>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</li>
<li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li>
</ol>
<p>B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。</p>
<h4 id="（10）-索引最左前缀-最左匹配"><a href="#（10）-索引最左前缀-最左匹配" class="headerlink" title="（10） 索引最左前缀/最左匹配"></a>（10） 索引最左前缀/最左匹配</h4><p>假如我们对a b c三个字段建立了联合索引，在联合索引中，从最左边的字段开始，任何连续的索引都能匹配上，当遇到范围查询的时候停止。比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引。并且对查询时字段的顺序没有限制，也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配。</p>
<h4 id="（11）-Mysql的优化（高频，索引优化，性能优化）"><a href="#（11）-Mysql的优化（高频，索引优化，性能优化）" class="headerlink" title="（11） Mysql的优化（高频，索引优化，性能优化）"></a>（11） Mysql的优化（高频，索引优化，性能优化）</h4><p>高频访问：</p>
<ul>
<li>分表分库：将数据库表进行水平拆分，减少表的长度</li>
<li>增加缓存： 在web和DB之间加上一层缓存层</li>
<li>增加数据库的索引：在合适的字段加上索引，解决高频访问的问题</li>
</ul>
<p>并发优化：</p>
<ul>
<li>主从读写分离：只在主服务器上写，从服务器上读</li>
<li>负载均衡集群：通过集群或者分布式的方式解决并发压力<h4 id="（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别"><a href="#（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别" class="headerlink" title="（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别"></a>（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别</h4></li>
<li>InnoDB ： InnoDB是mysql的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表  行级锁</li>
<li>MyISAM ： 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用  表级锁</li>
<li>MEMORY ： memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景</li>
<li>CSV</li>
<li>blackhole<h4 id="（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"><a href="#（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）" class="headerlink" title="（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"></a>（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</h4>数据库事务是指逻辑上对数据的一种操作，这个事务要么全部成功，要么全部失败。</li>
</ul>
<p><strong>A: atom 原子性</strong><br><br>数据库事务的原子性是指：事务是一个不可分割的工作单位，这组操作要么全部发生，要么全部不发生。</p>
<p><strong>C: consistency 一致性</strong><br><br>数据库事务的一致性是指：在事务开始以前，数据库中的数据有一个一致的状态。在事务完成后，数据库中的事务也应该保持这种一致性。事务应该将数据从一个一致性状态转移到另一个一致性状态。<br>比如在银行转账操作后两个账户的总额应当不变。</p>
<p><strong>I: isolation 隔离性</strong><br><br>数据库事务的隔离性要求数据库中的事务不会受另一个并发执行的事务的影响，对于数据库中同时执行的每个事务来说，其他事务要么还没开始执行，要么已经执行结束，它都感觉不到还有别的事务正在执行。</p>
<p><strong>D：durability 持久性</strong><br><br>数据库事务的持久性要求事务对数据库的改变是永久的，哪怕数据库发生损坏都不会影响到已发生的事务。<br>如果事务没有完成，数据库因故断电了，那么重启后也应该是没有执行事务的状态，如果事务已经完成后数据库断电了，那么重启后就应该是事务执行完成后的状态。</p>
<h4 id="（14）什么是脏读，不可重复读和幻读？"><a href="#（14）什么是脏读，不可重复读和幻读？" class="headerlink" title="（14）什么是脏读，不可重复读和幻读？"></a>（14）什么是脏读，不可重复读和幻读？</h4><p>详见<a href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a></p>
<ul>
<li><p>脏读：脏读是指一个事务在处理过程中读取了另一个还没提交的事务的数据。</p>
<blockquote>
<p>比如A向B转账100，A的账户减少了100，而B的账户还没来得及修改，此时一个并发的事务访问到了B的账户，就是脏读</p>
</blockquote>
</li>
<li>不可重复读：不可重复读是对于数据库中的某一个字段，一个事务多次查询却返回了不同的值，这是由于在查询的间隔中，该字段被另一个事务修改并提交了。<blockquote>
<p>比如A第一次查询自己的账户有1000元，此时另一个事务给A的账户增加了1000元，所以A再次读取他的账户得到了2000的结果，跟第一次读取的不一样。<br>不可重复读与脏读的不同之处在于，脏读是读取了另一个事务没有提交的脏数据，不可重复读是读取了已经提交的数据，实际上并不是一个异常现象。</p>
</blockquote>
</li>
<li>幻读：事务多次读取同一个范围的时候，查询结果的记录数不一样，这是由于在查询的间隔中，另一个事务新增或删除了数据。<blockquote>
<p>比如A公司一共有100个人，第一次查询总人数得到100条记录，此时另一个事务新增了一个人，所以下一次查询得到101条记录。<br>不可重复度和幻读的不同之处在于，幻读是多次读取的结果行数不同，不可重复度是读取结果的值不同。</p>
</blockquote>
</li>
</ul>
<p>避免不可重复读需要锁行，避免幻读则需要锁表。</p>
<p>脏读，不可重复读和幻读都是数据库的读一致性问题，是在并行的过程中出现的问题，必须采用一定的隔离级别解决。<br>详见<a href="https://www.cnblogs.com/Hakuna-Matata/p/7772794.html">脏读、不可重复读和幻读的区别</a></p>
<h4 id="（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"><a href="#（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）" class="headerlink" title="（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"></a>（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</h4><p>详见<a href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a>和<a href="https://blog.csdn.net/fg2006/article/details/6937413">数据库隔离级别</a></p>
<p>为了保证数据库事务一致性，解决脏读，不可重复读和幻读的问题，数据库的隔离级别一共有四种隔离级别：</p>
<ul>
<li>读未提交 Read Uncommitted: 最低级别的隔离，不能解决以上问题</li>
<li>读已提交 Read committed:   可以避免脏读的发生 </li>
<li>可重复读 Reapeatable read:  确保事务可以多次从一个字段中读取相同的值，在该事务执行期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读。 通过锁行来实现 </li>
<li>串行化 Serializaion  最严格的事务隔离机制，要求所有事务被串行执行，可以避免以上所有问题。 通过锁表来实现</li>
</ul>
<p>Oracle的默认隔离级别是<strong>读已提交</strong>，实现了四种隔离级别中的读已提交和串行化隔离级别</p>
<p>MySQL的默认隔离级别是<strong>可重复读</strong>，并且实现了所有四种隔离级别</p>
<h4 id="（16）-数据库连接池的作用"><a href="#（16）-数据库连接池的作用" class="headerlink" title="（16） 数据库连接池的作用"></a>（16） 数据库连接池的作用</h4><h4 id="（17）-Mysql的表空间方式，各自特点"><a href="#（17）-Mysql的表空间方式，各自特点" class="headerlink" title="（17） Mysql的表空间方式，各自特点"></a>（17） Mysql的表空间方式，各自特点</h4><ul>
<li>共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 </li>
<li><p>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； 缺点：mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题</p>
<h4 id="（18）-分布式事务"><a href="#（18）-分布式事务" class="headerlink" title="（18） 分布式事务"></a>（18） 分布式事务</h4><h4 id="（19）-数据库的范式"><a href="#（19）-数据库的范式" class="headerlink" title="（19） 数据库的范式"></a>（19） 数据库的范式</h4><p><a href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</a></p>
</li>
<li><p><strong>第一范式(确保每列保持原子性)</strong><br><br>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
</li>
</ul>
<blockquote>
<p>比如 学生 选课（包括很多课程） 就不符合第一范式</p>
<ul>
<li><strong>第二范式(确保表中的每列都和主键相关)</strong><br><br>在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。 </li>
</ul>
<p>比如一张学生信息表，由主键（学号）可以唯一确定一个学生的姓名，班级，年龄等信息。但是主键 （学号，班级） 与列 姓名，班主任，教室 就不符合第二范式，因为班主任跟部分主键（班级）是依赖关系</p>
<ul>
<li><strong>第三范式(确保非主键的列没有传递依赖)</strong><br><br>在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。</li>
</ul>
<p>比如一张学生信息表，主键是（学号）列包括 姓名，班级，班主任 就不符合第三范式，因为非主键的列中 班主任 依赖于 班级</p>
<ul>
<li><strong>BCNF范式（确保主键之间没有传递依赖）</strong><br><br>主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。<h4 id="（20）-数据的锁的种类，加锁的方式"><a href="#（20）-数据的锁的种类，加锁的方式" class="headerlink" title="（20） 数据的锁的种类，加锁的方式"></a>（20） 数据的锁的种类，加锁的方式</h4>以MYSQL为例，</li>
<li>按照类型来分有乐观锁和悲观锁</li>
<li>根据粒度来分有行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁）</li>
<li>根据作用来分有共享锁（读锁）和排他锁（写锁）。<h4 id="（21）-什么是共享锁和排他锁"><a href="#（21）-什么是共享锁和排他锁" class="headerlink" title="（21） 什么是共享锁和排他锁"></a>（21） 什么是共享锁和排他锁</h4></li>
<li>共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。</li>
<li>排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）</li>
</ul>
</blockquote>
<p>  <a href="https://blog.csdn.net/qq_42743933/article/details/81236658">https://blog.csdn.net/qq_42743933/article/details/81236658</a></p>
<h4 id="（22）-分库分表的理解和简介"><a href="#（22）-分库分表的理解和简介" class="headerlink" title="（22） 分库分表的理解和简介"></a>（22） 分库分表的理解和简介</h4><h4 id="（23）"><a href="#（23）" class="headerlink" title="（23）"></a>（23）</h4><h4 id="（24）数据库高并发的解决方案"><a href="#（24）数据库高并发的解决方案" class="headerlink" title="（24）数据库高并发的解决方案"></a>（24）数据库高并发的解决方案</h4><ol>
<li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li>
<li>增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li>
<li>主从读写分离，让主服务器负责写，从服务器负责读。</li>
<li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li>
<li>使用分布式架构，分散计算压力。<h4 id="（25）乐观锁与悲观锁解释一下"><a href="#（25）乐观锁与悲观锁解释一下" class="headerlink" title="（25）乐观锁与悲观锁解释一下"></a>（25）乐观锁与悲观锁解释一下</h4>一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。</li>
</ol>
<p>悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。</p>
<h4 id="（26）乐观锁与悲观锁是怎么实现的"><a href="#（26）乐观锁与悲观锁是怎么实现的" class="headerlink" title="（26）乐观锁与悲观锁是怎么实现的"></a>（26）乐观锁与悲观锁是怎么实现的</h4><p>悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。</p>
<p>悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。</p>
<p>乐观锁有三种常用的实现形式：</p>
<ul>
<li>一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。</li>
<li>一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。</li>
<li>最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似。</li>
</ul>
<h1 id="4-Linux"><a href="#4-Linux" class="headerlink" title="4. Linux"></a>4. Linux</h1><h4 id="（1）-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"><a href="#（1）-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）" class="headerlink" title="（1） Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"></a>（1） Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</h4><p><a href="https://blog.csdn.net/sqsltr/article/details/92762279">https://blog.csdn.net/sqsltr/article/details/92762279</a></p>
<p><a href="https://www.cnblogs.com/euphie/p/6376508.html">https://www.cnblogs.com/euphie/p/6376508.html</a></p>
<p>（IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据）</p>
<ul>
<li>阻塞：调用IO操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到IO可用并完成数据拷贝。</li>
<li>非阻塞：调用IO操作的时候，内核会马上返回结果，如果IO不可用，会返回错误，这种方式下进程需要不断轮询直到IO可用为止，但是当进程从内核拷贝数据时是阻塞的。</li>
<li>IO多路复用就是同时监听多个描述符，一旦某个描述符IO就绪（读就绪或者写就绪），就能够通知进程进行相应的IO操作，否则就将进程阻塞在select或者epoll语句上。</li>
</ul>
<ul>
<li>同步IO：同步IO模型包括阻塞IO，非阻塞IO和IO多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。</li>
<li>异步IO：在检测IO是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当IO完成后内核会给进程发送一个信号。<h4 id="（2）-文件系统的理解（EXT4，XFS，BTRFS）"><a href="#（2）-文件系统的理解（EXT4，XFS，BTRFS）" class="headerlink" title="（2） 文件系统的理解（EXT4，XFS，BTRFS）"></a>（2） 文件系统的理解（EXT4，XFS，BTRFS）</h4></li>
</ul>
<h4 id="（3）-EPOLL的介绍和了解"><a href="#（3）-EPOLL的介绍和了解" class="headerlink" title="（3） EPOLL的介绍和了解"></a>（3） EPOLL的介绍和了解</h4><p><a href="https://zhuanlan.zhihu.com/p/56486633">https://zhuanlan.zhihu.com/p/56486633</a> </p>
<p><a href="https://www.jianshu.com/p/397449cadc9a">https://www.jianshu.com/p/397449cadc9a</a></p>
<p><a href="https://blog.csdn.net/davidsguo008/article/details/73556811">https://blog.csdn.net/davidsguo008/article/details/73556811</a></p>
<p>Epoll是Linux进行IO多路复用的一种方式，用于在一个线程里监听多个IO源，在IO源可用的时候返回并进行操作。它的特点是基于事件驱动，性能很高。</p>
<p>epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间，由用户程序进行处理。</p>
<p>Epoll有三个系统调用：epoll_create(),epoll_ctl()和epoll_wait()。</p>
<ul>
<li><p>eoll_create()函数在内核中初始化一个eventpoll对象，同时初始化红黑树和就绪链表。</p>
</li>
<li><p>epoll_ctl()用来对监听的文件描述符进行管理。将文件描述符插入红黑树，或者从红黑树中删除，这个过程的时间复杂度是log(N)。同时向内核注册文件描述符的回调函数。</p>
</li>
<li><p>epoll_wait()会将进程放到eventpoll的等待队列中，将进程阻塞，当某个文件描述符IO可用时，内核通过回调函数将该文件描述符放到就绪链表里，epoll_wait()会将就绪链表里的文件描述符返回到用户空间。</p>
<h4 id="（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？"><a href="#（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？" class="headerlink" title="（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？"></a>（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</h4><p>（1）select的方法介绍：select把所有监听的文件描述符拷贝到内核中，挂起进程。当某个文件描述符可读或可写的时候，中断程序唤起进程，select将监听的文件描述符再次拷贝到用户空间，然select后遍历这些文件描述符找到IO可用的文件。下次监控的时候需要再次拷贝这些文件描述符到内核空间。select支持监听的描述符最大数量是1024.<br><img src="fig/select.png" alt="select"><br>（2）poll使用链表保存文件描述符，其他的跟select没有什么不同。</p>
</li>
</ul>
<p>（3）epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间。<br><img src="fig/epoll.png" alt="epoll"><br>详见 <a href="https://www.cnblogs.com/Anker/p/3265058.html">https://www.cnblogs.com/Anker/p/3265058.html</a></p>
<h4 id="（5）-Epoll的ET模式和LT模式（ET的非阻塞）"><a href="#（5）-Epoll的ET模式和LT模式（ET的非阻塞）" class="headerlink" title="（5） Epoll的ET模式和LT模式（ET的非阻塞）"></a>（5） Epoll的ET模式和LT模式（ET的非阻塞）</h4><ul>
<li>ET是边缘触发模式，在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。</li>
<li>LT是水平触发模式，在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。</li>
</ul>
<h4 id="（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"><a href="#（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）" class="headerlink" title="（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"></a>（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）</h4><p>详见：<a href="https://blog.csdn.net/qq_36357820/article/details/76606113">https://blog.csdn.net/qq_36357820/article/details/76606113</a></p>
<ol>
<li>top命令查看linux负载：</li>
<li>uptime查看linux负载</li>
<li>w查看linux负载：</li>
<li>vmstat查看linux负载<h4 id="（7）-linux的其他常见命令（kill，find，cp等等）"><a href="#（7）-linux的其他常见命令（kill，find，cp等等）" class="headerlink" title="（7） linux的其他常见命令（kill，find，cp等等）"></a>（7） linux的其他常见命令（kill，find，cp等等）</h4><h4 id="（8）-shell脚本用法"><a href="#（8）-shell脚本用法" class="headerlink" title="（8） shell脚本用法"></a>（8） shell脚本用法</h4><h4 id="（9）-硬连接和软连接的区别"><a href="#（9）-硬连接和软连接的区别" class="headerlink" title="（9） 硬连接和软连接的区别"></a>（9） 硬连接和软连接的区别</h4><h4 id="（10）-文件权限怎么看（rwx）"><a href="#（10）-文件权限怎么看（rwx）" class="headerlink" title="（10） 文件权限怎么看（rwx）"></a>（10） 文件权限怎么看（rwx）</h4><h4 id="（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变"><a href="#（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变" class="headerlink" title="（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变"></a>（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</h4><h4 id="（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"><a href="#（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令" class="headerlink" title="（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"></a>（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</h4><h4 id="（13）Linux中线程的同步方式有哪些？"><a href="#（13）Linux中线程的同步方式有哪些？" class="headerlink" title="（13）Linux中线程的同步方式有哪些？"></a>（13）Linux中线程的同步方式有哪些？</h4><h4 id="（14）怎么修改一个文件的权限"><a href="#（14）怎么修改一个文件的权限" class="headerlink" title="（14）怎么修改一个文件的权限"></a>（14）怎么修改一个文件的权限</h4>chmod 777  (177 277 477 等，权限组合是 1 2 4，分别代表r x w )</li>
</ol>
<h4 id="（15）查看文件内容常用命令"><a href="#（15）查看文件内容常用命令" class="headerlink" title="（15）查看文件内容常用命令"></a>（15）查看文件内容常用命令</h4><p>详见： <a href="http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html">http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html</a></p>
<ol>
<li>cat 与 tac<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat的功能是将文件从第一行开始连续的将内容输出在屏幕上。当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。所以通常使用重定向的方式，输出满足指定格式的内容</span><br><span class="line"></span><br><span class="line">cat语法：cat [-n]  文件名 （-n ： 显示时，连行号一起输出）</span><br><span class="line"></span><br><span class="line">tac的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，tac实际上是cat反过来写。这个命令不常用。</span><br><span class="line"></span><br><span class="line">tac语法：tac 文件名。</span><br></pre></td></tr></table></figure></li>
<li>more和less（常用）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如:ls -al | more</span><br><span class="line"></span><br><span class="line">more的语法：more 文件名</span><br><span class="line"></span><br><span class="line">Enter 向下n行，需要定义，默认为1行； </span><br><span class="line"></span><br><span class="line">Ctrl f 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">空格键 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">Ctrl b 返回上一屏； </span><br><span class="line"></span><br><span class="line">= 输出当前行的行号； </span><br><span class="line"></span><br><span class="line">:f 输出文件名和当前行的行号； </span><br><span class="line"></span><br><span class="line">v 调用vi编辑器； </span><br><span class="line"></span><br><span class="line">! 命令 调用Shell，并执行命令； </span><br><span class="line"></span><br><span class="line">q 退出more</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">less的功能和more相似，但是使用more无法向前翻页，只能向后翻。</span><br><span class="line"></span><br><span class="line">less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。</span><br><span class="line"></span><br><span class="line">less的语法：less 文件名</span><br></pre></td></tr></table></figure></li>
<li>head和tail<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">head和tail通常使用在只需要读取文件的前几行或者后几行的情况下使用。head的功能是显示文件的前几行内容</span><br><span class="line"></span><br><span class="line">head的语法：head [n number] 文件名 (number 显示行数)</span><br><span class="line"></span><br><span class="line">tail的功能恰好和head相反，只显示最后几行内容</span><br><span class="line"></span><br><span class="line">tail的语法:tail [-n number] 文件名</span><br></pre></td></tr></table></figure></li>
<li>nl<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl的功能和cat -n一样，同样是从第一行输出全部内容，并且把行号显示出来</span><br><span class="line"></span><br><span class="line">nl的语法：nl 文件名</span><br></pre></td></tr></table></figure></li>
<li>vim</li>
</ol>
<p>这个用的太普遍了，主要是用于编辑。</p>
<h4 id="（16）怎么找出含有关键字的前后4行"><a href="#（16）怎么找出含有关键字的前后4行" class="headerlink" title="（16）怎么找出含有关键字的前后4行"></a>（16）怎么找出含有关键字的前后4行</h4><h4 id="（17）Linux的GDB调试"><a href="#（17）Linux的GDB调试" class="headerlink" title="（17）Linux的GDB调试"></a>（17）Linux的GDB调试</h4><h4 id="（18）coredump是什么-怎么才能coredump"><a href="#（18）coredump是什么-怎么才能coredump" class="headerlink" title="（18）coredump是什么 怎么才能coredump"></a>（18）coredump是什么 怎么才能coredump</h4><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
<p>coredump产生的条件</p>
<ol>
<li>shell资源控制限制，使用 ulimit -c 命令查看shell执行程序时的资源 ，如果为0，则不会产生coredump。可以用ulimit -c unlimited设置为不限大小。</li>
<li>读写越界，包括：数组访问越界，指针指向错误的内存，字符串读写越界</li>
<li>使用了线程不安全的函数，读写未加锁保护</li>
<li>错误使用指针转换</li>
<li>堆栈溢出<h4 id="（19）tcpdump常用命令"><a href="#（19）tcpdump常用命令" class="headerlink" title="（19）tcpdump常用命令"></a>（19）tcpdump常用命令</h4>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</li>
</ol>
<p>实用命令实例</p>
<p>将某端口收发的数据包保存到文件<br><br><code>sudo tcpdump -i any port 端口 -w 文件名.cap</code></p>
<p>打印请求到屏幕<br><br><code>sudo tcpdump -i any port 端口 -Xnlps0</code></p>
<p>默认启动<br><br><code>tcpdump</code><br>普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。<br>监视指定网络接口的数据包<br><br><code>tcpdump -i eth1</code><br>如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络接口。　</p>
<h4 id="（20）-crontab命令"><a href="#（20）-crontab命令" class="headerlink" title="（20） crontab命令"></a>（20） crontab命令</h4><p>详见：<a href="https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html">https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html</a></p>
<p>corntab命令是用来指定用户计划任务的。用户将需要定时执行的任务写入crontab文件中，提交给crond进程定期执行。</p>
<ul>
<li><p>crontab命令用来对crontab文件进行管理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1．命令格式：</span><br><span class="line">crontab [-u user] file</span><br><span class="line">crontab [-u user] [ -e | -l | -r ]</span><br><span class="line">2．命令功能：</span><br><span class="line">通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</span><br><span class="line">3．命令参数：</span><br><span class="line">-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</span><br><span class="line">file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</span><br><span class="line">-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</span><br><span class="line">-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</span><br><span class="line">-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</span><br><span class="line">-i：在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure>
</li>
<li><p>crontab文件内容</p>
</li>
</ul>
<p>crond是Linux下的周期性执行系统任务的守护进程，他会根据/etc下的crontab配置文件的内容执行。用户需要将计划任务写入crontab文件中才能执行。</p>
<p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minute   hour   day   month   week   command</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>minute： 表示分钟，可以是从0到59之间的任何整数。</li>
<li>hour：表示小时，可以是从0到23之间的任何整数。</li>
<li>day：表示日期，可以是从1到31之间的任何整数。</li>
<li>month：表示月份，可以是从1到12之间的任何整数。</li>
<li>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</li>
<li>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</li>
</ul>
<p>在以上各个字段中，还可以使用以下特殊字符：</p>
<ul>
<li>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</li>
<li>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</li>
<li>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</li>
<li>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</li>
</ul>
<h4 id="（21）-查看后台进程"><a href="#（21）-查看后台进程" class="headerlink" title="（21） 查看后台进程"></a>（21） 查看后台进程</h4><ul>
<li>jobs</li>
</ul>
<p>查看当前控制台的后台进程</p>
<p>想要停止后台进程，使用jobs命令查看其进程号（比如为num），然后kill %num即可</p>
<ul>
<li>ps</li>
</ul>
<p>查看后台进程</p>
<ul>
<li>top</li>
</ul>
<p>查看所有进程和资源使用情况，类似Windows中的任务管理器</p>
<p>停止进程：界面是交互式的，在窗口输入k 之后输入PID，会提示输入停止进程模式 有SIGTERM和 SIGKILL 如果留空不输入，就是SIGTERM（优雅停止）</p>
<p>退出top：输入q即可</p>
<h1 id="5-操作系统"><a href="#5-操作系统" class="headerlink" title="5. 操作系统"></a>5. 操作系统</h1><h4 id="（1）-进程与线程的区别和联系（重点）"><a href="#（1）-进程与线程的区别和联系（重点）" class="headerlink" title="（1） 进程与线程的区别和联系（重点）"></a>（1） 进程与线程的区别和联系（重点）</h4><ul>
<li>区别</li>
</ul>
<ol>
<li>进程是对运行时程序的封装，是系统进行资源分配和调度的基本单元，而线程是进程的子任务，是CPU分配和调度的基本单元。</li>
<li>一个进程可以有多个线程，但是一个线程只能属于一个进程。</li>
<li>进程的创建需要系统分配内存和CPU，文件句柄等资源，销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。</li>
<li>进程之间不会相互影响；而一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。</li>
</ol>
<ul>
<li>联系 进程与线程之间的关系：线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。<h4 id="（2）-Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"><a href="#（2）-Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关" class="headerlink" title="（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"></a>（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</h4>答：32768. 因为进程的pid是用pid_t来表示的，pid_t的最大值是32768.所以理论上最多有32768个进程。</li>
</ul>
<p>至于线程。进程最多可以创建的线程数是根据分配给调用栈的大小，以及操作系统（32位和64位不同）共同决定的。Linux32位下是300多个。</p>
<h4 id="（3）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"><a href="#（3）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）" class="headerlink" title="（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"></a>（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</h4><ul>
<li>存储器：内存</li>
<li>控制器：南桥北桥</li>
<li>运算器：CPU</li>
<li>输入设备：键盘</li>
<li><p>输出设备：显示器、网卡</p>
<h4 id="（4）-进程之间的通信方法有哪几种-（重点）"><a href="#（4）-进程之间的通信方法有哪几种-（重点）" class="headerlink" title="（4） 进程之间的通信方法有哪几种 （重点）"></a>（4） 进程之间的通信方法有哪几种 （重点）</h4><p>进程之间的通信方式主要有六种，包括<strong>管道，信号量，消息队列，信号，共享内存，套接字</strong>。</p>
</li>
<li><p>管道：管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的<br><img src="fig/管道通信.png" alt="fig/管道通信.png"></p>
<p>匿名管道pipe和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。</p>
<p>管道的底层实现 <a href="https://segmentfault.com/a/1190000009528245">https://segmentfault.com/a/1190000009528245</a></p>
</li>
<li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。</p>
</li>
<li><p>信号：信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的</p>
</li>
<li><p>共享内存：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。</p>
</li>
<li><p>消息队列：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。<br>消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。<br>可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p>
</li>
<li><p>套接字：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p>
<h4 id="（5）-进程调度方法详细介绍"><a href="#（5）-进程调度方法详细介绍" class="headerlink" title="（5） 进程调度方法详细介绍"></a>（5） 进程调度方法详细介绍</h4><p><a href="https://blog.csdn.net/u011080472/article/details/51217754">https://blog.csdn.net/u011080472/article/details/51217754</a></p>
</li>
</ul>
<p><a href="https://blog.csdn.net/leex_brave/article/details/51638300">https://blog.csdn.net/leex_brave/article/details/51638300</a></p>
<ul>
<li>先来先服务 （FCFS first come first serve）：按照作业到达任务队列的顺序调度  FCFS是非抢占式的，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性）而不利于短作业（I/O繁忙性）。</li>
<li>短作业优先 （SHF short job first）：每次从队列里选择预计时间最短的作业运行。SJF是非抢占式的，优先照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。但是不利于长作业，长作业可能一直处于等待状态，出现饥饿现象；完全未考虑作业的优先紧迫程度，不能用于实时系统。</li>
<li>最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。该算法确保一旦新的短作业或短进程进入系统，能够很快得到处理。</li>
<li>高响应比优先调度算法（Highest Reponse Ratio First, HRRF）是非抢占式的，主要用于作业调度。基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。响应比 = （等待时间 + 服务时间） / 服务时间 = 等待时间 / 服务时间 + 1。因为每次都需要计算响应比，所以比较耗费系统资源。</li>
<li>时间片轮转 用于分时系统的进程调度。基本思想：系统将CPU处理时间划分为若干个时间片（q），进程按照到达先后顺序排列。每次调度选择队首的进程，执行完1个时间片q后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。该算法能在给定的时间内响应所有用户的而请求，达到分时系统的目的。</li>
<li>多级反馈队列(Multilevel Feedback Queue) <h4 id="（6）-进程的执行过程是什么样的，执行一个进程需要做哪些工作？"><a href="#（6）-进程的执行过程是什么样的，执行一个进程需要做哪些工作？" class="headerlink" title="（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？"></a>（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？</h4>进程的执行需要经过三大步骤：编译，链接和装入。</li>
<li>编译：将源代码编译成若干模块</li>
<li>链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接）</li>
<li>装入：将模块装入内存运行</li>
</ul>
<p><a href="https://blog.csdn.net/qq_38623623/article/details/78306498">https://blog.csdn.net/qq_38623623/article/details/78306498</a></p>
<p>将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。</p>
<p>通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。</p>
<h4 id="（6）-操作系统的内存管理说一下"><a href="#（6）-操作系统的内存管理说一下" class="headerlink" title="（6） 操作系统的内存管理说一下"></a>（6） 操作系统的内存管理说一下</h4><p><a href="https://www.cnblogs.com/peterYong/p/6556619.html">https://www.cnblogs.com/peterYong/p/6556619.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/141602175">https://zhuanlan.zhihu.com/p/141602175</a></p>
<p>操作系统的内存管理包括物理内存管理和虚拟内存管理</p>
<ul>
<li>物理内存管理包括交换与覆盖，分页管理，分段管理和段页式管理等；</li>
<li>虚拟内存管理包括虚拟内存的概念，页面置换算法，页面分配策略等；</li>
</ul>
<p>（面试官这样问的时候，其实是希望你能讲讲虚拟内存）</p>
<h4 id="（7）-实现一个LRU算法"><a href="#（7）-实现一个LRU算法" class="headerlink" title="（7） 实现一个LRU算法"></a>（7） 实现一个LRU算法</h4><p>用到两个数据结构：哈希+双向链表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; &gt; cache ;<span class="comment">// 存放键，迭代器</span></span><br><span class="line">list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; auxlist; <span class="comment">// 存放 &lt;键，值&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; l;<span class="comment">// front:new back:old 存放值 新的放前面，因为前面的可以取得有效的迭代器</span></span><br><span class="line">    map&lt;<span class="type">int</span>,list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;::iterator &gt; cache;<span class="comment">// 存放键，迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        cap=capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> mapitera = cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(mapitera==cache.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// found</span></span><br><span class="line">            list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::iterator listItera = mapitera-&gt;second;</span><br><span class="line">            <span class="type">int</span> value = (*listItera).second;</span><br><span class="line"></span><br><span class="line">            l.<span class="built_in">erase</span>(listItera);</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> itera = cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(itera!=cache.<span class="built_in">end</span>())&#123;<span class="comment">// exist</span></span><br><span class="line">            list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::iterator listItera = itera-&gt;second;</span><br><span class="line"></span><br><span class="line">            l.<span class="built_in">erase</span>(listItera);</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// not exist</span></span><br><span class="line">            <span class="keyword">if</span>(cache.<span class="built_in">size</span>()&gt;=cap)&#123;</span><br><span class="line">                pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; oldpair = l.<span class="built_in">back</span>();</span><br><span class="line">                l.<span class="built_in">pop_back</span>();</span><br><span class="line">                cache.<span class="built_in">erase</span>(oldpair.first);</span><br><span class="line">            &#125;</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="（8）-死锁产生的必要条件（怎么检测死锁，解决死锁问题）"><a href="#（8）-死锁产生的必要条件（怎么检测死锁，解决死锁问题）" class="headerlink" title="（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）"></a>（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）</h4><p>（1） 互斥：一个资源每次只能被一个进程使用。<br><br>（2） 占有并请求：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br><br>（3） 不可剥夺:进程已获得的资源，在末使用完之前，不能强行剥夺。<br><br>（4） 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系。<br></p>
<p>产生死锁的原因主要是：<br><br>（1） 因为系统资源不足。<br><br>（2） 进程运行推进的顺序不合适。<br><br>（3） 资源分配不当等。<br></p>
<h4 id="（8）-死锁的恢复"><a href="#（8）-死锁的恢复" class="headerlink" title="（8） 死锁的恢复"></a>（8） 死锁的恢复</h4><ol>
<li>重新启动：是最简单、最常用的死锁消除方法，但代价很大，因为在此之前所有进程已经完成的计算工作都将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程。</li>
<li>终止进程(process termination)：终止参与死锁的进程并回收它们所占资源。<br> (1) 一次性全部终止；(2) 逐步终止(优先级，代价函数)</li>
<li>剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源。<br> (1) 逐步剥夺：一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止。<br> (2) 一次剥夺：一次性地剥夺死锁进程所占有的全部资源。</li>
<li>进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大：<br> (1) 要实现“回退”，必须“记住”以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间。<br> (2) 一个回退的进程应当“挽回”它在回退点之间所造成的影响，如修改某一文件，给其它进程发送消息等，这些在实现时是难以做到的</li>
</ol>
<h4 id="（8）什么是饥饿"><a href="#（8）什么是饥饿" class="headerlink" title="（8）什么是饥饿"></a>（8）什么是饥饿</h4><p>饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而不能继续执行时，就会发生饥饿现象。</p>
<h4 id="（9）-如果要你实现一个mutex互斥锁你要怎么实现？"><a href="#（9）-如果要你实现一个mutex互斥锁你要怎么实现？" class="headerlink" title="（9） 如果要你实现一个mutex互斥锁你要怎么实现？"></a>（9） 如果要你实现一个mutex互斥锁你要怎么实现？</h4><p><a href="https://blog.csdn.net/kid551/article/details/84338619">https://blog.csdn.net/kid551/article/details/84338619</a></p>
<p>实现mutex最重要的就是实现它的lock()方法和unlock()方法。我们保存一个全局变量flag，flag=1表明该锁已经锁住，flag=0表明锁没有锁住。<br>实现lock()时，使用一个while循环不断检测flag是否等于1，如果等于1就一直循环。然后将flag设置为1；unlock()方法就将flag置为0；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;flag,<span class="number">1</span>)==<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//flag=1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为while有可能被重入，所以可以用TestandSet()方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> old = *ptr;</span><br><span class="line">    *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？"><a href="#（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？" class="headerlink" title="（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？"></a>（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？</h4><p>线程之间通信：</p>
<ul>
<li>使用全局变量</li>
<li>使用信号机制</li>
<li>使用事件</li>
</ul>
<p>进程之间同步：<br><a href="https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html">https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html</a></p>
<ul>
<li>信号量</li>
<li><p>管程</p>
<h4 id="（13）-什么时候用多进程，什么时候用多线程"><a href="#（13）-什么时候用多进程，什么时候用多线程" class="headerlink" title="（13） 什么时候用多进程，什么时候用多线程"></a>（13） 什么时候用多进程，什么时候用多线程</h4><p><a href="https://blog.csdn.net/yu876876/article/details/82810178">https://blog.csdn.net/yu876876/article/details/82810178</a></p>
</li>
<li><p>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></p>
</li>
<li>计算量：需要大量计算的优先使用<strong>多线程</strong>  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</li>
<li>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</li>
<li>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</li>
</ul>
<p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p>
<h4 id="（14）-文件读写使用的系统调用"><a href="#（14）-文件读写使用的系统调用" class="headerlink" title="（14） 文件读写使用的系统调用"></a>（14） 文件读写使用的系统调用</h4><h4 id="（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？"><a href="#（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？" class="headerlink" title="（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？"></a>（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？</h4><p><a href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p>
<ul>
<li>孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。</li>
<li>僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。<h4 id="（16）-说一下PCB-说一下进程地址空间"><a href="#（16）-说一下PCB-说一下进程地址空间" class="headerlink" title="（16） 说一下PCB/说一下进程地址空间/"></a>（16） 说一下PCB/说一下进程地址空间/</h4><a href="https://blog.csdn.net/qq_38499859/article/details/80057427">https://blog.csdn.net/qq_38499859/article/details/80057427</a></li>
</ul>
<p>PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。</p>
<p>PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息</p>
<p><img src="https://img-blog.csdn.net/20140904215636015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd6aGVianV0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>进程地址空间内有：</p>
<ul>
<li>代码段text：存放程序的二进制代码</li>
<li>初始化的数据Data：已经初始化的变量和数据</li>
<li>未初始化的数据BSS：还没有初始化的数据</li>
<li>栈</li>
<li>堆<h4 id="（17）-内核空间和用户空间是怎样区分的"><a href="#（17）-内核空间和用户空间是怎样区分的" class="headerlink" title="（17） 内核空间和用户空间是怎样区分的"></a>（17） 内核空间和用户空间是怎样区分的</h4>在Linux中虚拟地址空间范围为0到4G，最高的1G地址（0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间，低的3G空间（0x00000000到0xBFFFFFFF）供各个进程使用，就是用户空间。</li>
</ul>
<p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。</p>
<h4 id="（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"><a href="#（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）" class="headerlink" title="（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"></a>（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）</h4><p><a href="https://blog.csdn.net/s_lisheng/article/details/74278765">https://blog.csdn.net/s_lisheng/article/details/74278765</a></p>
<ul>
<li>临界区</li>
<li>信号量</li>
<li>事件</li>
<li>互斥量<h4 id="（19）-同一个进程内的线程会共享什么资源？"><a href="#（19）-同一个进程内的线程会共享什么资源？" class="headerlink" title="（19） 同一个进程内的线程会共享什么资源？"></a>（19） 同一个进程内的线程会共享什么资源？</h4></li>
<li>该进程的地址空间</li>
<li>全局变量</li>
<li>堆空间</li>
</ul>
<p>线程的栈空间是自己独有的</p>
<h4 id="（20）-异常和中断的区别"><a href="#（20）-异常和中断的区别" class="headerlink" title="（20） 异常和中断的区别"></a>（20） 异常和中断的区别</h4><h4 id="（21）-一般情况下在Linux-windows平台下栈空间的大小"><a href="#（21）-一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="（21） 一般情况下在Linux/windows平台下栈空间的大小"></a>（21） 一般情况下在Linux/windows平台下栈空间的大小</h4><p>在Linux下栈空间通常是8M，Windows下是1M</p>
<h4 id="（22）虚拟内存的了解"><a href="#（22）虚拟内存的了解" class="headerlink" title="（22）虚拟内存的了解"></a>（22）虚拟内存的了解</h4><p><a href="https://www.cnblogs.com/Przz/p/6876988.html">https://www.cnblogs.com/Przz/p/6876988.html</a></p>
<p>在运行一个进程的时候，它所需要的内存空间可能大于系统的物理内存容量。通常一个进程会有4G的空间，但是物理内存并没有这么大，所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。<br>当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。</p>
<h4 id="（23）服务器高并发的解决方案"><a href="#（23）服务器高并发的解决方案" class="headerlink" title="（23）服务器高并发的解决方案"></a>（23）服务器高并发的解决方案</h4><ol>
<li><p>应用数据与静态资源分离<br>将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</p>
</li>
<li><p>客户端缓存<br>因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</p>
</li>
<li><p>集群和分布式<br>（集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br><br>（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br><br>可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</p>
</li>
<li><p>反向代理<br>在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</p>
<h4 id="（24）协程了解吗（高频）"><a href="#（24）协程了解吗（高频）" class="headerlink" title="（24）协程了解吗（高频）"></a>（24）协程了解吗（高频）</h4><p>协程和微线程是一个东西。</p>
</li>
</ol>
<p>协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。<br>这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。</p>
<h4 id="（25）那协程的底层是怎么实现的，怎么使用协程？"><a href="#（25）那协程的底层是怎么实现的，怎么使用协程？" class="headerlink" title="（25）那协程的底层是怎么实现的，怎么使用协程？"></a>（25）那协程的底层是怎么实现的，怎么使用协程？</h4><p>协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p>
<h4 id="（23）进程的状态以及转换图"><a href="#（23）进程的状态以及转换图" class="headerlink" title="（23）进程的状态以及转换图"></a>（23）进程的状态以及转换图</h4><ul>
<li>三态模型<br>三态模型包括三种状态：<ol>
<li>执行：进程分到CPU时间片，可以执行</li>
<li>就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行</li>
<li>阻塞：有IO事件或者等待其他资源<br><img src="fig/三态模型.png" alt=""></li>
</ol>
</li>
<li><p>五态模型</p>
<ol>
<li>新建态：进程刚刚创建。</li>
<li>就绪态：</li>
<li>运行态：</li>
<li>等待态：出现等待事件</li>
<li>终止态：进程结束<br><img src="fig/五态模型.png" alt=""></li>
</ol>
</li>
<li><p>七态模型</p>
<ol>
<li>新建态</li>
<li>就绪挂起态</li>
<li>就绪态</li>
<li>运行态</li>
<li>等待态</li>
<li>挂起等待态</li>
<li>终止态<br><img src="fig/七态模型.png" alt=""></li>
</ol>
</li>
</ul>
<h4 id="（24）在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的？"><a href="#（24）在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的？" class="headerlink" title="（24）在执行malloc申请内存的时候，操作系统是怎么做的？/内存分配的原理说一下/malloc函数底层是怎么实现的？/进程是怎么分配内存的？"></a>（24）在执行malloc申请内存的时候，操作系统是怎么做的？/内存分配的原理说一下/malloc函数底层是怎么实现的？/进程是怎么分配内存的？</h4><p><a href="https://blog.csdn.net/yusiguyuan/article/details/39496057">https://blog.csdn.net/yusiguyuan/article/details/39496057</a></p>
<p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p>
<ul>
<li>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</li>
<li>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li>
</ul>
<p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p>
<p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p>
<h4 id="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"><a href="#（25）什么是字节序？怎么判断是大端还是小端？有什么用？" class="headerlink" title="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"></a>（25）什么是字节序？怎么判断是大端还是小端？有什么用？</h4><p><a href="https://www.cnblogs.com/broglie/p/5645200.html">https://www.cnblogs.com/broglie/p/5645200.html</a></p>
<p>字节序是对象在内存中存储的方式，大端即为最高有效位在前面，小端即为最低有效位在前面。<br>判断大小端的方法：使用一个union数据结构<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="type">short</span> s;</span><br><span class="line">  <span class="type">char</span> c[<span class="number">2</span>]; <span class="comment">// sizeof(short)=2;</span></span><br><span class="line">&#125;un;</span><br><span class="line">un.s=<span class="number">0x0102</span>;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">1</span> <span class="keyword">and</span> un.c[<span class="number">1</span>]==<span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;大端&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">2</span> <span class="keyword">and</span> un.c[<span class="number">1</span>]==<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;小端&quot;</span>;</span><br></pre></td></tr></table></figure><br>在网络编程中不同字节序的机器发送和接收的顺序不同。</p>
<h1 id="6-场景题-算法题"><a href="#6-场景题-算法题" class="headerlink" title="6. 场景题/算法题"></a>6. 场景题/算法题</h1><h4 id="（0）-leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！"><a href="#（0）-leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！" class="headerlink" title="（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！"></a>（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</h4><p>面试中90%的算法题都从leetcode hot100和剑指offer中出 刷两遍非常有必要</p>
<h4 id="（1）-介绍熟悉的设计模式（单例，简单工厂模式）"><a href="#（1）-介绍熟悉的设计模式（单例，简单工厂模式）" class="headerlink" title="（1） 介绍熟悉的设计模式（单例，简单工厂模式）"></a>（1） 介绍熟悉的设计模式（单例，简单工厂模式）</h4><h4 id="（2）-写单例模式，线程安全版本"><a href="#（2）-写单例模式，线程安全版本" class="headerlink" title="（2） 写单例模式，线程安全版本"></a>（2） 写单例模式，线程安全版本</h4><figure class="highlight c++"><figcaption><span>version</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">      <span class="comment">// initialize</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance==<span class="literal">nullptr</span>) instance=<span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="（3）-写三个线程交替打印ABC"><a href="#（3）-写三个线程交替打印ABC" class="headerlink" title="（3） 写三个线程交替打印ABC"></a>（3） 写三个线程交替打印ABC</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mymutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">0</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 1: a&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 1 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">1</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 2: b&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">2</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 2 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">2</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 3: c&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 3 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(printa)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(printb)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th3</span><span class="params">(printc)</span></span>;</span><br><span class="line"></span><br><span class="line">    th<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    th<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    th<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; main thread &quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（4）-二维码登录的实现过程-场景题"><a href="#（4）-二维码登录的实现过程-场景题" class="headerlink" title="（4） 二维码登录的实现过程 场景题"></a>（4） 二维码登录的实现过程 场景题</h4><p><img src="fig/二维码登录流程.png" alt=""></p>
<h4 id="（5）-不使用临时变量实现swap函数"><a href="#（5）-不使用临时变量实现swap函数" class="headerlink" title="（5） 不使用临时变量实现swap函数"></a>（5） 不使用临时变量实现swap函数</h4><ul>
<li>使用异或/加减等方式，下面给出使用异或的实现方法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">  a=a^b;</span><br><span class="line">  b=a^b;</span><br><span class="line">  a=a^b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"><a href="#（6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢" class="headerlink" title="（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"></a>（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</h4><h4 id="（7）-实现快排"><a href="#（7）-实现快排" class="headerlink" title="（7） 实现快排"></a>（7） 实现快排</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec,<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    vec[a]=vec[a]^vec[b];</span><br><span class="line">    vec[b]=vec[a]^vec[b];</span><br><span class="line">    vec[a]=vec[a]^vec[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=vec[start+(end-start)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end <span class="keyword">and</span> vec[start]&lt;pivot) start++;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end <span class="keyword">and</span> vec[end]&gt;pivot) end--;</span><br><span class="line">        <span class="keyword">if</span>(start&lt;end) <span class="built_in">swap</span>(vec,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pivot=<span class="built_in">partition</span>(vec,start,end);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec,start,pivot<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec,pivot<span class="number">+1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（8）-实现一个堆排序"><a href="#（8）-实现一个堆排序" class="headerlink" title="（8） 实现一个堆排序"></a>（8） 实现一个堆排序</h4>堆排序的基本过程：</li>
<li>将n个元素的序列构建一个大顶堆或小顶堆</li>
<li>将堆顶的元素放到序列末尾</li>
<li>将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</li>
</ul>
<p>整体时间复杂度为nlogn<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    arr[a]=arr[a]^arr[b];</span><br><span class="line">    arr[b]=arr[a]^arr[b];</span><br><span class="line">    arr[a]=arr[a]^arr[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> len,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxid=index;</span><br><span class="line">    <span class="comment">// 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2</span></span><br><span class="line">    <span class="type">int</span> left=<span class="number">2</span>*index<span class="number">+1</span>,right=<span class="number">2</span>*index<span class="number">+2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找当前以index为根的子树中最大/最小的元素的下标</span></span><br><span class="line">    <span class="keyword">if</span>(left&lt;len <span class="keyword">and</span> arr[left]&lt;arr[maxid]) maxid=left;</span><br><span class="line">    <span class="keyword">if</span>(right&lt;len <span class="keyword">and</span> arr[right]&lt;arr[maxid]) maxid=right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行交换，记得要递归进行adjust,传入的index是maxid</span></span><br><span class="line">    <span class="keyword">if</span>(maxid!=index)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr,maxid,index);</span><br><span class="line">        <span class="built_in">adjust</span>(arr,len,maxid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(len<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">adjust</span>(arr,len,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr,<span class="number">0</span>,i);</span><br><span class="line">        <span class="built_in">adjust</span>(arr,i,<span class="number">0</span>);<span class="comment">// 注意每次adjust是从根往下调整，所以这里index是0！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;before: &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> item:arr) cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">heapsort</span>(arr,arr.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;after: &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> item:arr)cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="（8）-实现一个插入排序"><a href="#（8）-实现一个插入排序" class="headerlink" title="（8） 实现一个插入排序"></a>（8） 实现一个插入排序</h4><p><a href="https://blog.csdn.net/left_la/article/details/8656425">https://blog.csdn.net/left_la/article/details/8656425</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="type">int</span> key=nums[i];</span><br><span class="line">    <span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[j]&gt;key)&#123;</span><br><span class="line">      nums[j<span class="number">+1</span>]=nums[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j<span class="number">+1</span>]=key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（9）-快排存在的问题，如何优化"><a href="#（9）-快排存在的问题，如何优化" class="headerlink" title="（9） 快排存在的问题，如何优化"></a>（9） 快排存在的问题，如何优化</h4><ul>
<li>3 种快排基准选择方法：</li>
</ul>
<p>随机（rand函数）、固定（队首、队尾）、三数取中（队首、队中和队尾的中间数）</p>
<ul>
<li>4种优化方式：</li>
</ul>
<p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序</p>
<p>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p>
<p>优化3：优化递归操作</p>
<p>优化4：使用并行或多线程处理子序列</p>
<h4 id="（10）-反转一个链表（招银网络二面）"><a href="#（10）-反转一个链表（招银网络二面）" class="headerlink" title="（10） 反转一个链表（招银网络二面）"></a>（10） 反转一个链表（招银网络二面）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* root)</span></span>&#123;</span><br><span class="line">  ListNode* pre=<span class="literal">nullptr</span>,cur=root,nxt;</span><br><span class="line">  <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    nxt=cur-&gt;next;</span><br><span class="line">    cur-&gt;next=pre;</span><br><span class="line">    pre=cur;cur=nxt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（11）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）"><a href="#（11）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）" class="headerlink" title="（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）"></a>（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）</h4><p><em>Top K 问题的常见形式：</em></p>
<blockquote>
<p>给定10000个整数，找第K大（第K小）的数<br><br> 给定10000个整数，找出最大（最小）的前K个数<br><br>给定100000个单词，求前K词频的单词<br></p>
</blockquote>
<p><em>解决Top K问题若干种方法</em></p>
<ul>
<li>使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。</li>
<li>Quick Select算法。使用类似快排的思路，根据pivot划分数组。</li>
<li>使用排序方法，排序后再寻找top K元素。</li>
<li>使用选择排序的思想，对前K个元素部分排序。</li>
<li>将1000…..个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数。</li>
</ul>
<ol>
<li>使用最大最小堆的思路 （以top K 最大元素为例）<br><br>按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</li>
</ol>
<blockquote>
<p>note：最小堆的插入时间复杂度为log(n)，n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p>
</blockquote>
<p>C++中的最大最小堆要用标准库的priority_queue来实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> v, <span class="type">int</span> i): <span class="built_in">value</span>(v), <span class="built_in">idx</span>(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) &#123;</span><br><span class="line">    <span class="keyword">return</span> n<span class="number">1.</span>value &lt; n<span class="number">2.</span>value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; pq; <span class="comment">// 此时pq为最大堆</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用Quick Select的思路（以寻找第K大的元素为例）<br><br>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的：<br>首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。<br>此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作；<br>如果左边的数组元素个数等于K-1，则第K大的数就是pivot；<br>如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</li>
</ol>
<p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//此为Java实现</span><br><span class="line">public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">  return quickSelect(nums, k, 0, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// quick select to find the kth-largest element</span><br><span class="line">public int quickSelect(int[] arr, int k, int left, int right) &#123;</span><br><span class="line">  if (left == right) return arr[right];</span><br><span class="line">  int index = partition(arr, left, right);</span><br><span class="line">  if (index - left + 1 &gt; k)</span><br><span class="line">    return quickSelect(arr, k, left, index - 1);</span><br><span class="line">  else if (index - left + 1 == k)</span><br><span class="line">    return arr[index];</span><br><span class="line">  else</span><br><span class="line">    return quickSelect(arr, k - (index - left + 1), index + 1, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）<br><br>扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K)<h4 id="（12）-8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"><a href="#（12）-8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）" class="headerlink" title="（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"></a>（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）</h4>我们可以使用外部排序来对它进行处理。首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行m路归并排序。取这m份数据的最小元素，进行排序，输出排序后最小的元素到结果中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。</li>
</ol>
<p><a href="https://blog.csdn.net/ailunlee/article/details/84548950">https://blog.csdn.net/ailunlee/article/details/84548950</a></p>
<h4 id="（13）-自己构建一棵二叉树，使用带有null标记的前序遍历序列"><a href="#（13）-自己构建一棵二叉树，使用带有null标记的前序遍历序列" class="headerlink" title="（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列"></a>（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列</h4><p>在写二叉树相关算法的时候，如果需要自己构造测试用例（自己构造一棵二叉树），往往是一件很麻烦的事情，我们可以用一个带有null标记的前序遍历序列来进行构造。 <strong>需要注意的是vec2tree()参数中的start是引用传递，而不是简单的参数值传递</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">treeNode</span>&#123;</span><br><span class="line">    string val;</span><br><span class="line">    treeNode* left,*right;</span><br><span class="line">    <span class="built_in">treeNode</span>(string val):<span class="built_in">val</span>(val)&#123;</span><br><span class="line">        left=<span class="literal">nullptr</span>;</span><br><span class="line">        right=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">treeNode* <span class="title">vec2tree</span><span class="params">(vector&lt;string&gt;&amp; vec,<span class="type">int</span>&amp; start)</span></span>&#123;</span><br><span class="line">    treeNode* root;</span><br><span class="line">    <span class="keyword">if</span>(vec[start]==<span class="string">&quot;null&quot;</span>)&#123;</span><br><span class="line">        start+=<span class="number">1</span>;</span><br><span class="line">        root=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root=<span class="keyword">new</span> <span class="built_in">treeNode</span>(vec[start]);</span><br><span class="line">        start+=<span class="number">1</span>;</span><br><span class="line">        root-&gt;left=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">        root-&gt;right=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree2vec</span><span class="params">(treeNode *root,vector&lt;string&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;left,vec);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;right,vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec=&#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>,&amp;start=index;</span><br><span class="line">    treeNode* root=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">    <span class="comment">//displaytree(root);</span></span><br><span class="line">    vector&lt;string&gt; mvec;</span><br><span class="line">    <span class="built_in">tree2vec</span>(root,mvec);</span><br><span class="line">    <span class="keyword">for</span>(string item:mvec) cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="（14）-介绍一下b树和它的应用场景有哪些"><a href="#（14）-介绍一下b树和它的应用场景有哪些" class="headerlink" title="（14） 介绍一下b树和它的应用场景有哪些"></a>（14） 介绍一下b树和它的应用场景有哪些</h4><p>B树也叫做B-树，或者平衡多路树，它是每个节点最多有m个子树的<strong>平衡树</strong>。一个m阶的B树具有如下几个特征：</p>
<ol>
<li>根结点至少有两个子女。</li>
<li>每个中间节点都包含至多m个子树 ， 每个节点包含的元素个数是其子树个数-1（其中 m/2 &lt;= k &lt;= m）</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个子树包含的元素的值域分划。</li>
</ol>
<p>b树主要应用于文件系统中，在数据库中（mongoDB）也有应用，与B+树相比好处应该是有时不需要访问到叶节点就可以获取数据。</p>
<p>查询时间复杂度是logN</p>
<h4 id="（15）-介绍一下b-树和它的应用场景有哪些"><a href="#（15）-介绍一下b-树和它的应用场景有哪些" class="headerlink" title="（15） 介绍一下b+树和它的应用场景有哪些"></a>（15） 介绍一下b+树和它的应用场景有哪些</h4><p>B+树是一种特殊的B树，它把数据都存储在叶子节点，并且叶节点间有指针连接。内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点。</p>
<p>应用场景主要是数据库的索引</p>
<p>查询时间复杂度也是logN<br><a href="https://zhuanlan.zhihu.com/p/110202102">https://zhuanlan.zhihu.com/p/110202102</a></p>
<p><a href="https://blog.csdn.net/hguisu/article/details/7786014">https://blog.csdn.net/hguisu/article/details/7786014</a></p>
<h4 id="（16）-介绍一下红黑树和它的应用场景有哪些"><a href="#（16）-介绍一下红黑树和它的应用场景有哪些" class="headerlink" title="（16） 介绍一下红黑树和它的应用场景有哪些"></a>（16） 介绍一下红黑树和它的应用场景有哪些</h4><p>红黑树是一种特殊的二叉查找树，它在每一个节点上都使用红色或黑色进行标记，通过一些性质确保它是始终平衡的。<br>它的性质是这样的：</p>
<ol>
<li>每个节点不是红色就是黑色。</li>
<li>根节点是黑色的。</li>
<li>叶节点的空节点是黑色的。</li>
<li>如果一个节点是红色的，那么它的两个子节点是黑色的。</li>
<li>对于任意节点，从它到叶节点的每条路径上都有相同数目的黑色节点。</li>
</ol>
<p>红黑树的插入，查询，删除在一般情况和最坏情况下的时间复杂度都是O(log(n))</p>
<p>应用场景主要是STL中map，set的实现，优点在于支持频繁的修改，因为查询删除插入时间复杂度都是logN</p>
<h4 id="（17）-怎么写sql取表的前1000行数据（招银网络二面）"><a href="#（17）-怎么写sql取表的前1000行数据（招银网络二面）" class="headerlink" title="（17） 怎么写sql取表的前1000行数据（招银网络二面）"></a>（17） 怎么写sql取表的前1000行数据（招银网络二面）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> limit <span class="number">1000</span></span><br><span class="line"><span class="keyword">from</span> t1</span><br></pre></td></tr></table></figure>
<h4 id="（18）-N个骰子出现和为m的概率"><a href="#（18）-N个骰子出现和为m的概率" class="headerlink" title="（18） N个骰子出现和为m的概率"></a>（18） N个骰子出现和为m的概率</h4><h4 id="（19）-海量数据问题（可参考左神的书）"><a href="#（19）-海量数据问题（可参考左神的书）" class="headerlink" title="（19） 海量数据问题（可参考左神的书）"></a>（19） 海量数据问题（可参考左神的书）</h4><h4 id="（20）-一致性哈希"><a href="#（20）-一致性哈希" class="headerlink" title="（20） 一致性哈希"></a>（20） 一致性哈希</h4><h4 id="（21）希尔排序说一下-手撕"><a href="#（21）希尔排序说一下-手撕" class="headerlink" title="（21）希尔排序说一下/手撕"></a>（21）希尔排序说一下/手撕</h4><p><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">https://www.cnblogs.com/chengxiao/p/6104371.html</a><br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h4 id="（22）Dijkstra算法说一下"><a href="#（22）Dijkstra算法说一下" class="headerlink" title="（22）Dijkstra算法说一下"></a>（22）Dijkstra算法说一下</h4><h4 id="（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"><a href="#（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）" class="headerlink" title="（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"></a>（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）</h4><p>模拟STL中vector的实现即可，去看一下vector的源码。</p>
<h4 id="（24）最小生成树算法说一下"><a href="#（24）最小生成树算法说一下" class="headerlink" title="（24）最小生成树算法说一下"></a>（24）最小生成树算法说一下</h4><h4 id="（25）-海量数据的bitmap使用原理"><a href="#（25）-海量数据的bitmap使用原理" class="headerlink" title="（25） 海量数据的bitmap使用原理"></a>（25） 海量数据的bitmap使用原理</h4><p>bitmap算法就是使用一个比特映射一个值，它可以用在整数排序和数据压缩上，因为使用一个比特位去存储一个数，所以它可以大大节省空间。</p>
<p>它的具体过程是：先根据数组中元素最大的数N计算需要分配多大的空间。<br>如果使用int型数组的形式来保存的话，一个int = 4字节  =4*8比特 = 32比特。也就是一个int数可以映射32个数据（图1），然后需要找到最大的数Max，表示最多需要的位数，所以需要开辟的数组空间为int a[1+Max/32]。<br>然后需要推导一个整数a内如何映射32个数据，方法是将待存储的数据模32，然后将a中相应位置的比特置为1。<br>依此方法映射每一个元素，待读取的时候扫描每个比特位，遇到值为1的就还原该数字。<br><img src="fig/bitmap1.png" alt=""></p>
<p><strong>移位计算公式：</strong><br>N/32就是将N的二进制右移log32（也就是5）位 ： N&gt;&gt;5<br><br>N%32就是求N的后5位：N&amp; 0x1F  (0x1F = 00011111)<br><br>模32然后相应位置置为1： a[i] |= 1&lt;&lt; N &amp; 0x1F<br></p>
<p>所以总的公式为： a[ N&gt;&gt;5 ] |= 1&lt;&lt; N &amp; 0x1F<br></p>
<p><strong>BitMap算法评价</strong></p>
<ul>
<li>优点：<ol>
<li>运算效率高，不进行比较和移位；</li>
<li>占用内存少，比如最大的数MAX=10000000；只需占用内存为MAX/8=1250000Byte=1.25M。</li>
</ol>
</li>
<li>缺点：<ol>
<li>所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用2-bitmap）。</li>
<li>所需要的空间随着最大元素的增大而增大，当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。</li>
</ol>
</li>
</ul>
<h4 id="（26）-布隆过滤器原理与优点"><a href="#（26）-布隆过滤器原理与优点" class="headerlink" title="（26） 布隆过滤器原理与优点"></a>（26） 布隆过滤器原理与优点</h4><p>布隆过滤器是一个比特向量或者比特数组，它本质上是一种概率型数据结构，用来查找一个元素是否在集合中，支持高效插入和查询某条记录。常作为针对超大数据量下高效查找数据的一种方法。</p>
<p><strong>它的具体工作过程是这样子的：</strong><br>假设布隆过滤器的大小为m（比特向量的长度为m），有k个哈希函数，它对每个数据用这k个哈希函数计算哈希，得到k个哈希值，然后将向量中相应的位设为1。在查询某个数据是否存在的时候，对这个数据用k个哈希函数得到k个哈希值，再在比特向量中相应的位查找是否为1，如果某一个相应的位不为1，那这个数据就肯定不存在。但是如果全找到了，则这个数据有可能存在。</p>
<p><strong>为什么说有可能存在呢？</strong><br>因为不同的数据经过哈希后可能有相同的哈希值，在比特向量上某个位置查找到1也可能是由于某个另外的数据映射得到的。</p>
<p><strong>支持删除操作吗</strong><br>目前布隆过滤器只支持插入和查找操作，不支持删除操作，如果要支持删除，就要另外使用一个计数变量，每次将相应的位置为1则计数加一，删除则减一。</p>
<p>布隆过滤器中哈希函数的个数需要选择。如果太多则很快所有位都置为1，如果太少会容易误报。</p>
<p><strong>布隆过滤器的大小以及哈希函数的个数怎么选择？</strong><br>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率<br><img src="fig/布隆过滤器.png" alt=""></p>
<h4 id="（27）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"><a href="#（27）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题" class="headerlink" title="（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"></a>（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</h4><h4 id="（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"><a href="#（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）" class="headerlink" title="（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"></a>（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评测题目: </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FIFOQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(initCap,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">condition_variable cv;</span><br><span class="line">mutex m;</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">false</span>;<span class="comment">// isFull</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  	unique_lock&lt;mutex&gt;&lt;/mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">    <span class="keyword">while</span>(flag==<span class="literal">true</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        end=(end<span class="number">+1</span>)%initCap;</span><br><span class="line">        vec[end]=v;</span><br><span class="line">        cv.<span class="built_in">notifyall</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  unique_lock&lt;mutex&gt;&lt;/mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">  	<span class="keyword">if</span>(start!=end)&#123;</span><br><span class="line">    	<span class="type">int</span> val = vec[start];</span><br><span class="line">    	start=(start<span class="number">+1</span>)%initCap;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">    	cv.<span class="built_in">notifyall</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	flag=<span class="literal">false</span>;</span><br><span class="line">    	cv.<span class="built_in">notifyall</span>();</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是面试时写的，并没有运行，也许有错误，请客观参考</p>
<h1 id="在main执行之前和之后执行的代码可能是什么？"><a href="#在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="在main执行之前和之后执行的代码可能是什么？"></a>在main执行之前和之后执行的代码可能是什么？</h1><p>main函数执行之前，主要就是初始化系统相关资源：</p>
<ul>
<li>设置栈指针</li>
<li>初始化静态static变量和global全局变量，即.data段的内容</li>
<li>将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容</li>
<li>全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码</li>
<li>将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数</li>
</ul>
<p>main函数执行之后：</p>
<ul>
<li>全局对象的析构函数会在main函数之后执行；</li>
<li>可以用 atexit 注册一个函数，它会在main 之后执行;</li>
</ul>
<h1 id="结构体内存对齐问题？"><a href="#结构体内存对齐问题？" class="headerlink" title="结构体内存对齐问题？"></a>结构体内存对齐问题？</h1><p>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</p>
<p>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</p>
<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul>
<li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li>
<li>指针可以有多级，引用只有一级</li>
<li>指针可以为空，引用不能为NULL且在定义时必须初始化</li>
<li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li>
<li>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。</li>
<li>引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。</li>
<li>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</li>
<li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li>
<li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li>
</ul>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">　　p=&amp;a;</span><br><span class="line">　　cout&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">test</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;指针p为NULL&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="comment">//0x22ff44 1</span></span><br><span class="line"><span class="comment">//指针p为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPTR</span><span class="params">(<span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">    p = &amp;a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testREFF</span><span class="params">(<span class="type">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">    p = a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* b = &amp;a;</span><br><span class="line">    <span class="built_in">testPTR</span>(b);<span class="comment">//改变指针指向，但是没改变指针的所指的内容</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;<span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; *b &lt;&lt; endl;<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">testREFF</span>(a);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><ul>
<li>申请方式不同：栈由系统自动分配；堆是自己申请和释放的。</li>
<li>申请大小限制不同：栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li>
<li>申请效率不同：栈由系统分配，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片。</li>
</ul>
<p>形象的比喻</p>
<p>栈就像我们去饭馆里吃饭，只管点菜（发出申# # 和吃（使用），吃饱了就走，不必理会# 洗菜等准备工作和# 刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>
<p>堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>
<h1 id="区别以下指针类型？"><a href="#区别以下指针类型？" class="headerlink" title="区别以下指针类型？"></a>区别以下指针类型？</h1><ul>
<li><code>int *p[10]</code>表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</li>
<li><code>int (*p)[10]</code>表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</li>
<li><code>int *p(int)</code>是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</li>
<li><code>int (*p)(int)</code>是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</li>
</ul>
<h1 id="宏定义和typedef区别？"><a href="#宏定义和typedef区别？" class="headerlink" title="宏定义和typedef区别？"></a>宏定义和typedef区别？</h1><p>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p>
<p>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</p>
<p>宏不检查类型；typedef会检查数据类型。</p>
<p>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</p>
<p>注意对指针的操作，typedef char <em> p_char和define p_char char </em>区别巨大。</p>
<h1 id="变量声明和定义区别？"><a href="#变量声明和定义区别？" class="headerlink" title="变量声明和定义区别？"></a>变量声明和定义区别？</h1><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</p>
<p>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</p>
<h1 id="哪几种情况必须用到初始化成员列表？"><a href="#哪几种情况必须用到初始化成员列表？" class="headerlink" title="哪几种情况必须用到初始化成员列表？"></a>哪几种情况必须用到初始化成员列表？</h1><p>初始化一个const成员。</p>
<p>初始化一个reference成员。</p>
<p>调用一个基类的构造函数，而该函数有一组参数。</p>
<p>调用一个数据成员对象的构造函数，而该函数有一组参数。</p>
<h1 id="a和-amp-a有什么区别？"><a href="#a和-amp-a有什么区别？" class="headerlink" title="a和&amp;a有什么区别？"></a>a和&amp;a有什么区别？</h1><p>假设数组<code>int a[10];</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure><br>a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。<code>*(a + 1) = a[1]</code>。</p>
<p>&amp;a是数组的指针，其类型为<code>int (*)[10]</code>（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。</p>
<p>若<code>(int *)p</code>，此时输出<code>*p</code>时，其值为<code>a[0]</code>的值，因为被转为<code>int *</code>类型，解引用时按照int类型大小来读取。</p>
<h1 id="迭代器失效的情况"><a href="#迭代器失效的情况" class="headerlink" title="迭代器失效的情况"></a>迭代器失效的情况</h1><p>以vector为例：</p>
<p>插入元素：</p>
<ul>
<li>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。</li>
<li>中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。</li>
</ul>
<p>删除元素：</p>
<ul>
<li>尾后删除：只有尾迭代失效。</li>
<li>中间删除：删除位置之后所有迭代失效。</li>
</ul>
<h1 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h1><ul>
<li>C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。</li>
<li>标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。</li>
<li>C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。</li>
<li>C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。</li>
<li>在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。</li>
<li>C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++允许重复定义变量，C语言也是做不到这一点的</li>
<li>在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</li>
<li>C++相对与C增加了一些关键字，如：bo# usi# dynamic_ca# namespace等等</li>
</ul>
<h1 id="C-中struct和class的区别"><a href="#C-中struct和class的区别" class="headerlink" title="C++中struct和class的区别"></a>C++中struct和class的区别</h1><p>相同点：</p>
<ul>
<li>两者都拥有成员# 公有和私有部分</li>
<li>任何可以使用class完成的工作，同样可以使用struct完成</li>
</ul>
<p>不同点</p>
<ul>
<li>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</li>
<li>class默认是private继承，而struct模式是public继承</li>
<li>class可以作为模板类型，struct不行</li>
</ul>
<p>引申：C++和C的struct区别</p>
<p>C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）</p>
<p>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数</p>
<p>C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</p>
<p>struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当作类的一种特例</p>
<h1 id="define宏定义和const的区别"><a href="#define宏定义和const的区别" class="headerlink" title="define宏定义和const的区别"></a>define宏定义和const的区别</h1><p>编译阶段</p>
<p>define是在编译的预处理阶段起作用，而const是在# 运行的时候起作用</p>
<p>安全性</p>
<p>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错</p>
<p>const常量有数据类型，编译器可以对其进行类型安全检查</p>
<p>内存占用</p>
<p>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</p>
<p>宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。</p>
<p>宏不检查类型；const会检查数据类型。</p>
<p>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</p>
<h1 id="final和override关键字"><a href="#final和override关键字" class="headerlink" title="final和override关键字"></a>final和override关键字</h1><p>override</p>
<p>当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">//OK</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果不使用override，当你手一抖，将foo()写成了foo()会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f00</span><span class="params">()</span></span>; <span class="comment">//OK，这个函数是B新增的，不是继承的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f0o</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>final</p>
<p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">final</span> : A <span class="comment">// 指明B是不可以被继承的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// Error: 在A中已经被final了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : B <span class="comment">// Error: B is final</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="拷贝初始化和直接初始化"><a href="#拷贝初始化和直接初始化" class="headerlink" title="拷贝初始化和直接初始化"></a>拷贝初始化和直接初始化</h1><p>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</p>
<ul>
<li><code>string str1(&quot;I am a string&quot;);</code>//语句1 直接初始化</li>
<li><code>string str2(str1);</code>//语句2 直接初始化，str1是已经存在的对象，直接调用构造函数对str2进行初始化</li>
<li><code>string str3 = &quot;I am a string&quot;;</code>//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</li>
<li><code>string str4 = str1;</code>//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</li>
</ul>
<p>为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了（语句1和语句3等价）。但是需要辨别两种情况。</p>
<p>当拷贝构造函数为private时：语句3和语句4在编译时会报错</p>
<p>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</p>
<h1 id="初始化和赋值的区别"><a href="#初始化和赋值的区别" class="headerlink" title="初始化和赋值的区别"></a>初始化和赋值的区别</h1><p>对于简单类型来说，初始化和赋值没什么区别</p>
<p>对于类和复杂数据类型来说，这两者的区别就大了，举例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num1;</span><br><span class="line">    <span class="type">int</span> num2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">num1</span>(a),<span class="built_in">num2</span>(b)&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)&#123;&#125;;</span><br><span class="line">    <span class="comment">//重载 = 号操作符函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a)&#123;</span><br><span class="line">        num1 = a.num1 + <span class="number">1</span>;</span><br><span class="line">        num2 = a.num2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    A a1 = a; <span class="comment">//拷贝初始化操作，调用拷贝构造函数</span></span><br><span class="line">    A b;</span><br><span class="line">    b = a;<span class="comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="模板函数和模板类的特例化"><a href="#模板函数和模板类的特例化" class="headerlink" title="模板函数和模板类的特例化"></a>模板函数和模板类的特例化</h1><p>引入原因</p>
<p>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p>
<p>定义</p>
<p>对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p>
<p>（1）模板函数特例化</p>
<p>必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对&lt;&gt;，表明将原模板的所有模板参数提供实参，举例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1,<span class="type">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &gt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &gt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;v1,<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本质</p>
<p>特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p>
<p>注意</p>
<p>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p>
<p>（2）类模板特例化</p>
<p>原理类似函数模板，不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hash</span>&lt;sales_data&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(sales_data&amp; s)</span></span>;</span><br><span class="line">    <span class="comment">//里面所有T都换成特例化类型版本sales_data</span></span><br><span class="line">    <span class="comment">//按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>类模板的部分特例化</p>
<p>不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p>
<p>特例化类中的部分成员</p>
<p>可以特例化类中的部分成员函数而不是整个类，举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Barst</span><span class="params">(T a)</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> Foo&lt;<span class="type">int</span>&gt;::<span class="built_in">Bar</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//进行int类型的特例化处理</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我是int型特例化&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line">Foo&lt;<span class="type">int</span>&gt; fi;<span class="comment">//使用特例化</span></span><br><span class="line">fs.<span class="built_in">Bar</span>();<span class="comment">//使用的是普通模板，即Foo&lt;string&gt;::Bar()</span></span><br><span class="line">fi.<span class="built_in">Bar</span>();<span class="comment">//特例化版本，执行Foo&lt;int&gt;::Bar()</span></span><br><span class="line"><span class="comment">//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</span></span><br></pre></td></tr></table></figure></p>
<h1 id="C和C-的类型安全"><a href="#C和C-的类型安全" class="headerlink" title="C和C++的类型安全"></a>C和C++的类型安全</h1><p>什么是类型安全？</p>
<p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。类型安全的编程语言与类型安全的程序之间，没有必然联系。好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序，相反的，差一点儿的程序员可能使用类型相当安全的语言写出类型不太安全的程序。绝对类型安全的编程语言暂时还没有。</p>
<p>如果C++使用得当，它将远比C更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安全：</p>
<ul>
<li>操作符new返回的指针类型严格与对象匹配，而不是void*</li>
<li>C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；</li>
<li>引入const关键字代替define constants，它是有类型有作用域的，define constants只是简单的文本替换</li>
</ul>
<p>C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。</p>
<p>例1：不同类型指针之间转换<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child1</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">Child1</span>(<span class="type">int</span> e):<span class="built_in">i</span>(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="built_in">Child2</span>(<span class="type">double</span> e):<span class="built_in">d</span>(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Child1 <span class="title">c1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Child2 <span class="title">c2</span><span class="params">(<span class="number">4.1</span>)</span></span>;</span><br><span class="line">    Parent* pp;</span><br><span class="line">    Child1* pc1;</span><br><span class="line"></span><br><span class="line">    pp=&amp;c1; </span><br><span class="line">    pc1=(Child1*)pp;  <span class="comment">// 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误</span></span><br><span class="line">    cout&lt;&lt;pc1-&gt;i&lt;&lt;endl; <span class="comment">//输出：5</span></span><br><span class="line"></span><br><span class="line">    pp=&amp;c2;</span><br><span class="line">    pc1=(Child1*)pp;  <span class="comment">//强制转换，且类型发生变化，将造成错误</span></span><br><span class="line">    cout&lt;&lt;pc1-&gt;i&lt;&lt;endl;<span class="comment">// 输出：1717986918</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面两个例子之所以引起类型不安全的问题，是因为程序员使用不得当。第一个例子用到了空类型指针void<em>，第二个例子则是在两个类型指针之间进行强制转换。因此，想保证程序的类型安全性，应尽量避免使用空类型指针void</em>，尽量不对两种类型指针做强制转换。</p>
<h1 id="C-有哪几种的构造函数"><a href="#C-有哪几种的构造函数" class="headerlink" title="C++有哪几种的构造函数"></a>C++有哪几种的构造函数</h1><p>C++中的构造函数可以分为4类：</p>
<ul>
<li>默认构造函数</li>
<li>初始化构造函数（有参数）</li>
<li>拷贝构造函数</li>
<li>移动构造函数（move和右值引用）</li>
<li>委托构造函数</li>
<li>转换构造函数</li>
</ul>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()&#123;<span class="comment">//默认构造函数，没有参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1000</span>;</span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> a, <span class="type">int</span> n):<span class="built_in">age</span>(a), <span class="built_in">num</span>(n)&#123;&#125;; <span class="comment">//初始化构造函数，有参数和参数列表</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student&amp; s)&#123;<span class="comment">//拷贝构造函数，这里与编译器生成的一致</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = s.age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = s.num;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> r)&#123;   <span class="comment">//转换构造函数,形参是其他类型变量，且只有一个形参</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1002</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">18</span>,<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function">Student <span class="title">s3</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s4</span><span class="params">(s3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 age:%d, num:%d\n&quot;</span>, s<span class="number">1.</span>age, s<span class="number">1.</span>num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 age:%d, num:%d\n&quot;</span>, s<span class="number">2.</span>age, s<span class="number">2.</span>num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s3 age:%d, num:%d\n&quot;</span>, s<span class="number">3.</span>age, s<span class="number">3.</span>num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 age:%d, num:%d\n&quot;</span>, s<span class="number">4.</span>age, s<span class="number">4.</span>num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//s1 age:20, num:1000</span></span><br><span class="line"><span class="comment">//s2 age:18, num:1001</span></span><br><span class="line"><span class="comment">//s3 age:10, num:1002</span></span><br><span class="line"><span class="comment">//s2 age:10, num:1002</span></span><br></pre></td></tr></table></figure><br>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</p>
<p>复制构造函数用于复制本类的对象</p>
<p>转换构造函数用于将其他类型的变量，隐式转换为本类对象</p>
<h1 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h1><p>浅拷贝</p>
<p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p>
<p>深拷贝</p>
<p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()&#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="number">20</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Student&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Student</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Student &quot;</span> &lt;&lt; &amp;name &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> name;</span><br><span class="line">        name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student &amp;s)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        <span class="comment">//浅拷贝，当对象的name和传入对象的name指向相同的地址</span></span><br><span class="line">        name = s.name;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="comment">//name = new char(20);</span></span><br><span class="line">        <span class="comment">//memcpy(name, s.name, strlen(s.name));</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy Student&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;<span class="comment">// 花括号让s1和s2变成局部对象，方便测试</span></span><br><span class="line">        Student s1;</span><br><span class="line">        <span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">// 复制对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浅拷贝执行结果：</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//copy Student</span></span><br><span class="line"><span class="comment">//~Student 0x7fffed0c3ec0</span></span><br><span class="line"><span class="comment">//~Student 0x7fffed0c3ed0</span></span><br><span class="line"><span class="comment">//*** Error in `/tmp/815453382/a.out&#x27;: double free or corruption (fasttop): 0x0000000001c82c20 ***</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝执行结果：</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//copy Student</span></span><br><span class="line"><span class="comment">//~Student 0x7fffebca9fb0</span></span><br><span class="line"><span class="comment">//~Student 0x7fffebca9fc0</span></span><br></pre></td></tr></table></figure><br>从执行结果可以看出，浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。</p>
<h1 id="auto-decltype和decltype-auto-的用法"><a href="#auto-decltype和decltype-auto-的用法" class="headerlink" title="auto decltype和decltype(auto)的用法"></a>auto decltype和decltype(auto)的用法</h1><p>（1）auto</p>
<p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，</p>
<p>auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通；类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> c = a + b;<span class="comment">// c为int型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i; <span class="comment">// 变量i是顶层const, 会被忽略, 所以j的类型是int</span></span><br><span class="line"><span class="keyword">auto</span> k = &amp;i; <span class="comment">// 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> l = i; <span class="comment">//如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用和指针类型</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>&amp; y = x;</span><br><span class="line"><span class="keyword">auto</span> z = y; <span class="comment">//z是int型不是int&amp; 型</span></span><br><span class="line"><span class="keyword">auto</span>&amp; p1 = y; <span class="comment">//p1是int&amp;型</span></span><br><span class="line"><span class="keyword">auto</span> p2 = &amp;x; <span class="comment">//p2是指针类型int*</span></span><br></pre></td></tr></table></figure></p>
<p>（2）decltype</p>
<p>有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) sum = <span class="number">5</span>; <span class="comment">// sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">4</span>; <span class="comment">// a的类型是int, 所以b的类型也是int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不论是顶层const还是底层const, decltype都会保留   </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>(c) d = c; <span class="comment">// d的类型和c是一样的, 都是顶层const</span></span><br><span class="line"><span class="type">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(f) g = f; <span class="comment">// g也是底层const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用与指针类型</span></span><br><span class="line"><span class="comment">//1. 如果表达式是引用类型, 那么decltype的类型也是引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">3</span>, &amp;j = i;</span><br><span class="line"><span class="keyword">decltype</span>(j) k = <span class="number">5</span>; <span class="comment">// k的类型是 const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) t = <span class="number">5</span>; <span class="comment">// 此时是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对指针的解引用操作返回的是引用类型</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>, j = <span class="number">6</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c = j; <span class="comment">// c是int&amp;类型, c和j绑定在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) j = i; <span class="comment">// 此时j的类型是int&amp;类型, j和i绑定在了一起</span></span><br></pre></td></tr></table></figure></p>
<p>（3）decltype(auto)</p>
<p>decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“=”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) j = f;<span class="comment">//j的类型是const int* 并且指向的是e</span></span><br></pre></td></tr></table></figure></p>
<h1 id="C-中NULL和nullptr区别"><a href="#C-中NULL和nullptr区别" class="headerlink" title="C++中NULL和nullptr区别"></a>C++中NULL和nullptr区别</h1><p>算是为了与C语言进行兼容而定义的一个问题吧</p>
<p>NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。在C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0。编译器一般对其实际定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><br>在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。因为C++中允许有函数重载，所以可以试想如下函数定义情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;char*&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：int</span></span><br></pre></td></tr></table></figure><br>那么在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</p>
<p>nullptr的一种实现方式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">class</span> <span class="title class_">nullptr_t</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  <span class="keyword">inline</span> <span class="keyword">operator</span> T*() <span class="type">const</span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">C</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">inline</span> <span class="keyword">operator</span> T C::*() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>&amp;() <span class="type">const</span>;</span><br><span class="line">&#125; <span class="literal">nullptr</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure><br>以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。但nullptr仍然存在一定问题，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;char* p&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;int* p&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;int p&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>((<span class="type">char</span>*)<span class="literal">nullptr</span>);<span class="comment">//语句1</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">nullptr</span>);<span class="comment">//语句2</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);<span class="comment">//语句3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//语句1：char* p</span></span><br><span class="line"><span class="comment">//语句2:报错，有多个匹配</span></span><br><span class="line"><span class="comment">//3：int p</span></span><br></pre></td></tr></table></figure><br>在这种情况下存在对不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。</p>
<h1 id="简要说明C-的内存分区"><a href="#简要说明C-的内存分区" class="headerlink" title="简要说明C++的内存分区"></a>简要说明C++的内存分区</h1><p>C++中的内存分区，分别# # 自由存# 全局/静态存# 常量存储区和代码区。如下图所示</p>
<p>图片</p>
<p>栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p>
<p>堆：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p>
<p>自由存储区：就是那些由malloc等分配的内存块，它和堆是十分相似的，不过它是用free来结束自己的生命的</p>
<p>全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</p>
<p>常量存储区：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改</p>
<p>代码区：存放函数体的二进制代码</p>
<p>《C/C++内存管理详解》：</p>
<p><a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/</a></p>
<h1 id="C-的异常处理的方法"><a href="#C-的异常处理的方法" class="headerlink" title="C++的异常处理的方法"></a>C++的异常处理的方法</h1><p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p>
<p>数组下标越界</p>
<p>除法计算时除数为0</p>
<p>动态分配空间时空间不足</p>
<p>…</p>
<p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p>
<p>（1）t# throw和catch关键字</p>
<p>C++中的异常处理机制主要使用t# throw和catch三个关键字，其在程序中的用法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> m = <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;before dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1</span>;  <span class="comment">//抛出int型异常</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1.0</span>;  <span class="comment">//拋出 double 型异常</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">double</span> d) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch (double)&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch (...)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//before dividing.</span></span><br><span class="line"><span class="comment">//catch (...)</span></span><br><span class="line"><span class="comment">//finished</span></span><br></pre></td></tr></table></figure><br>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块。如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。</p>
<p>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。</p>
<p>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p>
<p>（2）函数的异常声明列表</p>
<p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：</p>
<p>int fun() throw(int,double,A,B,C){…};<br>这种写法表名函数可能会抛出int,double型或# # C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p>
<p>（3）C++标准异常类  exception</p>
<p>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          cout &lt;&lt; <span class="built_in">typeid</span>(*a).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">// Error condition</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">catch</span> (bad_typeid)&#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;Object is NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：bject is NULL</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</li>
<li>bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</li>
<li>out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</li>
</ul>
<h1 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h1><p>1)  初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。</p>
<p>2)  静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。</p>
<p>3)  而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的。</p>
<h1 id="值传递、指针传递、引用传递的区别和效率"><a href="#值传递、指针传递、引用传递的区别和效率" class="headerlink" title="值传递、指针传递、引用传递的区别和效率"></a>值传递、指针传递、引用传递的区别和效率</h1><ul>
<li>值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象   或是大的结构体对象，将耗费一定的时间和空间。（传值）</li>
<li>指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）</li>
<li>引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）</li>
<li>效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。</li>
</ul>
<h1 id="什么是内存池，如何实现"><a href="#什么是内存池，如何实现" class="headerlink" title="什么是内存池，如何实现"></a>什么是内存池，如何实现</h1><p>内存池（Memory Pool） 是一种内存分配方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</p>
<p>这里简单描述一下《STL源码剖析》中的内存池实现机制：</p>
<p>allocate包装malloc,deallocate包装free</p>
<p>一般是一次20*2个的申请，先用一半，留着一半，为什么也没个说法，侯捷在STL那边书里说好像是C++委员会成员认为20是个比较好的数字，既不大也不小</p>
<p>首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20*32byte）</p>
<p>客户端之后有有内存需求，想申请（20<em>64bytes）的空间，这时内存池只有（20</em>32bytes），就先将（10*64bytes)个区块返回，1个区块交出，另外9个处于维护状态，此时内存池空空如也</p>
<p>接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。</p>
<p>如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常</p>
<p>allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。内部实现，目前的所有编译器都是直接调用的<code>::operator new()</code>和<code>::operator delete()</code>，说白了就是和直接使用new运算符的效果是一样的，所以老师说它们都没做任何特殊处理。</p>
<p>最开始GC2.9之前：</p>
<p>new和 operator new 的区别：new 是个运算符，编辑器会调用 operator new(0)</p>
<p><code>operator new()</code>里面有调用malloc的操作，那同样的 operator delete()里面有调用的free的操作</p>
<p>GCC2.9的alloc的一个比较好的分配器的实现规则</p>
<p>维护一条0-15号的一共16条链表，其中0表示8 bytes ，1表示 16 bytes,2表示 24bytes。。。。而15 表示 16* 8 = 128bytes，如果在申请时并不是8的倍数，那就找刚好能满足内存大小的那个位置。比如想申请 12，那就是找16了，想申请 20 ，那就找 24 了</p>
<p>但是现在GC4.9及其之后 也还有，变成_pool_alloc这个名字了，不再是默认的了，你需要自己去指定它可以自己指定，比如说<code>vector&lt;string,__gnu_cxx::pool_allocvec;</code>这样来使用它，现在用的又回到以前那种对malloc和free的包装形式了</p>
<h1 id="从汇编层去解释一下引用"><a href="#从汇编层去解释一下引用" class="headerlink" title="从汇编层去解释一下引用"></a>从汇编层去解释一下引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9:      int x = 1;</span><br><span class="line">00401048  mov     dword ptr [ebp-4],1</span><br><span class="line">10:     int &amp;b = x;</span><br><span class="line">0040104F   lea     eax,[ebp-4]</span><br><span class="line">00401052  mov     dword ptr [ebp-8],eax</span><br></pre></td></tr></table></figure>
<p>x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低。</p>
<p><code>lea eax,[ebp-4]</code> 这条语句将x的地址ebp-4放入eax寄存器</p>
<p><code>mov dword ptr [ebp-8],eax</code>这条语句将eax的值放入b的地址</p>
<p><code>ebp-8</code>中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？所以从汇编层次来看，的确引用是通过指针来实现的。</p>
<h1 id="C-模板是什么，你知道底层怎么实现的？"><a href="#C-模板是什么，你知道底层怎么实现的？" class="headerlink" title="C++模板是什么，你知道底层怎么实现的？"></a>C++模板是什么，你知道底层怎么实现的？</h1><p>1)  编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p>
<p>2)  这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</p>
<h1 id="什么是内存泄露，如何检测与避免"><a href="#什么是内存泄露，如何检测与避免" class="headerlink" title="什么是内存泄露，如何检测与避免"></a>什么是内存泄露，如何检测与避免</h1><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p>
<h2 id="避免内存泄露的几种方式"><a href="#避免内存泄露的几种方式" class="headerlink" title="避免内存泄露的几种方式"></a>避免内存泄露的几种方式</h2><ul>
<li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li>
<li>一定要将基类的析构函数声明为虚函数</li>
<li>对象数组的释放一定要用delete []</li>
<li>有new就有delete，有malloc就有free，保证它们一定成对出现</li>
</ul>
<h1 id="对象复用的了解，零拷贝的了解"><a href="#对象复用的了解，零拷贝的了解" class="headerlink" title="对象复用的了解，零拷贝的了解"></a>对象复用的了解，零拷贝的了解</h1><h2 id="对象复用"><a href="#对象复用" class="headerlink" title="对象复用"></a>对象复用</h2><p>对象复用其本质是一种设计模式：Flyweight享元模式。</p>
<p>通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。</p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</p>
<p>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</p>
<p>在C++中，vector的一个成员函数emplace_back()很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//初始构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(string p_name, <span class="type">int</span> p_age): <span class="built_in">name</span>(std::<span class="built_in">move</span>(p_name)), <span class="built_in">age</span>(p_age)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;I have been constructed&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//拷贝构造函数</span></span><br><span class="line">     <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; other): <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">age</span>(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;I have been copy constructed&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//转移构造函数</span></span><br><span class="line">     <span class="built_in">Person</span>(Person&amp;&amp; other): <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">age</span>(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;I have been moved&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; e;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_back:&quot;</span> &lt;&lt;endl;</span><br><span class="line">    e.<span class="built_in">emplace_back</span>(<span class="string">&quot;Jane&quot;</span>, <span class="number">23</span>); <span class="comment">//不用构造类对象</span></span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">36</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//emplace_back:</span></span><br><span class="line"><span class="comment">//I have been constructed</span></span><br><span class="line"><span class="comment">//push_back:</span></span><br><span class="line"><span class="comment">//I have been constructed</span></span><br><span class="line"><span class="comment">//I am being moved.</span></span><br></pre></td></tr></table></figure>
<h1 id="解释一下什么是trivial-destructor"><a href="#解释一下什么是trivial-destructor" class="headerlink" title="解释一下什么是trivial destructor"></a>解释一下什么是trivial destructor</h1><p>“trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。</p>
<p>反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数如果申请了新的空间一定要显式的释放，否则会造成内存泄露</p>
<p>对于trivial destructor，如果每次都进行调用，显然对效率是一种伤害，如何进行判断呢？《STL源码解析》中给出的说明是：</p>
<p>首先利用<code>value_type()</code>获取所指对象的型别，再利用<strong>type_traits判断该型别的析构函数是否trivial，若是`(</strong>true_type)<code>，则什么也不做，若为</code>(__false_type)`，则去调用destory()函数</p>
<p>也就是说，在实际的应用当中，STL库提供了相关的判断方法__type_traits，感兴趣的读者可以自行查阅使用方式。除了trivial destructor，还有trivial construct、trivial copy construct等，如果能够对是否trivial进行区分，可以采用内存处理函数memcpy()、malloc()等更加高效的完成相关操作，提升效率。</p>
<h1 id="C-中类的数据成员和成员函数内存分布情况"><a href="#C-中类的数据成员和成员函数内存分布情况" class="headerlink" title="C++中类的数据成员和成员函数内存分布情况"></a>C++中类的数据成员和成员函数内存分布情况</h1><p>C++类是由结构体发展得来的，所以他们的成员变量（C语言的结构体只有成员变量）的内存分配机制是一样的。下面我们以类来说明问题，如果类的问题通了，结构体也也就没问题啦。类分为成员变量和成员函数，我们先来讨论成员变量。</p>
<p>一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的同时这些成员变量也就被定义了），举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">23</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;对象地址：&quot;</span>&lt;&lt; &amp;p &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age地址：&quot;</span>&lt;&lt; &amp;(p.age) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;对象大小：&quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age大小：&quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(p.age) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//对象地址：0x7fffec0f15a8</span></span><br><span class="line"><span class="comment">//age地址：0x7fffec0f15a8</span></span><br><span class="line"><span class="comment">//对象大小：4</span></span><br><span class="line"><span class="comment">//age大小：4</span></span><br></pre></td></tr></table></figure>
<p>从代码运行结果来看，对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。要是成员函数占用类的对象空间，那么将是多么可怕的事情：定义一次类对象就有成员函数占用一段空间。我们再来补充一下静态成员函数的存放问题：静态成员函数与一般成员函数的唯一区别就是没有this指针，因此不能访问非静态数据成员，就像我前面提到的，所有函数都存放在代码区，静态函数也不例外。所有有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。</p>
<h1 id="析构函数的作用，如何起作用？"><a href="#析构函数的作用，如何起作用？" class="headerlink" title="析构函数的作用，如何起作用？"></a>析构函数的作用，如何起作用？</h1><p>1)  构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。</p>
<p>规则，只要你一实例化对象，系统自动回调用一个构造函数就是你不写，编译器也自动调用一次。</p>
<p>2)  析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。</p>
<p>析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。当撤销对象时，编译器也会自动调用析构函数。</p>
<p>每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。</p>
<h1 id="构造函数析构函数可否抛出异常"><a href="#构造函数析构函数可否抛出异常" class="headerlink" title="构造函数析构函数可否抛出异常"></a>构造函数析构函数可否抛出异常</h1><p>1)   C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。</p>
<p>因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。</p>
<p>2)  用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；</p>
<p>3)  如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；</p>
<p>4)  如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。</p>
<h1 id="类什么时候会析构？"><a href="#类什么时候会析构？" class="headerlink" title="类什么时候会析构？"></a>类什么时候会析构？</h1><p>1)  对象生命周期结束，被销毁时；</p>
<p>2)  delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；</p>
<p>3)  对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。</p>
<h1 id="构造函数的几种关键字"><a href="#构造函数的几种关键字" class="headerlink" title="构造函数的几种关键字"></a>构造函数的几种关键字</h1><p>default</p>
<p>default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CString</span>() = <span class="keyword">default</span>; <span class="comment">//语句1</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CString</span>(<span class="type">const</span> <span class="type">char</span>* pstr) : _str(pstr)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;<span class="comment">//这样不允许使用new关键字</span></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CString</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     string _str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">CString</span>(); <span class="comment">//语句2</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//Hello World</span></span><br></pre></td></tr></table></figure>
<p>如果没有加语句1，语句2会报错，表示找不到参数为空的构造函数，将其设置为default可以解决这个问题</p>
<p>delete</p>
<p>delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;<span class="comment">//这样不允许使用new关键字</span></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CString</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">CString</span>(); <span class="comment">//语句1</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部）</p>
<h1 id="C-函数调用的压栈过程"><a href="#C-函数调用的压栈过程" class="headerlink" title="C++函数调用的压栈过程"></a>C++函数调用的压栈过程</h1><p>从代码入手，解释这个过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> var1 = param1;</span><br><span class="line">    <span class="type">int</span> var2 = param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var1=%d,var2=%d&quot;</span>, <span class="built_in">f</span>(var1), <span class="built_in">f</span>(var2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//var1=1,var2=2</span></span><br></pre></td></tr></table></figure>
<p>当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；</p>
<p>当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；</p>
<p>当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈</p>
<p>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</p>
<h1 id="说说移动构造函数"><a href="#说说移动构造函数" class="headerlink" title="说说移动构造函数"></a>说说移动构造函数</h1><p>1)  我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p>
<p>2)  拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。</p>
<p>所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；</p>
<p>3)  移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。</p>
<h1 id="C-中将临时变量作为返回值时的处理过程"><a href="#C-中将临时变量作为返回值时的处理过程" class="headerlink" title="C++中将临时变量作为返回值时的处理过程"></a>C++中将临时变量作为返回值时的处理过程</h1><p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p>
<p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</p>
<p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p>
<p>如果我们需要返回值，一般使用赋值语句就可以了</p>
<h1 id="关于this指针你知道什么？全说出来"><a href="#关于this指针你知道什么？全说出来" class="headerlink" title="关于this指针你知道什么？全说出来"></a>关于this指针你知道什么？全说出来</h1><p>this指针是类的指针，指向对象的首地址。</p>
<p>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</p>
<p>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</p>
<h2 id="this指针的用处"><a href="#this指针的用处" class="headerlink" title="this指针的用处"></a>this指针的用处</h2><p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行</p>
<h2 id="this指针的使用"><a href="#this指针的使用" class="headerlink" title="this指针的使用"></a>this指针的使用</h2><p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；</p>
<p>另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n = n （不能写成n = n）</p>
<p>类的this指针有以下特点</p>
<p>(1）this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，成员函数默认第一个参数为T * const this</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">其中，func的原型在编译器看来应该是：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(A * <span class="type">const</span> <span class="keyword">this</span>,<span class="type">int</span> p)</span></span>;</span><br></pre></td></tr></table></figure>
<p>（2）由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//此处，编译器将会编译成：</span></span><br><span class="line">A::<span class="built_in">func</span>(&amp;a,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。</p>
<h1 id="几个this指针的易混问题"><a href="#几个this指针的易混问题" class="headerlink" title="几个this指针的易混问题"></a>几个this指针的易混问题</h1><h2 id="this指针是什么时候创建的？"><a href="#this指针是什么时候创建的？" class="headerlink" title="this指针是什么时候创建的？"></a>this指针是什么时候创建的？</h2><p>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p>
<p>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答</p>
<h2 id="this指针存放在何处？堆、栈、全局变量，还是其他？"><a href="#this指针存放在何处？堆、栈、全局变量，还是其他？" class="headerlink" title="this指针存放在何处？堆、栈、全局变量，还是其他？"></a>this指针存放在何处？堆、栈、全局变量，还是其他？</h2><p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</p>
<h2 id="this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？"><a href="#this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？" class="headerlink" title="this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？"></a>this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</h2><p>大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</p>
<p>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的</p>
<h2 id="this指针是如何访问类中的变量的？"><a href="#this指针是如何访问类中的变量的？" class="headerlink" title="this指针是如何访问类中的变量的？"></a>this指针是如何访问类中的变量的？</h2><p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。</p>
<p>在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。</p>
<p>this是类的指针，如果换成结构体，那this就是结构的指针了。</p>
<h2 id="我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"><a href="#我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？" class="headerlink" title="我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"></a>我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</h2><p>this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p>
<h2 id="每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"><a href="#每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？" class="headerlink" title="每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"></a>每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</h2><p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰</p>
<h1 id="构造函数、拷贝构造函数和赋值操作符的区别"><a href="#构造函数、拷贝构造函数和赋值操作符的区别" class="headerlink" title="构造函数、拷贝构造函数和赋值操作符的区别"></a>构造函数、拷贝构造函数和赋值操作符的区别</h1><p>构造函数</p>
<p>对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</p>
<p>拷贝构造函数</p>
<p>对象不存在，但是使用别的已经存在的对象来进行初始化</p>
<p>赋值运算符</p>
<p>对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是赋值操作符&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1; <span class="comment">//调用构造函数</span></span><br><span class="line">    A a2 = a1; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    a2 = a1; <span class="comment">//调用赋值操作符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//我是构造函数</span></span><br><span class="line"><span class="comment">//我是拷贝构造函数</span></span><br><span class="line"><span class="comment">//我是赋值操作符</span></span><br></pre></td></tr></table></figure>
<h1 id="静态类型和动态类型以及静态绑定和动态绑定的总结"><a href="#静态类型和动态类型以及静态绑定和动态绑定的总结" class="headerlink" title="静态类型和动态类型以及静态绑定和动态绑定的总结"></a>静态类型和动态类型以及静态绑定和动态绑定的总结</h1><ul>
<li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li>
<li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li>
<li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li>
<li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li>
</ul>
<p>从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。</p>
<h1 id="引用是否能实现动态绑定，为什么可以实现？"><a href="#引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="引用是否能实现动态绑定，为什么可以实现？"></a>引用是否能实现动态绑定，为什么可以实现？</h1><p>可以。</p>
<p>引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>  <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>  <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;son :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;son :: not virtual function&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    Base&amp; b = s; <span class="comment">// 基类类型引用绑定已经存在的Son对象，引用必须初始化</span></span><br><span class="line">    s.<span class="built_in">fun</span>(); <span class="comment">//son::fun()</span></span><br><span class="line">    b.<span class="built_in">fun</span>(); <span class="comment">//son :: fun()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要说明的是虚函数才具有动态绑定，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。</p>
<h1 id="全局变量和局部变量有什么区别？"><a href="#全局变量和局部变量有什么区别？" class="headerlink" title="全局变量和局部变量有什么区别？"></a>全局变量和局部变量有什么区别？</h1><p>生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p>
<p>使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</p>
<p>操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载，局部变量则分配在堆栈里面 。</p>
<h1 id="指针加减计算要注意什么？"><a href="#指针加减计算要注意什么？" class="headerlink" title="指针加减计算要注意什么？"></a>指针加减计算要注意什么？</h1><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *a, *b, c;</span><br><span class="line">    a = (<span class="type">int</span>*)<span class="number">0x500</span>;</span><br><span class="line">    b = (<span class="type">int</span>*)<span class="number">0x520</span>;</span><br><span class="line">    c = b - a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// 8</span></span><br><span class="line">    a += <span class="number">0x020</span>;</span><br><span class="line">    c = b - a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// -24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5<em>16\^2=1280）和1312（5</em>16\^2+2*16=1312)， 那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是考虑到是int类型占4位，所以c的值为32/4=8</p>
<p>a自增16进制0x20之后，其实际地址变为1280 + 2<em>16</em>4 = 1408，（因为一个int占4位，所以要乘4），这样它们的差值就变成了1312 - 1280 = -96，所以c的值就变成了-96/4 = -24</p>
<p>遇到指针的计算，需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果</p>
<h1 id="怎样判断两个浮点数是否相等？"><a href="#怎样判断两个浮点数是否相等？" class="headerlink" title="怎样判断两个浮点数是否相等？"></a>怎样判断两个浮点数是否相等？</h1><p>对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p>
<h1 id="方法调用的原理（栈、汇编）"><a href="#方法调用的原理（栈、汇编）" class="headerlink" title="方法调用的原理（栈、汇编）"></a>方法调用的原理（栈、汇编）</h1><p>1)  机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;</p>
<p>2)  由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。</p>
<p>3)  过程实现</p>
<ul>
<li>备份原来的帧指针，调整当前的栈帧指针到栈指针位置；</li>
<li>建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；</li>
<li>使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</li>
<li>恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了</li>
<li>恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。</li>
<li>释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。</li>
<li>恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。</li>
<li>弹出返回地址，跳出当前过程，继续执行调用者的代码。</li>
</ul>
<p>4)  过程调用和返回指令</p>
<ul>
<li>call指令</li>
<li>leave指令</li>
<li>ret指令</li>
</ul>
<h1 id="C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h1><p>1) 指针参数传递本质上是值传递，它所传递的是一个地址值。</p>
<p>值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。</p>
<p>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</p>
<p>2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</p>
<p>被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。</p>
<p>因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</p>
<p>3) 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。</p>
<p>而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</p>
<p>4) 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。</p>
<p>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。</p>
<p>符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p>
<h1 id="类如何实现只能静态分配和只能动态分配"><a href="#类如何实现只能静态分配和只能动态分配" class="headerlink" title="类如何实现只能静态分配和只能动态分配"></a>类如何实现只能静态分配和只能动态分配</h1><p>1)  前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建</p>
<p>2)  建立类的对象有两种方式：</p>
<ul>
<li>静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；</li>
<li>动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；</li>
</ul>
<p>3)  只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。</p>
<h1 id="如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>如果想将某个类用作基类，为什么该类必须定义而非声明？</h1><p>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。</p>
<h1 id="什么情况会自动生成默认构造函数？"><a href="#什么情况会自动生成默认构造函数？" class="headerlink" title="什么情况会自动生成默认构造函数？"></a>什么情况会自动生成默认构造函数？</h1><ul>
<li>带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。<ul>
<li>不过这个合成操作只有在构造函数真正被需要的时候才会发生；</li>
<li>如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；</li>
</ul>
</li>
<li>带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；</li>
<li>带有一个虚函数的类</li>
<li>带有一个虚基类的类</li>
<li>合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。</li>
</ul>
<h1 id="函数指针？"><a href="#函数指针？" class="headerlink" title="函数指针？"></a>函数指针？</h1><ul>
<li>什么是函数指针?</li>
</ul>
<p>函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。</p>
<p>一个具体函数的名字，如果后面不跟调用符号(即括号)，则该名字就是该函数的指针(注意：大部分情况下，可以这么认为，但这种说法并不很严格)。</p>
<ul>
<li>函数指针的声明方法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*pf)(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;); (<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个<code>const int&amp;</code>参数的函数。注意*pf两边的括号是必须的，否则上面的定义就变成了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">pf</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>; (<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>而这声明了一个函数pf，其返回类型为int *， 带有两个<code>const int&amp;</code>参数。</p>
<ul>
<li>为什么有函数指针</li>
</ul>
<p>函数与数据项相似，函数也有地址。我们希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。</p>
<ul>
<li><p>一个函数名就是一个指针，它指向函数的代码。一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；</p>
</li>
<li><p>两种方法赋值：</p>
</li>
</ul>
<p>指针名 = 函数名； 指针名 = &amp;函数名</p>
<h1 id="函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h1><ol>
<li>调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈;</li>
<li>调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中);</li>
<li>在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp);</li>
<li>在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;</li>
</ol>
<h1 id="你知道printf函数的实现原理是什么吗？"><a href="#你知道printf函数的实现原理是什么吗？" class="headerlink" title="你知道printf函数的实现原理是什么吗？"></a>你知道printf函数的实现原理是什么吗？</h1><p>在C/C++中，对函数参数的扫描是从后向前的。</p>
<p>C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p>
<p>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf(“%d,%d”,a,b);（其中a、b都是int型的）的汇编代码.</p>
<h1 id="说一说你了解的关于lambda函数的全部知识"><a href="#说一说你了解的关于lambda函数的全部知识" class="headerlink" title="说一说你了解的关于lambda函数的全部知识"></a>说一说你了解的关于lambda函数的全部知识</h1><p>1) 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；</p>
<p>2) 每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。</p>
<p>3) lambda表达式的语法定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] （parameters） <span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type &#123;statement&#125;;</span><br></pre></td></tr></table></figure>
<p>4) lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</p>
<h1 id="为什么模板类一般都是放在一个h文件中"><a href="#为什么模板类一般都是放在一个h文件中" class="headerlink" title="为什么模板类一般都是放在一个h文件中"></a>为什么模板类一般都是放在一个h文件中</h1><ul>
<li>模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。</li>
</ul>
<p>所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<ul>
<li>在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。</li>
</ul>
<p>所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。</p>
<p>然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。</p>
<h1 id="cout和printf有什么区别？"><a href="#cout和printf有什么区别？" class="headerlink" title="cout和printf有什么区别？"></a>cout和printf有什么区别？</h1><p>cout&lt;&lt;是一个函数，cout&lt;&lt;后可以跟不同的类型是因为cout&lt;&lt;已存在针对各种类型数据的重载，所以会自动识别数据的类型。输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。</p>
<p>cout是有缓冲输出:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt; &lt; <span class="string">&quot;abc &quot;</span> &lt; &lt;endl;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt; &lt; <span class="string">&quot;abc\n &quot;</span>;cout &lt; &lt;flush; 这两个才是一样的.</span><br></pre></td></tr></table></figure>
<p>flush立即强迫缓冲输出。<br>printf是无缓冲输出。有输出时立即输出</p>
<h1 id="当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>当程序中有函数重载时，函数的匹配原则和顺序是什么？</h1><ul>
<li><p>名字查找</p>
</li>
<li><p>确定候选函数</p>
</li>
<li><p>寻找最佳匹配</p>
</li>
</ul>
<h1 id="定义和声明的区别"><a href="#定义和声明的区别" class="headerlink" title="定义和声明的区别"></a>定义和声明的区别</h1><p>如果是指变量的声明和定义<br>从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</p>
<p>如果是指函数的声明和定义<br>声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。<br>定义：一般在源文件里，具体就是函数的实现过程 写明函数体。</p>
<h1 id="说一下你理解的-ifdef-endif代表着什么？"><a href="#说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="说一下你理解的 ifdef   endif代表着什么？"></a>说一下你理解的 ifdef   endif代表着什么？</h1><ul>
<li><p>一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</p>
</li>
<li><p>条件编译命令最常见的形式为：</p>
</li>
</ul>
<p>#ifdef 标识符<br> 程序段1<br> #else<br> 程序段2<br> #endif<br>它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。<br>其中#else部分也可以没有，即：</p>
<p> #ifdef<br> 程序段1<br> #denif</p>
<ul>
<li>在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。</li>
</ul>
<p>在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。</p>
<h1 id="隐式转换，如何消除隐式转换？"><a href="#隐式转换，如何消除隐式转换？" class="headerlink" title="隐式转换，如何消除隐式转换？"></a>隐式转换，如何消除隐式转换？</h1><p>1、C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换</p>
<p>2、C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值和布尔类型的转换，整数和浮点数的转换等。</p>
<p>某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。</p>
<p>3、 基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从小-&gt;大的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。</p>
<p>4、 C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p>
<p>5、如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</p>
<h1 id="迭代器：-it、it-哪个好，为什么"><a href="#迭代器：-it、it-哪个好，为什么" class="headerlink" title="迭代器：++it、it++哪个好，为什么"></a>迭代器：++it、it++哪个好，为什么</h1><ul>
<li>前置返回一个引用，后置返回一个对象</li>
</ul>
<p>// ++i实现代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>++()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i++实现代码为：                 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>++(<span class="type">int</span>)                 </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp = *<span class="keyword">this</span>;                   </span><br><span class="line"></span><br><span class="line">   ++*<span class="keyword">this</span>;                       </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;                  </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="C-如何处理多个异常的？"><a href="#C-如何处理多个异常的？" class="headerlink" title="C++如何处理多个异常的？"></a>C++如何处理多个异常的？</h1><ul>
<li><p>C++中的异常情况：<br>  语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。<br>  运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。</p>
</li>
<li><p>C++异常处理机制：<br>  异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。<br>  C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获)<br>  抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。</p>
</li>
</ul>
<p>~cpptry  {  可能抛出异常的语句；（检查）  }  catch（类型名[形参名]）//捕获特定类型的异常  {  //处理1；}  catch（类型名[形参名]）//捕获特定类型的异常  {  //处理2；}  catch（…）//捕获所有类型的异常  {  }~</p>
<h1 id="模板和实现可不可以不写在一个文件里面？为什么？"><a href="#模板和实现可不可以不写在一个文件里面？为什么？" class="headerlink" title="模板和实现可不可以不写在一个文件里面？为什么？"></a>模板和实现可不可以不写在一个文件里面？为什么？</h1><p>因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。</p>
<p>但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。<br>《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，</p>
<p>它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<h1 id="在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h1><p>1、在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p>
<p>2、为什么是不可预期的问题？</p>
<p>delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。</p>
<p>此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p>
<p>3、 如果在类的析构函数中调用delete this，会发生什么？</p>
<p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h1 id="如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>如何在不使用额外空间的情况下，交换两个数？你有几种方法</h1><ul>
<li>算术</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x + y;</span><br><span class="line"> y = x - y;</span><br><span class="line"></span><br><span class="line">x = x - y; </span><br></pre></td></tr></table></figure>
<ul>
<li>异或</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x^y;<span class="comment">// 只能对int,char..</span></span><br><span class="line"> y = x^y;</span><br><span class="line"> x = x^y;</span><br><span class="line"> x ^= y ^= x;</span><br></pre></td></tr></table></figure>
<h1 id="你知道strcpy和memcpy的区别是什么吗？"><a href="#你知道strcpy和memcpy的区别是什么吗？" class="headerlink" title="你知道strcpy和memcpy的区别是什么吗？"></a>你知道strcpy和memcpy的区别是什么吗？</h1><ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li>
</ol>
<h1 id="程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><a href="#程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？" class="headerlink" title="程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？"></a>程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</h1><p>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</p>
<p>char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。</p>
<h1 id="你知道const-char-与string之间的关系是什么吗？"><a href="#你知道const-char-与string之间的关系是什么吗？" class="headerlink" title="你知道const char* 与string之间的关系是什么吗？"></a>你知道const char* 与string之间的关系是什么吗？</h1><ul>
<li><p>string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化</p>
</li>
<li><p>三者的转化关系如下所示：</p>
</li>
</ul>
<p>a)  string转const char* </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = “abc”; </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = s.<span class="built_in">c_str</span>(); </span><br></pre></td></tr></table></figure>
<p>b)  const char* 转string，直接赋值即可 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = “abc”; </span><br><span class="line"> <span class="function">string <span class="title">s</span><span class="params">(c_s)</span></span>; </span><br></pre></td></tr></table></figure>
<p>c)  string 转char* </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s = “abc”; </span><br><span class="line"><span class="type">char</span>* c; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = s.<span class="built_in">length</span>(); </span><br><span class="line">c = <span class="keyword">new</span> <span class="type">char</span>[len<span class="number">+1</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(c,s.<span class="built_in">c_str</span>()); </span><br></pre></td></tr></table></figure>
<p>d)  char* 转string </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* c = “abc”; </span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(c)</span></span>; </span><br></pre></td></tr></table></figure>
<p>e)  const char<em> 转char</em> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cpc = “abc”; </span><br><span class="line"><span class="type">char</span>* pc = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cpc)<span class="number">+1</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(pc,cpc);</span><br></pre></td></tr></table></figure>
<p>f)  char<em> 转const char</em>，直接赋值即可 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* pc = “abc”; </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cpc = pc;</span><br></pre></td></tr></table></figure>
<h1 id="为什么拷贝构造函数必须传引用不能传值？"><a href="#为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="为什么拷贝构造函数必须传引用不能传值？"></a>为什么拷贝构造函数必须传引用不能传值？</h1><ul>
<li>拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。</li>
<li>参数传递过程到底发生了什么？<ul>
<li>将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)！</li>
</ul>
</li>
<li>值传递:<ul>
<li>对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；</li>
<li>对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；</li>
</ul>
</li>
</ul>
<p>如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用</p>
<p>ii)引用传递:<br>  无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).<br>上述1) 2)回答了为什么拷贝构造函数使用值传递会产生无限递归调用，内存溢出。</p>
<p>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。</p>
<h1 id="你知道空类的大小是多少吗？"><a href="#你知道空类的大小是多少吗？" class="headerlink" title="你知道空类的大小是多少吗？"></a>你知道空类的大小是多少吗？</h1><ul>
<li>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</li>
<li>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</li>
<li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；</li>
<li>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。</li>
</ul>
<h1 id="this指针调用成员变量时，堆栈会发生什么变化？"><a href="#this指针调用成员变量时，堆栈会发生什么变化？" class="headerlink" title="this指针调用成员变量时，堆栈会发生什么变化？"></a>this指针调用成员变量时，堆栈会发生什么变化？</h1><p>当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。</p>
<p>即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。</p>
<p>例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</p>
<h1 id="你知道静态绑定和动态绑定吗？讲讲？"><a href="#你知道静态绑定和动态绑定吗？讲讲？" class="headerlink" title="你知道静态绑定和动态绑定吗？讲讲？"></a>你知道静态绑定和动态绑定吗？讲讲？</h1><ul>
<li><p>对象的静态类型：对象在声明时采用的类型。是在编译期确定的。</p>
</li>
<li><p>对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</p>
</li>
<li><p>静态绑定：绑定的是对象的静态类型，某特性（比如函数依赖于对象的静态类型，发生在编译期。</p>
</li>
<li><p>动态绑定：绑定的是对象的动态类型，某特性（比如函数依赖于对象的动态类型，发生在运行期。</p>
</li>
</ul>
<h1 id="如何设计一个类计算子类的个数？"><a href="#如何设计一个类计算子类的个数？" class="headerlink" title="如何设计一个类计算子类的个数？"></a>如何设计一个类计算子类的个数？</h1><ul>
<li>为类设计一个static静态变量count作为计数器；</li>
<li>类定义结束后初始化count;</li>
<li>在构造函数中对count进行+1;</li>
<li>设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</li>
<li>设计复制构造函数，在进行复制函数中对count+1操作；</li>
<li>在析构函数中对count进行-1；</li>
</ul>
<h1 id="怎么快速定位错误出现的地方"><a href="#怎么快速定位错误出现的地方" class="headerlink" title="怎么快速定位错误出现的地方"></a>怎么快速定位错误出现的地方</h1><p>1、如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。</p>
<p>2、对于复杂的模板错误，最好使用生成输出窗口。</p>
<p>多数情况下出发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析了。</p>
<h1 id="类对象的大小受哪些因素影响？"><a href="#类对象的大小受哪些因素影响？" class="headerlink" title="类对象的大小受哪些因素影响？"></a>类对象的大小受哪些因素影响？</h1><ul>
<li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</li>
<li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</li>
<li>虚函数的话，会在类对象插入vptr指针，加上指针大小；</li>
<li>当该该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</li>
</ul>
<h1 id="移动构造函数听说过吗？说说"><a href="#移动构造函数听说过吗？说说" class="headerlink" title="移动构造函数听说过吗？说说"></a>移动构造函数听说过吗？说说</h1><ul>
<li>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</li>
<li>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</li>
<li>C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</li>
<li>与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。</li>
</ul>
<p>这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；</p>
<p>5)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Example6</span> (Example6&amp;&amp; x) : <span class="built_in">ptr</span>(x.ptr) </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    x.ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move assignment</span></span><br><span class="line"></span><br><span class="line">  Example6&amp; <span class="keyword">operator</span>= (Example6&amp;&amp; x) </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> ptr; </span><br><span class="line"></span><br><span class="line">   ptr = x.ptr;</span><br><span class="line"></span><br><span class="line">   x.ptr=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="什么时候合成构造函数？都说一说，你知道的都说一下"><a href="#什么时候合成构造函数？都说一说，你知道的都说一下" class="headerlink" title="什么时候合成构造函数？都说一说，你知道的都说一下"></a>什么时候合成构造函数？都说一说，你知道的都说一下</h1><ul>
<li>如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；</li>
<li>没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；</li>
<li>带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；</li>
<li>带有一个虚基类的类</li>
</ul>
<p>还有一点需要注意的是：</p>
<ul>
<li>并不是任何没有构造函数的类都会合成一个构造函数</li>
<li>编译器合成出来的构造函数并不会显示设定类内的每一个成员变量</li>
</ul>
<h1 id="那什么时候需要合成拷贝构造函数呢？"><a href="#那什么时候需要合成拷贝构造函数呢？" class="headerlink" title="那什么时候需要合成拷贝构造函数呢？"></a>那什么时候需要合成拷贝构造函数呢？</h1><p>有三种情况会以一个对象的内容作为另一个对象的初值：</p>
<ul>
<li>对一个对象做显示的初始化操作，X xx = x;</li>
<li>当对象被当做参数交给某个函数时；</li>
<li><p>当函数传回一个类对象时；</p>
</li>
<li><p>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；</p>
</li>
<li>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；</li>
</ul>
<h1 id="说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>说一说strcpy、sprintf与memcpy这三个函数的不同之处</h1><ul>
<li>操作对象不同<ul>
<li>strcpy的两个操作对象均为字符串</li>
<li>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</li>
<li>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</li>
</ul>
</li>
<li>执行效率不同<ul>
<li>memcpy最高，strcpy次之，sprintf的效率最低。</li>
</ul>
</li>
<li>实现功能不同<ul>
<li>strcpy主要实现字符串变量间的拷贝</li>
<li>sprintf主要实现其他数据类型格式到字符串的转化</li>
<li>memcpy主要是内存块间的拷贝。</li>
</ul>
</li>
</ul>
<h1 id="将引用作为函数参数有哪些好处？"><a href="#将引用作为函数参数有哪些好处？" class="headerlink" title="将引用作为函数参数有哪些好处？"></a>将引用作为函数参数有哪些好处？</h1><ul>
<li>传递引用给函数与传递指针的效果是一样的。</li>
</ul>
<p>这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p>
<ul>
<li>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；</li>
</ul>
<p>而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；</p>
<p>如果传递的是对象，还将调用拷贝构造函数。</p>
<p>因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p>
<ul>
<li>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；</li>
</ul>
<p>另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p>
<h1 id="如何阻止一个类被实例化？有哪些方法？"><a href="#如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="如何阻止一个类被实例化？有哪些方法？"></a>如何阻止一个类被实例化？有哪些方法？</h1><ul>
<li>将类定义为抽象基类或者将构造函数声明为private；</li>
<li>不允许类外部创建类对象，只能在类内部创建对象</li>
</ul>
<h1 id="strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>strcpy函数和strncpy函数的区别？哪个函数更安全？</h1><ul>
<li>函数原型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* strDest, <span class="type">const</span> <span class="type">char</span>* strSrc)</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strncpy</span><span class="params">(<span class="type">char</span>* strDest, <span class="type">const</span> <span class="type">char</span>* strSrc, <span class="type">int</span> pos)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。<br>  strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。</p>
</li>
<li><p>如果目标长&gt;指定长&gt;源长，则将源长全部拷贝到目标长，自动加上’\0’<br>  如果指定长&lt;源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’  如果指定长&gt;目标长，运行时错误 ；</p>
</li>
</ul>
<h1 id="你知道回调函数吗？它的作用？"><a href="#你知道回调函数吗？它的作用？" class="headerlink" title="你知道回调函数吗？它的作用？"></a>你知道回调函数吗？它的作用？</h1><ul>
<li>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；</li>
<li>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；</li>
<li>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</li>
<li>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</li>
</ul>
<h1 id="动态编译与静态编译"><a href="#动态编译与静态编译" class="headerlink" title="动态编译与静态编译"></a>动态编译与静态编译</h1><ul>
<li><p>静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</p>
</li>
<li><p>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。</p>
</li>
</ul>
<p>缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%A7%AF%E7%B4%AF/" rel="tag"># 积累</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/06/Cannon%E5%92%8CStencil%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/" rel="prev" title="Cannon算法和Stencil计算">
      <i class="fa fa-chevron-left"></i> Cannon算法和Stencil计算
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/12/gloo/" rel="next" title="gloo介绍">
      gloo介绍 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-C-C"><span class="nav-number">1.</span> <span class="nav-text">1. 语言基础 (C&#x2F;C++)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%880%EF%BC%89-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">（0） 指针和引用的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%9C%A8%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89-%E5%A0%86%E5%92%8C%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">（2） 堆和栈有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%A0%86%E5%BF%AB%E4%B8%80%E7%82%B9%E8%BF%98%E6%98%AF%E6%A0%88%E5%BF%AB%E4%B8%80%E7%82%B9%EF%BC%9F%EF%BC%88%E5%AD%97%E8%8A%82%E6%8F%90%E5%89%8D%E6%89%B9%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="nav-number">1.0.0.4.</span> <span class="nav-text">（3）堆快一点还是栈快一点？（字节提前批一面）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89-new%E5%92%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8Cnew-%E4%B8%8E-malloc%E7%9A%84%E5%BC%82%E5%90%8C%E5%A4%84"><span class="nav-number">1.0.0.5.</span> <span class="nav-text">（4） new和delete是如何实现的，new 与 malloc的异同处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86malloc-free%EF%BC%8CC-%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81new-delete%E5%91%A2%EF%BC%9F"><span class="nav-number">1.0.0.6.</span> <span class="nav-text">（5）既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89-C%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.0.7.</span> <span class="nav-text">（6） C和C++的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%887%EF%BC%89delete%E5%92%8Cdelete-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.0.8.</span> <span class="nav-text">（7）delete和delete[]的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%888%EF%BC%89-C-%E3%80%81Java%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%AD%89%EF%BC%88java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="nav-number">1.0.0.9.</span> <span class="nav-text">（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%889%EF%BC%89C-%E5%92%8Cpython%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.0.10.</span> <span class="nav-text">（9）C++和python的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89-Struct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.0.11.</span> <span class="nav-text">（10） Struct和class的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8811%EF%BC%89-define-%E5%92%8Cconst%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%88%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%81%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%AD%89%EF%BC%89"><span class="nav-number">1.0.0.12.</span> <span class="nav-text">（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8812%EF%BC%89-%E5%9C%A8C-%E4%B8%ADconst%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%94%A8%E9%80%94%EF%BC%89"><span class="nav-number">1.0.0.13.</span> <span class="nav-text">（12） 在C++中const的用法（定义，用途）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8813%EF%BC%89-C-%E4%B8%AD%E7%9A%84static%E7%94%A8%E6%B3%95%E5%92%8C%E6%84%8F%E4%B9%89"><span class="nav-number">1.0.0.14.</span> <span class="nav-text">（13） C++中的static用法和意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8814%EF%BC%89-%E8%AE%A1%E7%AE%97%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9A"><span class="nav-number">1.0.0.15.</span> <span class="nav-text">（14） 计算下面几个类的大小：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8815%EF%BC%89-C-%E7%9A%84STL%E4%BB%8B%E7%BB%8D%EF%BC%88%E8%BF%99%E4%B8%AA%E7%B3%BB%E5%88%97%E4%B9%9F%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%BE%AF%E6%8D%B7%E8%80%81%E5%B8%88%E7%9A%84%E8%BF%99%E6%96%B9%E9%9D%A2%E7%9A%84%E4%B9%A6%E7%B1%8D%E4%B8%8E%E8%A7%86%E9%A2%91%EF%BC%89%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8C%85%E6%8B%AC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86allocator%EF%BC%8C%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9C%BA%E7%90%86%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%AD%89"><span class="nav-number">1.0.0.16.</span> <span class="nav-text">（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8816%EF%BC%89-STL%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84hash%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.0.0.17.</span> <span class="nav-text">（16） STL源码中的hash表的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8817%EF%BC%89%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.0.0.18.</span> <span class="nav-text">（17）解决哈希冲突的方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8818%EF%BC%89-STL%E4%B8%ADunordered-map%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.0.19.</span> <span class="nav-text">（18） STL中unordered_map和map的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8819%EF%BC%89-STL%E4%B8%ADvector%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.0.0.20.</span> <span class="nav-text">（19） STL中vector的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8820%EF%BC%89-vector%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%E5%8F%8A%E5%85%B6%E5%8E%9F%E5%9B%A0%EF%BC%8C%E9%A2%91%E7%B9%81%E5%AF%B9vector%E8%B0%83%E7%94%A8push-back-%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%E5%92%8C%E5%8E%9F%E5%9B%A0%E3%80%82"><span class="nav-number">1.0.0.21.</span> <span class="nav-text">（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8821%EF%BC%89C-%E4%B8%ADvector%E5%92%8Clist%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.0.22.</span> <span class="nav-text">（21）C++中vector和list的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8822%EF%BC%89-C-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">1.0.0.23.</span> <span class="nav-text">（22） C++中的重载和重写的区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8823%EF%BC%89-C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E7%83%AD%E9%97%A8%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-number">1.0.0.24.</span> <span class="nav-text">（23） C ++内存管理（热门问题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8824%EF%BC%89-%E4%BB%8B%E7%BB%8D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E6%AF%8F%E4%B8%80%E4%B8%AA%E3%80%82"><span class="nav-number">1.0.0.25.</span> <span class="nav-text">（24） 介绍面向对象的三大特性，并且举例说明每一个。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8825%EF%BC%89-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%92%8C%E4%B8%8B%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B8%80%E8%B5%B7%E5%9B%9E%E7%AD%94%EF%BC%89"><span class="nav-number">1.0.0.26.</span> <span class="nav-text">（25） 多态的实现（和下个问题一起回答）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8826%EF%BC%89-C-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%EF%BC%88%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E7%83%AD%E9%97%A8%EF%BC%8C%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">1.0.0.27.</span> <span class="nav-text">（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8827%EF%BC%89-%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E5%99%A8%E5%A4%84%E7%90%86%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">1.0.0.28.</span> <span class="nav-text">（27） 实现编译器处理虚函数表应该如何处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8828%EF%BC%89-%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.0.0.29.</span> <span class="nav-text">（28） 基类的析构函数一般写成虚函数的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8829%EF%BC%89-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E8%88%AC%E4%B8%8D%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.0.30.</span> <span class="nav-text">（29） 构造函数为什么一般不定义为虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8830%EF%BC%89-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="nav-number">1.0.0.31.</span> <span class="nav-text">（30） 构造函数或者析构函数中调用虚函数会怎样</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8831%EF%BC%89-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.0.32.</span> <span class="nav-text">（31） 纯虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8832%EF%BC%89-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.0.0.33.</span> <span class="nav-text">（32） 静态绑定和动态绑定的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8833%EF%BC%89-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%89"><span class="nav-number">1.0.0.34.</span> <span class="nav-text">（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8834%EF%BC%89-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">1.0.0.35.</span> <span class="nav-text">（34） 对象复用的了解，零拷贝的了解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8835%EF%BC%89-%E4%BB%8B%E7%BB%8DC-%E6%89%80%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.0.36.</span> <span class="nav-text">（35） 介绍C++所有的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8836%EF%BC%89-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%89"><span class="nav-number">1.0.0.37.</span> <span class="nav-text">（36） 什么情况下会调用拷贝构造函数（三种情况）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8837%EF%BC%89-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%92%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="nav-number">1.0.0.38.</span> <span class="nav-text">（37） 结构体内存对齐方式和为什么要进行内存对齐？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8838%EF%BC%89-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-number">1.0.0.39.</span> <span class="nav-text">（38） 内存泄露的定义，如何检测与避免？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8839%EF%BC%89-C-%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.0.0.40.</span> <span class="nav-text">（39） C++的智能指针有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8840%EF%BC%89-%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.0.0.41.</span> <span class="nav-text">（40） 调试程序的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8841%EF%BC%89-%E9%81%87%E5%88%B0coredump%E8%A6%81%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95"><span class="nav-number">1.0.0.42.</span> <span class="nav-text">（41） 遇到coredump要怎么调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8842%EF%BC%89-inline%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%B4%E4%B8%80%E4%B8%8B-%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.0.43.</span> <span class="nav-text">（42） inline关键字说一下 和宏定义有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8843%EF%BC%89-%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.0.0.44.</span> <span class="nav-text">（43） 模板的用法与适用场景 实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8844%EF%BC%89-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%BC%9A%E5%BF%AB%E4%B8%80%E4%BA%9B%EF%BC%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF%EF%BC%89%EF%BC%9F"><span class="nav-number">1.0.0.45.</span> <span class="nav-text">（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8845%EF%BC%89-%E7%94%A8%E8%BF%87C11%E5%90%97%EF%BC%8C%E7%9F%A5%E9%81%93C11%E6%96%B0%E7%89%B9%E6%80%A7%E5%90%97%EF%BC%9F%EF%BC%88%E6%9C%89%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BB%BA%E8%AE%AE%E7%86%9F%E6%82%89C11%EF%BC%89"><span class="nav-number">1.0.0.46.</span> <span class="nav-text">（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8846%EF%BC%89-C-%E7%9A%84%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B%EF%BC%88%E7%AE%80%E5%8D%95%E4%B8%80%E7%82%B9C-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%8B%E6%A0%88%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="nav-number">1.0.0.47.</span> <span class="nav-text">（46） C++的调用惯例（简单一点C++函数调用的压栈过程）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8847%EF%BC%89-C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.0.0.48.</span> <span class="nav-text">（47） C++的四种强制转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8848%EF%BC%89string%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.0.0.49.</span> <span class="nav-text">（48）string的底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8849%EF%BC%89%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B%E6%88%96%E8%80%85%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-number">1.0.0.50.</span> <span class="nav-text">（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8850%EF%BC%89set%EF%BC%8Cmap%E5%92%8Cvector%E7%9A%84%E6%8F%92%E5%85%A5%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.0.0.51.</span> <span class="nav-text">（50）set，map和vector的插入复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8851%EF%BC%89%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.0.52.</span> <span class="nav-text">（51）定义和声明的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8852%EF%BC%89typdef%E5%92%8Cdefine%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.0.53.</span> <span class="nav-text">（52）typdef和define区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8853%EF%BC%89%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%94%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.0.0.54.</span> <span class="nav-text">（53）被free回收的内存是立即返还给操作系统吗？为什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8854%EF%BC%89%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.0.0.55.</span> <span class="nav-text">（54）引用作为函数参数以及返回值的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8855%EF%BC%89%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="nav-number">1.0.0.56.</span> <span class="nav-text">（55）友元函数和友元类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8856%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.0.0.57.</span> <span class="nav-text">（56） 说一下volatile关键字的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8857%EF%BC%89-STL%E4%B8%AD%E7%9A%84sort-%E7%AE%97%E6%B3%95%E6%98%AF%E7%94%A8%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8Cstable-sort-%E5%91%A2"><span class="nav-number">1.0.0.58.</span> <span class="nav-text">（57） STL中的sort()算法是用什么实现的，stable_sort()呢</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8858%EF%BC%89vector%E4%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-number">1.0.0.59.</span> <span class="nav-text">（58）vector会迭代器失效吗？什么情况下会迭代器失效？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8858%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88C-%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-number">1.0.0.60.</span> <span class="nav-text">（58）为什么C++没有实现垃圾回收？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3"><span class="nav-number">2.</span> <span class="nav-text">2. 计网相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89-%E5%BB%BA%E7%AB%8BTCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%84%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">（1） 建立TCP服务器的各个系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89-%E7%BB%A7%E4%B8%8A%E4%B8%80%E9%A2%98%EF%BC%8C%E8%AF%B4%E6%98%8Esocket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9F%E5%85%B6%E4%B8%ADclose%E6%98%AF%E4%B8%80%E6%AC%A1%E5%B0%B1%E8%83%BD%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%AD%E7%9A%84%E5%90%97%EF%BC%8C%E5%8D%8A%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="nav-number">2.0.0.2.</span> <span class="nav-text">（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89-%E5%AF%B9%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BB%8B%E7%BB%8D%E3%80%82%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEIGP%E5%8C%85%E6%8B%ACRIP%EF%BC%8COSPF%EF%BC%8C%E5%92%8C%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEEGP%E5%92%8CBGP"><span class="nav-number">2.0.0.3.</span> <span class="nav-text">（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89-UDP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">2.0.0.4.</span> <span class="nav-text">（4） UDP如何实现可靠传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.0.0.5.</span> <span class="nav-text">（5） TCP和UDP的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89-TCP%E5%92%8CUDP%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-number">2.0.0.6.</span> <span class="nav-text">（6） TCP和UDP相关的协议与端口号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%887%EF%BC%89-TCP%EF%BC%88UDP%EF%BC%8CIP%EF%BC%89%E7%AD%89%E9%A6%96%E9%83%A8%E7%9A%84%E8%AE%A4%E8%AF%86%EF%BC%88http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E6%9E%84%E6%88%90%EF%BC%89"><span class="nav-number">2.0.0.7.</span> <span class="nav-text">（7） TCP（UDP，IP）等首部的认识（http请求报文构成）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%888%EF%BC%89-%E7%BD%91%E9%A1%B5%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">2.0.0.8.</span> <span class="nav-text">（8） 网页解析的过程与实现方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%889%EF%BC%89-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%A8%E9%83%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E5%A6%82www-baidu-com%EF%BC%89"><span class="nav-number">2.0.0.9.</span> <span class="nav-text">（9）    在浏览器中输入URL后执行的全部过程（如www.baidu.com）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%88%86%E7%89%87%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.0.0.10.</span> <span class="nav-text">（10） 网络层分片的原因与具体实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8811%EF%BC%89-TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%EF%BC%88TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80%E6%98%AF%E7%83%AD%E9%97%A8%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-number">2.0.0.11.</span> <span class="nav-text">（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8812%EF%BC%89-TCP%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E6%AF%8F%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%A4%84%E4%BA%8E%E5%93%AA%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="nav-number">2.0.0.12.</span> <span class="nav-text">（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8813%EF%BC%89-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%EF%BC%9F"><span class="nav-number">2.0.0.13.</span> <span class="nav-text">（13） 为什么使用三次握手，两次握手可不可以？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8814%EF%BC%89-TIME-WAIT%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%AD%89%E4%BA%8E2MSL%EF%BC%89"><span class="nav-number">2.0.0.14.</span> <span class="nav-text">（14） TIME_WAIT的意义（为什么要等于2MSL）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8815%EF%BC%89-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%8D%E5%A4%AA%E9%AB%98%E9%A2%91%EF%BC%89"><span class="nav-number">2.0.0.15.</span> <span class="nav-text">（15） 超时重传机制（不太高频）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8816%EF%BC%89-TCP%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F"><span class="nav-number">2.0.0.16.</span> <span class="nav-text">（16） TCP怎么保证可靠性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8817%EF%BC%89-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%8C%E9%87%87%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%88%E6%AD%BB%E9%94%81%E5%8F%AF%E8%83%BD%EF%BC%8C%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E5%BE%81%EF%BC%89%EF%BC%9F"><span class="nav-number">2.0.0.17.</span> <span class="nav-text">（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8818%EF%BC%89-tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.0.0.18.</span> <span class="nav-text">（18） tcp滑动窗口协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8819%EF%BC%89-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.0.0.19.</span> <span class="nav-text">（19） 拥塞控制和流量控制的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8820%EF%BC%89-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%8C%E7%AE%97%E6%B3%95%E5%90%8D%E5%AD%97%EF%BC%9F%EF%BC%88%E6%9E%81%E5%85%B6%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">2.0.0.20.</span> <span class="nav-text">（20） TCP拥塞控制，算法名字？（极其重要）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8821%EF%BC%89-http%E5%8D%8F%E8%AE%AE%E4%B8%8ETCP%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="nav-number">2.0.0.21.</span> <span class="nav-text">（21） http协议与TCP的区别与联系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8822%EF%BC%89-http-1-0%E5%92%8Chttp-1-1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.0.0.22.</span> <span class="nav-text">（22） http&#x2F;1.0和http&#x2F;1.1的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8823%EF%BC%89-http%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9Fget%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">2.0.0.23.</span> <span class="nav-text">（23） http的请求方法有哪些？get和post的区别。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8824%EF%BC%89-http%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81-403-201%E7%AD%89%E7%AD%89%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">2.0.0.24.</span> <span class="nav-text">（24） http的状态码 403 201等等是什么意思</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8825%EF%BC%89-http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%94%B1http%E5%8D%87%E7%BA%A7%E4%B8%BAhttps%E9%9C%80%E8%A6%81%E5%81%9A%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C"><span class="nav-number">2.0.0.25.</span> <span class="nav-text">（25） http和https的区别，由http升级为https需要做哪些操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8826%EF%BC%89-https%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%80%8E%E4%B9%88%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">2.0.0.26.</span> <span class="nav-text">（26） https的具体实现，怎么确保安全性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8827%EF%BC%89-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%97%B6%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9A%84seq%E5%BA%8F%E5%8F%B7%E6%98%AF%E6%80%8E%E6%A0%B7%E4%BA%A7%E7%94%9F%E7%9A%84"><span class="nav-number">2.0.0.27.</span> <span class="nav-text">（27） TCP三次握手时的第一次的seq序号是怎样产生的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8828%EF%BC%89-%E4%B8%80%E4%B8%AA%E6%9C%BA%E5%99%A8%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%8A%E9%99%90%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%90%97%EF%BC%9F%E9%82%A3%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%B6%85%E8%BF%87%E8%BF%99%E4%B8%AA%E9%99%90%E5%88%B6%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">2.0.0.28.</span> <span class="nav-text">（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8829%EF%BC%89-%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E7%B3%BB"><span class="nav-number">2.0.0.29.</span> <span class="nav-text">（29） 对称密码和非对称密码体系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8830%EF%BC%89-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="nav-number">2.0.0.30.</span> <span class="nav-text">（30） 数字证书的了解（高频）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8831%EF%BC%89-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8Fclose-wait%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">2.0.0.31.</span> <span class="nav-text">（31） 服务器出现大量close_wait的连接的原因以及解决方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8832%EF%BC%89-%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B%EF%BC%8C%E4%BB%8B%E7%BB%8DMD5%E7%AE%97%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88MD5%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%80%86%E7%9A%84%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%8A%A0%E5%BC%BA%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A9%E5%AE%83%E4%B8%8D%E9%82%A3%E4%B9%88%E5%AE%B9%E6%98%93%E8%A2%AB%E7%A0%B4%E8%A7%A3%E5%91%A2%EF%BC%9F%EF%BC%88%E7%99%BE%E5%BA%A6%E5%AE%89%E5%85%A8%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="nav-number">2.0.0.32.</span> <span class="nav-text">（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8833%EF%BC%89-%E5%8D%95%E6%9D%A1%E8%AE%B0%E5%BD%95%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">2.0.0.33.</span> <span class="nav-text">（33） 单条记录高并发访问的优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8834%EF%BC%89-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bping%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%88%86%E5%88%AB%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.0.0.34.</span> <span class="nav-text">（34） 介绍一下ping的过程，分别用到了哪些协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8835%EF%BC%89-TCP-IP%E7%9A%84%E7%B2%98%E5%8C%85%E4%B8%8E%E9%81%BF%E5%85%8D%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="nav-number">2.0.0.35.</span> <span class="nav-text">（35） TCP&#x2F;IP的粘包与避免介绍一下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8836%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8BTCP%E7%9A%84%E5%B0%81%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85"><span class="nav-number">2.0.0.36.</span> <span class="nav-text">（36） 说一下TCP的封包和拆包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8837%EF%BC%89-%E4%B8%80%E4%B8%AAip%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%EF%BC%8C%E9%9D%A0%E4%BB%80%E4%B9%88%E8%AF%86%E5%88%AB%EF%BC%9F"><span class="nav-number">2.0.0.37.</span> <span class="nav-text">（37） 一个ip配置多个域名，靠什么识别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8838%EF%BC%89-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%EF%BC%88DDos%E6%94%BB%E5%87%BB%EF%BC%89"><span class="nav-number">2.0.0.38.</span> <span class="nav-text">（38） 服务器攻击（DDos攻击）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8839%EF%BC%89DNS%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">2.0.0.39.</span> <span class="nav-text">（39）DNS的工作过程和原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8841%EF%BC%89OSA%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.0.0.40.</span> <span class="nav-text">（41）OSA七层协议和五层协议，分别有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8842%EF%BC%89IP%E5%AF%BB%E5%9D%80%E5%92%8CMAC%E5%AF%BB%E5%9D%80%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">2.0.0.41.</span> <span class="nav-text">（42）IP寻址和MAC寻址有什么不同，怎么实现的</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.</span> <span class="nav-text">3. 数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89-%E5%85%B3%E7%B3%BB%E5%9E%8B%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BD%8E%E9%A2%91%EF%BC%89"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">（1） 关系型和非关系型数据库的区别（低频）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BD%8E%E9%A2%91%EF%BC%89"><span class="nav-number">3.0.0.2.</span> <span class="nav-text">（2） 什么是非关系型数据库（低频）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8B-MySQL-%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%86%85%E9%83%A8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">3.0.0.3.</span> <span class="nav-text">（3） 说一下 MySQL 执行一条查询语句的内部执行过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.0.0.4.</span> <span class="nav-text">（4） 数据库的索引类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">3.0.0.5.</span> <span class="nav-text">（5） 说一下事务是怎么实现的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89-MySQL%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%80%8E%E4%B9%88%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">3.0.0.6.</span> <span class="nav-text">（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%887%EF%BC%89-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">3.0.0.7.</span> <span class="nav-text">（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%888%EF%BC%89-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">3.0.0.8.</span> <span class="nav-text">（8） 索引的底层实现（重点）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%889%EF%BC%89-B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">3.0.0.9.</span> <span class="nav-text">（9） B树和B+树的区别（重点）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89-%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80-%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="nav-number">3.0.0.10.</span> <span class="nav-text">（10） 索引最左前缀&#x2F;最左匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8811%EF%BC%89-Mysql%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%8C%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%EF%BC%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%89"><span class="nav-number">3.0.0.11.</span> <span class="nav-text">（11） Mysql的优化（高频，索引优化，性能优化）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8812%EF%BC%89-MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D%EF%BC%8Cinnodb%E5%92%8Cmyisam%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="nav-number">3.0.0.12.</span> <span class="nav-text">（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8813%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%EF%BC%88%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E9%83%BD%E8%A6%81%E8%83%BD%E5%A4%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%8C%E7%90%86%E8%A7%A3%E9%80%8F%E5%BD%BB%EF%BC%8C%E6%AF%94%E5%A6%82%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%85%B3%E8%81%94%EF%BC%8C%E9%9A%94%E7%A6%BB%E6%80%A7%E4%B8%8D%E5%A5%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-number">3.0.0.13.</span> <span class="nav-text">（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8814%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E8%AF%BB%EF%BC%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="nav-number">3.0.0.14.</span> <span class="nav-text">（14）什么是脏读，不可重复读和幻读？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8815%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8Cmysql%E5%92%8COracle%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">3.0.0.15.</span> <span class="nav-text">（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8816%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.0.0.16.</span> <span class="nav-text">（16） 数据库连接池的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8817%EF%BC%89-Mysql%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%90%84%E8%87%AA%E7%89%B9%E7%82%B9"><span class="nav-number">3.0.0.17.</span> <span class="nav-text">（17） Mysql的表空间方式，各自特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8818%EF%BC%89-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">3.0.0.18.</span> <span class="nav-text">（18） 分布式事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8819%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8C%83%E5%BC%8F"><span class="nav-number">3.0.0.19.</span> <span class="nav-text">（19） 数据库的范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8820%EF%BC%89-%E6%95%B0%E6%8D%AE%E7%9A%84%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%8C%E5%8A%A0%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.0.0.20.</span> <span class="nav-text">（20） 数据的锁的种类，加锁的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8821%EF%BC%89-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="nav-number">3.0.0.21.</span> <span class="nav-text">（21） 什么是共享锁和排他锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8822%EF%BC%89-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E7%AE%80%E4%BB%8B"><span class="nav-number">3.0.0.22.</span> <span class="nav-text">（22） 分库分表的理解和简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8823%EF%BC%89"><span class="nav-number">3.0.0.23.</span> <span class="nav-text">（23）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8824%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.0.0.24.</span> <span class="nav-text">（24）数据库高并发的解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8825%EF%BC%89%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B"><span class="nav-number">3.0.0.25.</span> <span class="nav-text">（25）乐观锁与悲观锁解释一下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8826%EF%BC%89%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">3.0.0.26.</span> <span class="nav-text">（26）乐观锁与悲观锁是怎么实现的</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Linux"><span class="nav-number">4.</span> <span class="nav-text">4. Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89-Linux%E7%9A%84I-O%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E8%B6%85%E7%BA%A7%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">4.0.0.1.</span> <span class="nav-text">（1） Linux的I&#x2F;O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88EXT4%EF%BC%8CXFS%EF%BC%8CBTRFS%EF%BC%89"><span class="nav-number">4.0.0.2.</span> <span class="nav-text">（2） 文件系统的理解（EXT4，XFS，BTRFS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89-EPOLL%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BA%86%E8%A7%A3"><span class="nav-number">4.0.0.3.</span> <span class="nav-text">（3） EPOLL的介绍和了解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89-IO%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88select-poll-epoll%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">4.0.0.4.</span> <span class="nav-text">（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89-Epoll%E7%9A%84ET%E6%A8%A1%E5%BC%8F%E5%92%8CLT%E6%A8%A1%E5%BC%8F%EF%BC%88ET%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="nav-number">4.0.0.5.</span> <span class="nav-text">（5） Epoll的ET模式和LT模式（ET的非阻塞）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89-%E6%9F%A5%E8%AF%A2%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8CPU%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%88%E6%B3%A8%E6%84%8F%E8%A6%81%E4%BA%86%E8%A7%A3%E5%88%B0used%EF%BC%8Cbuf%EF%BC%8C%E4%BB%A3%E8%A1%A8%E6%84%8F%E4%B9%89%EF%BC%89"><span class="nav-number">4.0.0.6.</span> <span class="nav-text">（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%887%EF%BC%89-linux%E7%9A%84%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%EF%BC%88kill%EF%BC%8Cfind%EF%BC%8Ccp%E7%AD%89%E7%AD%89%EF%BC%89"><span class="nav-number">4.0.0.7.</span> <span class="nav-text">（7） linux的其他常见命令（kill，find，cp等等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%888%EF%BC%89-shell%E8%84%9A%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">4.0.0.8.</span> <span class="nav-text">（8） shell脚本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%889%EF%BC%89-%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.0.0.9.</span> <span class="nav-text">（9） 硬连接和软连接的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E7%9C%8B%EF%BC%88rwx%EF%BC%89"><span class="nav-number">4.0.0.10.</span> <span class="nav-text">（10） 文件权限怎么看（rwx）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8811%EF%BC%89-%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%97%B6%E9%97%B4%EF%BC%88mtime-atime%EF%BC%8Cctime%EF%BC%89%EF%BC%8C%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%94%B9%E5%8F%98"><span class="nav-number">4.0.0.11.</span> <span class="nav-text">（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8812%EF%BC%89-Linux%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%9F%A5%E7%9C%8B%E7%89%B9%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8D%A0%E7%94%A8%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E6%83%85%E5%86%B5%E5%91%BD%E4%BB%A4"><span class="nav-number">4.0.0.12.</span> <span class="nav-text">（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8813%EF%BC%89Linux%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">4.0.0.13.</span> <span class="nav-text">（13）Linux中线程的同步方式有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8814%EF%BC%89%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90"><span class="nav-number">4.0.0.14.</span> <span class="nav-text">（14）怎么修改一个文件的权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8815%EF%BC%89%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">4.0.0.15.</span> <span class="nav-text">（15）查看文件内容常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8816%EF%BC%89%E6%80%8E%E4%B9%88%E6%89%BE%E5%87%BA%E5%90%AB%E6%9C%89%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%89%8D%E5%90%8E4%E8%A1%8C"><span class="nav-number">4.0.0.16.</span> <span class="nav-text">（16）怎么找出含有关键字的前后4行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8817%EF%BC%89Linux%E7%9A%84GDB%E8%B0%83%E8%AF%95"><span class="nav-number">4.0.0.17.</span> <span class="nav-text">（17）Linux的GDB调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8818%EF%BC%89coredump%E6%98%AF%E4%BB%80%E4%B9%88-%E6%80%8E%E4%B9%88%E6%89%8D%E8%83%BDcoredump"><span class="nav-number">4.0.0.18.</span> <span class="nav-text">（18）coredump是什么 怎么才能coredump</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8819%EF%BC%89tcpdump%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">4.0.0.19.</span> <span class="nav-text">（19）tcpdump常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8820%EF%BC%89-crontab%E5%91%BD%E4%BB%A4"><span class="nav-number">4.0.0.20.</span> <span class="nav-text">（20） crontab命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8821%EF%BC%89-%E6%9F%A5%E7%9C%8B%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.0.0.21.</span> <span class="nav-text">（21） 查看后台进程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.</span> <span class="nav-text">5. 操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">5.0.0.1.</span> <span class="nav-text">（1） 进程与线程的区别和联系（重点）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89-Linux%E7%90%86%E8%AE%BA%E4%B8%8A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3"><span class="nav-number">5.0.0.2.</span> <span class="nav-text">（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%9F%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F%EF%BC%88%E7%99%BE%E5%BA%A6%E5%AE%89%E5%85%A8%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="nav-number">5.0.0.3.</span> <span class="nav-text">（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D-%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">5.0.0.4.</span> <span class="nav-text">（4） 进程之间的通信方法有哪几种 （重点）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.0.0.5.</span> <span class="nav-text">（5） 进程调度方法详细介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%9C%80%E8%A6%81%E5%81%9A%E5%93%AA%E4%BA%9B%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="nav-number">5.0.0.6.</span> <span class="nav-text">（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="nav-number">5.0.0.7.</span> <span class="nav-text">（6） 操作系统的内存管理说一下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%887%EF%BC%89-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU%E7%AE%97%E6%B3%95"><span class="nav-number">5.0.0.8.</span> <span class="nav-text">（7） 实现一个LRU算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%888%EF%BC%89-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%88%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-number">5.0.0.9.</span> <span class="nav-text">（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%888%EF%BC%89-%E6%AD%BB%E9%94%81%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-number">5.0.0.10.</span> <span class="nav-text">（8） 死锁的恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%888%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E9%A5%A5%E9%A5%BF"><span class="nav-number">5.0.0.11.</span> <span class="nav-text">（8）什么是饥饿</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%889%EF%BC%89-%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAmutex%E4%BA%92%E6%96%A5%E9%94%81%E4%BD%A0%E8%A6%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">5.0.0.12.</span> <span class="nav-text">（9） 如果要你实现一个mutex互斥锁你要怎么实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%8F%88%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">5.0.0.13.</span> <span class="nav-text">（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8813%EF%BC%89-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.0.0.14.</span> <span class="nav-text">（13） 什么时候用多进程，什么时候用多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8814%EF%BC%89-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">5.0.0.15.</span> <span class="nav-text">（14） 文件读写使用的系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8815%EF%BC%89-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BD%A2%E6%88%90%E7%9A%84%EF%BC%9F"><span class="nav-number">5.0.0.16.</span> <span class="nav-text">（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8816%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8BPCB-%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">5.0.0.17.</span> <span class="nav-text">（16） 说一下PCB&#x2F;说一下进程地址空间&#x2F;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8817%EF%BC%89-%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%98%AF%E6%80%8E%E6%A0%B7%E5%8C%BA%E5%88%86%E7%9A%84"><span class="nav-number">5.0.0.18.</span> <span class="nav-text">（17） 内核空间和用户空间是怎样区分的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8818%EF%BC%89-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%88%E5%B0%A4%E5%85%B6%E6%98%AF%E5%A6%82%E6%9E%9C%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BE%88%E5%A4%A7%E5%8F%AF%E8%83%BD%E4%BC%9A%E7%BB%93%E5%90%88%E8%AE%A8%E8%AE%BA%EF%BC%89"><span class="nav-number">5.0.0.19.</span> <span class="nav-text">（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8819%EF%BC%89-%E5%90%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%86%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%BC%9A%E5%85%B1%E4%BA%AB%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="nav-number">5.0.0.20.</span> <span class="nav-text">（19） 同一个进程内的线程会共享什么资源？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8820%EF%BC%89-%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.0.0.21.</span> <span class="nav-text">（20） 异常和中断的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8821%EF%BC%89-%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E5%9C%A8Linux-windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">5.0.0.22.</span> <span class="nav-text">（21） 一般情况下在Linux&#x2F;windows平台下栈空间的大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8822%EF%BC%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">5.0.0.23.</span> <span class="nav-text">（22）虚拟内存的了解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8823%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">5.0.0.24.</span> <span class="nav-text">（23）服务器高并发的解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8824%EF%BC%89%E5%8D%8F%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="nav-number">5.0.0.25.</span> <span class="nav-text">（24）协程了解吗（高频）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8825%EF%BC%89%E9%82%A3%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="nav-number">5.0.0.26.</span> <span class="nav-text">（25）那协程的底层是怎么实现的，怎么使用协程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8823%EF%BC%89%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="nav-number">5.0.0.27.</span> <span class="nav-text">（23）进程的状态以及转换图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8824%EF%BC%89%E5%9C%A8%E6%89%A7%E8%A1%8Cmalloc%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%B4%E4%B8%80%E4%B8%8B-malloc%E5%87%BD%E6%95%B0%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-%E8%BF%9B%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%EF%BC%9F"><span class="nav-number">5.0.0.28.</span> <span class="nav-text">（24）在执行malloc申请内存的时候，操作系统是怎么做的？&#x2F;内存分配的原理说一下&#x2F;malloc函数底层是怎么实现的？&#x2F;进程是怎么分配内存的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8825%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E6%98%AF%E5%A4%A7%E7%AB%AF%E8%BF%98%E6%98%AF%E5%B0%8F%E7%AB%AF%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">5.0.0.29.</span> <span class="nav-text">（25）什么是字节序？怎么判断是大端还是小端？有什么用？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%9C%BA%E6%99%AF%E9%A2%98-%E7%AE%97%E6%B3%95%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text">6. 场景题&#x2F;算法题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%880%EF%BC%89-leetcode-hot100%E8%87%B3%E5%B0%91%E5%88%B7%E4%B8%A4%E9%81%8D%EF%BC%8C%E5%89%91%E6%8C%87offer%E8%87%B3%E5%B0%91%E5%88%B7%E4%B8%A4%E9%81%8D-%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D%EF%BC%81%EF%BC%81"><span class="nav-number">6.0.0.1.</span> <span class="nav-text">（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89-%E4%BB%8B%E7%BB%8D%E7%86%9F%E6%82%89%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%95%E4%BE%8B%EF%BC%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">6.0.0.2.</span> <span class="nav-text">（1） 介绍熟悉的设计模式（单例，简单工厂模式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89-%E5%86%99%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%88%E6%9C%AC"><span class="nav-number">6.0.0.3.</span> <span class="nav-text">（2） 写单例模式，线程安全版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89-%E5%86%99%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0ABC"><span class="nav-number">6.0.0.4.</span> <span class="nav-text">（3） 写三个线程交替打印ABC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89-%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B-%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="nav-number">6.0.0.5.</span> <span class="nav-text">（4） 二维码登录的实现过程 场景题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89-%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0swap%E5%87%BD%E6%95%B0"><span class="nav-number">6.0.0.6.</span> <span class="nav-text">（5） 不使用临时变量实现swap函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%886%EF%BC%89-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAstrcpy%E5%87%BD%E6%95%B0%EF%BC%88%E6%88%96%E8%80%85memcpy%EF%BC%89%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%86%85%E5%AD%98%E5%8F%AF%E8%83%BD%E9%87%8D%E5%8F%A0%E5%91%A2"><span class="nav-number">6.0.0.7.</span> <span class="nav-text">（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%887%EF%BC%89-%E5%AE%9E%E7%8E%B0%E5%BF%AB%E6%8E%92"><span class="nav-number">6.0.0.8.</span> <span class="nav-text">（7） 实现快排</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%888%EF%BC%89-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">6.0.0.9.</span> <span class="nav-text">（8） 实现一个堆排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%888%EF%BC%89-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">6.0.0.10.</span> <span class="nav-text">（8） 实现一个插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%889%EF%BC%89-%E5%BF%AB%E6%8E%92%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="nav-number">6.0.0.11.</span> <span class="nav-text">（9） 快排存在的问题，如何优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89-%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8B%9B%E9%93%B6%E7%BD%91%E7%BB%9C%E4%BA%8C%E9%9D%A2%EF%BC%89"><span class="nav-number">6.0.0.12.</span> <span class="nav-text">（10） 反转一个链表（招银网络二面）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8811%EF%BC%89-Top-K%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%AF%E4%BB%A5%E9%87%87%E5%8F%96%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%90%84%E8%87%AA%E4%BC%98%E7%82%B9%EF%BC%9F%EF%BC%89%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">6.0.0.13.</span> <span class="nav-text">（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8812%EF%BC%89-8G%E7%9A%84int%E5%9E%8B%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%AA%E6%9C%892G%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AF%B9%E5%AE%83%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%EF%BC%9F%EF%BC%88%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%EF%BC%89%EF%BC%88%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="nav-number">6.0.0.14.</span> <span class="nav-text">（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8813%EF%BC%89-%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BA%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%B8%A6%E6%9C%89null%E6%A0%87%E8%AE%B0%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="nav-number">6.0.0.15.</span> <span class="nav-text">（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8814%EF%BC%89-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bb%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">6.0.0.16.</span> <span class="nav-text">（14） 介绍一下b树和它的应用场景有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8815%EF%BC%89-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bb-%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">6.0.0.17.</span> <span class="nav-text">（15） 介绍一下b+树和它的应用场景有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8816%EF%BC%89-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">6.0.0.18.</span> <span class="nav-text">（16） 介绍一下红黑树和它的应用场景有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8817%EF%BC%89-%E6%80%8E%E4%B9%88%E5%86%99sql%E5%8F%96%E8%A1%A8%E7%9A%84%E5%89%8D1000%E8%A1%8C%E6%95%B0%E6%8D%AE%EF%BC%88%E6%8B%9B%E9%93%B6%E7%BD%91%E7%BB%9C%E4%BA%8C%E9%9D%A2%EF%BC%89"><span class="nav-number">6.0.0.19.</span> <span class="nav-text">（17） 怎么写sql取表的前1000行数据（招银网络二面）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8818%EF%BC%89-N%E4%B8%AA%E9%AA%B0%E5%AD%90%E5%87%BA%E7%8E%B0%E5%92%8C%E4%B8%BAm%E7%9A%84%E6%A6%82%E7%8E%87"><span class="nav-number">6.0.0.20.</span> <span class="nav-text">（18） N个骰子出现和为m的概率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8819%EF%BC%89-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%AF%E5%8F%82%E8%80%83%E5%B7%A6%E7%A5%9E%E7%9A%84%E4%B9%A6%EF%BC%89"><span class="nav-number">6.0.0.21.</span> <span class="nav-text">（19） 海量数据问题（可参考左神的书）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8820%EF%BC%89-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-number">6.0.0.22.</span> <span class="nav-text">（20） 一致性哈希</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8821%EF%BC%89%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E8%AF%B4%E4%B8%80%E4%B8%8B-%E6%89%8B%E6%92%95"><span class="nav-number">6.0.0.23.</span> <span class="nav-text">（21）希尔排序说一下&#x2F;手撕</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8822%EF%BC%89Dijkstra%E7%AE%97%E6%B3%95%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="nav-number">6.0.0.24.</span> <span class="nav-text">（22）Dijkstra算法说一下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8823%EF%BC%89%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E8%A6%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%AF%B4%E6%80%9D%E8%B7%AF%EF%BC%88%E8%85%BE%E8%AE%AFteg%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="nav-number">6.0.0.25.</span> <span class="nav-text">（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8824%EF%BC%89%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="nav-number">6.0.0.26.</span> <span class="nav-text">（24）最小生成树算法说一下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8825%EF%BC%89-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84bitmap%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86"><span class="nav-number">6.0.0.27.</span> <span class="nav-text">（25） 海量数据的bitmap使用原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8826%EF%BC%89-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E7%82%B9"><span class="nav-number">6.0.0.28.</span> <span class="nav-text">（26） 布隆过滤器原理与优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8827%EF%BC%89-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A4%84%E7%90%86%E5%A4%A7%E8%A7%84%E6%A8%A1%E9%97%AE%E9%A2%98%E6%97%B6%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%8F%97%E9%99%90%E3%80%81%E7%A3%81%E7%9B%98%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA%E9%97%AE%E9%A2%98"><span class="nav-number">6.0.0.29.</span> <span class="nav-text">（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8828%EF%BC%89%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BD%BF%E5%AE%83%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88%E9%98%BF%E9%87%8C%E4%B8%89%E9%9D%A2%EF%BC%89"><span class="nav-number">6.0.0.30.</span> <span class="nav-text">（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8main%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">在main执行之前和之后执行的代码可能是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">结构体内存对齐问题？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">指针和引用的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.</span> <span class="nav-text">堆和栈的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E4%BB%A5%E4%B8%8B%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">区别以下指针类型？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Ctypedef%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">宏定义和typedef区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">变量声明和定义区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%AA%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E5%BF%85%E9%A1%BB%E7%94%A8%E5%88%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">哪几种情况必须用到初始化成员列表？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#a%E5%92%8C-amp-a%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">a和&amp;a有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">16.</span> <span class="nav-text">迭代器失效的情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">17.</span> <span class="nav-text">C和C++的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">18.</span> <span class="nav-text">C++中struct和class的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#define%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">19.</span> <span class="nav-text">define宏定义和const的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final%E5%92%8Coverride%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">20.</span> <span class="nav-text">final和override关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">21.</span> <span class="nav-text">拷贝初始化和直接初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">22.</span> <span class="nav-text">初始化和赋值的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">23.</span> <span class="nav-text">模板函数和模板类的特例化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E5%92%8CC-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="nav-number">24.</span> <span class="nav-text">C和C++的类型安全</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">25.</span> <span class="nav-text">C++有哪几种的构造函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">26.</span> <span class="nav-text">浅拷贝和深拷贝的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#auto-decltype%E5%92%8Cdecltype-auto-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">27.</span> <span class="nav-text">auto decltype和decltype(auto)的用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E4%B8%ADNULL%E5%92%8Cnullptr%E5%8C%BA%E5%88%AB"><span class="nav-number">28.</span> <span class="nav-text">C++中NULL和nullptr区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8EC-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="nav-number">29.</span> <span class="nav-text">简要说明C++的内存分区</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">30.</span> <span class="nav-text">C++的异常处理的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">31.</span> <span class="nav-text">静态变量什么时候初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%95%88%E7%8E%87"><span class="nav-number">32.</span> <span class="nav-text">值传递、指针传递、引用传递的区别和效率</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B1%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">33.</span> <span class="nav-text">什么是内存池，如何实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E6%B1%87%E7%BC%96%E5%B1%82%E5%8E%BB%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%BC%95%E7%94%A8"><span class="nav-number">34.</span> <span class="nav-text">从汇编层去解释一下引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E6%A8%A1%E6%9D%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%BA%95%E5%B1%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">C++模板是什么，你知道底层怎么实现的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D"><span class="nav-number">36.</span> <span class="nav-text">什么是内存泄露，如何检测与避免</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">36.1.</span> <span class="nav-text">内存泄露</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">36.2.</span> <span class="nav-text">避免内存泄露的几种方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">37.</span> <span class="nav-text">对象复用的了解，零拷贝的了解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8"><span class="nav-number">37.1.</span> <span class="nav-text">对象复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">37.2.</span> <span class="nav-text">零拷贝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFtrivial-destructor"><span class="nav-number">38.</span> <span class="nav-text">解释一下什么是trivial destructor</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5"><span class="nav-number">39.</span> <span class="nav-text">C++中类的数据成员和成员函数内存分布情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">析构函数的作用，如何起作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-number">41.</span> <span class="nav-text">构造函数析构函数可否抛出异常</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%9E%90%E6%9E%84%EF%BC%9F"><span class="nav-number">42.</span> <span class="nav-text">类什么时候会析构？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">43.</span> <span class="nav-text">构造函数的几种关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%8B%E6%A0%88%E8%BF%87%E7%A8%8B"><span class="nav-number">44.</span> <span class="nav-text">C++函数调用的压栈过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">45.</span> <span class="nav-text">说说移动构造函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E4%B8%AD%E5%B0%86%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-number">46.</span> <span class="nav-text">C++中将临时变量作为返回值时的处理过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Ethis%E6%8C%87%E9%92%88%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%EF%BC%9F%E5%85%A8%E8%AF%B4%E5%87%BA%E6%9D%A5"><span class="nav-number">47.</span> <span class="nav-text">关于this指针你知道什么？全说出来</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E9%92%88%E7%9A%84%E7%94%A8%E5%A4%84"><span class="nav-number">47.1.</span> <span class="nav-text">this指针的用处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">47.2.</span> <span class="nav-text">this指针的使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%A0%E4%B8%AAthis%E6%8C%87%E9%92%88%E7%9A%84%E6%98%93%E6%B7%B7%E9%97%AE%E9%A2%98"><span class="nav-number">48.</span> <span class="nav-text">几个this指针的易混问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%9F"><span class="nav-number">48.1.</span> <span class="nav-text">this指针是什么时候创建的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E9%92%88%E5%AD%98%E6%94%BE%E5%9C%A8%E4%BD%95%E5%A4%84%EF%BC%9F%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%8C%E8%BF%98%E6%98%AF%E5%85%B6%E4%BB%96%EF%BC%9F"><span class="nav-number">48.2.</span> <span class="nav-text">this指针存放在何处？堆、栈、全局变量，还是其他？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E9%92%88%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%EF%BC%9F%E7%BB%91%E5%AE%9A%EF%BC%9F%E8%BF%98%E6%98%AF%E5%9C%A8%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%A6%96%E5%8F%82%E6%95%B0%E5%B0%B1%E6%98%AFthis%E6%8C%87%E9%92%88%EF%BC%9F%E9%82%A3%E4%B9%88%EF%BC%8Cthis%E6%8C%87%E9%92%88%E5%8F%88%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E2%80%9C%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%90%8E%E5%87%BD%E6%95%B0%E7%9A%84%E2%80%9D%EF%BC%9F"><span class="nav-number">48.3.</span> <span class="nav-text">this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E9%92%88%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%EF%BC%9F"><span class="nav-number">48.4.</span> <span class="nav-text">this指针是如何访问类中的变量的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E5%8F%AA%E6%9C%89%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%90%8E%EF%BC%8C%E6%89%8D%E8%83%BD%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8this%E6%8C%87%E9%92%88%E3%80%82%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1this%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F"><span class="nav-number">48.5.</span> <span class="nav-text">我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E7%B1%BB%E7%BC%96%E8%AF%91%E5%90%8E%EF%BC%8C%E6%98%AF%E5%90%A6%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%87%BD%E6%95%B0%E8%A1%A8%E4%BF%9D%E5%AD%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%A5%E4%BE%BF%E7%94%A8%E6%9D%A5%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">48.6.</span> <span class="nav-text">每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">49.</span> <span class="nav-text">构造函数、拷贝构造函数和赋值操作符的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">50.</span> <span class="nav-text">静态类型和动态类型以及静态绑定和动态绑定的总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%98%AF%E5%90%A6%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">引用是否能实现动态绑定，为什么可以实现？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">52.</span> <span class="nav-text">全局变量和局部变量有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%8A%A0%E5%87%8F%E8%AE%A1%E7%AE%97%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">53.</span> <span class="nav-text">指针加减计算要注意什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="nav-number">54.</span> <span class="nav-text">怎样判断两个浮点数是否相等？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%88%E6%A0%88%E3%80%81%E6%B1%87%E7%BC%96%EF%BC%89"><span class="nav-number">55.</span> <span class="nav-text">方法调用的原理（栈、汇编）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="nav-number">56.</span> <span class="nav-text">C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AA%E8%83%BD%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%8F%AA%E8%83%BD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="nav-number">57.</span> <span class="nav-text">类如何实现只能静态分配和只能动态分配</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%83%B3%E5%B0%86%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%94%A8%E4%BD%9C%E5%9F%BA%E7%B1%BB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%A5%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E8%80%8C%E9%9D%9E%E5%A3%B0%E6%98%8E%EF%BC%9F"><span class="nav-number">58.</span> <span class="nav-text">如果想将某个类用作基类，为什么该类必须定义而非声明？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">59.</span> <span class="nav-text">什么情况会自动生成默认构造函数？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%9F"><span class="nav-number">60.</span> <span class="nav-text">函数指针？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F%E5%93%AA%E4%B8%AA%E5%85%88%E5%85%A5%E6%A0%88%EF%BC%9F"><span class="nav-number">61.</span> <span class="nav-text">函数调用过程栈的变化，返回值和参数变量哪个先入栈？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93printf%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="nav-number">62.</span> <span class="nav-text">你知道printf函数的实现原理是什么吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E5%85%B3%E4%BA%8Elambda%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%A8%E9%83%A8%E7%9F%A5%E8%AF%86"><span class="nav-number">63.</span> <span class="nav-text">说一说你了解的关于lambda函数的全部知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AF%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AAh%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="nav-number">64.</span> <span class="nav-text">为什么模板类一般都是放在一个h文件中</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cout%E5%92%8Cprintf%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">65.</span> <span class="nav-text">cout和printf有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%93%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%9C%89%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%97%B6%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%E5%92%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">66.</span> <span class="nav-text">当程序中有函数重载时，函数的匹配原则和顺序是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">67.</span> <span class="nav-text">定义和声明的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84-ifdef-endif%E4%BB%A3%E8%A1%A8%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">68.</span> <span class="nav-text">说一下你理解的 ifdef   endif代表着什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="nav-number">69.</span> <span class="nav-text">隐式转换，如何消除隐式转换？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9A-it%E3%80%81it-%E5%93%AA%E4%B8%AA%E5%A5%BD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">70.</span> <span class="nav-text">迭代器：++it、it++哪个好，为什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%9F"><span class="nav-number">71.</span> <span class="nav-text">C++如何处理多个异常的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%86%99%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8C%E9%9D%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">72.</span> <span class="nav-text">模板和实现可不可以不写在一个文件里面？为什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%AF%B9%E8%B1%A1%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F"><span class="nav-number">73.</span> <span class="nav-text">在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%EF%BC%9F%E4%BD%A0%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">74.</span> <span class="nav-text">如何在不使用额外空间的情况下，交换两个数？你有几种方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93strcpy%E5%92%8Cmemcpy%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="nav-number">75.</span> <span class="nav-text">你知道strcpy和memcpy的区别是什么吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%9C%A8%E6%89%A7%E8%A1%8Cint-main-int-argc-char-argv-%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">76.</span> <span class="nav-text">程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93const-char-%E4%B8%8Estring%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="nav-number">77.</span> <span class="nav-text">你知道const char* 与string之间的关系是什么吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E4%BC%A0%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BC%A0%E5%80%BC%EF%BC%9F"><span class="nav-number">78.</span> <span class="nav-text">为什么拷贝构造函数必须传引用不能传值？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E7%A9%BA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%E5%90%97%EF%BC%9F"><span class="nav-number">79.</span> <span class="nav-text">你知道空类的大小是多少吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E5%A0%86%E6%A0%88%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="nav-number">80.</span> <span class="nav-text">this指针调用成员变量时，堆栈会发生什么变化？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%90%97%EF%BC%9F%E8%AE%B2%E8%AE%B2%EF%BC%9F"><span class="nav-number">81.</span> <span class="nav-text">你知道静态绑定和动态绑定吗？讲讲？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%AE%A1%E7%AE%97%E5%AD%90%E7%B1%BB%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%9F"><span class="nav-number">82.</span> <span class="nav-text">如何设计一个类计算子类的个数？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%94%99%E8%AF%AF%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">83.</span> <span class="nav-text">怎么快速定位错误出现的地方</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%8F%97%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="nav-number">84.</span> <span class="nav-text">类对象的大小受哪些因素影响？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%AC%E8%AF%B4%E8%BF%87%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4"><span class="nav-number">85.</span> <span class="nav-text">移动构造函数听说过吗？说说</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%90%88%E6%88%90%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F%E9%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="nav-number">86.</span> <span class="nav-text">什么时候合成构造函数？都说一说，你知道的都说一下</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%82%A3%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="nav-number">87.</span> <span class="nav-text">那什么时候需要合成拷贝构造函数呢？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4strcpy%E3%80%81sprintf%E4%B8%8Ememcpy%E8%BF%99%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="nav-number">88.</span> <span class="nav-text">说一说strcpy、sprintf与memcpy这三个函数的不同之处</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%86%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">89.</span> <span class="nav-text">将引用作为函数参数有哪些好处？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">90.</span> <span class="nav-text">如何阻止一个类被实例化？有哪些方法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#strcpy%E5%87%BD%E6%95%B0%E5%92%8Cstrncpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9B%B4%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">91.</span> <span class="nav-text">strcpy函数和strncpy函数的区别？哪个函数更安全？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">92.</span> <span class="nav-text">你知道回调函数吗？它的作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E4%B8%8E%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91"><span class="nav-number">93.</span> <span class="nav-text">动态编译与静态编译</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
