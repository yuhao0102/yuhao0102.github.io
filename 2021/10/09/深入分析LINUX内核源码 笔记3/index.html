<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="进程间通信管道所谓管道，是指用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称pipe文件。向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将大量的数据送入管道；而接收管道输出的接收进程(即读进程)，可从管道中接收数据。由于发送进程和接收进程是利用管道进行通信的，故又称管道通信。这种方式首创于UNIX系统，因它能传送大量的数据，且很有效，故很多操作系统都引入了这种通信">
<meta property="og:type" content="article">
<meta property="og:title" content="深入分析Linux内核源码笔记3">
<meta property="og:url" content="http://yoursite.com/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B03/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="进程间通信管道所谓管道，是指用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称pipe文件。向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将大量的数据送入管道；而接收管道输出的接收进程(即读进程)，可从管道中接收数据。由于发送进程和接收进程是利用管道进行通信的，故又称管道通信。这种方式首创于UNIX系统，因它能传送大量的数据，且很有效，故很多操作系统都引入了这种通信">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1633935241.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633944372.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634004097.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634005281.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634010838.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634017201.jpg">
<meta property="article:published_time" content="2021-10-09T08:00:00.000Z">
<meta property="article:modified_time" content="2021-10-13T08:14:37.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1633935241.jpg">

<link rel="canonical" href="http://yoursite.com/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B03/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>深入分析Linux内核源码笔记3 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入分析Linux内核源码笔记3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-09 16:00:00" itemprop="dateCreated datePublished" datetime="2021-10-09T16:00:00+08:00">2021-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-13 16:14:37" itemprop="dateModified" datetime="2021-10-13T16:14:37+08:00">2021-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>所谓管道，是指用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称<code>pipe</code>文件。向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将大量的数据送入管道；而接收管道输出的接收进程(即读进程)，可从管道中接收数据。由于发送进程和接收进程是利用管道进行通信的，故又称管道通信。这种方式首创于<code>UNIX</code>系统，因它能传送大量的数据，且很有效，故很多操作系统都引入了这种通信方式，<code>Linux</code>也不例外。</p>
<p>为了协调双方的通信，管道通信机制必须提供以下 3 方面的协调能力。</p>
<ul>
<li>互斥。当一个进程正在对<code>pipe</code>进行读/写操作时，另一个进程必须等待。 </li>
<li>同步。当写(输入)进程把一定数量(如 4KB)数据写入<code>pipe</code>后，便去睡眠等待，直到读(输出)进程取走数据后，再把它唤醒。当读进程读到一空<code>pipe</code>时，也应睡眠等待，直至写进程将数据写入管道后，才将它唤醒。</li>
<li>对方是否存在。只有确定对方已存在时，才能进行通信。</li>
</ul>
<h3 id="Linux管道的实现机制"><a href="#Linux管道的实现机制" class="headerlink" title="Linux管道的实现机制"></a>Linux管道的实现机制</h3><p>从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下所述。</p>
<ul>
<li>限制管道的大小。实际上，管道是一个固定大小的缓冲区。在<code>Linux</code>中，该缓冲区的大小为 1 页，即 4KB，使得它的大小不像文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的<code>write()</code>调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供<code>write()</code>调用写。</li>
<li>读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的<code>read()</code>调用将默认地被阻塞，等待某些数据被写入，这解决了<code>read()</code>调用返回文件结束的问题。</li>
</ul>
<p>注意，从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据。</p>
<h4 id="管道的结构"><a href="#管道的结构" class="headerlink" title="管道的结构"></a>管道的结构</h4><p>在<code>Linux</code>中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的<code>file</code>结构和<code>VFS</code>的索引节点<code>inode</code>。通过将两个<code>file</code>结构指向同一个临时的<code>VFS</code>索引节点，而这个<code>VFS</code>索引节点又指向一个物理页面而实现的。如图 7.1 所示。<br><img src="/img/1633935241.jpg" alt=""></p>
<p>两个<code>file</code>数据结构定义文件操作例程地址是不同的，其中一个是向管道中写入数据的例程地址，而另一个是从管道中读出数据的例程地址。</p>
<h4 id="管道的读写"><a href="#管道的读写" class="headerlink" title="管道的读写"></a>管道的读写</h4><p>管道实现的源代码在<code>fs/pipe.c</code>中，在<code>pipe.c</code>中有很多函数，其中有两个函数比较重要，即管道读函数<code>pipe_read()</code>和管道写函数<code>pipe_wrtie()</code>。管道写函数通过将字节复制到<code>VFS</code>索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。</p>
<p>当写进程向管道中写入时，它利用标准的库函数<code>write()</code>，系统根据库函数传递的文件描述符，可找到该文件的<code>file</code>结构。<code>file</code>结构中指定了用来进行写操作的函数(即写入函数)地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查<code>VFS</code>索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：</p>
<ul>
<li>内存中有足够的空间可容纳所有要写入的数据；</li>
<li>内存没有被读程序锁定。</li>
</ul>
<p>如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在<code>VFS</code>索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。</p>
<p>管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。</p>
<h3 id="管道的应用"><a href="#管道的应用" class="headerlink" title="管道的应用"></a>管道的应用</h3><p>管道是利用<code>pipe()</code>系统调用而不是利用<code>open()</code>系统调用建立的。<code>pipe()</code>调用的原型是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span><br></pre></td></tr></table></figure></p>
<p>我们看到，有两个文件描述符与管道结合在一起，一个文件描述符用于管道的<code>read()</code>端，一个文件描述符用于管道的<code>write()</code>端。由于一个函数调用不能返回两个值，<code>pipe()</code>的参数是指向两个元素的整型数组的指针，它将由调用两个所要求的文件描述符填入。</p>
<p><code>fd[0]</code>元素将含有管道<code>read()</code>端的文件描述符，而<code>fd[1]</code>含有管道<code>write()</code>端的文件描述符。系统可根据<code>fd[0]</code>和<code>fd[1]</code>分别找到对应的<code>file</code>结构。</p>
<p>注意，在<code>pipe</code>的参数中，没有路径名，这表明，创建管道并不像创建文件一样，要为它创建一个目录连接。这样做的好处是，其他现存的进程无法得到该管道的文件描述符，从而不能访问它。那么，两个进程如何使用一个管道来通信呢？</p>
<p>我们知道，<code>fork()</code>和<code>exec()</code>系统调用可以保证文件描述符的复制品既可供双亲进程使用，也可供它的子女进程使用。也就是说，一个进程用<code>pipe()</code>系统调用创建管道，然后用<code>fork()</code>调用创建一个或多个进程，那么，管道的文件描述符将可供所有这些进程使用。</p>
<p>这里更明确的含义是：一个普通的管道仅可供具有共同祖先的两个进程之间共享，并且这个祖先必须已经建立了供它们使用的管道。注意，在管道中的数据始终以和写数据相同的次序来进行读，这表示<code>lseek()</code>系统调用<br>对管道不起作用。</p>
<h3 id="命名管道CFIFOC"><a href="#命名管道CFIFOC" class="headerlink" title="命名管道CFIFOC"></a>命名管道CFIFOC</h3><p><code>Linux</code>还支持另外一种管道形式，称为命名管道，或<code>FIFO</code>，这是因为这种管道的操作方式基于“先进先出”原理。上面讲述的管道类型也被称为“匿名管道”。命名管道中，首先写入管道的数据是首先被读出的数据。匿名管道是临时对象，而<code>FIFO</code>则是文件系统的真正实体，如果进程有足够的权限就可以使用<code>FIFO</code>。<code>FIFO</code>和匿名管道的数据结构以及操作极其类似，二者的主要区别在于，<code>FIFO</code>在使用之前就已经存在，用户可打开或关闭<code>FIFO</code>；而匿名管道只在操作时存在，因而是临时对象。</p>
<p>为了创建先进先出文件，可以从<code>shell</code>提示符使用<code>mknod</code>命令或可以在程序中使用<code>mknod()</code>系统调用。</p>
<p><code>mknod()</code>系统调用的原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/type.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="string">&lt;sys/state.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">char</span> *pathname,<span class="type">node_t</span> mode, <span class="type">dev_t</span> dev)</span>;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>pathname</code>是被创建的文件名称，<code>mode</code>表示将在该文件上设置的权限位和将被创建的文件类型(在此情况下为<code>S_IFIFO</code>)，<code>dev</code>是当创建设备特殊文件时使用的一个值。因此，对于先进先出文件它的值为 0。</p>
<p>一旦先进先出文件已经被创建，它可以由任何具有适当权限的进程利用标准的<code>open()</code>系统调用加以访问。当用<code>open()</code>调用打开时，一个先进先出文件和一个匿名管道具有同样的基本功能。即当管道是空的时候，<code>read()</code>调用被阻塞。当管道是满的时候，<code>write()</code>等待被阻塞，并且当用<code>fcntl()</code>设置<code>O_NONBLOCK</code>标志时，将引起<code>read()</code>调用和<code>write()</code>调用立即返回。</p>
<p>在它们已被阻塞的情况下，带有一个<code>EAGAIN</code>错误信息。由于命名管道可以被很多无关系的进程同时访问，那么，在有多个读进程和/或多个写进程的应用中使用<code>FIFO</code>是非常有用的。</p>
<p>多个进程写一个管道会出现这样的问题，即多个进程所写的数据混在一起怎么办？幸好系统有这样的规则：一个<code>write()</code>调用可以写管道能容纳(<code>Linux</code>为 4KB)的任意个字节，系统将保证这些数据是分开的。这表示多个写操作的数据在<code>FIFO</code>文件中并不混合而将被维持分离的信息。 </p>
<h2 id="信号-signal"><a href="#信号-signal" class="headerlink" title="信号(signal)"></a>信号(signal)</h2><h3 id="信号种类"><a href="#信号种类" class="headerlink" title="信号种类"></a>信号种类</h3><p>每一种信号都给予一个符号名。<code>Linux</code>定义了<code>i386</code>的 32 个信号，在<code>include/asm/signal.h</code>中定义。表给出常用的符号名、描述和它们的信号值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号名</th>
<th>描述</th>
<th>信号值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SIGHUP</code></td>
<td>在控制终端上发生的结束信号</td>
<td>1</td>
</tr>
<tr>
<td><code>SIGINT</code></td>
<td>中断，用户键入<code>CTRL–C</code>时发送</td>
<td>2</td>
</tr>
<tr>
<td><code>SIGQUIT</code></td>
<td>从键盘来的中断(ctrl_c)信号</td>
<td>3</td>
</tr>
<tr>
<td><code>SIGILL</code></td>
<td>非法指令</td>
<td>4</td>
</tr>
<tr>
<td><code>SIGTRAP</code></td>
<td>跟踪陷入</td>
<td>5</td>
</tr>
<tr>
<td><code>SIGABRT</code></td>
<td>非正常结束，程序调用<code>abort</code>时发送</td>
<td>6</td>
</tr>
<tr>
<td><code>SIGIOT</code></td>
<td>IOT指令</td>
<td>6</td>
</tr>
<tr>
<td><code>SIGBUS</code></td>
<td>总线超时</td>
<td>7</td>
</tr>
<tr>
<td><code>SIGFPE</code></td>
<td>浮点异常</td>
<td>8</td>
</tr>
<tr>
<td><code>SIGKILL</code></td>
<td>杀死进程(不能被捕或忽略)</td>
<td>9</td>
</tr>
<tr>
<td><code>SIGUSR1</code></td>
<td>用户定义信号#1</td>
<td>10</td>
</tr>
<tr>
<td><code>SIGSEGV</code></td>
<td>段违法</td>
<td>11</td>
</tr>
<tr>
<td><code>SIGUSR2</code></td>
<td>用户定义信号#2</td>
<td>12</td>
</tr>
<tr>
<td><code>SIGPIPE</code></td>
<td>向无人读到的管道写</td>
<td>13</td>
</tr>
<tr>
<td><code>SIGALRM</code></td>
<td>定时器告警，时间到</td>
<td>14</td>
</tr>
<tr>
<td><code>SIGTERM</code></td>
<td>Kill发出的软件结束信号</td>
<td>15</td>
</tr>
<tr>
<td><code>SIGCHLD</code></td>
<td>子程序结束或停止</td>
<td>17</td>
</tr>
<tr>
<td><code>SIGCONT</code></td>
<td>如果已停止则续继</td>
<td>18</td>
</tr>
<tr>
<td><code>SIGSTOP</code></td>
<td>停止信号</td>
<td>19</td>
</tr>
<tr>
<td><code>SIGTSTP</code></td>
<td>交互停止信号</td>
<td>20</td>
</tr>
<tr>
<td><code>SIGTTIN</code></td>
<td>后台进程想读</td>
<td>21</td>
</tr>
<tr>
<td><code>SIGTTOU</code></td>
<td>后台进程想写</td>
<td>22</td>
</tr>
<tr>
<td><code>SIGPWR</code></td>
<td>电源失效</td>
<td>30</td>
</tr>
</tbody>
</table>
</div>
<p>每种信号类型都有对应的信号处理程序(也叫信号的操作)，就好像每个中断都有一个中断服务例程一样。大多数信号的默认操作是结束接收信号的进程。然而，一个进程通常可以请求系统采取某些代替的操作，各种代替操作如下所述。</p>
<ol>
<li>忽略信号。随着这一选项的设置，进程将忽略信号的出现。有两个信号不可以被忽略：<code>SIGKILL</code>，它将结束进程；<code>SIGSTOP</code>，它是作业控制机制的一部分，将挂起作业的执行。</li>
<li>恢复信号的默认操作。</li>
<li>执行一个预先安排的信号处理函数。进程可以登记特殊的信号处理函数。当进程收到信号时，信号处理函数将像中断服务例程一样被调用，当从该信号处理函数返回时，控制被返回给主程序，并且继续正常执行。</li>
</ol>
<p>但是，信号和中断有所不同。中断的响应和处理都发生在内核空间，而信号的响应发生在内核空间，信号处理程序的执行却发生在用户空间。那么，什么时候检测和响应信号呢？通常发生在以下两种情况下：</p>
<ol>
<li>当前进程由于系统调用、中断或异常而进入内核空间以后，从内核空间返回到用户空间前夕；</li>
<li>当前进程在内核中进入睡眠以后刚被唤醒的时候，由于检测到信号的存在而提前返回到用户空间。</li>
</ol>
<p>当有信号要响应时，当前进程在用户态执行的过程中，陷入系统调用或中断服务例程，于是，当前进程从用户态切换到内核态；当处理完系统调用要返回到用户态前夕，发现有信号处理程序需要执行，于是，又从内核态切换到用户态；当执行完信号处理程序后，并不是接着就在用户态执行应用程序，而是还要返回到内核态。为什么还要返回到内核态呢？这是因为此时还没有真正从系统调用返回到用户态，于是从信号处理程序返回到内核态就是为了处理从系统调用到用户态的返回。</p>
<h3 id="信号掩码"><a href="#信号掩码" class="headerlink" title="信号掩码"></a>信号掩码</h3><p>在<code>POSIX</code>下，每个进程有一个信号掩码(Signal Mask)。简单地说，信号掩码是一个“位图”，其中每一位都对应着一种信号。如果位图中的某一位为 1，就表示在执行当前信号的处理程序期间相应的信号暂时被“屏蔽”，使得在执行的过程中不会嵌套地响应那种信号。</p>
<p>当一个程序正在运行时，在键盘上按一下<code>CTRL+C</code>，内核就会向相应的进程发出一个<code>SIGINT</code>信号，而对这个信号的默认操作就是通过<code>do_exit()</code>结束该进程的运行。在实践中却发现，两次<code>CTRL+C</code>事件往往过于密集，有时候刚刚进入第 1 个信号的处理程序，第 2 个<code>SIGINT</code>信号就到达了，而第 2 个信号的默认操作是杀死进程，这样，第 1 个信号的处理程序根本没有执行完。为了避免这种情况的出现，就在执行一个信号处理程序的过程中将该种信号自动屏蔽掉。所谓“屏蔽”，与将信号忽略是不同的，它只是将信号暂时“遮盖”一下，一旦屏蔽去掉，已到达的信号又继续得到处理。</p>
<p><code>Linux</code>内核中有一个专门的函数集合来执行设置和修改信号掩码，它们放在<code>kernel/signal.c</code>中，其函数形式和功能如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数形式</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int sigemptyset(sigset_t *mask)</code></td>
<td>清所有信号掩码的阻塞标志</td>
</tr>
<tr>
<td><code>int sigfillset(sigset_t *mask, int signum)</code></td>
<td>设置所有信号掩码的阻塞标志</td>
</tr>
<tr>
<td><code>int sigdelset(sigset_t *mask, int signum)</code></td>
<td>删除个别信号阻塞</td>
</tr>
<tr>
<td><code>int sigaddset(sigset_t *mask, int signum)</code></td>
<td>增加个别信号阻塞</td>
</tr>
<tr>
<td><code>int sigisnumber(sigset_t *mask, int signum)</code></td>
<td>确定特定的信号是否在掩码中被标志为阻塞</td>
</tr>
</tbody>
</table>
</div>
<p>另外，进程也可以利用<code>sigprocmask()</code>系统调用改变和检查自己的信号掩码的值，其实现代码在<code>kernel/signal.c</code>中，原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oset)</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>set</code>是指向信号掩码的指针，进程的信号掩码是根据参数<code>how</code>的取值设置成<code>set</code>。参数<code>how</code>的取值及含义如下：</p>
<ul>
<li><code>SIG_BOLCK</code>：<code>set</code>规定附加的阻塞信号</li>
<li><code>SIG_UNBOCK</code>：<code>set</code>规定一组不予阻塞的信号</li>
<li><code>SIG_SETBLOCK</code>：<code>set</code>变成新进程的信号掩码 </li>
</ul>
<p>用一段代码来说明这个问题：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (how) &#123;</span><br><span class="line">	<span class="keyword">case</span> SIG_BLOCK:</span><br><span class="line">		current-&gt;blocked |= new_set;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SIG_UNBLOCK:</span><br><span class="line">		current-&gt;blocked &amp;= ~new_set;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SIG_SETMASK:</span><br><span class="line">		current-&gt;blocked = new_set;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>current</code>为指向当前进程<code>task_struc</code>结构的指针。第 3 个参数<code>oset</code>也是指向信号掩码的指针，它将包含以前的信号掩码值，使得在必要的时候，可以恢复它。</p>
<p>进程可以用<code>sigpending()</code>系统调用来检查是否有挂起的阻塞信号。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>除了<code>signal()</code>系统调用，<code>Linux</code>还提供关于信号的系统调用如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>调用原型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int sigaction(sig,&amp;handler,&amp;oldhandler)</code></td>
<td>定义对信号的处理操作</td>
</tr>
<tr>
<td><code>int sigreturn(&amp;context)</code></td>
<td>从信号返回</td>
</tr>
<tr>
<td><code>int sigprocmask(int how, sigset_t *mask, sigset_t *old)</code></td>
<td>检查或修改信号屏蔽</td>
</tr>
<tr>
<td><code>int sigpending(sigset_t mask)</code></td>
<td>替换信号掩码并使进程挂起</td>
</tr>
<tr>
<td><code>int kill(pid_t pid, int sig)</code></td>
<td>发送信号到进程</td>
</tr>
<tr>
<td><code>long alarm(long secs)</code></td>
<td>设置事件闹钟</td>
</tr>
<tr>
<td><code>int pause(void)</code></td>
<td>将调用进程挂起直到下一个进程</td>
</tr>
</tbody>
</table>
</div>
<p>其中<code>sigset_t</code>定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">sigset_t</span>; <span class="comment">/* 至少 32 位*/</span></span><br></pre></td></tr></table></figure></p>
<p>下面介绍几个典型的系统调用。</p>
<h4 id="kill系统调用"><a href="#kill系统调用" class="headerlink" title="kill系统调用"></a>kill系统调用</h4><p>从前面的叙述可以看到，一个进程接收到的信号，或者是由异常的错误产生(如浮点异常)，或者是用户在键盘上用中断和退出信号干涉而产生，那么，一个进程能否给另一个进程发送信号？回答是肯定的，但发送者进程必须有适当的权限。<code>Kill()</code>系统调用可以完成此任务：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>sig</code>规定发送哪一个信号，参数<code>pid</code>(进程标识号)规定把信号发送到何处，<code>pid</code>各种不同值具有下列意义：</p>
<ul>
<li><code>pid&gt;0</code>：信号<code>sig</code>发送给进程标识号为<code>pid</code>的进程；</li>
<li><code>pid=0</code>：设调用<code>kill()</code>的进程其组标识号为<code>p</code>，则把信号<code>sig</code>发送给与<code>p</code>相等的其他所有进程；</li>
<li><code>pid=-1</code>：<code>Linux</code>规定把信号<code>sig</code>发送给系统中除去<code>init</code>进程和调用者以外的所有进程；</li>
<li><code>pid&lt;-1</code>：信号发送给进程组<code>-pid</code>中的所有进程。</li>
</ul>
<p>为了用<code>kill()</code>发送信号，调用进程的有效用户<code>ID</code>必须是<code>root</code>，或者必须和接收进程的实际或有效用户<code>ID</code>相同。</p>
<h4 id="pause-和alarm-系统调用"><a href="#pause-和alarm-系统调用" class="headerlink" title="pause()和alarm()系统调用"></a>pause()和alarm()系统调用</h4><p>当一个进程需要等待另一个进程完成某项操作时，它将执行<code>pause()</code>调用，当这项操作已完成时，另一个进程可以发送一个预约的信号给这一暂停的进程，它将强迫<code>pause()</code>返回，并且允许收到信号的进程恢复执行，知道它正在等待的事件现在已经出现。</p>
<p>对于许多实际应用，需要在一段指定时间后，中断进程的原有操作，以进行某种其他的处理，系统提供了<code>alarm()</code>系统调用。每个进程都有一个闹钟计时器与之相联，在经过预先设置的时间后，进程可以用它来给自己发送<code>SIGALARM</code>信号。<code>alarm()</code>调用只取一个参数<code>secs</code>，它是在闹钟关闭之前所经过的秒数。如果传递一个 0 值给<code>alarm()</code>，这将关闭任何当前正在运行的闹钟计时器。</p>
<p><code>alarm()</code>返回值是以前的闹钟计时器值，如果当前没有设置任何闹钟计时器，这将是零，或者是当作出该调用时，闹钟的剩余时间。</p>
<h3 id="典型系统调用的实现"><a href="#典型系统调用的实现" class="headerlink" title="典型系统调用的实现"></a>典型系统调用的实现</h3><p><code>sigaction()</code>系统调用的实现较具代表性，它的主要功能为设置信号处理程序，其原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction * action,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> sigaction * oldaction)</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>sigaction</code>数据结构在<code>include/asm/signal.h</code>中定义，其格式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="type">__sighandler_t</span> sa_handler;</span><br><span class="line">	<span class="type">sigset_t</span> sa_mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sa_flags;</span><br><span class="line">	<span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>其中<code>__sighandler_t</code>定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">__sighandler_t</span>)</span> <span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>在这个结构中，<code>sa_handler</code>为指向处理函数的指针，<code>sa_mask</code>是信号掩码，当该信号<code>signum</code>出现时，这个掩码就被逻辑或到接收进程的信号掩码中。当信号处理程序执行时，这个掩码保持有效。<code>sa_flags</code>域是几个位标志的逻辑或(OR)组合，其中两个主要的标志是：</p>
<ul>
<li><code>SA_ONESHOT</code>信号出现时，将信号操作置为默认操作；</li>
<li><code>SA_NOMASK</code>忽略<code>sigaction</code>结构的<code>sa_mask</code>域。</li>
</ul>
<p><code>Linux</code>中定义的信号处理的 3 种类型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_DFL ((__sighandler_t)0) <span class="comment">/* 缺省的信号处理*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_IGN ((__sighandler_t)1) <span class="comment">/*忽略这个信号 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_ERR ((__sighandler_t)-1) <span class="comment">/*从信号返回错误 */</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面是<code>sigaction()</code>系统调用在内核中实现的代码及解释。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction * action,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> sigaction * oldaction)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">new_sa</span>, *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (signum&lt;<span class="number">1</span> || signum&gt;<span class="number">32</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">/* 信号的值不在 1～32 之间，则出错 */</span></span><br><span class="line">	<span class="keyword">if</span> (signum==SIGKILL || signum==SIGSTOP)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">/* SIGKILL和SIGSTOP不能设置信号处理程序 */</span></span><br><span class="line">	p = signum - <span class="number">1</span> + current-&gt;sig-&gt;action;</span><br><span class="line">	<span class="comment">/*在当前进程中，指向信号`signum`的`action`的指针 */</span></span><br><span class="line">	<span class="keyword">if</span> (action) &#123;</span><br><span class="line">		<span class="type">int</span> err = verify_area(VERIFY_READ, action, <span class="keyword">sizeof</span>(*action));</span><br><span class="line">		<span class="comment">/* 验证给action在用户空间分配的地址的有效性 */</span></span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		memcpy_fromfs(&amp;new_sa, action, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sigaction));</span><br><span class="line">		<span class="comment">/* 把actoin的内容从用户空间拷贝到内核空间*/</span></span><br><span class="line">		new_sa.sa_mask |= _S(signum);</span><br><span class="line">		<span class="comment">/* 把信号signum加到掩码中 */</span></span><br><span class="line">		<span class="keyword">if</span> (new_sa.sa_flags &amp; SA_NOMASK)</span><br><span class="line">			new_sa.sa_mask &amp;= ~_S(signum);</span><br><span class="line">		<span class="comment">/* 如果标志为SA_NOMASK，当信号signum出现时，将它的操作置为默认操作 */</span></span><br><span class="line">		new_sa.sa_mask &amp;= _BLOCKABLE;</span><br><span class="line">		<span class="comment">/* 不能阻塞`SIGKILL`和`SIGSTOP */</span></span><br><span class="line">		<span class="keyword">if</span> (new_sa.sa_handler != SIG_DFL &amp;&amp; new_sa.sa_handler !=SIG_IGN) &#123;</span><br><span class="line">			err = verify_area(VERIFY_READ, new_sa.sa_handler, <span class="number">1</span>);</span><br><span class="line">			<span class="comment">/* 当处理程序不是信号默认的处理操作，并且`signum`信号不能被忽略时，验证给信号处理程序分配空间的有效性 */</span></span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (oldaction) &#123; </span><br><span class="line">		<span class="type">int</span> err = verify_area(VERIFY_WRITE, oldaction, <span class="keyword">sizeof</span>(*oldaction));</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		memcpy_tofs(oldaction, p, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sigaction));</span><br><span class="line">		<span class="comment">/* 恢复原来的信号处理程序 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (action) &#123;</span><br><span class="line">		*p = new_sa;</span><br><span class="line">		check_pending(signum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Linux</code>可以将各种信号发送给程序，以表示程序故障、用户请求的中断、其他各种情况等。通过对<code>sigaction()</code>系统调用源代码的分析，有助于灵活应用信号的系统调用。</p>
<h3 id="进程与信号的关系"><a href="#进程与信号的关系" class="headerlink" title="进程与信号的关系"></a>进程与信号的关系</h3><p>系统在<code>task_struct</code>结构中利用两个域分别记录当前挂起的信号(Signal)以及当前阻塞的信号(Blocked)。挂起的信号指尚未进行处理的信号。阻塞的信号指进程当前不处理的信号，如果产生了某个当前被阻塞的信号，则该信号会一直保持挂起，直到该信号不再被阻塞为止。除了<code>SIGKILL</code>和<code>SIGSTOP</code>信号外，所有的信号均可以被阻塞，信号的阻塞可通过系统调用<code>sigprocmask()</code>实现。每个进程的<code>task_struct</code>结构中还包含了一个指向<code>sigaction</code>结构数组的指针，该结构数组中的信息实际指定了进程处理所有信号的方式。</p>
<p>如果某个<code>sigaction</code>结构中包含有处理信号的例程地址，则由该处理例程处理该信号；反之，则根据结构中的一个标志或者由内核进行默认处理，或者只是忽略该信号。通过系统调用<code>sigaction()</code>，进程可以修改<code>sigaction</code>结构数组的信息，从而指定进程处理信号的方式。</p>
<p>进程不能向系统中所有的进程发送信号，一般而言，除系统和超级用户外，普通进程只能向具有相同<code>uid</code>和<code>gid</code>的进程，或者处于同一进程组的进程发送信号。当有信号产生时，内核将进程<code>task_struct</code>的<code>signal</code>字中的相应位设置为 1。系统不对置位之前该位已经为1 的情况进行处理，因而进程无法接收到前一次信号。如果进程当前没有阻塞该信号，并且进程正处于可中断的等待状态(INTERRUPTIBLE)，则内核将该进程的状态改变为运行(RUNNING)，并放置在运行队列中。这样，调度程序在进行调度时，就有可能选择该进程运行，从而可以让进程处理该信号。</p>
<p>发送给某个进程的信号并不会立即得到处理，相反，只有该进程再次运行时，才有机会处理该信号。每次进程从系统调用中退出时，内核会检查它的<code>signal</code>和<code>block</code>字段，如果有任何一个未被阻塞的信号发出，内核就根据<code>sigaction</code>结构数组中的信息进行处理。处理过程如下。 </p>
<ol>
<li>检查对应的<code>sigaction</code>结构，如果该信号不是<code>SIGKILL</code>或<code>SIGSTOP</code>信号，且被忽略，则不处理该信号。</li>
<li>如果该信号利用默认的处理程序处理，则由内核处理该信号，否则转向第(3)步。</li>
<li>该信号由进程自己的处理程序处理，内核将修改当前进程的调用堆栈，并将进程的程序计数寄存器修改为信号处理程序的入口地址。此后，指令将跳转到信号处理程序，当从信号处理程序中返回时，实际就返回了进程的用户模式部分。</li>
</ol>
<p><code>Linux</code>是与<code>POSIX</code>兼容的，因此，进程在处理某个信号时，还可以修改进程的<code>blocked</code>掩码。但是，当信号处理程序返回时，<code>blocked</code>值必须恢复为原有的掩码值，这一任务由内核的<code>sigaction()</code>函数完成。</p>
<p><code>Linux</code>在进程的调用堆栈帧中添加了对清理程序的调用，该清理程序可以恢复原有的<code>blocked</code>掩码值。当内核在处理信号时，可能同时有多个信号需要由用户处理程序处理，这时，<code>Linux</code>内核可以将所有的信号处理程序地址推入堆栈中，而当所有的信号处理完毕后，调用清理程序恢复原先的<code>blocked</code>值。</p>
<h3 id="信号举例"><a href="#信号举例" class="headerlink" title="信号举例"></a>信号举例</h3><p>下面通过<code>Linux</code>提供的系统调用<code>signal()</code>，来说明如何执行一个预先安排好的信号处理函数。<code>signal()</code>调用的原型是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (* signal(<span class="type">int</span> signum, <span class="type">void</span>(*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>signal()</code>的返回值是指向一个函数的指针，该函数的参数为一个整数，无返回值，下面是用户级程序的一段代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> ctrl_c_count=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> (* old_handler)(INT);</span><br><span class="line"><span class="type">void</span> <span class="title function_">ctrl_c</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">	old_handler = signal(SIGINT,ctrl_c);</span><br><span class="line">	<span class="keyword">while</span> ((c=getchar())! = <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ctrl-c count = %d\n&quot;</span>,ctrl_c_count);</span><br><span class="line">	(<span class="type">void</span>) signal(SIGINT,old_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ctrl_c</span><span class="params">(<span class="type">int</span> signum)</span> </span><br><span class="line">&#123;</span><br><span class="line">	(<span class="type">void</span>)signal(SIGINT,ctrl_c)</span><br><span class="line">	++ctrl_c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序说明：这个程序是从键盘获得字符，直到换行符为止，然后进入无限循环。这里，程序安排了捕获<code>ctrl_c</code>信号(SIGINT)，并且利用<code>SIGINT</code>来执行一个<code>ctrl_c</code>的处理函数。当在键盘上敲入一个换行符时，<code>SIGINT</code>原来的操作(很可能是默认操作)才被恢复。<code>main()</code>函数中的第一个语句完成设置信号处理程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">old_handler = signal(SIGINT,ctrl_c);</span><br></pre></td></tr></table></figure></p>
<p><code>signal()</code>的两个参数是：信号值，这里是键盘中断信号<code>SIGINT</code>，以及一个指向函数的指针，这里是<code>ctrl_c</code>，当这个中断信号出现时，将调用该函数。<code>signal()</code>调用返回旧的信号处理程序的地址，在此它被赋给变量<code>older_handler</code>，使得原来的信号处理程序稍后可以被恢复。</p>
<p>一旦信号处理程序放在应放的位置，进程收到任何中断(SIGINT)信号将引起信号处理函数的执行。这个函数增加<code>ctrl_c_count</code>变量的值以保持对<code>SIGINT</code>事件出现次数的计数。注意信号处理函数也执行另一个<code>signal()</code>调用，它重新建立<code>SIGINT</code>信号和<code>ctrl_c</code>函数之间的联系。这是必需的，因为当信号出现时，用<code>signal()</code>调用设置的信号处理程序被自动恢复为默认操作，使得随后的同一信号将只执行信号的默认操作。</p>
<h2 id="System-V的IPC机制"><a href="#System-V的IPC机制" class="headerlink" title="System V的IPC机制"></a>System V的IPC机制</h2><p>为了提供与其他系统的兼容性，<code>Linux</code>也支持 3 种<code>system V</code>的进程间通信机制：消息、信号量(semaphores)和共享内存，<code>Linux</code>对这些机制的实施大同小异。我们把信号量、消息和共享内存统称<code>System V IPC</code>的对象，每一个对象都具有同样类型的接口，即系统调用。</p>
<p>就像每个文件都有一个打开文件号一样，每个对象也都有唯一的识别号，进程可以通过系统调用传递的识别号来存取这些对象，与文件的存取一样，对这些对象的存取也要验证存取权限，<code>System V IPC</code>可以通过系统调用对对象的创建者设置这些对象的存取权限。</p>
<p>在<code>Linux</code>内核中，<code>System V IPC</code>的所有对象有一个公共的数据结构<code>pc_perm</code>结构，它是<code>IPC</code>对象的权限描述，在<code>linux/ipc.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">key_t</span> key; <span class="comment">/* 键 */</span></span><br><span class="line">	ushort uid; <span class="comment">/* 对象拥有者对应进程的有效用户识别号和有效组识别号 */</span></span><br><span class="line">	ushort gid;</span><br><span class="line">	ushort cuid; <span class="comment">/* 对象创建者对应进程的有效用户识别号和有效组识别号 */</span></span><br><span class="line">	ushort cgid;</span><br><span class="line">	ushort mode; <span class="comment">/* 存取模式 */</span></span><br><span class="line">	ushort seq; <span class="comment">/* 序列号 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个结构中，要进一步说明的是键(key)。键和识别号指的是不同的东西。系统支持两种键：公有和私有。如果键是公有的，则系统中所有的进程通过权限检查后，均可以找到<code>System V IPC</code>对象的识别号。如果键是公有的，则键值为 0，说明每个进程都可以用键值 0 建立一个专供其私用的对象。注意，对<code>System V IPC</code>对象的引用是通过识别号而不是通过键，从后面的系统调用中可了解这一点。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量(semaphore )实际是一个整数，它的值由多个进程进行测试(test)和设置(set)。就每个进程所关心的测试和设置操作而言，这两个操作是不可中断的，或称“原子”操作，即一旦开始直到两个操作全部完成。测试和设置操作的结果是：信号量的当前值和设置值相加，其和或者是正或者为负。根据测试和设置操作的结果，一个进程可能必须睡眠，直到有另一个进程改变信号量的值。</p>
<p>信号量作为资源计数器，它的初值可以是任何正整数，其初值不一定为 0 或 1。另外，如果一个进程要先获得两个或多个的共享资源后才能执行的话，那么，相应地也需要多个信号量，而多个进程要分别获得多个临界资源后方能运行，这就是信号量集合机制。</p>
<h4 id="信号量的数据结构"><a href="#信号量的数据结构" class="headerlink" title="信号量的数据结构"></a>信号量的数据结构</h4><p><code>Linux</code>中信号量是通过内核提供的一系列数据结构实现的，这些数据结构存在于内核空间，对它们的分析是充分理解信号量及利用信号量实现进程间通信的基础，下面先给出信号量的数据结构(存在于<code>include/linux/sem.h</code>中)，其他一些数据结构将在相关的系统调用中介绍。</p>
<p>(1)系统中每个信号量的数据结构(sem)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> semval; <span class="comment">/* 信号量的当前值 */</span></span><br><span class="line">	<span class="type">int</span> sempid; <span class="comment">/*在信号量上最后一次操作的进程识别号 *</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>(2)系统中表示信号量集合(set)的数据结构(semid_ds)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span> <span class="comment">/* IPC`权限 */</span></span><br><span class="line">	<span class="type">long</span> sem_otime; <span class="comment">/* 最后一次对信号量操作(semop)的时间 */</span></span><br><span class="line">	<span class="type">long</span> sem_ctime; <span class="comment">/* 对这个结构最后一次修改的时间 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span> <span class="comment">/* 在信号量数组中指向第一个信号量的指针 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">sem_pending</span>;</span> <span class="comment">/* 待处理的挂起操作*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> **<span class="title">sem_pending_last</span>;</span> <span class="comment">/* 最后一个挂起操作 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">undo</span>;</span> <span class="comment">/* 在这个数组上的`undo`请求 */</span></span><br><span class="line">	ushort sem_nsems; <span class="comment">/* 在信号量数组上的信号量号 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>(3)系统中每一信号量集合的队列结构(sem_queue)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> * <span class="title">next</span>;</span> <span class="comment">/* 队列中下一个节点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> ** <span class="title">prev</span>;</span> <span class="comment">/* 队列中前一个节点, *(q-&gt;prev) == q */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wait_queue</span> * <span class="title">sleeper</span>;</span> <span class="comment">/* 正在睡眠的进程 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> * <span class="title">undo</span>;</span> <span class="comment">/* undo`结构*/</span></span><br><span class="line">	<span class="type">int</span> pid; <span class="comment">/* 请求进程的进程识别号 */</span></span><br><span class="line">	<span class="type">int</span> status; <span class="comment">/* 操作的完成状态 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> * <span class="title">sma</span>;</span> <span class="comment">/*有操作的信号量集合数组 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> * <span class="title">sops</span>;</span> <span class="comment">/* 挂起操作的数组 */</span></span><br><span class="line">	<span class="type">int</span> nsops; <span class="comment">/* 操作的个数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>(4)几个主要数据结构之间的关系：<br><img src="/img/1633944372.jpg" alt=""></p>
<p>从图 7.3 可以看出，<code>semid_ds</code>结构的<code>sem_base</code>指向一个信号量数组，允许操作这些信号量集合的进程可以利用系统调用执行操作 。注意，信号量与信号量集合的区别，从上面可以看出，信号量用<code>sem</code>结构描述，而信号量集合用<code>semid_ds</code>结构描述。</p>
<h4 id="系统调用：semget"><a href="#系统调用：semget" class="headerlink" title="系统调用：semget()"></a>系统调用：semget()</h4><p>为了创建一个新的信号量集合，或者存取一个已存在的集合，要使用<code>segget()</code>系统调用，其描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semget</span> <span class="params">( <span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg )</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果成功，则返回信号量集合的<code>IPC</code>识别号；如果为-1，则出现错误。</p>
<p><code>semget()</code>中的第 1 个参数是键值，这个键值要与已有的键值进行比较，已有的键值指在内核中已存在的其他信号量集合的键值。对信号量集合的打开或存取操作依赖于<code>semflg</code>参数的取值。</p>
<ul>
<li><code>IPC_CREAT</code>：如果内核中没有新创建的信号量集合，则创建它。</li>
<li><code>IPC_EXCL</code>：当与<code>IPC_CREAT</code>一起使用时，如果信号量集合已经存在，则创建失败。</li>
</ul>
<p>如果<code>IPC_CREAT</code>单独使用，<code>semget()</code>为一个新创建的集合返回标识号，或者返回具有相同键值的已存在集合的标识号。如果<code>IPC_EXCL</code>与<code>IPC_CREAT</code>一起使用，要么创建一个新的集合，要么对已存在的集合返回-1。<code>IPC_EXCL</code>单独是没有用的，当与<code>IPC_CREAT</code>结合起来使用时，可以保证新创建集合的打开和存取。</p>
<p>作为<code>System V IPC</code>的其他形式，一种可选项是把一个八进制与掩码或，形成信号量集合的存取权限。</p>
<p>第 3 个参数<code>nsems</code>指的是在新创建的集合中信号量的个数。其最大值在<code>linux/sem.h</code>中定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SEMMSL 250 <span class="comment">/* &lt;= 8 000 max num of semaphores per id */</span> </span></span><br></pre></td></tr></table></figure></p>
<p>注意，如果你是显式地打开一个现有的集合，则<code>nsems</code>参数可以忽略。</p>
<p>下面举例说明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_semaphore_set</span><span class="params">( <span class="type">key_t</span> keyval, <span class="type">int</span> numsems )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sid;</span><br><span class="line">	<span class="keyword">if</span> ( ! numsems )</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((sid = semget( keyval, numsems, IPC_CREAT | <span class="number">0660</span> )) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(sid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这个例子显式地用了 0660 权限。这个函数要么返回一个集合的标识号，要么返回-1 而出错。键值必须传递给它，信号量的个数也传递给它，这是因为如果创建成功则要分配空间。</p>
<h4 id="系统调用-semop"><a href="#系统调用-semop" class="headerlink" title="系统调用: semop()"></a>系统调用: semop()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semop</span> <span class="params">( <span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">unsigned</span> nsops)</span>;</span><br></pre></td></tr></table></figure>
<p>如果所有的操作都执行，则成功返回 0。如果为-1，则出错。</p>
<p><code>semop()</code>中的第 1 个参数(semid)是集合的识别号(可以由<code>semget()</code>系统调用得到)。第 2 个参数(sops)是一个指针，它指向在集合上执行操作的数组。而第 3 个参数(nsops)是在那个数组上操作的个数。</p>
<p><code>sops</code>参数指向类型为<code>sembuf</code>的一个数组，这个结构在<code>/inclide/linux/sem.h</code>中声明，是内核中的一个数据结构，描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">	ushort sem_num; <span class="comment">/* 在数组中信号量的索引值 */</span></span><br><span class="line">	<span class="type">short</span> sem_op; <span class="comment">/* 信号量操作值(正数、负数或 0) */</span></span><br><span class="line">	<span class="type">short</span> sem_flg; <span class="comment">/* 操作标志，为IPC_NOWAIT或SEM_UNDO*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果<code>sem_op</code>为负数，那么就从信号量的值中减去<code>sem_op</code>的绝对值，这意味着进程要获取资源，这些资源是由信号量控制或监控来存取的。如果没有指定<code>IPC_NOWAIT</code>，那么调用进程睡眠到请求的资源数得到满足(其他的进程可能释放一些资源)。</li>
<li>如果<code>sem_op</code>是正数，把它的值加到信号量，这意味着把资源归还给应用程序的集合。</li>
<li>最后，如果<code>sem_op</code>为 0，那么调用进程将睡眠到信号量的值也为 0，这相当于一个信号量到达了 100%的利用。</li>
</ul>
<p>综上所述，<code>Linux</code>按如下的规则判断是否所有的操作都可以成功：操作值和信号量的当前值相加大于 0，或操作值和当前值均为 0，则操作成功。如果系统调用中指定的所有操作中有一个操作不能成功时，则<code>Linux</code>会挂起这一进程。但是，如果操作标志指定这种情况下不能挂起进程的话，系统调用返回并指明信号量上的操作没有成功，而进程可以继续执行。如果进程被挂起，<code>Linux</code>必须保存信号量的操作状态并将当前进程放入等待队列。</p>
<p>为此，<code>Linux</code>内核在堆栈中建立一个<code>sem_queue</code>结构并填充该结构。新的<code>sem_queue</code>结构添加到集合的等待队列中(利用<code>sem_pending</code>和<code>sem_pending_last</code>指针)。当前进程放入<code>sem_queue</code>结构的等待队列中<code>sleeper</code>后调用调度程序选择其他的进程运行。</p>
<h4 id="系统调用：semctl"><a href="#系统调用：semctl" class="headerlink" title="系统调用：semctl()"></a>系统调用：semctl()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semctl</span> <span class="params">( <span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, <span class="keyword">union</span> semun arg )</span>;</span><br></pre></td></tr></table></figure>
<p>成功返回正数，出错返回-1。</p>
<p>注意，<code>semctl()</code>是在集合上执行控制操作。</p>
<p><code>semctl()</code>的第 1 个参数(semid)是集合的标识号，第 2 个参数(semnum)是将要操作的信号量个数，从本质上说，它是集合的一个索引，对于集合上的第一个信号量，则该值为0。</p>
<ul>
<li><code>cmd</code>参数表示在集合上执行的命令，这些命令及解释如表所示。</li>
<li><code>arg</code>参数的类型为<code>semun</code>，这个特殊的联合体在<code>include/linux/sem.h</code>中声明，对它的描述如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arg for semctl system calls. */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> val; <span class="comment">/* value for SETVAL */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span> <span class="comment">/* buffer for IPC_STAT &amp; IPC_SET */</span></span><br><span class="line">	ushort *<span class="built_in">array</span>; <span class="comment">/* array for GETALL &amp; SETALL */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span> <span class="comment">/* buffer for IPC_INFO */</span></span><br><span class="line">	<span class="type">void</span> *__pad;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个联合体中，有 3 个成员已经在表 7.1 中提到，剩下的两个成员<code>_buf</code>和<code>_pad</code>用在内核中信号量的实现代码，开发者很少用到。事实上，这两个成员是<code>Linux</code>操作系统所特有的，在<code>UINX</code>中没有。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IPC_STAT</code></td>
<td>从信号量集合上检索<code>semid_ds</code>结构，并存到<code>semun</code>联合体参数的成员<code>buf</code>的地址中</td>
</tr>
<tr>
<td><code>IPC_SET</code></td>
<td>设置一个信号量集合的<code>semid_ds</code>结构中<code>ipc_perm</code>域的值，并从<code>semun</code>的<code>buf</code>中取出值</td>
</tr>
<tr>
<td><code>IPC_RMID</code></td>
<td>从内核中删除信号量集合</td>
</tr>
<tr>
<td><code>GETALL</code></td>
<td>从信号量集合中获得所有信号量的值，并把其整数值存到<code>semun</code>联合体成员的一个指针数组中</td>
</tr>
<tr>
<td><code>GETNCNT</code></td>
<td>返回当前等待资源的进程个数</td>
</tr>
<tr>
<td><code>GETPID</code></td>
<td>返回最后一个执行系统调用<code>semop()</code>进程的<code>PID</code></td>
</tr>
<tr>
<td><code>GETVAL</code></td>
<td>返回信号量集合内单个信号量的值</td>
</tr>
<tr>
<td><code>GETZCNT</code></td>
<td>返回当前等待 100%资源利用的进程个数</td>
</tr>
<tr>
<td><code>SETALL</code></td>
<td>与<code>GETALL</code>正好相反</td>
</tr>
<tr>
<td><code>SETVAL</code></td>
<td>用联合体中<code>val</code>成员的值设置信号量集合中单个信号量的值</td>
</tr>
</tbody>
</table>
</div>
<p>这个系统调用比较复杂，我们举例说明。下面这个程序段返回集合上索引为<code>semnum</code>对应信号量的值。当用<code>GETVAL</code>命令时，最后的参数(semnum)被忽略。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_sem_val</span><span class="params">( <span class="type">int</span> sid, <span class="type">int</span> semnum )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>( semctl(sid, semnum, GETVAL, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>和信号量操作相关的概念还有“死锁”。当某个进程修改了信号量而进入临界区之后，却因为崩溃或被“杀死(kill)”而没有退出临界区，这时，其他被挂起在信号量上的进程永远得不到运行机会，这就是所谓的死锁。<code>Linux</code>通过维护一个信号量数组的调整列表(semadj)来避免这一问题。其基本思想是，当应用这些“调整”时，让信号量的状态退回到操作实施前的状态。</p>
<p>关于调整的描述是在<code>sem_undo</code>数据结构中，在<code>include/linux/sem.h</code>描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*每一个任务都有一系列的恢复(undo)请求，当进程退出时，自动执行`undo`请求*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> * <span class="title">proc_next</span>;</span> <span class="comment">/*在这个进程上的下一个sem_undo节点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> * <span class="title">id_next</span>;</span> <span class="comment">/* 在这个信号量集和上的下一个sem_undo节点*/</span></span><br><span class="line">	<span class="type">int</span> semid; <span class="comment">/* 信号量集的标识号*/</span> </span><br><span class="line">	<span class="type">short</span> * semadj; <span class="comment">/* 信号量数组的调整，每个进程一个*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>sem_undo</code>结构也出现在<code>task_struct</code>数据结构中。</p>
<p>每一个单独的信号量操作也许要请求得到一次“调整”，<code>Linux</code>将为每一个信号量数组的每一个进程维护至少一个<code>sem_undo</code>结构。如果请求的进程没有这个结构，当必要时则创建它，新创建的<code>sem_undo</code>数据结构既在这个进程的<code>task_struct</code>数据结构中排队，也在信号量数组的<code>semid_ds</code>结构中排队。当对信号量数组上的一个信号量施加操作时，这个操作值的负数与这个信号量的“调整”相加，因此，如果操作值为 2，则把-2 加到这个信号量的“调整”域。</p>
<p>当进程被删除时，<code>Linux</code>完成了对<code>sem_undo</code>数据结构的设置及对信号量数组的调整。如果一个信号量集合被删除，<code>sem_undo</code>结构依然留在这个进程的<code>task_struct</code>结构中，但信号量集合的识别号变为无效。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>一个或多个进程可向消息队列写入消息，而一个或多个进程可从消息队列中读取消息。在许多微内核结构的操作系统中，内核和各组件之间的基本通信方式就是消息队列。例如，在<code>Minlx</code>操作系统中，内核、I/O任务、服务器进程和用户进程之间就是通过消息队列实现通信的。</p>
<p><code>Linux</code>中的消息可以被描述成在内核地址空间的一个内部链表，每一个消息队列由一个<code>IPC</code>的标识号唯一地标识。<code>Linux</code>为系统中所有的消息队列维护一个<code>msgque</code>链表，该链表中的每个指针指向一个<code>msgid_ds</code>结构，该结构完整描述一个消息队列。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>(1)消息缓冲区(<code>msgbuf</code>)，可以把这个特殊的数据结构看成一个存放消息数据的模板，它在<code>include/linux/msg.h</code>中声明，描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* msgsnd`和`msgrcv`系统调用使用的消息缓冲区*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> mtype; <span class="comment">/* 消息的类型，必须为正数 */</span></span><br><span class="line">	<span class="type">char</span> mtext[<span class="number">1</span>]; <span class="comment">/* 消息正文 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，对于消息数据元素(mtext)，不要受其描述的限制。实际上，这个域(mtext)不仅能保存字符数组，而且能保存任何形式的任何数据。这个域本身是任意的，因为这个结构本身可以由应用程序员重新定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_msgbuf</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> mtype; <span class="comment">/* 消息类型 */</span></span><br><span class="line">	<span class="type">long</span> request_id; <span class="comment">/* 请求识别号 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">client</span> <span class="title">info</span>;</span> <span class="comment">/* 客户消息结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们看到，消息的类型还是和前面一样，但是结构的剩余部分由两个其他的元素代替，而且有一个是结构。这就是消息队列的优美之处，内核根本不管传送的是什么样的数据，任何信息都可以传送。</p>
<p>但是，消息的长度还是有限制的，在<code>Linux</code>中，给定消息的最大长度在<code>include/linux/msg.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MSGMAX 8192 <span class="comment">/* max size of message (bytes) */</span></span></span><br></pre></td></tr></table></figure></p>
<p>消息总的长度不能超过 8192 字节，包括<code>mtype</code>域，它是 4 字节长。</p>
<p>(2)消息结构(msg)：内核把每一条消息存储在以<code>msg</code>结构为框架的队列中，它在<code>include/ linux/msg.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_next</span>;</span> <span class="comment">/* 队列上的下一条消息 */</span></span><br><span class="line">	<span class="type">long</span> msg_type; <span class="comment">/*消息类型*/</span></span><br><span class="line">	<span class="type">char</span> *msg_spot; <span class="comment">/* 消息正文的地址 */</span></span><br><span class="line">	<span class="type">short</span> msg_ts; <span class="comment">/* 消息正文的大小 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>msg_next</code>是指向下一条消息的指针，它们在内核地址空间形成一个单链表。</p>
<p>(3)消息队列结构(msgid_ds)：当在系统中创建每一个消息队列时，内核创建、存储及维护这个结构的一个实例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在系统中的每一个消息队列对应一个msqid_ds结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_first</span>;</span> <span class="comment">/* 队列上第一条消息，即链表头*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_last</span>;</span> <span class="comment">/* 队列中的最后一条消息，即链表尾 */</span></span><br><span class="line">	<span class="type">time_t</span> msg_stime; <span class="comment">/* 发送给队列的最后一条消息的时间 */</span></span><br><span class="line">	<span class="type">time_t</span> msg_rtime; <span class="comment">/* 从消息队列接收到的最后一条消息的时间 */</span></span><br><span class="line">	<span class="type">time_t</span> msg_ctime; <span class="comment">/* 最后修改队列的时间*/</span></span><br><span class="line">	ushort msg_cbytes; <span class="comment">/*队列上所有消息总的字节数 */</span></span><br><span class="line">	ushort msg_qnum; <span class="comment">/*在当前队列上消息的个数 */</span></span><br><span class="line">	ushort msg_qbytes; <span class="comment">/* 队列最大的字节数 */</span></span><br><span class="line">	ushort msg_lspid; <span class="comment">/* 发送最后一条消息的进程的`pid */</span></span><br><span class="line">	ushort msg_lrpid; <span class="comment">/* 接收最后一条消息的进程的`pid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="系统调用-msgget"><a href="#系统调用-msgget" class="headerlink" title="系统调用: msgget()"></a>系统调用: msgget()</h4><p>为了创建一个新的消息队列，或存取一个已经存在的队列，要使用<code>msgget()</code>系统调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgget</span> <span class="params">( <span class="type">key_t</span> key, <span class="type">int</span> msgflg )</span>;</span><br></pre></td></tr></table></figure></p>
<p>成功，则返回消息队列识别号，失败，则返回-1。</p>
<p><code>semget()</code>中的第一个参数是键值，这个键值要与现有的键值进行比较，现有的键值指在内核中已存在的其他消息队列的键值。对消息队列的打开或存取操作依赖于<code>msgflg</code>参数的取值。</p>
<ul>
<li><code>IPC_CREAT</code>：如果这个队列在内核中不存在，则创建它。</li>
<li><code>IPC_EXCL</code>：当与<code>IPC_CREAT</code>一起使用时，如果这个队列已存在，则创建失败。</li>
</ul>
<p>如果<code>IPC_CREAT</code>单独使用，<code>semget()</code>为一个新创建的消息队列返回标识号，或者返回具有相同键值的已存在队列的标识号。如果<code>IPC_EXCL</code>与<code>IPC_CREAT</code>一起使用，要么创建一个新的队列，要么对已存在的队列返回-1。<code>IPC_EXCL</code>不能单独使用，当与<code>IPC_CREAT</code>结合起来使用时，可以保证新创建队列的打开和存取。</p>
<p>与文件系统的存取权限一样，每一个<code>IPC</code>对象也具有存取权限，因此，可以把一个 8 进制与掩码或，形成对消息队列的存取权限。</p>
<p>下面我们来创建一个打开或创建消息队列的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_queue</span><span class="params">( <span class="type">key_t</span> keyval )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> qid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((qid = msgget( keyval, IPC_CREAT | <span class="number">0660</span> )) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(qid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这个例子显式地用了 0660 权限。这个函数要么返回一个消息队列的标识号，要么返回-1 而出错。键值作为唯一的参数必须传递给它。</p>
<h4 id="系统调用：msgsnd"><a href="#系统调用：msgsnd" class="headerlink" title="系统调用：msgsnd()"></a>系统调用：msgsnd()</h4><p>一旦我们有了队列识别号，我们就可以在这个队列上执行操作。要把一条消息传递给一个队列，必须用<code>msgsnd()</code>系统调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span> <span class="params">( <span class="type">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="type">int</span> msgsz, <span class="type">int</span> msgflg )</span>;</span><br></pre></td></tr></table></figure></p>
<p>返回：成功为 0， 失败为-1。</p>
<p><code>msgsnd()</code>的第 1 个参数是队列识别号，由<code>msgget()</code>调用返回。第 2 个参数<code>msgp</code>是一个指针，指向我们重新声明和装载的消息缓冲区。<code>msgsz</code>参数包含了消息以字节为单位的长度，其中包括了消息类型的 4 个字节。<code>msgflg</code>参数可以设置成 0(忽略)，或者设置或<code>IPC_NOWAIT</code>：如果消息队列满，消息不写到队列中，并且控制权返回给调用进程(继续执行)；如果不指定<code>IPC_NOWAIT</code>，调用进程将挂起(阻塞)直到消息被写到队列中。</p>
<p>下面我们来看一个发送消息的简单函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">send_message</span><span class="params">( <span class="type">int</span> qid, <span class="keyword">struct</span> mymsgbuf *qbuf )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result, length;</span><br><span class="line">	<span class="comment">/* mymsgbuf结构的实际长度 */</span></span><br><span class="line">	length = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ) - <span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">	<span class="keyword">if</span>((result = msgsnd( qid, qbuf, length, <span class="number">0</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个小函数试图把缓冲区<code>qbuf</code>中的消息，发送给队列识别号为<code>qid</code>的消息队列。 </p>
<p>现在，我们在消息队列里有了一条消息，可以用<code>ipcs</code>命令来看队列的状态。如何从消息队列检索消息，可以用<code>msgrcv()</code>系统调用。</p>
<h4 id="系统调用：msgrcv"><a href="#系统调用：msgrcv" class="headerlink" title="系统调用：msgrcv()"></a>系统调用：msgrcv()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgrcv</span> <span class="params">( <span class="type">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="type">int</span> msgsz, <span class="type">long</span> mtype, <span class="type">int</span> msgflg )</span>;</span><br></pre></td></tr></table></figure>
<p>成功，则返回拷贝到消息缓冲区的字节数，失败为-1。</p>
<p>很明显，第 1 个参数用来指定要检索的队列(必须由<code>msgget()</code>调用返回)，第 2 个参数(msgp)是存放检索到消息的缓冲区的地址，第 3 个参数(msgsz)是消息缓冲区的大小，包括消息类型的长度(4 字节)。第 4 个参数(mtype)指定了消息的类型。内核将搜索队列中相匹配类型的最早的消息，并且返回这个消息的一个拷贝，返回的消息放在由<code>msgp</code>参数指向的地址。这里存在一个特殊的情况，如果传递给<code>mytype</code>参数的值为 0，就可以不管类型，只返回队列中最早的消息。</p>
<p>如果传递给参数<code>msgflg</code>的值为<code>IPC_NOWAIT</code>，并且没有可取的消息，那么给调用进程返回<code>ENOMSG</code>错误消息，否则，调用进程阻塞，直到一条消息到达队列并且满足<code>msgrcv()</code>的参数。如果一个客户正在等待消息，而队列被删除，则返回<code>EIDRM</code>。如果当进程正在阻塞，并且等待一条消息到达但捕获到了一个信号，则返回<code>EINTR</code>。</p>
<p>下面我们来看一个从我们已建的消息队列中检索消息的例子<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read_message</span><span class="params">( <span class="type">int</span> qid, <span class="type">long</span> type, <span class="keyword">struct</span> mymsgbuf *qbuf )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result, length;</span><br><span class="line">	<span class="comment">/* 计算mymsgbuf结构的实际大小*/</span></span><br><span class="line">	length = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mymsgbuf) - <span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">	<span class="keyword">if</span>((result = msgrcv( qid, qbuf, length, type, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当从队列中成功地检索到消息后，这个消息将从队列中删除。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存可以被描述成内存一个区域(段)的映射，这个区域可以被更多的进程所共享。一旦内存被共享之后，对共享内存的访问同步需要由其他<code>IPC</code>机制，例如信号量来实现。像所有的<code>System V IPC</code>对象一样，<code>Linux</code>对共享内存的存取是通过对访问键和访问权限的检查来控制的。 </p>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>与消息队列和信号量集合类似，内核为每一个共享内存段(存在于它的地址空间)维护着一个特殊的数据结构<code>shmid_ds</code>，这个结构在<code>include/linux/shm.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在系统中每一个共享内存段都有一个shmid_ds数据结构. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span> <span class="comment">/* 操作权限 */</span></span><br><span class="line">	<span class="type">int</span> shm_segsz; <span class="comment">/* 段的大小(以字节为单位) */</span></span><br><span class="line">	<span class="type">time_t</span> shm_atime; <span class="comment">/* 最后一个进程附加到该段的时间 */</span></span><br><span class="line">	<span class="type">time_t</span> shm_dtime; <span class="comment">/* 最后一个进程离开该段的时间 */</span></span><br><span class="line">	<span class="type">time_t</span> shm_ctime; <span class="comment">/* 最后一次修改这个结构的时间 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> shm_cpid; <span class="comment">/*创建该段进程的pid */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> shm_lpid; <span class="comment">/* 在该段上操作的最后一个进程的`pid */</span></span><br><span class="line">	<span class="type">short</span> shm_nattch; <span class="comment">/*当前附加到该段的进程的个数 */</span></span><br><span class="line">	<span class="comment">/* 下面是私有的 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> shm_npages; <span class="comment">/*段的大小(以页为单位) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *shm_pages; <span class="comment">/* 指向frames -&gt; SHMMAX的指针数组 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">attaches</span>;</span> <span class="comment">/* 对共享段的描述 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们用图 7.4 来表示共享内存的数据结构<code>shmid_ds</code>与其他相关数据结构的关系。<br><img src="/img/1634004097.jpg" alt=""></p>
<h4 id="共享内存的处理过程"><a href="#共享内存的处理过程" class="headerlink" title="共享内存的处理过程"></a>共享内存的处理过程</h4><p>某个进程第 1 次访问共享虚拟内存时将产生缺页异常。这时，<code>Linux</code>找出描述该内存的<code>vm_area_struct</code>结构，该结构中包含用来处理这种共享虚拟内存段的处理函数地址。共享内存缺页异常处理代码对<code>shmid_ds</code>的页表项表进行搜索，以便查看是否存在该共享虚拟内存的页表项。如果没有，系统将分配一个物理页并建立页表项，该页表项加入<code>shmid_ds</code>结构的同时也添加到进程的页表中。这就意味着当下一个进程试图访问这页内存时出现缺页异常，共享内存的缺页异常处理代码则把新创建的物理页给这个进程。因此说，第 1 个进程对共享内存的存取引起创建新的物理页面，而其他进程对共享内存的存取引起把那个页添加到它们的地址空间。</p>
<p>当某个进程不再共享其虚拟内存时，利用系统调用将共享段从自己的虚拟地址区域中移去，并更新进程页表。当最后一个进程释放了共享段之后，系统将释放给共享段所分配的物理页。当共享的虚拟内存没有被锁定到物理内存时，共享内存也可能会被交换到交换区中。</p>
<h4 id="系统调用：shmget"><a href="#系统调用：shmget" class="headerlink" title="系统调用：shmget()"></a>系统调用：shmget()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span> <span class="params">( <span class="type">key_t</span> key, <span class="type">int</span> size, <span class="type">int</span> shmflg )</span>；</span><br></pre></td></tr></table></figure>
<p>成功，则返回共享内存段的识别号, 失败返回-1。</p>
<p><code>shmget()</code>系统调用类似于信号量和消息队列的系统调用，在此不进一步赘述。</p>
<h4 id="系统调用：shmat"><a href="#系统调用：shmat" class="headerlink" title="系统调用：shmat()"></a>系统调用：shmat()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> *shmaddr, <span class="type">int</span> shmflg)</span>；</span><br></pre></td></tr></table></figure>
<p>成功，则返回附加到进程的那个段的地址，失败返回-1。</p>
<p>其中<code>shmid</code>是由<code>shmget()</code>调用返回的共享内存段识别号，<code>shmaddr</code>是你希望共享段附加的地址，<code>shmflag</code>允许你规定希望所附加的段为只读(利用<code>SHM_RDONLY)</code>以代替读写。通常，并不需要规定你自己的<code>shmaddr</code>，可以用传递参数值零使得系统为你取得一个地址。</p>
<p>这个调用可能是最简单的，下面看一个例子，把一个有效的识别号传递给一个段，然后返回这个段被附加到内存的内存地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">attach_segment</span><span class="params">( <span class="type">int</span> shmid )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(shmat(shmid, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦一个段适当地被附加，并且一个进程有指向那个段起始地址的一个指针，那么，对那个段的读写就变得相当容易。</p>
<h4 id="系统调用：shmctl"><a href="#系统调用：shmctl" class="headerlink" title="系统调用：shmctl()"></a>系统调用：shmctl()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span> <span class="params">( <span class="type">int</span> shmqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf )</span>;</span><br></pre></td></tr></table></figure>
<p>成功返回 0 ，失败返回-1。</p>
<p>这个特殊的调用和<code>semctl()</code>调用几乎相同，因此，这里不进行详细的讨论。有效命令的值如下所述。</p>
<ul>
<li><code>IPC_STAT</code>：检索一个共享段的<code>shmid_ds</code>结构，把它存到<code>buf</code>参数的地址中。</li>
<li><code>IPC_SET</code>：对一个共享段来说，从<code>buf</code>参数中取值设置<code>shmid_ds</code>结构的<code>ipc_perm</code>域的值。</li>
<li><code>IPC_RMID</code>：把一个段标记为删除。</li>
<li><code>IPC_RMID</code>：命令实际上不从内核删除一个段，而是仅仅把这个段标记为删除，实际的删除发生在最后一个进程离开这个共享段时。</li>
</ul>
<p>当一个进程不再需要共享内存段时，它将调用<code>shmdt()</code>系统调用取消这个段，但是，这并不是从内核真正地删除这个段，而是把相关<code>shmid_ds</code>结构的<code>shm_nattch</code>域的值减 1，当这个值为 0 时，内核才从物理上删除这个共享段。 </p>
<h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟文件系统又称虚拟文件系统转换(Virual Filesystem Switch ，简称<code>VFS</code>)。说它虚拟，是因为它所有的数据结构都是在运行以后才建立，并在卸载时删除，而在磁盘上并没有存储这些数据结构。如果只有<code>VFS</code>，系统是无法工作的，因为它的这些数据结构不能凭空而来，只有与实际的文件系统，如<code>Ext2</code>、<code>Minix</code>、<code>MSDOS</code>、<code>VFAT</code>等相结合，才能开始工作，所以<code>VFS</code>并不是一个真正的文件系统。与<code>VFS</code>相对应，我们称<code>Ext2、Minix、MSDOS</code>等为具体文件系统。</p>
<h3 id="虚拟文件系统的作用"><a href="#虚拟文件系统的作用" class="headerlink" title="虚拟文件系统的作用"></a>虚拟文件系统的作用</h3><p>对具体文件系统来说，<code>VFS</code>是一个管理者，而对内核的其他子系统来说，<code>VFS</code>是它们与具体文件系统的一个接口。</p>
<p><code>VFS</code>提供一个统一的接口(实际上就是<code>file_operatoin</code>数据结构)，一个具体文件系统要想被<code>Linux</code>支持，就必须按照这个接口编写自己的操作函数，而将自己的细节对内核其他子系统隐藏起来。因而，对内核其他子系统以及运行在操作系统之上的用户程序而言，所有的文件系统都是一样的。实际上，要支持一个新的文件系统，主要任务就是编写这些接口函数。</p>
<p>概括说来，<code>VFS</code>主要有以下几个作用。</p>
<ol>
<li>对具体文件系统的数据结构进行抽象，以一种统一的数据结构进行管理。</li>
<li>接受用户层的系统调用，例如<code>write、open、stat、link</code>等。</li>
<li>支持多种具体文件系统之间相互访问。</li>
<li>接受内核其他子系统的操作请求，特别是内存管理子系统。 </li>
</ol>
<p>通过<code>VFS</code>，<code>Linux</code>可以支持很多种具体文件系统，表是<code>Linux</code>支持的部分具体文件系统。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件系统</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Minix Linux</code></td>
<td>最早支持的文件系统。主要缺点是最大<code>64MB</code>的磁盘分区和最长 14 个字符的文件名称的限制</td>
</tr>
<tr>
<td><code>Ext</code></td>
<td>第 1 个<code>Linux</code>专用的文件系统，支持<code>2GB</code>磁盘分区，255 字符的文件名称，但性能有问题</td>
</tr>
<tr>
<td><code>Xiafs</code></td>
<td>在<code>Minix</code>基础上发展起来，克服了<code>Minix</code>的主要缺点。但很快被更完善的文件系统取代</td>
</tr>
<tr>
<td><code>Ext2</code></td>
<td>当前实际上的<code>Linux</code>标准文件系统。性能强大，易扩充，可移植</td>
</tr>
<tr>
<td><code>Ext3</code></td>
<td>日志文件系统。Ext3 文件系统是对稳定的<code>Ext2</code>文件系统的改进</td>
</tr>
<tr>
<td><code>System V UNIX</code></td>
<td>早期支持的文件系统，也有与<code>Minix</code>同样的限制</td>
</tr>
<tr>
<td><code>NFS</code></td>
<td>网络文件系统。使得用户可以像访问本地文件一样访问远程主机上的文件</td>
</tr>
<tr>
<td><code>ISO 9660</code></td>
<td>光盘使用的文件系统</td>
</tr>
<tr>
<td><code>/proc</code></td>
<td>一个反映内核运行情况的虚的文件系统，并不实际存在于磁盘上</td>
</tr>
<tr>
<td><code>Msdos DOS</code></td>
<td>的文件系统，系统力图使它表现得像`UNIX</td>
</tr>
<tr>
<td><code>UMSDOS</code></td>
<td>该文件系统允许<code>MSDOS</code>文件系统可以当作<code>Linux</code>固有的文件系统一样使用</td>
</tr>
<tr>
<td><code>Vfat fat</code></td>
<td>文件系统的扩展，支持长文件名</td>
</tr>
<tr>
<td><code>Ntfs</code>Windows NT`</td>
<td>的文件系统</td>
</tr>
<tr>
<td><code>Hpfs</code></td>
<td><code>OS/2</code>的文件系统</td>
</tr>
</tbody>
</table>
</div>
<h3 id="VFS所处理的系统调用"><a href="#VFS所处理的系统调用" class="headerlink" title="VFS所处理的系统调用"></a>VFS所处理的系统调用</h3><p>表列出<code>VFS</code>的系统调用，这些系统调用涉及文件系统、常规文件、目录及符号链接。另外还有少数几个由<code>VFS</code>处理的其他系统调用：诸如<code>ioperm()</code>、<code>ioctl()</code>、<code>pipe()</code>和<code>mknod()</code>，涉及设备文件和管道文件。由<code>VFS</code>处理的最后一组系统调用，诸如<code>socket()</code>、<code>connect()</code>、<code>bind()</code>和<code>protocols()</code>，属于套接字系统调用并用于实现网络功能。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统调用名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mount()</code>/<code>umount()</code></td>
<td>安装/卸载文件系统</td>
</tr>
<tr>
<td><code>sysfs()</code></td>
<td>获取文件系统信息</td>
</tr>
<tr>
<td><code>statfs()</code>/<code>fstatfs()</code>/<code>ustat()</code></td>
<td>获取文件系统统计信息</td>
</tr>
<tr>
<td><code>chroot()</code></td>
<td>更改根目录</td>
</tr>
<tr>
<td><code>chdir()</code>/<code>fchdir()</code>/<code>getcwd()</code></td>
<td>更改当前目录</td>
</tr>
<tr>
<td><code>mkdir()</code>/<code>rmdir()</code></td>
<td>创建/删除目录</td>
</tr>
<tr>
<td><code>getdents()</code>/<code>readdir()</code>/<code>link()unlink()</code>/<code>rename()</code></td>
<td>对目录项进行操作</td>
</tr>
<tr>
<td><code>readlink()</code>/<code>symlink()</code></td>
<td>对软链接进行操作</td>
</tr>
<tr>
<td><code>chown()</code>/<code>fchown()</code>/<code>lchown()</code></td>
<td>更改文件所有者</td>
</tr>
<tr>
<td><code>chmod()</code>/<code>fchmod()</code>/<code>utime()</code></td>
<td>更改文件属性</td>
</tr>
<tr>
<td><code>stat()</code>/<code>fstat()</code>/<code>lstat()</code>/<code>access()</code></td>
<td>读取文件状态</td>
</tr>
<tr>
<td><code>open()</code>/<code>close()</code>/<code>creat()</code>/<code>umask()</code></td>
<td>打开/关闭文件</td>
</tr>
<tr>
<td><code>dup()</code>/<code>dup2()</code>/<code>fcntl()</code></td>
<td>对文件描述符进行操作</td>
</tr>
<tr>
<td><code>select()</code>/<code>poll()</code></td>
<td>异步<code>I/O</code>通信</td>
</tr>
<tr>
<td><code>truncate()</code>/<code>ftruncate()</code></td>
<td>更改文件长度</td>
</tr>
<tr>
<td><code>lseek()</code>/<code>_llseek()</code></td>
<td>更改文件指针</td>
</tr>
<tr>
<td><code>read()</code>/<code>write()</code>/<code>readv()</code>/<code>writev()</code>/<code>sendfile()</code></td>
<td>文件<code>I/O</code>操作</td>
</tr>
<tr>
<td><code>pread()</code>/<code>pwrite()</code></td>
<td>搜索并访问文件</td>
</tr>
<tr>
<td><code>mmap()</code>/<code>munmap()</code></td>
<td>文件内存映射</td>
</tr>
<tr>
<td><code>fdatasync()</code>/<code>fsync()</code>/<code>sync()</code>/<code>msync()</code></td>
<td>同步访问文件数据</td>
</tr>
<tr>
<td><code>flock()</code></td>
<td>处理文件锁</td>
</tr>
</tbody>
</table>
</div>
<h2 id="VFS中的数据结构"><a href="#VFS中的数据结构" class="headerlink" title="VFS中的数据结构"></a>VFS中的数据结构</h2><p>你可以把通用文件模型看作是面向对象的，在这里，对象是一个软件结构，其中既定义了数据结构也定义了其上的操作方法。出于效率的考虑，<code>Linux</code>的编码并未采用面向对象的程序设计语言(比如C++)。因此对象作为数据结构来实现：数据结构中指向函数的域就对应于对象的方法。</p>
<p>通用文件模型由下列对象类型组成。</p>
<ul>
<li>超级块(superblock)对象：存放系统中已安装文件系统的有关信息。每个文件系统都有一个超级块对象。</li>
<li>索引节点(inode)对象：存放关于具体文件的一般信息。对于基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的文件控制块(FCB)，也就是说，每个文件都有一个索引节点对象。每个索引节点对象都有一个索引节点号，这个号唯一地标识某个文件系统中的指定文件。</li>
<li>目录项(dentry)对象：存放目录项与对应文件进行链接的信息。<code>VFS</code>把每个目录看作一个由若干子目录和文件组成的常规文件。例如，在查找路径名<code>/tmp/test</code>时，内核为根目录<code>/</code>创建一个目录项对象，为根目录下的<code>tmp</code>项创建一个第 2 级目录项对象，为<code>/tmp</code>目录下的<code>test</code>项创建一个第 3 级目录项对象。</li>
<li>文件(file)对象：存放打开文件与进程之间进行交互的有关信息。这类信息仅当进程访问文件期间存在于内存中。</li>
</ul>
<p>下面我们讨论超级块、索引节点、目录项及文件的数据结构，它们的共同特点有两个：</p>
<ul>
<li>充分考虑到对多种具体文件系统的兼容性；</li>
<li>是“虚”的，也就是说只能存在于内存。</li>
</ul>
<p>这正体现了<code>VFS</code>的特点，在下面的描述中，读者也许能体会到以上特点。</p>
<h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><p><code>VFS</code>超级块是各种具体文件系统在安装时建立的，并在这些文件系统卸载时自动删除，可见，<code>VFS</code>超级块确实只存在于内存中，同时提到<code>VFS</code>超级块也应该说成是哪个具体文件系统的<code>VFS</code>超级块。<code>VFS</code>超级块在<code>inculde/fs/fs.h</code>中定义，即数据结构<code>super_block</code>，该结构及其主要域的含义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/************描述具体文件系统的整体信息的域*****************</span></span><br><span class="line"><span class="comment">	kdev_t s_dev; /* 包含该具体文件系统的块设备标识符。例如，对于 /dev/hda1，其设备标识符为 0x301 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_blocksize; <span class="comment">/*该具体文件系统中数据块的大小，以字节为单位 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> s_blocksize_bits; <span class="comment">/*块大小的值占用的位数，例如，如果块大小为 1024 字节，则该值为 10*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> s_maxbytes; <span class="comment">/* 文件的最大长度 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_flags; <span class="comment">/* 安装标志*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_magic; <span class="comment">/*魔数，即该具体文件系统区别于其他文件系统的一个标志*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**************用于管理超级块的域******************/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_list</span>;</span> <span class="comment">/*指向超级块链表的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">s_lock</span> /*锁标志位，若置该位，则其他进程不能对该超级块操作*/</span></span><br><span class="line"><span class="class">	<span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">s_umount</span> /*对超级块读写时进行同步*/</span></span><br><span class="line"><span class="class">	<span class="title">unsigned</span> <span class="title">char</span> <span class="title">s_dirt</span>;</span> <span class="comment">/*脏位，若置该位，表明该超级块已被修改*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">s_root</span>;</span> <span class="comment">/*指向该具体文件系统安装目录的目录项*/</span></span><br><span class="line">	<span class="type">int</span> s_count; <span class="comment">/*对超级块的使用计数*/</span></span><br><span class="line">	<span class="type">atomic_t</span> s_active;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_dirty</span>;</span> <span class="comment">/*已修改的索引节点形成的链表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_locked_inodes</span>;</span><span class="comment">/* 要进行同步的索引节点形成的链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_files</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">	/***********和具体文件系统相联系的域*************************/</span></span><br><span class="line"><span class="class">	<span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">s_type</span>;</span> <span class="comment">/*指向文件系统的file_system_type数据结构的指针 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> *<span class="title">s_op</span>;</span> <span class="comment">/*指向某个特定的具体文件系统的用于超级块操作的函数集合 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span> *<span class="title">dq_op</span>;</span> <span class="comment">/* 指向某个特定的具体文件系统用于限额操作的函数集合 */</span></span><br><span class="line">	u; <span class="comment">/*一个共用体，其成员是各种文件系统的fsname_sb_info数据结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>所有超级块对象(每个已安装的文件系统都有一个超级块)以双向环形链表的形式链接在一起。链表中第一个元素和最后一个元素的地址分别存放在<code>super_blocks</code>变量的<code>s_list</code>域的<code>next</code>和<code>prev</code>域中。<code>s_list</code>域的数据类型为<code>struct list_head</code>，在超级块的<code>s_dirty</code>域以及内核的其他很多地方都可以找到这样的数据类型；这种数据类型仅仅包括指向链表中的前一个元素和后一个元素的指针。因此，超级块对象的<code>s_list</code>域包含指向链表中两个相邻超级块对象的指针。图 8.2 说明了<code>list_head</code>元素、<code>next</code>和<code>prev</code>是如何嵌入到超级块对象中的。<br><img src="/img/1634005281.jpg" alt=""></p>
<p>超级块最后一个<code>u</code>联合体域包括属于具体文件系统的超级块信息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Minix_sb_info</span> <span class="title">Minix_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Ext2_sb_info</span> <span class="title">Ext2_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext3_sb_info</span> <span class="title">ext3_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hpfs_sb_info</span> <span class="title">hpfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ntfs_sb_info</span> <span class="title">ntfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msdos_sb_info</span> <span class="title">msdos_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">isofs_sb_info</span> <span class="title">isofs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nfs_sb_info</span> <span class="title">nfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_sb_info</span> <span class="title">sysv_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">affs_sb_info</span> <span class="title">affs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ufs_sb_info</span> <span class="title">ufs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">efs_sb_info</span> <span class="title">efs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">shmem_sb_info</span> <span class="title">shmem_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">romfs_sb_info</span> <span class="title">romfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">smb_sb_info</span> <span class="title">smbfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hfs_sb_info</span> <span class="title">hfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">adfs_sb_info</span> <span class="title">adfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qnx4_sb_info</span> <span class="title">qnx4_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reiserfs_sb_info</span> <span class="title">reiserfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bfs_sb_info</span> <span class="title">bfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">udf_sb_info</span> <span class="title">udf_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ncp_sb_info</span> <span class="title">ncpfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usbdev_sb_info</span> <span class="title">usbdevfs_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">jffs2_sb_info</span> <span class="title">jffs2_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cramfs_sb_info</span> <span class="title">cramfs_sb</span>;</span></span><br><span class="line">	<span class="type">void</span> *generic_sbp;</span><br><span class="line">&#125; u;</span><br></pre></td></tr></table></figure></p>
<p>通常，为了效率起见<code>u</code>域的数据被复制到内存。任何基于磁盘的文件系统都需要访问和更改自己的磁盘分配位示图，以便分配和释放磁盘块。<code>VFS</code>允许这些文件系统直接对内存超级块的<code>u</code>联合体域进行操作，无需访问磁盘。</p>
<p>但是，这种方法带来一个新问题：有可能<code>VFS</code>超级块最终不再与磁盘上相应的超级块同步。因此，有必要引入一个<code>s_dirt</code>标志，来表示该超级块是否是脏的。<code>Linux</code>是通过周期性地将所有“脏”的超级块写回磁盘来减少该问题带来的危害。</p>
<p>与超级块关联的方法就是所谓的超级块操作。这些操作是由数据结构<code>super_operations</code>来描述的，该结构的起始地址存放在超级块的<code>s_op</code>域中。</p>
<h3 id="VFS的索引节点"><a href="#VFS的索引节点" class="headerlink" title="VFS的索引节点"></a>VFS的索引节点</h3><p>具体文件系统的索引节点是存储在磁盘上的，是一种静态结构，要使用它，必须调入内存，填写<code>VFS</code>的索引节点，因此，也称<code>VFS</code>索引节点为动态节点。<code>VFS</code>索引节点的数据结构<code>inode</code>在<code>/includ/fs/fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/**********描述索引节点高速缓存管理的域****************/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_hash</span>;</span> <span class="comment">/*指向哈希链表的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_list</span>;</span> <span class="comment">/*指向索引节点链表的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_dentry</span>;</span><span class="comment">/*指向目录项链表的指针*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_dirty_buffers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_dirty_data_buffers</span>;</span></span><br><span class="line">	<span class="comment">/**********描述文件信息的域****************/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_ino; <span class="comment">/*索引节点号*/</span></span><br><span class="line">	<span class="type">kdev_t</span> i_dev; <span class="comment">/*设备标识号 */</span></span><br><span class="line">	<span class="type">umode_t</span> i_mode; <span class="comment">/*文件的类型与访问权限 */</span></span><br><span class="line">	<span class="type">nlink_t</span> i_nlink; <span class="comment">/*与该节点建立链接的文件数 */</span></span><br><span class="line">	<span class="type">uid_t</span> i_uid; <span class="comment">/*文件拥有者标识号*/</span></span><br><span class="line">	<span class="type">gid_t</span> i_gid; <span class="comment">/*文件拥有者所在组的标识号*/</span></span><br><span class="line">	<span class="type">kdev_t</span> i_rdev; <span class="comment">/*实际设备标识号*/</span></span><br><span class="line">	<span class="type">off_t</span> i_size; <span class="comment">/*文件的大小(以字节为单位)*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_blksize; <span class="comment">/*块大小*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_blocks; <span class="comment">/*该文件所占块数*/</span></span><br><span class="line">	<span class="type">time_t</span> i_atime; <span class="comment">/*文件的最后访问时间*/</span></span><br><span class="line">	<span class="type">time_t</span> i_mtime; <span class="comment">/*文件的最后修改时间*/</span></span><br><span class="line">	<span class="type">time_t</span> i_ctime; <span class="comment">/*节点的修改时间*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_version; <span class="comment">/*版本号*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">i_zombie</span>;</span> <span class="comment">/*僵死索引节点的信号量*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/***********用于索引节点操作的域*****************/</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">i_op</span>;</span> <span class="comment">/*索引节点的操作*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">i_sb</span>;</span> <span class="comment">/*指向该文件系统超级块的指针 */</span></span><br><span class="line">	<span class="type">atomic_t</span> i_count; <span class="comment">/*当前使用该节点的进程数。计数为 0，表明该节点可丢弃或被重新使用 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">i_fop</span>;</span> <span class="comment">/*指向文件操作的指针 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_lock; <span class="comment">/*该节点是否被锁定，用于同步操作中*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">i_sem</span>;</span> <span class="comment">/*指向用于同步操作的信号量结构*/</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> *i_wait; <span class="comment">/*指向索引节点等待队列的指针*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_dirt; <span class="comment">/*表明该节点是否被修改过，若已被修改，则应当将该节点写回磁盘*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_lock</span> *<span class="title">i_flock</span>;</span> <span class="comment">/*指向文件加锁链表的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dquot</span> *<span class="title">i_dquot</span>[<span class="title">MAXQUOTAS</span>];</span> <span class="comment">/*索引节点的磁盘限额*/</span></span><br><span class="line">	<span class="comment">/************用于分页机制的域**********************************/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">i_mapping</span>;</span> <span class="comment">/* 把所有可交换的页面管理起来*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> <span class="title">i_data</span>;</span></span><br><span class="line">	<span class="comment">/**********以下几个域应当是联合体****************************************/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_devices</span>;</span> <span class="comment">/*设备文件形成的链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> <span class="title">i_pipe</span>;</span> <span class="comment">/*指向管道文件*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span> <span class="comment">/*指向块设备文件的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">char_device</span> *<span class="title">i_cdev</span>;</span> <span class="comment">/*指向字符设备文件的指针*/</span></span><br><span class="line">	<span class="comment">/*************************其他域***************************************/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_dnotify_mask; <span class="comment">/* Directory notify events */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dnotify_struct</span> *<span class="title">i_dnotify</span>;</span> <span class="comment">/* for directory notifications */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i_state; <span class="comment">/*索引节点的状态标志*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i_flags; <span class="comment">/*文件系统的安装标志*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i_sock; <span class="comment">/*如果是套接字文件则为真*/</span></span><br><span class="line">	<span class="type">atomic_t</span> i_writecount; <span class="comment">/*写进程的引用计数*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i_attr_flags; <span class="comment">/*文件创建标志*/</span></span><br><span class="line">	__u32 i_generation <span class="comment">/*为以后的开发保留*/</span></span><br><span class="line">	<span class="comment">/*************************各个具体文件系统的索引节点********************/</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span>;</span> <span class="comment">/*类似于超级块的一个共用体，其成员是各种具体文件系统的fsname_inode_info数据结构 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对<code>inode</code>数据结构的进一步说明。</p>
<ul>
<li>每个文件都有一个<code>inode</code>，每个<code>inode</code>有一个索引节点号<code>i_ino</code>。在同一个文件系统中，每个索引节点号都是唯一的，内核有时根据索引节点号的哈希值查找其<code>inode</code>结构。</li>
<li>每个文件都有个文件主，其最初的文件主是创建了这个文件的用户，但以后可以改变。</li>
<li>每个用户都有一个用户组，且属于某个用户组，因此，<code>inode</code>结构中就有相应的<code>i_uid</code>、<code>i_gid</code>以指明文件主的身份。</li>
<li><code>inode</code>中有两个设备号，<code>i_dev</code>和<code>i_rdev</code>。首先，除特殊文件外，每个节点都存储在某个设备上，这就是<code>i_dev</code>。其次，如果索引节点所代表的并不是常规文件，而是某个设备，那就还得有个设备号，这就是<code>i_rdev</code>。</li>
<li>每当一个文件被访问时，系统都要在这个文件的<code>inode</code>中记下时间标记，这就是<code>inode</code>中与时间相关的几个域。</li>
<li>每个索引节点都会复制磁盘索引节点包含的一些数据，比如文件占用的磁盘块数。如果<code>i_state</code>域的值等于<code>I_DIRTY</code>，该索引节点就是“脏”的，也就是说，对应的磁盘索引节点必须被更新。<code>i_state</code>域的其他值有<code>I_LOCK</code>(这意味着该索引节点对象已加锁)，<code>I_FREEING</code>(这意味着该索引节点对象正在被释放)。每个索引节点对象总是出现在下列循环双向链表的某个链表中。<ul>
<li>未用索引节点链表。变量<code>inode_unused</code>的<code>next</code>域和<code>prev</code>域分别指向该链表中的首元素和尾元素。这个链表用做内存高速缓存。</li>
<li>正在使用索引节点链表。变量<code>inode_in_use</code>指向该链表中的首元素和尾元素。</li>
<li>脏索引节点链表。由相应超级块的<code>s_dirty</code>域指向该链表中的首元素和尾元素。</li>
<li>这 3 个链表都是通过索引节点的<code>i_list</code>域链接在一起的。</li>
</ul>
</li>
<li>属于“正在使用”或“脏”链表的索引节点对象也同时存放在一个称为<code>inode_hashtable</code>链表中。哈希表加快了对索引节点对象的搜索，前提是系统内核要知道索引节点号及对应文件所在文件系统的超级块对象的地址。由于散列技术可能引发冲突，所以，索引节点对象设置一个<code>i_hash</code>域，其中包含向前和向后的两个指针，分别指向散列到同一地址的前一个索引节点和后一个索引节点；该域由此创建了由这些索引节点组成的一个双向链<br>表。</li>
</ul>
<p>与索引节点关联的方法也叫索引节点操作，由<code>inode_operations</code>结构来描述，该结构的地址存放在<code>i_op</code>域中，该结构也包括一个指向文件操作方法的指针。</p>
<h3 id="目录项对象"><a href="#目录项对象" class="headerlink" title="目录项对象"></a>目录项对象</h3><p>每个文件除了有一个索引节点<code>inode</code>数据结构外，还有一个目录项<code>dentry</code>(directory enrty)数据结构。<code>dentry</code>结构中有个<code>d_inode</code>指针指向相应的<code>inode</code>结构。二者所描述的目标不同，<code>dentry</code>结构代表的是逻辑意义上的文件，所描述的是文件逻辑上的属性，因此，目录项对象在磁盘上并没有对应的映像；而<code>inode</code>结构代表的是物理意义上的文件，记录的是物理上的属性，对于一个具体的文件系统(如<code>Ext2</code>)，<code>Ext2_inode</code>结构在磁盘上就有对应的映像。所以说，一个索引节点对象可能对应多个目录项对象。</p>
<p><code>dentry</code>的定义在<code>include/linux/dcache.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> d_count; <span class="comment">/* 目录项引用计数器 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> d_flags; <span class="comment">/* 目录项标志 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">d_inode</span>;</span> <span class="comment">/* 与文件名关联的索引节点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * <span class="title">d_parent</span>;</span> <span class="comment">/* 父目录的目录项 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_hash</span>;</span> <span class="comment">/* 目录项形成的哈希表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span> <span class="comment">/*未使用的LRU链表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span> <span class="comment">/*父目录的子目录项所形成的链表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span> <span class="comment">/* 该目录项的子目录所形成的链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_alias</span>;</span> <span class="comment">/* 索引节点别名的链表*/</span> </span><br><span class="line">	<span class="type">int</span> d_mounted; <span class="comment">/* 目录项的安装点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span> <span class="comment">/* 目录项名(可快速查找) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> d_time; <span class="comment">/* 由d_revalidate函数使用 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span> <span class="comment">/* 目录项的函数集*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">d_sb</span>;</span> <span class="comment">/* 目录项树的根 (即文件的超级块)*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> d_vfs_flags;</span><br><span class="line">	<span class="type">void</span> * d_fsdata; <span class="comment">/* 具体文件系统的数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> d_iname[DNAME_INLINE_LEN]; <span class="comment">/* 短文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一个有效的<code>dentry</code>结构必定有一个<code>inode</code>结构，这是因为一个目录项要么代表着一个文件，要么代表着一个目录，而目录实际上也是文件。所以，只要<code>dentry</code>结构是有效的，则其指针<code>d_inode</code>必定指向一个<code>inode</code>结构。可是，反过来则不然，一个<code>inode</code>却可能对应着不止一个<code>dentry</code>结构；也就是说，一个文件可以有不止一个文件名或路径名。这是因为一个已经建立的文件可以被连接(link)到其他文件名。所以在<code>inode</code>结构中有一个队列<code>i_dentry</code>，凡是代表着同一个文件的所有目录项都通过其<code>dentry</code>结构中的<code>d_alias</code>域挂入相应<code>inode</code>结构中的<code>i_dentry</code>队列。</p>
<p>在内核中有一个哈希表<code>dentry_hashtable</code>，是一个<code>list_head</code>的指针数组。一旦在内存中建立起一个目录节点的<code>dentry</code>结构，该<code>dentry</code>结构就通过其<code>d_hash</code>域链入哈希表中的某个队列中。</p>
<p>内核中还有一个队列<code>dentry_unused</code>，凡是已经没有用户(<code>count</code>域为 0)使用的<code>dentry</code>结构就通过其<code>d_lru</code>域挂入这个队列。<code>dentry</code>结构中除了<code>d_alias</code>、<code>d_hash</code>、<code>d_lru</code>三个队列外，还有<code>d_vfsmnt</code>、<code>d_child</code>及<code>d_subdir</code>三个队列。其中<code>d_vfsmnt</code>仅在该<code>dentry</code>为一个安装点时才使用。另外，当该目录节点有父目录时，则其<code>dentry</code>结构就通过<code>d_child</code>挂入其父节点的<code>d_subdirs</code>队列中，同时又通过指针<code>d_parent</code>指向其父目录的<code>dentry</code>结构，而它自己各个子目录的<code>dentry</code>结构则挂在其<code>d_subdirs</code>域指向的队列中。</p>
<p>从上面的叙述可以看出，一个文件系统中所有目录项结构或组织为一个哈希表，或组织为一颗树，或按照某种需要组织为一个链表，这将为文件访问和文件路径搜索奠定下良好的基础。</p>
<h3 id="与进程相关的文件结构"><a href="#与进程相关的文件结构" class="headerlink" title="与进程相关的文件结构"></a>与进程相关的文件结构</h3><h4 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h4><p>在<code>Linux</code>中，进程是通过文件描述符(file descriptors，简称<code>fd</code>)而不是文件名来访问文件的，文件描述符实际上是一个整数。<code>Linux</code>中规定每个进程最多能同时使用<code>NR_OPEN</code>个文件描述符，这个值在<code>fs.h</code>中定义，为 1024×1024(2.0 版中仅定义为 256)。每个文件都有一个 32 位的数字来表示下一个读写的字节位置，这个数字叫做文件位置。</p>
<p>每次打开一个文件，除非明确要求，否则文件位置都被置为 0，即文件的开始处，此后的读或写操作都将从文件的开始处执行，但你可以通过执行系统调用<code>LSEEK</code>(随机存储)对这个文件位置进行修改。<code>Linux</code>中专门用了一个数据结构<code>file</code>来保存打开文件的文件位置，这个结构称为打开的文件描述(open file description)。</p>
<p>我们知道，<code>Linux</code>中的文件是能够共享的，假如把文件位置存放在索引节点中，则如果有两个或更多个进程同时打开同一个文件时，它们将去访问同一个索引节点，于是一个进程的<code>LSEEK</code>操作将影响到另一个进程的读操作，这显然是不允许也是不可想象的。</p>
<p>另一个想法是既然进程是通过文件描述符访问文件的，为什么不用一个与文件描述符数组相平行的数组来保存每个打开文件的文件位置？这个想法也是不能实现的，原因就在于在生成一个新进程时，子进程要共享父进程的所有信息，包括文件描述符数组。</p>
<p><code>file</code>结构中主要保存了文件位置，此外，还把指向该文件索引节点的指针也放在其中。<code>file</code>结构形成一个双链表，称为系统打开文件表，其最大长度是<code>NR_FILE</code>，在<code>fs.h</code>中定义为8192。</p>
<p><code>file</code>结构在<code>include\linux\fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">f_list</span>;</span> <span class="comment">/*所有打开的文件形成一个链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">f_dentry</span>;</span> <span class="comment">/*指向相关目录项的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">f_vfsmnt</span>;</span> <span class="comment">/*指向VFS安装点的指针*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span> <span class="comment">/*指向文件操作表的指针*/</span></span><br><span class="line">	<span class="type">mode_t</span> f_mode; <span class="comment">/*文件的打开模式*/</span></span><br><span class="line">	<span class="type">loff_t</span> f_pos; <span class="comment">/*文件的当前位置*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_flags; <span class="comment">/*打开文件时所指定的标志*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> f_count; <span class="comment">/*使用该结构的进程数*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> f_reada, f_ramax, f_raend, f_ralen, f_rawin;</span><br><span class="line">	<span class="comment">/*预读标志、要预读的最多页面数、上次预读后的文件指针、预读的字节数以及预读的页面数*/</span></span><br><span class="line">	<span class="type">int</span> f_owner; <span class="comment">/* 通过信号进行异步I/O数据的传送*/</span> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> f_uid, f_gid; <span class="comment">/*用户的UID和GID*/</span></span><br><span class="line">	<span class="type">int</span> f_error; <span class="comment">/*网络写操作的错误码*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> f_version; <span class="comment">/*版本号*/</span></span><br><span class="line">	<span class="type">void</span> *private_data; <span class="comment">/* tty`驱动程序所需 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每个文件对象总是包含在下列的一个双向循环链表之中。</p>
<ul>
<li>“未使用”文件对象的链表。该链表既可以用做文件对象的内存高速缓存，又可以当作超级用户的备用存储器，也就是说，即使系统的动态内存用完，也允许超级用户打开文件。由于这些对象是未使用的，它们的<code>f_count</code>域是<code>NULL</code>，该链表首元素的地址存放在变量<code>free_list</code>中，内核必须确认该链表总是至少包含<code>NR_RESERVED_FILES</code>个对象，通常该值设为 10。</li>
<li>“正在使用”文件对象的链表。该链表中的每个元素至少由一个进程使用，因此，各个元素的<code>f_count</code>域不会为<code>NULL</code>，该链表中第一个元素的地址存放在变量<code>anon_list</code>中。</li>
</ul>
<p>如果<code>VFS</code>需要分配一个新的文件对象，就调用函数<code>get_empty_filp()</code>。该函数检测“未使用”文件对象链表的元素个数是否多于<code>NR_RESERVED_FILES</code>，如果是，可以为新打开的文件使用其中的一个元素；如果没有，则退回到正常的内存分配。</p>
<h4 id="用户打开文件表"><a href="#用户打开文件表" class="headerlink" title="用户打开文件表"></a>用户打开文件表</h4><p>每个进程用一个<code>files_struct</code>结构来记录文件描述符的使用情况，这个<code>files_struct</code>结构称为用户打开文件表，它是进程的私有数据。<code>files_struct</code>结构在<code>include/linux/sched.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> count; <span class="comment">/* 共享该表的进程数 */</span></span><br><span class="line">	<span class="type">rwlock_t</span> file_lock; <span class="comment">/* 保护以下的所有域,以免在tsk-&gt;alloc_lock中的嵌套*/</span></span><br><span class="line">	<span class="type">int</span> max_fds; <span class="comment">/* 当前文件对象的最大数 */</span></span><br><span class="line">	<span class="type">int</span> max_fdset; <span class="comment">/* 当前文件描述符的最大数 */</span></span><br><span class="line">	<span class="type">int</span> next_fd; <span class="comment">/* 已分配的文件描述符加 1 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> ** <span class="title">fd</span>;</span> <span class="comment">/* 指向文件对象指针数组的指针 */</span></span><br><span class="line">	fd_set *close_on_exec; <span class="comment">/*指向执行`exec()`时需要关闭的文件描述符*/</span></span><br><span class="line">	fd_set *open_fds; <span class="comment">/*指向打开文件描述符的指针*/</span></span><br><span class="line">	fd_set close_on_exec_init;<span class="comment">/* 执行`exec()`时需要关闭的文件描述符的初值集合*/</span></span><br><span class="line">	fd_set open_fds_init; <span class="comment">/*文件描述符的初值集合*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">fd_array</span>[32];</span><span class="comment">/* 文件对象指针的初始化数组*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>fd</code>域指向文件对象的指针数组。该数组的长度存放在<code>max_fds</code>域中。通常，<code>fd</code>域指向<code>files_struct</code>结构的<code>fd_array</code>域，该域包括 32 个文件对象指针。如果进程打开的文件数目多于 32，内核就分配一个新的、更大的文件指针数组，并将其地址存放在<code>fd</code>域中；内核同时也更新<code>max_fds</code>域的值。</p>
<p>对于在<code>fd</code>数组中有入口地址的每个文件来说，数组的索引就是文件描述符(file descriptor)。通常，数组的第 1 个元素(索引为 0)是进程的标准输入文件，数组的第 2 个元素(索引为 1)是进程的标准输出文件，数组的第 3 个元素(索引为 2)是进程的标准错误文件。请注意，借助于<code>dup()、dup2()</code>和<code>fcntl()</code>系统调用，两个文件描述符就可以指向同一个打开的文件，也就是说，数组的两个元素可能指向同一个文件对象。</p>
<p><code>open_fds</code>域包含<code>open_fds_init</code>域的地址，<code>open_fds_init</code>域表示当前已打开文件的文件描述符的位图。<code>max_fdset</code>域存放位图中的位数。由于数据结构<code>fd_set</code>有 1024 位，通常不需要扩大位图的大小。不过，如果确实需要，内核仍能动态增加位图的大小，这非常类似文件对象的数组的情形。</p>
<p>当开始使用一个文件对象时调用内核提供的<code>fget()</code>函数。这个函数接收文件描述符<code>fd</code>作为参数，返回在<code>current-&gt;files-&gt;fd[fd]</code>中的地址，即对应文件对象的地址，如果没有任何文件与<code>fd</code>对应，则返回<code>NULL</code>。在第 1 种情况下，<code>fget()</code>使文件对象引用计数器<code>f_count</code>的值增 1。</p>
<p>当内核完成对文件对象的使用时，调用内核提供的<code>fput()</code>函数。该函数将文件对象的地址作为参数，并递减文件对象引用计数器<code>f_count</code>的值，另外，如果这个域变为<code>NULL</code>，该函数就调用文件操作的“释放”方法(如果已定义)，释放相应的目录项对象，并递减对应索引节点对象的<code>i_writeaccess</code>域的值(如果该文件是写打开)，最后，将该文件对象从“正在使用”链表移到“未使用”链表。</p>
<h4 id="关于文件系统信息的fs-struct结构"><a href="#关于文件系统信息的fs-struct结构" class="headerlink" title="关于文件系统信息的fs_struct结构"></a>关于文件系统信息的fs_struct结构</h4><p><code>fs_struct</code>结构在 2.4 以前的版本中在<code>include/linux/sched.h</code>中定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="type">int</span> umask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * <span class="title">root</span>, * <span class="title">pwd</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在 2.4 版本中，单独定义在<code>include/linux/fs_struct.h</code>中:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="type">rwlock_t</span> lock;</span><br><span class="line">	<span class="type">int</span> umask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * <span class="title">root</span>, * <span class="title">pwd</span>, * <span class="title">altroot</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> * <span class="title">rootmnt</span>, * <span class="title">pwdmnt</span>, * <span class="title">altrootmnt</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>count</code>域表示共享同一<code>fs_struct</code>表的进程数目。<code>umask</code>域由<code>umask()</code>系统调用使用，用于为新创建的文件设置初始文件许可权。</p>
<p><code>fs_struct</code>中的<code>dentry</code>结构是对一个目录项的描述，<code>root</code>、<code>pwd</code>及<code>altroot</code>三个指针都指向这个结构。其中，<code>root</code>所指向的<code>dentry</code>结构代表着本进程所在的根目录，也就是在用户登录进入系统时所看到的根目录；<code>pwd</code>指向进程当前所在的目录；而<code>altroot</code>则是为用户设置的替换根目录。实际运行时，这 3 个目录不一定都在同一个文件系统中。例如，进程的根目录通常是安装于<code>/</code>节点上的<code>Ext2</code>文件系统，而当前工作目录可能是安装于<code>/msdos</code>的一个<code>DOS</code>文件系统。因此，<code>fs_struct</code>结构中的<code>rootmnt</code>、<code>pwdmnt</code>及<code>altrootmnt</code>就是对那 3 个目录的安装点的描述，安装点的数据结构为<code>vfsmount</code>。</p>
<h3 id="主要数据结构间的关系"><a href="#主要数据结构间的关系" class="headerlink" title="主要数据结构间的关系"></a>主要数据结构间的关系</h3><p>超级块是对一个文件系统的描述；索引节点是对一个文件物理属性的描述；而目录项是对一个文件逻辑属性的描述。除此之外，文件与进程之间的关系是由另外的数据结构来描述的。一个进程所处的位置是由<code>fs_struct</code>来描述的，而一个进程(或用户)打开的文件是由<code>files_struct</code>来描述的，而整个系统所打开的文件是由<code>file</code>结构来描述。如图 8.4 给出了这些数据结构之间的关系。<br><img src="/img/1634010838.jpg" alt=""></p>
<h3 id="有关操作的数据结构"><a href="#有关操作的数据结构" class="headerlink" title="有关操作的数据结构"></a>有关操作的数据结构</h3><p>各种<code>Linux</code>支持的具体文件系统都有一套自己的操作函数，在安装时，这些结构体的成员指针将被初始化，指向对应的函数。如果说<code>VFS</code>体现了<code>Linux</code>的优越性，那么这些数据结构的设计就体现了<code>VFS</code>的优越性所在。</p>
<h4 id="超级块操作"><a href="#超级块操作" class="headerlink" title="超级块操作"></a>超级块操作</h4><p>超级块操作是由<code>super_operations</code>数据结构来描述的，该结构的起始地址存放在超级块的<code>s_op</code>域中。该结构定义于<code>fs.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* <span class="doctag">NOTE:</span> write_inode, delete_inode, clear_inode, put_inode can be called</span></span><br><span class="line"><span class="comment">* without the big kernel lock held in all filesystems.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*read_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">void</span> (*read_inode2) (<span class="keyword">struct</span> inode *, <span class="type">void</span> *) ;</span><br><span class="line">	<span class="type">void</span> (*dirty_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">void</span> (*write_inode) (<span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">void</span> (*put_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">void</span> (*delete_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">void</span> (*put_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="type">void</span> (*write_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="type">void</span> (*write_super_lockfs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="type">void</span> (*unlockfs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="type">int</span> (*statfs) (<span class="keyword">struct</span> super_block *, <span class="keyword">struct</span> statfs *);</span><br><span class="line">	<span class="type">int</span> (*remount_fs) (<span class="keyword">struct</span> super_block *, <span class="type">int</span> *, <span class="type">char</span> *);</span><br><span class="line">	<span class="type">void</span> (*clear_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">void</span> (*umount_begin) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的每个函数就叫做超级块的一个方法，表给予描述。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数形式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Read_inode(inode)</code></td>
<td><code>inode</code>的地址是该函数的参数，<code>inode</code>中的<code>i_no</code>域表示从磁盘要读取的具体文件系统的<code>inode</code>，用磁盘上的数据填充参数<code>inode</code>的域</td>
</tr>
<tr>
<td><code>Dirty_inode(inode)</code></td>
<td>把<code>inode</code>标记为“脏”</td>
</tr>
<tr>
<td><code>Write_inode(inode)</code></td>
<td>用参数指定的<code>inode</code>更新某个文件系统的<code>inode。inode</code>的<code>i_ino</code>域标识指定磁盘上文件系统的索引节点</td>
</tr>
<tr>
<td><code>Put_inode(inode)</code></td>
<td>释放参数指定的索引节点对象。释放一个对象并不意味着释放内存，因为其他进程可能仍然在使用这个对象。该方法是可选的</td>
</tr>
<tr>
<td><code>Delete_inode(inode)</code></td>
<td>删除那些包含文件、磁盘索引节点及<code>VFS</code>索引节点的数据块</td>
</tr>
<tr>
<td><code>Notify_change(dentry, iattr)</code></td>
<td>依照参数<code>iattr</code>的值修改索引节点的一些属性。如果没有定义该函数，<code>VFS</code>转去执行<code>write_inode()</code>方法</td>
</tr>
<tr>
<td><code>Put_super(super)</code></td>
<td>释放超级块对象</td>
</tr>
<tr>
<td><code>Write_super(super)</code></td>
<td>将超级块的信息写回磁盘，该方法是可选的</td>
</tr>
<tr>
<td><code>Statfs(super, buf, bufsize)</code></td>
<td>将文件系统的统计信息填写在<code>buf</code>缓冲区中</td>
</tr>
<tr>
<td><code>Remount_fs(super, flags, data)</code></td>
<td>用新的选项重新安装文件系统(当某个安装选项必须被修改时进行调用)</td>
</tr>
<tr>
<td><code>Clear_inode(inode)</code></td>
<td>与<code>put_inode</code>类似，但同时也把索引节点对应文件中的数据占用的所有页释放</td>
</tr>
<tr>
<td><code>Umount_begin(super)</code></td>
<td>中断一个安装操作(只在网络文件系统中使用)</td>
</tr>
</tbody>
</table>
</div>
<p>上面这些方法对所有的文件系统都是适用的，但对于一个具体的文件系统来说，可能只用到其中的几个方法。如果那些方法没有定义，则对应的域为空。</p>
<h4 id="索引节点操作inode-operations"><a href="#索引节点操作inode-operations" class="headerlink" title="索引节点操作inode_operations"></a>索引节点操作inode_operations</h4><p>索引节点操作是由<code>inode_operations</code>结构来描述的，主要是用来将<code>VFS</code>对索引节点的操作转化为具体文件系统处理相应操作的函数，在<code>fs.h</code>中描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*create) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">int</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *,<span class="keyword">struct</span> <span class="title">dentry</span> *);</span></span><br><span class="line">	<span class="type">int</span> (*link) (<span class="keyword">struct</span> dentry *,<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*unlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*symlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">	<span class="type">int</span> (*mkdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*rmdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*mknod) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*rename) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line">	<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*readlink) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> *,<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*follow_link) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> nameidata *);</span><br><span class="line">	<span class="type">void</span> (*truncate) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">int</span> (*permission) (<span class="keyword">struct</span> inode *, <span class="type">int</span>); </span><br><span class="line">	<span class="type">int</span> (*revalidate) (<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">int</span> (*setattr) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> iattr *);</span><br><span class="line">	<span class="type">int</span> (*getattr) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> iattr *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>表所示为对索引节点的每个方法给予描述。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数形式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Create(dir, dentry, mode)</code></td>
<td>在某个目录下，为与<code>dentry</code>目录项相关的常规文件创建一个新的磁盘索引节点</td>
</tr>
<tr>
<td><code>Lookup(dir, dentry)</code></td>
<td>查找索引节点所在的目录，这个索引节点所对应的文件名就包含在<code>dentry</code>目录项中</td>
</tr>
<tr>
<td><code>Link(old_dentry, dir, new_dentry)</code></td>
<td>创建一个新的名为<code>new_dentry</code>硬链接，这个新的硬连接指向<code>dir</code>目录下名为<code>old_dentry</code>的文件</td>
</tr>
<tr>
<td><code>unlink(dir, dentry)</code></td>
<td>从<code>dir</code>目录删除<code>dentry</code>目录项所指文件的硬链接</td>
</tr>
<tr>
<td><code>symlink(dir, dentry, symname)</code></td>
<td>在某个目录下，为与目录项相关的符号链创建一个新的索引节点</td>
</tr>
<tr>
<td><code>mkdir(dir, dentry, mode)</code></td>
<td>在某个目录下，为与目录项对应的目录创建一个新的索引节点</td>
</tr>
<tr>
<td><code>mknod(dir, dentry, mode, rdev)</code></td>
<td>在<code>dir</code>目录下，为与目录项对象相关的特殊文件创建一个新的磁盘索引节点。其中参数<code>mode</code>和<code>rdev</code>分别表示文件的类型和该设备的主码</td>
</tr>
<tr>
<td><code>rename(old_dir, old_dentry, new_dir, new_dentry)</code></td>
<td>将<code>old_dir</code>目录下的文件<code>old_dentry</code>移到<code>new_dir</code>目录下，新文件名包含在<code>new_dentry</code>指向的目录项中</td>
</tr>
<tr>
<td><code>readlink(dentry, buffer, buflen)</code></td>
<td>将<code>dentry</code>所指定的符号链中对应的文件路径名拷贝到<code>buffer</code>所指定的内存区</td>
</tr>
<tr>
<td><code>follow_link(inode, dir)</code></td>
<td>解释<code>inode</code>索引节点所指定的符号链；如果该符号链是相对路径名，从指定的<code>dir</code>目录开始进行查找</td>
</tr>
<tr>
<td><code>truncate(inode)</code></td>
<td>修改索引节点<code>inode</code>所指文件的长度。在调用该方法之前，必须将<code>inode</code>对象的<code>i_size</code>域设置为需要的新长度值</td>
</tr>
<tr>
<td><code>permission(inode, mask)</code></td>
<td>确认是否允许对<code>inode</code>索引节点所指的文件进行指定模式的访问</td>
</tr>
<tr>
<td><code>revalidate(dentry)</code></td>
<td>更新由目录项所指定文件的已缓存的属性(通常由网络文件系统调用)</td>
</tr>
<tr>
<td><code>setattr(dentry, attr)</code></td>
<td>设置目录项的属性</td>
</tr>
<tr>
<td><code>getattr(dentry, attr)</code></td>
<td>获得目录项的属性</td>
</tr>
</tbody>
</table>
</div>
<p>以上这些方法均适用于所有的文件系统，但对某一个具体文件系统来说，可能只用到其中的一部分方法。例如，<code>msdos</code>文件系统其公用索引节点的操作在<code>fs/msdos/namei.c</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">msdos_dir_inode_operations</span> =</span> &#123;</span><br><span class="line">	create: msdos_create,</span><br><span class="line">	lookup: msdos_lookup,</span><br><span class="line">	unlink: msdos_unlink,</span><br><span class="line">	mkdir: msdos_mkdir, </span><br><span class="line">	rmdir: msdos_rmdir,</span><br><span class="line">	rename: msdos_rename,</span><br><span class="line">	setattr: fat_notify_change,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="目录项操作"><a href="#目录项操作" class="headerlink" title="目录项操作"></a>目录项操作</h4><p>目录项操作是由<code>dentry_operations</code>数据结构来描述的，定义于<code>include/linux/dcache.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*d_revalidate)(<span class="keyword">struct</span> dentry *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*d_hash) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> qstr *);</span><br><span class="line">	<span class="type">int</span> (*d_compare) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> qstr *, <span class="keyword">struct</span> qstr *);</span><br><span class="line">	<span class="type">int</span> (*d_delete)(<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">void</span> (*d_release)(<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="type">void</span> (*d_iput)(<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>表给出目录项对象的方法及其描述。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数形成</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d_revalidate(dentry)</code></td>
<td>判定目录项是否有效。默认情况下，<code>VFS</code>函数什么也不做，而网络文件系统可以指定自己的函数</td>
</tr>
<tr>
<td><code>d_hash(dentry, hash)</code></td>
<td>生成一个哈希值。对目录项哈希表而言，这是一个具体文件系统的哈希函数。参数<code>dentry</code>标识包含该路径分量的目录。参数<code>hash</code>指向一个结构，该结构包含要查找的路径名分量以及由<code>hash</code>函数生成的哈希值</td>
</tr>
<tr>
<td><code>d_compare(dir, name1,  name2)</code></td>
<td>比较两个文件名。name1 应该属于<code>dir</code>所指目录。默认情况下，<code>VFS</code>的这个函数就是常用的字符串匹配。</td>
</tr>
<tr>
<td><code>d_delete(dentry)</code></td>
<td>如果对目录项的最后一个引用被删除(<code>d_count</code>变为“0”)，就调用该方法。默认情况下，<code>VFS</code>的这个函数什么也不做</td>
</tr>
<tr>
<td><code>d_release(dentry)</code></td>
<td>当要释放一个目录项时(放入<code>slab</code>分配器)，就调用该方法。默认情况下，VFS`的这个函数什么也不做</td>
</tr>
<tr>
<td><code>d_iput(dentry, ino)</code></td>
<td>当要丢弃目录项对应的索引节点时，就调用该方法。默认情况下，<code>VFS</code>的这个函数调用<code>iput()</code>释放索引节点</td>
</tr>
</tbody>
</table>
</div>
<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>文件操作是由<code>file_operations</code>结构来描述的，定义在<code>fs.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment"> * read, write, poll, fsync, readv, writev can be called</span></span><br><span class="line"><span class="comment"> * without the big kernel lock held in all filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *); </span><br><span class="line">	<span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">	<span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dentry *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*readv) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*writev) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">( *get_unmapped_area)</span><span class="params">( <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个数据结构就是连接<code>VFS</code>文件操作与具体文件系统的文件操作之间的枢纽，也是编写设备驱动程序的重要接口，后面还会给出进一步的说明。对每个函数的描述如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数形式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Owner()</code></td>
<td>指向模块的指针。只有驱动程序才把这个域置为<code>THIS_MODULE</code>，文件系统一般忽略这个域</td>
</tr>
<tr>
<td><code>llseek(file, offset, whence)</code></td>
<td>修改文件指针</td>
</tr>
<tr>
<td><code>read(file, buf, count, offset)</code></td>
<td>从文件的<code>offset</code>处开始读出<code>count</code>个字节，然后增加<code>*offset</code>的值</td>
</tr>
<tr>
<td><code>write(file, buf, count, offset)</code></td>
<td>从文件的<code>*offset</code>处开始写入<code>count</code>个字节，然后增加<code>*offset</code>的值</td>
</tr>
<tr>
<td><code>readdir(dir, dirent, filldir)</code></td>
<td>返回<code>dir</code>所指目录的下一个目录项，这个值存入参数<code>dirent</code>；参数<code>filldir</code>存放一个辅助函数的地址，该函数可以提取目录项的各个域</td>
</tr>
<tr>
<td><code>poll(file, poll_table)</code></td>
<td>检查是否存在关于某文件的操作事件，如果没有则睡眠，直到发生该类操作事件为止</td>
</tr>
<tr>
<td><code>ioctl(inode, file, cmd, arg)</code></td>
<td>向一个基本硬件设备发送命令。该方法只适用于设备文件</td>
</tr>
<tr>
<td><code>mmap(file, vma)</code></td>
<td>执行文件的内存映射，并将这个映射放入进程的地址空间</td>
</tr>
<tr>
<td><code>open(inode, file)</code></td>
<td>通过创建一个新的文件而打开一个文件，并把它链接到相应的索引节点</td>
</tr>
<tr>
<td><code>flush(file)</code></td>
<td>当关闭对一个打开文件的引用时，就调用该方法。也就是说，减少该文件对象<code>f_count</code>域的值。该方法的实际用途依赖于具体文件系统</td>
</tr>
<tr>
<td><code>release(inode, file)</code></td>
<td>释放文件对象。当关闭对打开文件的最后一个引用时，也就是说，该文件对象<code>f_count</code>域的值变为 0 时，调用该方法</td>
</tr>
<tr>
<td><code>fsync(file, dentry)</code></td>
<td>将<code>file</code>文件在高速缓存中的全部数据写入磁盘</td>
</tr>
<tr>
<td><code>fasync(file, on)</code></td>
<td>通过信号来启用或禁用异步<code>I/O</code>通告</td>
</tr>
<tr>
<td><code>check_media_change(dev)</code></td>
<td>检测自上次对设备文件操作以来是否存在介质的改变(可以对块设备使用这一方法，因为它支持可移动介质)</td>
</tr>
<tr>
<td><code>revalidate(dev)</code></td>
<td>恢复设备的一致性(由网络文件系统使用，这是在确认某个远程设备上的介质已被改变之后才使用)</td>
</tr>
<tr>
<td><code>lock(file, cmd, file_lock)</code></td>
<td>对<code>file</code>文件申请一个锁</td>
</tr>
<tr>
<td><code>readv(file, iovec, count, offset)</code></td>
<td>与<code>read()</code>类似，所不同的是，<code>readv()</code>把读入的数据放在多个缓冲区中(叫缓冲区向量)</td>
</tr>
<tr>
<td><code>writev(file, buf, iovec, offset)</code></td>
<td>与<code>write()</code>类似。所不同的是，<code>writev()</code>把数据写入多个缓冲区中(叫缓冲区向量)</td>
</tr>
</tbody>
</table>
</div>
<p><code>VFS</code>中定义的这个<code>file_operations</code>数据结构相当于一个标准模板，对于一个具体的文件系统来说，可能只用到其中的一些函数。注意，2.2 和 2.4 版在对<code>file_operations</code>进行初始化时有所不同，在 2.2 版中，如果某个函数没有定义，则将其置为<code>NULL</code>，如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">device_fops</span> =</span> &#123;</span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">/* seek */</span></span><br><span class="line">	device_read, <span class="comment">/* read */</span></span><br><span class="line">	device_write, <span class="comment">/* write */</span></span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">/* readdir */</span></span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">/* poll */</span></span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">/* ioctl */</span></span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">/* mmap */</span></span><br><span class="line">	device_open, <span class="comment">/* open */</span></span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">/* flush */</span></span><br><span class="line">	device_release <span class="comment">/* release */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是标准<code>C</code>的用法，在 2.4 版中，采用了<code>gcc</code>的扩展用法，如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">device_fops</span> =</span> &#123;</span><br><span class="line">	read : device_read, <span class="comment">/* read */</span></span><br><span class="line">	write : device_write, <span class="comment">/* write */</span></span><br><span class="line">	open : device_open, <span class="comment">/* open */</span></span><br><span class="line">	release : device_release <span class="comment">/* release */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种方式显然简单明了，在设备驱动程序的开发中，经常会用到这种形式。</p>
<h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><h3 id="块高速缓存"><a href="#块高速缓存" class="headerlink" title="块高速缓存"></a>块高速缓存</h3><p><code>Linux</code>支持的文件系统大多以块的形式组织文件，为了减少对物理块设备的访问，在文件以块的形式调入内存后，使用块高速缓存(buffer_cache)对它们进行管理。每个缓冲区由两部分组成，第 1 部分称为缓冲区首部，用数据结构<code>buffer_head</code>表示，第 2 部分是真正的缓冲区内容(即所存储的数据)。由于缓冲区首部不与数据区域相连，数据区域独立存储。因而在缓冲区首部中，有一个指向数据的指针和一个缓冲区长度的字段。图 8.6 给出了一个缓冲区的格式。<br><img src="/img/1634017201.jpg" alt=""></p>
<p>缓冲区首部包含如下内容。</p>
<ul>
<li>用于描述缓冲区内容的信息，包括：所在设备号、起始物理块号、包含在缓冲区中的字节数。</li>
<li>缓冲区状态的域：是否有有用数据、是否正在使用、重新利用之前是否要写回磁盘等。</li>
<li>用于管理的域。</li>
</ul>
<p><code>buffer-head</code>数据结构在<code>include\linux\fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Try to keep the most commonly used fields in single cache lines (16</span></span><br><span class="line"><span class="comment"> * bytes) to improve performance. This ordering should be</span></span><br><span class="line"><span class="comment"> * particularly beneficial on 32-bit processors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We use the first 16 bytes for the data which is used in searches</span></span><br><span class="line"><span class="comment"> * over the block hash lists (ie. getblk() and friends).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The second 16 bytes we use for lru buffer scans, as used by</span></span><br><span class="line"><span class="comment"> * sync_buffers() and refill_freelist(). -- sct</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">	<span class="comment">/* First cache line: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_next</span>;</span> <span class="comment">/* 哈希队列链表*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> b_blocknr; <span class="comment">/* 逻辑块号 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> b_size; <span class="comment">/* 块大小 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> b_list; <span class="comment">/* 本缓冲区所出现的链表 */</span></span><br><span class="line">	<span class="type">kdev_t</span> b_dev; <span class="comment">/* 虚拟设备标示符(B_FREE = free) */</span></span><br><span class="line">	<span class="type">atomic_t</span> b_count; <span class="comment">/* 块引用计数器 */</span></span><br><span class="line">	<span class="type">kdev_t</span> b_rdev; <span class="comment">/* 实际设备标识符*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> b_state; <span class="comment">/* 缓冲区状态位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> b_flushtime; <span class="comment">/* 对脏缓冲区进行刷新的时间*/</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_next_free</span>;</span><span class="comment">/* 指向`lru/free`链表中的下一个元素 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_prev_free</span>;</span><span class="comment">/* 指向链表中的上一个元素*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span><span class="comment">/* 每个页面中的缓冲区链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_reqnext</span>;</span> <span class="comment">/*请求队列 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> **<span class="title">b_pprev</span>;</span> <span class="comment">/* 哈希队列的双向链表 */</span></span><br><span class="line">	<span class="type">char</span> * b_data; <span class="comment">/* 指向数据块 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span> <span class="comment">/* 这个`bh`所映射的页面*/</span></span><br><span class="line">	<span class="type">void</span> (*b_end_io)(<span class="keyword">struct</span> buffer_head *bh, <span class="type">int</span> uptodate); <span class="comment">/* I/O`结束方法*/</span></span><br><span class="line">	<span class="type">void</span> *b_private; <span class="comment">/* 给`b_end_io`保留 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> b_rsector; <span class="comment">/* 缓冲区在磁盘上的实际位置*/</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> b_wait; <span class="comment">/* 缓冲区等待队列 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">b_inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_inode_buffers</span>;</span> <span class="comment">/* inode`脏缓冲区的循环链表*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中缓冲区状态在<code>fs.h</code>中定义为枚举类型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bh state bits */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bh_state_bits</span> &#123;</span></span><br><span class="line">	BH_Uptodate, <span class="comment">/* 如果缓冲区包含有效数据则置 1 */</span></span><br><span class="line">	BH_Dirty, <span class="comment">/* 如果缓冲区数据被改变则置 1 */</span></span><br><span class="line">	BH_Lock, <span class="comment">/* 如果缓冲区被锁定则置 1*/</span></span><br><span class="line">	BH_Req, <span class="comment">/* 如果缓冲区数据无效则置 0 */</span></span><br><span class="line">	BH_Mapped, <span class="comment">/* 如果缓冲区有一个磁盘映射则置 1 */</span></span><br><span class="line">	BH_New, <span class="comment">/* 如果缓冲区为新且还没有被写出则置 1 */</span></span><br><span class="line">	BH_Async, <span class="comment">/* 如果缓冲区是进行end_buffer_io_async I/O同步则置 1 */</span></span><br><span class="line">	BH_Wait_IO, <span class="comment">/* 如果我们应该把这个缓冲区写出则置 1 */</span></span><br><span class="line">	BH_launder, <span class="comment">/* 如果我们应该“清洗”这个缓冲区则置 1 */</span></span><br><span class="line">	BH_JBD, <span class="comment">/* 如果与journal_head相连接则置 1 */</span></span><br><span class="line">	BH_PrivateStart,<span class="comment">/* 这不是一个状态位，但是，第 1 位由其他实体用于私有分配*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显然一个缓冲区可以同时具有上述状态的几种。</p>
<p>块高速缓存的管理很复杂，下面先对空缓冲区、空闲缓冲区、正使用的缓冲区、缓冲区的大小以及缓冲区的类型作一个简短的介绍。</p>
<p>缓冲区可以分为两种，一种是包含了有效数据的，另一种是没有被使用的，即空缓冲区。具有有效数据并不能表明某个缓冲区正在被使用，毕竟，在同一时间内，被进程访问的缓冲区(即处于使用状态)只有少数几个。当前没有被进程访问的有效缓冲区和空缓冲区称为空闲缓冲区。其实，<code>buffer_head</code>结构中的<code>b_count</code>就可以反映出缓冲区是否处于使用状态。如果它为 0，则缓冲区是空闲的。大于 0，则缓冲区正被进程访问。</p>
<p>缓冲区的大小不是固定的，当前<code>Linux</code>支持 5 种大小的缓冲区，分别是 512、1024、2048、4096、8192 字节。<code>Linux</code>所支持的文件系统都使用共同的块高速缓存，在同一时刻，块高速缓存中存在着来自不同物理设备的数据块，为了支持这些不同大小的数据块，<code>Linux</code>使用了几种不同大小的缓冲区。当前的<code>Linux</code>缓冲区有 3 种类型，在<code>include/linux/fs.h</code>中有如下的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_CLEAN 0 <span class="comment">/*未使用的、干净的缓冲区*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LOCKED 1 <span class="comment">/*被锁定的缓冲区，正等待写入*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_DIRTY 2 <span class="comment">/*脏的缓冲区，其中有有效数据，需要写回磁盘*/</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>VFS</code>使用了多个链表来管理块高速缓存中的缓冲区。</p>
<p>首先，对于包含了有效数据的缓冲区，用一个哈希表来管理，用<code>hash_table</code>来指向这个哈希表。哈希索引值由数据块号以及其所在的设备标识号计算(散列)得到。所以在<code>buffer_head</code>这个结构中有一些用于哈希表管理的域。使用哈希表可以迅速地查找到所要寻找的数据块所在的缓冲区。</p>
<p>对于每一种类型的未使用的有效缓冲区，系统还使用一个<code>LRU</code>(最近最少使用)双链表管理，即<code>lru-list</code>链。由于共有 3 种类型的缓冲区，所以有 3 个这样的<code>LRU</code>链表。当需要访问某个数据块时，系统采取如下算法。</p>
<p>首先，根据数据块号和所在设备号在块高速缓存中查找，如果找到，则将它的<code>b_count</code>域加 1，因为这个域正是反映了当前使用这个缓冲区的进程数。如果这个缓冲区同时又处于某个<code>LRU</code>链中，则将它从<code>LRU</code>链中解开。如果数据块还没有调入缓冲区，则系统必须进行磁盘<code>I/O</code>操作，将数据块调入块高速缓存，同时将空缓冲区分配一个给它。如果块高速缓存已满(即没有空缓冲区可供分配)，则从某个<code>LRU</code>链首取下一个，先看是否置了“脏”位，如已置，则将它的内容写回磁盘。然后清空内容，将它分配给新的数据块。</p>
<p>在缓冲区使用完了后，将它的<code>b_count</code>域减 1，如果<code>b_count</code>变为 0，则将它放在某个<code>LRU</code>链尾，表示该缓冲区已可以重新利用。为了配合以上这些操作，以及其他一些多块高速缓存的操作，系统另外使用了几个链表，主要是：</p>
<ul>
<li>对于每一种大小的空闲缓冲区，系统使用一个链表管理，即<code>free_list</code>链。</li>
<li>对于空缓冲区，系统使用一个<code>unused_list</code>链管理。</li>
</ul>
<p>以上几种链表都在<code>fs/buffer.c</code>定义。</p>
<p><code>Linux</code>中，用<code>bdflush</code>守护进程完成对块高速缓存的一般管理。<code>bdflush</code>守护进程是一个简单的内核线程，在系统启动时运行，它在系统中注册的进程名称为<code>kflushd</code>，你可以使用<code>ps</code>命令看到此系统进程。它的一个作用是监视块高速缓存中的“脏”缓冲区，在分配或丢弃缓冲区时，将对“脏”缓冲区数目作一个统计。通常情况下，该进程处于休眠状态，当块高速缓存中“脏”缓冲区的数目达到一定的比例，默认是 60%，该进程将被唤醒。但是，如果系统急需，则在任何时刻都可以唤醒这个进程。使用<code>update</code>命令可以看到和改变这个数值。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># update -d</span></span><br></pre></td></tr></table></figure></p>
<p>当有数据写入缓冲区使之变成“脏”时，所有的“脏”缓冲区被连接到一个<code>BUF_DIRTY_LRU</code>链表中，<code>bdflush</code>会将适当数目的缓冲区中的数据块写到磁盘上。这个数值的缺省值为 500，可以用<code>update</code>命令改变这个值。</p>
<p>另一个与块高速缓存管理相关的是<code>update</code>命令，它不仅仅是一个命令，还是一个后台进程。当以超级用户的身份运行时(在系统初始化时)，它将周期性调用系统服务例程将老的“脏”缓冲区中内容“冲刷”到磁盘上去。它所完成的这个工作与<code>bdflush</code>类似，不同之处在于，当一个“脏”缓冲区完成这个操作后, 它将把写入到磁盘上的时间标记到<code>buffer_head</code>结构中。<code>update</code>每次运行时它将在系统的所有“脏”缓冲区中查找那些“冲刷”时间已经超过一定期限的，这些过期缓冲区都要被写回磁盘。</p>
<h3 id="索引节点高速缓存"><a href="#索引节点高速缓存" class="headerlink" title="索引节点高速缓存"></a>索引节点高速缓存</h3><p><code>VFS</code>也用了一个高速缓存来加快对索引节点的访问，和块高速缓存不同的一点是每个缓冲区不用再分为两个部分了，因为<code>inode</code>结构中已经有了类似于块高速缓存中缓冲区首部的域。索引节点高速缓存的实现代码全部在<code>fs/inode.c</code>。</p>
<h4 id="索引节点链表"><a href="#索引节点链表" class="headerlink" title="索引节点链表"></a>索引节点链表</h4><p>每个索引节点可能处于哈希表中，也可能同时处于下列“类型”链表的一种中：</p>
<ul>
<li><code>in_use</code>有效的索引节点，即<code>i_count &gt; 0</code> 且<code>i_nlink &gt; 0</code>(参看前面的<code>inode</code>结构)</li>
<li><code>dirty</code>类似于<code>in_use</code> ，但还“脏”；</li>
<li><code>unused</code>有效的索引节点但还没使用，即<code>i_count = 0</code>。</li>
</ul>
<p>这几个链表定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(inode_in_use)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(inode_unused)</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">inode_hashtable</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(anon_hash_chain)</span>; <span class="comment">/* for inodes with NULL i_sb */</span></span><br></pre></td></tr></table></figure></p>
<p>因此，索引节点高速缓存的结构概述如下。</p>
<ul>
<li>全局哈希表<code>inode_hashtable</code>，其中哈希值是根据每个超级块指针的值和 32 位索引节点号而得。对没有超级块的索引节点<code>inode-&gt;i_sb == NULL</code>，则将其加入到<code>anon_hash_chain</code>链表的首部。例如，<code>net/socket.c</code>中<code>sock_alloc()</code>函数，通过调用<code>fs/inode.c</code>中<code>get_empty_inode()</code>创建的套接字是一个匿名索引节点，这个节点就加入到了<code>anon_hash_chain</code>链表。</li>
<li>正在使用的索引节点链表。全局变量<code>inode_in_use</code>指向该链表中的首元素和尾元素。函数<code>get_empty_inode()</code>获得一个空节点，<code>get_new_inode()</code>获得一个新节点，通过这两个函数新分配的索引节点就加入到这个链表中。</li>
<li>未用索引节点链表。全局变量<code>inode_unused</code>的<code>next</code>域和<code>prev</code>域分别指向该链表中的首元素和尾元素。</li>
<li>脏索引节点链表。由相应超级块的<code>s_dirty</code>域指向该链表中的首元素和尾元素。</li>
<li>对<code>inode</code>对象的缓存，定义如下：<code>static kmem_cache_t * inode_cachep</code>，这是一个<code>Slab</code>缓存，用于分配和释放索引节点对象。</li>
</ul>
<p>索引节点的<code>i_hash</code>域指向哈希表，<code>i_list</code>指向<code>in_use</code>、<code>unused</code>或<code>dirty</code>某个链表。所有这些链表都受单个自旋锁<code>inode_lock</code>的保护，其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* A simple spinlock to protect the list manipulations.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* NOTE! You also have to own the lock if you change</span></span><br><span class="line"><span class="comment">* the i_state of an inode while it is in use..</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> inode_lock = SPIN_LOCK_UNLOCKED;</span><br></pre></td></tr></table></figure></p>
<p>索引节点高速缓存的初始化是由<code>inode_init()</code>实现的，而这个函数是在系统启动时由<code>init/main.c</code>中的<code>start_kernel()</code>函数调用的。<code>inode_init()</code>只有一个参数，表示索引节点高速缓存所使用的物理页面数。因此，索引节点高速缓存可以根据可用物理内存的大小来进行配置，例如，如果物理内存足够大，就可以创建一个大的哈希表。</p>
<p>索引节点状态的信息存放在数据结构<code>inodes_stat_t</code>中，在<code>fs/fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inodes_stat_t</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> nr_inodes;</span><br><span class="line">	<span class="type">int</span> nr_unused;</span><br><span class="line">	<span class="type">int</span> dummy[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">inodes_stat_t</span> <span class="title">inodes_stat</span></span></span><br></pre></td></tr></table></figure></p>
<p>用户程序可以通过<code>/proc/sys/fs/inode-nr</code>和<code>/proc/sys/fs/inode-state</code>获得索引节点高速缓存中索引节点总数及未用索引节点数。</p>
<h4 id="索引节点高速缓存的工作过程"><a href="#索引节点高速缓存的工作过程" class="headerlink" title="索引节点高速缓存的工作过程"></a>索引节点高速缓存的工作过程</h4><p>为了帮助大家理解索引节点高速缓存如何工作，我们来跟踪一下在打开<code>Ext2</code>文件系统的一个常规文件时，相应索引节点的作用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;file&quot;</span>, O_RDONLY);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure></p>
<p><code>open()</code>系统调用是由<code>fs/open.c</code>中的<code>sys_open</code>函数实现的，而真正的工作是由<code>fs/open.c</code>中的<code>filp_open()</code>函数完成的，<code>filp_open()</code>函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> file *<span class="title function_">filp_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename, <span class="type">int</span> flags, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> namei_flags, error;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span></span><br><span class="line">	namei_flags = flags;</span><br><span class="line">	<span class="keyword">if</span> ((namei_flags+<span class="number">1</span>) &amp; O_ACCMODE)</span><br><span class="line">		namei_flags++;</span><br><span class="line">	<span class="keyword">if</span> (namei_flags &amp; O_TRUNC)</span><br><span class="line">		namei_flags |= <span class="number">2</span>;</span><br><span class="line">	error = open_namei(filename, namei_flags, mode, &amp;nd);</span><br><span class="line">	<span class="keyword">if</span> (!error)</span><br><span class="line">		<span class="keyword">return</span> dentry_open(nd.dentry, nd.mnt, flags);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>nameidata</code>结构在<code>fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">last</span>;</span> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">int</span> last_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个数据结构是临时性的，其中，我们主要关注<code>dentry</code>和<code>mnt</code>域。<code>dentry</code>结构我们已经在前面介绍过，而<code>vfsmount</code>结构记录着所属文件系统的安装信息，例如文件系统的安装点、文件系统的根节点等。<code>filp_open()</code>主要调用以下两个函数。</p>
<ul>
<li><code>open_namei()</code>：填充目标文件所在目录的<code>dentry</code>结构和所在文件系统的<code>vfsmount</code>结构。在<code>dentry</code>结构中<code>dentry-&gt;d_inode</code>就指向目标文件的索引节点。</li>
<li><code>dentry_open()</code>：建立目标文件的一个“上下文”，即<code>file</code>数据结构，并让它与当前进程的<code>task_strrct</code>结构挂上钩。同时，在这个函数中，调用了具体文件系统的打开函数，即<code>f_op-&gt;open()</code>。该函数返回指向新建立的<code>file</code>结构的指针。</li>
</ul>
<p><code>open_namei()</code>函数通过<code>path_walk()</code>与目录项高速缓存(即目录项哈希表)打交道，而<code>path_walk()</code>又调用具体文件系统的<code>inode_operations-&gt;lookup()</code>方法；该方法从磁盘找到并读入当前节点的目录项，然后通过<code>iget(sb, ino)</code>，根据索引节点号从磁盘读入相应索引节点并在内存建立起相应的<code>inode</code>结构，这就到了我们讨论的索引节点高速缓存。</p>
<p>当索引节点读入内存后，通过调用<code>d_add(dentry, inode)</code>，就将<code>dentry</code>结构和<code>inode</code>结构之间的链接关系建立起来。两个数据结构之间的联系是双向的。一方面，<code>dentry</code>结构中的指针<code>d_inode</code>指向<code>inode</code>结构，这是一对一的关系，因为一个目录项只对应着一个文件。反之则不然，同一个文件可以有多个不同的文件名或路径(通过系统调用<code>link()</code>建立，注意与符号连接的区别，那是由<code>symlink()</code>建立的)，所以从<code>inode</code>结构到<code>dentry</code>结构的方向是一对多的关系。因此，<code>inode</code>结构的<code>i_ dentry</code>是个队列，<code>dentry</code>结构通过其队列头部<code>d_alias</code>挂入相应<code>inode</code>结构的队列中。</p>
<p>为了进一步说明索引节点高速缓存，我们来进一步考察<code>iget()</code>。当我们打开一个文件时，就调用了<code>iget()</code>函数，而<code>iget</code>真正调用的是<code>iget4(sb, ino, NULL, NULL)</code>函数，该函数代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode *<span class="title function_">iget4</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="type">unsigned</span> <span class="type">long</span> ino, <span class="type">find_inode_t</span> find_actor, <span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> * <span class="title">head</span> =</span> inode_hashtable + hash(sb,ino);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	spin_lock(&amp;inode_lock);</span><br><span class="line">	inode = find_inode(sb, ino, head, find_actor, opaque);</span><br><span class="line">	<span class="keyword">if</span> (inode) &#123;</span><br><span class="line">		__iget(inode);</span><br><span class="line">		spin_unlock(&amp;inode_lock);</span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">		<span class="keyword">return</span> inode;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;inode_lock);</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	* get_new_inode() will do the right thing, re-trying the search</span></span><br><span class="line"><span class="comment">	* in case it had to block at any point.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> get_new_inode(sb, ino, head, find_actor, opaque);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面对以上代码给出进一步的解释。</p>
<ul>
<li><code>inode</code>结构中有个哈希表<code>inode_hashtable</code>，首先在<code>inode_lock</code>锁的保护下，通过<code>find_ inode</code>函数在哈希表中查找目标节点的<code>inode</code>结构，由于索引节点号只有在同一设备上时才是唯一的，因此，在哈希计算时要把索引节点所在设备的<code>super_block</code>结构的地址也结合进去。如果在哈希表中找到该节点，则其引用计数<code>i_count</code>加 1；如果<code>i_count</code>在增加之前为 0，说明该节点不“脏”，则该节点当前肯定处于<code>inode_unused list</code>队列中，于是，就把该节点从这个队列删除而插入<code>inode_in_use</code>队列；最后，把<code>inodes_stat.nr_unused</code>减 1。</li>
<li>如果该节点当前被加锁，则必须等待，直到解锁，以便确保<code>iget4()</code>返回一个未加锁的节点。</li>
<li>如果在哈希表中没有找到该节点，说明目标节点的<code>inode</code>结构还不在内存，因此，调用<code>get_new_inode()</code>从磁盘上读入相应的索引节点并建立起一个<code>inode</code>结构，并把该结构插入到哈希表中。</li>
<li>对<code>get_new_inode()</code>给出进一步的说明，该函数从<code>slab</code>缓存区中分配一个新的<code>inode</code>结构，但是这个分配操作有可能出现阻塞，于是，就应当解除保护哈希表的<code>inode_lock</code>自旋锁，以便在哈希表中再次进行搜索。如果这次在哈希表中找到这个索引节点，就通过<code>__iget</code>把该节点的引用计数加 1，并撤销新分配的节点；如果在哈希表中还没有找到，就使用新分配的索引节点。因此，把该索引节点的一些域先初始化为必须的值，然后调用具体文件系统的<code>sb-&gt;s_op-&gt;read_inode()</code>域填充该节点的其他域。这就把我们从索引节点高速缓存带到了某个具体文件系统的代码中。当<code>s_op-&gt;read_inode()</code>方法正在从磁盘读索引节点时，该节点被加锁(<code>i_state = I_LOCK</code>)；当<code>read_inode()</code>返回时，该节点的锁被解除，并且唤醒所有等待者。</li>
</ul>
<h3 id="目录高速缓存"><a href="#目录高速缓存" class="headerlink" title="目录高速缓存"></a>目录高速缓存</h3><p>每个目录项对象属于以下 4 种状态之一。</p>
<ul>
<li>空闲状态：处于该状态的目录项对象不包含有效的信息，还没有被<code>VFS</code>使用。它对应的内存区由<code>slab</code>分配器进行管理。</li>
<li>未使用状态：处于该状态的目录项对象当前还没有被内核使用。该对象的引用计数器<code>d_count</code>的值为<code>NULL</code>。但其<code>d_inode</code>域仍然指向相关的索引节点。该目录项对象包含有效的信息，但为了在必要时回收内存，它的内容可能被丢弃。 </li>
<li>正在使用状态：处于该状态的目录项对象当前正在被内核使用。该对象的引用计数器<code>d_count</code>的值为正数，而其<code>d_inode</code>域指向相关的索引节点对象。该目录项对象包含有效的信息，并且不能被丢弃。</li>
<li>负状态：与目录项相关的索引节点不复存在，那是因为相应的磁盘索引节点已被删除。该目录项对象的<code>d_inode</code>域置为<code>NULL</code>，但该对象仍然被保存在目录项高速缓存中，以便后续对同一文件目录名的查找操作能够快速完成，术语“负的”容易使人误解，因为根本不涉及任何负值。</li>
</ul>
<p>为了最大限度地提高处理这些目录项对象的效率，<code>Linux</code>使用目录项高速缓存，它由以下两种类型的数据结构组成。</p>
<ul>
<li>处于正在使用、未使用或负状态的目录项对象的集合。</li>
<li>一个哈希表，从中能够快速获取与给定的文件名和目录名对应的目录项对象。如果访问的对象不在目录项高速缓存中，哈希函数返回一个空值。</li>
</ul>
<p>目录项高速缓存的作用也相当于索引节点高速缓存的控制器。内核内存中，目录项可能已经不使用，但与其相关的索引节点并不被丢弃，这是由于目录项高速缓存仍在使用它们，因此，索引节点的<code>i_count</code>域不为空。于是，这些索引节点对象还保存在<code>RAM</code>中，并能够借助相应的目录项快速引用它们。</p>
<p>所有“未使用”目录项对象都存放在一个“最近最少使用”的双向链表中，该链表按照插入的时间排序。一旦目录项高速缓存的空间开始变小，内核就从链表的尾部删除元素，使得多数最近经常使用的对象得以保留。<code>LRU</code>链表的首元素和尾元素的地址存放在变量<code>dentry_unused</code>中的<code>next</code>域和<code>prev</code>域中。目录项对象的<code>d_lru</code>域包含的指针指向该链表中相邻目录的对象。</p>
<p>每个“正在使用”的目录项对象都被插入一个双向链表中，该链表由相应索引节点对象的<code>i_dentry</code>域所指向。目录项对象的<code>d_alias</code>域存放链表中相邻元素的地址。当指向相应文件的最后一个硬链接被删除后，一个“正在使用”的目录项对象可能变成“负”状态。在这种情况下，该目录项对象被移到“未使用” 目录项对象组成的<code>LRU</code>链表中。每当内核缩减目录项高速缓存时，“负”状态目录项对象就朝着<code>LRU</code>链表的尾部移动，这样一来，这些对象就逐渐被释放。</p>
<p>哈希表是由<code>dentry_hashtable</code>数组实现的。数组中的每个元素是一个指向链表的指针，这种链表就是把具有相同哈希表值的目录项进行散列而形成的。该数组的长度取决于系统已安装<code>RAM</code>的数量。目录项对象的<code>d_hash</code>域包含指向具有相同<code>hash</code>值的链表中的相邻元素。哈希函数产生的值是由目录及文件名的目录项对象的地址计算出的。 </p>
<h2 id="文件系统的注册、安装与卸载"><a href="#文件系统的注册、安装与卸载" class="headerlink" title="文件系统的注册、安装与卸载"></a>文件系统的注册、安装与卸载</h2><h3 id="文件系统的注册"><a href="#文件系统的注册" class="headerlink" title="文件系统的注册"></a>文件系统的注册</h3><p>每个文件系统都有一个初始化例程，它的作用就是在<code>VFS</code>中进行注册，即填写一个叫做<code>file_system_type</code>的数据结构，该结构包含了文件系统的名称以及一个指向对应的<code>VFS</code>超级块读取例程的地址，所有已注册的文件系统的<code>file_system_type</code>结构形成一个链表，为区别后面将要说到的已安装的文件系统形成的另一个链表，我们把这个链表称为注册链表。</p>
<p><code>file_system_type</code>的数据结构在<code>fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">int</span> fs_flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *(*<span class="title">read_super</span>) (<span class="keyword">struct</span> <span class="title">super_block</span> *, <span class="title">void</span> *, <span class="title">int</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对其中几个域的说明如下。</p>
<ul>
<li><code>name</code>：文件系统的类型名，以字符串的形式出现。</li>
<li><code>fs_flags</code>：指明具体文件系统的一些特性，有关标志定义于<code>fs.h</code>中：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* public flags for file_system_type */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_REQUIRES_DEV 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_NO_DCACHE 2 <span class="comment">/* Only dcache the necessary things. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_NO_PRELIM 4 <span class="comment">/* prevent preloading of dentries, even if</span></span></span><br><span class="line"><span class="comment"><span class="meta"> 						* FS_NO_DCACHE is not set.</span></span></span><br><span class="line"><span class="comment"><span class="meta"> 						*/</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_SINGLE 8 <span class="comment">/* Filesystem that can have only one superblock */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_NOMOUNT 16 <span class="comment">/* Never mount from userland */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_LITTER 32 <span class="comment">/* Keeps the tree in dcache */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_ODD_RENAME 32768 <span class="comment">/* Temporary stuff; will go away as soon</span></span></span><br><span class="line"><span class="comment"><span class="meta">							* as nfs_rename() will be cleaned up</span></span></span><br><span class="line"><span class="comment"><span class="meta">							*/</span></span></span><br></pre></td></tr></table></figure>
<p>对某些常用标志的说明如下。</p>
<ol>
<li>有些虚拟的文件系统，如<code>pipe</code>、共享内存等，根本不允许由用户进程通过系统调用<code>mount()</code>来安装。这样的文件系统其<code>fs_flags</code>中的<code>FS_NOMOUNT</code>标志位为 1。</li>
<li>一般的文件系统类型要求有物理的设备作为其物质基础，其<code>fs_flags</code>中的<code>FS_REQUIRES_DEV</code>标志位为 1，这些文件系统如<code>Ext2</code>、<code>Minix</code>、<code>ufs</code>等。</li>
<li>有些虚拟文件系统在安装了同类型中的第 1 个“设备”，从而创建了其超级块的<code>super_block</code>数据结构，在安装同一类型中的其他设备时就共享已存在的<code>super_block</code>结构，而不再有自己的超级块结构。此时<code>fs_flags</code>中的<code>FS_SINGLE</code>标志位为 1，表示整个文件系统只有一个超级块，而不像一般的文件系统类型那样，每个具体的设备上都有一个超级块。</li>
</ol>
<ul>
<li><code>read_super</code>：这是各种文件系统读入其超级块的函数指针。因为不同的文件系统其超级块不同，因此其读入函数也不同。</li>
<li><code>owner</code>：如果<code>file_system_type</code>所代表的文件系统是通过可安装模块实现的，则该指针指向代表着具体模块的<code>module</code>结构。如果文件系统是静态地链接到内核，则这个域为<code>NULL</code>。<ul>
<li>实际上，你只需要把这个域置为<code>THIS_MODLUE</code>(这是个一个宏)，它就能自动地完成上述工作。</li>
</ul>
</li>
<li><code>next</code>：把所有的<code>file_system_type</code>结构链接成单项链表的链接指针，变量<code>file_systems</code>指向这个链表。这个链表是一个临界资源，受<code>file_systems_lock</code>自旋读写锁的保护。</li>
<li><code>fs_supers</code>：这个域是一个双向链表。链表中的元素是超级块结构。如前说述，每个文件系统都有一个超级块，但有些文件系统可能被安装在不同的设备上，而且每个具体的设备都有一个超级块，这些超级块就形成一个双向链表。</li>
</ul>
<p>搞清楚这个数据结构的各个域以后，就很容易理解注册函数<code>register_filesystem()</code>，该函数定义于<code>fs/super.c</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * register_filesystem - register a new filesystem</span></span><br><span class="line"><span class="comment"> * @fs: the file system structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Adds the file system passed to the list of file systems the kernel</span></span><br><span class="line"><span class="comment"> * is aware of for mount and other syscalls. Returns 0 on success,</span></span><br><span class="line"><span class="comment"> * or a negative errno code on an error.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The &amp;struct file_system_type that is passed is linked into the kernel</span></span><br><span class="line"><span class="comment"> * structures and must not be freed until the file system has been</span></span><br><span class="line"><span class="comment"> * unregistered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_filesystem</span><span class="params">(<span class="keyword">struct</span> file_system_type * fs)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> ** <span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (!fs)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (fs-&gt;next)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	INIT_LIST_HEAD(&amp;fs-&gt;fs_supers);</span><br><span class="line">	write_lock(&amp;file_systems_lock);</span><br><span class="line">	p = find_filesystem(fs-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (*p)</span><br><span class="line">		res = -EBUSY;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*p = fs;</span><br><span class="line">	write_unlock(&amp;file_systems_lock);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>find_filesystem()</code>函数在同一个文件中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> file_system_type **<span class="title function_">find_filesystem</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> **<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">for</span> (p=&amp;file_systems; *p; p=&amp;(*p)-&gt;next)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>((*p)-&gt;name,name) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，对注册链表的操作必须互斥地进行，因此，对该链表的查找加了写锁<code>write_lock</code>。文件系统注册后，还可以撤消这个注册，即从注册链表中删除一个<code>file_system_type</code>结构，此后系统不再支持该种文件系统。<code>fs/super.c</code>中的<code>unregister_filesystem()</code>函数就是起这个作用的，它在执行成功后返回 0，如果注册链表中本来就没有指定的要删除的结构，则返回-1，其代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* unregister_filesystem - unregister a file system</span></span><br><span class="line"><span class="comment">* @fs: filesystem to unregister</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Remove a file system that was previously successfully registered</span></span><br><span class="line"><span class="comment">* with the kernel. An error is returned if the file system is not found.</span></span><br><span class="line"><span class="comment">* Zero is returned on a success.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Once this function has returned the &amp;struct file_system_type structure</span></span><br><span class="line"><span class="comment">* may be freed or reused.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unregister_filesystem</span><span class="params">(<span class="keyword">struct</span> file_system_type * fs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> ** <span class="title">tmp</span>;</span></span><br><span class="line">	write_lock(&amp;file_systems_lock);</span><br><span class="line">	tmp = &amp;file_systems; </span><br><span class="line">	<span class="keyword">while</span> (*tmp) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fs == *tmp) &#123;</span><br><span class="line">			*tmp = fs-&gt;next;</span><br><span class="line">			fs-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">			write_unlock(&amp;file_systems_lock);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = &amp;(*tmp)-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	write_unlock(&amp;file_systems_lock);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件系统的安装"><a href="#文件系统的安装" class="headerlink" title="文件系统的安装"></a>文件系统的安装</h3><p>要使用一个文件系统，仅仅注册是不行的，还必须安装这个文件系统。在安装<code>Linux</code>时，硬盘上已经有一个分区安装了<code>Ext2</code>文件系统，它是作为根文件系统的，根文件系统在启动时自动安装。其实，在系统启动后你所看到的文件系统，都是在启动时安装的。如果需要自己(一般是超级用户)安装文件系统，则需要指定 3 种信息：文件系统的名称、包含文件系统的物理块设备、文件系统在已有文件系统中的安装点。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -t iso9660 /dev/hdc /mnt/cdrom</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>iso9660</code>就是文件系统的名称，<code>/dev/hdc</code>是包含文件系统的物理块设备，<code>/mnt/cdrom</code>是将要安装到的目录，即安装点。从这个例子可以看出，安装一个文件系统实际上是安装一个物理设备。</p>
<p>把一个文件系统(或设备)安装到一个目录点时要用到的主要数据结构为<code>vfsmount</code>，定义于<code>include/linux/mount.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_hash</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt_parent</span>;</span> <span class="comment">/* fs we are mounted on */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_mountpoint</span>;</span> <span class="comment">/* dentry of mountpoint */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span> <span class="comment">/* root of the mounted tree */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span> <span class="comment">/* pointer to superblock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_mounts</span>;</span> <span class="comment">/* list of children, anchored here */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_child</span>;</span> <span class="comment">/* and going through their mnt_child */</span></span><br><span class="line">	<span class="type">atomic_t</span> mnt_count;</span><br><span class="line">	<span class="type">int</span> mnt_flags;</span><br><span class="line">	<span class="type">char</span> *mnt_devname; <span class="comment">/* Name of device e.g. /dev/dsk/hda1 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面对结构中的主要域给予进一步说明。</p>
<ul>
<li>为了对系统中的所有安装点进行快速查找，内核把它们按哈希表来组织，<code>mnt_hash</code>就是形成哈希表的队列指针。</li>
<li><code>mnt_mountpoint</code>是指向安装点<code>dentry</code>结构的指针。而<code>dentry</code>指针指向安装点所在目录树中根目录的<code>dentry</code>结构。 </li>
<li><code>mnt_parent</code>是指向上一层安装点的指针。如果当前的安装点没有上一层安装点(如根设备)，则这个指针为<code>NULL</code>。同时，<code>vfsmount</code>结构中还有<code>mnt_mounts</code>和<code>mnt_child</code>两个队列头，只要上一层<code>vfsmount</code>结构存在，就把当前<code>vfsmount</code>结构中<code>mnt_child</code>链入上一层<code>vfsmount</code>结构的<code>mnt_mounts</code>队列中。这样就形成一个设备安装的树结构，从一个<code>vfsmount</code>结构的<code>mnt_mounts</code>队列开始，可以找到所有直接或间接安装在这个安装点上的其他设备。</li>
<li><code>mnt_sb</code>指向所安装设备的超级块结构<code>super_blaock</code>。</li>
<li><code>mnt_list</code>是指向<code>vfsmount</code>结构所形成链表的头指针。</li>
</ul>
<p>另外，系统还定义了<code>vfsmntlist</code>变量，指向<code>mnt_list</code>队列。对这个数据结构的进一步理解请看后面文件系统安装的具体实现过程。</p>
<p>文件系统的安装选项，也就是<code>vfsmount</code>结构中的安装标志<code>mnt_flags</code>在<code>linux/fs.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* These are the fs-independent mount-flags: up to 32 flags are supported</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_RDONLY 1 <span class="comment">/* Mount read-only */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_NOSUID 2 <span class="comment">/* Ignore suid and sgid bits */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_NODEV 4 <span class="comment">/* Disallow access to device special files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_NOEXEC 8 <span class="comment">/* Disallow program execution */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_SYNCHRONOUS 16 <span class="comment">/* Writes are synced at once */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_REMOUNT 32 <span class="comment">/* Alter flags of a mounted FS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_MANDLOCK 64 <span class="comment">/* Allow mandatory locks on an FS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_NOATIME 1024 <span class="comment">/* Do not update access times. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_NODIRATIME 2048 <span class="comment">/* Do not update directory access times */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_BIND 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_MOVE 8192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_REC 16384</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_VERBOSE 32768</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_ACTIVE (1&lt;&lt;30)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_NOUSER (1&lt;&lt;31)</span></span><br></pre></td></tr></table></figure></p>
<p>从定义可以看出，每个标志对应 32 位中的一位。安装标志是针对整个文件系统中的所有文件的。例如，如果<code>MS_NOSUID</code>标志为 1，则整个文件系统中所有可执行文件的<code>suid</code>标志位都不起作用了。</p>
<h4 id="安装根文件系统"><a href="#安装根文件系统" class="headerlink" title="安装根文件系统"></a>安装根文件系统</h4><p>当系统启动时，就要在变量<code>ROOT_DEV</code>中寻找包含根文件系统的磁盘主码。当编译内核或向最初的启动装入程序传递一个合适的选项时，根文件系统可以被指定为<code>/dev</code>目录下的一个设备文件。类似地，根文件系统的安装标志存放在<code>root_mountflags</code>变量中。用户可以指定这些标志，这是通过对已编译的内核映像执行<code>/sbin/rdev</code>外部程序，或者向最初的启动装入程序传递一个合适的选项来达到的。根文件系统的安装函数为<code>mount_root()</code>。 </p>
<h4 id="安装一个常规文件系统"><a href="#安装一个常规文件系统" class="headerlink" title="安装一个常规文件系统"></a>安装一个常规文件系统</h4><p>一旦在系统中安装了根文件系统，就可以安装其他的文件系统。每个文件系统都可以安装在系统目录树中的一个目录上。</p>
<p>前面我们介绍了以命令方式来安装文件系统，在用户程序中要安装一个文件系统则可以调用<code>mount()</code>系统调用。<code>mount()</code>系统调用在内核的实现函数为<code>sys_mount()</code>，其代码在<code>fs/namespace.c</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_mount</span><span class="params">(<span class="type">char</span> * dev_name, <span class="type">char</span> * dir_name, <span class="type">char</span> * type,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">void</span> * data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data_page;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> type_page;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> dev_page;</span><br><span class="line">	<span class="type">char</span> *dir_page;</span><br><span class="line">	retval = copy_mount_options (type, &amp;type_page);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	dir_page = getname(dir_name);</span><br><span class="line">	retval = PTR_ERR(dir_page);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dir_page))</span><br><span class="line">		<span class="keyword">goto</span> out1;</span><br><span class="line">	retval = copy_mount_options (dev_name, &amp;dev_page);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out2;</span><br><span class="line">	retval = copy_mount_options (data, &amp;data_page);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out3;</span><br><span class="line">	lock_kernel();</span><br><span class="line">	retval = do_mount((<span class="type">char</span>*)dev_page, dir_page, (<span class="type">char</span>*)type_page, flags, (<span class="type">void</span>*)data_page);</span><br><span class="line">	unlock_kernel();</span><br><span class="line">	free_page(data_page);</span><br><span class="line">out3:</span><br><span class="line">	free_page(dev_page);</span><br><span class="line">out2:</span><br><span class="line">	putname(dir_page);</span><br><span class="line">out1:</span><br><span class="line">	free_page(type_page);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出进一步的解释。</p>
<ul>
<li>参数<code>dev_name</code>为待安装文件系统所在设备的路径名，如果不需要就为空(例如，当待安装的是基于网络的文件系统时)；<code>dir_name</code>则是安装点(空闲目录)的路径名；<code>type</code>是文件系统的类型，必须是已注册文件系统的字符串名(如“Ext2”，“MSDOS”等)；<code>flags</code>是安装模式，如前面所述。<code>data</code>指向一个与文件系统相关的数据结构(可以为<code>NULL</code>)。</li>
<li><code>copy_mount_options()</code>和<code>getname()</code>函数将结构形式或字符串形式的参数值从用户空间拷贝到内核空间。这些参数值的长度均以一个页面为限，但是<code>getname()</code>在复制时遇到字符串结尾符“\0”就停止，并返回指向该字符串的指针；而<code>copy_mount_options()</code>则拷贝整个页面，并返回该页面的起始地址。</li>
</ul>
<p>该函数调用的主要函数为<code>do_mount()</code>，<code>do_mount()</code>执行期间要加内核锁，不过这个锁是针对<code>SMP</code>，我们暂不考虑。<code>do_mount()</code>的实现代码在<code>fs/namespace.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_mount</span><span class="params">(<span class="type">char</span> * dev_name, <span class="type">char</span> * dir_name, <span class="type">char</span> *type_page,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">void</span> *data_page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span></span><br><span class="line">	<span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mnt_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* Discard magic */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL)</span><br><span class="line">		flags &amp;= ~MS_MGC_MSK;</span><br><span class="line">	<span class="comment">/* Basic sanity checks */</span></span><br><span class="line">	<span class="keyword">if</span> (!dir_name || !*dir_name || !<span class="built_in">memchr</span>(dir_name, <span class="number">0</span>, PAGE_SIZE))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (dev_name &amp;&amp; !<span class="built_in">memchr</span>(dev_name, <span class="number">0</span>, PAGE_SIZE))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">/* Separate the per-mountpoint flags */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MS_NOSUID)</span><br><span class="line">		mnt_flags |= MNT_NOSUID;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MS_NODEV)</span><br><span class="line">		mnt_flags |= MNT_NODEV;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MS_NOEXEC)</span><br><span class="line">		mnt_flags |= MNT_NOEXEC;</span><br><span class="line">	flags &amp;= ~(MS_NOSUID|MS_NOEXEC|MS_NODEV);</span><br><span class="line">	<span class="comment">/* ... and get the mountpoint */</span></span><br><span class="line">	<span class="keyword">if</span> (path_init(dir_name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, &amp;nd))</span><br><span class="line">		retval = path_walk(dir_name, &amp;nd);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MS_REMOUNT)</span><br><span class="line">		retval = do_remount(&amp;nd, flags &amp; ~MS_REMOUNT, mnt_flags, data_page);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MS_BIND)</span><br><span class="line">		retval = do_loopback(&amp;nd, dev_name, flags &amp; MS_REC);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MS_MOVE)</span><br><span class="line">		retval = do_move_mount(&amp;nd, dev_name); </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		retval = do_add_mount(&amp;nd, type_page, flags, mnt_flags, dev_name, data_page);</span><br><span class="line">	path_release(&amp;nd);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面对函数中的主要代码给予解释。</p>
<ul>
<li><code>MS_MGC_VAL</code>和<code>MS_MGC_MSK</code>是在以前的版本中定义的安装标志和掩码，现在的安装标志中已经不使用这些魔数了，因此，当还有这个魔数时，则丢弃它。</li>
<li>对参数<code>dir_name</code>和<code>dev_name</code>进行基本检查，注意<code>!dir_name</code>和<code>!*dir_name</code>的不同，前者指指向字符串的指针为不为空，而后者指字符串不为空。<code>memchr()</code>函数在指定长度的字符串中寻找指定的字符，如果字符串中没有结尾符“\0”，也是一种错误。前面已说过，对于基于网络的文件系统<code>dev_name</code>可以为空。</li>
<li>把安装标志为<code>MS_NOSUID、MS_NOEXEC</code>和<code>MS_NODEV</code>的 3 个标志位从<code>flags</code>分离出来，放在局部安装标志变量<code>mnt_flags</code>中。</li>
<li>函数<code>path_init()</code>和<code>path_walk()</code>寻找安装点的<code>dentry</code>数据结构，找到的<code>dentry</code>结构存放在局部变量<code>nd</code>的<code>dentry</code>域中。</li>
<li>如果<code>flags</code>中的<code>MS_REMOUNT</code>标志位为 1，就表示所要求的只是改变一个原已安装设备的安装方式，例如从“只读“安装方式改为“可写”安装方式，这是通过调用<code>do_remount()</code>函数完成的。</li>
<li>如果<code>flags</code>中的<code>MS_BIND</code>标志位为 1，就表示把一个“回接”设备捆绑到另一个对象上。回接设备是一种特殊的设备(虚拟设备)，而实际上并不是一种真正设备，而是一种机制，这种机制提供了把回接设备回接到某个可访问的常规文件或块设备的手段。通常在<code>/dev</code>目录中有<code>/dev/loop0</code>和<code>/dev/loop1</code>两个回接设备文件。调用<code>do_loopback()</code>来实现回接设备的安装。</li>
<li>如果<code>flags</code>中的<code>MS_MOVE</code>标志位为 1，就表示把一个已安装的设备可以移到另一个安装点，这是通过调用<code>do_move_mount()</code>函数来实现的。</li>
<li>如果不是以上 3 种情况，那就是一般的安装请求，于是把安装点加入到目录树中，这是通过调用<code>do_add_mount()</code>函数来实现的，而<code>do_add_mount()</code>首先调用<code>do_kern_mount()</code>函数形成一个安装点，该函数的代码在<code>fs/super.c</code>中：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vfsmount *<span class="title function_">do_kern_mount</span><span class="params">(<span class="type">char</span> *type, <span class="type">int</span> flags, <span class="type">char</span> *name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">fstype</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!type || !<span class="built_in">memchr</span>(type, <span class="number">0</span>, PAGE_SIZE))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we need capabilities... */</span></span><br><span class="line">	<span class="keyword">if</span> (!capable(CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EPERM);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ... filesystem driver... */</span> </span><br><span class="line"></span><br><span class="line">	fstype = get_fs_type(type);</span><br><span class="line">	<span class="keyword">if</span> (!fstype)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">	<span class="comment">/* ... allocated vfsmount... */</span></span><br><span class="line">	mnt = alloc_vfsmnt();</span><br><span class="line">	<span class="keyword">if</span> (!mnt) &#123;</span><br><span class="line">		mnt = ERR_PTR(-ENOMEM);</span><br><span class="line">		<span class="keyword">goto</span> fs_out;</span><br><span class="line">	&#125;</span><br><span class="line">	set_devname(mnt, name);</span><br><span class="line">	<span class="comment">/* get locked superblock */</span></span><br><span class="line">	<span class="keyword">if</span> (fstype-&gt;fs_flags &amp; FS_REQUIRES_DEV)</span><br><span class="line">		sb = get_sb_bdev(fstype, name, flags, data);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (fstype-&gt;fs_flags &amp; FS_SINGLE)</span><br><span class="line">		sb = get_sb_single(fstype, flags, data);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sb = get_sb_nodev(fstype, flags, data);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(sb)) &#123;</span><br><span class="line">		free_vfsmnt(mnt);</span><br><span class="line">		mnt = (<span class="keyword">struct</span> vfsmount *)sb;</span><br><span class="line">		<span class="keyword">goto</span> fs_out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fstype-&gt;fs_flags &amp; FS_NOMOUNT)</span><br><span class="line">		sb-&gt;s_flags |= MS_NOUSER;</span><br><span class="line"></span><br><span class="line">	mnt-&gt;mnt_sb = sb;</span><br><span class="line">	mnt-&gt;mnt_root = dget(sb-&gt;s_root);</span><br><span class="line">	mnt-&gt;mnt_mountpoint = mnt-&gt;mnt_root;</span><br><span class="line">	mnt-&gt;mnt_parent = mnt;</span><br><span class="line">	up_write(&amp;sb-&gt;s_umount);</span><br><span class="line">fs_out:</span><br><span class="line">	put_filesystem(fstype);</span><br><span class="line">	<span class="keyword">return</span> mnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对该函数的解释如下。</p>
<ul>
<li>只有系统管理员才具有安装一个设备的权力，因此首先要检查当前进程是否具有这种权限。</li>
<li><code>get_fs_type()</code>函数根据具体文件系统的类型名在<code>file_system_file</code>链表中找到相应的结构。</li>
<li><code>alloc_vfsmnt()</code>函数调用<code>slab</code>分配器给类型为<code>vfsmount</code>结构的局部变量<code>mnt</code>分配空间，并进行相应的初始化。</li>
<li><code>set_devname()</code>函数设置设备名。</li>
<li>一般的文件系统类型要求有物理的设备作为其物质基础，如果<code>fs_flags</code>中的<code>FS_REQUIRES_DEV</code>标志位为 1，说明这就是正常的文件系统类型，如<code>Ext2、mnix</code>等。对于这种文件系统类型，通过调用<code>get_sb_bdev()</code>从待安装设备上读其超级块。</li>
<li>如果<code>fs_flags</code>中的<code>FS_SINGLE</code>标志位为 1，说明整个文件系统只有一个类型，也就是说，这是一种虚拟的文件系统类型。这种文件类型在安装了同类型的第 1 个“设备”，通过调用<code>get_sb_single()</code>创建了超级块<code>super_block</code>结构后，再安装的同类型设备就共享这个数据结构。但是像<code>Ext2</code>这样的文件系统类型在每个具体设备上都有一个超级块。</li>
<li>还有些文件系统类型的<code>fs_flags</code>中的<code>FS_NOMOUNT、FS_REUIRE_DEV</code>以及<code>FS_SINGLE</code>标志位全都为 0，那么这些所谓的文件系统其实是“虚拟的”，通常只是用来实现某种机制或者规程，所以根本就没有对应的物理设备。对于这样的文件系统类型都是通过<code>get_sb_nodev()</code>来生成一个<code>super_block</code>结构的。</li>
<li>如果文件类型<code>fs_flags</code>的<code>FS_NOMOUNT</code>标志位为 1，说明根本就没有用户进行安装，因此，把超级块中的<code>MS_NOUSER</code>标志位置 1。</li>
<li><code>mnt-&gt;mnt_sb</code>指向所安装设备的超级块<code>sb</code>；<code>mnt-&gt;mnt_root</code>指向其超级块的根<code>b-&gt;s_root</code>，<code>dget()</code>函数把<code>dentry</code>的引用计数<code>count</code>加 1；<code>mnt-&gt;mnt_mountpoint</code>也指向超级块的根，而<code>mnt-&gt;mnt_parent</code>指向自己。到此为止，仅仅形成了一个安装点，但还没有把这个安装点挂接在目录树上。</li>
</ul>
<p>下面我们来看<code>do_add_mount()</code>的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_add_mount</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">char</span> *type, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params"> <span class="type">int</span> mnt_flags, <span class="type">char</span> *name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span> =</span> do_kern_mount(type, flags, name, data);</span><br><span class="line">	<span class="type">int</span> err = PTR_ERR(mnt);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(mnt))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	down(&amp;mount_sem);</span><br><span class="line">	<span class="comment">/* Something was mounted here while we slept */</span></span><br><span class="line">	<span class="keyword">while</span>(d_mountpoint(nd-&gt;dentry) &amp;&amp; follow_down(&amp;nd-&gt;mnt, &amp;nd-&gt;dentry)) ;</span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (!check_mnt(nd-&gt;mnt))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	<span class="comment">/* Refuse the same filesystem on the same mount point */</span></span><br><span class="line">	err = -EBUSY;</span><br><span class="line">	<span class="keyword">if</span> (nd-&gt;mnt-&gt;mnt_sb == mnt-&gt;mnt_sb &amp;&amp; nd-&gt;mnt-&gt;mnt_root == nd-&gt;dentry)</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	mnt-&gt;mnt_flags = mnt_flags;</span><br><span class="line">	err = graft_tree(mnt, nd);</span><br><span class="line">nlock:</span><br><span class="line">	up(&amp;mount_sem);</span><br><span class="line">	mntput(mnt);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是对以上代码的解释。</p>
<ul>
<li>首先检查<code>do_kern_mount()</code>所形成的安装点是否有效。</li>
<li>在<code>do_mount()</code>函数中，<code>path_init()</code>和<code>path_walk()</code>函数已经找到了安装点的<code>dentry</code>结构、<code>inode</code>结构以及<code>vfsmount</code>结构，并存放在类型为<code>nameidata</code>的局部变量<code>nd</code>中，在<code>do_add_mount()</code>中通过参数传递了过来。</li>
<li>但是，在<code>do_kern_mount()</code>函数中从设备上读入超级块的过程是个较为漫长的过程，当前进程在等待从设备上读入超级块的过程中几乎可肯定要睡眠，这样就有可能另一个进程捷足先登抢先将另一个设备安装到了同一个安装点上。<code>d_mountpoint()</code>函数就是检查是否发生了这种情况。如果确实发生了这种情况，其对策就是调用<code>follow_down()</code>前进到已安装设备的根节点，并且通过<code>while</code>循环进一步检测新的安装点，直到找到一个空安装点为止。</li>
<li>如果在同一个安装点上要安装两个同样的文件系统，则出错。</li>
<li>调用<code>graft_tree()</code>把<code>mnt</code>与安装树挂接起来，完成最终的安装。</li>
<li>至此，设备的安装就完成了。</li>
</ul>
<h3 id="文件系统的卸载"><a href="#文件系统的卸载" class="headerlink" title="文件系统的卸载"></a>文件系统的卸载</h3><p>如果文件系统中的文件当前正在使用，该文件系统是不能被卸载的。如果文件系统中的文件或目录正在使用，则<code>VFS</code>索引节点高速缓存中可能包含相应的<code>VFS</code>索引节点。根据文件系统所在设备的标识符，检查在索引节点高速缓存中是否有来自该文件系统的<code>VFS</code>索引节点，如果有且使用计数大于 0，则说明该文件系统正在被使用，因此，该文件系统不能被卸载。否则，查看对应的<code>VFS</code>超级块，如果该文件系统的<code>VFS</code>超级块标志为“脏”，则必须将超级块信息写回磁盘。上述过程结束之后，对应的<code>VFS</code>超级块被释放，<code>vfsmount</code>数据结构将从<code>vfsmntlist</code>链表中断开并被释放。具体的实现代码为<code>fs/super.c</code>中的<code>sysy_umount()</code>函数，在此不再进行详细的讨论。</p>
<h2 id="限额机制"><a href="#限额机制" class="headerlink" title="限额机制"></a>限额机制</h2><p>限额机制对一个用户可分配的文件数目和可使用的磁盘空间设置了限制。限制有软限制和硬限制之分，硬限制是绝对不允许超过的，而软限制则由系统管理员来确定。当用户占用的资源超过软限制时，系统开始启动定时机制，并在用户的终端上显示警告信息，但并不终止用户进程的运行，在<code>include/linux/quota.h</code>中有如下宏定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_IQ_TIME 604800 <span class="comment">/* (7*24*60*60) =1 周 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_DQ_TIME 604800 <span class="comment">/* (7*24*60*60) =1 周 */</span></span></span><br></pre></td></tr></table></figure></p>
<p>分别是超过索引节点软限制的最长允许时间和超过块的软限制的最长允许时间。</p>
<p>首先，在编译内核时，要选择“支持限额机制”一项，默认情况下，<code>Linux</code>不使用限额机制。如果使用了限额机制，每一个安装的文件系统都与一个限额文件相联系，限额文件通常驻留在文件系统的根目录里，它实际是一组以用户标识号来索引的限额记录，每个限额记录可称为一个限额块，其数据结构如下(在<code>inclue/linux/quota.h</code>中定义)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dqblk</span> &#123;</span></span><br><span class="line">	__u32 dqb_bhardlimit; <span class="comment">/* 块的硬限制*/</span></span><br><span class="line">	__u32 dqb_bsoftlimit; <span class="comment">/* 块的软限制 */</span></span><br><span class="line">	__u32 dqb_curblocks; <span class="comment">/* 当前占有的块数 */</span></span><br><span class="line">	__u32 dqb_ihardlimit; <span class="comment">/* 索引节点的硬限制 */</span></span><br><span class="line">	__u32 dqb_isoftlimit; <span class="comment">/* 索引节点的软限制 */</span></span><br><span class="line">	__u32 dqb_curinodes; <span class="comment">/* 当前占用的索引节点数 */</span></span><br><span class="line">	<span class="type">time_t</span> dqb_btime; <span class="comment">/* 块的软限制变为硬限制前，剩余的警告次数*/</span></span><br><span class="line">	<span class="type">time_t</span> dqb_itime; <span class="comment">/* 索引节点的软限制变为硬限制前，剩余的警告次数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>限额块调入内存后，用哈希表来管理，这就要用到另一个结构<code>dquot</code>(也在<code>inclue/linux/quota.h</code>中定义)，其数据结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dquot</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dq_hash</span>;</span> <span class="comment">/*在内存的哈希表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dq_inuse</span>;</span> <span class="comment">/*正在使用的限额块组成的链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dq_free</span>;</span> <span class="comment">/* 空闲限额块组成的链表 */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> dq_wait_lock; <span class="comment">/* 指向加锁限额块的等待队列*/</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> dq_wait_free; <span class="comment">/* 指向未用限额块的等待队列*/</span></span><br><span class="line">	<span class="type">int</span> dq_count; <span class="comment">/* 引用计数 */</span></span><br><span class="line">	<span class="comment">/* fields after this point are cleared when invalidating */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">dq_sb</span>;</span> <span class="comment">/* superblock this applies to */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> dq_id; <span class="comment">/* ID this applies to (uid, gid) */</span></span><br><span class="line">	<span class="type">kdev_t</span> dq_dev; <span class="comment">/* Device this applies to */</span></span><br><span class="line">	<span class="type">short</span> dq_type; <span class="comment">/* Type of quota */</span></span><br><span class="line">	<span class="type">short</span> dq_flags; <span class="comment">/* See DQ_* */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> dq_referenced; <span class="comment">/* Number of times this dquot was</span></span><br><span class="line"><span class="comment">	referenced during its lifetime */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dqblk</span> <span class="title">dq_dqb</span>;</span> <span class="comment">/* Diskquota usage */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>哈希表是用文件系统所在的设备号和用户标识号为散列关键值的。<code>vfs</code>的索引节点结构中有一个指向<code>dquot</code>结构的指针。也就是说，调入内存的索引节点都要与相应的<code>dquot</code>结构联系，<code>dquot</code>结构中，引用计数就是反映了当前有几个索引节点与之联系，只有在引用计数为 0 时，才将该结构放入空闲链表中。</p>
<p>如果使用了限额机制，则当有新的块分配请求，系统要以文件拥有者的标识号为索引去查找限额文件中相应的限额块，如果限额并没有满，则接受请求，并把它加入使用计数中。如果已达到或超过限额，则拒绝请求，并返回错误信息。</p>
<h2 id="文件系统的系统调用"><a href="#文件系统的系统调用" class="headerlink" title="文件系统的系统调用"></a>文件系统的系统调用</h2><h3 id="open系统调用"><a href="#open系统调用" class="headerlink" title="open系统调用"></a>open系统调用</h3><p>进程要访问一个文件，必须首先获得一个文件描述符，这是通过<code>open</code>系统调用来完成的。该系统调用是用来获得欲访问文件的文件描述符，如果文件并不存在，则还可以用它来创建一个新文件。其函数为<code>sys_open()</code>，在<code>fs/open.c</code>中定义，函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename, <span class="type">int</span> flags, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> * tmp;</span><br><span class="line">	<span class="type">int</span> fd, error;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BITS_PER_LONG != 32</span></span><br><span class="line">	flags |= O_LARGEFILE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	tmp = getname(filename);</span><br><span class="line">	fd = PTR_ERR(tmp);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(tmp)) &#123;</span><br><span class="line">		fd = get_unused_fd();</span><br><span class="line">		<span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> filp_open(tmp, flags, mode);</span><br><span class="line">			error = PTR_ERR(f);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(f))</span><br><span class="line">				<span class="keyword">goto</span> out_error;</span><br><span class="line">			fd_install(fd, f);</span><br><span class="line">		&#125;</span><br><span class="line">out:</span><br><span class="line">		putname(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fd; </span><br><span class="line"></span><br><span class="line">out_error:</span><br><span class="line">	put_unused_fd(fd);</span><br><span class="line">	fd = error;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1．入口参数</p>
<ul>
<li><code>filename</code>：欲打开文件的路径。</li>
<li><code>flags</code>：规定如何打开该文件，它必须取下列 3 个值之一。<ul>
<li><code>O_RDONLY</code>以只读方式打开文件</li>
<li><code>O_WRONLY</code>以只写方式打开文件</li>
<li><code>O_RDWR</code>以读和写的方式打开文件</li>
<li>此外，还可以用或运算对下列标志值任意组合。<ul>
<li><code>O_CREAT</code>打开文件，如果文件不存在则建立文件</li>
<li><code>O_EXCL</code>如果已经置<code>O_CREAT</code>且文件存在，则强制<code>open()</code>失败</li>
<li><code>O_TRUNC</code>将文件的长度截为 0</li>
<li><code>O_APPEND</code>强制<code>write()</code>从文件尾开始</li>
</ul>
</li>
<li>对于终端文件，这 4 个标志是没有任何意义的，另提供了两个新的标志。<ul>
<li><code>O_NOCTTY</code>停止这个终端作为控制终端</li>
<li><code>O_NONBLOCK</code>使<code>open()</code>、<code>read()</code>、<code>write()</code>不被阻塞。</li>
</ul>
</li>
<li>这些标志的符号名称在<code>/include/asmi386/fcntl.h</code>中定义。</li>
</ul>
</li>
<li><code>mode</code>：这个参数实际上是可选的，如果用<code>open()</code>创建一个新文件，则要用到该参数，它用来规定对该文件的所有者、文件的用户组和系统中其他用户的访问权限位。它用或运算对下列符号常量建立所需的组合。<ul>
<li><code>S_IRUSR</code>文件所有者的读权限位</li>
<li><code>S_IWUSR</code>文件所有者的写权限位</li>
<li><code>S_IXUSR</code>文件所有者的执行权限位</li>
<li><code>S_IRGRP</code>文件用户组的读权限位</li>
<li><code>S_IWGRP</code>文件用户组的写权限位</li>
<li><code>S_IXGRP</code>文件用户组的执行权限位</li>
<li><code>S_IROTH</code>文件其他用户的读权限位</li>
<li><code>S_IWOTH</code>文件其他用户的写权限位</li>
<li><code>S_IXOTH</code>文件其他用户的执行权限位</li>
<li>这些标志的符号名称在<code>/include/linux/stat.h</code>中定义。</li>
</ul>
</li>
</ul>
<h4 id="出口参数"><a href="#出口参数" class="headerlink" title="出口参数"></a>出口参数</h4><p>返回一个文件描述符。 </p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p><code>sys_open()</code>主要是调用<code>filp_open()</code>，这个函数也在<code>fs/open.c</code>中，这已在前面做过介绍。</p>
<p>从当前进程的<code>files_struct</code>结构的<code>fd</code>数组中找到第 1 个未使用项，使其指向<code>file</code>结构，将该项的下标作为文件描述符返回，结束。</p>
<p>在以上过程中，如果出错，则将分配的文件描述符、<code>file</code>结构收回，<code>inode</code>也被释放，函数返回一个负数以示出错，其中<code>PTR_ERR()</code>和<code>IS_ERR()</code>是出错处理函数。</p>
<h3 id="read系统调用"><a href="#read系统调用" class="headerlink" title="read系统调用"></a>read系统调用</h3><p>如果通过<code>open</code>调用获得一个文件描述符，而且是用<code>O_RDONLY</code>或<code>O_RDWR</code>标志打开的，就可以用<code>read</code>系统调用从该文件中读取字节。其内核函数在<code>fs/read_write.c</code>中定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">ssize_t</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">char</span> * buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line">	ret = -EBADF;</span><br><span class="line">	file = fget(fd);</span><br><span class="line">	<span class="keyword">if</span> (file) &#123;</span><br><span class="line">		<span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_READ) &#123;</span><br><span class="line">			ret = locks_verify_area ( FLOCK_VERIFY_READ,</span><br><span class="line">			file-&gt;f_dentry-&gt;d_inode,</span><br><span class="line">			file, file-&gt;f_pos, count);</span><br><span class="line">			<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">				<span class="type">ssize_t</span> (*read)(<span class="keyword">struct</span> file *, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">				ret = -EINVAL;</span><br><span class="line">				<span class="keyword">if</span> (file-&gt;f_op &amp;&amp; (read = file-&gt;f_op-&gt;read) != <span class="literal">NULL</span>)</span><br><span class="line">					ret = read(file, buf, count, &amp;file-&gt;f_pos);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">			dnotify_parent(file-&gt;f_dentry, DN_ACCESS);</span><br><span class="line">		fput(file);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="入口参数"><a href="#入口参数" class="headerlink" title="入口参数"></a>入口参数</h4><ul>
<li><code>fd</code>：要读的文件的文件描述符。</li>
<li><code>buf</code>：指向用户内存区中用来存储将读取字节的区域的指针。</li>
<li><code>count</code>：欲读的字节数。 </li>
</ul>
<h4 id="出口参数-1"><a href="#出口参数-1" class="headerlink" title="出口参数"></a>出口参数</h4><p>返回一个整数。在出错时返回-1；否则返回所读的字节数，通常这个数就是<code>count</code>值，但如果请求的字节数超过剩余的字节数，则返回实际读的字节数，例如文件的当前位置在文件尾，则返回值为 0。</p>
<h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><ol>
<li>函数<code>fget()</code>根据打开文件号<code>fd</code>找到该文件已打开文件的<code>file</code>结构。</li>
<li>取得了目标文件的<code>file</code>结构指针，并确认文件是以只读方式打开后，还要检查文件从当前位置<code>f_pos</code>开始的<code>count</code>个字节是否对读操作加上了“强制锁”，这是通过调用<code>locks_verify_area()</code>函数完成的，其代码在<code>fs.h</code>中。</li>
<li>通过了对强制锁的检查后，就是读操作本身了。</li>
<li>如果读操作的返回值大于 0，说明出错，则调用<code>dnotify_parent()</code>报告错误，并释放文件描述符、<code>file</code>结构、<code>inode</code>结构。</li>
</ol>
<h3 id="fcntl系统调用"><a href="#fcntl系统调用" class="headerlink" title="fcntl系统调用"></a>fcntl系统调用</h3><p>这个系统调用功能比较多，可以执行多种操作，其内核函数在<code>fs/fcntl.c</code>中定义。</p>
<h4 id="入口参数-1"><a href="#入口参数-1" class="headerlink" title="入口参数"></a>入口参数</h4><ol>
<li><code>fd</code>：欲访问文件的文件描述符。</li>
<li><code>cmd</code>：要执行的操作的命令，这个参数定义了 10 个标志，下面介绍其中的 5 个，<code>F_DUPFD</code>、<code>F_GETFD</code>、<code>F_SETFD</code>、<code>F_GETFL</code>和<code>F_SETFL</code></li>
<li><code>arg</code>：可选，主要根据<code>cmd</code>来决定是否需要。</li>
</ol>
<h4 id="出口参数-2"><a href="#出口参数-2" class="headerlink" title="出口参数"></a>出口参数</h4><p>根据第二个参数(cmd)的不同，这个返回值也不一样</p>
<h4 id="函数功能"><a href="#函数功能" class="headerlink" title="函数功能"></a>函数功能</h4><ul>
<li>如果第二个参数(cmd)取值是<code>F_DUPFD</code>，则进行复制文件描述符的操作。它需要用到第三个参数<code>arg</code>，这时<code>arg</code>是一个文件描述符，<code>fcntl(fd, F_DUPFD, arg)</code>在<code>files_struct</code>结构中从指定的<code>arg</code>开始搜索空闲的文件描述符，找到第一个后，将<code>fd</code>的内容复制进来，然后将新找到的文件描述符返回。</li>
<li>第二个参数(cmd)取值是<code>F_GETFD</code>，则返回<code>files_struct</code>结构中<code>close_on_exec</code>的值。无需第三个参数。</li>
<li>第二个参数(cmd)取值是<code>F_SETFD</code>，则需要第三个参数，若<code>arg</code>最低位为 1，则对<code>close_on_exec</code>置位，否则清除<code>close_on_exec</code>。</li>
<li>第二个参数(cmd)取值是<code>F_GETFL</code>，则用来读取<code>open</code>系统调用第二个参数设置的标志，即文件的打开方式(<code>O_RDONLY</code>，<code>O_WRONLY</code>，<code>O_APPEND</code>等)，它不需要第三个参数。实际上这时函数返回的是<code>file</code>结构中的<code>flags</code>域。</li>
<li>第二个参数(cmd)取值是<code>F_SETFL</code>，则用来对<code>open</code>系统调用第二个参数设置的标志进行改变，但是它只能对<code>O_APPEND</code>和<code>O_NONBLOCK</code>标志进行改变，这时需要第三个参数<code>arg</code>，用来确定如何改变。函数返回 0 表示操作成功，否则返回-1，并置一个错</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B04/" rel="prev" title="深入分析Linux内核源码笔记4">
      <i class="fa fa-chevron-left"></i> 深入分析Linux内核源码笔记4
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/15/ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" rel="next" title="glibc内存管理ptmalloc源代码分析1">
      glibc内存管理ptmalloc源代码分析1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">1.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">1.1.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E7%AE%A1%E9%81%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.1.</span> <span class="nav-text">Linux管道的实现机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">管道的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">管道的读写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.1.2.</span> <span class="nav-text">管道的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93CFIFOC"><span class="nav-number">1.1.3.</span> <span class="nav-text">命名管道CFIFOC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7-signal"><span class="nav-number">1.2.</span> <span class="nav-text">信号(signal)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB"><span class="nav-number">1.2.1.</span> <span class="nav-text">信号种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%8E%A9%E7%A0%81"><span class="nav-number">1.2.2.</span> <span class="nav-text">信号掩码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.2.3.</span> <span class="nav-text">系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kill%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">kill系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pause-%E5%92%8Calarm-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">pause()和alarm()系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.4.</span> <span class="nav-text">典型系统调用的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.5.</span> <span class="nav-text">进程与信号的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.2.6.</span> <span class="nav-text">信号举例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System-V%E7%9A%84IPC%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">System V的IPC机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">信号量的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9Asemget"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">系统调用：semget()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-semop"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">系统调用: semop()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9Asemctl"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">系统调用：semctl()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.3.2.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-msgget"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">系统调用: msgget()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9Amsgsnd"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">系统调用：msgsnd()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9Amsgrcv"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">系统调用：msgrcv()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">1.3.3.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">共享内存的处理过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9Ashmget"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">系统调用：shmget()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9Ashmat"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">系统调用：shmat()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9Ashmctl"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">系统调用：shmctl()</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">虚拟文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">虚拟文件系统的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VFS%E6%89%80%E5%A4%84%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.1.2.</span> <span class="nav-text">VFS所处理的系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VFS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">VFS中的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E7%BA%A7%E5%9D%97"><span class="nav-number">2.2.1.</span> <span class="nav-text">超级块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VFS%E7%9A%84%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.2.</span> <span class="nav-text">VFS的索引节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.3.</span> <span class="nav-text">目录项对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.4.</span> <span class="nav-text">与进程相关的文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">文件对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">用户打开文件表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9A%84fs-struct%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">关于文件系统信息的fs_struct结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.2.5.</span> <span class="nav-text">主要数据结构间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%85%B3%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.6.</span> <span class="nav-text">有关操作的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E7%BA%A7%E5%9D%97%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">超级块操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9Cinode-operations"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">索引节点操作inode_operations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.6.3.</span> <span class="nav-text">目录项操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.6.4.</span> <span class="nav-text">文件操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">2.3.</span> <span class="nav-text">高速缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">2.3.1.</span> <span class="nav-text">块高速缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">2.3.2.</span> <span class="nav-text">索引节点高速缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">索引节点链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">索引节点高速缓存的工作过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">2.3.3.</span> <span class="nav-text">目录高速缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B3%A8%E5%86%8C%E3%80%81%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="nav-number">2.4.</span> <span class="nav-text">文件系统的注册、安装与卸载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-number">2.4.1.</span> <span class="nav-text">文件系统的注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">2.4.2.</span> <span class="nav-text">文件系统的安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">安装根文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E4%B8%80%E4%B8%AA%E5%B8%B8%E8%A7%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">安装一个常规文件系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="nav-number">2.4.3.</span> <span class="nav-text">文件系统的卸载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E9%A2%9D%E6%9C%BA%E5%88%B6"><span class="nav-number">2.5.</span> <span class="nav-text">限额机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.6.</span> <span class="nav-text">文件系统的系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#open%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.6.1.</span> <span class="nav-text">open系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E5%8F%A3%E5%8F%82%E6%95%B0"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">出口参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">执行过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.6.2.</span> <span class="nav-text">read系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3%E5%8F%82%E6%95%B0"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">入口参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E5%8F%A3%E5%8F%82%E6%95%B0-1"><span class="nav-number">2.6.2.2.</span> <span class="nav-text">出口参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-1"><span class="nav-number">2.6.2.3.</span> <span class="nav-text">执行过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fcntl%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.6.3.</span> <span class="nav-text">fcntl系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3%E5%8F%82%E6%95%B0-1"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">入口参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E5%8F%A3%E5%8F%82%E6%95%B0-2"><span class="nav-number">2.6.3.2.</span> <span class="nav-text">出口参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD"><span class="nav-number">2.6.3.3.</span> <span class="nav-text">函数功能</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
