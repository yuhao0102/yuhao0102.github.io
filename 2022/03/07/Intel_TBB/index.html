<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="在多核的平台上开发并行化的程序，必须合理地利用系统的资源 - 如与内核数目相匹配的线程，内存的合理访问次序，最大化重用缓存。有时候用户使用(系统)低级的应用接口创建、管理线程，很难保证是否程序处于最佳状态。  Intel Thread Building Blocks (TBB) 很好地解决了上述问题：   TBB提供C++模版库，用户不必关注线程，而专注任务本身。  抽象层仅需很少的接口代码，性能">
<meta property="og:type" content="article">
<meta property="og:title" content="Intel Thread Building Blocks (TBB)">
<meta property="og:url" content="http://yoursite.com/2022/03/07/Intel_TBB/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="在多核的平台上开发并行化的程序，必须合理地利用系统的资源 - 如与内核数目相匹配的线程，内存的合理访问次序，最大化重用缓存。有时候用户使用(系统)低级的应用接口创建、管理线程，很难保证是否程序处于最佳状态。  Intel Thread Building Blocks (TBB) 很好地解决了上述问题：   TBB提供C++模版库，用户不必关注线程，而专注任务本身。  抽象层仅需很少的接口代码，性能">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/20150401170607494.jpg">
<meta property="og:image" content="http://yoursite.com/img/20150415215857456.jpg">
<meta property="og:image" content="http://yoursite.com/img/20150415220015936.jpg">
<meta property="article:published_time" content="2022-03-07T14:51:00.000Z">
<meta property="article:modified_time" content="2022-03-11T09:21:41.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/20150401170607494.jpg">

<link rel="canonical" href="http://yoursite.com/2022/03/07/Intel_TBB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>Intel Thread Building Blocks (TBB) | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/03/07/Intel_TBB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Intel Thread Building Blocks (TBB)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-07 22:51:00" itemprop="dateCreated datePublished" datetime="2022-03-07T22:51:00+08:00">2022-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-11 17:21:41" itemprop="dateModified" datetime="2022-03-11T17:21:41+08:00">2022-03-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在多核的平台上开发并行化的程序，必须合理地利用系统的资源 - 如与内核数目相匹配的线程，内存的合理访问次序，最大化重用缓存。有时候用户使用(系统)低级的应用接口创建、管理线程，很难保证是否程序处于最佳状态。 </p>
<p>Intel Thread Building Blocks (TBB) 很好地解决了上述问题： </p>
<ul>
<li>TBB提供C++模版库，用户不必关注线程，而专注任务本身。 </li>
<li>抽象层仅需很少的接口代码，性能上毫不逊色。 </li>
<li>灵活地适合不同的多核平台。 </li>
<li>线程库的接口适合于跨平台的移植(Linux, Windows, Mac) </li>
<li>支持的C++编译器 – Microsoft, GNU and Intel  </li>
</ul>
<p>主要的功能：</p>
<ul>
<li>通用的并行算法 <ul>
<li>循环的并行： <ul>
<li>parallel_for, parallel_reduce – 相对独立的循环层 </li>
<li>parallel_scan – 依赖于上一层的结果 </li>
</ul>
</li>
</ul>
</li>
<li>流的并行算法 <ul>
<li>parallel_while – 用于非结构化的流或堆 </li>
<li>pipeline - 对流水线的每一阶段并行，有效使用缓存 </li>
</ul>
</li>
<li>并行排序 <ul>
<li>parallel_sort – 并行快速排序，调用了parallel_for </li>
</ul>
</li>
<li>任务调度者 <ul>
<li>管理线程池，及隐藏本地线程复杂度 </li>
<li>并行算法的实现由任务调度者的接口完成 </li>
<li>任务调度者的设计考虑到本地线程的并行所引起的性能问题 </li>
</ul>
</li>
<li>并行容器 <ul>
<li>concurrent_hash_map </li>
<li>concurrent_vector </li>
<li>concurrent_queue </li>
</ul>
</li>
<li>同步原语 <ul>
<li>atomic </li>
<li>mutex </li>
<li>spin_mutex – 适合于较小的敏感区域 </li>
<li>queuing_mutex – 线程按次序等待(获得)一个锁 </li>
<li>spin_rw_mutex </li>
<li>queuing_rw_mutex </li>
</ul>
</li>
<li>高性能的内存申请 <ul>
<li>使用TBB的allocator 代替 C语言的 malloc/realloc/free 调用 </li>
<li>使用TBB的allocator 代替 C++语言的 new/delete 操作 </li>
</ul>
</li>
</ul>
<h1 id="术语与基本概念"><a href="#术语与基本概念" class="headerlink" title="术语与基本概念"></a>术语与基本概念</h1><h2 id="分割（splitable-concept）："><a href="#分割（splitable-concept）：" class="headerlink" title="分割（splitable concept）："></a>分割（splitable concept）：</h2><p>包含一个分割构造函数的类型是可分割的。分割构造函数原型为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X::X(X&amp; obj, Split)</span><br></pre></td></tr></table></figure></p>
<p>能将实例obj分割为obj以及一个新构造的对象。其中的Split是一个哑元参数，在tbb_stddef.h中的有其定义（一个空类）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class split &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>TBB将在以下情况使用分割构造：</p>
<ul>
<li>将一个区域（range）分为两个子区域（subrange）以便并行处理</li>
<li>将一个主体（body，即函数对象）分为两个主体以便并行处理 </li>
</ul>
<h2 id="区域（range-concept）"><a href="#区域（range-concept）" class="headerlink" title="区域（range concept）"></a>区域（range concept）</h2><p>描述了一种集合类型的需求，这种集合可被递归分割。区域类型R必须满足以下需求： </p>
<ul>
<li><code>R::R(const R&amp; )</code>：构造函数</li>
<li><code>R::~R()</code>：析构函数</li>
<li><code>bool R::empty() const</code>：区域为空返回ture</li>
<li><code>bool R::is_divisible() const</code>：如果区域可再分，返回ture</li>
<li><code>R::R(R&amp; r, split)</code>：将r分为两个子区域</li>
</ul>
<p>TBB内置了三种区域模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenameValue&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blocked_range</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;typenameRowValue, <span class="keyword">typename</span> ColValue&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blocked_range2d</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;typenamePageValue, <span class="keyword">typename</span> RowValue, <span class="keyword">typename</span> ColValue&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blocked_range3d</span>; </span><br></pre></td></tr></table></figure></p>
<p><code>blocked_range&lt;Value&gt;</code>描述了一个能被递归分割的半开放区域[I,j)。 </p>
<h2 id="分割器（partitioner）："><a href="#分割器（partitioner）：" class="headerlink" title="分割器（partitioner）："></a>分割器（partitioner）：</h2><p>指定了循环模板将其任务分割后分配给各个线程的方式。循环模板（如parallel_for、parallel_reduce、parallel_scan）的默认行为只是尽量递归将区域分割以使所有的处理器处于繁忙状态，不一定分割的尽可能合适。如下表所示，可选的分割器参数允许指定其他的行为： </p>
<ul>
<li><code>const auto_partitioner&amp;</code>：按负载平衡进行分割，而不是真正依照Range::is_divisible的许可。当与类（比如blocked_range）一起使用时，选择一个合适的粒度也很重要。常规可接受的性能可以通过尺寸为1的默认粒度来达到。</li>
<li><code>affinity_partitioner&amp;</code>：与auto_partitioner类似，但通过选择映射子区域到工作线程提高缓存的亲缘性。当一个循环体在一个相同的数据集再次执行并且该数据集与缓存相符时，能显著提高性能。</li>
<li><code>const simple_partitioner&amp;</code>：递归分割一个区域，直到不能再分。何时终止递归分割由函数Range：：is_devisible完全决定。当与blocked_range等类一起使用时，选择合适的可并发粒度在限制开销方面至关重要。</li>
</ul>
<h1 id="基本算法参考及使用"><a href="#基本算法参考及使用" class="headerlink" title="基本算法参考及使用"></a>基本算法参考及使用</h1><h2 id="基本算法（algorithms）"><a href="#基本算法（algorithms）" class="headerlink" title="基本算法（algorithms）"></a>基本算法（algorithms）</h2><p>Intel TBB提供的大多数并行算法支持泛型。但是这些受支持的类型必须实现必要的概念方法。并行算法可以嵌套，例如，一个<code>parallel_for</code>的内部可以调用另一个<code>parallel_for</code>。目前版本的TBB（4.0）提供的基本算法如下所示：</p>
<ul>
<li>parallel_for</li>
<li>parallel_reduce</li>
<li>parallel_scan</li>
<li>parallel_do</li>
<li>管道(pipeline、parallel_pipeline)</li>
<li>parallel_sort</li>
<li>parallel_invoke</li>
</ul>
<h3 id="parallel-for"><a href="#parallel-for" class="headerlink" title="parallel_for"></a>parallel_for</h3><p>parallel_for是在一个值域执行并行迭代操作的模板函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenameIndex, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">Func <span class="title">parallel_for</span><span class="params">( Index first, Index_type last, <span class="type">const</span> Func&amp; f</span></span></span><br><span class="line"><span class="params"><span class="function">                  [, task_group_context&amp;group] )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenameIndex, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">Func <span class="title">parallel_for</span><span class="params">( Index first, Index_type last, </span></span></span><br><span class="line"><span class="params"><span class="function">                  Index step, <span class="type">const</span> Func&amp;f</span></span></span><br><span class="line"><span class="params"><span class="function">                  [, task_group_context&amp;group] )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenameRange, <span class="keyword">typename</span> Body&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_for</span><span class="params">( <span class="type">const</span> Range&amp; range, <span class="type">const</span> Body&amp; body, </span></span></span><br><span class="line"><span class="params"><span class="function">                  [, partitioner[,task_group_context&amp; group]] )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>头文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “tbb/parallel_for.h”</span></span><br></pre></td></tr></table></figure></p>
<p><code>parallel_for(first, last,step, f)</code>表示一个循环的并行执行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i= first; i&lt;last; i+=step) <span class="built_in">f</span>(i);</span><br></pre></td></tr></table></figure></p>
<p>注意以下几点：</p>
<ol>
<li>索引类型必须是整形</li>
<li>循环不能回环</li>
<li>步长（step）必须为正，如果省略了，隐指为1</li>
<li>并没有保证迭代操作以并行方式进行</li>
<li>较小的迭代等待更大的迭代可能会发生死锁</li>
<li>分割策略总是auto_partitioner</li>
</ol>
<p><code>parallel_for(range, body, partitioner)</code>提供了并行迭代的泛型形式。它表示在区域的每个值，并行执行<code>body</code>。<code>partitioner</code>选项指定了分割策略。Range类型必须符合Range概念模型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt;::iterator IntVecIt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">body</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> blocked_range&lt;IntVecIt&gt;&amp;r)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> i = r.<span class="built_in">begin</span>(); i!=r.<span class="built_in">end</span>(); i++)</span><br><span class="line">         cout&lt;&lt;*i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">      vec.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt; IntVecIt&gt;(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>())</span><br><span class="line">      , <span class="built_in">body</span>());</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parallel-reduce"><a href="#parallel-reduce" class="headerlink" title="parallel_reduce"></a>parallel_reduce</h3><p>parallel_reduce模板在一个区域迭代，将由各个任务计算得到的部分结果合并，得到最终结果。</p>
<p>parallel_reduce对区域（range）类型的要求与parallel_for一样。body类型需要分割构造函数以及一个join方法。body的分割构造函数拷贝运行循环体需要的只读数据，并分配并归操作中初始化并归变量的标志元素。join方法会组合并归操作中各任务的结果。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenameRange, <span class="keyword">typename</span> Value, </span></span><br><span class="line"><span class="function">        <span class="keyword">typename</span> Func, <span class="keyword">typename</span> Reduction&gt;</span></span><br><span class="line"><span class="function">Value <span class="title">parallel_reduce</span><span class="params">(<span class="type">const</span> Range&amp; range, <span class="type">const</span> Value&amp; identity,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> Func&amp; func,<span class="type">const</span> Reduction&amp; reduction,</span></span></span><br><span class="line"><span class="params"><span class="function">                    [, partitioner[,task_group_context&amp; group]] )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenameRange, <span class="keyword">typename</span> Body&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_reduce</span><span class="params">(<span class="type">const</span> Range&amp; range, <span class="type">const</span> Body&amp; body</span></span></span><br><span class="line"><span class="params"><span class="function">                     [, partitioner[,task_group_context&amp; group]] )</span></span>;</span><br></pre></td></tr></table></figure>
<p>头文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “tbb/parallel_reduce.h”</span></span><br></pre></td></tr></table></figure></p>
<p>parallel_reduce模板有两种形式。函数形式是为方便与lambda表达式一起使用而设计。第二种形式是为了最小化数据拷贝。下面总结了第一种形式中的identity,func,reduction的类型要求要求：</p>
<ul>
<li><code>Value Identity</code>：<code>Func::operator()</code>的左标识元素</li>
<li><code>Value Func::operator()(const Range&amp; range, const Value&amp; x)</code>：累计从初始值x开始的子区域的结果</li>
<li><code>Value Reduction::operator()(const Value&amp; x, const Value&amp; y);</code>：合并x跟y的结果</li>
</ul>
<p>parallel_reduce使用分割构造函数来为每个线程生成一个或多个body的拷贝。当它拷贝body的时候，也许body的<code>operator()</code>或者<code>join()</code>正在并发运行。要确保这种并发运行下的安全。典型应用中，这种安全要求不会消耗你太多的精力。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_reduce.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">      vec.<span class="built_in">push_back</span>(i);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">parallel_reduce</span>(blocked_range&lt;vector&lt;<span class="type">int</span>&gt;::iterator&gt;(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()),</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        [](<span class="type">const</span> blocked_range&lt;vector&lt;<span class="type">int</span>&gt;::iterator&gt;&amp; r, <span class="type">int</span> init)-&gt;<span class="type">int</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> a = r.<span class="built_in">begin</span>(); a!=r.<span class="built_in">end</span>(); a++)</span><br><span class="line">                init+=*a;</span><br><span class="line">            <span class="keyword">return</span> init;</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        [](<span class="type">int</span> x, <span class="type">int</span> y)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x+y;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;result:&quot;</span>&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> n = <span class="number">1</span>&lt;&lt;<span class="number">26</span>;</span><br><span class="line">    <span class="type">float</span> res = tbb::<span class="built_in">parallel_reduce</span>(tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n), (<span class="type">float</span>)<span class="number">0</span>,</span><br><span class="line">    [&amp;] (tbb::blocked_range&lt;<span class="type">size_t</span>&gt; r, <span class="type">float</span> local_res) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">            local_res += std::<span class="built_in">sin</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> local_res;</span><br><span class="line">    &#125;, [] (<span class="type">float</span> x, <span class="type">float</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parallel-scan"><a href="#parallel-scan" class="headerlink" title="parallel_scan"></a>parallel_scan</h3><p>并行计算前束（prefix）的函数模板。即输入一个数组，生成一个数组，其中每个元素的值都是原数组中在此元素之前的元素的某个运算符的结果的累积。比如求和：输入：[2, 8,  9, -4,  1, 3, -2,  7]，生成：[0, 2, 10, 19, 15, 16, 19, 17]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_scan</span><span class="params">( <span class="type">const</span> Range&amp; range, Body&amp; body )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_scan</span><span class="params">( <span class="type">const</span> Range&amp; range, Body&amp; body, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">    auto_partitioner&amp; )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_scan</span><span class="params">( <span class="type">const</span> Range&amp; range, Body&amp; body, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">simple_partitioner&amp; )</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “tbb/parallel_scan.h”</span></span><br></pre></td></tr></table></figure>
<p><code>parallel_scan&lt;Range,Body&gt;</code>以泛型形式实现并行前束。它的要求如下：</p>
<ul>
<li><code>void Body::operator()(const Range&amp; r, pre_scan tag)</code>：累积归纳区域r</li>
<li>·void Body::operator()(const Range&amp; r, final_scan tag)`：归纳区域r以及计算扫描结果</li>
<li><code>Body::Body(Body&amp; b, split)</code>：分割b以便this和b能被单独累积归纳。*this对象即本表下行的对象a</li>
<li><code>void Body::reverse_join(Body&amp; a)</code>：将a的归纳结果合并到this，this是先前从a的分割构造函数中创建的。*this对象即本表上一行中的对象b</li>
<li><code>void Body::assign(Body&amp; b)</code>：将b的归纳结果赋给this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_scan.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Body</span></span><br><span class="line">&#123;</span><br><span class="line">    T _sum;</span><br><span class="line">    T* <span class="type">const</span> _y;</span><br><span class="line">    <span class="type">const</span> T* <span class="type">const</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Body</span>(T y[], <span class="type">const</span> T x[]):_sum(<span class="number">0</span>), _x(x), _y(y)&#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">get_sum</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _sum;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tag&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> blocked_range&lt;<span class="type">int</span>&gt;&amp; r, Tag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T temp = _sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i&lt; r.<span class="built_in">end</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp+=_x[i];</span><br><span class="line">            <span class="keyword">if</span>(Tag::<span class="built_in">is_final_scan</span>())</span><br><span class="line">                _y[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        _sum = temp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Body</span>(Body&amp;b, split):_x(b._x), _y(b._y), _sum(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse_join</span><span class="params">(Body&amp; a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _sum+=a._sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(Body&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _sum = b._sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> y[<span class="number">10</span>];</span><br><span class="line">    <span class="function">Body&lt;<span class="type">int</span>&gt; <span class="title">body</span><span class="params">(y,x)</span></span>;</span><br><span class="line">    <span class="built_in">parallel_scan</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, <span class="number">10</span>), body);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sum:&quot;</span>&lt;&lt;body.<span class="built_in">get_sum</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> n = <span class="number">1</span>&lt;&lt;<span class="number">26</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">float</span> res = tbb::<span class="built_in">parallel_scan</span>(tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n), (<span class="type">float</span>)<span class="number">0</span>,</span><br><span class="line">    [&amp;] (tbb::blocked_range&lt;<span class="type">size_t</span>&gt; r, <span class="type">float</span> local_res, <span class="keyword">auto</span> is_final) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">            local_res += std::<span class="built_in">sin</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (is_final) &#123;</span><br><span class="line">                a[i] = local_res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> local_res;</span><br><span class="line">    &#125;, [] (<span class="type">float</span> x, <span class="type">float</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a[n / <span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parallel-do"><a href="#parallel-do" class="headerlink" title="parallel_do"></a>parallel_do</h3><p>并行处理工作项的模板函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Body&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_do</span><span class="params">( InputIterator first, InputIteratorlast,</span></span></span><br><span class="line"><span class="params"><span class="function">    Body body[,task_group_context&amp; group] )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/parallel_do.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><code>parallel_do(first, last,body)</code>在对处于半开放区间[first, last)的元素应用函数对象body（不见得并行运行）。如果body重载的()函数的第二个参数（类型为<code>parallel_do_feeder</code>）不为空，那么可以增加另外的工作项。当对输入队列或者通过<code>parallel_do_feeder::add</code>方法添加的所有项x执行的<code>body(x)</code>都返回后，函数结束。其中的<code>parallel_do_feeder</code>允许<code>parallel_do</code>的<code>body</code>添加额外的工作项，只有<code>parallel_do</code>才能创建或者销毁<code>parallel_do_feeder</code>对象。其他的代码对<code>parallel_do_feeder</code>唯一能做的事就是调用它的add方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_do.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">t_test</span></span><br><span class="line">&#123;</span><br><span class="line">       string msg;</span><br><span class="line">       <span class="type">int</span> ref;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           cout&lt;&lt;msg&lt;&lt;endl;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">body_test</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* t, parallel_do_feeder&lt;T*&gt;&amp; feeder)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">              (*t)();</span><br><span class="line">              <span class="keyword">if</span>(t-&gt;ref == <span class="number">0</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                   t-&gt;msg = <span class="string">&quot;added msg&quot;</span>;</span><br><span class="line">                   feeder.<span class="built_in">add</span>(t);</span><br><span class="line">                   t-&gt;ref++;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;    </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       t_test *pt = <span class="keyword">new</span> t_test;</span><br><span class="line">       pt-&gt;ref = <span class="number">0</span>;</span><br><span class="line">       pt-&gt;msg = <span class="string">&quot;original msg&quot;</span>;</span><br><span class="line"> </span><br><span class="line">       vector&lt;t_test*&gt; vec;</span><br><span class="line">       vec.<span class="built_in">push_back</span>(pt);</span><br><span class="line">       <span class="built_in">parallel_do</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">body_test</span>&lt;t_test&gt;());</span><br><span class="line">       <span class="keyword">delete</span> pt;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pipleline"><a href="#pipleline" class="headerlink" title="pipleline"></a>pipleline</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pipeline</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">pipeline</span>();</span><br><span class="line">    ~<span class="built_in">pipeline</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_filter</span><span class="params">( filter&amp; f )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">( <span class="type">size_t</span> max_number_of_live_tokens</span></span></span><br><span class="line"><span class="params"><span class="function">                        [,task_group_context&amp; group] )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可按以下步骤使用pipeline类：</p>
<ol>
<li>从filter继承类f，f的构造函数传递给基类filter的构造函数一个参数，来指定它的模式</li>
<li>重载虚方法<code>filter::operator()</code>来实现过滤器对元素处理，并返回一个将被下一个过滤器处理的元素指针。如果流里没有其他的要处理的元素，返回空值。最后一个过滤器的返回值将被忽略。</li>
<li>生成pipeline类的实例</li>
<li>生成过滤器f的实例，并将它们按先后顺序加给pipeline。一个过滤器的实例一次只能加给一个pipeline。同一时间，一个过滤器禁止成为多个pipeline的成员。</li>
<li>调用pipeline::run方法。参数max_number_of_live_tokens指定了能并发运行的阶段数量上限。较高的值会以更多的内存消耗为代价来增加并发性。 </li>
</ol>
<p>函数<code>parallel_pipeline</code>提供了一种强类型的面向lambda的方式来建立并运行管道。 </p>
<p>过滤器基类filter<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">filter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">mode</span></span><br><span class="line">    &#123;</span><br><span class="line">        parallel = implementation-defined,</span><br><span class="line">        serial_in_order = implementation-defined,</span><br><span class="line">        serial_out_of_order =implementation-defined</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_serial</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_ordered</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="type">void</span>* item )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">finalize</span><span class="params">( <span class="type">void</span>* item )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">filter</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">filter</span>( mode );</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>过滤器模式有三种模式：parallel，serial_in_order,serial_out_of_order</p>
<ul>
<li>parallel过滤器能不按特定的顺序并行处理多个工作项</li>
<li>serial_out_of_order过滤器不按特定的顺序每次处理一个工作项</li>
<li>serial_in_order过滤器每次处理一个工作项。管道中的所有serial_in_order过滤器都按同样的顺序处理工作项。</li>
</ul>
<p>由于parallel过滤器支持并行加速，所以推荐使用。如果必须使用serial过滤器，那么serial_out_of_order类型的过滤器是优先考虑的，因为他在处理顺序上的约束较少。</p>
<h3 id="线程绑定过滤器thread-bound-filter"><a href="#线程绑定过滤器thread-bound-filter" class="headerlink" title="线程绑定过滤器thread_bound_filter"></a>线程绑定过滤器thread_bound_filter</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_bound_filter</span>: <span class="keyword">public</span> filter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">thread_bound_filter</span>(mode filter_mode);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">result_type</span></span><br><span class="line">    &#123;</span><br><span class="line">        success,</span><br><span class="line">        item_not_available,</span><br><span class="line">        end_of_stream</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">result_type <span class="title">try_process_item</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">result_type <span class="title">process_item</span><span class="params">()</span></span>;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>管道中过滤器的抽象基类，线程必须显式为其提供服务。当一个过滤器必须由某个指定线程执行的时候会派上用场。服务于<code>thread_bound_filter</code>的线程不能是调用<code>pipeline::run()</code>的线程。 </p>
<p>example:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/pipeline.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tbb/compat/thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tbb/task_scheduler_init.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> namespacestd;</span><br><span class="line"><span class="keyword">using</span> namespacetbb;</span><br><span class="line"><span class="type">char</span> input[] =<span class="string">&quot;abcdefg\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">inputfilter</span>:<span class="keyword">public</span> filter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;input:&quot;</span>&lt;&lt;*_ptr&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> _ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inputfilter</span>():<span class="built_in">filter</span>(serial_in_order),_ptr(input)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">outputfilter</span>: <span class="keyword">public</span> thread_bound_filter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span> *item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;*(<span class="type">char</span>*)item;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">outputfilter</span>():<span class="built_in">thread_bound_filter</span>(serial_in_order)&#123;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_pipeline</span><span class="params">(pipeline *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">run</span>(<span class="number">8</span>);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inputfilter inf;</span><br><span class="line">    outputfilter ouf;</span><br><span class="line">    pipeline p;</span><br><span class="line">    p.<span class="built_in">add_filter</span>(inf);</span><br><span class="line">    p.<span class="built_in">add_filter</span>(ouf);</span><br><span class="line">     <span class="comment">//由于主线程服务于继承自thread_bound_filter的outputfilter，所以pipeline要运行在另一个单独的线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(run_pipeline, &amp;p)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(ouf.<span class="built_in">process_item</span>()!=thread_bound_filter::end_of_stream)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="简单循环的并行化"><a href="#简单循环的并行化" class="headerlink" title="简单循环的并行化"></a>简单循环的并行化</h1><p>假设你想要对某个数组的所有元素都应用函数 Foo，并且能安全地同时处理。先列出来串行化的代码版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SerialApplyFoo</span><span class="params">( <span class="type">float</span> a[], <span class="type">size_t</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">size_t</span> i=<span class="number">0</span>; i!=n; ++i ) </span><br><span class="line">        <span class="built_in">Foo</span>(a[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迭代空间的类型为 size_t ，范围从0到 n-1 。模板函数<code>tbb::parallel_for</code>会将此迭代空间打散为一些块（chunk），在每个块上运行一个独立的线程。将此循环并行化的第一个步骤是将此循环体转变成对块的操作的形式。这种形式是一种STL风格的函数对象，叫做实体对象（body object），其中 operator() 处理一个块。下面的代码声明了这个实体对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplyFoo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> *<span class="type">const</span> my_a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">float</span> *a = my_a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)  <span class="built_in">Foo</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ApplyFoo</span>(<span class="type">float</span> a[]) : <span class="built_in">my_a</span>(a)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>例子中的 using 指令可以使你在使用 tbb 中定义的数据时不需要每次都加上 tbb 前缀。后面的例子都假定提供了这么个 using 指令。</p>
<p>注意<code>operator()</code>的参数。<code>blocked_range&lt;T&gt;</code>是intel tbb 库提供的一个模板类。它以类型<code>T</code>上声明了一个一维迭代空间。<code>parallel_for</code>也能接受其他类型的迭代空间。Intel TBB 库为二维空间提供了<code>blocked_range2d</code>。</p>
<p>ApplyFoo 的实例需要成员变量来记住所有在初始循环的外部定义却在内部使用的局部变量。由于parallel_for 并不在意实体对象的创建方式，这些成员变量通常由实体对象的构造函数初始化。模板函数parallel_for 要求实体对象有拷贝构造函数，通过调用它为每个工作者线程创建隔离的拷贝。它也通过调用析构函数来销毁这些拷贝。在大多数情况下，隐式产生的拷贝构造函数与析构函数就够用了。如果不满足需求，那么为了一致性，你就要同时定义两者。</p>
<p>因为实体对象可能被拷贝，它的<code>operator()</code>就不能修改实体。否则，这些改动对于调用<code>parallel_for</code>的线程可见与否依赖于<code>operator()</code>执行是在原始对象还是在拷贝对象上。为了凸显这点小差别，<code>parallel_for</code>要求实体对象的<code>operator ()</code>声明为 const.</p>
<p>示例的<code>operator()</code>将<code>my_a</code>加载到局部变量<code>a</code>。</p>
<p>一旦你将循环体写成了实体对象，使用下面的方式调用模板方法<code>parallel_for</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelApplyFoo</span><span class="params">(<span class="type">float</span> a[], <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n), <span class="built_in">ApplyFoo</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里构造的<code>blocked_range</code>代表了从 0 到 n -1 的整个迭代区域。<code>parallel_for</code>会将此区域为每个处理器分出子区域。构造函数的一般形式是<code>blocked_range&lt;T&gt;(begin, end, grainsize)</code>。 T 指定了值的类型。 参数 begin 和 end 规定半开放区间<code>[begin,end)</code>作为该迭代区域的STL样式。参数 grainsize 后面会提到。例子使用默认的 grainsize值（1），因为默认情况下， parallel_for的启发式算法能在默认粒度下很好的工作。</p>
<p>采用lambda表达式，上面的例子可以写为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>( disable: 588)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelApplyFoo</span><span class="params">(<span class="type">float</span> *a, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n),</span><br><span class="line">        [=](<span class="type">const</span> blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)  </span><br><span class="line">                <span class="built_in">Foo</span>(a[i]);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了更紧凑，对于在一个整形的连续区域执行并行循环，TBB有对应形式的<code>parallel_for</code>。表达式<code>parallel_for(first,last,step,f)</code>就像<code>for(auto i = first; i&lt; last; i+= step) f(i)</code>，只是在资源许可的情况下，每个<code>f(i)</code>可以并行求值。参数 step 是可选的。前面的例子可以重写为如下紧凑形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 588)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelApplyFoo</span><span class="params">(<span class="type">float</span> a[], <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), n, [=](<span class="type">size_t</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Foo</span>(a[i]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>紧凑形式只能支持整形的线性迭代空间。自动分块特性将在下面介绍。</p>
<h2 id="自动分块"><a href="#自动分块" class="headerlink" title="自动分块"></a>自动分块</h2><p>并行循环的构造导致它调度工作的每个分块额外的开销。从2.2 版本开始，Intel TBB 视负载平衡所需自动选择分块尺寸。TBB采用的启发式算法会限制开销，同时为负载均衡提供足够的可选项。</p>
<p>注意：典型地，一个至少需要100万个时钟周期的循环才能使用parallel_for来提高性能。例如，在一个2GHz的处理器上需要500微秒的循环是可以从parallel_for 受益的。</p>
<p>对于大部分应用，推荐使用默认的自动分块。然而，伴随大多数启发式算法，总有一些更精确地控制块的尺寸会产生更好性能的情况。下一节会解释。</p>
<h2 id="控制分块"><a href="#控制分块" class="headerlink" title="控制分块"></a>控制分块</h2><p>分块是通过分区（partitioner）和粒度（grainsize）控制的。为了分块时获得最大的控制权，两者都需要指定。</p>
<ul>
<li>指定<code>simple_partitioner()</code>作为<code>parallel_for</code>的第三个参数。关闭自动分块。</li>
</ul>
<p>指定构造区间时的粒度。这里讨论的构造形式为：<code>blocked_range&lt;T&gt;(begin,end,grainsize)</code>。<code>grainsize</code>的默认值为1，它是每个块的循环迭代的单位。如果块太小，间接的开销可能更甚于有用的工作。</p>
<p>上节的例子修改为使用显式的粒度 G ：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelApplyFoo</span><span class="params">( <span class="type">float</span> a[], <span class="type">size_t</span> n )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>,n,G), <span class="built_in">ApplyFoo</span>(a),  </span><br><span class="line">                 <span class="built_in">simple_partitioner</span>()); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p>粒度为并行设置了最低门槛。例子中的<code>parallel_for</code>在块上（大小不见得一样）调用<code>ApplyFoo::operator()</code>。让块尺寸作为在块上迭代的数量。使用<code>simple_partitioner</code>确保<code>[G/2] &lt;= chunksize &lt;= G</code>。</p>
<p>使用<code>auto_partitioner</code>、<code>affinity_partitioner</code>时，可以仅为区间（range）指定粒度，这是一种中等级别的控制。<code>auto_partitioner</code>是默认的分区器。两个分区器都实现了“自动分块”一节中描述的自动粒度启发式算法。<code>affinity_partitioner</code>实现了额外的窍门（在下面的“带宽与缓存亲缘性”一节中解释）。虽然这些分区器可能导致超出 G  迭代数量的块，但不会产生少于 [G/2] 迭代的块。分区器在启发式算法失败时会产生浪费性的小块，虽然偶然，但显式指定区间粒度会很有用。</p>
<h2 id="带宽与缓存（cache）亲缘性"><a href="#带宽与缓存（cache）亲缘性" class="headerlink" title="带宽与缓存（cache）亲缘性"></a>带宽与缓存（cache）亲缘性</h2><p>对于足够简单的函数 Foo, 编写成并行循环的例子也许不能展现出良好的加速效果。原因可能是处理器与内存间的系统带宽不足。这种情况下，你可能要重新考虑算法以便更好地利用缓存（cache）。为更好地利用缓存进行重构通常会使程序（无论并行还是串行）受益。</p>
<p>某些情况下的重构的一种替代方案是<code>affinity_partitioner</code>。他不仅自动选择粒度，而且优化缓存的亲缘性。使用它在下列情况下会显著地改进性能：</p>
<ul>
<li>每次数据问题时，计算只有少量操作</li>
<li>被循环访问的数据适合留在缓存中</li>
<li>循环，或者类似的循环，在同样的数据上重复执行</li>
<li>可用硬件线程的数量多于两个。如果只有两个线程可用，intel TBB 的默认调度会提供良好的缓存亲缘性。</li>
</ul>
<p>下面的代码展示了如何使用<code>affinity_partitioner</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelApplyFoo</span><span class="params">(<span class="type">float</span> a[], <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">static</span> affinity_partitioner ap;</span><br><span class="line">   <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n), <span class="built_in">ApplyFoo</span>(a), ap);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimeStepFoo</span><span class="params">(<span class="type">float</span> a[], <span class="type">size_t</span> n, <span class="type">int</span> steps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; steps; ++t) </span><br><span class="line">       <span class="built_in">ParallelApplyFoo</span>(a, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>affinity_partitioner</code>的对象<code>ap</code>存在于循环迭代中。它记着循环的迭代从哪里执行，这样每个迭代都能被以前执行它的线程处理。示例中将<code>affinity_partitioner</code>的对象示例声明为局部静态变量来得到<code>ap</code>正确的生存周期。另一种方法是将它定义在<code>TimeStepFoo</code>函数中循环体的外面， 传递给<code>parallel_for</code>的调用链。 </p>
<h2 id="分区器总结"><a href="#分区器总结" class="headerlink" title="分区器总结"></a>分区器总结</h2><p>并行循环模板<code>parallel_for</code>以及<code>parallel_reduce</code>接受一个可选的<code>partitioner</code> 参数，通过它指定执行循环的策略。下表总结了三种分区器，以及当与<code>blocked_range</code>联合使用时的效果。</p>
<ul>
<li><code>simple_partitioner</code>：以粒度为单位选择块大小</li>
<li><code>auto_partitioner</code>：自动选择块大小</li>
<li><code>affinity_partitioner</code>：自动选择块大小以及缓存亲缘性</li>
</ul>
<p><code>auto_partitioner</code>在不指定分区器的情况下使用。一般来说， 应该使用<code>auto_partitioner</code>或者<code>affinity_partitioner</code>，因为他们基于有效的执行资源来制定块的数量。然而，在下述情况下，<code>simple_partitioner</code>是可用的：</p>
<ul>
<li><code>operator()</code>的子区域（subrange）不能超出某个限度。 这可能是有利的。例如，如果你的<code>operator()</code>需要一个跟区域大小成正比的临时数组。子区域的大小限定了，你就可以为这个数组使用一个自动变量而不是使用动态内存分配。</li>
<li>大尺度的子区域不能有效使用缓存。例如，假定一个子区域的处理流程需要重复清理同一块内存区域。保持子区域在某个限度下可以使重复引用的内存区域适合放入缓存。</li>
<li>你想调整为某个特定的机器。</li>
</ul>
<h2 id="parallel-reduce-1"><a href="#parallel-reduce-1" class="headerlink" title="parallel_reduce"></a>parallel_reduce</h2><p>循环可以做减量，像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">SerialSumFoo</span><span class="params">(<span class="type">float</span> a[], <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != n; ++i) </span><br><span class="line">        sum += <span class="built_in">Foo</span>(a[i]);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果迭代是独立的，你可以使用模板类<code>parallel_reduce</code>来并行化这个循环：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ParallelSumFoo</span><span class="params">( <span class="type">const</span> <span class="type">float</span> a[], <span class="type">size_t</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SumFoo <span class="title">sf</span><span class="params">(a)</span></span>; </span><br><span class="line">    <span class="built_in">parallel_reduce</span>( <span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>,n), sf ); </span><br><span class="line">    <span class="keyword">return</span> sf.my_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类<code>SumFoo</code>指定了降低的细节，诸如怎么累加子总和并将它们合并。下面是<code>SumFoo</code>的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SumFoo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span>* my_a; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">float</span> my_sum;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="type">const</span> blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r )</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">float</span> *a = my_a; </span><br><span class="line">        <span class="type">float</span> sum = my_sum; </span><br><span class="line">        <span class="type">size_t</span> end = r.<span class="built_in">end</span>(); </span><br><span class="line">        <span class="keyword">for</span>( <span class="type">size_t</span> i=r.<span class="built_in">begin</span>(); i!=end; ++i )  </span><br><span class="line">            sum += <span class="built_in">Foo</span>(a[i]);  </span><br><span class="line">        my_sum = sum;     </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SumFoo</span>( SumFoo&amp; x, split ) : <span class="built_in">my_a</span>(x.my_a), <span class="built_in">my_sum</span>(<span class="number">0</span>) &#123;&#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">( <span class="type">const</span> SumFoo&amp; y )</span> </span>&#123;my_sum+=y.my_sum;&#125; </span><br><span class="line">        </span><br><span class="line">    <span class="built_in">SumFoo</span>(<span class="type">float</span> a[] ) : </span><br><span class="line">        <span class="built_in">my_a</span>(a), <span class="built_in">my_sum</span>(<span class="number">0</span>) </span><br><span class="line">    &#123;&#125; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>注意与<code>parallel_for</code>章节中提到的<code>ApplyFoo</code>类的区别。第一，<code>operator()</code>不是<code>const</code>。这是因为它必须更新<code>SumFoo::my_sum</code>。第二，<code>SumFoo</code>提供分割构造函数以及一个<code>join</code>方法以使<code>parallel_reduce</code>工作。分割构造函数需要两个参数，其一，一个指向原始对象的引用，其二，一个类型为<code>split</code>（TBB库中定义） 的哑元参数。这个哑元参数将分割构造函数与拷贝构造函数区分开。</p>
<p>提示：实例中，<code>operator()</code>的定义为访问标量值在循环内部使用局部临时变量（a, sum, end）。这种技术通过明白告诉编译器这些值可以放在缓存中而不是内存中来提高性能。如果这些值过大不适合放进寄存器，或者以一种编译器不能追踪的方式获取地址，这项技术就没用了。在一个典型的优化编译器中，为只写变量（如例子中的 sum )使用局部临时变量应该足够了。因为随后编译器就能推断这个循环不会写任何其他的位置，并将其他的读取提升到循环外。</p>
<p>当任务调度器确定工作者线程有效时，<code>parallel_reduce</code>调用分割构造函数为工作者创建子任务。当子任务完工后，<code>parallel_reduce</code>使用<code>join</code>方法 来累加子任务的结果。</p>
<p>如果没有工作者线程可用，迭代的第二半约减操作时就使用第一半使用过的同一个实体对象。它开始的地方，就是第一半结束的地方。</p>
<p>小心： 因为分割/合并在没有有效工作者时不能派上用场， parallel_reduce 没有必要做递归分割。</p>
<p>小心：因为同一个实体（body）可能被用来累加多个子区域， operator() 不能丢弃早先的累加值就至关重要了。下面的代码展示了一种错误定义<code>SumFoo::operator()</code>的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SumFoo</span></span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="type">float</span> my_sum;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="type">const</span> blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r )</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... </span><br><span class="line">        <span class="type">float</span> sum = <span class="number">0</span>;  <span class="comment">// WRONG – should be &quot;sum = my_sum&quot;. </span></span><br><span class="line">        ... </span><br><span class="line">        <span class="keyword">for</span>( ... )  </span><br><span class="line">            sum += <span class="built_in">Foo</span>(a[i]);  </span><br><span class="line">        my_sum = sum;    </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于错误的函数实现，<code>operator()</code>只是返回了应用parallel_reduce后最后一个子区域而不是所有子区域的值。<code>parallel_reduce</code>的分区器与粒度的规则跟<code>parallel_for</code>是一样的。</p>
<p><code>parallel_reduce</code>归纳了所有相关操作。通常，分割构造函数会做两件事：</p>
<ul>
<li>拷贝必要的只读信息来运行循环体</li>
<li>初始化约减操作标识元素的变量</li>
<li>join 方法做相应的合并操作。你可以在同一时间做多个约减操作：可以使用单个parallel_reduce 同时搜集最大、最小</li>
</ul>
<p>注意：约减（reduction）操作可以是不可交换的。例子中浮点数加法如果替换成了字符串连接，同样可行。</p>
<p>高级示例</p>
<p>一个高级点的联合操作的例子是找到最小<code>Foo(i)</code>的索引。串行版本是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">SerialMinIndexFoo</span><span class="params">( <span class="type">const</span> <span class="type">float</span> a[], <span class="type">size_t</span> n )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> value_of_min = FLT_MAX;   <span class="comment">// FLT_MAX from &lt;climits&gt; </span></span><br><span class="line">    <span class="type">long</span> index_of_min = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">for</span>( <span class="type">size_t</span> i=<span class="number">0</span>; i&lt;n; ++i ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> value = <span class="built_in">Foo</span>(a[i]); </span><br><span class="line">        <span class="keyword">if</span>( value&lt;value_of_min ) </span><br><span class="line">        &#123;</span><br><span class="line">            value_of_min = value; </span><br><span class="line">            index_of_min = i; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> index_of_min; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p>循环的工作方式就是保持最终找到的最小值以及这个值的索引。这是循环迭代间携带的唯一信息。为了将此循环转换成<code>parallel_reduce</code>， 函数对象（<code>operator()</code>）必须保持追踪这个携带信息，并知道如何在这些迭代跨越多个线程时合并这个信息。同样，函数对象必须记录一个指向 a 的指针来提供上下文。</p>
<p>下面的代码展示了完整的函数对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinIndexFoo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> *<span class="type">const</span> my_a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> value_of_min;</span><br><span class="line">    <span class="type">long</span> index_of_min;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> *a = my_a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> value = <span class="built_in">Foo</span>(a[i]);</span><br><span class="line">            <span class="keyword">if</span> (value &lt; value_of_min)</span><br><span class="line">            &#123;</span><br><span class="line">               value_of_min = value;</span><br><span class="line">               index_of_min = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">MinIndexFoo</span>(MinIndexFoo&amp; x, split) :</span><br><span class="line">        <span class="built_in">my_a</span>(x.my_a),</span><br><span class="line">        <span class="built_in">value_of_min</span>(FLT_MAX),  <span class="comment">// FLT_MAX from &lt;climits&gt;</span></span><br><span class="line">        <span class="built_in">index_of_min</span>(<span class="number">-1</span>)</span><br><span class="line">     &#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">const</span> SumFoo&amp; y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y.value_of_min &lt; value_of_min)</span><br><span class="line">        &#123;</span><br><span class="line">            value_of_min = y.value_of_min;</span><br><span class="line">            index_of_min = y.index_of_min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">MinIndexFoo</span>(<span class="type">const</span> <span class="type">float</span> a[]) :</span><br><span class="line">        <span class="built_in">my_a</span>(a),</span><br><span class="line">        <span class="built_in">value_of_min</span>(FLT_MAX),  <span class="comment">// FLT_MAX from &lt;climits&gt;</span></span><br><span class="line">        <span class="built_in">index_of_min</span>(<span class="number">-1</span>),</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在可以使用<code>parallel_reduce</code>来重写<code>SerialMinIndex</code>了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">ParallelMinIndexFoo</span><span class="params">(<span class="type">float</span> a[], <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">MinIndexFoo <span class="title">mif</span><span class="params">(a)</span></span>;</span><br><span class="line">   <span class="built_in">parallel_reduce</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n), mif);</span><br><span class="line">   <span class="keyword">return</span> mif.index_of_min;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>截至目前，所有的示例都使用<code>blocked_range&lt;T&gt;</code>类来指定区域。这个类可以在很多情况下使用，但并非适用所有的情况。你可以使用Intel Threading Building Blocks 定义自己的迭代空间对象。这个对象必需提供两个方法以及一个“分割构造函数”指定将其自身分割为子空间的方式。如果这个类叫R， 方法以及构造函数会是下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// True if range is empty </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="comment">// True if range can be split into non-empty subranges </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_divisible</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="comment">// Split r into subranges r and *this </span></span><br><span class="line">    <span class="built_in">R</span>( R&amp; r, split ); </span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果区域为空，<code>empty()</code>返回 true. 如果区域可被分割为两个非空子区域，而且这个分割带来的好处多于带来的损耗，is_divisible 就返回 true. 分割构造函数有两个参数：</p>
<ul>
<li>第一个类型为 R</li>
<li>第二个类型为 tbb::split</li>
<li>第二个参数没用；它只是为了将这个构造函数与普通的拷贝构造函数区分开。分割构造函数会试图将 r 大约分成两个等分， 将 r 更新为第一个等分，将构造出来的对象作为第二个等分。这两个等分都应该是非空的。并行算法模板在只有 r.is_divisible 为 true 的情况下才在 r 调用分割构造函数。</li>
</ul>
<p>迭代空间不用必须是线性的。tbb/blocked_range2d.h 就是个二维区域的示例。它的分割构造函数试图沿着最长的坐标轴分割此区域。当与parallel_for 一起使用时，它以使循环陷入“递归阻塞”的方式来改进缓存使用。这种漂亮的缓存行为意味着在 blocked_ranged2d<T> 上使用 parallel_for 能让循环比对应的串行版本运行的更快，即使是在单个的处理器上。</p>
<h1 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h1><p>互斥控制某块代码能同时被多少线程执行。在Intel  Threading Building Blocks（intelTBB）中，互斥通过互斥体（mutexes）和锁（locks）来实现。互斥体是一种对象，在此对象上，一个线程可以获得一把锁。在同一时间，只有一个线程能持有某个互斥体的锁，其他线程必须等待时机。</p>
<p>最简单的互斥体是<code>spin_mutex</code>。试图在<code>spin_mutex</code>上获得锁的线程要保持繁忙等待，直到成功。<code>spin_mutex</code>适合一个锁只被持有数个指令时常的情况。例如，下面的代码使用一个互斥体FreeListMutex来保护一个共享变量FreeList。它负责审查在同一时间只有一个线程访问FreeList。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Node* FreeList;</span><br><span class="line"><span class="keyword">typedef</span> spin_mutex FreeListMutexType;</span><br><span class="line">FreeListMutexType FreeListMutex;</span><br><span class="line"><span class="function">Node* <span class="title">AllocateNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node* n;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">FreeListMutexType::scoped_lock <span class="title">lock</span><span class="params">(FreeListMutex)</span></span>;</span><br><span class="line">		n = FreeList;</span><br><span class="line">		<span class="keyword">if</span> (n)</span><br><span class="line">			FreeList = n-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!n)</span><br><span class="line">		n = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FreeNode</span><span class="params">(Node* n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FreeListMutexType::scoped_lock <span class="title">lock</span><span class="params">(FreeListMutex)</span></span>;</span><br><span class="line">	n-&gt;next = FreeList;</span><br><span class="line">	FreeList = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>scoped_lock</code>的构造子（构造函数）会一直等待，直到FreeListMutex上没有别的锁。析构子（析构函数）释放获得的锁。AllocateNode中的大括弧也许看起来不太常见。它们的作用是使锁的生命周期尽可能的短，这样其他的正在等待的线程就能尽可能快地得到机会。</p>
<p>注意：确保命名锁对象，否则它会被过快的销毁。例如，如果例子中的scoped_lock对象以如下方式创建<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FreeListMutexType::<span class="built_in">scoped_lock</span> (FreeListMutex);</span><br></pre></td></tr></table></figure></p>
<p>这样<code>scoped_lock</code>会在执行到分号处时销毁，即在FreeList被访问前释放锁。</p>
<p>编写<code>AllocatedNode</code>的另一种可选方式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">AllocateNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node* n;</span><br><span class="line">	FreeListMutexType::scoped_lock lock;</span><br><span class="line">	lock.<span class="built_in">acquire</span>(FreeListMutex);</span><br><span class="line">	n = FreeList;</span><br><span class="line">	<span class="keyword">if</span> (n)</span><br><span class="line">		FreeList = n-&gt;next;</span><br><span class="line">	lock.<span class="built_in">release</span>();</span><br><span class="line">	<span class="keyword">if</span> (!n)</span><br><span class="line">		n = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>acquire</code>方法在得到锁前会一直等待；<code>release</code>方法释放该锁。</p>
<p>推荐的做法是尽可能得加上大括弧，以使得那些代码被锁保护对于维护者来说更为清晰。</p>
<p>如果你很熟悉锁的C接口，也许会疑惑为什么在互斥体对象自身上没有获取、释放方法。原因是C接口不是异常安全的，因为如果被保护的区域抛出一个异常，控制流就会略过释放操作。借助面向对象接口，析构scoped_lock对象会致使锁的释放，无论是正常退出保护区域，还是因为异常。即使对于我们使用acquire、release方法实现的AllocateNode的版本也是这样的——显式释放让锁得以早点释放，而后，析构函数判断锁已经被释放，就不去操作锁了。</p>
<p>Intel TBB中所有的互斥体都有类似的接口，不但能让他们易于学习，还能适用于泛型编程。例如，所有的互斥体都嵌套一个<code>scoped_lock</code>类型，对于给定类型M，对应的锁类型是<code>M::scoped_lock</code>。</p>
<p>推荐为互斥体类型使用typedef，如同前面的例子所示。以这种方式，你可以稍后改变锁的类型而不用编辑其余的代码。在这些例子中，可以使用<code>typedef queuing_mutex FreeListMutexType</code>来代替<code>typedef spin_mutex FreeListMutexType</code>（及使用<code>queuing_mutex</code>代替<code>spin_mutex</code>），代码仍然正确。</p>
<h2 id="互斥体要素"><a href="#互斥体要素" class="headerlink" title="互斥体要素"></a>互斥体要素</h2><p>互斥体的行家总结了互斥体的各种特性。知道这些是有帮助的，因为它们影响通用性、性能的权衡。选择正确会有助于性能提升。互斥体能以下面的要素描述：</p>
<ul>
<li>可伸缩性   一些互斥体被称为可伸缩的。在严格意义上，这不是一个准确的名字，因为互斥体限制在某个时间某个线程的执行。一个可伸缩的互斥体是不会比这个做的更差。如果等待线程消耗了大量的处理器循环和内存带宽，减少了线程做实际工作的速度，此时互斥体会比串行执行更糟糕。在轻微竞争的情况下，可伸缩互斥体通常要比非可伸缩互斥体要慢，此时非可伸缩互斥体要优于前者。如果有疑惑，就使用可伸缩互斥体。</li>
<li>公平    互斥体可以是公平或者非公平的。公平的互斥体按照线程到达的顺序使其通过，防止饿死线程。每个线程依序进行。然而，非公平互斥体会更快，它们允许正在运行的线程先通过，而不是下一个也许因为某个中断正在睡眠的在线（in line）线程。</li>
<li>递归    互斥体可以是递归的，也可以是非递归的。可递归互斥体允许线程在持有此互斥体锁的情况下再次获得锁。这在一些递归算法中很有用，但也增加了锁实现的开销。</li>
<li>放弃或者阻塞   这是影响性能的实现细节。在长等待时，Intel TBB的互斥体要么放弃（yields）要么阻塞（blocks）。这里的放弃（yields）的意思是，重复轮询看能否有进展，如果不能，就暂时放弃处理器的使用权。阻塞意味着直到互斥体完成处理才释放处理器。如果等待短暂，就使用放弃互斥体；如果等待时间往往比较长，就使用阻塞互斥体。（在windows系统中，yield通过SwitchToThread()实现，其他系统中通过<code>sched_yield()</code>实现）</li>
</ul>
<p>下面是互斥体的行为总结：</p>
<ul>
<li><code>spin_mutex</code>    非可伸缩，非公平，非递归，在用户空间自旋（光吃不干）。看起来它似乎在所有场景里都是最坏的，例外就是，在轻微竞争的情况下，它非常快。如果你设计程序时，竞争行为在很多spin_mutex对象间传播，那还是使用别的种类的互斥体为好。如果互斥体是重度竞争的，你的算法无论如何都不会是可伸缩的。此种情况下，重新设计算法比寻找更有效的锁合适。</li>
<li><code>queuing_mutex</code>   可伸缩，公平，非递归，在用户控件自旋。当可伸缩与公平很重要时使用。</li>
<li><code>spin_rw_mutex</code>、<code>queuing_rw_mutex</code>     与spin_mutex、queuing_mutex类似，但是增加了读取锁支持。</li>
<li><code>mutex</code>与<code>recursive_mutex</code>    这两个互斥体是对系统原生互斥的包装。在windows系统中，是在CRITICAL_SECTION（关键代码段）上封装的。在Linux以及Mac OS 操作系统中，通过pthread的互斥体实现。封装的好处是加入了异常安全接口，并相比Intel TBB的其他互斥体提供了接口的一致性，这样当出于性能方面考虑时能方便地将其替换为别的互斥体。</li>
<li><code>null_mutex</code>和<code>null_rw_mutex</code>   这两个互斥体什么都不做。它们可被用作模版参数。例如，假定你要定义一个容器模板并且知道它的一些实例会被多个线程共享，需要内部锁定，但是其余的会被某个线程私有，不需要锁定。你可以定义一个将互斥体类型作为参数的模板。在需要锁定时，这个参数可以是真实互斥体类型中的一种，在不需要锁定时，将null_mutex作为参数传入。</li>
</ul>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>互斥在当多个线程写操作某个共享变量时是必要的。但允许多个读操作者进入保护区域就没什么大不了了。互斥体的读写变种，在类名称中以_rw_标记，通过区分读取锁与写入锁，允许多个读操作者。一个给定的互斥体，可以有多个读取锁。</p>
<p><code>scoped_lock</code>的构造函数通过一个额外的布尔型参数来区分读取锁请求与写入锁请求。如果这个参数为false，表示请求读取锁。true表示请求写入锁。默认值为true，这样，当省略此参数时，<code>spin_rw_mutex</code>或者<code>queuing_rw_mutex</code>的行为就跟没有<code>_rw_</code>的版本一样。</p>
<h3 id="升级-降级"><a href="#升级-降级" class="headerlink" title="升级/降级"></a>升级/降级</h3><p>通过方法<code>upgrade_to_writer</code>可以将一个读取锁升级为写入锁：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;string&gt; MyVector;</span><br><span class="line"><span class="keyword">typedef</span> spin_rw_mutex MyVectorMutexType;</span><br><span class="line">MyVectorMutexType MyVectorMutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddKeyIfMissing</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Obtain a reader lock on MyVectorMutex </span></span><br><span class="line">	<span class="function">MyVectorMutexType::scoped_lock</span></span><br><span class="line"><span class="function">		<span class="title">lock</span><span class="params">(MyVectorMutex,<span class="comment">/*is_writer=*/</span><span class="literal">false</span>)</span></span>;</span><br><span class="line">	<span class="type">size_t</span> n = MyVector.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (MyVector[i] == key) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (!MyVectorMutex.<span class="built_in">upgrade_to_writer</span>())</span><br><span class="line">		<span class="comment">// Check if key was added while lock was temporarily released </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = n; i&lt;MyVector.<span class="built_in">size</span>(); ++i)</span><br><span class="line">			<span class="keyword">if</span> (MyVector[i] == key) <span class="keyword">return</span>;</span><br><span class="line">	vector.<span class="built_in">push_back</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，vector在某些时候必须重新搜索。这是因为upgrade_to_writer在它升级前可能不得不临时释放锁。否则，接下来可能会发生死锁（下面会讲到）。upgrade_to_writer方法返回值为bool类型，在没有释放锁就成功升级的情况下会返回true，如果锁被临时释放了，返回false。因此，如果upgrade_to_writer返回了false，代码必须重新运行查找操作确保“key”没有被其他的线程插入。例子假定“keys”总被追加到vector的末端，而且这些键值不会被移除。由于这些假定，它不用重新搜索整个vector，而仅搜索那些最初搜索过的之外的元素。需要记住的关键点是，如果upgrade_to_writer返回了false，任何假定持有读取锁的假定都可能无效，必须重新检查。</p>
<pre><code>于此相应，有个相对的方法downgrade_to_reader，但是在实际应用中，基本找不到使用它的理由。
</code></pre><h3 id="锁异常"><a href="#锁异常" class="headerlink" title="锁异常"></a>锁异常</h3><p>锁会导致性能与正确性问题。对于使用锁的新手，有些问题要避免：</p>
<ul>
<li>死锁：当多个线程企图获得多个锁，而且它们会相互持有对方需要的锁时，死锁就会发生。更为准确地定义，当发生以下情况时死锁会发生：</li>
<li>存在线程回路：每个线程至少持有互斥体上的一个锁，而且在等待回路中下一个线程已经持有锁的互斥体</li>
<li>任何线程都不愿意放弃它的锁：避免需要同一时间持有两把锁的情况。将大块的程序拆分为小块，每块都可以在持有一把锁的情况下完工。</li>
<li>总是以同样的顺序取锁。例如，如果你有“外部容器”与“内部容器”互斥体，需要从中获取锁，你可以总是先从“外部密室”获取。另外一个例子是在锁具有命名的情况下“以字母顺序获取锁”。或者，如果锁没有命名，就以互斥体的数字地址作为顺序获取锁。</li>
</ul>
<h3 id="锁护送"><a href="#锁护送" class="headerlink" title="锁护送"></a>锁护送</h3><p>另外一个与锁相关的常见问题是锁护送。当操作系统打断一个持有锁的线程时，这种情况就会发生。所有其他的需要这把锁的线程都必须等待被中断的线程恢复并释放锁。公平互斥体会导致更糟糕的状况，因为，如果一个正在等待的线程被中断，所有它后面的线程都必须等待它恢复（就不单是需要它持有锁的那些线程的问题了）。</p>
<p>要最小化这种情况发生，应该尽量缩短持有锁的时间。在请求锁之前，进行任何可被预先计算的工作。</p>
<p>要避免这种情况，尽可能使用原子操作代替锁。</p>
<h1 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h1><p>Intel Threading Building Blocks (Intel® TBB)是基于任务（task）驱动的。一般来说，只有在TBB提供的算法模板中找不到合适的模板时，才考虑使用任务调度器自行实现。任务（task）是一个逻辑概念，操作系统并没有提供对应的实现。你可以把它当作线程池的进化。实现时，一个thread可对应多个task。在非阻塞编程时，相对于线程（thread），基于任务的编程有很多优点，比如：</p>
<ul>
<li>task的启动、停止通常比thread更快</li>
<li>task更能匹配有效资源（因为有TBB的任务调度器）</li>
<li>task在编程时使程序员更能专注业务实现而不是底层细节</li>
<li>task实现了负载均衡</li>
</ul>
<p>但是，要记住，task的应用场景是并行，而不是并发（不要企图把TBB用于Socket之类的并发敲打）。如果一个task被阻塞，其对应的thread也将被阻塞，这样，运行于thread之上的所有task都将被阻塞。</p>
<h2 id="任务对象的生成"><a href="#任务对象的生成" class="headerlink" title="任务对象的生成"></a>任务对象的生成</h2><p>task的定义在task.h中，派生类必须要实现纯虚函数<code>execute</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! Should be overridden by derived classes.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> task* <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>task对象不能直接new，而是要使用TBB中重载的new操作符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span> bytes, <span class="type">const</span> tbb::internal::allocate_root_proxy&amp; )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span> bytes, <span class="type">const</span> tbb::internal::allocate_root_with_context_proxy&amp; p )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span> bytes, <span class="type">const</span> tbb::internal::allocate_continuation_proxy&amp; p )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span> bytes, <span class="type">const</span> tbb::internal::allocate_child_proxy&amp; p )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span> bytes, <span class="type">const</span> tbb::internal::allocate_additional_child_of_proxy&amp; p )</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面是TBB Tutorial中的示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tick_count.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> tbb::task;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">SerialFib</span><span class="params">(<span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">SerialFib</span>(n - <span class="number">1</span>) + <span class="built_in">SerialFib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FibTask</span> : <span class="keyword">public</span> task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">long</span> n;</span><br><span class="line">	<span class="type">long</span>* <span class="type">const</span> sum;</span><br><span class="line">	<span class="built_in">FibTask</span>(<span class="type">long</span> n_, <span class="type">long</span>* sum_) :</span><br><span class="line">		<span class="built_in">n</span>(n_), <span class="built_in">sum</span>(sum_)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">task* <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;   </span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*sum = <span class="built_in">SerialFib</span>(n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">long</span> x, y;</span><br><span class="line">			FibTask&amp; a = *<span class="built_in">new</span>(<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">1</span>, &amp;x);</span><br><span class="line">			FibTask&amp; b = *<span class="built_in">new</span>(<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">2</span>, &amp;y);</span><br><span class="line">			<span class="comment">// ref_count的值为2+1（a+b+后面函数sapwn_and_wait_for_all产生的等待任务） </span></span><br><span class="line">			<span class="built_in">set_ref_count</span>(<span class="number">3</span>);</span><br><span class="line">			<span class="built_in">spawn</span>(b);			 </span><br><span class="line">			<span class="built_in">spawn_and_wait_for_all</span>(a);</span><br><span class="line">			*sum = x + y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ParallelFib</span><span class="params">(<span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> sum;</span><br><span class="line">	FibTask&amp; a = *<span class="built_in">new</span>(task::<span class="built_in">allocate_root</span>()) <span class="built_in">FibTask</span>(n, &amp;sum);</span><br><span class="line">	task::<span class="built_in">spawn_root_and_wait</span>(a);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line">	tick_count start = tick_count::<span class="built_in">now</span>();</span><br><span class="line">	<span class="built_in">ParallelFib</span>(<span class="number">10</span>);</span><br><span class="line">	tick_count end = tick_count::<span class="built_in">now</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tick count = %f\n&quot;</span>, (end - start).<span class="built_in">seconds</span>());</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="任务的调度"><a href="#任务的调度" class="headerlink" title="任务的调度"></a>任务的调度</h2><p>调度器持有一个定向图表，每个节点对应一个任务对象。每个task指向它的继任者（successor），也就是指向等待它完成的任务（可以为空）。successor可以通过task::parent()得到。每个任务对象都包含一个引用计数，用来统计将此任务作为继任者的任务数量”。下图是斐波那契计算的任务图形快照：<br><img src="/img/20150401170607494.jpg" alt=""></p>
<p>任务A、B、C都产生了子任务并等待其完成。它们的引用计数为子任务的数目+1.</p>
<p>任务D正在运行，但是没有产生子任务，所以不需要设置引用计数</p>
<p>任务E、F、G都没有开始执行（spawned，当时没有excuting）</p>
<p>调度器运行任务的方式倾向于最小化内存需求以及跨线程通讯。但也需要在两种执行方式（深度优先、广度优先）间达到平衡。假定树是固定的，深度优先就是最佳的顺序执行方式：</p>
<ul>
<li>趁热打铁  最深层次的通常是最新创建的任务，因此在缓存（cache）中处于活跃状态。如果他们能完成，紧接着他们的任务就会被执行（比如D执行完后执行C），虽然不如第一个任务在缓存中的状态活跃，但相比创建事件更久的任务，它是最有效的。</li>
<li>最小化空间占用  执行最浅节点的任务会将树按照广度优先展开。这将同时创建指数级数量的节点。于此相比，深度优先只创建同等数量的节点，而且同一时间存在一个线性数量，因为它将其他准备好的任务压入堆栈。</li>
</ul>
<p>虽然广度优先有着严重的内存占用问题，但在如果你拥有无数个物理线程，它能最大并行化。一般来说物理线程都是有限的，所以广度优先执行的数量让有效的处理器保持繁忙就够了。调度器实现了广度优先、深度优先的混合执行模式。每个线程都有自己的就绪任务队列。当一个线程产出一个任务时，就将此任务推入队列的底部。</p>
<h2 id="线程的队列"><a href="#线程的队列" class="headerlink" title="线程的队列"></a>线程的队列</h2><p>线程执行任务的时候，按照以下规则从任务队列取得任务：</p>
<ul>
<li>规则1：获取上一个task的execute方法返回的task，如果为空继续获取</li>
<li>规则2：从自身的队列底部弹出一个task，如果队列为空，继续下一条判断</li>
<li>规则3：随机选择一个任务队列，从其顶部“偷”一个task。如果选择的队列为空，继续遍历其余的队列，直到成功</li>
</ul>
<p>规则2的效果就是执行本线程最近产出的任务，属于深度优先执行任务。规则3会从别的线程任务队列中选择最先产出的任务，发生广度优先任务执行，将潜在的并行变为实际的并行执行。作为任务演进图的一部分，获取任务是自动的。任务入队可以是显式的，也可以是隐式的。一个线程总是把任务加入自己队列的底部（不会加入另外线程的队列）。只有偷窃器才能把一个线程产出的任务传送到另外一个线程。在以下条件下，一个线程会将一个任务压入它的队列：</p>
<ul>
<li>任务被此线程显式产出，比如方法spawn</li>
<li>一个任务被方法task::recycle_to_reexecute标记为再执行</li>
<li>一个线程执行完最后的前任任务，并且此后隐式地将任务的引用计数减少到0。如果这种情况发生，线程隐式的将后续任务推入他的队列底部。如果一个任务有外部引用，执行完它所有的孩子任务并不会导致它的引用计数为0</li>
</ul>
<p>总体来说，任务调度的基本策略是“广度优先窃取，深度优先运行”。广度优先窃取准则会使线程保持繁忙，提升并行效率。深度优先运行准则会使每个线程在有足够工作需要做时，保持高效操作。</p>
<h2 id="有用的任务技术"><a href="#有用的任务技术" class="headerlink" title="有用的任务技术"></a>有用的任务技术</h2><h3 id="递归链式反应"><a href="#递归链式反应" class="headerlink" title="递归链式反应"></a>递归链式反应</h3><p>如果任务图为树形结构，调度器能工作的最好。因为此时“广度优先窃取、深度优先执行”策略非常适合。而且，树形结构的任务图也能很快地为很多任务创建出来。比如，一个主控任务需要创建N个孩子，如果直接创建，需要O（N）个步骤。但使用树形结构叉分建立，只需要O(lg(N))个步骤。</p>
<p> 一般情况下，问题都不是明显的树形结构，但可以轻松将他们映射到树。比如，parallel_for工作在迭代空间（比如，一个整数队列）。模板函数parallel_for使用定义将一个迭代空间递归映射到一个二叉树。</p>
<h3 id="持续传递"><a href="#持续传递" class="headerlink" title="持续传递"></a>持续传递</h3><p><code>spawn_and_wait_for_all</code>方法使正在执行的父任务等待所有的子任务完成，但是会稍微影响一些性能。当一个线程调用这个函数时，它会保持繁忙直到所有的孩子任务完成。有些时候，父任务准备就绪，可以继续执行，但却不能马上开始，因为它的线程还在执行其他任务中的一个任务。解决方案是父任务不再等待它的孩子，而是产出子任务后返回。子任务不是被作为父任务的孩子被分配，而是作为父任务的持续任务（continuation task）。这样，空闲的线程在它的子任务完成后就能偷窃并运行持续任务。上述FibTask的“持续传递”变体如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FibContinuation</span> : <span class="keyword">public</span> task</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span>* <span class="type">const</span> sum;</span><br><span class="line">	<span class="type">long</span> x, y;</span><br><span class="line">	<span class="built_in">FibContinuation</span>(<span class="type">long</span>* sum_) : <span class="built_in">sum</span>(sum_) &#123;&#125;</span><br><span class="line">	<span class="function">task* <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		*sum = x + y;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FibTask</span> : <span class="keyword">public</span> task</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">long</span> n;</span><br><span class="line">	<span class="type">long</span>* <span class="type">const</span> sum;</span><br><span class="line">	<span class="built_in">FibTask</span>(<span class="type">long</span> n_, <span class="type">long</span>* sum_) :</span><br><span class="line">		<span class="built_in">n</span>(n_), <span class="built_in">sum</span>(sum_)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">task* <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n&lt;<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*sum = <span class="built_in">SerialFib</span>(n);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			FibContinuation&amp; c =</span><br><span class="line">				*<span class="built_in">new</span>(<span class="built_in">allocate_continuation</span>()) <span class="built_in">FibContinuation</span>(sum);</span><br><span class="line">			FibTask&amp; a = *<span class="built_in">new</span>(c.<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">2</span>, &amp;c.x);</span><br><span class="line">			FibTask&amp; b = *<span class="built_in">new</span>(c.<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">1</span>, &amp;c.y);</span><br><span class="line">			<span class="comment">// 这里的引用计数是2，而不是2+1. </span></span><br><span class="line">			c.<span class="built_in">set_ref_count</span>(<span class="number">2</span>);</span><br><span class="line">			<span class="built_in">spawn</span>(b);</span><br><span class="line">			<span class="built_in">spawn</span>(a);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>两个版本的以下不同点需要了解：</p>
<ul>
<li>最大的区别是，在execute方法中，原来版本的x、y都是局部变量。在持续传递版本，它们就不能是局部变量了，因为父任务在子任务完成之前就返回了。作为替代方案，他们都是持续任务FibContinuation的字段。</li>
<li>改为使用allocate_continuation分配持续的任务。它与allocate_child类似，只是它的继任者（successor）是c而不是this，并且设置this的继任者为NULL，下面的图示了这种转换：</li>
</ul>
<p><img src="/img/20150415215857456.jpg" alt=""></p>
<p>这种转换的一个属性就是它不改变继任者的引用计数，这样就避免了涉入引用计数逻辑。</p>
<p>引用计数被设置为2，子任务的数量。在初始版本，它被设置为3，因为spawn_and_wait_for_all需要增加计数。而且，代码设置持续任务（FibContinuation）而不是父任务的引用计数，因为是持续任务对象在等待子任务。</p>
<p>指针sum通过<code>FibContinuation</code>的构造函数传递给持续任务对象，因为现在是<code>FibContinuation</code>把计算结果保存到<code>*sum</code>。子任务仍然使用<code>allocate_child</code>分配，但是都作为<code>c</code>，而不是父节点的孩子。这样，当两个子任务完成后，就是c而不是this作为继任者被产出。如果你凑巧使用<code>this.allocate_child()</code>，父任务就会在两个子任务完成后再次运行。</p>
<p>如果大家还记得初始版本中的ParallelFib是怎么编写的，就也许会担心持续传递风格会打破这段代码，因为现在根FibTask在子任务完工之前完成，并且实现代码使用<code>spawn_root_and_wait</code>来等待根<code>FibTask</code>。这算不上问题，因为<code>spawn_root_and_wait</code>被设计的能与持续传递风格很好的工作。调用<code>spawn_root_and_wait(x)</code>并不真的等待x结束。实际上，它构造了X的一个亚元(dummy)继任者，并且等待继任者的引用计数被消减。因为<code>allocate_continuation</code>将此亚元继任者传递给持续任务，亚元继任者的引用计数会在持续任务完成后才递减。</p>
<h3 id="调度旁路"><a href="#调度旁路" class="headerlink" title="调度旁路"></a>调度旁路</h3><p>调度旁路（scheduler bypass）是一种优化手段，此时你直接指定下一个要运行的任务。持续传递风格经常会为调度旁路开启机会。例如，在持续传递例子的最后，方法<code>execute()</code>产出任务“a”后返回。这会导致正在执行的线程做以下事情：</p>
<ol>
<li>将任务“a”入栈线程的任务队列</li>
<li>从方法<code>execute()</code>返回</li>
<li>将任务“a”出栈，如果它被别的线程“偷窃”</li>
</ol>
<p>步骤1、3都是不必要的队列操作，更坏的是，允许“偷窃”会损害局部性而没有显著增加并行。方法execute()能通过返回一个指向“a”的指针而不是产出它来避免这些问题。由线程执行任务的规则1可知，“a”变为此线程的下一个要执行的任务。而且，这种方法保证执行任务“a”的是此线程，而不是另外的线程。</p>
<p>下面的示例显示了前一节的例子中必须要做的变更：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FibTask</span> : <span class="keyword">public</span> task</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">		<span class="function">task* <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n&lt;CutOff)</span><br><span class="line">		&#123;</span><br><span class="line">			*sum = <span class="built_in">SerialFib</span>(n);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			FibContinuation&amp; c =</span><br><span class="line">				*<span class="built_in">new</span>(<span class="built_in">allocate_continuation</span>()) <span class="built_in">FibContinuation</span>(sum);</span><br><span class="line">			FibTask&amp; a = *<span class="built_in">new</span>(c.<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">2</span>, &amp;c.x);</span><br><span class="line">			FibTask&amp; b = *<span class="built_in">new</span>(c.<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">1</span>, &amp;c.y);</span><br><span class="line">			<span class="comment">// Set ref_count to &quot;two children&quot;. </span></span><br><span class="line">			c.<span class="built_in">set_ref_count</span>(<span class="number">2</span>);</span><br><span class="line">			<span class="built_in">spawn</span>(b);</span><br><span class="line">			<span class="built_in">spawn</span>(a);</span><br><span class="line">			<span class="comment">//return NULL;</span></span><br><span class="line">			<span class="keyword">return</span> &amp;a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="任务再生"><a href="#任务再生" class="headerlink" title="任务再生"></a>任务再生</h3><p>不但可以绕过调度器，也可以绕过任务分配与再分配。这在递归任务执行调度旁路时，会有相应的更高几率发生。考虑前面的例子。当它创建了一个持续任务“c”，会执行下面的步骤：</p>
<ol>
<li>创建子任务“a”</li>
<li>创建并产出子任务“b”</li>
<li>从<code>execute()</code>方法返回指向任务“a”的指针</li>
<li>销毁父任务</li>
</ol>
<p>如果把“a”当作父任务，就可以避免上述的步骤1、4. 在很多场景中，步骤1需要从父任务中拷贝状态。将“a”当作父任务会消除拷贝开销。下面的例子显示了使用任务再生改造调度旁路的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FibTask</span> : <span class="keyword">public</span> task</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*const*/</span> <span class="type">long</span> n;</span><br><span class="line">	<span class="type">long</span>* <span class="comment">/*const*/</span> sum;</span><br><span class="line">	...</span><br><span class="line">		<span class="function">task* <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n&lt;<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*sum = <span class="built_in">SerialFib</span>(n);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			FibContinuation&amp; c =</span><br><span class="line">				*<span class="built_in">new</span>(<span class="built_in">allocate_continuation</span>()) <span class="built_in">FibContinuation</span>(sum);</span><br><span class="line">			FibTask&amp; a = *<span class="built_in">new</span>(c.<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">2</span>, &amp;c.x);</span><br><span class="line">			FibTask&amp; b = *<span class="built_in">new</span>(c.<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">1</span>, &amp;c.y);</span><br><span class="line">			<span class="built_in">recycle_as_child_of</span>(c);</span><br><span class="line">			n -= <span class="number">2</span>;</span><br><span class="line">			sum = &amp;c.x;</span><br><span class="line">			<span class="comment">// Set ref_count to &quot;two children&quot;. </span></span><br><span class="line">			c.<span class="built_in">set_ref_count</span>(<span class="number">2</span>);</span><br><span class="line">			<span class="built_in">spawn</span>(b);</span><br><span class="line">			<span class="comment">//return &amp;a;</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>execute()</code>方法现在返回this，而不是”a” 任务。调用<code>recycle_as_child_of(c)</code>有几种作用：</p>
<ul>
<li>标记this在<code>execute()</code>返回后不能自动销毁</li>
<li>设置this的继任者为<code>c</code></li>
</ul>
<p>为了防止引用计数问题，<code>recycle_as_child_of</code>有个前置条件，那就是this的继任者必须为空。这是在<code>allocate_continuation</code>发生后的情况。下图显示了allocate_continuation、recycle_as_child_of如何转换任务图：</p>
<p><img src="/img/20150415220015936.jpg" alt=""></p>
<p>使用任务再生时，确保原始任务的字段在任务开始运行后不能处于被使用状态。例子使用调度旁路技术来确保这点。可以在产出时，当它的字段没有被使用时再产出再生任务。这个限制甚至适用于任何const字段，因为产出（spawning）后，任务可能在父任务没有任何动作的情况下运行并销毁。</p>
<p>一个类似的方法，<code>task::recycle_as_continuation()</code>，将一个任务作为一个持续任务而不是孩子任务。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于任务调度的复杂性，官方并不鼓励直接使用调度器，采用<code>parallel_for</code>、<code>parallel_reduce</code>等模板是个好主意。以下细节需要谨记：</p>
<ul>
<li>使用<code>new(allocation_method)T</code>来分配一个<code>task</code> （<code>allocation_method</code>是<code>task</code>类的一种分配方法）。不要创建局部或者文件作用域的task实例</li>
<li>除非使用<code>allocate_additional_child_of</code>，否则在运行任何任务前，它的兄弟任务都必须分配完毕。</li>
<li>采用持续传递、绕过调度器，以及任务再生等技术榨取最大性能</li>
<li>如果一个任务完成了，并且没有被标记为再执行，就会自动销毁。同样，它的继任者的引用计数会减少，如果到了0，继任者会被自动产出</li>
</ul>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>Intel Threading Building Blocks（Intel TBB）提供了两种与STL模板类（<code>std::allocator</code>)类似的内存分配器模板。这两类模板（<code>scalable_allocator&lt;T&gt;</code>、<code>cache_aligned_allocator&lt;T&gt;</code>）解决并行编程中的如下关键问题：</p>
<ul>
<li>可伸缩性    当在线程中使用原本为串行编程而设计的内存分配器因单个同一时间只允许一个线程分配的共享池而竞争的时候，可伸缩性的问题就会凸显。使用内存分配模板scalable_allocator<T>来避免此类可伸缩性瓶颈。这个模板可以提升急速分配、释放内存程序的性能。</li>
<li>伪共享   当两个线程访问同一缓存行的不同字节时，伪共享的问题就会出现。这是因为，缓存行（cache line）是不同处理器缓存间交换信息的单位。如果一个处理器修改了一个缓存行而另外一个处理器读（或者写）同一个缓存行，那么它必须从一个处理器移动到另外一个处理器，即使两个处理处理的是这行内的不同字节。因为缓存行的移动会耗费数百个时钟周期，伪共享会损害性能。</li>
</ul>
<p>使用<code>cache_aligned_allocator&lt;T&gt;</code>类在某个缓存行分配。两个使用<code>cache_aligned_allocator</code>分配的对象能被确保不会使用伪共享。如果一个对象使用<code>cache_aligned_allocator&lt;T&gt;</code>分配，而另外一个对象使用了不同的方式，就没有了这种保证。<code>cache_aligned_allocator&lt;T&gt;</code>的接口类似<code>std::allocator</code>，所以你可以将它作为allocator参数传递给STL的模板类。</p>
<p>下面的代码展示了如何声明一个使用<code>cache_aligned_allocator</code>作为分配器的STL vector：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>,cache_aligned_allocator&lt;<span class="type">int</span>&gt; &gt;;</span><br></pre></td></tr></table></figure>
<p><code>cache_aligned_allocator&lt;T&gt;</code>的设计功能的实现伴随着空间开销，因为它必须至少分配一条缓存行占用的内存，即使是对很小的对象。所以，如果伪共享不成问题，就别使用<code>cache_aligned_allocator&lt;T&gt;</code>。可伸缩内存分配器包含了Intel的PSL CTG团队开发的McRT技术。</p>
<h2 id="动态库的选择"><a href="#动态库的选择" class="headerlink" title="动态库的选择"></a>动态库的选择</h2><p><code>scalable_allocator&lt;T&gt;</code>模板需要Intel TBB 可伸缩内存分配器库。它并不需要Intel TBB的常规库，并且能与Intel TBB独立开来使用。如果没有指定可伸缩分配器库，模板<code>tbb_allocator&lt;T&gt;</code>、<code>cache_aligned_allocator&lt;T&gt;</code>就会使用<code>malloc</code>、<code>free</code>等标准库提供的内存分配函数。因此，甚至可以在忽略可伸缩内存分配器库的应用中使用这些模板。Intel Threading Building Blocks的其余部分，有没有Intel TBB可伸缩内存分配器库都可以使用。</p>
<h2 id="自动替换malloc等C-C-动态内存分配函数"><a href="#自动替换malloc等C-C-动态内存分配函数" class="headerlink" title="自动替换malloc等C/C++动态内存分配函数"></a>自动替换malloc等C/C++动态内存分配函数</h2><p>在windows、Linux操作系统中，可以自动使用Intel TBB中相应的可伸缩实现替换所有标准动态内存分配函数调用（比如：malloc）。在一些场合，可以提升性能。</p>
<h3 id="Linux-C-C-动态内存借口替换"><a href="#Linux-C-C-动态内存借口替换" class="headerlink" title="Linux C/C++动态内存借口替换"></a>Linux C/C++动态内存借口替换</h3><p>替换通过代理库（release：libtbbmalloc_proxy.so.x、debug：libtbbmalloc_proxy_debug.so.x）提供。替换行为可以通过运行时加载代理库（通过LD_PRELOAD）或者链接（linking）代理库实现。代理库实现了以下动态内存函数：</p>
<ul>
<li>C library：malloc，calloc，realloc，free</li>
<li>标准POSIX函数：posix_memalign</li>
<li>废弃的函数：valloc，memalign，pvalloc，mallopt</li>
<li>全局C++操作符：new、delete</li>
</ul>
<p>动态加载时，要保证代理库以及相应的可伸缩内存分配器库可被访问。要做到这点，可通过在<code>LD_LIBRARY_PATH</code>中包含或者将其加入到<code>/etc/ld.so.conf</code>中</p>
<p>下面是一个如何设置<code>LD_PRELOAD</code>以及链接程序使用替换的例子。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set LD_PRELOAD so that loader loads release version of proxy </span></span><br><span class="line">LD_PRELOAD=libtbbmalloc_proxy.so.2 </span><br><span class="line"><span class="comment"># Link with release version of proxy and scalable allocator </span></span><br><span class="line">g++ foo.o bar.o -ltbbmalloc_proxy -ltbbmalloc -o a.out</span><br></pre></td></tr></table></figure></p>
<p>使用Debug版本的库：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set LD_PRELOAD so that loader loads debug version of proxy </span></span><br><span class="line">LD_PRELOAD=libtbbmalloc_proxy_debug.so.2 </span><br><span class="line"><span class="comment"># Link with debug version of proxy and scalable allocator </span></span><br><span class="line">g++ foo.o bar.o -ltbbmalloc_proxy_debug -ltbbmalloc_debug -o a.out</span><br></pre></td></tr></table></figure></p>
<h3 id="windows下C-动态内存接口替换"><a href="#windows下C-动态内存接口替换" class="headerlink" title="windows下C++动态内存接口替换"></a>windows下C++动态内存接口替换</h3><p>替换通过代理库（release：tbbmalloc_proxy.dll，debug：tbbmalloc_debug_proxy.dll）提供。能以下面的任一种方式实现：</p>
<ul>
<li>包含头文件 #include “tbb/tbbmalloc_proxy.h”</li>
<li>设置链接参数 <ul>
<li>对于32位代码：tbbmalloc_proxy.lib /INCLUDE:”___TBB_malloc_proxy”  （三个下划线）</li>
<li>对于64位代码：tbbmalloc_proxy.lib /INCLUDE:”__TBB_malloc_proxy”      （两个下划线）</li>
</ul>
</li>
</ul>
<p>代理库实现了下面的动态内存函数：</p>
<ul>
<li>标准C运行时动态内存函数：malloc，calloc，realloc，free</li>
<li>全局C++操作符：new，delete</li>
<li>Microsoft C运行时库函数：<code>_msize</code></li>
</ul>
<p>同样要保证代理库、可伸缩内存分配库在程序启动时能被加载，例如，可将其路径包含在<code>%PATH%</code>环境变量中。</p>
<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>可以使用原子操作来避免使用互斥。当一个线程执行原子操作，在其他线程眼里，这个操作是瞬时完成的。原子操作的优点是，相比较锁操作是快速的，而且不用为死锁、锁护送等问题而烦恼。缺点是，它们只有有限的一组操作，常常无法和成为有效的复杂操作。尽管如此，也不应该放弃使用原子操作替换互斥的机会。<code>aotmic&lt;T&gt;</code>类以C++风格实现了原子操作。   </p>
<p>原子操作的一个典型应用是线程安全的引用计数。设x是类型为 int 的引用计数，当它变为0时程序需要做一些操作。在单线程代码中，你可以使用 int 来定义 x，然后<code>--x;if ( x==0 ) action()</code>。但在多线程环境中，这种方法可能会失效，因为两个线程可能以下表的方式交替操作（其中的t(x)代表机器的寄存器）。</p>
<p>下表列出了原子操作模板的5种基本操作：</p>
<ul>
<li><code>= x</code>：读取 x 的值</li>
<li><code>x =</code>：给 x 赋值，并返回它</li>
<li><code>x.fetch_and_store(y)</code>：执行x=y，并返回x的旧值</li>
<li><code>x.fetch_and_add(y)</code>：执行x+=y，并返回x的旧值</li>
<li><code>x.compare_and_swap(y,z)</code>：如果x==z，执行 x=y . 返回x的旧值</li>
</ul>
<p>因为这些操作都是自动的，它们可被在安全应用而不用互斥体。考虑下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">unsigned</span>&gt; counter;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">GetUniqueInteger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> counter.<span class="built_in">fetch_and_add</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例程 GetUniqueInteger 每被调用一次就返回一个不同的整形，直到计数器又从头计数。无论多少个线程同时执行这段代码，都不会出例外。</p>
<p>compare_and_swap 是很多非阻塞算法的基本操作。互斥体的一个问题是，如果持有某个锁的线程挂起了，其他所有线程在它恢复之前都会被阻塞。非阻塞算法用原子操作代替锁来避免这个问题。他们（非阻塞算法）通常很复杂，而且需要复杂的分析去验证。然而，下面的习惯很直观，值得知晓。它以一种基于 globalx 旧值的方式更新 globalx 。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">int</span>&gt; globalx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">UpdateX</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">// Update x and return old value of x. </span></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Read globalX </span></span><br><span class="line">		oldx = globalx;</span><br><span class="line">		<span class="comment">// Compute new value </span></span><br><span class="line">		newx = ...expression involving oldx....</span><br><span class="line">			<span class="comment">// Store new value if another thread has not changed globalX. </span></span><br><span class="line">	&#125; <span class="keyword">while</span> (globalx.<span class="built_in">compare_and_swap</span>(newx, oldx) != oldx);</span><br><span class="line">	<span class="keyword">return</span> oldx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比较差的情况下，一些线程迭代循环直到没有其他的线程干预。一般来说，如果更新只需要少数指令，这种方法要快于相应的互斥体解决方案。</p>
<p>注意：如果下述序列不利于你的意图，那么上述的更新方法就不可取：</p>
<ul>
<li>一个线程从 globalx 中读取值 A</li>
<li>其他的线程将 globalx 从 A 修改为 B ，再到 A</li>
<li>步骤1 的线程执行 compare_and_swap， 读取 A ，但没有检测到期间变化到 B</li>
</ul>
<p>这个问题被称为 ABA 问题。为链表数据结构设计设计非阻塞算法时，它常常成为问题。</p>
<h2 id="atomic没有构造函数"><a href="#atomic没有构造函数" class="headerlink" title="atomic没有构造函数"></a>atomic<T>没有构造函数</h2><p><code>atomic&lt;T&gt;</code>模板类特意没有声明构造函数，因为诸如上述的 GetUniqueInteger 之类的例子一般要求在所有的文件作用域构造函数被调用前就可以工作。如果该模板类声明了构造函数，在它被引用后，也许要初始化一个文件作用域的实例。在下述上下文中，任何没有生命构造函数的 C++类的原子类型<code>atomic&lt;T&gt;</code>的对象 X 被自动初始化为 0 ：</p>
<ul>
<li>X 被声明为文件作用域变量，或者类的静态数据成员</li>
<li>X 是类的成员，并且显式地出现在该类的构造函数的初始化列表中</li>
</ul>
<p>下面的代码是对这些问题的解释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">int</span>&gt; x; <span class="comment">// 由于处于文件作用域，初始化为0 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">	atomic&lt;<span class="type">int</span>&gt; y;</span><br><span class="line">	atomic&lt;<span class="type">int</span>&gt; notzeroed;</span><br><span class="line">	<span class="type">static</span> atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Foo</span>() :</span><br><span class="line">		<span class="built_in">y</span>() <span class="comment">// y 初始化为0. </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// notzeroed has unspecified value here. </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; Foo::z; <span class="comment">// 静态成员，初始化为0</span></span><br></pre></td></tr></table></figure>
<h1 id="异常与终止"><a href="#异常与终止" class="headerlink" title="异常与终止"></a>异常与终止</h1><p>Intel TBB支持异常与终止（cancellation），当算法中的代码抛出异常时，会按依次发生：</p>
<ul>
<li>捕获异常。算法内进一步的异常被忽略。</li>
<li>算法终止。挂起的迭代操作不被执行。如果内部存在嵌套的Intel TBB并行，那么它的取消与否取决于特定实现（下面会提到）</li>
<li>算法的所有部分都停止后，会在调用算法的线程（thread）上抛出异常。</li>
</ul>
<p>步骤3中抛出的异常可能是初始的异常，也可能仅仅是captured_exception类型的摘要。后者常发生在当前的系统中，因为在线程间传递异常需要支持C++的std::exception_ptr机制。随着编译器在支持此项特性上的进展，将来的Intel TBB版本可能抛出初始的异常。所以，确保你的代码可以捕获两种异常中的任意异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Update</span> &#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> blocked_range&lt;<span class="type">int</span>&gt;&amp; r)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) Data.<span class="built_in">at</span>(i) += <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Data.<span class="built_in">resize</span>(<span class="number">1000</span>);</span><br><span class="line">   <span class="keyword">try</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, <span class="number">2000</span>), <span class="built_in">Update</span>());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">catch</span> (captured_exception&amp; ex)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;captured_exception: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">catch</span> (out_of_range&amp; ex)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;out_of_range: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="无异常终止"><a href="#无异常终止" class="headerlink" title="无异常终止"></a>无异常终止</h2><p>要取消某个算法而不抛出异常，使用表达式<code>task::self().cancel_group_execution()</code>. 其中的<code>task::self()</code>引用当前线程最靠内的Intel TBB任务。调用<code>cancel_group_execution()</code>取消它的<code>task_group_context</code>中的所以线程（下节会详细介绍）。如果的确导致了任务终止，此方法会返回 true ，如果task_group_context 已经被取消，就会返回 false。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Update</span> &#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> blocked_range&lt;<span class="type">int</span>&gt;&amp; r)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) <span class="keyword">if</span> (i &lt; Data.<span class="built_in">size</span>())</span><br><span class="line">         &#123;</span><br><span class="line">            ++Data[i];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">// Cancel related tasks.</span></span><br><span class="line">            <span class="keyword">if</span> (task::<span class="built_in">self</span>().<span class="built_in">cancel_group_execution</span>()) </span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; caused cancellation\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Data.<span class="built_in">resize</span>(<span class="number">1000</span>);</span><br><span class="line">   <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, <span class="number">2000</span>), <span class="built_in">Update</span>());</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/06/cpp17guide/" rel="prev" title="C++ 17 指南">
      <i class="fa fa-chevron-left"></i> C++ 17 指南
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/10/simd/" rel="next" title="SIMD介绍">
      SIMD介绍 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">术语与基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%89%B2%EF%BC%88splitable-concept%EF%BC%89%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">分割（splitable concept）：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%9F%9F%EF%BC%88range-concept%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">区域（range concept）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E5%99%A8%EF%BC%88partitioner%EF%BC%89%EF%BC%9A"><span class="nav-number">1.3.</span> <span class="nav-text">分割器（partitioner）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%8F%82%E8%80%83%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">基本算法参考及使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%EF%BC%88algorithms%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">基本算法（algorithms）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#parallel-for"><span class="nav-number">2.1.1.</span> <span class="nav-text">parallel_for</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parallel-reduce"><span class="nav-number">2.1.2.</span> <span class="nav-text">parallel_reduce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parallel-scan"><span class="nav-number">2.1.3.</span> <span class="nav-text">parallel_scan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parallel-do"><span class="nav-number">2.1.4.</span> <span class="nav-text">parallel_do</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pipleline"><span class="nav-number">2.1.5.</span> <span class="nav-text">pipleline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%91%E5%AE%9A%E8%BF%87%E6%BB%A4%E5%99%A8thread-bound-filter"><span class="nav-number">2.1.6.</span> <span class="nav-text">线程绑定过滤器thread_bound_filter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">简单循环的并行化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%88%86%E5%9D%97"><span class="nav-number">3.1.</span> <span class="nav-text">自动分块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%88%86%E5%9D%97"><span class="nav-number">3.2.</span> <span class="nav-text">控制分块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E5%AE%BD%E4%B8%8E%E7%BC%93%E5%AD%98%EF%BC%88cache%EF%BC%89%E4%BA%B2%E7%BC%98%E6%80%A7"><span class="nav-number">3.3.</span> <span class="nav-text">带宽与缓存（cache）亲缘性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%99%A8%E6%80%BB%E7%BB%93"><span class="nav-number">3.4.</span> <span class="nav-text">分区器总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parallel-reduce-1"><span class="nav-number">3.5.</span> <span class="nav-text">parallel_reduce</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%92%E6%96%A5"><span class="nav-number">4.</span> <span class="nav-text">互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93%E8%A6%81%E7%B4%A0"><span class="nav-number">4.1.</span> <span class="nav-text">互斥体要素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">4.2.</span> <span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%87%E7%BA%A7-%E9%99%8D%E7%BA%A7"><span class="nav-number">4.2.1.</span> <span class="nav-text">升级&#x2F;降级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E5%BC%82%E5%B8%B8"><span class="nav-number">4.2.2.</span> <span class="nav-text">锁异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E6%8A%A4%E9%80%81"><span class="nav-number">4.2.3.</span> <span class="nav-text">锁护送</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="nav-number">5.</span> <span class="nav-text">任务调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E6%88%90"><span class="nav-number">5.1.</span> <span class="nav-text">任务对象的生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">5.2.</span> <span class="nav-text">任务的调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%98%9F%E5%88%97"><span class="nav-number">5.3.</span> <span class="nav-text">线程的队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E7%94%A8%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%8A%80%E6%9C%AF"><span class="nav-number">5.4.</span> <span class="nav-text">有用的任务技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E9%93%BE%E5%BC%8F%E5%8F%8D%E5%BA%94"><span class="nav-number">5.4.1.</span> <span class="nav-text">递归链式反应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E7%BB%AD%E4%BC%A0%E9%80%92"><span class="nav-number">5.4.2.</span> <span class="nav-text">持续传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E6%97%81%E8%B7%AF"><span class="nav-number">5.4.3.</span> <span class="nav-text">调度旁路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%86%8D%E7%94%9F"><span class="nav-number">5.4.4.</span> <span class="nav-text">任务再生</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">6.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">6.1.</span> <span class="nav-text">动态库的选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%9B%BF%E6%8D%A2malloc%E7%AD%89C-C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text">自动替换malloc等C&#x2F;C++动态内存分配函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-C-C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%80%9F%E5%8F%A3%E6%9B%BF%E6%8D%A2"><span class="nav-number">6.2.1.</span> <span class="nav-text">Linux C&#x2F;C++动态内存借口替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#windows%E4%B8%8BC-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E6%8E%A5%E5%8F%A3%E6%9B%BF%E6%8D%A2"><span class="nav-number">6.2.2.</span> <span class="nav-text">windows下C++动态内存接口替换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">7.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">7.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#atomic%E6%B2%A1%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">atomic没有构造函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%BB%88%E6%AD%A2"><span class="nav-number">8.</span> <span class="nav-text">异常与终止</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2"><span class="nav-number">8.1.</span> <span class="nav-text">无异常终止</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
