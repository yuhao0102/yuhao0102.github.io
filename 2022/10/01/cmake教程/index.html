<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="从可执行文件到库本章的主要内容有：  将单个源码文件编译为可执行文件  切换生成器  构建和连接静态库与动态库  用条件语句控制编译  向用户显示选项  指定编译器  切换构建类型  设置编译器选项  为语言设定标准  使用控制流进行构造   本章的示例将指导您完成构建代码所需的基本任务：编译可执行文件、编译库、根据用户输入执行构建操作等等。CMake是一个构建系统生成器，特别适合于独立平台和编译">
<meta property="og:type" content="article">
<meta property="og:title" content="CMake教程">
<meta property="og:url" content="http://yoursite.com/2022/10/01/cmake%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="从可执行文件到库本章的主要内容有：  将单个源码文件编译为可执行文件  切换生成器  构建和连接静态库与动态库  用条件语句控制编译  向用户显示选项  指定编译器  切换构建类型  设置编译器选项  为语言设定标准  使用控制流进行构造   本章的示例将指导您完成构建代码所需的基本任务：编译可执行文件、编译库、根据用户输入执行构建操作等等。CMake是一个构建系统生成器，特别适合于独立平台和编译">
<meta property="og:locale" content="zn_CH">
<meta property="article:published_time" content="2022-10-01T06:54:00.000Z">
<meta property="article:modified_time" content="2022-10-02T05:10:01.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="积累">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2022/10/01/cmake%E6%95%99%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>CMake教程 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/10/01/cmake%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CMake教程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-01 14:54:00" itemprop="dateCreated datePublished" datetime="2022-10-01T14:54:00+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-02 13:10:01" itemprop="dateModified" datetime="2022-10-02T13:10:01+08:00">2022-10-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="从可执行文件到库"><a href="#从可执行文件到库" class="headerlink" title="从可执行文件到库"></a>从可执行文件到库</h1><p>本章的主要内容有：</p>
<ul>
<li><p>将单个源码文件编译为可执行文件</p>
</li>
<li><p>切换生成器</p>
</li>
<li><p>构建和连接静态库与动态库</p>
</li>
<li><p>用条件语句控制编译</p>
</li>
<li><p>向用户显示选项</p>
</li>
<li><p>指定编译器</p>
</li>
<li><p>切换构建类型</p>
</li>
<li><p>设置编译器选项</p>
</li>
<li><p>为语言设定标准</p>
</li>
<li><p>使用控制流进行构造</p>
</li>
</ul>
<p>本章的示例将指导您完成构建代码所需的基本任务：编译可执行文件、编译库、根据用户输入执行构建操作等等。CMake是一个构建系统生成器，特别适合于独立平台和编译器。除非另有说明，否则所有配置都独立于操作系统，它们可以在GNU/Linux、macOS和Windows的系统下运行。</p>
<p>本书的示例主要为C++项目设计，并使用C++示例进行了演示，但CMake也可以用于其他语言的项目，包括C和Fortran。我们会尝试一些有意思的配置，其中包含了一些C++、C和Fortran语言示例。您可以根据自己喜好，选择性了解。有些示例是定制的，以突出在选择特定语言时需要面临的挑战。</p>
<h2 id="将单个源文件编译为可执行文件"><a href="#将单个源文件编译为可执行文件" class="headerlink" title="将单个源文件编译为可执行文件"></a>将单个源文件编译为可执行文件</h2><p>本节示例中，我们将演示如何运行CMake配置和构建一个简单的项目。该项目由单个源文件组成，用于生成可执行文件。我们将用C++讨论这个项目，您在GitHub示例库中可以找到C和Fortran的例子。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们希望将以下源代码编译为单个可执行文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function">std::string <span class="title">say_hello</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello, CMake world!&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">say_hello</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h3><p>我们把CMake指令放入一个名为CMakeLists.txt的文件中。文件的名称区分大小写，必须命名为CMakeLists.txt，CMake才能够解析。</p>
<p>用编辑器打开一个文本文件，将这个文件命名为CMakeLists.txt。</p>
<p>第一行，设置CMake所需的最低版本。如果使用的CMake版本低于该版本，则会发出致命错误：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.5 FATAL_ERROR)</span><br></pre></td></tr></table></figure></p>
<p>第二行，声明了项目的名称(recipe-01)和支持的编程语言(CXX代表C++)：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span> LANGUAGES CXX)</span><br></pre></td></tr></table></figure>
<p>指示CMake创建一个新目标：可执行文件hello-world。这个可执行文件是通过编译和链接源文件hello-world.cpp生成的。CMake将为编译器使用默认设置，并自动选择生成工具：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br></pre></td></tr></table></figure>
<p>将该文件与源文件hello-world.cpp放在相同的目录中。记住，它只能被命名为CMakeLists.txt。</p>
<p>现在，可以通过创建build目录，在build目录下来配置项目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- The CXX compiler identification is GNU 8.1.0</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/user/cmake-cookbook/chapter-01/recipe-01/cxx-example/build</span><br></pre></td></tr></table></figure>
<p>如果一切顺利，项目的配置已经在build目录中生成。我们现在可以编译可执行文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br><span class="line">Scanning dependencies of target hello-world</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/hello-world.dir/hello-world.cpp.o</span><br><span class="line">[100%] Linking CXX executable hello-world</span><br><span class="line">[100%] Built target hello-world</span><br></pre></td></tr></table></figure>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>示例中，我们使用了一个简单的CMakeLists.txt来构建“Hello world”可执行文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br></pre></td></tr></table></figure>
<p>NOTE:CMake语言不区分大小写，但是参数区分大小写。</p>
<blockquote>
<p>CMake中，C++是默认的编程语言。不过，我们还是建议使用LANGUAGES选项在project命令中显式地声明项目的语言。</p>
</blockquote>
<p>要配置项目并生成构建器，我们必须通过命令行界面(CLI)运行CMake。CMake CLI提供了许多选项，cmake -help将输出以显示列出所有可用选项的完整帮助信息，我们将在书中对这些选项进行更多地了解。正如您将从cmake -help的输出中显示的内容，它们中的大多数选项会让你您访问CMake手册，查看详细信息。通过下列命令生成构建器：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br></pre></td></tr></table></figure>
<p>这里，我们创建了一个目录build(生成构建器的位置)，进入build目录，并通过指定CMakeLists.txt的位置(本例中位于父目录中)来调用CMake。可以使用以下命令行来实现相同的效果：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -H. -Bbuild</span><br></pre></td></tr></table></figure>
<p>该命令是跨平台的，使用了-H和-B为CLI选项。-H表示当前目录中搜索根CMakeLists.txt文件。-Bbuild告诉CMake在一个名为build的目录中生成所有的文件。</p>
<p>运行cmake命令会输出一系列状态消息，显示配置信息：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cmake ..</span><br><span class="line">-- The CXX compiler identification is GNU <span class="number">8.1</span>.<span class="number">0</span></span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/user/cmake-cookbook/chapter-<span class="number">01</span>/recipe-<span class="number">01</span>/cxx-example/build</span><br></pre></td></tr></table></figure>
<p>NOTE:在与CMakeLists.txt相同的目录中执行cmake .，原则上足以配置一个项目。然而，CMake会将所有生成的文件写到项目的根目录中。这将是一个源代码内构建，通常是不推荐的，因为这会混合源代码和项目的目录树。我们首选的是源外构建。</p>
<p>CMake是一个构建系统生成器。将描述构建系统(如：Unix Makefile、Ninja、Visual Studio等)应当如何操作才能编译代码。然后，CMake为所选的构建系统生成相应的指令。默认情况下，在GNU/Linux和macOS系统上，CMake使用Unix Makefile生成器。Windows上，Visual Studio是默认的生成器。</p>
<p>GNU/Linux上，CMake默认生成Unix Makefile来构建项目：</p>
<ul>
<li>Makefile: make将运行指令来构建项目。</li>
<li>CMakefile：包含临时文件的目录，CMake用于检测操作系统、编译器等。此外，根据所选的生成器，它还包含特定的文件。</li>
<li>cmake_install.cmake：处理安装规则的CMake脚本，在项目安装时使用。</li>
<li>CMakeCache.txt：如文件名所示，CMake缓存。CMake在重新运行配置时使用这个文件。</li>
</ul>
<p>要构建示例项目，我们运行以下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br></pre></td></tr></table></figure></p>
<p>最后，CMake不强制指定构建目录执行名称或位置，我们完全可以把它放在项目路径之外。这样做同样有效：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p /tmp/someplace</span><br><span class="line">$ <span class="built_in">cd</span> /tmp/someplace</span><br><span class="line">$ cmake /path/to/source</span><br><span class="line">$ cmake --build .</span><br></pre></td></tr></table></figure></p>
<p>由CMake生成的构建系统，即上面给出的示例中的Makefile，将包含为给定项目构建目标文件、可执行文件和库的目标及规则。hello-world可执行文件是在当前示例中的唯一目标，运行以下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build . --target <span class="built_in">help</span></span><br><span class="line">The following are some of the valid targets <span class="keyword">for</span> this Makefile:</span><br><span class="line">... all (the default <span class="keyword">if</span> no target is provided)</span><br><span class="line">... clean</span><br><span class="line">... depend</span><br><span class="line">... rebuild_cache</span><br><span class="line">... hello-world</span><br><span class="line">... edit_cache</span><br><span class="line">... hello-world.o</span><br><span class="line">... hello-world.i</span><br><span class="line">... hello-world.s</span><br></pre></td></tr></table></figure></p>
<p>CMake生成的目标比构建可执行文件的目标要多。可以使用<code>cmake --build . --target &lt;target-name&gt;</code>语法，实现如下功能：</p>
<ul>
<li>all(或Visual Studio generator中的ALL_BUILD)是默认目标，将在项目中构建所有目标。</li>
<li>clean，删除所有生成的文件。</li>
<li>rebuild_cache，将调用CMake为源文件生成依赖(如果有的话)。</li>
<li>edit_cache，这个目标允许直接编辑缓存。</li>
</ul>
<p>对于更复杂的项目，通过测试阶段和安装规则，CMake将生成额外的目标：</p>
<ul>
<li>test(或Visual Studio generator中的RUN_TESTS)将在CTest的帮助下运行测试套件。我们将在第4章中详细讨论测试和CTest。</li>
<li>install，将执行项目安装规则。我们将在第10章中讨论安装规则。</li>
<li>package，此目标将调用CPack为项目生成可分发的包。打包和CPack将在第11章中讨论。</li>
</ul>
<h2 id="切换生成器"><a href="#切换生成器" class="headerlink" title="切换生成器"></a>切换生成器</h2><p>CMake是一个构建系统生成器，可以使用单个CMakeLists.txt为不同平台上的不同工具集配置项目。您可以在CMakeLists.txt中描述构建系统必须运行的操作，以配置并编译代码。基于这些指令，CMake将为所选的构建系统(Unix Makefile、Ninja、Visual Studio等等)生成相应的指令。</p>
<h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>CMake针对不同平台支持本地构建工具列表。同时支持命令行工具(如Unix Makefile和Ninja)和集成开发环境(IDE)工具。用以下命令，可在平台上找到生成器名单，以及已安装的CMake版本：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></p>
<p>这个命令的输出，将列出CMake命令行界面上所有的选项，您会找到可用生成器的列表。例如，安装了CMake 3.11.2的GNU/Linux机器上的输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Generators</span><br><span class="line">The following generators are available on this platform:</span><br><span class="line">Unix Makefiles = Generates standard UNIX makefiles.</span><br><span class="line">Ninja = Generates build.ninja files.</span><br><span class="line">Watcom WMake = Generates Watcom WMake makefiles.</span><br><span class="line">CodeBlocks - Ninja = Generates CodeBlocks project files.</span><br><span class="line">CodeBlocks - Unix Makefiles = Generates CodeBlocks project files.</span><br><span class="line">CodeLite - Ninja = Generates CodeLite project files.</span><br><span class="line">CodeLite - Unix Makefiles = Generates CodeLite project files.</span><br><span class="line">Sublime Text 2 - Ninja = Generates Sublime Text 2 project files.</span><br><span class="line">Sublime Text 2 - Unix Makefiles = Generates Sublime Text 2 project files.</span><br><span class="line">Kate - Ninja = Generates Kate project files.</span><br><span class="line">Kate - Unix Makefiles = Generates Kate project files.</span><br><span class="line">Eclipse CDT4 - Ninja = Generates Eclipse CDT 4.0 project files.</span><br><span class="line">Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT 4.0 project files.</span><br></pre></td></tr></table></figure></p>
<p>使用此示例，我们将展示为项目切换生成器是多么EASY。</p>
<h3 id="具体实施-1"><a href="#具体实施-1" class="headerlink" title="具体实施"></a>具体实施</h3><p>我们将重用前一节示例中的hello-world.cpp和CMakeLists.txt。惟一的区别在使用CMake时，因为现在必须显式地使用命令行方式，用-G切换生成器。</p>
<p>首先，使用以下步骤配置项目:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -G Ninja ..</span><br><span class="line">-- The CXX compiler identification is GNU 8.1.0</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /home/user/cmake-cookbook/chapter-01/recipe-02/cxx-exampl</span><br></pre></td></tr></table></figure></p>
<p>第二步，构建项目：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br><span class="line">[2/2] Linking CXX executable hello-world</span><br></pre></td></tr></table></figure></p>
<h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>与前一个配置相比，每一步的输出没什么变化。每个生成器都有自己的文件集，所以编译步骤的输出和构建目录的内容是不同的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build.ninja和rules.ninja：包含Ninja的所有的构建语句和构建规则。</span><br><span class="line">CMakeCache.txt：CMake会在这个文件中进行缓存，与生成器无关。</span><br><span class="line">CMakeFiles：包含由CMake在配置期间生成的临时文件。</span><br><span class="line">cmake_install.cmake：CMake脚本处理安装规则，并在安装时使用。</span><br><span class="line">cmake --build .将ninja命令封装在一个跨平台的接口中。</span><br></pre></td></tr></table></figure></p>
<h2 id="构建和链接静态库和动态库"><a href="#构建和链接静态库和动态库" class="headerlink" title="构建和链接静态库和动态库"></a>构建和链接静态库和动态库</h2><p>项目中会有单个源文件构建的多个可执行文件的可能。项目中有多个源文件，通常分布在不同子目录中。这种实践有助于项目的源代码结构，而且支持模块化、代码重用和关注点分离。同时，这种分离可以简化并加速项目的重新编译。本示例中，我们将展示如何将源代码编译到库中，以及如何链接这些库。</p>
<h3 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h3><p>回看第一个例子，这里并不再为可执行文件提供单个源文件，我们现在将引入一个类，用来包装要打印到屏幕上的消息。更新一下的hello-world.cpp:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Message <span class="title">say_hello</span><span class="params">(<span class="string">&quot;Hello, CMake World!&quot;</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; say_hello &lt;&lt; std::endl;</span><br><span class="line">  <span class="function">Message <span class="title">say_goodbye</span><span class="params">(<span class="string">&quot;Goodbye, CMake World&quot;</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; say_goodbye &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Message类包装了一个字符串，并提供重载过的&lt;&lt;操作，并且包括两个源码文件：Message.hpp头文件与Message.cpp源文件。Message.hpp中的接口包含以下内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Message</span>(<span class="type">const</span> std::string &amp;m) : <span class="built_in">message_</span>(m) &#123;&#125;</span><br><span class="line">  <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, Message &amp;obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.<span class="built_in">printObject</span>(os);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string message_;</span><br><span class="line">  <span class="function">std::ostream &amp;<span class="title">printObject</span><span class="params">(std::ostream &amp;os)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Message.cpp实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">Message::printObject</span><span class="params">(std::ostream &amp;os)</span> </span>&#123;</span><br><span class="line">  os &lt;&lt; <span class="string">&quot;This is my very nice message: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  os &lt;&lt; message_;</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-2"><a href="#具体实施-2" class="headerlink" title="具体实施"></a>具体实施</h3><p>这里有两个文件需要编译，所以CMakeLists.txt必须进行修改。本例中，先把它们编译成一个库，而不是直接编译成可执行文件:</p>
<p>创建目标——静态库。库的名称和源码文件名相同，具体代码如下：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span></span><br><span class="line">  STATIC</span><br><span class="line">    <span class="keyword">Message</span>.hpp</span><br><span class="line">    <span class="keyword">Message</span>.cpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>创建hello-world可执行文件的目标部分不需要修改：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br></pre></td></tr></table></figure></p>
<p>最后，将目标库链接到可执行目标：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(hello-world <span class="keyword">message</span>)</span><br></pre></td></tr></table></figure></p>
<p>对项目进行配置和构建。库编译完成后，将连接到hello-world可执行文件中：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --build .</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scanning dependencies of <span class="keyword">target</span> <span class="keyword">message</span></span><br><span class="line">[ <span class="number">25</span>%] Building CXX object CMakeFiles/<span class="keyword">message</span>.dir/<span class="keyword">Message</span>.cpp.o</span><br><span class="line">[ <span class="number">50</span>%] Linking CXX static library libmessage.a</span><br><span class="line">[ <span class="number">50</span>%] Built <span class="keyword">target</span> <span class="keyword">message</span></span><br><span class="line">Scanning dependencies of <span class="keyword">target</span> hello-world</span><br><span class="line">[ <span class="number">75</span>%] Building CXX object CMakeFiles/hello-world.dir/hello-world.cpp.o</span><br><span class="line">[<span class="number">100</span>%] Linking CXX executable hello-world</span><br><span class="line">[<span class="number">100</span>%] Built <span class="keyword">target</span> hello-world</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello-world</span></span><br><span class="line">This is my very nice message:</span><br><span class="line">Hello, CMake World!</span><br><span class="line">This is my very nice message:</span><br><span class="line">Goodbye, CMake World</span><br></pre></td></tr></table></figure>
<h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>本节引入了两个新命令：</p>
<p><code>add_library(message STATIC Message.hpp Message.cpp)</code>：生成必要的构建指令，将指定的源码编译到库中。add_library的第一个参数是目标名。整个CMakeLists.txt中，可使用相同的名称来引用库。生成的库的实际名称将由CMake通过在前面添加前缀lib和适当的扩展名作为后缀来形成。生成库是根据第二个参数(STATIC或SHARED)和操作系统确定的。</p>
<p><code>target_link_libraries(hello-world message)</code>: 将库链接到可执行文件。此命令还确保hello-world可执行文件可以正确地依赖于消息库。因此，在消息库链接到hello-world可执行文件之前，需要完成消息库的构建。</p>
<p>编译成功后，构建目录包含libmessage.a一个静态库(在GNU/Linux上)和hello-world可执行文件。</p>
<p>CMake接受其他值作为add_library的第二个参数的有效值，我们来看下本书会用到的值：</p>
<ul>
<li>STATIC：用于创建静态库，即编译文件的打包存档，以便在链接其他目标时使用，例如：可执行文件。</li>
<li>SHARED：用于创建动态库，即可以动态链接，并在运行时加载的库。可以在CMakeLists.txt中使用add_library(message SHARED Message.hpp Message.cpp)从静态库切换到动态共享对象(DSO)。</li>
<li>OBJECT：可将给定add_library的列表中的源码编译到目标文件，不将它们归档到静态库中，也不能将它们链接到共享对象中。如果需要一次性创建静态库和动态库，那么使用对象库尤其有用。我们将在本示例中演示。</li>
<li>MODULE：又为DSO组。与SHARED库不同，它们不链接到项目中的任何目标，不过可以进行动态加载。该参数可以用于构建运行时插件。</li>
</ul>
<p>CMake还能够生成特殊类型的库，这不会在构建系统中产生输出，但是对于组织目标之间的依赖关系，和构建需求非常有用：</p>
<ul>
<li>IMPORTED：此类库目标表示位于项目外部的库。此类库的主要用途是，对现有依赖项进行构建。因此，IMPORTED库将被视为不可变的。</li>
<li>INTERFACE：与IMPORTED库类似。不过，该类型库可变，没有位置信息。它主要用于项目之外的目标构建使用。</li>
<li>ALIAS：顾名思义，这种库为项目中已存在的库目标定义别名。不过，不能为IMPORTED库选择别名。</li>
</ul>
<p>本例中，我们使用add_library直接集合了源代码。后面的章节中，我们将使用target_sources汇集源码，特别是在第7章。</p>
<h3 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h3><p>现在展示OBJECT库的使用，修改CMakeLists.txt，如下：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">03</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span>-objs</span><br><span class="line">    OBJECT</span><br><span class="line">        <span class="keyword">Message</span>.hpp</span><br><span class="line">        <span class="keyword">Message</span>.cpp</span><br><span class="line">    )</span><br><span class="line"><span class="comment"># this is only needed for older compilers</span></span><br><span class="line"><span class="comment"># but doesn&#x27;t hurt either to have it</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="keyword">message</span>-objs</span><br><span class="line">    PROPERTIES</span><br><span class="line">        POSITION_INDEPENDENT_CODE <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span>-shared</span><br><span class="line">    SHARED</span><br><span class="line">        $&lt;TARGET_OBJECTS:<span class="keyword">message</span>-objs&gt;</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span>-static</span><br><span class="line">    STATIC</span><br><span class="line">        $&lt;TARGET_OBJECTS:<span class="keyword">message</span>-objs&gt;</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello-world <span class="keyword">message</span>-static)</span><br></pre></td></tr></table></figure></p>
<p>首先，<code>add_library</code>改为<code>add_library(Message-objs OBJECT Message.hpp Message.cpp)</code>。此外，需要保证编译的目标文件与生成位置无关。可以通过使用<code>set_target_properties</code>命令，设置message-objs目标的相应属性来实现。</p>
<blockquote>
<p>可能在某些平台和/或使用较老的编译器上，需要显式地为目标设置POSITION_INDEPENDENT_CODE属性。</p>
</blockquote>
<p>现在，可以使用这个对象库来获取静态库(message-static)和动态库(message-shared)。要注意引用对象库的生成器表达式语法:<code>$&lt;TARGET_OBJECTS:message-objs&gt;</code>。生成器表达式是CMake在生成时(即配置之后)构造，用于生成特定于配置的构建输出。</p>
<p>是否可以让CMake生成同名的两个库？换句话说，它们都可以被称为message，而不是message-static和message-shared吗？我们需要修改这两个目标的属性：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  SHARED</span><br><span class="line">    $&lt;TARGET_OBJECTS:<span class="keyword">message</span>-objs&gt;</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="keyword">message</span>-shared</span><br><span class="line">    PROPERTIES</span><br><span class="line">        OUTPUT_NAME <span class="string">&quot;message&quot;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span>-static</span><br><span class="line">    STATIC</span><br><span class="line">        $&lt;TARGET_OBJECTS:<span class="keyword">message</span>-objs&gt;</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="keyword">message</span>-static</span><br><span class="line">    PROPERTIES</span><br><span class="line">        OUTPUT_NAME <span class="string">&quot;message&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p>
<p>我们可以链接到DSO吗？这取决于操作系统和编译器：</p>
<ul>
<li>GNU/Linux和macOS上，不管选择什么编译器，它都可以工作。</li>
<li>Windows上，不能与Visual Studio兼容，但可以与MinGW和MSYS2兼容。</li>
</ul>
<h2 id="用条件句控制编译"><a href="#用条件句控制编译" class="headerlink" title="用条件句控制编译"></a>用条件句控制编译</h2><p>目前为止，看到的示例比较简单，CMake执行流是线性的：从一组源文件到单个可执行文件，也可以生成静态库或动态库。为了确保完全控制构建项目、配置、编译和链接所涉及的所有步骤的执行流，CMake提供了自己的语言。本节中，我们将探索条件结构if-else- else-endif的使用。</p>
<h3 id="具体实施-3"><a href="#具体实施-3" class="headerlink" title="具体实施"></a>具体实施</h3><p>从与上一个示例的的源代码开始，我们希望能够在不同的两种行为之间进行切换：</p>
<ul>
<li>将Message.hpp和Message.cpp构建成一个库(静态或动态)，然后将生成库链接到hello-world可执行文件中。</li>
<li>将Message.hpp，Message.cpp和hello-world.cpp构建成一个可执行文件，但不生成任何一个库。<br>让我们来看看如何使用CMakeLists.txt来实现：</li>
</ul>
<p>首先，定义最低CMake版本、项目名称和支持的语言：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">04</span> LANGUAGES CXX)</span><br></pre></td></tr></table></figure></p>
<p>我们引入了一个新变量<code>USE_LIBRARY</code>，这是一个逻辑变量，值为OFF。我们还打印了它的值：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(USE_LIBRARY <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Compile sources into a library? $&#123;USE_LIBRARY&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>CMake中定义<code>BUILD_SHARED_LIBS</code>全局变量，并设置为OFF。调用<code>add_library</code>并省略第二个参数，将构建一个静态库：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">OFF</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后，引入一个变量<code>_sources</code>，包括Message.hpp和Message.cpp：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND _sources <span class="keyword">Message</span>.hpp <span class="keyword">Message</span>.cpp)</span><br></pre></td></tr></table></figure></p>
<p>然后，引入一个基于USE_LIBRARY值的if-else语句。如果逻辑为真，则Message.hpp和Message.cpp将打包成一个库：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(USE_LIBRARY)</span><br><span class="line">    <span class="comment"># add_library will create a static library</span></span><br><span class="line">    <span class="comment"># since BUILD_SHARED_LIBS is OFF</span></span><br><span class="line">    <span class="keyword">add_library</span>(<span class="keyword">message</span> <span class="variable">$&#123;_sources&#125;</span>)</span><br><span class="line">    <span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(hello-world <span class="keyword">message</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">add_executable</span>(hello-world hello-world.cpp <span class="variable">$&#123;_sources&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>我们可以再次使用相同的命令集进行构建。由于USE_LIBRARY为OFF, hello-world可执行文件将使用所有源文件来编译。可以通过在GNU/Linux上，运行objdump -x命令进行验证。</p>
<h3 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h3><p>我们介绍了两个变量：USE_LIBRARY和BUILD_SHARED_LIBS。这两个变量都设置为OFF。如CMake语言文档中描述，逻辑真或假可以用多种方式表示：</p>
<ul>
<li>如果将逻辑变量设置为以下任意一种：1、ON、YES、true、Y或非零数，则逻辑变量为true。</li>
<li>如果将逻辑变量设置为以下任意一种：0、OFF、NO、false、N、IGNORE、NOTFOUND、空字符串，或者以-NOTFOUND为后缀，则逻辑变量为false。</li>
</ul>
<p><code>USE_LIBRARY</code>变量将在第一个和第二个行为之间切换。<code>BUILD_SHARED_LIBS</code>是CMake的一个全局标志。因为CMake内部要查询<code>BUILD_SHARED_LIBS</code>全局变量，所以<code>add_library</code>命令可以在不传递STATIC/SHARED/OBJECT参数的情况下调用；如果为false或未定义，将生成一个静态库。</p>
<p>这个例子说明，可以引入条件来控制CMake中的执行流。但是，当前的设置不允许从外部切换，不需要手动修改CMakeLists.txt。原则上，我们希望能够向用户开放所有设置，这样就可以在不修改构建代码的情况下调整配置，稍后将展示如何做到这一点。</p>
<blockquote>
<p>else()和endif()中的()，可能会让刚开始学习CMake代码的同学感到惊讶。其历史原因是，因为其能够指出指令的作用范围。例如，可以使用if(USE_LIBRARY)…else(USE_LIBRARY)…endif(USE_LIBIRAY)。这个格式并不唯一，可以根据个人喜好来决定使用哪种格式。</p>
</blockquote>
<p>TIPS:_sources变量是一个局部变量，不应该在当前范围之外使用，可以在名称前加下划线。</p>
<h2 id="向用户显示选项"><a href="#向用户显示选项" class="headerlink" title="向用户显示选项"></a>向用户显示选项</h2><p>前面的配置中，我们引入了条件句：通过硬编码的方式给定逻辑变量值。不过，这会影响用户修改这些变量。CMake代码没有向读者传达，该值可以从外部进行修改。推荐在CMakeLists.txt中使用option()命令，以选项的形式显示逻辑开关，用于外部设置，从而切换构建系统的生成行为。本节的示例将向您展示，如何使用这个命令。</p>
<h3 id="具体实施-4"><a href="#具体实施-4" class="headerlink" title="具体实施"></a>具体实施</h3><p>看一下前面示例中的静态/动态库示例。与其硬编码USE_LIBRARY为ON或OFF，现在为其设置一个默认值，同时也可以从外部进行更改：</p>
<p>用一个选项替换上一个示例的set(USE_LIBRARY OFF)命令。该选项将修改USE_LIBRARY的值，并设置其默认值为OFF：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span>(USE_LIBRARY <span class="string">&quot;Compile sources into a library&quot;</span> <span class="keyword">OFF</span>)</span><br></pre></td></tr></table></figure></p>
<p>现在，可以通过CMake的-DCLI选项，将信息传递给CMake来切换库的行为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -D USE_LIBRARY=ON ..</span></span><br><span class="line">-- ...</span><br><span class="line">-- Compile sources into a library? ON</span><br><span class="line">-- ...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --build .</span></span><br><span class="line">Scanning dependencies of target message</span><br><span class="line">[ 25%] Building CXX object CMakeFiles/message.dir/Message.cpp.o</span><br><span class="line">[ 50%] Linking CXX static library libmessage.a</span><br><span class="line">[ 50%] Built target message</span><br><span class="line">Scanning dependencies of target hello-world</span><br><span class="line">[ 75%] Building CXX object CMakeFiles/hello-world.dir/hello-world.cpp.o</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Linking CXX executable hello-world</span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target hello-world</span></span><br></pre></td></tr></table></figure></p>
<p>-D开关用于为CMake设置任何类型的变量：逻辑变量、路径等等。</p>
<h3 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span>(&lt;option_variable&gt; <span class="string">&quot;help string&quot;</span> [initial value])</span><br></pre></td></tr></table></figure>
<p>option可接受三个参数：</p>
<ul>
<li><code>&lt;option_variable&gt;</code>表示该选项的变量的名称。</li>
<li>“help string”记录选项的字符串，在CMake的终端或图形用户界面中可见。</li>
<li>[initial value]选项的默认值，可以是ON或OFF。</li>
</ul>
<h3 id="更多信息-1"><a href="#更多信息-1" class="headerlink" title="更多信息"></a>更多信息</h3><p>有时选项之间会有依赖的情况。示例中，我们提供生成静态库或动态库的选项。但是，如果没有将USE_LIBRARY逻辑设置为ON，则此选项没有任何意义。CMake提供cmake_dependent_option()命令用来定义依赖于其他选项的选项：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CMakeDependentOption)</span><br><span class="line"><span class="comment"># second option depends on the value of the first</span></span><br><span class="line">cmake_dependent_option(</span><br><span class="line">    MAKE_STATIC_LIBRARY <span class="string">&quot;Compile sources into a static library&quot;</span> <span class="keyword">OFF</span></span><br><span class="line">    <span class="string">&quot;USE_LIBRARY&quot;</span> <span class="keyword">ON</span></span><br><span class="line">    )</span><br><span class="line"><span class="comment"># third option depends on the value of the first</span></span><br><span class="line">cmake_dependent_option(</span><br><span class="line">    MAKE_SHARED_LIBRARY <span class="string">&quot;Compile sources into a shared library&quot;</span> <span class="keyword">ON</span></span><br><span class="line">    <span class="string">&quot;USE_LIBRARY&quot;</span> <span class="keyword">ON</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p>
<p>如果<code>USE_LIBRARY</code>为ON，<code>MAKE_STATIC_LIBRARY</code>默认值为OFF，否则<code>MAKE_SHARED_LIBRARY</code>默认值为ON。可以这样运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -D USE_LIBRARY=OFF -D MAKE_SHARED_LIBRARY=ON ..</span></span><br></pre></td></tr></table></figure></p>
<p>这仍然不会构建库，因为USE_LIBRARY仍然为OFF。</p>
<p>CMake有适当的机制，通过包含模块来扩展其语法和功能，这些模块要么是CMake自带的，要么是定制的。本例中，包含了一个名为CMakeDependentOption的模块。如果没有include这个模块，cmake_dependent_option()命令将不可用。</p>
<blockquote>
<p>手册中的任何模块都可以以命令行的方式使用<code>cmake --help-module &lt;name-of-module&gt;</code>。例如，<code>cmake --help-module CMakeDependentOption</code>将打印刚才讨论的模块的手册页(帮助页面)。</p>
</blockquote>
<h2 id="指定编译器"><a href="#指定编译器" class="headerlink" title="指定编译器"></a>指定编译器</h2><p>目前为止，我们还没有过多考虑如何选择编译器。CMake可以根据平台和生成器选择编译器，还能将编译器标志设置为默认值。然而，我们通常控制编译器的选择。在后面的示例中，我们还将考虑构建类型的选择，并展示如何控制编译器标志。</p>
<h3 id="具体实施-5"><a href="#具体实施-5" class="headerlink" title="具体实施"></a>具体实施</h3><p>如何选择一个特定的编译器？例如，如果想使用Intel或Portland Group编译器怎么办？CMake将语言的编译器存储在<code>CMAKE_&lt;LANG&gt;_COMPILER</code>变量中，其中<code>&lt;LANG&gt;</code>是受支持的任何一种语言，对于我们的目的是CXX、C或Fortran。用户可以通过以下两种方式之一设置此变量：</p>
<p>使用CLI中的-D选项，例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -D CMAKE_CXX_COMPILER=clang++ ..</span></span><br></pre></td></tr></table></figure></p>
<p>通过导出环境变量CXX(C++编译器)、CC(C编译器)和FC(Fortran编译器)。例如，使用这个命令使用clang++作为C++编译器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">env</span> CXX=clang++ cmake ..</span><br></pre></td></tr></table></figure></p>
<p>到目前为止讨论的示例，都可以通过传递适当的选项，配置合适的编译器。</p>
<blockquote>
<p>CMake了解运行环境，可以通过其CLI的-D开关或环境变量设置许多选项。前一种机制覆盖后一种机制，但是我们建议使用-D显式设置选项。显式优于隐式，因为环境变量可能被设置为不适合(当前项目)的值。</p>
</blockquote>
<p>我们在这里假设，其他编译器在标准路径中可用，CMake在标准路径中执行查找编译器。如果不是这样，用户将需要将完整的编译器可执行文件或包装器路径传递给CMake。</p>
<blockquote>
<p>我们建议使用<code>-D CMAKE_&lt;LANG&gt;_COMPILERCLI</code>选项设置编译器，而不是导出CXX、CC和FC。这是确保跨平台并与非POSIX兼容的唯一方法。为了避免变量污染环境，这些变量可能会影响与项目一起构建的外部库环境。</p>
</blockquote>
<h3 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a>工作原理</h3><p>配置时，CMake会进行一系列平台测试，以确定哪些编译器可用，以及它们是否适合当前的项目。一个合适的编译器不仅取决于我们所使用的平台，还取决于我们想要使用的生成器。CMake执行的第一个测试基于项目语言的编译器的名称。例如，cc是一个工作的C编译器，那么它将用作C项目的默认编译器。GNU/Linux上，使用Unix Makefile或Ninja时, GCC家族中的编译器很可能是C++、C和Fortran的默认选择。Microsoft Windows上，将选择Visual Studio中的C++和C编译器(前提是Visual Studio是生成器)。如果选择MinGW或MSYS Makefile作为生成器，则默认使用MinGW编译器。</p>
<h3 id="更多信息-2"><a href="#更多信息-2" class="headerlink" title="更多信息"></a>更多信息</h3><p>我们的平台上的CMake，在哪里可以找到可用的编译器和编译器标志？CMake提供—system-information标志，它将把关于系统的所有信息转储到屏幕或文件中。要查看这个信息，请尝试以下操作：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --system-information information.txt</span></span><br></pre></td></tr></table></figure></p>
<p>文件中(本例中是information.txt)可以看到CMAKE_CXX_COMPILER、CMAKE_C_COMPILER和CMAKE_Fortran_COMPILER的默认值，以及默认标志。我们将在下一个示例中看到相关的标志。</p>
<p>CMake提供了额外的变量来与编译器交互：</p>
<ul>
<li><code>CMAKE_&lt;LANG&gt;_COMPILER_LOADED</code>:如果为项目启用了语言<code>&lt;LANG&gt;</code>，则将设置为TRUE。</li>
<li><code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>:编译器标识字符串，编译器供应商所特有。例如，GCC用于GNU编译器集合，AppleClang用于macOS上的Clang, MSVC用于Microsoft Visual Studio编译器。注意，不能保证为所有编译器或语言定义此变量。</li>
<li><code>CMAKE_COMPILER_IS_GNU&lt;LANG&gt;</code>:如果语言<code>&lt;LANG&gt;</code>是GNU编译器集合的一部分，则将此逻辑变量设置为TRUE。注意变量名的<code>&lt;LANG&gt;</code>部分遵循GNU约定：C语言为CC, C++语言为CXX, Fortran语言为G77。</li>
<li><code>CMAKE_&lt;LANG&gt;_COMPILER_VERSION</code>:此变量包含一个字符串，该字符串给定语言的编译器版本。版本信息在major[.minor[.patch[.tweak]]]中给出。但是，对于<code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>，不能保证所有编译器或语言都定义了此变量。</li>
</ul>
<p>我们可以尝试使用不同的编译器，配置下面的示例CMakeLists.txt。这个例子中，我们将使用CMake变量来探索已使用的编译器(及版本)：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">06</span> LANGUAGES C CXX)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Is the C++ compiler loaded? $&#123;CMAKE_CXX_COMPILER_LOADED&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_LOADED)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;The C++ compiler ID is: $&#123;CMAKE_CXX_COMPILER_ID&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Is the C++ from GNU? $&#123;CMAKE_COMPILER_IS_GNUCXX&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;The C++ compiler version is: $&#123;CMAKE_CXX_COMPILER_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Is the C compiler loaded? $&#123;CMAKE_C_COMPILER_LOADED&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(CMAKE_C_COMPILER_LOADED)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;The C compiler ID is: $&#123;CMAKE_C_COMPILER_ID&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Is the C from GNU? $&#123;CMAKE_COMPILER_IS_GNUCC&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;The C compiler version is: $&#123;CMAKE_C_COMPILER_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>注意，这个例子不包含任何目标，没有要构建的东西，我们只关注配置步骤:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">...</span><br><span class="line">-- Is the C++ compiler loaded? 1</span><br><span class="line">-- The C++ compiler ID is: GNU</span><br><span class="line">-- Is the C++ from GNU? 1</span><br><span class="line">-- The C++ compiler version is: 8.1.0</span><br><span class="line">-- Is the C compiler loaded? 1</span><br><span class="line">-- The C compiler ID is: GNU</span><br><span class="line">-- Is the C from GNU? 1</span><br><span class="line">-- The C compiler version is: 8.1.0</span><br></pre></td></tr></table></figure></p>
<p>当然，输出将取决于可用和已选择的编译器(及版本)。</p>
<h2 id="切换构建类型"><a href="#切换构建类型" class="headerlink" title="切换构建类型"></a>切换构建类型</h2><p>CMake可以配置构建类型，例如：Debug、Release等。配置时，可以为Debug或Release构建设置相关的选项或属性，例如：编译器和链接器标志。控制生成构建系统使用的配置变量是<code>CMAKE_BUILD_TYPE</code>。该变量默认为空，CMake识别的值为:</p>
<ul>
<li>Debug：用于在没有优化的情况下，使用带有调试符号构建库或可执行文件。</li>
<li>Release：用于构建的优化的库或可执行文件，不包含调试符号。</li>
<li>RelWithDebInfo：用于构建较少的优化库或可执行文件，包含调试符号。</li>
<li>MinSizeRel：用于不增加目标代码大小的优化方式，来构建库或可执行文件。</li>
</ul>
<h3 id="具体实施-6"><a href="#具体实施-6" class="headerlink" title="具体实施"></a>具体实施</h3><p>示例中，我们将展示如何为项目设置构建类型：</p>
<p>首先，定义最低CMake版本、项目名称和支持的语言：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">07</span> LANGUAGES C CXX)</span><br></pre></td></tr></table></figure></p>
<p>然后，设置一个默认的构建类型(本例中是Release)，并打印一条消息。要注意的是，该变量被设置为缓存变量，可以通过缓存进行编辑：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_BUILD_TYPE Release CACHE <span class="keyword">STRING</span> <span class="string">&quot;Build type&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Build type: $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>最后，打印出CMake设置的相应编译标志：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;C flags, Debug configuration: $&#123;CMAKE_C_FLAGS_DEBUG&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;C flags, Release configuration: $&#123;CMAKE_C_FLAGS_RELEASE&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;C flags, Release configuration with Debug info: $&#123;CMAKE_C_FLAGS_RELWITHDEBINFO&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;C flags, minimal Release configuration: $&#123;CMAKE_C_FLAGS_MINSIZEREL&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;C++ flags, Debug configuration: $&#123;CMAKE_CXX_FLAGS_DEBUG&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;C++ flags, Release configuration: $&#123;CMAKE_CXX_FLAGS_RELEASE&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;C++ flags, Release configuration with Debug info: $&#123;CMAKE_CXX_FLAGS_RELWITHDEBINFO&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;C++ flags, minimal Release configuration: $&#123;CMAKE_CXX_FLAGS_MINSIZEREL&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>验证配置的输出:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">...</span><br><span class="line">-- Build <span class="built_in">type</span>: Release</span><br><span class="line">-- C flags, Debug configuration: -g</span><br><span class="line">-- C flags, Release configuration: -O3 -DNDEBUG</span><br><span class="line">-- C flags, Release configuration with Debug info: -O2 -g -DNDEBUG</span><br><span class="line">-- C flags, minimal Release configuration: -Os -DNDEBUG</span><br><span class="line">-- C++ flags, Debug configuration: -g</span><br><span class="line">-- C++ flags, Release configuration: -O3 -DNDEBUG</span><br><span class="line">-- C++ flags, Release configuration with Debug info: -O2 -g -DNDEBUG</span><br><span class="line">-- C++ flags, minimal Release configuration: -Os -DNDEBUG</span><br></pre></td></tr></table></figure></p>
<p>切换构建类型:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -D CMAKE_BUILD_TYPE=Debug ..</span><br><span class="line">-- Build <span class="built_in">type</span>: Debug</span><br><span class="line">-- C flags, Debug configuration: -g</span><br><span class="line">-- C flags, Release configuration: -O3 -DNDEBUG</span><br><span class="line">-- C flags, Release configuration with Debug info: -O2 -g -DNDEBUG</span><br><span class="line">-- C flags, minimal Release configuration: -Os -DNDEBUG</span><br><span class="line">-- C++ flags, Debug configuration: -g</span><br><span class="line">-- C++ flags, Release configuration: -O3 -DNDEBUG</span><br><span class="line">-- C++ flags, Release configuration with Debug info: -O2 -g -DNDEBUG</span><br><span class="line">-- C++ flags, minimal Release configuration: -Os -DNDEBUG</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-5"><a href="#工作原理-5" class="headerlink" title="工作原理"></a>工作原理</h3><p>我们演示了如何设置默认构建类型，以及如何(从命令行)覆盖它。这样，就可以控制项目，是使用优化，还是关闭优化启用调试。我们还看到了不同配置使用了哪些标志，这主要取决于选择的编译器。需要在运行CMake时显式地打印标志，也可以仔细阅读运行CMake —system-information的输出，以了解当前平台、默认编译器和语言的默认组合是什么。下一个示例中，我们将讨论如何为不同的编译器和不同的构建类型，扩展或调整编译器标志。</p>
<h2 id="设置编译器选项"><a href="#设置编译器选项" class="headerlink" title="设置编译器选项"></a>设置编译器选项</h2><p>前面的示例展示了如何探测CMake，从而获得关于编译器的信息，以及如何切换项目中的编译器。后一个任务是控制项目的编译器标志。CMake为调整或扩展编译器标志提供了很大的灵活性，您可以选择下面两种方法:</p>
<ul>
<li>CMake将编译选项视为目标属性。因此，可以根据每个目标设置编译选项，而不需要覆盖CMake默认值。</li>
<li>可以使用-DCLI标志直接修改<code>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</code>变量。这将影响项目中的所有目标，并覆盖或扩展CMake默认值。</li>
</ul>
<p>本示例中，我们将展示这两种方法。</p>
<h3 id="准备工作-3"><a href="#准备工作-3" class="headerlink" title="准备工作"></a>准备工作</h3><p>编写一个示例程序，计算不同几何形状的面积，computer_area.cpp：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_circle.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_polygon.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_rhombus.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry_square.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> geometry;</span><br><span class="line">  <span class="type">double</span> radius = <span class="number">2.5293</span>;</span><br><span class="line">  <span class="type">double</span> A_circle = area::<span class="built_in">circle</span>(radius);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;A circle of radius &quot;</span> &lt;&lt; radius &lt;&lt; <span class="string">&quot; has an area of &quot;</span> &lt;&lt; A_circle</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">int</span> nSides = <span class="number">19</span>;</span><br><span class="line">  <span class="type">double</span> side = <span class="number">1.29312</span>;</span><br><span class="line">  <span class="type">double</span> A_polygon = area::<span class="built_in">polygon</span>(nSides, side);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;A regular polygon of &quot;</span> &lt;&lt; nSides &lt;&lt; <span class="string">&quot; sides of length &quot;</span> &lt;&lt; side</span><br><span class="line">            &lt;&lt; <span class="string">&quot; has an area of &quot;</span> &lt;&lt; A_polygon &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">double</span> d1 = <span class="number">5.0</span>;</span><br><span class="line">  <span class="type">double</span> d2 = <span class="number">7.8912</span>;</span><br><span class="line">  <span class="type">double</span> A_rhombus = area::<span class="built_in">rhombus</span>(d1, d2);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;A rhombus of major diagonal &quot;</span> &lt;&lt; d1 &lt;&lt; <span class="string">&quot; and minor diagonal &quot;</span> &lt;&lt; d2</span><br><span class="line">            &lt;&lt; <span class="string">&quot; has an area of &quot;</span> &lt;&lt; A_rhombus &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">double</span> l = <span class="number">10.0</span>;</span><br><span class="line">  <span class="type">double</span> A_square = area::<span class="built_in">square</span>(l);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;A square of side &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; has an area of &quot;</span> &lt;&lt; A_square</span><br><span class="line">  &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数的各种实现分布在不同的文件中，每个几何形状都有一个头文件和源文件。总共有4个头文件和5个源文件要编译：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├─ CMakeLists.txt</span><br><span class="line">├─ compute-areas.cpp</span><br><span class="line">├─ geometry_circle.cpp</span><br><span class="line">├─ geometry_circle.hpp</span><br><span class="line">├─ geometry_polygon.cpp</span><br><span class="line">├─ geometry_polygon.hpp</span><br><span class="line">├─ geometry_rhombus.cpp</span><br><span class="line">├─ geometry_rhombus.hpp</span><br><span class="line">├─ geometry_square.cpp</span><br><span class="line">└─ geometry_square.hpp</span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-7"><a href="#具体实施-7" class="headerlink" title="具体实施"></a>具体实施</h3><p>现在已经有了源代码，我们的目标是配置项目，并使用编译器标示进行实验:</p>
<p>设置CMake的最低版本:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br></pre></td></tr></table></figure></p>
<p>声明项目名称和语言:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(recipe-<span class="number">08</span> LANGUAGES CXX)</span><br></pre></td></tr></table></figure></p>
<p>然后，打印当前编译器标志。CMake将对所有C++目标使用这些:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;C++ compiler flags: $&#123;CMAKE_CXX_FLAGS&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>为目标准备了标志列表，其中一些将无法在Windows上使用:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND flags <span class="string">&quot;-fPIC&quot;</span> <span class="string">&quot;-Wall&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> WIN32)</span><br><span class="line">  <span class="keyword">list</span>(APPEND flags <span class="string">&quot;-Wextra&quot;</span> <span class="string">&quot;-Wpedantic&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>添加了一个新的目标——geometry库，并列出它的源依赖关系:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(geometry</span><br><span class="line">  STATIC</span><br><span class="line">    geometry_circle.cpp</span><br><span class="line">    geometry_circle.hpp</span><br><span class="line">    geometry_polygon.cpp</span><br><span class="line">    geometry_polygon.hpp</span><br><span class="line">    geometry_rhombus.cpp</span><br><span class="line">    geometry_rhombus.hpp</span><br><span class="line">    geometry_square.cpp</span><br><span class="line">    geometry_square.hpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>为这个库目标设置了编译选项:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(geometry</span><br><span class="line">  PRIVATE</span><br><span class="line">    <span class="variable">$&#123;flags&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>然后，将生成compute-areas可执行文件作为一个目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(compute-areas compute-areas.cpp)</span><br></pre></td></tr></table></figure></p>
<p>还为可执行目标设置了编译选项:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(compute-areas</span><br><span class="line">  PRIVATE</span><br><span class="line">    <span class="string">&quot;-fPIC&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，将可执行文件链接到geometry库:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(compute-areas geometry)</span><br></pre></td></tr></table></figure></p>
<h3 id="如何工作-1"><a href="#如何工作-1" class="headerlink" title="如何工作"></a>如何工作</h3><p>本例中，警告标志有-Wall、-Wextra和-Wpedantic，将这些标示添加到geometry目标的编译选项中； compute-areas和 geometry目标都将使用-fPIC标志。编译选项可以添加三个级别的可见性：INTERFACE、PUBLIC和PRIVATE。</p>
<p>可见性的含义如下:</p>
<ul>
<li>PRIVATE，编译选项会应用于给定的目标，不会传递给与目标相关的目标。我们的示例中， 即使compute-areas将链接到geometry库，compute-areas也不会继承geometry目标上设置的编译器选项。</li>
<li>INTERFACE，给定的编译选项将只应用于指定目标，并传递给与目标相关的目标。</li>
<li>PUBLIC，编译选项将应用于指定目标和使用它的目标。</li>
</ul>
<p>目标属性的可见性CMake的核心，我们将在本书中经常讨论这个话题。以这种方式添加编译选项，不会影响全局CMake变量<code>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</code>，并能更细粒度控制在哪些目标上使用哪些选项。</p>
<p>我们如何验证，这些标志是否按照我们的意图正确使用呢？或者换句话说，如何确定项目在CMake构建时，实际使用了哪些编译标志？一种方法是，使用CMake将额外的参数传递给本地构建工具。本例中会设置环境变量VERBOSE=1：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build . -- VERBOSE=1</span><br><span class="line">... lots of output ...</span><br><span class="line">[ 14%] Building CXX object CMakeFiles/geometry.dir/geometry_circle.cpp.o</span><br><span class="line">/usr/bin/c++ -fPIC -Wall -Wextra -Wpedantic -o CMakeFiles/geometry.dir/geometry_circle.cpp.o -c /home/bast/tmp/cmake-cookbook/chapter-01/recipe-08/cxx-example/geometry_circle.cpp</span><br><span class="line">[ 28%] Building CXX object CMakeFiles/geometry.dir/geometry_polygon.cpp.o</span><br><span class="line">/usr/bin/c++ -fPIC -Wall -Wextra -Wpedantic -o CMakeFiles/geometry.dir/geometry_polygon.cpp.o -c /home/bast/tmp/cmake-cookbook/chapter-01/recipe-08/cxx-example/geometry_polygon.cpp</span><br><span class="line">[ 42%] Building CXX object CMakeFiles/geometry.dir/geometry_rhombus.cpp.o</span><br><span class="line">/usr/bin/c++ -fPIC -Wall -Wextra -Wpedantic -o CMakeFiles/geometry.dir/geometry_rhombus.cpp.o -c /home/bast/tmp/cmake-cookbook/chapter-01/recipe-08/cxx-example/geometry_rhombus.cpp</span><br><span class="line">[ 57%] Building CXX object CMakeFiles/geometry.dir/geometry_square.cpp.o</span><br><span class="line">/usr/bin/c++ -fPIC -Wall -Wextra -Wpedantic -o CMakeFiles/geometry.dir/geometry_square.cpp.o -c /home/bast/tmp/cmake-cookbook/chapter-01/recipe-08/cxx-example/geometry_square.cpp</span><br><span class="line">... more output ...</span><br><span class="line">[ 85%] Building CXX object CMakeFiles/compute-areas.dir/compute-areas.cpp.o</span><br><span class="line">/usr/bin/c++ -fPIC -o CMakeFiles/compute-areas.dir/compute-areas.cpp.o -c /home/bast/tmp/cmake-cookbook/chapter-01/recipe-08/cxx-example/compute-areas.cpp</span><br><span class="line">... more output ...</span><br></pre></td></tr></table></figure></p>
<p>输出确认编译标志，确认指令设置正确。</p>
<p>控制编译器标志的第二种方法，不用对CMakeLists.txt进行修改。如果想在这个项目中修改geometry和compute-areas目标的编译器选项，可以使用CMake参数进行配置：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -D CMAKE_CXX_FLAGS=<span class="string">&quot;-fno-exceptions -fno-rtti&quot;</span> ..</span><br></pre></td></tr></table></figure></p>
<p>这个命令将编译项目，禁用异常和运行时类型标识(RTTI)。</p>
<p>也可以使用全局标志，可以使用CMakeLists.txt运行以下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -D CMAKE_CXX_FLAGS=<span class="string">&quot;-fno-exceptions -fno-rtti&quot;</span> ..</span><br></pre></td></tr></table></figure></p>
<p>这将使用-fno-rtti - fpic - wall - Wextra - wpedantic配置geometry目标，同时使用-fno exception -fno-rtti - fpic配置compute-areas。</p>
<h3 id="更多信息-3"><a href="#更多信息-3" class="headerlink" title="更多信息"></a>更多信息</h3><p>大多数时候，编译器有特性标示。当前的例子只适用于GCC和Clang；其他供应商的编译器不确定是否会理解(如果不是全部)这些标志。如果项目是真正跨平台，那么这个问题就必须得到解决，有三种方法可以解决这个问题。</p>
<p>最典型的方法是将所需编译器标志列表附加到每个配置类型CMake变量<code>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</code>。标志确定设置为给定编译器有效的标志，因此将包含在if-endif子句中，用于检查<code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>变量，例如：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> GNU)</span><br><span class="line">  <span class="keyword">list</span>(APPEND CMAKE_CXX_FLAGS <span class="string">&quot;-fno-rtti&quot;</span> <span class="string">&quot;-fno-exceptions&quot;</span>)</span><br><span class="line">  <span class="keyword">list</span>(APPEND CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;-Wsuggest-final-types&quot;</span> <span class="string">&quot;-Wsuggest-final-methods&quot;</span> <span class="string">&quot;-Wsuggest-override&quot;</span>)</span><br><span class="line">  <span class="keyword">list</span>(APPEND CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;-O3&quot;</span> <span class="string">&quot;-Wno-unused&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> Clang)</span><br><span class="line">  <span class="keyword">list</span>(APPEND CMAKE_CXX_FLAGS <span class="string">&quot;-fno-rtti&quot;</span> <span class="string">&quot;-fno-exceptions&quot;</span> <span class="string">&quot;-Qunused-arguments&quot;</span> <span class="string">&quot;-fcolor-diagnostics&quot;</span>)</span><br><span class="line">  <span class="keyword">list</span>(APPEND CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;-Wdocumentation&quot;</span>)</span><br><span class="line">  <span class="keyword">list</span>(APPEND CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;-O3&quot;</span> <span class="string">&quot;-Wno-unused&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>更细粒度的方法是，不修改<code>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</code>变量，而是定义特定的标志列表：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(COMPILER_FLAGS)</span><br><span class="line"><span class="keyword">set</span>(COMPILER_FLAGS_DEBUG)</span><br><span class="line"><span class="keyword">set</span>(COMPILER_FLAGS_RELEASE)</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> GNU)</span><br><span class="line">  <span class="keyword">list</span>(APPEND CXX_FLAGS <span class="string">&quot;-fno-rtti&quot;</span> <span class="string">&quot;-fno-exceptions&quot;</span>)</span><br><span class="line">  <span class="keyword">list</span>(APPEND CXX_FLAGS_DEBUG <span class="string">&quot;-Wsuggest-final-types&quot;</span> <span class="string">&quot;-Wsuggest-final-methods&quot;</span> <span class="string">&quot;-Wsuggest-override&quot;</span>)</span><br><span class="line">  <span class="keyword">list</span>(APPEND CXX_FLAGS_RELEASE <span class="string">&quot;-O3&quot;</span> <span class="string">&quot;-Wno-unused&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> Clang)</span><br><span class="line">  <span class="keyword">list</span>(APPEND CXX_FLAGS <span class="string">&quot;-fno-rtti&quot;</span> <span class="string">&quot;-fno-exceptions&quot;</span> <span class="string">&quot;-Qunused-arguments&quot;</span> <span class="string">&quot;-fcolor-diagnostics&quot;</span>)</span><br><span class="line">  <span class="keyword">list</span>(APPEND CXX_FLAGS_DEBUG <span class="string">&quot;-Wdocumentation&quot;</span>)</span><br><span class="line">  <span class="keyword">list</span>(APPEND CXX_FLAGS_RELEASE <span class="string">&quot;-O3&quot;</span> <span class="string">&quot;-Wno-unused&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>稍后，使用生成器表达式来设置编译器标志的基础上，为每个配置和每个目标生成构建系统:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target_compile_option(compute-areas</span><br><span class="line">  PRIVATE</span><br><span class="line">    <span class="variable">$&#123;CXX_FLAGS&#125;</span></span><br><span class="line">    <span class="string">&quot;$&lt;$&lt;CONFIG:Debug&gt;:$&#123;CXX_FLAGS_DEBUG&#125;&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;$&lt;$&lt;CONFIG:Release&gt;:$&#123;CXX_FLAGS_RELEASE&#125;&gt;&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>当前示例中展示了这两种方法，我们推荐后者(特定于项目的变量和target_compile_options)。</p>
<p>两种方法都有效，并在许多项目中得到广泛应用。不过，每种方式都有缺点。<code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>不能保证为所有编译器都定义。此外，一些标志可能会被弃用，或者在编译器的较晚版本中引入。与<code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>类似，<code>CMAKE_&lt;LANG&gt;_COMPILER_VERSION</code>变量不能保证为所有语言和供应商都提供定义。尽管检查这些变量的方式非常流行，但我们认为更健壮的替代方法是检查所需的标志集是否与给定的编译器一起工作，这样项目中实际上只使用有效的标志。结合特定于项目的变量、target_compile_options和生成器表达式，会让解决方案变得非常强大。</p>
<h2 id="为语言设定标准"><a href="#为语言设定标准" class="headerlink" title="为语言设定标准"></a>为语言设定标准</h2><p>编程语言有不同的标准，即提供改进的语言版本。启用新标准是通过设置适当的编译器标志来实现的。前面的示例中，我们已经展示了如何为每个目标或全局进行配置。3.1版本中，CMake引入了一个独立于平台和编译器的机制，用于为C++和C设置语言标准：为目标设置<code>&lt;LANG&gt;_STANDARD</code>属性。</p>
<h3 id="准备工作-4"><a href="#准备工作-4" class="headerlink" title="准备工作"></a>准备工作</h3><p>对于下面的示例，需要一个符合C++14标准或更高版本的C++编译器。此示例代码定义了动物的多态，我们使用std::unique_ptr作为结构中的基类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Animal&gt; cat = <span class="built_in">Cat</span>(<span class="string">&quot;Simon&quot;</span>);</span><br><span class="line">std::unique_ptr&lt;Animal&gt; dog = <span class="built_in">Dog</span>(<span class="string">&quot;Marlowe);</span></span><br></pre></td></tr></table></figure></p>
<p>没有为各种子类型显式地使用构造函数，而是使用工厂方法的实现。工厂方法使用C++11的可变参数模板实现。它包含继承层次结构中每个对象的创建函数映射：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::function&lt;std::unique_ptr&lt;Animal&gt;(<span class="type">const</span> std::string &amp;)&gt; CreateAnimal;</span><br></pre></td></tr></table></figure></p>
<p>基于预先分配的标签来分派它们，创建对象:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Animal&gt; simon = farm.<span class="built_in">create</span>(<span class="string">&quot;CAT&quot;</span>, <span class="string">&quot;Simon&quot;</span>);</span><br><span class="line">std::unique_ptr&lt;Animal&gt; marlowe = farm.<span class="built_in">create</span>(<span class="string">&quot;DOG&quot;</span>, <span class="string">&quot;Marlowe&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>标签和创建功能在工厂使用前已注册:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Factory&lt;CreateAnimal&gt; farm;</span><br><span class="line">farm.<span class="built_in">subscribe</span>(<span class="string">&quot;CAT&quot;</span>, [](<span class="type">const</span> std::string &amp; n) &#123; <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Cat&gt;(n); &#125;);</span><br><span class="line">farm.<span class="built_in">subscribe</span>(<span class="string">&quot;DOG&quot;</span>, [](<span class="type">const</span> std::string &amp; n) &#123; <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Dog&gt;(n); &#125;);</span><br></pre></td></tr></table></figure></p>
<p>使用C++11 Lambda函数定义创建函数，使用std::make_unique来避免引入裸指针的操作。这个工厂函数是在C++14中引入。</p>
<h3 id="具体实施-8"><a href="#具体实施-8" class="headerlink" title="具体实施"></a>具体实施</h3><p>将逐步构建CMakeLists.txt，并展示如何设置语言标准(本例中是C++14):</p>
<p>声明最低要求的CMake版本，项目名称和语言:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">09</span> LANGUAGES CXX)</span><br></pre></td></tr></table></figure></p>
<p>要求在Windows上导出所有库符号:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>需要为库添加一个目标，这将编译源代码为一个动态库:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(animals</span><br><span class="line">  SHARED</span><br><span class="line">    Animal.cpp</span><br><span class="line">    Animal.hpp</span><br><span class="line">    Cat.cpp</span><br><span class="line">    Cat.hpp</span><br><span class="line">    Dog.cpp</span><br><span class="line">    Dog.hpp</span><br><span class="line">    Factory.hpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>现在，为目标设置了CXX_STANDARD、CXX_EXTENSIONS和CXX_STANDARD_REQUIRED属性。还设置了position_independent ent_code属性，以避免在使用一些编译器构建DSO时出现问题:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(animals</span><br><span class="line">  PROPERTIES</span><br><span class="line">    CXX_STANDARD <span class="number">14</span></span><br><span class="line">    CXX_EXTENSIONS <span class="keyword">OFF</span></span><br><span class="line">    CXX_STANDARD_REQUIRED <span class="keyword">ON</span></span><br><span class="line">    POSITION_INDEPENDENT_CODE <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>然后，为”动物农场”的可执行文件添加一个新目标，并设置它的属性:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(animal-farm animal-farm.cpp)</span><br><span class="line"><span class="keyword">set_target_properties</span>(animal-farm</span><br><span class="line">  PROPERTIES</span><br><span class="line">    CXX_STANDARD <span class="number">14</span></span><br><span class="line">    CXX_EXTENSIONS <span class="keyword">OFF</span></span><br><span class="line">    CXX_STANDARD_REQUIRED <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，将可执行文件链接到库:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(animal-farm animals)</span><br></pre></td></tr></table></figure></p>
<p>现在，来看看猫和狗都说了什么:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ./animal-farm</span><br><span class="line">I<span class="string">&#x27;m Simon the cat!</span></span><br><span class="line"><span class="string">I&#x27;</span>m Marlowe the dog!</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-6"><a href="#工作原理-6" class="headerlink" title="工作原理"></a>工作原理</h3><p>步骤4和步骤5中，我们为动物和动物农场目标设置了一些属性:</p>
<ul>
<li>CXX_STANDARD会设置我们想要的标准。</li>
<li>CXX_EXTENSIONS告诉CMake，只启用ISO C++标准的编译器标志，而不使用特定编译器的扩展。</li>
<li>CXX_STANDARD_REQUIRED指定所选标准的版本。如果这个版本不可用，CMake将停止配置并出现错误。当这个属性被设置为OFF时，CMake将寻找下一个标准的最新版本，直到一个合适的标志。这意味着，首先查找C++14，然后是C++11，然后是C++98。</li>
</ul>
<blockquote>
<p>如果语言标准是所有目标共享的全局属性，那么可以将<code>CMAKE_&lt;LANG&gt;_STANDARD</code>、<code>CMAKE_&lt;LANG&gt;_EXTENSIONS</code>和<code>CMAKE_&lt;LANG&gt;_STANDARD_REQUIRED</code>变量设置为相应的值。所有目标上的对应属性都将使用这些设置。</p>
</blockquote>
<h3 id="更多信息-4"><a href="#更多信息-4" class="headerlink" title="更多信息"></a>更多信息</h3><p>通过引入编译特性，CMake对语言标准提供了更精细的控制。这些是语言标准引入的特性，比如C++11中的可变参数模板和Lambda表达式，以及C++14中的自动返回类型推断。可以使用target_compile_features()命令要求为特定的目标提供特定的特性，CMake将自动为标准设置正确的编译器标志。也可以让CMake为可选编译器特性，生成兼容头文件。</p>
<h2 id="使用控制流"><a href="#使用控制流" class="headerlink" title="使用控制流"></a>使用控制流</h2><p>本章前面的示例中，已经使用过if-else-endif。CMake还提供了创建循环的语言工具：foreach endforeach和while-endwhile。两者都可以与break结合使用，以便尽早从循环中跳出。本示例将展示如何使用foreach，来循环源文件列表。我们将应用这样的循环，在引入新目标的前提下，来为一组源文件进行优化降级。</p>
<h3 id="准备工作-5"><a href="#准备工作-5" class="headerlink" title="准备工作"></a>准备工作</h3><p>将重用第8节中的几何示例，目标是通过将一些源代码汇集到一个列表中，从而微调编译器的优化。</p>
<h3 id="具体实施-9"><a href="#具体实施-9" class="headerlink" title="具体实施"></a>具体实施</h3><p>下面是CMakeLists.txt中要的详细步骤:</p>
<p>与示例8中一样，指定了CMake的最低版本、项目名称和语言，并声明了几何库目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">10</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">add_library</span>(geometry</span><br><span class="line">  STATIC</span><br><span class="line">    geometry_circle.cpp</span><br><span class="line">    geometry_circle.hpp</span><br><span class="line">    geometry_polygon.cpp</span><br><span class="line">    geometry_polygon.hpp</span><br><span class="line">    geometry_rhombus.cpp</span><br><span class="line">    geometry_rhombus.hpp</span><br><span class="line">    geometry_square.cpp</span><br><span class="line">    geometry_square.hpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>使用-O3编译器优化级别编译库，对目标设置一个私有编译器选项:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(geometry</span><br><span class="line">  PRIVATE</span><br><span class="line">      -O3</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>然后，生成一个源文件列表，以较低的优化选项进行编译:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(</span><br><span class="line">  APPEND sources_with_lower_optimization</span><br><span class="line">    geometry_circle.cpp</span><br><span class="line">    geometry_rhombus.cpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>循环这些源文件，将它们的优化级别调到-O2。使用它们的源文件属性完成:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Setting source properties using IN LISTS syntax:&quot;</span>)</span><br><span class="line"><span class="keyword">foreach</span>(_source IN LISTS sources_with_lower_optimization)</span><br><span class="line">  <span class="keyword">set_source_files_properties</span>(<span class="variable">$&#123;_source&#125;</span> PROPERTIES COMPILE_FLAGS -O2)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Appending -O2 flag for $&#123;_source&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure></p>
<p>为了确保设置属性，再次循环并在打印每个源文件的COMPILE_FLAGS属性:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Querying sources properties using plain syntax:&quot;</span>)</span><br><span class="line"><span class="keyword">foreach</span>(_source <span class="variable">$&#123;sources_with_lower_optimization&#125;</span>)</span><br><span class="line">  <span class="keyword">get_source_file_property</span>(_flags <span class="variable">$&#123;_source&#125;</span> COMPILE_FLAGS)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Source $&#123;_source&#125; has the following extra COMPILE_FLAGS: $&#123;_flags&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure></p>
<p>最后，添加compute-areas可执行目标，并将geometry库连接上去:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(compute-areas compute-areas.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(compute-areas geometry)</span><br></pre></td></tr></table></figure></p>
<p>验证在配置步骤中正确设置了标志:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">...</span><br><span class="line">-- Setting <span class="built_in">source</span> properties using IN LISTS syntax:</span><br><span class="line">-- Appending -O2 flag <span class="keyword">for</span> geometry_circle.cpp</span><br><span class="line">-- Appending -O2 flag <span class="keyword">for</span> geometry_rhombus.cpp</span><br><span class="line">-- Querying sources properties using plain syntax:</span><br><span class="line">-- Source geometry_circle.cpp has the following extra COMPILE_FLAGS: -O2</span><br><span class="line">-- Source geometry_rhombus.cpp has the following extra COMPILE_FLAGS: -O2</span><br></pre></td></tr></table></figure></p>
<p>最后，还使用VERBOSE=1检查构建步骤。将看到-O2标志添加在-O3标志之后，但是最后一个优化级别标志(在本例中是-O2)不同:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build . -- VERBOSE=1</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-7"><a href="#工作原理-7" class="headerlink" title="工作原理"></a>工作原理</h3><p>foreach-endforeach语法可用于在变量列表上，表示重复特定任务。本示例中，使用它来操作、设置和获取项目中特定文件的编译器标志。CMake代码片段中引入了另外两个新命令:</p>
<p><code>set_source_files_properties(file PROPERTIES property value)</code>，它将属性设置为给定文件的传递值。与目标非常相似，文件在CMake中也有属性，允许对构建系统进行非常细粒度的控制。</p>
<p><code>get_source_file_property(VAR file property)</code>，检索给定文件所需属性的值，并将其存储在CMakeVAR变量中。</p>
<blockquote>
<p>CMake中，列表是用分号分隔的字符串组。列表可以由list或set命令创建。例如，set(var a b c d e)和list(APPEND a b c d e)都创建了列表a;b;c;d;e。</p>
<p>为了对一组文件降低优化，将它们收集到一个单独的目标(库)中，并为这个目标显式地设置优化级别，而不是附加一个标志，这样可能会更简洁，不过在本示例中，我们的重点是foreach-endforeach。</p>
</blockquote>
<p>更多信息<br>foreach()的四种使用方式:</p>
<ul>
<li><code>foreach(loop_var arg1 arg2 ...)</code>: 其中提供循环变量和显式项列表。当为sources_with_lower_optimization中的项打印编译器标志集时，使用此表单。注意，如果项目列表位于变量中，则必须显式展开它；也就是说，${sources_with_lower_optimization}必须作为参数传递。</li>
<li>通过指定一个范围，可以对整数进行循环，例如：<code>foreach(loop_var range total)</code>或<code>foreach(loop_var range start stop [step])</code>。</li>
<li>对列表值变量的循环，例如：<code>foreach(loop_var IN LISTS [list1[...]])</code>。参数解释为列表，其内容就会自动展开。</li>
<li>对变量的循环，例如：<code>foreach(loop_var IN ITEMS [item1 [...]])</code>。参数的内容没有展开。</li>
</ul>
<h1 id="检测环境"><a href="#检测环境" class="headerlink" title="检测环境"></a>检测环境</h1><h2 id="检测操作系统"><a href="#检测操作系统" class="headerlink" title="检测操作系统"></a>检测操作系统</h2><p>CMake是一组跨平台工具。不过，了解操作系统(OS)上执行配置或构建步骤也很重要。从而与操作系统相关的CMake代码，会根据操作系统启用条件编译，或者在可用或必要时使用特定于编译器的扩展。</p>
<h3 id="具体实施-10"><a href="#具体实施-10" class="headerlink" title="具体实施"></a>具体实施</h3><p>我们将用一个非常简单的CMakeLists.txt进行演示:</p>
<p>首先，定义CMake最低版本和项目名称。请注意，语言是NONE:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span> LANGUAGES NONE)</span><br></pre></td></tr></table></figure></p>
<p>然后，根据检测到的操作系统信息打印消息:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Configuring on/for Linux&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Darwin&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Configuring on/for macOS&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Configuring on/for Windows&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;AIX&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Configuring on/for IBM AIX&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Configuring on/for $&#123;CMAKE_SYSTEM_NAME&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>测试之前，检查前面的代码块，并考虑相应系统上的具体行为。</p>
<p>现在，测试配置项目:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br></pre></td></tr></table></figure></p>
<p>关于CMake输出，这里有一行很有趣——在Linux系统上(在其他系统上，输出会不同):<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- Configuring on/for Linux</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-8"><a href="#工作原理-8" class="headerlink" title="工作原理"></a>工作原理</h3><p>CMake为目标操作系统定义了CMAKE_SYSTEM_NAME，因此不需要使用定制命令、工具或脚本来查询此信息。然后，可以使用此变量的值实现特定于操作系统的条件和解决方案。在具有uname命令的系统上，将此变量设置为uname -s的输出。该变量在macOS上设置为“Darwin”。在Linux和Windows上，它分别计算为“Linux”和“Windows”。</p>
<h2 id="处理与平台相关的源代码"><a href="#处理与平台相关的源代码" class="headerlink" title="处理与平台相关的源代码"></a>处理与平台相关的源代码</h2><p>理想情况下，应该避免依赖于平台的源代码，但是有时我们没有选择，特别是当要求配置和编译不是自己编写的代码时。本示例中，将演示如何使用CMake根据操作系统编译源代码。</p>
<h3 id="准备工作-6"><a href="#准备工作-6" class="headerlink" title="准备工作"></a>准备工作</h3><p>修改hello-world.cpp示例代码，将第1章第1节的例子进行修改:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function">std::string <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IS_WINDOWS</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from Windows!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> IS_LINUX</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from Linux!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> IS_MACOS</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from macOS!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from an unknown system!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">say_hello</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-11"><a href="#具体实施-11" class="headerlink" title="具体实施"></a>具体实施</h3><p>完成一个CMakeLists.txt实例，使我们能够基于目标操作系统有条件地编译源代码：</p>
<p>首先，设置了CMake最低版本、项目名称和支持的语言:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">02</span> LANGUAGES CXX)</span><br></pre></td></tr></table></figure></p>
<p>然后，定义可执行文件及其对应的源文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br></pre></td></tr></table></figure></p>
<p>通过定义以下目标编译定义，让预处理器知道系统名称:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_LINUX&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Darwin&quot;</span>)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_MACOS&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_WINDOWS&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>继续之前，先检查前面的表达式，并考虑在不同系统上有哪些行为。</p>
<p>现在，准备测试它，并配置项目:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ./hello-world</span><br><span class="line">Hello from Linux!</span><br></pre></td></tr></table></figure></p>
<p>Windows系统上，将看到来自Windows的Hello。其他操作系统将产生不同的输出。</p>
<h3 id="工作原理-9"><a href="#工作原理-9" class="headerlink" title="工作原理"></a>工作原理</h3><p>hello-world.cpp示例中，有趣的部分是基于预处理器定义IS_WINDOWS、IS_LINUX或IS_MACOS的条件编译:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IS_WINDOWS</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from Windows!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> IS_LINUX</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from Linux!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> IS_MACOS</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from macOS!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello from an unknown system!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些定义在CMakeLists.txt中配置时定义，通过使用<code>target_compile_definition</code>在预处理阶段使用。可以不重复if-endif语句，以更紧凑的表达式实现，我们将在下一个示例中演示这种重构方式。也可以把if-endif语句加入到一个if-else-else-endif语句中。这个阶段，可以使用add_definitions(-DIS_LINUX)来设置定义(当然，可以根据平台调整定义)，而不是使用target_compile_definition。使用add_definitions的缺点是，会修改编译整个项目的定义，而<code>target_compile_definitions</code>给我们机会，将定义限制于一个特定的目标，以及通过PRIVATE|PUBLIC|INTERFACE限定符，限制这些定义可见性。</p>
<ul>
<li>PRIVATE，编译定义将只应用于给定的目标，而不应用于相关的其他目标。</li>
<li>INTERFACE，对给定目标的编译定义将只应用于使用它的目标。</li>
<li>PUBLIC，编译定义将应用于给定的目标和使用它的所有其他目标。</li>
</ul>
<h2 id="处理与编译器相关的源代码"><a href="#处理与编译器相关的源代码" class="headerlink" title="处理与编译器相关的源代码"></a>处理与编译器相关的源代码</h2><p>这个方法与前面的方法类似，我们将使用CMake来编译依赖于环境的条件源代码：本例将依赖于编译器。为了可移植性，我们尽量避免去编写新代码，但遇到有依赖的情况我们也要去解决，特别是当使用历史代码或处理编译器依赖工具，如sanitizers。</p>
<h3 id="准备工作-7"><a href="#准备工作-7" class="headerlink" title="准备工作"></a>准备工作</h3><p>本示例中，我们将从C++中的一个示例开始，稍后我们将演示一个Fortran示例，并尝试重构和简化CMake代码。</p>
<p>看一下hello-world.cpp源代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function">std::string <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IS_INTEL_CXX_COMPILER</span></span><br><span class="line">  <span class="comment">// only compiled when Intel compiler is selected</span></span><br><span class="line">  <span class="comment">// such compiler will not compile the other branches</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello Intel compiler!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> IS_GNU_CXX_COMPILER</span></span><br><span class="line">  <span class="comment">// only compiled when GNU compiler is selected</span></span><br><span class="line">  <span class="comment">// such compiler will not compile the other branches</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello GNU compiler!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> IS_PGI_CXX_COMPILER</span></span><br><span class="line">  <span class="comment">// etc.</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello PGI compiler!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> IS_XL_CXX_COMPILER</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello XL compiler!&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello unknown compiler - have we met before?&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">say_hello</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;compiler name is &quot;</span> COMPILER_NAME &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Fortran示例(hello-world.F90):<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> hello</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">#ifdef IS_Intel_FORTRAN_COMPILER</span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">&#x27;Hello Intel compiler!&#x27;</span></span><br><span class="line">#elif IS_GNU_FORTRAN_COMPILER</span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">&#x27;Hello GNU compiler!&#x27;</span></span><br><span class="line">#elif IS_PGI_FORTRAN_COMPILER</span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">&#x27;Hello PGI compiler!&#x27;</span></span><br><span class="line">#elif IS_XL_FORTRAN_COMPILER</span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">&#x27;Hello XL compiler!&#x27;</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">&#x27;Hello unknown compiler - have we met before?&#x27;</span></span><br><span class="line">#<span class="keyword">endif</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-12"><a href="#具体实施-12" class="headerlink" title="具体实施"></a>具体实施</h3><p>我们将从C++的例子开始，然后再看Fortran的例子:</p>
<p>CMakeLists.txt文件中，定义了CMake最低版本、项目名称和支持的语言:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">03</span> LANGUAGES CXX)</span><br></pre></td></tr></table></figure></p>
<p>然后，定义可执行目标及其对应的源文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.cpp)</span><br></pre></td></tr></table></figure></p>
<p>通过定义以下目标编译定义，让预处理器了解编译器的名称和供应商:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;COMPILER_NAME=\&quot;$&#123;CMAKE_CXX_COMPILER_ID&#125;\&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> Intel)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_INTEL_CXX_COMPILER&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> GNU)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_GNU_CXX_COMPILER&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> PGI)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_PGI_CXX_COMPILER&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> XL)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(hello-world PUBLIC <span class="string">&quot;IS_XL_CXX_COMPILER&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>现在我们已经可以预测结果了:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ./hello-world</span><br><span class="line">Hello GNU compiler!</span><br></pre></td></tr></table></figure></p>
<p>使用不同的编译器，此示例代码将打印不同的问候语。</p>
<p>前一个示例的CMakeLists.txt文件中的if语句似乎是重复的，我们不喜欢重复的语句。能更简洁地表达吗？当然可以！为此，让我们再来看看Fortran示例。</p>
<p>Fortran例子的CMakeLists.txt文件中，我们需要做以下工作:</p>
<p>需要使Fortran语言:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(recipe-<span class="number">03</span> LANGUAGES Fortran)</span><br></pre></td></tr></table></figure></p>
<p>然后，定义可执行文件及其对应的源文件。在本例中，使用大写.F90后缀:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-world hello-world.F90)</span><br></pre></td></tr></table></figure></p>
<p>我们通过定义下面的目标编译定义，让预处理器非常清楚地了解编译器:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(hello-world</span><br><span class="line">  PUBLIC <span class="string">&quot;IS_$&#123;CMAKE_Fortran_COMPILER_ID&#125;_FORTRAN_COMPILER&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>其余行为与C++示例相同。</p>
<h3 id="工作原理-10"><a href="#工作原理-10" class="headerlink" title="工作原理"></a>工作原理</h3><p>CMakeLists.txt会在配置时，进行预处理定义，并传递给预处理器。Fortran示例包含非常紧凑的表达式，我们使用<code>CMAKE_Fortran_COMPILER_ID</code>变量，通过<code>target_compile_definition</code>使用构造预处理器进行预处理定义。为了适应这种情况，我们必须将”Intel”从<code>IS_INTEL_CXX_COMPILER</code>更改为<code>IS_Intel_FORTRAN_COMPILER</code>。通过使用相应的<code>CMAKE_C_COMPILER_ID</code>和<code>CMAKE_CXX_COMPILER_ID</code>变量，我们可以在C或C++中实现相同的效果。但是，请注意，<code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>不能保证为所有编译器或语言都定义。</p>
<h2 id="检测处理器体系结构"><a href="#检测处理器体系结构" class="headerlink" title="检测处理器体系结构"></a>检测处理器体系结构</h2><h3 id="准备工作-8"><a href="#准备工作-8" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们以下面的arch-dependent.cpp代码为例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRINGIFY(x) #x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOSTRING(x) STRINGIFY(x)</span></span><br><span class="line"><span class="function">std::string <span class="title">say_hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::string <span class="title">arch_info</span><span class="params">(TOSTRING(ARCHITECTURE))</span></span>;</span><br><span class="line">  arch_info += std::<span class="built_in">string</span>(<span class="string">&quot; architecture. &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IS_32_BIT_ARCH</span></span><br><span class="line">  <span class="keyword">return</span> arch_info + std::<span class="built_in">string</span>(<span class="string">&quot;Compiled on a 32 bit host processor.&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> IS_64_BIT_ARCH</span></span><br><span class="line">  <span class="keyword">return</span> arch_info + std::<span class="built_in">string</span>(<span class="string">&quot;Compiled on a 64 bit host processor.&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> arch_info + std::<span class="built_in">string</span>(<span class="string">&quot;Neither 32 nor 64 bit, puzzling ...&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">say_hello</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-13"><a href="#具体实施-13" class="headerlink" title="具体实施"></a>具体实施</h3><p>CMakeLists.txt文件中，我们需要以下内容:</p>
<p>首先，定义可执行文件及其源文件依赖关系:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">04</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">add_executable</span>(arch-dependent arch-dependent.cpp)</span><br></pre></td></tr></table></figure></p>
<p>检查空指针类型的大小。CMake的<code>CMAKE_SIZEOF_VOID_P</code>变量会告诉我们CPU是32位还是64位。我们通过状态消息让用户知道检测到的大小，并设置预处理器定义:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_SIZEOF_VOID_P <span class="keyword">EQUAL</span> <span class="number">8</span>)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(arch-dependent PUBLIC <span class="string">&quot;IS_64_BIT_ARCH&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Target is 64 bits&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(arch-dependent PUBLIC <span class="string">&quot;IS_32_BIT_ARCH&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Target is 32 bits&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>通过定义以下目标编译定义，让预处理器了解主机处理器架构，同时在配置过程中打印状态消息:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_HOST_SYSTEM_PROCESSOR <span class="keyword">MATCHES</span> <span class="string">&quot;i386&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;i386 architecture detected&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(CMAKE_HOST_SYSTEM_PROCESSOR <span class="keyword">MATCHES</span> <span class="string">&quot;i686&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;i686 architecture detected&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(CMAKE_HOST_SYSTEM_PROCESSOR <span class="keyword">MATCHES</span> <span class="string">&quot;x86_64&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;x86_64 architecture detected&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;host processor architecture is unknown&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">target_compile_definitions</span>(arch-dependent</span><br><span class="line">  PUBLIC <span class="string">&quot;ARCHITECTURE=$&#123;CMAKE_HOST_SYSTEM_PROCESSOR&#125;&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>配置项目，并注意状态消息(打印出的信息可能会发生变化):<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">...</span><br><span class="line">-- Target is 64 bits</span><br><span class="line">-- x86_64 architecture detected</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>最后，构建并执行代码(实际输出将取决于处理器架构):<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br><span class="line">$ ./arch-dependent</span><br><span class="line">x86_64 architecture. Compiled on a 64 bit host processor.</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-11"><a href="#工作原理-11" class="headerlink" title="工作原理"></a>工作原理</h3><p>CMake定义了<code>CMAKE_HOST_SYSTEM_PROCESSOR</code>变量，以包含当前运行的处理器的名称。可以设置为“i386”、“i686”、“x86_64”、“AMD64”等等，当然，这取决于当前的CPU。<code>CMAKE_SIZEOF_VOID_P</code>为void指针的大小。我们可以在CMake配置时进行查询，以便修改目标或目标编译定义。可以基于检测到的主机处理器体系结构，使用预处理器定义，确定需要编译的分支源代码。</p>
<h3 id="更多信息-5"><a href="#更多信息-5" class="headerlink" title="更多信息"></a>更多信息</h3><p>除了<code>CMAKE_HOST_SYSTEM_PROCESSOR</code>, CMake还定义了<code>CMAKE_SYSTEM_PROCESSOR</code>变量。前者包含当前运行的CPU在CMake的名称，而后者将包含当前正在为其构建的CPU的名称。这是一个细微的差别，在交叉编译时起着非常重要的作用。另一种让CMake检测主机处理器体系结构，是使用C或C++中定义的符号，结合CMake的try_run函数，尝试构建执行的源代码分支的预处理符号。这将返回已定义错误码，这些错误可以在CMake端捕获</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__i386) || defined(__i386__) || defined(_M_IX86)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> cmake_arch i386</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__x86_64) || defined(__x86_64__) || defined(__amd64) || defined(_M_X64)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> cmake_arch x86_64</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这种策略也是检测目标处理器体系结构的推荐策略，因为CMake似乎没有提供可移植的内在解决方案。另一种选择，将只使用CMake，完全不使用预处理器，代价是为每种情况设置不同的源文件，然后使用target_source命令将其设置为可执行目标arch-dependent依赖的源文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(arch-dependent <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(CMAKE_HOST_SYSTEM_PROCESSOR <span class="keyword">MATCHES</span> <span class="string">&quot;i386&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;i386 architecture detected&quot;</span>)</span><br><span class="line">    <span class="keyword">target_sources</span>(arch-dependent</span><br><span class="line">        PRIVATE</span><br><span class="line">        arch-dependent-i386.cpp</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">elseif</span>(CMAKE_HOST_SYSTEM_PROCESSOR <span class="keyword">MATCHES</span> <span class="string">&quot;i686&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;i686 architecture detected&quot;</span>)</span><br><span class="line">    <span class="keyword">target_sources</span>(arch-dependent</span><br><span class="line">        PRIVATE</span><br><span class="line">            arch-dependent-i686.cpp</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">elseif</span>(CMAKE_HOST_SYSTEM_PROCESSOR <span class="keyword">MATCHES</span> <span class="string">&quot;x86_64&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;x86_64 architecture detected&quot;</span>)</span><br><span class="line">    <span class="keyword">target_sources</span>(arch-dependent</span><br><span class="line">        PRIVATE</span><br><span class="line">            arch-dependent-x86_64.cpp</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;host processor architecture is unknown&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>这种方法，显然需要对现有项目进行更多的工作，因为源文件需要分离。此外，不同源文件之间的代码复制肯定也会成为问题。</p>
<h2 id="检测处理器指令集"><a href="#检测处理器指令集" class="headerlink" title="检测处理器指令集"></a>检测处理器指令集</h2><p>本示例中，我们将讨论如何在CMake的帮助下检测主机处理器支持的指令集。这个功能是较新版本添加到CMake中的，需要CMake 3.10或更高版本。检测到的主机系统信息，可用于设置相应的编译器标志，或实现可选的源代码编译，或根据主机系统生成源代码。本示例中，我们的目标是检测主机系统信息，使用预处理器定义将其传递给C++源代码，并将信息打印到输出中。</p>
<h3 id="准备工作-9"><a href="#准备工作-9" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们是C++源码(processor-info.cpp)如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Number of logical cores: &quot;</span></span><br><span class="line">            &lt;&lt; NUMBER_OF_LOGICAL_CORES &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Number of physical cores: &quot;</span></span><br><span class="line">            &lt;&lt; NUMBER_OF_PHYSICAL_CORES &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Total virtual memory in megabytes: &quot;</span></span><br><span class="line">            &lt;&lt; TOTAL_VIRTUAL_MEMORY &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Available virtual memory in megabytes: &quot;</span></span><br><span class="line">            &lt;&lt; AVAILABLE_VIRTUAL_MEMORY &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Total physical memory in megabytes: &quot;</span></span><br><span class="line">            &lt;&lt; TOTAL_PHYSICAL_MEMORY &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Available physical memory in megabytes: &quot;</span></span><br><span class="line">            &lt;&lt; AVAILABLE_PHYSICAL_MEMORY &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Processor is 64Bit: &quot;</span></span><br><span class="line">            &lt;&lt; IS_64BIT &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Processor has floating point unit: &quot;</span></span><br><span class="line">            &lt;&lt; HAS_FPU &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Processor supports MMX instructions: &quot;</span></span><br><span class="line">            &lt;&lt; HAS_MMX &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Processor supports Ext. MMX instructions: &quot;</span></span><br><span class="line">            &lt;&lt; HAS_MMX_PLUS &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Processor supports SSE instructions: &quot;</span></span><br><span class="line">            &lt;&lt; HAS_SSE &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Processor supports SSE2 instructions: &quot;</span></span><br><span class="line">            &lt;&lt; HAS_SSE2 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Processor supports SSE FP instructions: &quot;</span></span><br><span class="line">            &lt;&lt; HAS_SSE_FP &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Processor supports SSE MMX instructions: &quot;</span></span><br><span class="line">            &lt;&lt; HAS_SSE_MMX &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Processor supports 3DNow instructions: &quot;</span></span><br><span class="line">            &lt;&lt; HAS_AMD_3DNOW &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Processor supports 3DNow+ instructions: &quot;</span></span><br><span class="line">            &lt;&lt; HAS_AMD_3DNOW_PLUS &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;IA64 processor emulating x86 : &quot;</span></span><br><span class="line">            &lt;&lt; HAS_IA64 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;OS name: &quot;</span></span><br><span class="line">            &lt;&lt; OS_NAME &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;OS sub-type: &quot;</span></span><br><span class="line">            &lt;&lt; OS_RELEASE &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;OS build ID: &quot;</span></span><br><span class="line">            &lt;&lt; OS_VERSION &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;OS platform: &quot;</span></span><br><span class="line">            &lt;&lt; OS_PLATFORM &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其包含config.h头文件，我们将使用config.h.in生成这个文件。config.h.in如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER_OF_LOGICAL_CORES @_NUMBER_OF_LOGICAL_CORES@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER_OF_PHYSICAL_CORES @_NUMBER_OF_PHYSICAL_CORES@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_VIRTUAL_MEMORY @_TOTAL_VIRTUAL_MEMORY@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AVAILABLE_VIRTUAL_MEMORY @_AVAILABLE_VIRTUAL_MEMORY@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_PHYSICAL_MEMORY @_TOTAL_PHYSICAL_MEMORY@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AVAILABLE_PHYSICAL_MEMORY @_AVAILABLE_PHYSICAL_MEMORY@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_64BIT @_IS_64BIT@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_FPU @_HAS_FPU@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_MMX @_HAS_MMX@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_MMX_PLUS @_HAS_MMX_PLUS@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_SSE @_HAS_SSE@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_SSE2 @_HAS_SSE2@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_SSE_FP @_HAS_SSE_FP@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_SSE_MMX @_HAS_SSE_MMX@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_AMD_3DNOW @_HAS_AMD_3DNOW@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_AMD_3DNOW_PLUS @_HAS_AMD_3DNOW_PLUS@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_IA64 @_HAS_IA64@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_NAME <span class="string">&quot;@_OS_NAME@&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_RELEASE <span class="string">&quot;@_OS_RELEASE@&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_VERSION <span class="string">&quot;@_OS_VERSION@&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_PLATFORM <span class="string">&quot;@_OS_PLATFORM@&quot;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="如何实施"><a href="#如何实施" class="headerlink" title="如何实施"></a>如何实施</h3><p>我们将使用CMake为平台填充config.h中的定义，并将示例源文件编译为可执行文件:</p>
<p>首先，我们定义了CMake最低版本、项目名称和项目语言:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">05</span> CXX)</span><br></pre></td></tr></table></figure></p>
<p>然后，定义目标可执行文件及其源文件，并包括目录:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(processor-info <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(processor-info</span><br><span class="line">  PRIVATE</span><br><span class="line">      processor-info.cpp</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_include_directories</span>(processor-info</span><br><span class="line">  PRIVATE</span><br><span class="line">       <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>继续查询主机系统的信息，获取一些关键字:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(key</span><br><span class="line">  IN ITEMS</span><br><span class="line">    NUMBER_OF_LOGICAL_CORES</span><br><span class="line">    NUMBER_OF_PHYSICAL_CORES</span><br><span class="line">    TOTAL_VIRTUAL_MEMORY</span><br><span class="line">    AVAILABLE_VIRTUAL_MEMORY</span><br><span class="line">    TOTAL_PHYSICAL_MEMORY</span><br><span class="line">    AVAILABLE_PHYSICAL_MEMORY</span><br><span class="line">    IS_64BIT</span><br><span class="line">    HAS_FPU</span><br><span class="line">    HAS_MMX</span><br><span class="line">    HAS_MMX_PLUS</span><br><span class="line">    HAS_SSE</span><br><span class="line">    HAS_SSE2</span><br><span class="line">    HAS_SSE_FP</span><br><span class="line">    HAS_SSE_MMX</span><br><span class="line">    HAS_AMD_3DNOW</span><br><span class="line">    HAS_AMD_3DNOW_PLUS</span><br><span class="line">    HAS_IA64</span><br><span class="line">    OS_NAME</span><br><span class="line">    OS_RELEASE</span><br><span class="line">    OS_VERSION</span><br><span class="line">    OS_PLATFORM</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">cmake_host_system_information</span>(RESULT _<span class="variable">$&#123;key&#125;</span> QUERY <span class="variable">$&#123;key&#125;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure></p>
<p>定义了相应的变量后，配置config.h:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configure_file</span>(config.h.in config.h @ONLY)</span><br></pre></td></tr></table></figure></p>
<p>现在准备好配置、构建和测试项目:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ./processor-info</span><br><span class="line">Number of logical cores: 4</span><br><span class="line">Number of physical cores: 2</span><br><span class="line">Total virtual memory <span class="keyword">in</span> megabytes: 15258</span><br><span class="line">Available virtual memory <span class="keyword">in</span> megabytes: 14678</span><br><span class="line">Total physical memory <span class="keyword">in</span> megabytes: 7858</span><br><span class="line">Available physical memory <span class="keyword">in</span> megabytes: 4072</span><br><span class="line">Processor is 64Bit: 1</span><br><span class="line">Processor has floating point unit: 1</span><br><span class="line">Processor supports MMX instructions: 1</span><br><span class="line">Processor supports Ext. MMX instructions: 0</span><br><span class="line">Processor supports SSE instructions: 1</span><br><span class="line">Processor supports SSE2 instructions: 1</span><br><span class="line">Processor supports SSE FP instructions: 0</span><br><span class="line">Processor supports SSE MMX instructions: 0</span><br><span class="line">Processor supports 3DNow instructions: 0</span><br><span class="line">Processor supports 3DNow+ instructions: 0</span><br><span class="line">IA64 processor emulating x86 : 0</span><br><span class="line">OS name: Linux</span><br><span class="line">OS sub-type: 4.16.7-1-ARCH</span><br><span class="line">OS build ID: <span class="comment">#1 SMP PREEMPT Wed May 2 21:12:36 UTC 2018</span></span><br><span class="line">OS platform: x86_64</span><br></pre></td></tr></table></figure></p>
<p>输出会随着处理器的不同而变化。</p>
<h3 id="工作原理-12"><a href="#工作原理-12" class="headerlink" title="工作原理"></a>工作原理</h3><p>CMakeLists.txt中的foreach循环会查询多个键值，并定义相应的变量。此示例的核心函数是cmake_host_system_information，它查询运行CMake的主机系统的系统信息。本例中，我们对每个键使用了一个函数调用。然后，使用这些变量来配置config.h.in中的占位符，输入并生成config.h。此配置使用configure_file命令完成。最后，config.h包含在processor-info.cpp中。编译后，它将把值打印到屏幕上。</p>
<h2 id="为Eigen库使能向量化"><a href="#为Eigen库使能向量化" class="headerlink" title="为Eigen库使能向量化"></a>为Eigen库使能向量化</h2><p>处理器的向量功能，可以提高代码的性能。对于某些类型的运算来说尤为甚之，例如：线性代数。本示例将展示如何使能矢量化，以便使用线性代数的Eigen C++库加速可执行文件。</p>
<h3 id="准备工作-10"><a href="#准备工作-10" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们用Eigen C++模板库，用来进行线性代数计算，并展示如何设置编译器标志来启用向量化。这个示例的源代码linear-algebra.cpp文件:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="function">EIGEN_DONT_INLINE</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">simple_function</span><span class="params">(Eigen::VectorXd &amp;va, Eigen::VectorXd &amp;vb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// this simple function computes the dot product of two vectors</span></span><br><span class="line">  <span class="comment">// of course it could be expressed more compactly</span></span><br><span class="line">  <span class="type">double</span> d = va.<span class="built_in">dot</span>(vb);</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">1000000</span>;</span><br><span class="line">  <span class="type">int</span> num_repetitions = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// generate two random vectors</span></span><br><span class="line">  Eigen::VectorXd va = Eigen::VectorXd::<span class="built_in">Random</span>(len);</span><br><span class="line">  Eigen::VectorXd vb = Eigen::VectorXd::<span class="built_in">Random</span>(len);</span><br><span class="line">  <span class="type">double</span> result;</span><br><span class="line">  <span class="keyword">auto</span> start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; num_repetitions; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="built_in">simple_function</span>(va, vb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> elapsed_seconds = end - start;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;elapsed seconds: &quot;</span> &lt;&lt; elapsed_seconds.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们期望向量化可以加快simple_function中的点积操作。</p>
<h3 id="如何实施-1"><a href="#如何实施-1" class="headerlink" title="如何实施"></a>如何实施</h3><p>根据Eigen库的文档，设置适当的编译器标志就足以生成向量化的代码。让我们看看CMakeLists.txt:</p>
<p>声明一个C++11项目:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">06</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用Eigen库，我们需要在系统上找到它的头文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Eigen3 <span class="number">3.3</span> REQUIRED CONFIG)</span><br><span class="line">CheckCXXCompilerFlag.cmake标准模块文件:</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(CheckCXXCompilerFlag)</span><br></pre></td></tr></table></figure></p>
<p>检查-march=native编译器标志是否工作:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_cxx_compiler_flag(<span class="string">&quot;-march=native&quot;</span> _march_native_works)</span><br></pre></td></tr></table></figure></p>
<p>另一个选项-xHost编译器标志也开启:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_cxx_compiler_flag(<span class="string">&quot;-xHost&quot;</span> _xhost_works)</span><br></pre></td></tr></table></figure></p>
<p>设置了一个空变量<code>_CXX_FLAGS</code>，来保存刚才检查的两个编译器中找到的编译器标志。如果看到<code>_march_native_works</code>，我们将<code>_CXX_FLAGS</code>设置为<code>-march=native</code>。如果看到<code>_xhost_works</code>，我们将<code>_CXX_FLAGS</code>设置为<code>-xHost</code>。如果它们都不起作用，<code>_CXX_FLAGS</code>将为空，并禁用矢量化:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(_CXX_FLAGS)</span><br><span class="line"><span class="keyword">if</span>(_march_native_works)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Using processor&#x27;s vector instructions (-march=native compiler flag set)&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(_CXX_FLAGS <span class="string">&quot;-march=native&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(_xhost_works)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Using processor&#x27;s vector instructions (-xHost compiler flag set)&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(_CXX_FLAGS <span class="string">&quot;-xHost&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;No suitable compiler flag found for vectorization&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>为了便于比较，我们还为未优化的版本定义了一个可执行目标，不使用优化标志:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(linear-algebra-unoptimized linear-algebra.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(linear-algebra-unoptimized</span><br><span class="line">  PRIVATE</span><br><span class="line">      Eigen3::Eigen</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>此外，我们定义了一个优化版本:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(linear-algebra linear-algebra.cpp)</span><br><span class="line"><span class="keyword">target_compile_options</span>(linear-algebra</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;_CXX_FLAGS&#125;</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(linear-algebra</span><br><span class="line">  PRIVATE</span><br><span class="line">      Eigen3::Eigen</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>让我们比较一下这两个可执行文件——首先我们配置(在本例中，-march=native_works):<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">...</span><br><span class="line">-- Performing Test _march_native_works</span><br><span class="line">-- Performing Test _march_native_works - Success</span><br><span class="line">-- Performing Test _xhost_works</span><br><span class="line">-- Performing Test _xhost_works - Failed</span><br><span class="line">-- Using processor<span class="string">&#x27;s vector instructions (-march=native compiler flag set)</span></span><br></pre></td></tr></table></figure></p>
<p>最后，让我们编译可执行文件，并比较运行时间:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br><span class="line">$ ./linear-algebra-unoptimized</span><br><span class="line">result: -261.505</span><br><span class="line">elapsed seconds: 1.97964</span><br><span class="line">$ ./linear-algebra</span><br><span class="line">result: -261.505</span><br><span class="line">elapsed seconds: 1.05048</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-13"><a href="#工作原理-13" class="headerlink" title="工作原理"></a>工作原理</h3><p>大多数处理器提供向量指令集，代码可以利用这些特性，获得更高的性能。由于线性代数运算可以从Eigen库中获得很好的加速，所以在使用Eigen库时，就要考虑向量化。我们所要做的就是，指示编译器为我们检查处理器，并为当前体系结构生成本机指令。不同的编译器供应商会使用不同的标志来实现这一点：GNU编译器使用-march=native标志来实现这一点，而Intel编译器使用-xHost标志。使用CheckCXXCompilerFlag.cmake模块提供的check_cxx_compiler_flag函数进行编译器标志的检查:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_cxx_compiler_flag(<span class="string">&quot;-march=native&quot;</span> _march_native_works)</span><br></pre></td></tr></table></figure></p>
<p>这个函数接受两个参数:</p>
<ul>
<li>第一个是要检查的编译器标志。</li>
<li>第二个是用来存储检查结果(true或false)的变量。如果检查为真，我们将工作标志添加到<code>_CXX_FLAGS</code>变量中，该变量将用于为可执行目标设置编译器标志。</li>
</ul>
<h1 id="检测外部库和程序"><a href="#检测外部库和程序" class="headerlink" title="检测外部库和程序"></a>检测外部库和程序</h1><h2 id="检测Python解释器"><a href="#检测Python解释器" class="headerlink" title="检测Python解释器"></a>检测Python解释器</h2><p>我们将介绍find_package命令，这个命令将贯穿本章。</p>
<h3 id="具体实施-14"><a href="#具体实施-14" class="headerlink" title="具体实施"></a>具体实施</h3><p>我们将逐步建立CMakeLists.txt文件:</p>
<p>首先，定义CMake最低版本和项目名称。注意，这里不需要任何语言支持:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span> LANGUAGES NONE)</span><br></pre></td></tr></table></figure></p>
<p>然后，使用find_package命令找到Python解释器:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>然后，执行Python命令并捕获它的输出和返回值:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;print(&#x27;Hello, world!&#x27;)&quot;</span></span><br><span class="line">  RESULT_VARIABLE _status</span><br><span class="line">  OUTPUT_VARIABLE _hello_world</span><br><span class="line">  ERROR_QUIET</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，打印Python命令的返回值和输出:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;RESULT_VARIABLE is: $&#123;_status&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;OUTPUT_VARIABLE is: $&#123;_hello_world&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>配置项目:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">-- Found PythonInterp: /usr/bin/python (found version <span class="string">&quot;3.6.5&quot;</span>)</span><br><span class="line">-- RESULT_VARIABLE is: 0</span><br><span class="line">-- OUTPUT_VARIABLE is: Hello, world!</span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /home/user/cmake-cookbook/chapter-03/recipe-01/example/build</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-14"><a href="#工作原理-14" class="headerlink" title="工作原理"></a>工作原理</h3><p>find_package是用于发现和设置包的CMake模块的命令。这些模块包含CMake命令，用于标识系统标准位置中的包。CMake模块文件称为<code>Find&lt;name&gt;.cmake</code>，当调用<code>find_package(&lt;name&gt;)</code>时，模块中的命令将会运行。</p>
<p>除了在系统上实际查找包模块之外，查找模块还会设置了一些有用的变量，反映实际找到了什么，也可以在自己的CMakeLists.txt中使用这些变量。对于Python解释器，相关模块为FindPythonInterp.cmake附带的设置了一些CMake变量:</p>
<ul>
<li>PYTHONINTERP_FOUND：是否找到解释器</li>
<li>PYTHON_EXECUTABLE：Python解释器到可执行文件的路径</li>
<li>PYTHON_VERSION_STRING：Python解释器的完整版本信息</li>
<li>PYTHON_VERSION_MAJOR：Python解释器的主要版本号</li>
<li>PYTHON_VERSION_MINOR ：Python解释器的次要版本号</li>
<li>PYTHON_VERSION_PATCH：Python解释器的补丁版本号</li>
</ul>
<p>可以强制CMake，查找特定版本的包。例如，要求Python解释器的版本大于或等于2.7：find_package(PythonInterp 2.7)</p>
<p>可以强制满足依赖关系:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>如果在查找位置中没有找到适合Python解释器的可执行文件，CMake将中止配置。</p>
<p>软件包没有安装在标准位置时，CMake无法正确定位它们。用户可以使用CLI的-D参数传递相应的选项，告诉CMake查看特定的位置。Python解释器可以使用以下配置:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -D PYTHON_EXECUTABLE=/custom/location/python ..</span><br></pre></td></tr></table></figure><br>这将指定非标准<code>/custom/location/python</code>安装目录中的Python可执行文件。</p>
<blockquote>
<p>每个包都是不同的，<code>Find&lt;package&gt;.cmake</code>模块试图提供统一的检测接口。。</p>
</blockquote>
<p>除了检测包之外，我们还想提到一个便于打印变量的helper模块。本示例中，我们使用了以下方法:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;RESULT_VARIABLE is: $&#123;_status&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;OUTPUT_VARIABLE is: $&#123;_hello_world&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用以下工具进行调试:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CMakePrintHelpers)</span><br><span class="line">cmake_print_variables(_status _hello_world)</span><br></pre></td></tr></table></figure></p>
<p>将产生以下输出:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- _status=<span class="string">&quot;0&quot;</span> ; _hello_world=<span class="string">&quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="检测Python库"><a href="#检测Python库" class="headerlink" title="检测Python库"></a>检测Python库</h2><p>可以使用Python工具来分析和操作程序的输出。然而，还有更强大的方法可以将解释语言(如Python)与编译语言(如C或C++)组合在一起使用。一种是扩展Python，通过编译成共享库的C或C++模块在这些类型上提供新类型和新功能，这是第9章的主题。另一种是将Python解释器嵌入到C或C++程序中。两种方法都需要下列条件:</p>
<ul>
<li>Python解释器的工作版本</li>
<li>Python头文件Python.h的可用性</li>
<li>Python运行时库libpython</li>
</ul>
<p>三个组件所使用的Python版本必须相同。我们已经演示了如何找到Python解释器；本示例中，我们将展示另外两种方式。</p>
<h3 id="准备工作-11"><a href="#准备工作-11" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们将一个简单的Python代码，嵌入到C程序中，可以在Python文档页面上找到。源文件称为hello-embedded-python.c:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Py_SetProgramName</span>(argv[<span class="number">0</span>]); <span class="comment">/* optional but recommended */</span></span><br><span class="line">  <span class="built_in">Py_Initialize</span>();</span><br><span class="line">  <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;from time import time,ctime\n&quot;</span></span><br><span class="line">                     <span class="string">&quot;print &#x27;Today is&#x27;,ctime(time())\n&quot;</span>);</span><br><span class="line">  <span class="built_in">Py_Finalize</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此代码将在程序中初始化Python解释器的实例，并使用Python的time模块，打印日期。</p>
<h3 id="具体实施-15"><a href="#具体实施-15" class="headerlink" title="具体实施"></a>具体实施</h3><p>以下是CMakeLists.txt中的步骤:</p>
<p>包含CMake最低版本、项目名称和所需语言:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">02</span> LANGUAGES C)</span><br></pre></td></tr></table></figure></p>
<p>使用C99标准，这不严格要求与Python链接，但有时你可能需要对Python进行连接:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>找到Python解释器。这是一个REQUIRED依赖:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>找到Python头文件和库的模块，称为FindPythonLibs.cmake:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PythonLibs <span class="variable">$&#123;PYTHON_VERSION_MAJOR&#125;</span>.<span class="variable">$&#123;PYTHON_VERSION_MINOR&#125;</span> EXACT REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>使用hello-embedded-python.c源文件，添加一个可执行目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-embedded-python hello-embedded-python.c)</span><br></pre></td></tr></table></figure></p>
<p>可执行文件包含Python.h头文件。因此，这个目标的include目录必须包含Python的include目录，可以通过<code>PYTHON_INCLUDE_DIRS</code>变量进行指定:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(hello-embedded-python</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;PYTHON_INCLUDE_DIRS&#125;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p>
<p>最后，将可执行文件链接到Python库，通过PYTHON_LIBRARIES变量访问:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(hello-embedded-python</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;PYTHON_LIBRARIES&#125;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p>
<p>现在，进行构建:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">...</span><br><span class="line">-- Found PythonInterp: /usr/bin/python (found version <span class="string">&quot;3.6.5&quot;</span>)</span><br><span class="line">-- Found PythonLibs: /usr/lib/libpython3.6m.so (found suitable exact version <span class="string">&quot;3.6.5&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>最后，执行构建，并运行可执行文件:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br><span class="line">$ ./hello-embedded-python</span><br><span class="line">Today is Thu Jun 7 22:26:02 2018</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-15"><a href="#工作原理-15" class="headerlink" title="工作原理"></a>工作原理</h3><p>FindPythonLibs.cmake模块将查找Python头文件和库的标准位置。由于，我们的项目需要这些依赖项，如果没有找到这些依赖项，将停止配置，并报出错误。</p>
<p>注意，我们显式地要求CMake检测安装的Python可执行文件。这是为了确保可执行文件、头文件和库都有一个匹配的版本。这对于不同版本，可能在运行时导致崩溃。我们通过<code>FindPythonInterp.cmake</code>中定义的<code>PYTHON_VERSION_MAJOR</code>和<code>PYTHON_VERSION_MINOR</code>来实现:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(PythonLibs <span class="variable">$&#123;PYTHON_VERSION_MAJOR&#125;</span>.<span class="variable">$&#123;PYTHON_VERSION_MINOR&#125;</span> EXACT REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>使用EXACT关键字，限制CMake检测特定的版本，在本例中是匹配的相应Python版本的包括文件和库。我们可以使用PYTHON_VERSION_STRING变量，进行更接近的匹配:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(PythonLibs <span class="variable">$&#123;PYTHON_VERSION_STRING&#125;</span> EXACT REQUIRED)</span><br></pre></td></tr></table></figure></p>
<h3 id="更多信息-6"><a href="#更多信息-6" class="headerlink" title="更多信息"></a>更多信息</h3><p>当Python不在标准安装目录中，我们如何确定Python头文件和库的位置是正确的？对于Python解释器，可以通过CLI的-D选项传递PYTHON_LIBRARY和PYTHON_INCLUDE_DIR选项来强制CMake查找特定的目录。这些选项指定了以下内容:</p>
<ul>
<li>PYTHON_LIBRARY：指向Python库的路径</li>
<li>PYTHON_INCLUDE_DIR：Python.h所在的路径</li>
</ul>
<p>这样，就能获得所需的Python版本。</p>
<blockquote>
<p>有时需要将<code>-D PYTHON_EXECUTABLE</code>、<code>-D PYTHON_LIBRARY</code>和<code>-D PYTHON_INCLUDE_DIR</code>传递给CMake CLI，以便找到及定位相应的版本的组件。</p>
</blockquote>
<h2 id="检测Python模块和包"><a href="#检测Python模块和包" class="headerlink" title="检测Python模块和包"></a>检测Python模块和包</h2><p>依赖于Python模块或包的项目中，确定满足对这些Python模块的依赖非常重要。本示例将展示如何探测用户的环境，以找到特定的Python模块和包。</p>
<h3 id="准备工作-12"><a href="#准备工作-12" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们将尝试在C++程序中嵌入一个稍微复杂一点的例子。这个示例再次引用Python在线文档，并展示了如何通过调用编译后的C++可执行文件，来执行用户定义的Python模块中的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  PyObject* pName, * pModule, * pDict, * pFunc;</span><br><span class="line">  PyObject* pArgs, * pValue;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Usage: pure-embedding pythonfile funcname [args]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Py_Initialize</span>();</span><br><span class="line">  <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;import sys&quot;</span>);</span><br><span class="line">  <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;sys.path.append(\&quot;.\&quot;)&quot;</span>);</span><br><span class="line">  pName = <span class="built_in">PyUnicode_DecodeFSDefault</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">/* Error checking of pName left out */</span></span><br><span class="line">  pModule = <span class="built_in">PyImport_Import</span>(pName);</span><br><span class="line">  <span class="built_in">Py_DECREF</span>(pName);</span><br><span class="line">  <span class="keyword">if</span> (pModule != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pFunc = <span class="built_in">PyObject_GetAttrString</span>(pModule, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">/* pFunc is a new reference */</span></span><br><span class="line">    <span class="keyword">if</span> (pFunc &amp;&amp; <span class="built_in">PyCallable_Check</span>(pFunc)) &#123;</span><br><span class="line">      pArgs = <span class="built_in">PyTuple_New</span>(argc - <span class="number">3</span>);</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc - <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pValue = <span class="built_in">PyLong_FromLong</span>(<span class="built_in">atoi</span>(argv[i + <span class="number">3</span>]));</span><br><span class="line">        <span class="keyword">if</span> (!pValue) &#123;</span><br><span class="line">          <span class="built_in">Py_DECREF</span>(pArgs);</span><br><span class="line">          <span class="built_in">Py_DECREF</span>(pModule);</span><br><span class="line">          <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Cannot convert argument\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* pValue reference stolen here: */</span></span><br><span class="line">        <span class="built_in">PyTuple_SetItem</span>(pArgs, i, pValue);</span><br><span class="line">      &#125;</span><br><span class="line">      pValue = <span class="built_in">PyObject_CallObject</span>(pFunc, pArgs);</span><br><span class="line">      <span class="built_in">Py_DECREF</span>(pArgs);</span><br><span class="line">      <span class="keyword">if</span> (pValue != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result of call: %ld\n&quot;</span>, <span class="built_in">PyLong_AsLong</span>(pValue));</span><br><span class="line">        <span class="built_in">Py_DECREF</span>(pValue);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Py_DECREF</span>(pFunc);</span><br><span class="line">        <span class="built_in">Py_DECREF</span>(pModule);</span><br><span class="line">        <span class="built_in">PyErr_Print</span>();</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Call failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">PyErr_Occurred</span>())</span><br><span class="line">        <span class="built_in">PyErr_Print</span>();</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Cannot find function \&quot;%s\&quot;\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Py_XDECREF</span>(pFunc);</span><br><span class="line">    <span class="built_in">Py_DECREF</span>(pModule);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">PyErr_Print</span>();</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to load \&quot;%s\&quot;\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Py_Finalize</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们希望嵌入的Python代码(use_numpy.py)使用NumPy设置一个矩阵，所有矩阵元素都为1.0:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_ones</span>(<span class="params">rows, cols</span>):</span><br><span class="line">  A = np.ones(shape=(rows, cols), dtype=<span class="built_in">float</span>)</span><br><span class="line">  <span class="built_in">print</span>(A)</span><br><span class="line">  <span class="comment"># we return the number of elements to verify</span></span><br><span class="line">  <span class="comment"># that the C++ code is able to receive return values</span></span><br><span class="line">  num_elements = rows*cols</span><br><span class="line">  <span class="keyword">return</span>(num_elements)</span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-16"><a href="#具体实施-16" class="headerlink" title="具体实施"></a>具体实施</h3><p>下面的代码中，我们能够使用CMake检查NumPy是否可用。我们需要确保Python解释器、头文件和库在系统上是可用的。然后，将再来确认NumPy的可用性：</p>
<p>首先，我们定义了最低CMake版本、项目名称、语言和C++标准:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">03</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>查找解释器、头文件和库的方法与前面的方法完全相同:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(PythonLibs <span class="variable">$&#123;PYTHON_VERSION_MAJOR&#125;</span>.<span class="variable">$&#123;PYTHON_VERSION_MINOR&#125;</span> EXACT REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>正确打包的Python模块，指定安装位置和版本。可以在CMakeLists.txt中执行Python脚本进行探测:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;import re, numpy; print(re.compile(&#x27;/__init__.py.*&#x27;).sub(&#x27;&#x27;,numpy.__file__))&quot;</span></span><br><span class="line">  RESULT_VARIABLE _numpy_status</span><br><span class="line">  OUTPUT_VARIABLE _numpy_location</span><br><span class="line">  ERROR_QUIET</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>如果找到NumPy，则_numpy_status变量为整数，否则为错误的字符串，而_numpy_location将包含NumPy模块的路径。如果找到NumPy，则将它的位置保存到一个名为NumPy的新变量中。注意，新变量被缓存，这意味着CMake创建了一个持久性变量，用户稍后可以修改该变量:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> _numpy_status)</span><br><span class="line">    <span class="keyword">set</span>(NumPy <span class="variable">$&#123;_numpy_location&#125;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;Location of NumPy&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>下一步是检查模块的版本。同样，我们在CMakeLists.txt中施加了一些Python魔法，将版本保存到<code>_numpy_version</code>变量中:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;import numpy; print(numpy.__version__)&quot;</span></span><br><span class="line">  OUTPUT_VARIABLE _numpy_version</span><br><span class="line">  ERROR_QUIET</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，FindPackageHandleStandardArgs的CMake包以正确的格式设置NumPy_FOUND变量和输出信息:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FindPackageHandleStandardArgs)</span><br><span class="line">find_package_handle_standard_args(NumPy</span><br><span class="line">  FOUND_VAR NumPy_FOUND</span><br><span class="line">  REQUIRED_VARS NumPy</span><br><span class="line">  VERSION_VAR _numpy_version</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>一旦正确的找到所有依赖项，我们就可以编译可执行文件，并将其链接到Python库:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(pure-embedding <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(pure-embedding</span><br><span class="line">  PRIVATE</span><br><span class="line">      Py<span class="variable">$&#123;PYTHON_VERSION_MAJOR&#125;</span>-pure-embedding.cpp</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_include_directories</span>(pure-embedding</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;PYTHON_INCLUDE_DIRS&#125;</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(pure-embedding</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;PYTHON_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>我们还必须保证use_numpy.py在build目录中可用:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/use_numpy.py</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/use_numpy.py</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/use_numpy.py</span><br><span class="line">  DEPENDS</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/use_numpy.py</span><br><span class="line">  )</span><br><span class="line"><span class="comment"># make sure building pure-embedding triggers the above custom command</span></span><br><span class="line"><span class="keyword">target_sources</span>(pure-embedding</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/use_numpy.py</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>现在，我们可以测试嵌入的代码:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">-- ...</span><br><span class="line">-- Found PythonInterp: /usr/bin/python (found version <span class="string">&quot;3.6.5&quot;</span>)</span><br><span class="line">-- Found PythonLibs: /usr/lib/libpython3.6m.so (found suitable exact version <span class="string">&quot;3.6.5&quot;</span>)</span><br><span class="line">-- Found NumPy: /usr/lib/python3.6/site-packages/numpy (found version <span class="string">&quot;1.14.3&quot;</span>)</span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ./pure-embedding use_numpy print_ones 2 3</span><br><span class="line">[[1. 1. 1.]</span><br><span class="line">[1. 1. 1.]]</span><br><span class="line">Result of call: 6</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-16"><a href="#工作原理-16" class="headerlink" title="工作原理"></a>工作原理</h3><p>例子中有三个新的CMake命令，需要<code>include(FindPackageHandleStandardArgs)</code>：</p>
<ul>
<li>execute_process</li>
<li>add_custom_command</li>
<li>find_package_handle_standard_args</li>
</ul>
<p><code>execute_process</code>将作为通过子进程执行一个或多个命令。最后，子进程返回值将保存到变量作为参数，传递给RESULT_VARIABLE，而管道标准输出和标准错误的内容将被保存到变量作为参数传递给OUTPUT_VARIABLE和ERROR_VARIABLE。execute_process可以执行任何操作，并使用它们的结果来推断系统配置。本例中，用它来确保NumPy可用，然后获得模块版本。</p>
<p><code>find_package_handle_standard_args</code>提供了，用于处理与查找相关程序和库的标准工具。引用此命令时，可以正确的处理与版本相关的选项(REQUIRED和EXACT)，而无需更多的CMake代码。稍后将介绍QUIET和COMPONENTS选项。本示例中，使用了以下方法:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FindPackageHandleStandardArgs)</span><br><span class="line">find_package_handle_standard_args(NumPy</span><br><span class="line">  FOUND_VAR NumPy_FOUND</span><br><span class="line">  REQUIRED_VARS NumPy</span><br><span class="line">  VERSION_VAR _numpy_version</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>所有必需的变量都设置为有效的文件路径(NumPy)后，发送到模块(NumPy_FOUND)。它还将版本保存在可传递的版本变量(_numpy_version)中并打印:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- Found NumPy: /usr/lib/python3.6/site-packages/numpy (found version <span class="string">&quot;1.14.3&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>目前的示例中，没有进一步使用这些变量。如果返回NumPy_FOUND为FALSE，则停止配置。</p>
<p>最后，将use_numpy.py复制到build目录，对代码进行注释:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/use_numpy.py</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/use_numpy.py</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/use_numpy.py</span><br><span class="line">  DEPENDS</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/use_numpy.py</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_sources</span>(pure-embedding</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/use_numpy.py</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>我们也可以使用file(COPY…)命令来实现复制。这里，我们选择使用add_custom_command，来确保文件在每次更改时都会被复制，而不仅仅是第一次运行配置时。还要注意target_sources命令，它将依赖项添加到<code>$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/use_numpy.py</code>；这样做是为了确保构建目标，能够触发之前的命令。</p>
<h2 id="检测BLAS和LAPACK数学库"><a href="#检测BLAS和LAPACK数学库" class="headerlink" title="检测BLAS和LAPACK数学库"></a>检测BLAS和LAPACK数学库</h2><p>虽然用于数学库底层实现实际所用的编程语言会随着时间而变化(Fortran、C、Assembly)，但是也都是Fortran调用接口。本示例中的任务要链接到这些库，并展示如何用不同语言编写的库。</p>
<h3 id="准备工作-13"><a href="#准备工作-13" class="headerlink" title="准备工作"></a>准备工作</h3><p>为了展示数学库的检测和连接，我们编译一个C++程序，将矩阵的维数作为命令行输入，生成一个随机的方阵A，一个随机向量b，并计算线性系统方程: Ax = b。另外，将对向量b的进行随机缩放。这里，需要使用的子程序是BLAS中的DSCAL和LAPACK中的DGESV来求线性方程组的解。示例C++代码的清单( linear-algebra.cpp)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CxxBLAS.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CxxLAPACK.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Usage: ./linear-algebra dim&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Generate a uniform distribution of real number between -1.0 and 1.0</span></span><br><span class="line">  std::random_device rd;</span><br><span class="line">  <span class="function">std::mt19937 <span class="title">mt</span><span class="params">(rd())</span></span>;</span><br><span class="line">  <span class="function">std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">-1.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">  <span class="comment">// Allocate matrices and right-hand side vector</span></span><br><span class="line">  <span class="type">int</span> dim = std::<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">A</span><span class="params">(dim * dim)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">b</span><span class="params">(dim)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ipiv</span><span class="params">(dim)</span></span>;</span><br><span class="line">  <span class="comment">// Fill matrix and RHS with random numbers between -1.0 and 1.0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; dim; r++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; dim; c++) &#123;</span><br><span class="line">      A[r + c * dim] = <span class="built_in">dist</span>(mt);</span><br><span class="line">    &#125;</span><br><span class="line">    b[r] = <span class="built_in">dist</span>(mt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Scale RHS vector by a random number between -1.0 and 1.0</span></span><br><span class="line">  <span class="built_in">C_DSCAL</span>(dim, <span class="built_in">dist</span>(mt), b.<span class="built_in">data</span>(), <span class="number">1</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;C_DSCAL done&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// Save matrix and RHS</span></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">A1</span><span class="params">(A)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">b1</span><span class="params">(b)</span></span>;</span><br><span class="line">  <span class="type">int</span> info;</span><br><span class="line">  info = <span class="built_in">C_DGESV</span>(dim, <span class="number">1</span>, A.<span class="built_in">data</span>(), dim, ipiv.<span class="built_in">data</span>(), b.<span class="built_in">data</span>(), dim);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;C_DGESV done&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;info is &quot;</span> &lt;&lt; info &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">double</span> eps = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dim; ++i) &#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dim; ++j)</span><br><span class="line">      sum += A1[i + j * dim] * b[j];</span><br><span class="line">    eps += std::<span class="built_in">abs</span>(b1[i] - sum);</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;check is &quot;</span> &lt;&lt; eps &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用C++11的随机库来生成-1.0到1.0之间的随机分布。<code>C_DSCAL</code>和<code>C_DGESV</code>分别是到BLAS和LAPACK库的接口。为了避免名称混淆，将在下面来进一步讨论CMake模块：</p>
<p>文件CxxBLAS.hpp用extern “C”封装链接BLAS:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fc_mangle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">DSCAL</span><span class="params">(<span class="type">int</span> *n, <span class="type">double</span> *alpha, <span class="type">double</span> *vec, <span class="type">int</span> *inc)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C_DSCAL</span><span class="params">(<span class="type">size_t</span> length, <span class="type">double</span> alpha, <span class="type">double</span> *vec, <span class="type">int</span> inc)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>对应的实现文件CxxBLAS.cpp:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CxxBLAS.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="comment">// see http://www.netlib.no/netlib/blas/dscal.f</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C_DSCAL</span><span class="params">(<span class="type">size_t</span> length, <span class="type">double</span> alpha, <span class="type">double</span> *vec, <span class="type">int</span> inc)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> big_blocks = (<span class="type">int</span>)(length / INT_MAX);</span><br><span class="line">  <span class="type">int</span> small_size = (<span class="type">int</span>)(length % INT_MAX);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> block = <span class="number">0</span>; block &lt;= big_blocks; block++) &#123;</span><br><span class="line">    <span class="type">double</span> *vec_s = &amp;vec[block * inc * (<span class="type">size_t</span>)INT_MAX];</span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> length_s = (block == big_blocks) ? small_size : INT_MAX;</span><br><span class="line">    ::<span class="built_in">DSCAL</span>(&amp;length_s, &amp;alpha, vec_s, &amp;inc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CxxLAPACK.hpp和CxxLAPACK.cpp为LAPACK调用执行相应的转换。</p>
<h3 id="具体实施-17"><a href="#具体实施-17" class="headerlink" title="具体实施"></a>具体实施</h3><p>对应的CMakeLists.txt包含以下构建块:</p>
<p>我们定义了CMake最低版本，项目名称和支持的语言:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">04</span> LANGUAGES CXX C Fortran)</span><br></pre></td></tr></table></figure></p>
<p>使用C++11标准:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>此外，我们验证Fortran和C/C++编译器是否能协同工作，并生成头文件，这个文件可以处理名称混乱。两个功能都由FortranCInterface模块提供:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FortranCInterface)</span><br><span class="line">FortranCInterface_VERIFY(CXX)</span><br><span class="line">FortranCInterface_HEADER(</span><br><span class="line">  fc_mangle.h</span><br><span class="line">  MACRO_NAMESPACE <span class="string">&quot;FC_&quot;</span></span><br><span class="line">  SYMBOLS DSCAL DGESV</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>然后，找到BLAS和LAPACK:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(BLAS REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(LAPACK REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>接下来，添加一个库，其中包含BLAS和LAPACK包装器的源代码，并链接到LAPACK_LIBRARIES，其中也包含BLAS_LIBRARIES:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">math</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">math</span></span><br><span class="line">  PRIVATE</span><br><span class="line">    CxxBLAS.cpp</span><br><span class="line">    CxxLAPACK.cpp</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">math</span></span><br><span class="line">  PUBLIC</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">math</span></span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="variable">$&#123;LAPACK_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>注意，目标的包含目录和链接库声明为PUBLIC，因此任何依赖于数学库的附加目标也将在其包含目录中。</p>
<p>最后，我们添加一个可执行目标并链接math：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(linear-algebra <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(linear-algebra</span><br><span class="line">  PRIVATE</span><br><span class="line">      linear-algebra.cpp</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(linear-algebra</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="keyword">math</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>配置时，我们可以关注相关的打印输出:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">...</span><br><span class="line">-- Detecting Fortran/C Interface</span><br><span class="line">-- Detecting Fortran/C Interface - Found GLOBAL and MODULE mangling</span><br><span class="line">-- Verifying Fortran/C Compiler Compatibility</span><br><span class="line">-- Verifying Fortran/C Compiler Compatibility - Success</span><br><span class="line">...</span><br><span class="line">-- Found BLAS: /usr/lib/libblas.so</span><br><span class="line">...</span><br><span class="line">-- A library with LAPACK API found.</span><br></pre></td></tr></table></figure></p>
<p>最后，构建并测试可执行文件:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br><span class="line">$ ./linear-algebra 1000</span><br><span class="line">C_DSCAL <span class="keyword">done</span></span><br><span class="line">C_DGESV <span class="keyword">done</span></span><br><span class="line">info is 0</span><br><span class="line">check is 1.54284e-10</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-17"><a href="#工作原理-17" class="headerlink" title="工作原理"></a>工作原理</h3><p>FindBLAS.cmake和FindLAPACK.cmake将在标准位置查找BLAS和LAPACK库。对于前者，该模块有SGEMM函数的Fortran实现，一般用于单精度矩阵乘积。对于后者，该模块有CHEEV函数的Fortran实现，用于计算复杂厄米矩阵的特征值和特征向量。查找在CMake内部，通过编译一个小程序来完成，该程序调用这些函数，并尝试链接到候选库。如果失败，则表示相应库不存于系统上。</p>
<p>生成机器码时，每个编译器都会处理符号混淆，不幸的是，这种操作并不通用，而与编译器相关。为了解决这个问题，我们使用FortranCInterface模块验证Fortran和C/C++能否混合编译，然后生成一个Fortran-C接口头文件fc_mangle.h，这个文件用来解决编译器性的问题。然后，必须将生成的fc_mann .h包含在接口头文件CxxBLAS.hpp和CxxLAPACK.hpp中。为了使用FortranCInterface，我们需要在LANGUAGES列表中添加C和Fortran支持。当然，也可以定义自己的预处理器定义，但是可移植性会差很多。</p>
<h2 id="检测OpenMP的并行环境"><a href="#检测OpenMP的并行环境" class="headerlink" title="检测OpenMP的并行环境"></a>检测OpenMP的并行环境</h2><p>本示例中，我们将展示如何编译一个包含OpenMP指令的程序(前提是使用一个支持OpenMP的编译器)。有许多支持OpenMP的Fortran、C和C++编译器。对于相对较新的CMake版本，为OpenMP提供了非常好的支持。本示例将展示如何在使用CMake 3.9或更高版本时，使用简单C++和Fortran程序来链接到OpenMP。</p>
<h3 id="准备工作-14"><a href="#准备工作-14" class="headerlink" title="准备工作"></a>准备工作</h3><p>C和C++程序可以通过包含omp.h头文件和链接到正确的库，来使用OpenMP功能。编译器将在性能关键部分之前添加预处理指令，并生成并行代码。在本示例中，我们将构建以下示例源代码(example.cpp)。这段代码从1到N求和，其中N作为命令行参数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;number of available processors: &quot;</span> &lt;&lt; <span class="built_in">omp_get_num_procs</span>()</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;number of threads: &quot;</span> &lt;&lt; <span class="built_in">omp_get_max_threads</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">auto</span> n = std::<span class="built_in">stol</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;we will form sum of numbers from 1 to &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// start timer</span></span><br><span class="line">  <span class="keyword">auto</span> t0 = <span class="built_in">omp_get_wtime</span>();</span><br><span class="line">  <span class="keyword">auto</span> s = <span class="number">0LL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+ : s)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    s += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// stop timer</span></span><br><span class="line">  <span class="keyword">auto</span> t1 = <span class="built_in">omp_get_wtime</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;sum: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;elapsed wall clock time: &quot;</span> &lt;&lt; t1 - t0 &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Fortran语言中，需要使用omp_lib模块并链接到库。在性能关键部分之前的代码注释中，可以再次使用并行指令。例如：F90需要包含以下内容:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> example</span><br><span class="line">  <span class="keyword">use</span> omp_lib</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">integer</span>(<span class="number">8</span>) :: i, n, s</span><br><span class="line">  <span class="keyword">character</span>(len=<span class="number">32</span>) :: arg</span><br><span class="line">  <span class="keyword">real</span>(<span class="number">8</span>) :: t0, t1</span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">&quot;number of available processors:&quot;</span>, omp_get_num_procs()</span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">&quot;number of threads:&quot;</span>, omp_get_max_threads()</span><br><span class="line">  <span class="keyword">call</span> <span class="built_in">get_command_argument</span>(<span class="number">1</span>, arg)</span><br><span class="line">  read(arg , *) n</span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">&quot;we will form sum of numbers from 1 to&quot;</span>, n</span><br><span class="line">  <span class="comment">! start timer</span></span><br><span class="line">  t0 = omp_get_wtime()</span><br><span class="line">  s = <span class="number">0</span></span><br><span class="line"><span class="comment">!$omp parallel do reduction(+:s)</span></span><br><span class="line">  <span class="keyword">do</span> i = <span class="number">1</span>, n</span><br><span class="line">  s = s + i</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment">! stop timer</span></span><br><span class="line">  t1 = omp_get_wtime()</span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">&quot;sum:&quot;</span>, s</span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">&quot;elapsed wall clock time (seconds):&quot;</span>, t1 - t0</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-18"><a href="#具体实施-18" class="headerlink" title="具体实施"></a>具体实施</h3><p>对于C++和Fortran的例子，CMakeLists.txt将遵循一个模板，该模板在这两种语言上很相似：</p>
<p>两者都定义了CMake最低版本、项目名称和语言(CXX或Fortran；我们将展示C++版本):<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.9</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">05</span> LANGUAGES CXX)</span><br></pre></td></tr></table></figure></p>
<p>使用C++11标准:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>调用find_package来搜索OpenMP:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenMP REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>最后，我们定义可执行目标，并链接到FindOpenMP模块提供的导入目标(在Fortran的情况下，我们链接到OpenMP::OpenMP_Fortran):<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(example example.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(example</span><br><span class="line">  PUBLIC</span><br><span class="line">      OpenMP::OpenMP_CXX</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>现在，可以配置和构建代码了:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br></pre></td></tr></table></figure></p>
<p>并行测试(在本例中使用了4个内核):<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./example 1000000000</span><br><span class="line">number of available processors: 4</span><br><span class="line">number of threads: 4</span><br><span class="line">we will form <span class="built_in">sum</span> of numbers from 1 to 1000000000</span><br><span class="line"><span class="built_in">sum</span>: 500000000500000000</span><br><span class="line">elapsed wall clock <span class="keyword">time</span>: 1.08343 seconds</span><br></pre></td></tr></table></figure></p>
<p>为了比较，我们可以重新运行这个例子，并将OpenMP线程的数量设置为1:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">env</span> OMP_NUM_THREADS=1 ./example 1000000000</span><br><span class="line">number of available processors: 4</span><br><span class="line">number of threads: 1</span><br><span class="line">we will form <span class="built_in">sum</span> of numbers from 1 to 1000000000</span><br><span class="line"><span class="built_in">sum</span>: 500000000500000000</span><br><span class="line">elapsed wall clock <span class="keyword">time</span>: 2.96427 seconds</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-18"><a href="#工作原理-18" class="headerlink" title="工作原理"></a>工作原理</h3><p>我们的示例很简单：编译代码，并运行在多个内核上时，我们会看到加速效果。加速效果并不是OMP_NUM_THREADS的倍数，不过本示例中并不关心，因为我们更关注的是如何使用CMake配置需要使用OpenMP的项目。我们发现链接到OpenMP非常简单，这要感谢FindOpenMP模块:</p>
<p>target_link_libraries(example<br>    PUBLIC<br>        OpenMP::OpenMP_CXX<br>    )<br>我们不关心编译标志或包含目录——这些设置和依赖项是在OpenMP::OpenMP_CXX中定义的(IMPORTED类型)。如第1章第3节中提到的，IMPORTED库是伪目标，它完全是我们自己项目的外部依赖项。要使用OpenMP，需要设置一些编译器标志，包括目录和链接库。所有这些都包含在OpenMP::OpenMP_CXX的属性上，并通过使用target_link_libraries命令传递给example。这使得在CMake中，使用库变得非常容易。我们可以使用cmake_print_properties命令打印接口的属性，该命令由CMakePrintHelpers.CMake模块提供:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CMakePrintHelpers)</span><br><span class="line">cmake_print_properties(</span><br><span class="line">    TARGETS</span><br><span class="line">        OpenMP::OpenMP_CXX</span><br><span class="line">    PROPERTIES</span><br><span class="line">        INTERFACE_COMPILE_OPTIONS</span><br><span class="line">        INTERFACE_INCLUDE_DIRECTORIES</span><br><span class="line">        INTERFACE_LINK_LIBRARIES</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p>
<p>所有属性都有INTERFACE_前缀，因为这些属性对所需目标，需要以接口形式提供，并且目标以接口的方式使用OpenMP。</p>
<p>对于低于3.9的CMake版本:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(example example.cpp)</span><br><span class="line"><span class="keyword">target_compile_options</span>(example</span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="variable">$&#123;OpenMP_CXX_FLAGS&#125;</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">set_target_properties</span>(example</span><br><span class="line">  PROPERTIES</span><br><span class="line">      LINK_FLAGS <span class="variable">$&#123;OpenMP_CXX_FLAGS&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<h2 id="检测MPI的并行环境"><a href="#检测MPI的并行环境" class="headerlink" title="检测MPI的并行环境"></a>检测MPI的并行环境</h2><p>本示例，将展示如何在系统上找到合适的MPI实现，从而编译一个简单的“Hello, World”MPI例程。</p>
<h3 id="准备工作-15"><a href="#准备工作-15" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Initialize the MPI environment. The two arguments to MPI Init are not</span></span><br><span class="line">  <span class="comment">// currently used by MPI implementations, but are there in case future</span></span><br><span class="line">  <span class="comment">// implementations might need the arguments.</span></span><br><span class="line">  <span class="built_in">MPI_Init</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// Get the number of processes</span></span><br><span class="line">  <span class="type">int</span> world_size;</span><br><span class="line">  <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;world_size);</span><br><span class="line">  <span class="comment">// Get the rank of the process</span></span><br><span class="line">  <span class="type">int</span> world_rank;</span><br><span class="line">  <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;world_rank);</span><br><span class="line">  <span class="comment">// Get the name of the processor</span></span><br><span class="line">  <span class="type">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];</span><br><span class="line">  <span class="type">int</span> name_len;</span><br><span class="line">  <span class="built_in">MPI_Get_processor_name</span>(processor_name, &amp;name_len);</span><br><span class="line">  <span class="comment">// Print off a hello world message</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello world from processor &quot;</span> &lt;&lt; processor_name &lt;&lt; <span class="string">&quot;, rank &quot;</span></span><br><span class="line">            &lt;&lt; world_rank &lt;&lt; <span class="string">&quot; out of &quot;</span> &lt;&lt; world_size &lt;&lt; <span class="string">&quot; processors&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// Finalize the MPI environment. No more MPI calls can be made after this</span></span><br><span class="line">  <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具体实施-19"><a href="#具体实施-19" class="headerlink" title="具体实施"></a>具体实施</h3><p>这个示例中，我们先查找MPI实现：库、头文件、编译器包装器和启动器。为此，我们将用到FindMPI.cmake标准CMake模块:</p>
<p>首先，定义了CMake最低版本、项目名称、支持的语言和语言标准:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.9</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">06</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后，调用find_package来定位MPI:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(MPI REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>与前面的配置类似，定义了可执行文件的的名称和相关源码，并链接到目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-mpi hello-mpi.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello-mpi</span><br><span class="line">  PUBLIC</span><br><span class="line">       MPI::MPI_CXX</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>配置和构建可执行文件:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">-- ...</span><br><span class="line">-- Found MPI_CXX: /usr/lib/openmpi/libmpi_cxx.so (found version <span class="string">&quot;3.1&quot;</span>)</span><br><span class="line">-- Found MPI: TRUE (found version <span class="string">&quot;3.1&quot;</span>)</span><br><span class="line">-- ...</span><br><span class="line">$ cmake --build .</span><br></pre></td></tr></table></figure></p>
<p>为了并行执行这个程序，我们使用mpirun启动器(本例中，启动了两个任务):<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -np 2 ./hello-mpi</span><br><span class="line">Hello world from processor larry, rank 1 out of 2 processors</span><br><span class="line">Hello world from processor larry, rank 0 out of 2 processors</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-19"><a href="#工作原理-19" class="headerlink" title="工作原理"></a>工作原理</h3><p>请记住，编译包装器是对MPI库编译器的封装。底层实现中，将会调用相同的编译器，并使用额外的参数(如成功构建并行程序所需的头文件包含路径和库)来扩充它。</p>
<p>编译和链接源文件时，包装器用了哪些标志？我们可以使用—showme选项来查看。要找出编译器的标志，我们可以这样使用:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mpicxx --showme:compile</span><br><span class="line">-pthread</span><br></pre></td></tr></table></figure></p>
<p>为了找出链接器标志，我们可以这样:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mpicxx --showme:<span class="built_in">link</span></span><br><span class="line">-pthread -Wl,-rpath -Wl,/usr/lib/openmpi -Wl,--enable-new-dtags -L/usr/lib/openmpi -lmpi_cxx -lmpi</span><br></pre></td></tr></table></figure></p>
<p>与之前的OpenMP配置类似，我们发现到MPI的链接非常简单，这要归功于FindMPI模块提供的目标:</p>
<p>正如在前面的配方中所讨论的，对于CMake版本低于3.9，需要更多的工作量:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-mpi hello-mpi.c)</span><br><span class="line"><span class="keyword">target_compile_options</span>(hello-mpi</span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="variable">$&#123;MPI_CXX_COMPILE_FLAGS&#125;</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_include_directories</span>(hello-mpi</span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="variable">$&#123;MPI_CXX_INCLUDE_PATH&#125;</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello-mpi</span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="variable">$&#123;MPI_CXX_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<h2 id="检测外部库-Ⅰ-使用pkg-config"><a href="#检测外部库-Ⅰ-使用pkg-config" class="headerlink" title="检测外部库:Ⅰ. 使用pkg-config"></a>检测外部库:Ⅰ. 使用pkg-config</h2><p>目前为止，我们已经讨论了两种检测外部依赖关系的方法:</p>
<p>使用CMake自带的find-module，但并不是所有的包在CMake的find模块都找得到。<br>使用<code>&lt;package&gt;Config.cmake,</code> <code>&lt;package&gt;ConfigVersion.cmake</code>和<code>&lt;package&gt;Targets.cmake</code>，这些文件由软件包供应商提供，并与软件包一起安装在标准位置的cmake文件夹下。</p>
<p>如果某个依赖项既不提供查找模块，也不提供供应商打包的CMake文件，该怎么办?在这种情况下，我们只有两个选择:</p>
<ul>
<li>依赖pkg-config程序，来找到系统上的包。这依赖于包供应商在.pc配置文件中，其中有关于发行包的元数据。</li>
<li>为依赖项编写自己的find-package模块。</li>
</ul>
<p>本示例中，将展示如何利用CMake中的pkg-config来定位ZeroMQ消息库。下一个示例中，将编写一个find模块，展示如何为ZeroMQ编写属于自己find模块。</p>
<h3 id="准备工作-16"><a href="#准备工作-16" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们构建的代码来自ZeroMQ手册 <a href="http://zguide.zeromq.org/page:all">http://zguide.zeromq.org/page:all</a> 的示例。由两个源文件hwserver.c和hwclient.c组成，这两个源文件将构建为两个独立的可执行文件。执行时，它们将打印“Hello, World”。</p>
<h3 id="具体实施-20"><a href="#具体实施-20" class="headerlink" title="具体实施"></a>具体实施</h3><p>这是一个C项目，我们将使用C99标准，逐步构建CMakeLists.txt文件:</p>
<p>声明一个C项目，并要求符合C99标准:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.6</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">09</span> LANGUAGES C)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用CMake附带的find-module，查找pkg-config。这里在find_package中传递了QUIET参数。只有在没有找到pkg-config时，CMake才会报错:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PkgConfig REQUIRED QUIET)</span><br></pre></td></tr></table></figure></p>
<p>找到pkg-config时，我们将使用pkg_search_module函数，以搜索任何附带包配置.pc文件的库或程序。该示例中，我们查找ZeroMQ库:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pkg_search_module(</span><br><span class="line">  ZeroMQ</span><br><span class="line">  REQUIRED</span><br><span class="line">      libzeromq libzmq lib0mq</span><br><span class="line">  IMPORTED_TARGET</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>如果找到ZeroMQ库，则打印状态消息:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">TARGET</span> PkgConfig::ZeroMQ)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Found ZeroMQ&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>然后，添加两个可执行目标，并链接到ZeroMQ。这将自动设置包括目录和链接库:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hwserver hwserver.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hwserver PkgConfig::ZeroMQ)</span><br><span class="line"><span class="keyword">add_executable</span>(hwclient hwclient.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hwclient PkgConfig::ZeroMQ)</span><br></pre></td></tr></table></figure></p>
<p>现在，我们可以配置和构建示例:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br></pre></td></tr></table></figure></p>
<p>在终端中，启动服务器，启动时会输出类似于本例的消息:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Current 0MQ version is 4.2.2</span><br></pre></td></tr></table></figure></p>
<p>然后，在另一个终端启动客户端，它将打印如下内容:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Connecting to hello world server…</span><br><span class="line">Sending Hello 0…</span><br><span class="line">Received World 0</span><br><span class="line">Sending Hello 1…</span><br><span class="line">Received World 1</span><br><span class="line">Sending Hello 2…</span><br></pre></td></tr></table></figure></p>
<p>当找到pkg-config时, CMake需要提供两个函数，来封装这个程序提供的功能:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkg_check_modules，查找传递列表中的所有模块(库和/或程序)</span><br><span class="line">pkg_search_module，要在传递的列表中找到第一个工作模块</span><br></pre></td></tr></table></figure></p>
<p>与find_package一样，这些函数接受REQUIRED和QUIET参数。更详细地说，我们对<code>pkg_search_module</code>的调用如下:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pkg_search_module(</span><br><span class="line">  ZeroMQ</span><br><span class="line">  REQUIRED</span><br><span class="line">      libzeromq libzmq lib0mq</span><br><span class="line">  IMPORTED_TARGET</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>这里，第一个参数是前缀，它将用于命名存储搜索ZeroMQ库结果的目标：PkgConfig::ZeroMQ。注意，我们需要为系统上的库名传递不同的选项：libzeromq、libzmq和lib0mq。这是因为不同的操作系统和包管理器，可为同一个包选择不同的名称。</p>
<p>NOTE:pkg_check_modules和pkg_search_module函数添加了IMPORTED_TARGET选项，并在CMake 3.6中定义导入目标的功能。3.6之前的版本，只定义了变量ZeroMQ_INCLUDE_DIRS(用于include目录)和ZeroMQ_LIBRARIES(用于链接库)，供后续使用。</p>
<h1 id="创建和运行测试"><a href="#创建和运行测试" class="headerlink" title="创建和运行测试"></a>创建和运行测试</h1><h2 id="创建一个简单的单元测试"><a href="#创建一个简单的单元测试" class="headerlink" title="创建一个简单的单元测试"></a>创建一个简单的单元测试</h2><p>CTest是CMake的测试工具，本示例中，我们将使用CTest进行单元测试。为了保持对CMake/CTest的关注，我们的测试代码会尽可能的简单。计划是编写和测试能够对整数求和的代码，示例代码只会对整数进行累加，不处理浮点数。</p>
<h2 id="准备工作-17"><a href="#准备工作-17" class="headerlink" title="准备工作"></a>准备工作</h2><p>代码示例由三个文件组成。实现源文件sum_integs.cpp对整数向量进行求和，并返回累加结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum_integers.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_integers</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; integers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : integers) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个示例是否是优雅的实现并不重要，接口以sum_integers的形式导出。接口在sum_integers.hpp文件中声明，详情如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_integers</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; integers)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>最后，main函数在main.cpp中定义，从argv[]中收集命令行参数，将它们转换成整数向量，调用sum_integers函数，并将结果打印到输出中:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum_integers.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// we assume all arguments are integers and we sum them up</span></span><br><span class="line"><span class="comment">// for simplicity we do not verify the type of arguments</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; integers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        integers.<span class="built_in">push_back</span>(std::<span class="built_in">stoi</span>(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="built_in">sum_integers</span>(integers);</span><br><span class="line">    std::cout &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试这段代码使用C++实现(test.cpp)，Bash shell脚本实现(test.sh)和Python脚本实现(test.py)，只要实现可以返回一个零或非零值，从而CMake可以解释为成功或失败。</p>
<p>C++例子(test.cpp)中，我们通过调用sum_integers来验证1 + 2 + 3 + 4 + 5 = 15：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum_integers.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> integers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sum_integers</span>(integers) == <span class="number">15</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Bash shell脚本调用可执行文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">EXECUTABLE=$<span class="number">1</span></span><br><span class="line">OUTPUT=$($EXECUTABLE <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$OUTPUT&quot;</span> = <span class="string">&quot;10&quot;</span> ]</span><br><span class="line">then</span><br><span class="line">    exit <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    exit <span class="number">1</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>此外，Python脚本调用可执行文件(使用—executable命令行参数传递)，并使用—short命令行参数执行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="comment"># test script expects the executable as argument</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--executable&#x27;</span>,</span><br><span class="line">                                         <span class="built_in">help</span>=<span class="string">&#x27;full path to executable&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--short&#x27;</span>,</span><br><span class="line">                                         default=<span class="literal">False</span>,</span><br><span class="line">                    action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;run a shorter test&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">execute_cpp_code</span>(<span class="params">integers</span>):</span><br><span class="line">    result = subprocess.check_output([args.executable] + integers)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(result)</span><br><span class="line"><span class="keyword">if</span> args.short:</span><br><span class="line">    <span class="comment"># we collect [1, 2, ..., 100] as a list of strings</span></span><br><span class="line">    result = execute_cpp_code([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>)])</span><br><span class="line">    <span class="keyword">assert</span> result == <span class="number">5050</span>, <span class="string">&#x27;summing up to 100 failed&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># we collect [1, 2, ..., 1000] as a list of strings</span></span><br><span class="line">    result = execute_cpp_code([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1001</span>)])</span><br><span class="line">    <span class="keyword">assert</span> result == <span class="number">500500</span>, <span class="string">&#x27;summing up to 1000 failed&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-21"><a href="#具体实施-21" class="headerlink" title="具体实施"></a>具体实施</h3><p>现在，我们将逐步描述如何为项目设置测试：</p>
<p>对于这个例子，我们需要C++11支持，可用的Python解释器，以及Bash shell:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED)</span><br><span class="line"><span class="keyword">find_program</span>(BASH_EXECUTABLE NAMES bash REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>然后，定义库及主要可执行文件的依赖关系，以及测试可执行文件：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># example library</span></span><br><span class="line"><span class="keyword">add_library</span>(sum_integers sum_integers.cpp)</span><br><span class="line"><span class="comment"># main code</span></span><br><span class="line"><span class="keyword">add_executable</span>(sum_up main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(sum_up sum_integers)</span><br><span class="line"><span class="comment"># testing binary</span></span><br><span class="line"><span class="keyword">add_executable</span>(cpp_test <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(cpp_test sum_integers)</span><br></pre></td></tr></table></figure></p>
<p>最后，打开测试功能并定义四个测试。最后两个测试， 调用相同的Python脚本，先没有任何命令行参数，再使用—short：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME bash_test</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;BASH_EXECUTABLE&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">test</span>.sh $&lt;TARGET_FILE:sum_up&gt;</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME cpp_test</span><br><span class="line">  <span class="keyword">COMMAND</span> $&lt;TARGET_FILE:cpp_test&gt;</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME python_test_long</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">test</span>.py --executable $&lt;TARGET_FILE:sum_up&gt;</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME python_test_short</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">test</span>.py --short --executable $&lt;TARGET_FILE:sum_up&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>现在，我们已经准备好配置和构建代码。先手动进行测试：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ./sum_up 1 2 3 4 5</span><br><span class="line">15</span><br></pre></td></tr></table></figure></p>
<p>然后，我们可以用ctest运行测试集：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ctest</span><br><span class="line"><span class="keyword">Test</span> <span class="keyword">project</span> /home/user/cmake-recipes/chapter-<span class="number">04</span>/recipe-<span class="number">01</span>/cxx-example/build</span><br><span class="line">Start <span class="number">1</span>: bash_test</span><br><span class="line"><span class="number">1</span>/<span class="number">4</span> <span class="keyword">Test</span> <span class="comment">#1: bash_test ........................ Passed 0.01 sec</span></span><br><span class="line">Start <span class="number">2</span>: cpp_test</span><br><span class="line"><span class="number">2</span>/<span class="number">4</span> <span class="keyword">Test</span> <span class="comment">#2: cpp_test ......................... Passed 0.00 sec</span></span><br><span class="line">Start <span class="number">3</span>: python_test_long</span><br><span class="line"><span class="number">3</span>/<span class="number">4</span> <span class="keyword">Test</span> <span class="comment">#3: python_test_long ................. Passed 0.06 sec</span></span><br><span class="line">Start <span class="number">4</span>: python_test_short</span><br><span class="line"><span class="number">4</span>/<span class="number">4</span> <span class="keyword">Test</span> <span class="comment">#4: python_test_short ................ Passed 0.05 sec</span></span><br><span class="line"><span class="number">100</span>% tests passed, <span class="number">0</span> tests failed out of <span class="number">4</span></span><br><span class="line">Total <span class="keyword">Test</span> time (real) = <span class="number">0.12</span> sec</span><br></pre></td></tr></table></figure></p>
<p>还应该尝试中断实现，以验证测试集是否能捕捉到更改。</p>
<h3 id="工作原理-20"><a href="#工作原理-20" class="headerlink" title="工作原理"></a>工作原理</h3><p>这里的两个关键命令：</p>
<ul>
<li>enable_testing()，测试这个目录和所有子文件夹(因为我们把它放在主CMakeLists.txt)。</li>
<li>add_test()，定义了一个新的测试，并设置测试名称和运行命令。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME cpp_test</span><br><span class="line">  <span class="keyword">COMMAND</span> $&lt;TARGET_FILE:cpp_test&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>上面的例子中，使用了生成器表达式:<code>$&lt;TARGET_FILE:cpp_test&gt;</code>。生成器表达式，是在生成构建系统生成时的表达式。此时，我们可以声明<code>$&lt;TARGET_FILE:cpp_test&gt;</code>变量，将使用cpp_test可执行目标的完整路径进行替换。</p>
<p>生成器表达式在测试时非常方便，因为不必显式地将可执行程序的位置和名称，可以硬编码到测试中。以一种可移植的方式实现这一点非常麻烦，因为可执行文件和可执行后缀(例如，Windows上是.exe后缀)的位置在不同的操作系统、构建类型和生成器之间可能有所不同。使用生成器表达式，我们不必显式地了解位置和名称。</p>
<p>也可以将参数传递给要运行的test命令，例如：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME python_test_short</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">test</span>.py --short --executable $&lt;TARGET_FILE:sum_up&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，我们按顺序运行测试，并展示如何缩短总测试时间并行执行测试(第8节)，执行测试用例的子集(第9节)。这里，可以自定义测试命令，可以以任何编程语言运行测试集。CTest关心的是，通过命令的返回码测试用例是否通过。CTest遵循的标准约定是，返回零意味着成功，非零返回意味着失败。可以返回零或非零的脚本，都可以做测试用例。</p>
<p>既然知道了如何定义和执行测试，那么了解如何诊断测试失败也很重要。为此，我们可以在代码中引入一个bug，让所有测试都失败:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Start <span class="number">1</span>: bash_test</span><br><span class="line"><span class="number">1</span>/<span class="number">4</span> <span class="keyword">Test</span> <span class="comment">#1: bash_test ........................***Failed 0.01 sec</span></span><br><span class="line">    Start <span class="number">2</span>: cpp_test</span><br><span class="line"><span class="number">2</span>/<span class="number">4</span> <span class="keyword">Test</span> <span class="comment">#2: cpp_test .........................***Failed 0.00 sec</span></span><br><span class="line">    Start <span class="number">3</span>: python_test_long</span><br><span class="line"><span class="number">3</span>/<span class="number">4</span> <span class="keyword">Test</span> <span class="comment">#3: python_test_long .................***Failed 0.06 sec</span></span><br><span class="line">    Start <span class="number">4</span>: python_test_short</span><br><span class="line"><span class="number">4</span>/<span class="number">4</span> <span class="keyword">Test</span> <span class="comment">#4: python_test_short ................***Failed 0.06 sec</span></span><br><span class="line"><span class="number">0</span>% tests passed, <span class="number">4</span> tests failed out of <span class="number">4</span></span><br><span class="line">Total <span class="keyword">Test</span> time (real) = <span class="number">0.13</span> sec</span><br><span class="line">The following tests FAILED:</span><br><span class="line"><span class="number">1</span> - bash_test (Failed)</span><br><span class="line"><span class="number">2</span> - cpp_test (Failed)</span><br><span class="line"><span class="number">3</span> - python_test_long (Failed)</span><br><span class="line"><span class="number">4</span> - python_test_short (Failed)</span><br><span class="line">Errors <span class="keyword">while</span> running CTest</span><br></pre></td></tr></table></figure></p>
<p>如果我们想了解更多，可以查看文件test/Temporary/lasttestsfailure.log。这个文件包含测试命令的完整输出，并且在分析阶段，要查看的第一个地方。使用以下CLI开关，可以从CTest获得更详细的测试输出：</p>
<ul>
<li><code>--output-on-failure</code>:将测试程序生成的任何内容打印到屏幕上，以免测试失败。</li>
<li><code>-v</code>:将启用测试的详细输出。</li>
<li><code>-vv</code>:启用更详细的输出。</li>
</ul>
<p>CTest提供了一个非常方快捷的方式，可以重新运行以前失败的测试；要使用的CLI开关是—rerun-failed，在调试期间非常有用。</p>
<h3 id="更多信息-7"><a href="#更多信息-7" class="headerlink" title="更多信息"></a>更多信息</h3><p>考虑以下定义:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME python_test_long</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">test</span>.py --executable $&lt;TARGET_FILE:sum_up&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>前面的定义可以通过显式指定脚本运行的WORKING_DIRECTORY重新表达，如下:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME python_test_long</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="keyword">test</span>.py --executable $&lt;TARGET_FILE:sum_up&gt;</span><br><span class="line">  WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>测试名称可以包含/字符，按名称组织相关测试也很有用，例如：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME python/long</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="keyword">test</span>.py --executable $&lt;TARGET_FILE:sum_up&gt;</span><br><span class="line">  WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>有时候，我们需要为测试脚本设置环境变量。这可以通过set_tests_properties实现:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_tests_properties</span>(python_test</span><br><span class="line">  PROPERTIES</span><br><span class="line">    ENVIRONMENT</span><br><span class="line">      ACCOUNT_MODULE_PATH=<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">      ACCOUNT_HEADER_FILE=<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/account/account.h</span><br><span class="line">      ACCOUNT_LIBRARY_FILE=$&lt;TARGET_FILE:account&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>这种方法在不同的平台上并不总可行，CMake提供了解决这个问题的方法。下面的代码片段与上面给出的代码片段相同，在执行实际的Python测试脚本之前，通过CMAKE_COMMAND调用CMake来预先设置环境变量:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME</span><br><span class="line">      python_test</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E env</span><br><span class="line">    ACCOUNT_MODULE_PATH=<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">    ACCOUNT_HEADER_FILE=<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/account/account.h</span><br><span class="line">    ACCOUNT_LIBRARY_FILE=$&lt;TARGET_FILE:account&gt;</span><br><span class="line">    <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/account/<span class="keyword">test</span>.py</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>同样，要注意使用生成器表达式<code>$&lt;TARGET_FILE:account&gt;</code>来传递库文件的位置。</p>
<p>我们已经使用ctest命令执行测试，CMake还将为生成器创建目标(Unix Makefile生成器为make test，Ninja工具为ninja test，或者Visual Studio为RUN_TESTS)。这意味着，还有另一种(几乎)可移植的方法来运行测试：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build . --target <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用Google-Test库进行单元测试"><a href="#使用Google-Test库进行单元测试" class="headerlink" title="使用Google Test库进行单元测试"></a>使用Google Test库进行单元测试</h2><p>本示例中，我们将演示如何在CMake的帮助下使用Google Test框架实现单元测试。与前一个配置相比，Google Test框架不仅仅是一个头文件，也是一个库，包含两个需要构建和链接的文件。可以将它们与我们的代码项目放在一起，但是为了使代码项目更加轻量级，我们将选择在配置时，下载一个定义良好的Google Test，然后构建框架并链接它。我们将使用较新的FetchContent模块(从CMake版本3.11开始可用)。</p>
<h3 id="准备工作-18"><a href="#准备工作-18" class="headerlink" title="准备工作"></a>准备工作</h3><p>main.cpp、sum_integers.cpp和sum_integers.hpp与之前相同，修改test.cpp:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum_integers.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST</span>(example, sum_zero) &#123;</span><br><span class="line">  <span class="keyword">auto</span> integers = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">-3</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> result = <span class="built_in">sum_integers</span>(integers);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(result, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST</span>(example, sum_five) &#123;</span><br><span class="line">  <span class="keyword">auto</span> integers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> result = <span class="built_in">sum_integers</span>(integers);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(result, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上面的代码所示，我们显式地将gtest.h，而不将其他Google Test源放在代码项目存储库中，会在配置时使用FetchContent模块下载它们。</p>
<h3 id="具体实施-22"><a href="#具体实施-22" class="headerlink" title="具体实施"></a>具体实施</h3><p>下面的步骤描述了如何设置CMakeLists.txt，使用GTest编译可执行文件及其相应的测试:</p>
<p>与前两个示例相比，CMakeLists.txt的开头基本没有变化，CMake 3.11才能使用FetchContent模块:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set minimum cmake version</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.11</span> FATAL_ERROR)</span><br><span class="line"><span class="comment"># project name and language</span></span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">03</span> LANGUAGES CXX)</span><br><span class="line"><span class="comment"># require C++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS <span class="keyword">ON</span>)</span><br><span class="line"><span class="comment"># example library</span></span><br><span class="line"><span class="keyword">add_library</span>(sum_integers sum_integers.cpp)</span><br><span class="line"><span class="comment"># main code</span></span><br><span class="line"><span class="keyword">add_executable</span>(sum_up main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(sum_up sum_integers)</span><br></pre></td></tr></table></figure></p>
<p>然后引入一个if，检查ENABLE_UNIT_TESTS。默认情况下，它为ON，但有时需要设置为OFF，以免在没有网络连接时，也能使用Google Test:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span>(ENABLE_UNIT_TESTS <span class="string">&quot;Enable unit tests&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Enable testing: $&#123;ENABLE_UNIT_TESTS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(ENABLE_UNIT_TESTS)</span><br><span class="line">    <span class="comment"># all the remaining CMake code will be placed here</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>if内部包含FetchContent模块，声明要获取的新内容，并查询其属性:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  googletest</span><br><span class="line">  GIT_REPOSITORY https://github.com/google/googletest.git</span><br><span class="line">  GIT_TAG release-<span class="number">1.8</span>.<span class="number">0</span></span><br><span class="line">)</span><br><span class="line">FetchContent_GetProperties(googletest)</span><br></pre></td></tr></table></figure></p>
<p>如果内容还没有获取到，将尝试获取并配置它。这需要添加几个可以链接的目标。本例中，我们对gtest_main感兴趣。该示例还包含一些变通方法，用于使用在Visual Studio下的编译:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> googletest_POPULATED)</span><br><span class="line">  FetchContent_Populate(googletest)</span><br><span class="line">  <span class="comment"># Prevent GoogleTest from overriding our compiler/linker options</span></span><br><span class="line">  <span class="comment"># when building with Visual Studio</span></span><br><span class="line">  <span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">  <span class="comment"># Prevent GoogleTest from using PThreads</span></span><br><span class="line">  <span class="keyword">set</span>(gtest_disable_pthreads <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">  <span class="comment"># adds the targers: gtest, gtest_main, gmock, gmock_main</span></span><br><span class="line">  <span class="keyword">add_subdirectory</span>(</span><br><span class="line">    <span class="variable">$&#123;googletest_SOURCE_DIR&#125;</span></span><br><span class="line">    <span class="variable">$&#123;googletest_BINARY_DIR&#125;</span></span><br><span class="line">    )</span><br><span class="line">  <span class="comment"># Silence std::tr1 warning on MSVC</span></span><br><span class="line">  <span class="keyword">if</span>(MSVC)</span><br><span class="line">    <span class="keyword">foreach</span>(_tgt gtest gtest_main gmock gmock_main)</span><br><span class="line">      <span class="keyword">target_compile_definitions</span>(<span class="variable">$&#123;_tgt&#125;</span></span><br><span class="line">        PRIVATE</span><br><span class="line">            <span class="string">&quot;_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING&quot;</span></span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">endforeach</span>()</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>然后，使用target_sources和target_link_libraries命令，定义cpp_test可执行目标并指定它的源文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(cpp_test <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(cpp_test</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="keyword">test</span>.cpp</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(cpp_test</span><br><span class="line">  PRIVATE</span><br><span class="line">    sum_integers</span><br><span class="line">    gtest_main</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，使用enable_test和add_test命令来定义单元测试:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME google_test</span><br><span class="line">  <span class="keyword">COMMAND</span> $&lt;TARGET_FILE:cpp_test&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>现在，准备配置、构建和测试项目:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ctest</span><br><span class="line">Test project /home/user/cmake-cookbook/chapter-04/recipe-03/cxx-example/build</span><br><span class="line">    Start 1: google_test</span><br><span class="line">1/1 Test <span class="comment">#1: google_test ...................... Passed 0.00 sec</span></span><br><span class="line">100% tests passed, 0 tests failed out of 1</span><br><span class="line">Total Test <span class="keyword">time</span> (real) = 0.00 sec</span><br></pre></td></tr></table></figure></p>
<p>可以直接运行cpp_test:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./cpp_test</span><br><span class="line">[==========] Running 2 tests from 1 <span class="built_in">test</span> <span class="keyword">case</span>.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 2 tests from example</span><br><span class="line">[ RUN ] example.sum_zero</span><br><span class="line">[ OK ] example.sum_zero (0 ms)</span><br><span class="line">[ RUN ] example.sum_five</span><br><span class="line">[ OK ] example.sum_five (0 ms)</span><br><span class="line">[----------] 2 tests from example (0 ms total)</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 2 tests from 1 <span class="built_in">test</span> <span class="keyword">case</span> ran. (0 ms total)</span><br><span class="line">[ PASSED ] 2 tests.</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-21"><a href="#工作原理-21" class="headerlink" title="工作原理"></a>工作原理</h3><p>FetchContent模块支持通过ExternalProject模块，在配置时填充内容，并在其3.11版本中成为CMake的标准部分。而ExternalProject_Add()在构建时(见第8章)进行下载操作，这样FetchContent模块使得构建可以立即进行，这样获取的主要项目和外部项目(在本例中为Google Test)仅在第一次执行CMake时调用，使用add_subdirectory可以嵌套。</p>
<p>为了获取Google Test，首先声明外部内容:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">    googletest</span><br><span class="line">  GIT_REPOSITORY https://github.com/google/googletest.git</span><br><span class="line">  GIT_TAG release-<span class="number">1.8</span>.<span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>本例中，我们获取了一个带有特定标记的Git库(release-1.8.0)，但是我们也可以从Subversion、Mercurial或HTTP(S)源获取一个外部项目。有关可用选项，可参考相应的ExternalProject_Add命令的选项，网址是<a href="https://cmake.org/cmake/help/v3.11/module/ExternalProject.html">https://cmake.org/cmake/help/v3.11/module/ExternalProject.html</a> 。</p>
<p>调用FetchContent_Populate()之前，检查是否已经使用FetchContent_GetProperties()命令处理了内容填充；否则，调用FetchContent_Populate()超过一次后，就会抛出错误。</p>
<p>FetchContent_Populate(googletest)用于填充源并定义googletest_SOURCE_DIR和googletest_BINARY_DIR，可以使用它们来处理Google Test项目(使用add_subdirectory()，因为它恰好也是一个CMake项目):<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(</span><br><span class="line">  <span class="variable">$&#123;googletest_SOURCE_DIR&#125;</span></span><br><span class="line">  <span class="variable">$&#123;googletest_BINARY_DIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>前面定义了以下目标：gtest、gtest_main、gmock和gmock_main。这个配置中，作为单元测试示例的库依赖项，我们只对gtest_main目标感兴趣：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(cpp_test</span><br><span class="line">  PRIVATE</span><br><span class="line">    sum_integers</span><br><span class="line">    gtest_main</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>构建代码时，可以看到如何正确地对Google Test进行配置和构建。有时，我们希望升级到更新的Google Test版本，这时需要更改的唯一一行就是详细说明GIT_TAG的那一行。</p>
<h2 id="使用动态分析来检测内存缺陷"><a href="#使用动态分析来检测内存缺陷" class="headerlink" title="使用动态分析来检测内存缺陷"></a>使用动态分析来检测内存缺陷</h2><p>内存缺陷：写入或读取越界，或者内存泄漏(已分配但从未释放的内存)，会产生难以跟踪的bug，最好尽早将它们检查出来。Valgrind( <a href="http://valgrind.org">http://valgrind.org</a> )是一个通用的工具，用来检测内存缺陷和内存泄漏。本节中，我们将在使用CMake/CTest测试时使用Valgrind对内存问题进行警告。</p>
<h3 id="准备工作-19"><a href="#准备工作-19" class="headerlink" title="准备工作"></a>准备工作</h3><p>对于这个配置，需要三个文件。第一个是测试的实现(我们可以调用文件leaky_implementation.cpp):<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leaky_implementation.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">do_some_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// we allocate an array</span></span><br><span class="line">  <span class="type">double</span> *my_array = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">1000</span>];</span><br><span class="line">  <span class="comment">// do some work</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// we forget to deallocate it</span></span><br><span class="line">  <span class="comment">// delete[] my_array;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还需要相应的头文件(leaky_implementation.hpp):<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>并且，需要测试文件(test.cpp):<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leaky_implementation.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> return_code = <span class="built_in">do_some_work</span>();</span><br><span class="line">  <span class="keyword">return</span> return_code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们希望测试通过，因为return_code硬编码为0。这里我们也期望检测到内存泄漏，因为my_array没有释放。</p>
<h3 id="具体实施-23"><a href="#具体实施-23" class="headerlink" title="具体实施"></a>具体实施</h3><p>下面展示了如何设置CMakeLists.txt来执行代码动态分析:</p>
<p>我们首先定义CMake最低版本、项目名称、语言、目标和依赖关系:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">05</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">add_library</span>(example_library leaky_implementation.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(cpp_test <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(cpp_test example_library)</span><br></pre></td></tr></table></figure></p>
<p>然后，定义测试目标，还定义了MEMORYCHECK_COMMAND:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_program</span>(MEMORYCHECK_COMMAND NAMES valgrind)</span><br><span class="line"><span class="keyword">set</span>(MEMORYCHECK_COMMAND_OPTIONS <span class="string">&quot;--trace-children=yes --leak-check=full&quot;</span>)</span><br><span class="line"><span class="comment"># add memcheck test action</span></span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME cpp_test</span><br><span class="line">  <span class="keyword">COMMAND</span> $&lt;TARGET_FILE:cpp_test&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>运行测试集，报告测试通过情况，如下所示:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ctest</span><br><span class="line"><span class="keyword">Test</span> <span class="keyword">project</span> /home/user/cmake-recipes/chapter-<span class="number">04</span>/recipe-<span class="number">05</span>/cxx-example/build</span><br><span class="line">Start <span class="number">1</span>: cpp_test</span><br><span class="line"><span class="number">1</span>/<span class="number">1</span> <span class="keyword">Test</span> <span class="comment">#1: cpp_test ......................... Passed 0.00 sec</span></span><br><span class="line"><span class="number">100</span>% tests passed, <span class="number">0</span> tests failed out of <span class="number">1</span></span><br><span class="line">Total <span class="keyword">Test</span> time (real) = <span class="number">0.00</span> sec</span><br></pre></td></tr></table></figure></p>
<p>现在，我们希望检查内存缺陷，可以观察到被检测到的内存泄漏:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ctest -T memcheck</span><br><span class="line">Site: myhost</span><br><span class="line">Build name: Linux-c++</span><br><span class="line">Create new tag: <span class="number">20171127</span>-<span class="number">1717</span> - Experimental</span><br><span class="line">Memory check <span class="keyword">project</span> /home/user/cmake-recipes/chapter-<span class="number">04</span>/recipe-<span class="number">05</span>/cxx-example/build</span><br><span class="line">Start <span class="number">1</span>: cpp_test</span><br><span class="line"><span class="number">1</span>/<span class="number">1</span> MemCheck <span class="comment">#1: cpp_test ......................... Passed 0.40 sec</span></span><br><span class="line"><span class="number">100</span>% tests passed, <span class="number">0</span> tests failed out of <span class="number">1</span></span><br><span class="line">Total <span class="keyword">Test</span> time (real) = <span class="number">0.40</span> sec</span><br><span class="line">-- Processing memory checking output:</span><br><span class="line"><span class="number">1</span>/<span class="number">1</span> MemCheck: <span class="comment">#1: cpp_test ......................... Defects: 1</span></span><br><span class="line">MemCheck log files can be found here: ( * corresponds to <span class="keyword">test</span> number)</span><br><span class="line">/home/user/cmake-recipes/chapter-<span class="number">04</span>/recipe-<span class="number">05</span>/cxx-example/build/Testing/Temporary/MemoryChecker.*.log</span><br><span class="line">Memory checking results:</span><br><span class="line">Memory Leak - <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>最后一步，应该尝试修复内存泄漏，并验证ctest -T memcheck没有报告错误。</p>
<h3 id="工作原理-22"><a href="#工作原理-22" class="headerlink" title="工作原理"></a>工作原理</h3><p>使用<code>find_program(MEMORYCHECK_COMMAND NAMES valgrind)</code>查找valgrind，并将<code>MEMORYCHECK_COMMAND</code>设置为其绝对路径。我们显式地包含CTest模块来启用memcheck测试操作，可以使用CTest -T memcheck来启用这个操作。此外，使用<code>set(MEMORYCHECK_COMMAND_OPTIONS &quot;--trace-children=yes --leak-check=full&quot;)</code>，将相关参数传递给Valgrind。内存检查会创建一个日志文件，该文件可用于详细记录内存缺陷信息。</p>
<h1 id="配置时和构建时的操作"><a href="#配置时和构建时的操作" class="headerlink" title="配置时和构建时的操作"></a>配置时和构建时的操作</h1><p>我们将学习如何在配置和构建时，执行自定义操作。先简单回顾一下，与CMake工作流程相关的时序:</p>
<ol>
<li><strong>CMake时</strong>或<strong>构建时</strong>：CMake正在运行，并处理项目中的<code>CMakeLists.txt</code>文件。</li>
<li><strong>生成时</strong>：生成构建工具(如Makefile或Visual Studio项目文件)。</li>
<li><strong>构建时</strong>：由CMake生成相应平台的原生构建脚本，在脚本中调用原生工具构建。此时，将调用编译器在特定的构建目录中构建目标(可执行文件和库)。</li>
<li><strong>CTest时</strong>或<strong>测试时</strong>：运行测试套件以检查目标是否按预期执行。</li>
<li><strong>CDash时</strong>或<strong>报告时</strong>：当测试结果上传到仪表板上，与其他开发人员共享测试报告。</li>
<li><strong>安装时</strong>：当目标、源文件、可执行程序和库，从构建目录安装到相应位置。</li>
<li><strong>CPack时</strong>或<strong>打包时</strong>：将项目打包用以分发时，可以是源码，也可以是二进制。</li>
<li><strong>包安装时</strong>：新生成的包在系统范围内安装。</li>
</ol>
<h2 id="使用平台无关的文件操作"><a href="#使用平台无关的文件操作" class="headerlink" title="使用平台无关的文件操作"></a>使用平台无关的文件操作</h2><p>有些项目构建时，可能需要与平台的文件系统进行交互。也就是检查文件是否存在、创建新文件来存储临时信息、创建或提取打包文件等等。使用CMake不仅能够在不同的平台上生成构建系统，还能够在不复杂的逻辑情况下，进行文件操作，从而独立于操作系统。本示例将展示，如何以可移植的方式下载库文件。</p>
<h3 id="准备工作-20"><a href="#准备工作-20" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们将展示如何提取Eigen库文件，并使用提取的源文件编译我们的项目。这个示例中，将重用第3章第7节的线性代数例子linear-algebra.cpp，用来检测外部库和程序、检测特征库。这里，假设已经包含Eigen库文件，已在项目构建前下载。</p>
<h3 id="具体实施-24"><a href="#具体实施-24" class="headerlink" title="具体实施"></a>具体实施</h3><p>项目需要解压缩Eigen打包文件，并相应地为目标设置包含目录:</p>
<p>首先，使能C++11项目:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们将自定义目标添加到构建系统中，自定义目标将提取构建目录中的库文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(unpack-eigen</span><br><span class="line">  ALL</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E tar xzf <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/eigen-eigen-<span class="number">5</span>a0156e40feb.tar.gz</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E rename eigen-eigen-<span class="number">5</span>a0156e40feb eigen-<span class="number">3.3</span>.<span class="number">4</span></span><br><span class="line">  WORKING_DIRECTORY</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  COMMENT</span><br><span class="line">      <span class="string">&quot;Unpacking Eigen3 in $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/eigen-3.3.4&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>为源文件添加了一个可执行目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(linear-algebra linear-algebra.cpp)</span><br></pre></td></tr></table></figure></p>
<p>由于源文件的编译依赖于Eigen头文件，需要显式地指定可执行目标对自定义目标的依赖关系:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_dependencies</span>(linear-algebra unpack-eigen)</span><br></pre></td></tr></table></figure></p>
<p>最后，指定包含哪些目录:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(linear-algebra</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/eigen-<span class="number">3.3</span>.<span class="number">4</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-23"><a href="#工作原理-23" class="headerlink" title="工作原理"></a>工作原理</h3><p>细看add_custom_target这个命令：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(unpack-eigen</span><br><span class="line">  ALL</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E tar xzf <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/eigen-eigen-<span class="number">5</span>a0156e40feb.tar.gz</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E rename eigen-eigen-<span class="number">5</span>a0156e40feb eigen-<span class="number">3.3</span>.<span class="number">4</span></span><br><span class="line">  WORKING_DIRECTORY</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  COMMENT</span><br><span class="line">      <span class="string">&quot;Unpacking Eigen3 in $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/eigen-3.3.4&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>构建系统中引入了一个名为unpack-eigen的目标。因为我们传递了ALL参数，目标将始终被执行。COMMAND参数指定要执行哪些命令。本例中，我们希望提取存档并将提取的目录重命名为egan -3.3.4，通过以下两个命令实现:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E tar xzf <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/eigen-eigen-</span><br><span class="line">5a0156e40feb.tar.gz</span><br><span class="line"><span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E rename eigen-eigen-5a0156e40feb eigen-3.3.4</span><br></pre></td></tr></table></figure></p>
<p>注意，使用-E标志调用CMake命令本身来执行实际的工作。对于许多常见操作，CMake实现了一个对所有操作系统都通用的接口，这使得构建系统独立于特定的平台。add_custom_target命令中的下一个参数是工作目录。我们的示例中，它对应于构建目录：CMAKE_CURRENT_BINARY_DIR。最后一个参数COMMENT，用于指定CMake在执行自定义目标时输出什么样的消息。</p>
<h2 id="配置时运行自定义命令"><a href="#配置时运行自定义命令" class="headerlink" title="配置时运行自定义命令"></a>配置时运行自定义命令</h2><p>运行CMake生成构建系统，从而指定原生构建工具必须执行哪些命令，以及按照什么顺序执行。我们已经了解了CMake如何在配置时运行许多子任务，以便找到工作的编译器和必要的依赖项。本示例中，我们将讨论如何使用execute_process命令在配置时运行定制化命令。</p>
<h3 id="具体实施-25"><a href="#具体实施-25" class="headerlink" title="具体实施"></a>具体实施</h3><p>第3章第3节中，我们已经展示了execute_process查找Python模块NumPy时的用法。本例中，我们将使用execute_process命令来确定，是否存在特定的Python模块(本例中为Python CFFI)，如果存在，我们在进行版本确定:</p>
<p>对于这个简单的例子，不需要语言支持:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">02</span> LANGUAGES NONE)</span><br></pre></td></tr></table></figure></p>
<p>我们要求Python解释器执行一个简短的代码片段，因此，需要使用find_package来查找解释器：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>然后，调用execute_process来运行一个简短的Python代码段；下一节中，我们将更详细地讨论这个命令:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># this is set as variable to prepare</span></span><br><span class="line"><span class="comment"># for abstraction using loops or functions</span></span><br><span class="line"><span class="keyword">set</span>(_module_name <span class="string">&quot;cffi&quot;</span>)</span><br><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;import $&#123;_module_name&#125;; print($&#123;_module_name&#125;.__version__)&quot;</span></span><br><span class="line">  OUTPUT_VARIABLE _stdout</span><br><span class="line">  ERROR_VARIABLE _stderr</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  ERROR_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>然后，打印结果：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_stderr <span class="keyword">MATCHES</span> <span class="string">&quot;ModuleNotFoundError&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Module $&#123;_module_name&#125; not found&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Found module $&#123;_module_name&#125; v$&#123;_stdout&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>下面是一个配置示例(假设Python CFFI包安装在相应的Python环境中):<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">-- Found PythonInterp: /home/user/cmake-cookbook/chapter-05/recipe-02/example/venv/bin/python (found version <span class="string">&quot;3.6.5&quot;</span>)</span><br><span class="line">-- Found module cffi v1.11.5</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-24"><a href="#工作原理-24" class="headerlink" title="工作原理"></a>工作原理</h3><p>execute_process命令将从当前正在执行的CMake进程中派生一个或多个子进程，从而提供了在配置项目时运行任意命令的方法。可以在一次调用execute_process时执行多个命令。但请注意，每个命令的输出将通过管道传输到下一个命令中。该命令接受多个参数:</p>
<ul>
<li>WORKING_DIRECTORY，指定应该在哪个目录中执行命令。</li>
<li>RESULT_VARIABLE将包含进程运行的结果。这要么是一个整数，表示执行成功，要么是一个带有错误条件的字符串。</li>
<li>OUTPUT_VARIABLE和ERROR_VARIABLE将包含执行命令的标准输出和标准错误。由于命令的输出是通过管道传输的，因此只有最后一个命令的标准输出才会保存到OUTPUT_VARIABLE中。</li>
<li>INPUT_FILE指定标准输入重定向的文件名</li>
<li>OUTPUT_FILE指定标准输出重定向的文件名</li>
<li>ERROR_FILE指定标准错误输出重定向的文件名</li>
</ul>
<p>设置OUTPUT_QUIET和ERROR_QUIET后，CMake将静默地忽略标准输出和标准错误。</p>
<p>设置OUTPUT_STRIP_TRAILING_WHITESPACE，可以删除运行命令的标准输出中的任何尾随空格</p>
<p>设置ERROR_STRIP_TRAILING_WHITESPACE，可以删除运行命令的错误输出中的任何尾随空格。</p>
<p>有了这些了解这些参数，回到我们的例子当中:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(_module_name <span class="string">&quot;cffi&quot;</span>)</span><br><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;import $&#123;_module_name&#125;; print($&#123;_module_name&#125;.__version__)&quot;</span></span><br><span class="line">  OUTPUT_VARIABLE _stdout</span><br><span class="line">  ERROR_VARIABLE _stderr</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  ERROR_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">if</span>(_stderr <span class="keyword">MATCHES</span> <span class="string">&quot;ModuleNotFoundError&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Module $&#123;_module_name&#125; not found&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Found module $&#123;_module_name&#125; v$&#123;_stdout&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>该命令检查<code>python -c &quot;import cffi; print(cffi.__version__)&quot;</code>的输出。如果没有找到模块，<code>_stderr</code>将包含ModuleNotFoundError，我们将在if语句中对其进行检查。本例中，我们将打印Module cffi not found。如果导入成功，Python代码将打印模块的版本，该模块通过管道输入<code>_stdout</code>，这样就可以打印如下内容:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Found module $&#123;_module_name&#125; v$&#123;_stdout&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="构建时运行自定义命令-Ⅰ-使用add-custom-command"><a href="#构建时运行自定义命令-Ⅰ-使用add-custom-command" class="headerlink" title="构建时运行自定义命令:Ⅰ. 使用add_custom_command"></a>构建时运行自定义命令:Ⅰ. 使用add_custom_command</h2><p>项目的构建目标取决于命令的结果，这些命令只能在构建系统生成完成后的构建执行。CMake提供了三个选项来在构建时执行自定义命令:</p>
<ul>
<li>使用add_custom_command编译目标，生成输出文件。</li>
<li>add_custom_target的执行没有输出。</li>
<li>构建目标前后，add_custom_command的执行可以没有输出。</li>
</ul>
<p>这三个选项强制执行特定的语义，并且不可互换。接下来的三个示例将演示具体的用法。</p>
<h3 id="准备工作-21"><a href="#准备工作-21" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们将重用第3章第4节中的C++示例，以说明如何使用add_custom_command的第一个选项。代码示例中，我们了解了现有的BLAS和LAPACK库，并编译了一个很小的C++包装器库，以调用线性代数的Fortran实现。</p>
<p>我们将把代码分成两部分。linear-algebra.cpp的源文件与第3章、第4章没有区别，并且将包含线性代数包装器库的头文件和针对编译库的链接。源代码将打包到一个压缩的tar存档文件中，该存档文件随示例项目一起提供。存档文件将在构建时提取，并在可执行文件生成之前，编译线性代数的包装器库。</p>
<h3 id="具体实施-26"><a href="#具体实施-26" class="headerlink" title="具体实施"></a>具体实施</h3><p>CMakeLists.txt必须包含一个自定义命令，来提取线性代数包装器库的源代码：</p>
<p>从CMake最低版本、项目名称和支持语言的定义开始:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">03</span> LANGUAGES CXX Fortran)</span><br></pre></td></tr></table></figure></p>
<p>选择C++11标准:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后，在系统上查找BLAS和LAPACK库:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(BLAS REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(LAPACK REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>声明一个变量wrap_BLAS_LAPACK_sources来保存wrap_BLAS_LAPACK.tar.gz压缩包文件的名称:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(wrap_BLAS_LAPACK_sources</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxBLAS.hpp</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxBLAS.cpp</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxLAPACK.hpp</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxLAPACK.cpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>声明自定义命令来提取wrap_BLAS_LAPACK.tar.gz压缩包，并更新提取文件的时间戳。注意这个<code>wrap_BLAS_LAPACK_sources</code>变量的预期输出:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT</span><br><span class="line">      <span class="variable">$&#123;wrap_BLAS_LAPACK_sources&#125;</span></span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E tar xzf <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/wrap_BLAS_LAPACK.tar.gz</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E touch <span class="variable">$&#123;wrap_BLAS_LAPACK_sources&#125;</span></span><br><span class="line">  WORKING_DIRECTORY</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  DEPENDS</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/wrap_BLAS_LAPACK.tar.gz</span><br><span class="line">  COMMENT</span><br><span class="line">      <span class="string">&quot;Unpacking C++ wrappers for BLAS/LAPACK&quot;</span></span><br><span class="line">  VERBATIM</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>接下来，添加一个库目标，源文件是新解压出来的:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">math</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">math</span></span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxBLAS.cpp</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxLAPACK.cpp</span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxBLAS.hpp</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxLAPACK.hpp</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">math</span></span><br><span class="line">  INTERFACE</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">math</span></span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="variable">$&#123;LAPACK_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，添加linear-algebra可执行目标。可执行目标链接到库:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(linear-algebra linear-algebra.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(linear-algebra</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="keyword">math</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>我们配置、构建和执行示例:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ./linear-algebra 1000</span><br><span class="line">C_DSCAL <span class="keyword">done</span></span><br><span class="line">C_DGESV <span class="keyword">done</span></span><br><span class="line">info is 0</span><br><span class="line">check is 4.35597e-10</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-25"><a href="#工作原理-25" class="headerlink" title="工作原理"></a>工作原理</h3><p>让我们来了解一下add_custom_command的使用:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT</span><br><span class="line">      <span class="variable">$&#123;wrap_BLAS_LAPACK_sources&#125;</span></span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E tar xzf <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/wrap_BLAS_LAPACK.tar.gz</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E touch <span class="variable">$&#123;wrap_BLAS_LAPACK_sources&#125;</span></span><br><span class="line">  WORKING_DIRECTORY</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  DEPENDS</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/wrap_BLAS_LAPACK.tar.gz</span><br><span class="line">  COMMENT</span><br><span class="line">      <span class="string">&quot;Unpacking C++ wrappers for BLAS/LAPACK&quot;</span></span><br><span class="line">  VERBATIM</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p><code>add_custom_command</code>向目标添加规则，并通过执行命令生成输出。<code>add_custom_command</code>中声明的任何目标，即在相同的CMakeLists.txt中声明的任何目标，使用输出的任何文件作为源文件的目标，在构建时会有规则生成这些文件。因此，源文件生成在构建时，目标和自定义命令在构建系统生成时，将自动处理依赖关系。</p>
<p>我们的例子中，输出是压缩tar包，其中包含有源文件。要检测和使用这些文件，必须在构建时提取打包文件。通过使用带有-E标志的CMake命令，以实现平台独立性。下一个命令会更新提取文件的时间戳。这样做是为了确保没有处理陈旧文件。<code>WORKING_DIRECTORY</code>可以指定在何处执行命令。示例中，CMAKE_CURRENT_BINARY_DIR是当前正在处理的构建目录。DEPENDS参数列出了自定义命令的依赖项。例子中，压缩的tar是一个依赖项。CMake使用COMMENT字段在构建时打印状态消息。最后，VERBATIM告诉CMake为生成器和平台生成正确的命令，从而确保完全独立。</p>
<p>我们来仔细看看这用使用方式和打包库的创建：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">math</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">math</span></span><br><span class="line">  PRIVATE</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxBLAS.cpp</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxLAPACK.cpp</span><br><span class="line">  PUBLIC</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxBLAS.hpp</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxLAPACK.hpp</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">math</span></span><br><span class="line">  INTERFACE</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">math</span></span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="variable">$&#123;LAPACK_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>我们声明一个没有源的库目标，是因为后续使用target_sources填充目标的源。这里实现了一个非常重要的目标，即让依赖于此目标的目标，了解需要哪些目录和头文件，以便成功地使用库。C++源文件的目标是PRIVATE，因此只用于构建库。因为目标及其依赖项都需要使用它们来成功编译，所以头文件是PUBLIC。包含目录使用target_include_categories指定，其中wrap_BLAS_LAPACK声明为INTERFACE，因为只有依赖于math目标的目标需要它。</p>
<h2 id="构建时为特定目标运行自定义命令"><a href="#构建时为特定目标运行自定义命令" class="headerlink" title="构建时为特定目标运行自定义命令"></a>构建时为特定目标运行自定义命令</h2><p>本节示例将展示，如何使用add_custom_command的第二个参数，来执行没有输出的自定义操作，这对于构建或链接特定目标之前或之后执行某些操作非常有用。由于自定义命令仅在必须构建目标本身时才执行，因此我们实现了对其执行的目标级控制。我们将通过一个示例来演示，在构建目标之前打印目标的链接，然后在编译后，立即测量编译后，可执行文件的静态分配大小。</p>
<h3 id="准备工作-22"><a href="#准备工作-22" class="headerlink" title="准备工作"></a>准备工作</h3><p>本示例中，我们将使用Fortran代码(example.f90):<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> example</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">real</span>(<span class="number">8</span>) :: array(<span class="number">20000000</span>)</span><br><span class="line">  <span class="keyword">real</span>(<span class="number">8</span>) :: r</span><br><span class="line">  <span class="keyword">integer</span> :: i</span><br><span class="line">  <span class="keyword">do</span> i = <span class="number">1</span>, <span class="built_in">size</span>(array)</span><br><span class="line">    <span class="keyword">call</span> <span class="built_in">random_number</span>(r)</span><br><span class="line">    array(i) = r</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">print</span> *, <span class="built_in">sum</span>(array)</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br></pre></td></tr></table></figure></p>
<p>虽然我们选择了Fortran，但Fortran代码的对于后面的讨论并不重要，因为有很多遗留的Fortran代码，存在静态分配大小的问题。</p>
<p>这段代码中，我们定义了一个包含20,000,000双精度浮点数的数组，这个数组占用160MB的内存。在这里，我们并不是推荐这样的编程实践。一般来说，这些内存的分配和代码中是否使用这段内存无关。一个更好的方法是只在需要时动态分配数组，随后立即释放。</p>
<p>示例代码用随机数填充数组，并计算它们的和——这样是为了确保数组确实被使用，并且编译器不会优化分配。我们将使用Python脚本(static-size.py)来统计二进制文件静态分配的大小，该脚本用size命令来封装:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># for simplicity we do not check number of</span></span><br><span class="line"><span class="comment"># arguments and whether the file really exists</span></span><br><span class="line">file_path = sys.argv[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    output = subprocess.check_output([<span class="string">&#x27;size&#x27;</span>, file_path]).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;command &quot;size&quot; is not available on this platform&#x27;</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line">size = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> output.split(<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">    <span class="keyword">if</span> file_path <span class="keyword">in</span> line:</span><br><span class="line">        <span class="comment"># we are interested in the 4th number on this line</span></span><br><span class="line">        size = <span class="built_in">int</span>(line.split()[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:.3f&#125; MB&#x27;</span>.<span class="built_in">format</span>(size/<span class="number">1.0e6</span>))</span><br></pre></td></tr></table></figure></p>
<p>要打印链接行，我们将使用第二个Python helper脚本(echo-file.py)打印文件的内容:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># for simplicity we do not verify the number and</span></span><br><span class="line"><span class="comment"># type of arguments</span></span><br><span class="line">file_path = sys.argv[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ERROR: file &#123;0&#125; not found&#x27;</span>.<span class="built_in">format</span>(file_path))</span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-27"><a href="#具体实施-27" class="headerlink" title="具体实施"></a>具体实施</h3><p>来看看CMakeLists.txt：</p>
<p>首先声明一个Fortran项目:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">05</span> LANGUAGES Fortran)</span><br></pre></td></tr></table></figure></p>
<p>例子依赖于Python解释器，所以以一种可移植的方式执行helper脚本:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>本例中，默认为“Release”构建类型，以便CMake添加优化标志:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_BUILD_TYPE Release CACHE <span class="keyword">STRING</span> <span class="string">&quot;Build type&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>现在，定义可执行目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(example <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(example</span><br><span class="line">  PRIVATE</span><br><span class="line">      example.f90</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>然后，定义一个自定义命令，在example目标在已链接之前，打印链接行:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  <span class="keyword">TARGET</span></span><br><span class="line">      example</span><br><span class="line">  PRE_LINK</span><br><span class="line">      <span class="keyword">COMMAND</span></span><br><span class="line">          <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span></span><br><span class="line">          <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/echo-<span class="keyword">file</span>.py</span><br><span class="line">            <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/CMakeFiles/example.dir/link.txt</span><br><span class="line">  COMMENT</span><br><span class="line">      <span class="string">&quot;link line:&quot;</span></span><br><span class="line">  VERBATIM</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>测试一下。观察打印的链接行和可执行文件的静态大小:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line">Scanning dependencies of target example</span><br><span class="line">[ 50%] Building Fortran object CMakeFiles/example.dir/example.f90.o</span><br><span class="line">[100%] Linking Fortran executable example</span><br><span class="line"><span class="built_in">link</span> line:</span><br><span class="line">/usr/bin/f95 -O3 -DNDEBUG -O3 CMakeFiles/example.dir/example.f90.o -o example</span><br><span class="line">static size of executable:</span><br><span class="line">160.003 MB</span><br><span class="line">[100%] Built target example</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-26"><a href="#工作原理-26" class="headerlink" title="工作原理"></a>工作原理</h3><p>当声明了库或可执行目标，就可以使用add_custom_command将其他命令锁定到目标上。这些命令将在特定的时间执行，与它们所附加的目标的执行相关联。CMake通过以下选项，定制命令执行顺序:</p>
<ul>
<li>PRE_BUILD：在执行与目标相关的任何其他规则之前执行的命令。</li>
<li>PRE_LINK：使用此选项，命令在编译目标之后，调用链接器或归档器之前执行。Visual Studio 7或更高版本之外的生成器中使用PRE_BUILD将被解释为PRE_LINK。</li>
<li>POST_BUILD：如前所述，这些命令将在执行给定目标的所有规则之后运行。</li>
</ul>
<p>本例中，将两个自定义命令绑定到可执行目标。PRE_LINK命令将${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/example.dir/link.txt的内容打印到屏幕上。在我们的例子中，链接行是这样的:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/f95 -O3 -DNDEBUG -O3 CMakeFiles/example.dir/example.f90.o -o example</span><br></pre></td></tr></table></figure></p>
<p>使用Python包装器来实现这一点，它依赖于shell命令。</p>
<p>第二步中，POST_BUILD自定义命令调用Python helper脚本static-size.py，生成器表达式$<target_file:example>作为参数。CMake将在生成时(即生成生成系统时)将生成器表达式扩展到目标文件路径。然后，Python脚本static-size.py使用size命令获取可执行文件的静态分配大小，将其转换为MB，并打印结果。我们的例子中，获得了预期的160 MB:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static size of executable:</span><br><span class="line">160.003 MB</span><br></pre></td></tr></table></figure></p>
<h2 id="探究编译和链接命令"><a href="#探究编译和链接命令" class="headerlink" title="探究编译和链接命令"></a>探究编译和链接命令</h2><p>生成构建系统期间最常见的操作，是试图评估在哪种系统上构建项目。这意味着要找出哪些功能工作，哪些不工作，并相应地调整项目的编译。使用的方法是查询依赖项是否被满足的信号，或者在代码库中是否启用工作区。接下来的几个示例，将展示如何使用CMake执行这些操作。</p>
<h3 id="准备工作-23"><a href="#准备工作-23" class="headerlink" title="准备工作"></a>准备工作</h3><p>示例将展示如何使用来自对应的<code>Check&lt;LANG&gt;SourceCompiles.cmake</code>标准模块的<code>check_&lt;lang&gt;_source_compiles</code>函数，以评估给定编译器是否可以将预定义的代码编译成可执行文件。该命令可帮助你确定:</p>
<ul>
<li>编译器支持所需的特性。</li>
<li>链接器工作正常，并理解特定的标志。</li>
<li>可以使用find_package找到的包含目录和库。</li>
</ul>
<p>本示例中，我们将展示如何检测OpenMP 4.5标准的循环特性，以便在C++可执行文件中使用。使用一个C++源文件，来探测编译器是否支持这样的特性。CMake提供了一个附加命令try_compile来探究编译。本示例将展示，如何使用这两种方法。</p>
<blockquote>
<p>可以使用CMake命令行界面来获取关于特定模块(<code>cmake --help-module &lt;module-name&gt;</code>)和命令(<code>cmake --help-command &lt;command-name&gt;</code>)的文档。示例中，<code>cmake --help-module CheckCXXSourceCompiles</code>将把<code>check_cxx_source_compiles</code>函数的文档输出到屏幕上，而<code>cmake --help-command try_compile</code>将对<code>try_compile</code>命令执行相同的操作。</p>
</blockquote>
<h3 id="具体实施-28"><a href="#具体实施-28" class="headerlink" title="具体实施"></a>具体实施</h3><p>我们将同时使用try_compile和check_cxx_source_compiles，并比较这两个命令的工作方式:</p>
<p>创建一个C++11工程：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.9</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">06</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>查找编译器支持的OpenMP：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenMP)</span><br><span class="line"><span class="keyword">if</span>(OpenMP_FOUND)</span><br><span class="line">    <span class="comment"># ... &lt;- the steps below will be placed here</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;OpenMP not found: no test for taskloop is run&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>如果找到OpenMP，再检查所需的特性是否可用。为此，设置了一个临时目录，try_compile将在这个目录下来生成中间文件。我们把它放在前面步骤中引入的if语句中:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(_scratch_dir <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/omp_try_compile)</span><br></pre></td></tr></table></figure></p>
<p>调用try_compile生成一个小项目，以尝试编译源文件taskloop.cpp。编译成功或失败的状态，将保存到<code>omp_taskloop_test_1</code>变量中。需要为这个示例编译设置适当的编译器标志、包括目录和链接库。因为使用导入的目标<code>OpenMP::OpenMP_CXX</code>，所以只需将<code>LINK_LIBRARIES</code>选项设置为try_compile即可。如果编译成功，则任务循环特性可用，我们为用户打印一条消息:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try_compile</span>(</span><br><span class="line">  omp_taskloop_test_1</span><br><span class="line">      <span class="variable">$&#123;_scratch_dir&#125;</span></span><br><span class="line">  SOURCES</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/taskloop.cpp</span><br><span class="line">  <span class="keyword">LINK_LIBRARIES</span></span><br><span class="line">      OpenMP::OpenMP_CXX</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Result of try_compile: $&#123;omp_taskloop_test_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>要使用<code>check_cxx_source_compiles</code>函数，需要包含<code>CheckCXXSourceCompiles.cmake</code>模块文件。其他语言也有类似的模块文件，<code>C(CheckCSourceCompiles.cmake)</code>和<code>Fortran(CheckFortranSourceCompiles.cmake)</code>:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CheckCXXSourceCompiles)</span><br></pre></td></tr></table></figure></p>
<p>我们复制源文件的内容，通过file(READ …)命令读取内容到一个变量中，试图编译和连接这个变量:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(READ <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/taskloop.cpp _snippet)</span><br></pre></td></tr></table></figure></p>
<p>我们设置了<code>CMAKE_REQUIRED_LIBRARIES</code>。这对于下一步正确调用编译器是必需的。注意使用导入的<code>OpenMP::OpenMP_CXX</code>目标，它还将设置正确的编译器标志和包含目录:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_REQUIRED_LIBRARIES OpenMP::OpenMP_CXX)</span><br></pre></td></tr></table></figure></p>
<p>使用代码片段作为参数，调用<code>check_cxx_source_compiles</code>函数。检查结果将保存到<code>omp_taskloop_test_2</code>变量中:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_cxx_source_compiles(<span class="string">&quot;$&#123;_snippet&#125;&quot;</span> omp_taskloop_test_2)</span><br></pre></td></tr></table></figure></p>
<p>调用<code>check_cxx_source_compiles</code>并向用户打印消息之前，我们取消了变量的设置:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unset</span>(CMAKE_REQUIRED_LIBRARIES)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Result of check_cxx_source_compiles: $&#123;omp_taskloop_test_2&#125;&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>最后，进行测试：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">-- ...</span><br><span class="line">-- Found OpenMP_CXX: -fopenmp (found version <span class="string">&quot;4.5&quot;</span>)</span><br><span class="line">-- Found OpenMP: TRUE (found version <span class="string">&quot;4.5&quot;</span>)</span><br><span class="line">-- Result of try_compile: TRUE</span><br><span class="line">-- Performing Test omp_taskloop_test_2</span><br><span class="line">-- Performing Test omp_taskloop_test_2 - Success</span><br><span class="line">-- Result of check_cxx_source_compiles: 1</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-27"><a href="#工作原理-27" class="headerlink" title="工作原理"></a>工作原理</h3><p>try_compile和check_cxx_source_compiles都将编译源文件，并将其链接到可执行文件中。如果这些操作成功，那么输出变量omp_task_loop_test_1(前者)和omp_task_loop_test_2(后者)将被设置为TRUE。然而，这两个命令实现的方式略有不同。<code>check_&lt;lang&gt;_source_compiles</code>命令是try_compile命令的简化包装。</p>
<p>要编译的代码片段必须作为CMake变量传入。大多数情况下，这意味着必须使用file(READ …)来读取文件。然后，代码片段被保存到构建目录的CMakeFiles/CMakeTmp子目录中。</p>
<p>微调编译和链接，必须通过设置以下CMake变量进行:</p>
<ul>
<li>CMAKE_REQUIRED_FLAGS：设置编译器标志。</li>
<li>CMAKE_REQUIRED_DEFINITIONS：设置预编译宏。</li>
<li>CMAKE_REQUIRED_INCLUDES：设置包含目录列表。</li>
<li>CMAKE_REQUIRED_LIBRARIES：设置可执行目标能够连接的库列表。</li>
</ul>
<p>调用<code>check_&lt;lang&gt;_compiles_function</code>之后，必须手动取消对这些变量的设置，以确保后续使用中，不会保留当前内容。</p>
<p>使用CMake 3.9中可以对于OpenMP目标进行导入,但是目前的配置也可以使用CMake的早期版本，通过手动为check_cxx_source_compiles设置所需的标志和库:<code>set(CMAKE_REQUIRED_FLAGS $&#123;OpenMP_CXX_FLAGS&#125;)</code>和<code>set(CMAKE_REQUIRED_LIBRARIES $&#123;OpenMP_CXX_LIBRARIES&#125;)</code>。</p>
<h1 id="生成源码"><a href="#生成源码" class="headerlink" title="生成源码"></a>生成源码</h1><h2 id="配置时生成源码"><a href="#配置时生成源码" class="headerlink" title="配置时生成源码"></a>配置时生成源码</h2><p>代码生成在配置时发生，例如：CMake可以检测操作系统和可用库；基于这些信息，我们可以定制构建的源代码。本节和下面的章节中，我们将演示如何生成一个简单源文件，该文件定义了一个函数，用于报告构建系统配置。</p>
<h3 id="准备工作-24"><a href="#准备工作-24" class="headerlink" title="准备工作"></a>准备工作</h3><p>此示例的代码使用Fortran和C语言编写，第9章将讨论混合语言编程。主程序是一个简单的Fortran可执行程序，它调用一个C函数print_info()，该函数将打印配置信息。值得注意的是，在使用Fortran 2003时，编译器将处理命名问题(对于C函数的接口声明)，如示例所示。我们将使用的example.f90作为源文件:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> hello_world</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">interface</span></span><br><span class="line">      <span class="function"><span class="keyword">subroutine</span></span> print_info() <span class="keyword">bind</span>(c, <span class="keyword">name</span>=<span class="string">&quot;print_info&quot;</span>)</span><br><span class="line">      <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">  <span class="keyword">call</span> print_info()</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br></pre></td></tr></table></figure></p>
<p>C函数<code>print_info()</code>在模板文件print_info.c.in中定义。在配置时，以@开头和结尾的变量将被替换为实际值:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Configuration and build information\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Who compiled | %s\n&quot;</span>, <span class="string">&quot;@_user_name@&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Compilation hostname | %s\n&quot;</span>, <span class="string">&quot;@_host_name@&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Fully qualified domain name | %s\n&quot;</span>, <span class="string">&quot;@_fqdn@&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Operating system | %s\n&quot;</span>,</span><br><span class="line">         <span class="string">&quot;@_os_name@, @_os_release@, @_os_version@&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Platform | %s\n&quot;</span>, <span class="string">&quot;@_os_platform@&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Processor info | %s\n&quot;</span>,</span><br><span class="line">         <span class="string">&quot;@_processor_name@, @_processor_description@&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;CMake version | %s\n&quot;</span>, <span class="string">&quot;@CMAKE_VERSION@&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;CMake generator | %s\n&quot;</span>, <span class="string">&quot;@CMAKE_GENERATOR@&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Configuration time | %s\n&quot;</span>, <span class="string">&quot;@_configuration_time@&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Fortran compiler | %s\n&quot;</span>, <span class="string">&quot;@CMAKE_Fortran_COMPILER@&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;C compiler | %s\n&quot;</span>, <span class="string">&quot;@CMAKE_C_COMPILER@&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fflush</span>(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-29"><a href="#具体实施-29" class="headerlink" title="具体实施"></a>具体实施</h3><p>在CMakeLists.txt中，我们首先必须对选项进行配置，并用它们的值替换print_info.c.in中相应的占位符。然后，将Fortran和C源代码编译成一个可执行文件:</p>
<p>声明了一个Fortran-C混合项目:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span> LANGUAGES Fortran C)</span><br></pre></td></tr></table></figure></p>
<p>使用execute_process为项目获取当且使用者的信息:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      whoami</span><br><span class="line">  TIMEOUT</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">  OUTPUT_VARIABLE</span><br><span class="line">      _user_name</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>使用cmake_host_system_information()函数(已经在第2章第5节遇到过)，可以查询很多系统信息:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># host name information</span></span><br><span class="line"><span class="keyword">cmake_host_system_information</span>(RESULT _host_name QUERY HOSTNAME)</span><br><span class="line"><span class="keyword">cmake_host_system_information</span>(RESULT _fqdn QUERY FQDN)</span><br><span class="line"><span class="comment"># processor information</span></span><br><span class="line"><span class="keyword">cmake_host_system_information</span>(RESULT _processor_name QUERY PROCESSOR_NAME)</span><br><span class="line"><span class="keyword">cmake_host_system_information</span>(RESULT _processor_description QUERY PROCESSOR_DESCRIPTION)</span><br><span class="line"><span class="comment"># os information</span></span><br><span class="line"><span class="keyword">cmake_host_system_information</span>(RESULT _os_name QUERY OS_NAME)</span><br><span class="line"><span class="keyword">cmake_host_system_information</span>(RESULT _os_release QUERY OS_RELEASE)</span><br><span class="line"><span class="keyword">cmake_host_system_information</span>(RESULT _os_version QUERY OS_VERSION)</span><br><span class="line"><span class="keyword">cmake_host_system_information</span>(RESULT _os_platform QUERY OS_PLATFORM)</span><br></pre></td></tr></table></figure></p>
<p>捕获配置时的时间戳，并通过使用字符串操作函数:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>(TIMESTAMP _configuration_time <span class="string">&quot;%Y-%m-%d %H:%M:%S [UTC]&quot;</span> UTC)</span><br></pre></td></tr></table></figure></p>
<p>现在，准备好配置模板文件print_info.c.in。通过CMake的configure_file函数生成代码。注意，这里只要求以@开头和结尾的字符串被替换:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configure_file</span>(print_info.c.in print_info.c @ONLY)</span><br></pre></td></tr></table></figure></p>
<p>最后，我们添加一个可执行目标，并定义目标源：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(example <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(example</span><br><span class="line">  PRIVATE</span><br><span class="line">    example.f90</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/print_info.c</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>下面是一个输出示例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ./example</span><br><span class="line">Configuration and build information</span><br><span class="line">-----------------------------------</span><br><span class="line">Who compiled | somebody</span><br><span class="line">Compilation hostname | laptop</span><br><span class="line">Fully qualified domain name | laptop</span><br><span class="line">Operating system | Linux, 4.16.13-1-ARCH, <span class="comment">#1 SMP PREEMPT Thu May 31 23:29:29 UTC 2018</span></span><br><span class="line">Platform | x86_64</span><br><span class="line">Processor info | Unknown P6 family, 2 core Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz</span><br><span class="line">CMake version | 3.11.3</span><br><span class="line">CMake generator | Unix Makefiles</span><br><span class="line">Configuration <span class="keyword">time</span> | 2018-06-25 15:38:03 [UTC]</span><br><span class="line">Fortran compiler | /usr/bin/f95</span><br><span class="line">C compiler | /usr/bin/cc</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-28"><a href="#工作原理-28" class="headerlink" title="工作原理"></a>工作原理</h3><p>configure_file命令可以复制文件，并用变量值替换它们的内容。示例中，使用configure_file修改模板文件的内容，并将其复制到一个位置，然后将其编译到可执行文件中。如何调用configure_file:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configure_file</span>(print_info.c.in print_info.c @ONLY)</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是模板的名称为<code>print_info.c.in</code>。CMake假设输入文件的目录，与项目的根目录相对；也就是说，在<code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/print_info.c.in</code>。我们选择print_info.c，作为第二个参数是配置文件的名称。假设输出文件位于相对于项目构建目录的位置：<code>$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/print_info.c</code>。</p>
<p>输入和输出文件作为参数时，CMake不仅将配置<code>@VAR@</code>变量，还将配置<code>$&#123;VAR&#125;</code>变量。如果<code>$&#123;VAR&#125;</code>是语法的一部分，并且不应该修改(例如在shell脚本中)，那么就很不方便。为了在引导CMake，应该将选项<code>@ONLY</code>传递给configure_file的调用，如前所述。</p>
<h2 id="记录项目版本信息以便报告"><a href="#记录项目版本信息以便报告" class="headerlink" title="记录项目版本信息以便报告"></a>记录项目版本信息以便报告</h2><p>代码版本很重要，不仅是为了可重复性，还为了记录API功能或简化支持请求和bug报告。源代码通常处于某种版本控制之下，例如：可以使用Git标记附加额外版本号(参见<a href="https://semver.org">https://semver.org</a> )。然而，不仅需要对源代码进行版本控制，而且可执行文件还需要记录项目版本，以便将其打印到代码输出或用户界面上。</p>
<p>本例中，将在CMake源文件中定义版本号。我们的目标是在配置项目时将程序版本记录到头文件中。然后，生成的头文件可以包含在代码的正确位置和时间，以便将代码版本打印到输出文件或屏幕上。</p>
<h3 id="准备工作-25"><a href="#准备工作-25" class="headerlink" title="准备工作"></a>准备工作</h3><p>将使用以下C文件(example.c)打印版本信息:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;version.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This is output from code %s\n&quot;</span>, PROJECT_VERSION);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Major version number: %i\n&quot;</span>, PROJECT_VERSION_MAJOR);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Minor version number: %i\n&quot;</span>, PROJECT_VERSION_MINOR);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello CMake world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，假设<code>PROJECT_VERSION_MAJOR</code>、<code>PROJECT_VERSION_MINOR</code>和<code>PROJECT_VERSION</code>是在<code>version.h</code>中定义的。目标是从以下模板中生成version.h.in:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJECT_VERSION_MAJOR @PROJECT_VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJECT_VERSION_MINOR @PROJECT_VERSION_MINOR@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJECT_VERSION_PATCH @PROJECT_VERSION_PATCH@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJECT_VERSION <span class="string">&quot;v@PROJECT_VERSION@&quot;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里使用预处理器定义，也可以使用字符串或整数常量来提高类型安全性(稍后我们将对此进行演示)。从CMake的角度来看，这两种方法是相同的。</p>
<h3 id="如何实施-2"><a href="#如何实施-2" class="headerlink" title="如何实施"></a>如何实施</h3><p>我们将按照以下步骤，在模板头文件中对版本进行注册:</p>
<p>要跟踪代码版本，我们可以在CMakeLists.txt中调用CMake的project时定义项目版本:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">04</span> VERSION <span class="number">2.0</span>.<span class="number">1</span> LANGUAGES C)</span><br></pre></td></tr></table></figure></p>
<p>然后，基于version.h.in生成version.h:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configure_file</span>(</span><br><span class="line">  version.h.in</span><br><span class="line">  generated/version.h</span><br><span class="line">  @ONLY</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，我们定义了可执行文件，并提供了目标包含路径:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(example example.c)</span><br><span class="line"><span class="keyword">target_include_directories</span>(example</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/generated</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-29"><a href="#工作原理-29" class="headerlink" title="工作原理"></a>工作原理</h3><p>当使用版本参数调用CMake的project时，CMake将为项目设置<code>PROJECT_VERSION_MAJOR</code>、<code>PROJECT_VERSION_MINOR</code>和<code>PROJECT_VERSION_PATCH</code>。此示例中的关键命令是configure_file，它接受一个输入文件(本例中是version.h.in)，通过将@之间的占位符替换成对应的CMake变量，生成一个输出文件(本例中是generate/version.h)。它将<code>@PROJECT_VERSION_MAJOR@</code>替换为2，以此类推。使用关键字<code>@ONLY</code>，我们将configure_file限制为只替换<code>@variables@</code>，而不修改<code>$&#123;variables&#125;</code>。后一种形式在<code>version.h.in</code>中没有使用。但是，当使用CMake配置shell脚本时，会经常出现。</p>
<p>生成的头文件可以包含在示例代码中，可以打印版本信息:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ./example</span><br><span class="line">This is output from code v2.0.1</span><br><span class="line">Major version number: 2</span><br><span class="line">Minor version number: 0</span><br><span class="line">Hello CMake world!</span><br></pre></td></tr></table></figure></p>
<p>NOTE:CMake以x.y.z格式给出的版本号，并将变量<code>PROJECT_VERSION</code>和<code>&lt;project-name&gt;_VERSION</code>设置为给定的值。此外,<code>PROJECT_VERSION_MAJOR</code>(<code>&lt;project-name&gt;_VERSION_MAJOR</code>),<code>PROJECT_VERSION_MINOR</code>(<code>&lt;project-name&gt;_VERSION_MINOR</code>) <code>PROJECT_VERSION_PATCH</code>(<code>&lt;project-name&gt;_VERSION_PATCH</code>)和<code>PROJECT_VERSION_TWEAK</code>(<code>&lt;project-name&gt;_VERSION_TWEAK</code>),将分别设置为X, Y, Z和t。</p>
<h2 id="配置时记录Git-Hash值"><a href="#配置时记录Git-Hash值" class="headerlink" title="配置时记录Git Hash值"></a>配置时记录Git Hash值</h2><p>大多数现代源代码存储库都使用Git作为版本控制系统进行跟踪，这可以归功于存储库托管平台GitHub的流行。因此，我们将在本示例中使用Git；然而，实际中会根据具体的动机和实现，可以转化为其他版本控制系统。我们以Git为例，提交的Git Hash决定了源代码的状态。因此，为了标记可执行文件，我们将尝试将Git Hash记录到可执行文件中，方法是将哈希字符串记录在一个头文件中，该头文件可以包含在代码中。</p>
<h3 id="准备工作-26"><a href="#准备工作-26" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们需要两个源文件，类似于前面的示例。其中一个将配置记录的Hash(version.hpp.in)，详情如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="type">const</span> std::string GIT_HASH = <span class="string">&quot;@GIT_HASH@&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>还需要一个示例源文件(example.cpp)，将Hash打印到屏幕上:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;version.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This code has been configured from version &quot;</span> &lt;&lt; GIT_HASH &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此示例还假定在Git存储库中至少有一个提交。因此，使用git init初始化这个示例，并使用<code>git add &lt;filename&gt;</code>，然后使用git commit创建提交，以便获得一个有意义的示例。</p>
<h3 id="具体实施-30"><a href="#具体实施-30" class="headerlink" title="具体实施"></a>具体实施</h3><p>下面演示了从Git记录版本信息的步骤:</p>
<p>定义项目和支持语言:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">06</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>定义GIT_HASH变量:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in case Git is not available, we default to &quot;unknown&quot;</span></span><br><span class="line"><span class="keyword">set</span>(GIT_HASH <span class="string">&quot;unknown&quot;</span>)</span><br><span class="line"><span class="comment"># find Git and if available set GIT_HASH variable</span></span><br><span class="line"><span class="keyword">find_package</span>(Git QUIET)</span><br><span class="line"><span class="keyword">if</span>(GIT_FOUND)</span><br><span class="line">  <span class="keyword">execute_process</span>(</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;GIT_EXECUTABLE&#125;</span> log -<span class="number">1</span> --pretty=format:%h</span><br><span class="line">    OUTPUT_VARIABLE GIT_HASH</span><br><span class="line">    OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">    ERROR_QUIET</span><br><span class="line">    WORKING_DIRECTORY</span><br><span class="line">        <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Git hash is $&#123;GIT_HASH&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>CMakeLists.txt剩余的部分，类似于之前的示例:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate file version.hpp based on version.hpp.in</span></span><br><span class="line"><span class="keyword">configure_file</span>(</span><br><span class="line">  version.hpp.in</span><br><span class="line">  generated/version.hpp</span><br><span class="line">  @ONLY</span><br><span class="line">  )</span><br><span class="line"><span class="comment"># example code</span></span><br><span class="line"><span class="keyword">add_executable</span>(example example.cpp)</span><br><span class="line"><span class="comment"># needs to find the generated header file</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(example</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/generated</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>验证输出(Hash不同):<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ./example</span><br><span class="line">This code has been configured from version d58c64f</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-30"><a href="#工作原理-30" class="headerlink" title="工作原理"></a>工作原理</h3><p>使用<code>find_package(Git QUIET)</code>来检测系统上是否有可用的Git。如果有(GIT_FOUND为True)，运行一个Git命令:<code>$&#123;GIT_EXECUTABLE&#125; log -1 --pretty=format:%h</code>。这个命令给出了当前提交Hash的简短版本。当然，这里我们可以灵活地运行Git命令。我们要求execute_process命令将结果放入名为GIT_HASH的变量中，然后删除任何尾随的空格。使用ERROR_QUIET，如果Git命令由于某种原因失败，我们不会停止配置。</p>
<p>由于Git命令可能会失败(源代码已经分发到Git存储库之外)，或者Git在系统上不可用，我们希望为这个变量设置一个默认值，如下所示:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(GIT_HASH <span class="string">&quot;unknown&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h1><h2 id="使用函数和宏重用代码"><a href="#使用函数和宏重用代码" class="headerlink" title="使用函数和宏重用代码"></a>使用函数和宏重用代码</h2><p>任何编程语言中，函数允许我们抽象(隐藏)细节并避免代码重复，CMake也不例外。本示例中，我们将以宏和函数为例进行讨论，并介绍一个宏，以便方便地定义测试和设置测试的顺序。我们的目标是定义一个宏，能够替换add_test和set_tests_properties，用于定义每组和设置每个测试的预期开销。</p>
<h3 id="准备工作-27"><a href="#准备工作-27" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们将基于第4章第2节中的例子。main.cpp、sum_integers.cpp和sum_integers.hpp文件不变，用来计算命令行参数提供的整数队列的和。单元测试(test.cpp)的源代码也没有改变。我们还需要Catch 2头文件，catch.hpp。与第4章相反，我们将把源文件放到子目录中，并形成以下文件树:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── src</span><br><span class="line">│     ├── CMakeLists.txt</span><br><span class="line">│     ├── main.cpp</span><br><span class="line">│     ├── sum_integers.cpp</span><br><span class="line">│     └── sum_integers.hpp</span><br><span class="line">└── tests</span><br><span class="line">      ├── catch.hpp</span><br><span class="line">      ├── CMakeLists.txt</span><br><span class="line">      └── test.cpp</span><br></pre></td></tr></table></figure>
<h3 id="具体实施-31"><a href="#具体实施-31" class="headerlink" title="具体实施"></a>具体实施</h3><p>定义了CMake最低版本、项目名称和支持的语言，并要求支持C++11标准:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span> LANGUAGES CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>根据GNU标准定义binary和library路径:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(GNUInstallDirs)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>)</span><br></pre></td></tr></table></figure></p>
<p>最后，使用add_subdirectory调用src/CMakeLists.txt和tests/CMakeLists.txt:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"><span class="keyword">add_subdirectory</span>(tests)</span><br></pre></td></tr></table></figure></p>
<p>src/CMakeLists.txt定义了源码目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">add_library</span>(sum_integers sum_integers.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(sum_up main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(sum_up sum_integers)</span><br></pre></td></tr></table></figure></p>
<p>tests/CMakeLists.txt中，构建并链接cpp_test可执行文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(cpp_test <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(cpp_test sum_integers)</span><br></pre></td></tr></table></figure></p>
<p>定义一个新宏add_catch_test:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(add_catch_test _name _cost)</span><br><span class="line">  <span class="keyword">math</span>(EXPR num_macro_calls <span class="string">&quot;$&#123;num_macro_calls&#125; + 1&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;add_catch_test called with $&#123;ARGC&#125; arguments: $&#123;ARGV&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(_argn <span class="string">&quot;$&#123;ARGN&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span>(_argn)</span><br><span class="line">      <span class="keyword">message</span>(STATUS <span class="string">&quot;oops - macro received argument(s) we did not expect: $&#123;ARGN&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">add_test</span>(</span><br><span class="line">    NAME</span><br><span class="line">      <span class="variable">$&#123;_name&#125;</span></span><br><span class="line">    <span class="keyword">COMMAND</span></span><br><span class="line">      $&lt;TARGET_FILE:cpp_test&gt;</span><br><span class="line">    [<span class="variable">$&#123;_name&#125;</span>] --success --out</span><br><span class="line">    <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/tests/<span class="variable">$&#123;_name&#125;</span>.log --durations yes</span><br><span class="line">    WORKING_DIRECTORY</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">set_tests_properties</span>(</span><br><span class="line">    <span class="variable">$&#123;_name&#125;</span></span><br><span class="line">    PROPERTIES</span><br><span class="line">        COST <span class="variable">$&#123;_cost&#125;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure></p>
<p>最后，使用add_catch_test定义了两个测试。此外，还设置和打印了变量的值:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(num_macro_calls <span class="number">0</span>)</span><br><span class="line">add_catch_test(short <span class="number">1.5</span>)</span><br><span class="line">add_catch_test(long <span class="number">2.5</span> extra_argument)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;in total there were $&#123;num_macro_calls&#125; calls to add_catch_test&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>现在，进行测试。配置项目(输出行如下所示):<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">-- ...</span><br><span class="line">-- add_catch_test called with 2 arguments: short;1.5</span><br><span class="line">-- add_catch_test called with 3 arguments: long;2.5;extra_argument</span><br><span class="line">-- oops - macro received argument(s) we did not expect: extra_argument</span><br><span class="line">-- <span class="keyword">in</span> total there were 2 calls to add_catch_test</span><br><span class="line">-- ...</span><br></pre></td></tr></table></figure></p>
<p>最后，构建并运行测试:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br><span class="line">$ ctest</span><br></pre></td></tr></table></figure></p>
<p>长时间的测试会先开始:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Start 2: long</span><br><span class="line">1/2 Test <span class="comment">#2: long ............................. Passed 0.00 sec</span></span><br><span class="line">Start 1: short</span><br><span class="line">2/2 Test <span class="comment">#1: short ............................ Passed 0.00 sec</span></span><br><span class="line">100% tests passed, 0 tests failed out of 2</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-31"><a href="#工作原理-31" class="headerlink" title="工作原理"></a>工作原理</h3><p>这个配置中的新添加了add_catch_test宏。这个宏需要两个参数_name和_cost，可以在宏中使用这些参数来调用add_test和set_tests_properties。参数前面的下划线，是为了向读者表明这些参数只能在宏中访问。另外，宏自动填充了${ARGC}(参数数量)和${ARGV}(参数列表)，我们可以在输出中验证了这一点:</p>
<ul>
<li><code>-- add_catch_test called with 2 arguments: short;1.5</code></li>
<li><code>-- add_catch_test called with 3 arguments: long;2.5;extra_argument</code></li>
</ul>
<p>宏还定义了<code>$&#123;ARGN&#125;</code>，用于保存最后一个参数之后的参数列表。此外，我们还可以使用<code>$&#123;ARGV0&#125;</code>、<code>$&#123;ARGV1&#125;</code>等来处理参数。我们演示一下，如何捕捉到调用中的额外参数(extra_argument):<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_catch_test(long <span class="number">2.5</span> extra_argument)</span><br></pre></td></tr></table></figure></p>
<p>我们使用了以下方法:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(_argn <span class="string">&quot;$&#123;ARGN&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(_argn)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;oops - macro received argument(s) we did not expect: $&#123;ARGN&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>这个if语句中，我们引入一个新变量，但不能直接查询ARGN，因为它不是通常意义上的CMake变量。使用这个宏，我们可以通过它们的名称和命令来定义测试，还可以指示预期的开销，这会让耗时长的测试在耗时短测试之前启动，这要归功于COST属性。</p>
<p>我们可以用一个函数来实现它，而不是使用相同语法的宏:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(add_catch_test _name _cost)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure></p>
<p>宏和函数之间的区别在于它们的变量范围。宏在调用者的范围内执行，而函数有自己的变量范围。换句话说，如果我们使用宏，需要设置或修改对调用者可用的变量。如果不去设置或修改输出变量，最好使用函数。我们注意到，可以在函数中修改父作用域变量，但这必须使用<code>PARENT_SCOPE</code>显式表示:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(variable_visible_outside <span class="string">&quot;some value&quot;</span> PARENT_SCOPE)</span><br></pre></td></tr></table></figure></p>
<p>为了演示作用域，我们在定义宏之后编写了以下调用:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(num_macro_calls <span class="number">0</span>)</span><br><span class="line">add_catch_test(short <span class="number">1.5</span>)</span><br><span class="line">add_catch_test(long <span class="number">2.5</span> extra_argument)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;in total there were $&#123;num_macro_calls&#125; calls to add_catch_test&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>在宏内部，将num_macro_calls加1:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">math</span>(EXPR num_macro_calls <span class="string">&quot;$&#123;num_macro_calls&#125; + 1&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>这时产生的输出:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- <span class="keyword">in</span> total there were 2 calls to add_catch_test</span><br></pre></td></tr></table></figure></p>
<p>如果我们将宏更改为函数，测试仍然可以工作，但是num_macro_calls在父范围内的所有调用中始终为0。将CMake宏想象成类似函数是很有用的，这些函数被直接替换到它们被调用的地方(在C语言中内联)。将CMake函数想象成黑盒函数很有必要。黑盒中，除非显式地将其定义为PARENT_SCOPE，否则不会返回任何内容。CMake中的函数没有返回值。</p>
<h3 id="更多信息-8"><a href="#更多信息-8" class="headerlink" title="更多信息"></a>更多信息</h3><p>可以在宏中嵌套函数调用，也可以在函数中嵌套宏调用，但是这就需要仔细考虑变量的作用范围。如果功能可以使用函数实现，那么这可能比宏更好，因为它对父范围状态提供了更多的默认控制。</p>
<p>我们还应该提到在<code>src/cmakelist.txt</code>中使用<code>CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE</code>:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>这个命令会将当前目录，添加到CMakeLists.txt中定义的所有目标的<code>interface_include_directory</code>属性中。换句话说，我们不需要使用<code>target_include_directory</code>来添加cpp_test所需头文件的位置。</p>
<h2 id="将CMake源代码分成模块"><a href="#将CMake源代码分成模块" class="headerlink" title="将CMake源代码分成模块"></a>将CMake源代码分成模块</h2><p>项目通常从单个CMakeLists.txt文件开始，随着时间的推移，这个文件会逐渐增长。本示例中，我们将演示一种将CMakeLists.txt分割成更小单元的机制。将CMakeLists.txt拆分为模块有几个动机，这些模块可以包含在主CMakeLists.txt或其他模块中:</p>
<ul>
<li>主CMakeLists.txt更易于阅读。</li>
<li>CMake模块可以在其他项目中重用。</li>
<li>与函数相结合，模块可以帮助我们限制变量的作用范围。</li>
</ul>
<p>本示例中，我们将演示如何定义和包含一个宏，该宏允许我们获得CMake的彩色输出(用于重要的状态消息或警告)。</p>
<h3 id="准备工作-28"><a href="#准备工作-28" class="headerlink" title="准备工作"></a>准备工作</h3><p>本例中，我们将使用两个文件，主CMakeLists.txt和cmake/colors.cmake:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── cmake</span><br><span class="line">│     └── colors.cmake</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>cmake/colors.cmake文件包含彩色输出的定义:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># colorize CMake output</span></span><br><span class="line"><span class="comment"># code adapted from stackoverflow: http://stackoverflow.com/a/19578320</span></span><br><span class="line"><span class="comment"># from post authored by https://stackoverflow.com/users/2556117/fraser</span></span><br><span class="line"><span class="keyword">macro</span>(define_colors)</span><br><span class="line">  <span class="keyword">if</span>(WIN32)</span><br><span class="line">    <span class="comment"># has no effect on WIN32</span></span><br><span class="line">    <span class="keyword">set</span>(ColourReset <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(ColourBold <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Red <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Green <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Yellow <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Blue <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Magenta <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Cyan <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(White <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldRed <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldGreen <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldYellow <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldBlue <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldMagenta <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldCyan <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldWhite <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">string</span>(ASCII <span class="number">27</span> Esc)</span><br><span class="line">    <span class="keyword">set</span>(ColourReset <span class="string">&quot;$&#123;Esc&#125;[m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(ColourBold <span class="string">&quot;$&#123;Esc&#125;[1m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Red <span class="string">&quot;$&#123;Esc&#125;[31m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Green <span class="string">&quot;$&#123;Esc&#125;[32m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Yellow <span class="string">&quot;$&#123;Esc&#125;[33m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Blue <span class="string">&quot;$&#123;Esc&#125;[34m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Magenta <span class="string">&quot;$&#123;Esc&#125;[35m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(Cyan <span class="string">&quot;$&#123;Esc&#125;[36m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(White <span class="string">&quot;$&#123;Esc&#125;[37m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldRed <span class="string">&quot;$&#123;Esc&#125;[1;31m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldGreen <span class="string">&quot;$&#123;Esc&#125;[1;32m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldYellow <span class="string">&quot;$&#123;Esc&#125;[1;33m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldBlue <span class="string">&quot;$&#123;Esc&#125;[1;34m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldMagenta <span class="string">&quot;$&#123;Esc&#125;[1;35m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldCyan <span class="string">&quot;$&#123;Esc&#125;[1;36m&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(BoldWhite <span class="string">&quot;$&#123;Esc&#125;[1;37m&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-32"><a href="#具体实施-32" class="headerlink" title="具体实施"></a>具体实施</h3><p>来看下我们如何使用颜色定义，来生成彩色状态消息:</p>
<p>从一个熟悉的头部开始:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">02</span> LANGUAGES NONE)</span><br></pre></td></tr></table></figure></p>
<p>然后，将cmake子目录添加到CMake模块搜索的路径列表中:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>包括colors.cmake模块，调用其中定义的宏:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(colors)</span><br><span class="line">define_colors()</span><br></pre></td></tr></table></figure></p>
<p>最后，打印了不同颜色的信息:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;This is a normal message&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;Red&#125;This is a red$&#123;ColourReset&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;BoldRed&#125;This is a bold red$&#123;ColourReset&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;Green&#125;This is a green$&#123;ColourReset&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;BoldMagenta&#125;This is bold$&#123;ColourReset&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-32"><a href="#工作原理-32" class="headerlink" title="工作原理"></a>工作原理</h3><p>这个例子中，不需要编译代码，也不需要语言支持，我们已经用LANGUAGES NONE明确了这一点：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(recipe-<span class="number">02</span> LANGUAGES NONE)</span><br></pre></td></tr></table></figure></p>
<p>我们定义了define_colors宏，并将其放在cmake/colors.cmake。因为还是希望使用调用宏中定义的变量，来更改消息中的颜色，所以我们选择使用宏而不是函数。我们使用以下行包括宏和调用define_colors:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(colors)</span><br><span class="line">define_colors()</span><br></pre></td></tr></table></figure></p>
<p>我们还需要告诉CMake去哪里查找宏:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>include(colors)命令指示CMake搜索${CMAKE_MODULE_PATH}，查找名称为colors.cmake的模块。</p>
<p>例子中，我们没有按以下的方式进行：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"><span class="keyword">include</span>(colors)</span><br></pre></td></tr></table></figure></p>
<p>而是使用一个显式包含的方式:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(cmake/colors.cmake)</span><br></pre></td></tr></table></figure></p>
<h3 id="更多信息-9"><a href="#更多信息-9" class="headerlink" title="更多信息"></a>更多信息</h3><p>推荐的做法是在模块中定义宏或函数，然后调用宏或函数。将包含模块用作函数调用不是很好的方式。除了定义函数和宏以及查找程序、库和路径之外，包含模块不应该做更多的事情。实际的include命令不应该定义或修改变量，其原因是重复的include(可能是偶然的)不应该引入任何不想要的副作用。</p>
<h2 id="编写函数来测试和设置编译器标志"><a href="#编写函数来测试和设置编译器标志" class="headerlink" title="编写函数来测试和设置编译器标志"></a>编写函数来测试和设置编译器标志</h2><p>前两个示例中，我们使用了宏。本示例中，将使用一个函数来抽象细节并避免代码重复。我们将实现一个接受编译器标志列表的函数。该函数将尝试用这些标志逐个编译测试代码，并返回编译器理解的第一个标志。这样，我们将了解几个新特性：函数、列表操作、字符串操作，以及检查编译器是否支持相应的标志。</p>
<h3 id="准备工作-29"><a href="#准备工作-29" class="headerlink" title="准备工作"></a>准备工作</h3><p>按照上一个示例的推荐，我们将在(set_compiler_flag.cmake)模块中定义函数，然后调用函数。该模块包含以下代码，我们将在后面详细讨论:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CheckCCompilerFlag)</span><br><span class="line"><span class="keyword">include</span>(CheckCXXCompilerFlag)</span><br><span class="line"><span class="keyword">include</span>(CheckFortranCompilerFlag)</span><br><span class="line"><span class="keyword">function</span>(set_compiler_flag _result _lang)</span><br><span class="line">  <span class="comment"># build a list of flags from the arguments</span></span><br><span class="line">  <span class="keyword">set</span>(_list_of_flags)</span><br><span class="line">  <span class="comment"># also figure out whether the function</span></span><br><span class="line">  <span class="comment"># is required to find a flag</span></span><br><span class="line">  <span class="keyword">set</span>(_flag_is_required <span class="keyword">FALSE</span>)</span><br><span class="line">  <span class="keyword">foreach</span>(_arg IN ITEMS <span class="variable">$&#123;ARGN&#125;</span>)</span><br><span class="line">      <span class="keyword">string</span>(TOUPPER <span class="string">&quot;$&#123;_arg&#125;&quot;</span> _arg_uppercase)</span><br><span class="line">      <span class="keyword">if</span>(_arg_uppercase <span class="keyword">STREQUAL</span> <span class="string">&quot;REQUIRED&quot;</span>)</span><br><span class="line">          <span class="keyword">set</span>(_flag_is_required <span class="keyword">TRUE</span>)</span><br><span class="line">      <span class="keyword">else</span>()</span><br><span class="line">          <span class="keyword">list</span>(APPEND _list_of_flags <span class="string">&quot;$&#123;_arg&#125;&quot;</span>)</span><br><span class="line">      <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">endforeach</span>()</span><br><span class="line">  <span class="keyword">set</span>(_flag_found <span class="keyword">FALSE</span>)</span><br><span class="line">  <span class="comment"># loop over all flags, try to find the first which works</span></span><br><span class="line">  <span class="keyword">foreach</span>(flag IN ITEMS <span class="variable">$&#123;_list_of_flags&#125;</span>)</span><br><span class="line">      <span class="keyword">unset</span>(_flag_works CACHE)</span><br><span class="line">      <span class="keyword">if</span>(_lang <span class="keyword">STREQUAL</span> <span class="string">&quot;C&quot;</span>)</span><br><span class="line">          check_c_compiler_flag(<span class="string">&quot;$&#123;flag&#125;&quot;</span> _flag_works)</span><br><span class="line">      <span class="keyword">elseif</span>(_lang <span class="keyword">STREQUAL</span> <span class="string">&quot;CXX&quot;</span>)</span><br><span class="line">          check_cxx_compiler_flag(<span class="string">&quot;$&#123;flag&#125;&quot;</span> _flag_works)</span><br><span class="line">      <span class="keyword">elseif</span>(_lang <span class="keyword">STREQUAL</span> <span class="string">&quot;Fortran&quot;</span>)</span><br><span class="line">          check_Fortran_compiler_flag(<span class="string">&quot;$&#123;flag&#125;&quot;</span> _flag_works)</span><br><span class="line">      <span class="keyword">else</span>()</span><br><span class="line">          <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Unknown language in set_compiler_flag: $&#123;_lang&#125;&quot;</span>)</span><br><span class="line">          <span class="keyword">endif</span>()</span><br><span class="line">    <span class="comment"># if the flag works, use it, and exit</span></span><br><span class="line">    <span class="comment"># otherwise try next flag</span></span><br><span class="line">    <span class="keyword">if</span>(_flag_works)</span><br><span class="line">      <span class="keyword">set</span>(<span class="variable">$&#123;_result&#125;</span> <span class="string">&quot;$&#123;flag&#125;&quot;</span> PARENT_SCOPE)</span><br><span class="line">      <span class="keyword">set</span>(_flag_found <span class="keyword">TRUE</span>)</span><br><span class="line">      <span class="keyword">break</span>()</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">endforeach</span>()</span><br><span class="line">  <span class="comment"># raise an error if no flag was found</span></span><br><span class="line">  <span class="keyword">if</span>(_flag_is_required <span class="keyword">AND</span> <span class="keyword">NOT</span> _flag_found)</span><br><span class="line">      <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;None of the required flags were supported&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-33"><a href="#具体实施-33" class="headerlink" title="具体实施"></a>具体实施</h3><p>展示如何在CMakeLists.txt中使用set_compiler_flag函数:</p>
<p>定义最低CMake版本、项目名称和支持的语言(本例中是C和C++):<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">03</span> LANGUAGES C CXX)</span><br></pre></td></tr></table></figure></p>
<p>显示包含set_compiler_flag.cmake:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(set_compiler_flag.cmake)</span><br></pre></td></tr></table></figure></p>
<p>测试C标志列表:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set_compiler_flag(</span><br><span class="line">  working_compile_flag C REQUIRED</span><br><span class="line">  <span class="string">&quot;-foo&quot;</span> <span class="comment"># this should fail</span></span><br><span class="line">  <span class="string">&quot;-wrong&quot;</span> <span class="comment"># this should fail</span></span><br><span class="line">  <span class="string">&quot;-wrong&quot;</span> <span class="comment"># this should fail</span></span><br><span class="line">  <span class="string">&quot;-Wall&quot;</span> <span class="comment"># this should work with GNU</span></span><br><span class="line">  <span class="string">&quot;-warn all&quot;</span> <span class="comment"># this should work with Intel</span></span><br><span class="line">  <span class="string">&quot;-Minform=inform&quot;</span> <span class="comment"># this should work with PGI</span></span><br><span class="line">  <span class="string">&quot;-nope&quot;</span> <span class="comment"># this should fail</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;working C compile flag: $&#123;working_compile_flag&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>测试C++标志列表:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set_compiler_flag(</span><br><span class="line">  working_compile_flag CXX REQUIRED</span><br><span class="line">  <span class="string">&quot;-foo&quot;</span> <span class="comment"># this should fail</span></span><br><span class="line">  <span class="string">&quot;-g&quot;</span> <span class="comment"># this should work with GNU, Intel, PGI</span></span><br><span class="line">  <span class="string">&quot;/RTCcsu&quot;</span> <span class="comment"># this should work with MSVC</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;working CXX compile flag: $&#123;working_compile_flag&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>现在，我们可以配置项目并验证输出。只显示相关的输出，相应的输出可能会因编译器的不同而有所不同:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">-- ...</span><br><span class="line">-- Performing Test _flag_works</span><br><span class="line">-- Performing Test _flag_works - Failed</span><br><span class="line">-- Performing Test _flag_works</span><br><span class="line">-- Performing Test _flag_works - Failed</span><br><span class="line">-- Performing Test _flag_works</span><br><span class="line">-- Performing Test _flag_works - Failed</span><br><span class="line">-- Performing Test _flag_works</span><br><span class="line">-- Performing Test _flag_works - Success</span><br><span class="line">-- working C compile flag: -Wall</span><br><span class="line">-- Performing Test _flag_works</span><br><span class="line">-- Performing Test _flag_works - Failed</span><br><span class="line">-- Performing Test _flag_works</span><br><span class="line">-- Performing Test _flag_works - Success</span><br><span class="line">-- working CXX compile flag: -g</span><br><span class="line">-- ...</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-33"><a href="#工作原理-33" class="headerlink" title="工作原理"></a>工作原理</h3><p>这里使用的模式是:</p>
<ul>
<li>定义一个函数或宏，并将其放入模块中</li>
<li>包含模块</li>
<li>调用函数或宏</li>
</ul>
<p>从输出中，可以看到代码检查列表中的每个标志。一旦检查成功，它就打印成功的编译标志。看看set_compiler_flag.cmake模块的内部，这个模块又包含三个模块:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CheckCCompilerFlag)</span><br><span class="line"><span class="keyword">include</span>(CheckCXXCompilerFlag)</span><br><span class="line"><span class="keyword">include</span>(CheckFortranCompilerFlag)</span><br></pre></td></tr></table></figure></p>
<p>这都是标准的CMake模块，CMake将在<code>$&#123;CMAKE_MODULE_PATH&#125;</code>中找到它们。这些模块分别提供<code>check_c_compiler_flag</code>、<code>check_cxx_compiler_flag</code>和<code>check_fortran_compiler_flag</code>宏。然后定义函数:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(set_compiler_flag _result _lang)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure></p>
<p><code>set_compiler_flag</code>函数需要两个参数，<code>_result</code>(保存成功编译标志或为空字符串)和_lang(指定语言:C、C++或Fortran)。</p>
<p>我们也能这样调用函数:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_compiler_flag(working_compile_flag C REQUIRED <span class="string">&quot;-Wall&quot;</span> <span class="string">&quot;-warn all&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里有五个调用参数，但是函数头只需要两个参数。这意味着REQUIRED、-Wall和-warn all将放在${ARGN}中。从${ARGN}开始，我们首先使用foreach构建一个标志列表。同时，从标志列表中过滤出REQUIRED，并使用它来设置_flag_is_required:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># build a list of flags from the arguments</span></span><br><span class="line"><span class="keyword">set</span>(_list_of_flags)</span><br><span class="line"><span class="comment"># also figure out whether the function</span></span><br><span class="line"><span class="comment"># is required to find a flag</span></span><br><span class="line"><span class="keyword">set</span>(_flag_is_required <span class="keyword">FALSE</span>)</span><br><span class="line"><span class="keyword">foreach</span>(_arg IN ITEMS <span class="variable">$&#123;ARGN&#125;</span>)</span><br><span class="line">  <span class="keyword">string</span>(TOUPPER <span class="string">&quot;$&#123;_arg&#125;&quot;</span> _arg_uppercase)</span><br><span class="line">  <span class="keyword">if</span>(_arg_uppercase <span class="keyword">STREQUAL</span> <span class="string">&quot;REQUIRED&quot;</span>)</span><br><span class="line">      <span class="keyword">set</span>(_flag_is_required <span class="keyword">TRUE</span>)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">      <span class="keyword">list</span>(APPEND _list_of_flags <span class="string">&quot;$&#123;_arg&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><br>现在，我们将循环<code>$&#123;_list_of_flags&#125;</code>，尝试每个标志，如果<code>_flag_works</code>被设置为TRUE，我们将<code>_flag_found</code>设置为TRUE，并中止进一步的搜索:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(_flag_found <span class="keyword">FALSE</span>)</span><br><span class="line"><span class="comment"># loop over all flags, try to find the first which works</span></span><br><span class="line"><span class="keyword">foreach</span>(flag IN ITEMS <span class="variable">$&#123;_list_of_flags&#125;</span>)</span><br><span class="line">  <span class="keyword">unset</span>(_flag_works CACHE)</span><br><span class="line">  <span class="keyword">if</span>(_lang <span class="keyword">STREQUAL</span> <span class="string">&quot;C&quot;</span>)</span><br><span class="line">      check_c_compiler_flag(<span class="string">&quot;$&#123;flag&#125;&quot;</span> _flag_works)</span><br><span class="line">  <span class="keyword">elseif</span>(_lang <span class="keyword">STREQUAL</span> <span class="string">&quot;CXX&quot;</span>)</span><br><span class="line">      check_cxx_compiler_flag(<span class="string">&quot;$&#123;flag&#125;&quot;</span> _flag_works)</span><br><span class="line">  <span class="keyword">elseif</span>(_lang <span class="keyword">STREQUAL</span> <span class="string">&quot;Fortran&quot;</span>)</span><br><span class="line">      check_Fortran_compiler_flag(<span class="string">&quot;$&#123;flag&#125;&quot;</span> _flag_works)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">      <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Unknown language in set_compiler_flag: $&#123;_lang&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="comment"># if the flag works, use it, and exit</span></span><br><span class="line">  <span class="comment"># otherwise try next flag</span></span><br><span class="line">  <span class="keyword">if</span>(_flag_works)</span><br><span class="line">      <span class="keyword">set</span>(<span class="variable">$&#123;_result&#125;</span> <span class="string">&quot;$&#123;flag&#125;&quot;</span> PARENT_SCOPE)</span><br><span class="line">      <span class="keyword">set</span>(_flag_found <span class="keyword">TRUE</span>)</span><br><span class="line">      <span class="keyword">break</span>()</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure></p>
<p><code>unset(_flag_works CACHE)</code>确保<code>check_*_compiler_flag</code>的结果，不会在使用<code>_flag_works result</code>变量时，使用的是缓存结果。</p>
<p>如果找到了标志，并且<code>_flag_works</code>设置为TRUE，我们就将<code>_result</code>映射到的变量:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(<span class="variable">$&#123;_result&#125;</span> <span class="string">&quot;$&#123;flag&#125;&quot;</span> PARENT_SCOPE)</span><br></pre></td></tr></table></figure></p>
<p>这需要使用PARENT_SCOPE来完成，因为我们正在修改一个变量，希望打印并在函数体外部使用该变量。请注意，如何使用${_result}语法解引用，从父范围传递的变量_result的值。不管函数的名称是什么，这对于确保工作标志被设置非常有必要。如果没有找到任何标志，并且该标志设置了REQUIRED，那我们将使用一条错误消息停止配置:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># raise an error if no flag was found</span></span><br><span class="line"><span class="keyword">if</span>(_flag_is_required <span class="keyword">AND</span> <span class="keyword">NOT</span> _flag_found)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;None of the required flags were supported&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<h3 id="更多信息-10"><a href="#更多信息-10" class="headerlink" title="更多信息"></a>更多信息</h3><p>我们也可以使用宏来完成这个任务，而使用函数可以对范围有更多的控制。我们知道函数只能可以修改结果变量。</p>
<p>另外，需要在编译和链接时设置一些标志，方法是为<code>check_&lt;lang&gt;_compiler_flag</code>函数设置<code>CMAKE_REQUIRED_FLAGS</code>。</p>
<h2 id="用指定参数定义函数或宏"><a href="#用指定参数定义函数或宏" class="headerlink" title="用指定参数定义函数或宏"></a>用指定参数定义函数或宏</h2><p>前面的示例中，我们研究了函数和宏，并使用了位置参数。这个示例中，我们将定义一个带有命名参数的函数。我们将复用第1节中的示例，使用函数和宏重用代码，而不是使用以下代码定义测试：add_catch_test(short 1.5)。</p>
<p>我们将这样调用函数:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_catch_test(</span><br><span class="line">    NAME</span><br><span class="line">      short</span><br><span class="line">  LABELS</span><br><span class="line">      short</span><br><span class="line">      cpp_test</span><br><span class="line">  COST</span><br><span class="line">      <span class="number">1.5</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<h3 id="准备工作-30"><a href="#准备工作-30" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们使用第1节中的示例，使用函数和宏重用代码，并保持C++源代码不变，文件树保持不变：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── cmake</span><br><span class="line">│     └── testing.cmake</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── src</span><br><span class="line">│     ├── CMakeLists.txt</span><br><span class="line">│     ├── main.cpp</span><br><span class="line">│     ├── sum_integers.cpp</span><br><span class="line">│     └── sum_integers.hpp</span><br><span class="line">└── tests</span><br><span class="line">    ├── catch.hpp</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── test.cpp</span><br></pre></td></tr></table></figure>
<h3 id="具体实施-34"><a href="#具体实施-34" class="headerlink" title="具体实施"></a>具体实施</h3><p>我们对CMake代码进行一些修改，如下所示:</p>
<p>CMakeLists.txt顶部中只增加了一行，因为我们将包括位于cmake下面的模块:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>保持src/CMakeLists.txt。</p>
<p>tests/CMakeLists.txt中，将add_catch_test函数定义移动到cmake/testing.cmake，并且定义两个测试:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(cpp_test <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(cpp_test sum_integers)</span><br><span class="line"><span class="keyword">include</span>(testing)</span><br><span class="line">add_catch_test(</span><br><span class="line">  NAME</span><br><span class="line">      short</span><br><span class="line">  LABELS</span><br><span class="line">      short</span><br><span class="line">      cpp_test</span><br><span class="line">  COST</span><br><span class="line">      <span class="number">1.5</span></span><br><span class="line">  )</span><br><span class="line">add_catch_test(</span><br><span class="line">  NAME</span><br><span class="line">      long</span><br><span class="line">  LABELS</span><br><span class="line">      long</span><br><span class="line">      cpp_test</span><br><span class="line">  COST</span><br><span class="line">      <span class="number">2.5</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>add_catch_test在cmake/testing.cmake中定义:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(add_catch_test)</span><br><span class="line">  <span class="keyword">set</span>(options)</span><br><span class="line">  <span class="keyword">set</span>(oneValueArgs NAME COST)</span><br><span class="line">  <span class="keyword">set</span>(multiValueArgs LABELS DEPENDS REFERENCE_FILES)</span><br><span class="line">  <span class="keyword">cmake_parse_arguments</span>(add_catch_test</span><br><span class="line">    <span class="string">&quot;$&#123;options&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;$&#123;oneValueArgs&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;$&#123;multiValueArgs&#125;&quot;</span></span><br><span class="line">    <span class="variable">$&#123;ARGN&#125;</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;defining a test ...&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot; NAME: $&#123;add_catch_test_NAME&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot; LABELS: $&#123;add_catch_test_LABELS&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot; COST: $&#123;add_catch_test_COST&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot; REFERENCE_FILES: $&#123;add_catch_test_REFERENCE_FILES&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">add_test</span>(</span><br><span class="line">    NAME</span><br><span class="line">        <span class="variable">$&#123;add_catch_test_NAME&#125;</span></span><br><span class="line">    <span class="keyword">COMMAND</span></span><br><span class="line">        $&lt;TARGET_FILE:cpp_test&gt;</span><br><span class="line">    [<span class="variable">$&#123;add_catch_test_NAME&#125;</span>] --success --out</span><br><span class="line">        <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/tests/<span class="variable">$&#123;add_catch_test_NAME&#125;</span>.log --durations yes</span><br><span class="line">    WORKING_DIRECTORY</span><br><span class="line">        <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">set_tests_properties</span>(<span class="variable">$&#123;add_catch_test_NAME&#125;</span></span><br><span class="line">    PROPERTIES</span><br><span class="line">        LABELS <span class="string">&quot;$&#123;add_catch_test_LABELS&#125;&quot;</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">if</span>(add_catch_test_COST)</span><br><span class="line">    <span class="keyword">set_tests_properties</span>(<span class="variable">$&#123;add_catch_test_NAME&#125;</span></span><br><span class="line">    PROPERTIES</span><br><span class="line">        COST <span class="variable">$&#123;add_catch_test_COST&#125;</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">if</span>(add_catch_test_DEPENDS)</span><br><span class="line">    <span class="keyword">set_tests_properties</span>(<span class="variable">$&#123;add_catch_test_NAME&#125;</span></span><br><span class="line">      PROPERTIES</span><br><span class="line">          DEPENDS <span class="variable">$&#123;add_catch_test_DEPENDS&#125;</span></span><br><span class="line">      )</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">if</span>(add_catch_test_REFERENCE_FILES)</span><br><span class="line">    <span class="keyword">file</span>(</span><br><span class="line">      COPY</span><br><span class="line">          <span class="variable">$&#123;add_catch_test_REFERENCE_FILES&#125;</span></span><br><span class="line">      DESTINATION</span><br><span class="line">          <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">      )</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure></p>
<p>测试输出:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">-- ...</span><br><span class="line">-- defining a <span class="built_in">test</span> ...</span><br><span class="line">-- NAME: short</span><br><span class="line">-- LABELS: short;cpp_test</span><br><span class="line">-- COST: 1.5</span><br><span class="line">-- REFERENCE_FILES:</span><br><span class="line">-- defining a <span class="built_in">test</span> ...</span><br><span class="line">-- NAME: long</span><br><span class="line">-- LABELS: long;cpp_test</span><br><span class="line">-- COST: 2.5</span><br><span class="line">-- REFERENCE_FILES:</span><br><span class="line">-- ...</span><br></pre></td></tr></table></figure></p>
<p>最后，编译并测试：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br><span class="line">$ ctest</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-34"><a href="#工作原理-34" class="headerlink" title="工作原理"></a>工作原理</h3><p>示例的特点是其命名参数，因此我们可以将重点放在cmake/testing.cmake模块上。CMake提供<code>cmake_parse_arguments</code>命令，我们使用函数名(add_catch_test)选项(我们的例子中是none)、单值参数(NAME和COST)和多值参数(LABELS、DEPENDS和REFERENCE_FILES)调用该命令:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(add_catch_test)</span><br><span class="line">  <span class="keyword">set</span>(options)</span><br><span class="line">  <span class="keyword">set</span>(oneValueArgs NAME COST)</span><br><span class="line">  <span class="keyword">set</span>(multiValueArgs LABELS DEPENDS REFERENCE_FILES)</span><br><span class="line">  <span class="keyword">cmake_parse_arguments</span>(add_catch_test</span><br><span class="line">    <span class="string">&quot;$&#123;options&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;$&#123;oneValueArgs&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;$&#123;multiValueArgs&#125;&quot;</span></span><br><span class="line">    <span class="variable">$&#123;ARGN&#125;</span></span><br><span class="line">    )</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure></p>
<p><code>cmake_parse_arguments</code>命令解析选项和参数，并在例子中定义如下:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_catch_test_NAME</span><br><span class="line">add_catch_test_COST</span><br><span class="line">add_catch_test_LABELS</span><br><span class="line">add_catch_test_DEPENDS</span><br><span class="line">add_catch_test_REFERENCE_FILES</span><br></pre></td></tr></table></figure></p>
<p>可以查询，并在函数中使用这些变量。这种方法使我们有机会用更健壮的接口和更具有可读的函数/宏调用，来实现函数和宏。</p>
<h3 id="更多信息-11"><a href="#更多信息-11" class="headerlink" title="更多信息"></a>更多信息</h3><p>选项关键字(本例中我们没有使用)由cmake_parse_arguments定义为TRUE或FALSE。add_catch_test函数，还提供test命令作为一个命名参数，为了更简洁的演示，我们省略了这个参数。</p>
<p>TIPS:cmake_parse_arguments命令在cmake 3.5的版本前中的CMakeParseArguments.cmake定义。因此，可以在CMake/test.cmake顶部的使用include(CMakeParseArguments)命令使此示例能与CMake早期版本一起工作。</p>
<h2 id="重新定义函数和宏"><a href="#重新定义函数和宏" class="headerlink" title="重新定义函数和宏"></a>重新定义函数和宏</h2><p>我们已经提到模块包含不应该用作函数调用，因为模块可能被包含多次。本示例中，我们将编写我们自己的“包含保护”机制，如果多次包含一个模块，将触发警告。内置的include_guard命令从3.10版开始可以使用，对于C/C++头文件，它的行为就像#pragma一样。对于当前版本的CMake，我们将演示如何重新定义函数和宏，并且展示如何检查CMake版本，对于低于3.10的版本，我们将使用定制的“包含保护”机制。</p>
<h3 id="准备工作-31"><a href="#准备工作-31" class="headerlink" title="准备工作"></a>准备工作</h3><p>这个例子中，我们将使用三个文件:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmake</span><br><span class="line">│     ├── custom.cmake</span><br><span class="line">│     └── include_guard.cmake</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure></p>
<p>custom.cmake模块包含以下代码:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_guard</span>(GLOBAL)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;custom.cmake is included and processed&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们稍后会对cmake/include_guard.cmake进行讨论。</p>
<h3 id="具体实施-35"><a href="#具体实施-35" class="headerlink" title="具体实施"></a>具体实施</h3><p>我们对三个CMake文件的逐步分解:</p>
<p>示例中，我们不会编译任何代码，因此我们的语言要求是NONE:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">05</span> LANGUAGES NONE)</span><br></pre></td></tr></table></figure></p>
<p>定义一个include_guard宏，将其放在一个单独的模块中:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (re)defines include_guard</span></span><br><span class="line"><span class="keyword">include</span>(cmake/<span class="keyword">include_guard</span>.cmake)</span><br></pre></td></tr></table></figure></p>
<p>cmake/include_guard.cmake文件包含以下内容(稍后将详细讨论):<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(<span class="keyword">include_guard</span>)</span><br><span class="line">  <span class="keyword">if</span> (CMAKE_VERSION <span class="keyword">VERSION_LESS</span> <span class="string">&quot;3.10&quot;</span>)</span><br><span class="line">    <span class="comment"># for CMake below 3.10 we define our</span></span><br><span class="line">    <span class="comment"># own include_guard(GLOBAL)</span></span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;calling our custom include_guard&quot;</span>)</span><br><span class="line">    <span class="comment"># if this macro is called the first time</span></span><br><span class="line">    <span class="comment"># we start with an empty list</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> included_modules)</span><br><span class="line">      <span class="keyword">set</span>(included_modules)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_FILE&#125;&quot;</span> <span class="keyword">IN_LIST</span> included_modules)</span><br><span class="line">      <span class="keyword">message</span>(WARNING <span class="string">&quot;module $&#123;CMAKE_CURRENT_LIST_FILE&#125; processed more than once&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line">    <span class="keyword">list</span>(APPEND included_modules <span class="variable">$&#123;CMAKE_CURRENT_LIST_FILE&#125;</span>)</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line">    <span class="comment"># for CMake 3.10 or higher we augment</span></span><br><span class="line">    <span class="comment"># the built-in include_guard</span></span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;calling the built-in include_guard&quot;</span>)</span><br><span class="line">    _include_guard(<span class="variable">$&#123;ARGV&#125;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure></p>
<p>主CMakeLists.txt中，我们模拟了两次包含自定义模块的情况:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(cmake/custom.cmake)</span><br><span class="line"><span class="keyword">include</span>(cmake/custom.cmake)</span><br></pre></td></tr></table></figure></p>
<p>最后，使用以下命令进行配置:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br></pre></td></tr></table></figure></p>
<p>使用CMake 3.10及更高版本的结果如下:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- calling the built-in <span class="keyword">include_guard</span></span><br><span class="line">-- custom.cmake is included <span class="keyword">and</span> processed</span><br><span class="line">-- calling the built-in <span class="keyword">include_guard</span></span><br></pre></td></tr></table></figure></p>
<p>使用CMake得到3.10以下的结果如下:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- calling our custom <span class="keyword">include_guard</span></span><br><span class="line">-- custom.cmake is included <span class="keyword">and</span> processed</span><br><span class="line">-- calling our custom <span class="keyword">include_guard</span></span><br><span class="line">CMake Warning at cmake/<span class="keyword">include_guard</span>.cmake:<span class="number">7</span> (<span class="keyword">message</span>):</span><br><span class="line">module</span><br><span class="line">/home/user/example/cmake/custom.cmake</span><br><span class="line">processed more than once</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">cmake/custom.cmake:<span class="number">1</span> (<span class="keyword">include_guard</span>)</span><br><span class="line">CMakeLists.txt:<span class="number">12</span> (<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-35"><a href="#工作原理-35" class="headerlink" title="工作原理"></a>工作原理</h3><p>include_guard宏包含两个分支，一个用于CMake低于3.10，另一个用于CMake高于3.10:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(<span class="keyword">include_guard</span>)</span><br><span class="line">  <span class="keyword">if</span> (CMAKE_VERSION <span class="keyword">VERSION_LESS</span> <span class="string">&quot;3.10&quot;</span>)</span><br><span class="line">      <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">      <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure></p>
<p>如果CMake版本低于3.10，进入第一个分支，并且内置的include_guard不可用，所以我们自定义了一个:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;calling our custom include_guard&quot;</span>)</span><br><span class="line"><span class="comment"># if this macro is called the first time</span></span><br><span class="line"><span class="comment"># we start with an empty list</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> included_modules)</span><br><span class="line">    <span class="keyword">set</span>(included_modules)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_FILE&#125;&quot;</span> <span class="keyword">IN_LIST</span> included_modules)</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">&quot;module $&#123;CMAKE_CURRENT_LIST_FILE&#125; processed more than once&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">list</span>(APPEND included_modules <span class="variable">$&#123;CMAKE_CURRENT_LIST_FILE&#125;</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果第一次调用宏，则included_modules变量没有定义，因此我们将其设置为空列表。然后检查<code>$&#123;CMAKE_CURRENT_LIST_FILE&#125;</code>是否是included_modules列表中的元素。如果是，则会发出警告；如果没有，我们将<code>$&#123;CMAKE_CURRENT_LIST_FILE&#125;</code>追加到这个列表。CMake输出中，我们可以验证自定义模块的第二个包含确实会导致警告。</p>
<p>CMake 3.10及更高版本的情况有所不同；在这种情况下，存在一个内置的include_guard，我们用自己的宏接收到参数并调用它:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(<span class="keyword">include_guard</span>)</span><br><span class="line">  <span class="keyword">if</span> (CMAKE_VERSION <span class="keyword">VERSION_LESS</span> <span class="string">&quot;3.10&quot;</span>)</span><br><span class="line">      <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">      <span class="keyword">message</span>(STATUS <span class="string">&quot;calling the built-in include_guard&quot;</span>)</span><br><span class="line">      _include_guard(<span class="variable">$&#123;ARGV&#125;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>_include_guard($&#123;ARGV&#125;)</code>指向内置的include_guard。本例中，使用自定义消息(“调用内置的include_guard”)进行了扩展。这种模式为我们提供了一种机制，来重新定义自己的或内置的函数和宏，这对于调试或记录日志来说非常有用。</p>
<p>NOTE:这种模式可能很有用，但是应该谨慎使用，因为CMake不会对重新定义的宏或函数进行警告。</p>
<h2 id="使用废弃函数、宏和变量"><a href="#使用废弃函数、宏和变量" class="headerlink" title="使用废弃函数、宏和变量"></a>使用废弃函数、宏和变量</h2><p>“废弃”是在不断发展的项目开发过程中一种重要机制，它向开发人员发出信号，表明将来某个函数、宏或变量将被删除或替换。在一段时间内，函数、宏或变量将继续可访问，但会发出警告，最终可能会上升为错误。</p>
<h3 id="准备工作-32"><a href="#准备工作-32" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们将从以下CMake项目开始:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">06</span> LANGUAGES NONE)</span><br><span class="line"><span class="keyword">macro</span>(custom_include_guard)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> included_modules)</span><br><span class="line">      <span class="keyword">set</span>(included_modules)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_FILE&#125;&quot;</span> <span class="keyword">IN_LIST</span> included_modules)</span><br><span class="line">      <span class="keyword">message</span>(WARNING <span class="string">&quot;module $&#123;CMAKE_CURRENT_LIST_FILE&#125; processed more than once&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">list</span>(APPEND included_modules <span class="variable">$&#123;CMAKE_CURRENT_LIST_FILE&#125;</span>)</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br><span class="line"><span class="keyword">include</span>(cmake/custom.cmake)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;list of all included modules: $&#123;included_modules&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>这段代码定义了一个自定义的”包含保护”机制，包括一个自定义模块(与前一个示例中的模块相同)，并打印所有包含模块的列表。对于CMake 3.10或更高版本有内置的include_guard。但是，不能简单地删除<code>custom_include_guard</code>和<code>$&#123;included_modules&#125;</code>，而是使用一个“废弃”警告来弃用宏和变量。某个时候，可以将该警告转换为FATAL_ERROR，使代码停止配置，并迫使开发人员对代码进行修改，切换到内置命令。</p>
<h3 id="具体实施-36"><a href="#具体实施-36" class="headerlink" title="具体实施"></a>具体实施</h3><p>“废弃”函数、宏和变量的方法如下:</p>
<p>首先，定义一个函数，我们将使用它来弃用一个变量:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(deprecate_variable _variable _access)</span><br><span class="line">  <span class="keyword">if</span>(_access <span class="keyword">STREQUAL</span> <span class="string">&quot;READ_ACCESS&quot;</span>)</span><br><span class="line">      <span class="keyword">message</span>(DEPRECATION <span class="string">&quot;variable $&#123;_variable&#125; is deprecated&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure></p>
<p>然后，如果CMake的版本大于3.9，我们重新定义custom_include_guard并将variable_watch附加到included_modules中:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CMAKE_VERSION <span class="keyword">VERSION_GREATER</span> <span class="string">&quot;3.9&quot;</span>)</span><br><span class="line">  <span class="comment"># deprecate custom_include_guard</span></span><br><span class="line">  <span class="keyword">macro</span>(custom_include_guard)</span><br><span class="line">    <span class="keyword">message</span>(DEPRECATION <span class="string">&quot;custom_include_guard is deprecated - use built-in include_guard instead&quot;</span>)</span><br><span class="line">    _custom_include_guard(<span class="variable">$&#123;ARGV&#125;</span>)</span><br><span class="line">  <span class="keyword">endmacro</span>()</span><br><span class="line">  <span class="comment"># deprecate variable included_modules</span></span><br><span class="line">  <span class="keyword">variable_watch</span>(included_modules deprecate_variable)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>CMake3.10以下版本的项目会产生以下结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">-- custom.cmake is included and processed</span><br><span class="line">-- list of all included modules: /home/user/example/cmake/custom.cmake</span><br></pre></td></tr></table></figure></p>
<p>CMake 3.10及以上将产生预期的“废弃”警告:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CMake Deprecation Warning at CMakeLists.txt:26 (message):</span><br><span class="line">custom_include_guard is deprecated - use built-in include_guard instead</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">cmake/custom.cmake:1 (custom_include_guard)</span><br><span class="line">CMakeLists.txt:34 (include)</span><br><span class="line">-- custom.cmake is included and processed</span><br><span class="line">CMake Deprecation Warning at CMakeLists.txt:19 (message):</span><br><span class="line">variable included_modules is deprecated</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">CMakeLists.txt:9999 (deprecate_variable)</span><br><span class="line">CMakeLists.txt:36 (message)</span><br><span class="line">-- list of all included modules: /home/user/example/cmake/custom.cmake</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-36"><a href="#工作原理-36" class="headerlink" title="工作原理"></a>工作原理</h3><p>弃用函数或宏相当于重新定义它，如前面的示例所示，并使用DEPRECATION打印消息:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(somemacro)</span><br><span class="line">  <span class="keyword">message</span>(DEPRECATION <span class="string">&quot;somemacro is deprecated&quot;</span>)</span><br><span class="line">  _somemacro(<span class="variable">$&#123;ARGV&#125;</span>)</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure></p>
<p>可以通过定义以下变量来实现对变量的弃用:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(deprecate_variable _variable _access)</span><br><span class="line">  <span class="keyword">if</span>(_access <span class="keyword">STREQUAL</span> <span class="string">&quot;READ_ACCESS&quot;</span>)</span><br><span class="line">      <span class="keyword">message</span>(DEPRECATION <span class="string">&quot;variable $&#123;_variable&#125; is deprecated&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure></p>
<p>然后，这个函数被添加到将要“废弃”的变量上:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">variable_watch</span>(somevariable deprecate_variable)</span><br></pre></td></tr></table></figure></p>
<p>如果在本例中<code>$&#123;included_modules&#125;</code>是读取 (READ_ACCESS)，那么deprecate_variable函数将发出带有DEPRECATION的消息。</p>
<h1 id="语言混合项目"><a href="#语言混合项目" class="headerlink" title="语言混合项目"></a>语言混合项目</h1><h2 id="使用C-C-库构建Fortran项目"><a href="#使用C-C-库构建Fortran项目" class="headerlink" title="使用C/C++库构建Fortran项目"></a>使用C/C++库构建Fortran项目</h2><p>本示例将展示如何用C系统库和自定义C代码来对接Fortran代码。</p>
<h3 id="准备工作-33"><a href="#准备工作-33" class="headerlink" title="准备工作"></a>准备工作</h3><p>第7章中，我们把项目结构列为一个树。每个子目录都有一个CMakeLists.txt文件，其中包含与该目录相关的指令。这使我们可以对子目录进行限制中，如这个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">      ├── bt-randomgen-example.f90</span><br><span class="line">      ├── CMakeLists.txt</span><br><span class="line">      ├── interfaces</span><br><span class="line">      │         ├── CMakeLists.txt</span><br><span class="line">      │         ├── interface_backtrace.f90</span><br><span class="line">      │         ├── interface_randomgen.f90</span><br><span class="line">      │         └── randomgen.c</span><br><span class="line">      └── utils</span><br><span class="line">      ├── CMakeLists.txt</span><br><span class="line">      └── util_strings.f90</span><br></pre></td></tr></table></figure></p>
<p>我们的例子中，src子目录中包括bt-randomgen-example.f90，会将源码编译成可执行文件。另外两个子目录interface和utils包含更多的源代码，这些源代码将被编译成库。</p>
<p>interfaces子目录中的源代码展示了如何包装向后追踪的C系统库。例如，interface_backtrace.f90:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> interface_backtrace</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">interface</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> backtrace(buffer, <span class="built_in">size</span>) result(bt) <span class="keyword">bind</span>(C, <span class="keyword">name</span>=<span class="string">&quot;backtrace&quot;</span>)</span><br><span class="line">      <span class="keyword">use</span>, <span class="keyword">intrinsic</span> :: <span class="keyword">iso_c_binding</span>, <span class="keyword">only</span>: <span class="keyword">c_int</span>, <span class="keyword">c_ptr</span></span><br><span class="line">      <span class="keyword">type</span>(<span class="keyword">c_ptr</span>) :: buffer</span><br><span class="line">      <span class="keyword">integer</span>(<span class="keyword">c_int</span>), <span class="keyword">value</span> :: <span class="built_in">size</span></span><br><span class="line">      <span class="keyword">integer</span>(<span class="keyword">c_int</span>) :: bt</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> backtrace_symbols_fd(buffer, <span class="built_in">size</span>, fd) <span class="keyword">bind</span>(C, <span class="keyword">name</span>=<span class="string">&quot;backtrace_symbols_fd&quot;</span>)</span><br><span class="line">      <span class="keyword">use</span>, <span class="keyword">intrinsic</span> :: <span class="keyword">iso_c_binding</span>, <span class="keyword">only</span>: <span class="keyword">c_int</span>, <span class="keyword">c_ptr</span></span><br><span class="line">      <span class="keyword">type</span>(<span class="keyword">c_ptr</span>) :: buffer</span><br><span class="line">      <span class="keyword">integer</span>(<span class="keyword">c_int</span>), <span class="keyword">value</span> :: <span class="built_in">size</span>, fd</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br></pre></td></tr></table></figure></p>
<p>上面的例子演示了：</p>
<ul>
<li>内置iso_c_binding模块，确保Fortran和C类型和函数的互操作性。</li>
<li>interface声明，将函数在单独库中绑定到相应的符号上。</li>
<li>bind(C)属性，为声明的函数进行命名修饰。</li>
</ul>
<p>这个子目录还包含两个源文件:</p>
<ul>
<li>randomgen.c：这是一个C源文件，它对外公开了一个函数，使用C标准rand函数在一个区间内生成随机整数。</li>
<li>interface_randomgen.f90：它将C函数封装在Fortran可执行文件中使用。</li>
</ul>
<h3 id="具体实施-37"><a href="#具体实施-37" class="headerlink" title="具体实施"></a>具体实施</h3><p>我们有4个CMakeLists.txt实例要查看——根目录下1个，子目录下3个。让我们从根目录的CMakeLists.txt开始:</p>
<p>声明一个Fortran和C的混合语言项目:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span> LANGUAGES Fortran C)</span><br></pre></td></tr></table></figure></p>
<p>CMake将静态库和动态库保存在build目录下的lib目录中。可执行文件保存在bin目录下，Fortran编译模块文件保存在modules目录下:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/lib)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/lib)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_Fortran_MODULE_DIRECTORY</span><br><span class="line"><span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/modules)</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们进入第一个子CMakeLists.txt，添加src子目录:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></figure></p>
<p>src/CMakeLists.txt文件添加了两个子目录:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(interfaces)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(utils)</span><br></pre></td></tr></table></figure></p>
<p>在interfaces子目录中，我们将执行以下操作:</p>
<p>包括FortranCInterface.cmak模块，并验证C和Fortran编译器可以正确地交互:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FortranCInterface)</span><br><span class="line">FortranCInterface_VERIFY()</span><br></pre></td></tr></table></figure><br>接下来，我们找到Backtrace系统库，因为我们想在Fortran代码中使用它:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Backtrace REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>然后，创建一个共享库目标，其中包含Backtrace包装器、随机数生成器，以及Fortran包装器的源文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(bt-randomgen-wrap SHARED <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(bt-randomgen-wrap</span><br><span class="line">  PRIVATE</span><br><span class="line">    interface_backtrace.f90</span><br><span class="line">    interface_randomgen.f90</span><br><span class="line">    randomgen.c</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>我们还为新生成的库目标设置了链接库。使用PUBLIC属性，以便连接到其他目标时，能正确地看到依赖关系:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(bt-randomgen-wrap</span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="variable">$&#123;Backtrace_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>utils子目录中，还有一个CMakeLists.txt，其只有一单行程序：我们创建一个新的库目标，子目录中的源文件将被编译到这个目标库中。并与这个目标没有依赖关系:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(utils SHARED util_strings.f90)</span><br></pre></td></tr></table></figure></p>
<p>回到src/CMakeLists.txt:</p>
<p>使用bt-randomgen-example.f90添加一个可执行目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(bt-randomgen-example bt-randomgen-example.f90)</span><br></pre></td></tr></table></figure></p>
<p>最后，将在子CMakeLists.txt中生成的库目标，并链接到可执行目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(bt-randomgen-example</span><br><span class="line">  PRIVATE</span><br><span class="line">      bt-randomgen-wrap</span><br><span class="line">      utils</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-37"><a href="#工作原理-37" class="headerlink" title="工作原理"></a>工作原理</h3><p>确定链接了正确库之后，需要保证程序能够正确调用函数。每个编译器在生成机器码时都会执行命名检查。不过，这种操作的约定不是通用的，而是与编译器相关的。FortranCInterface，我们已经在第3章第4节时，检查所选C编译器与Fortran编译器的兼容性。对于当前的目的，命名检查并不是一个真正的问题。Fortran 2003标准提供了可选name参数的函数和子例程定义了bind属性。如果提供了这个参数，编译器将使用程序员指定的名称为这些子例程和函数生成符号。例如，backtrace函数可以从C语言中暴露给Fortran，并保留其命名:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> backtrace(buffer, size) result(bt) bind(C, name=<span class="string">&quot;backtrace&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="更多信息-12"><a href="#更多信息-12" class="headerlink" title="更多信息"></a>更多信息</h3><p>interface/CMakeLists.txt中的CMake代码还表明，可以使用不同语言的源文件创建库。CMake能够做到以下几点:</p>
<ul>
<li>列出的源文件中获取目标文件，并识别要使用哪个编译器。</li>
<li>选择适当的链接器，以便构建库(或可执行文件)。</li>
</ul>
<p>CMake如何决定使用哪个编译器？在project命令时使用参数LANGUAGES指定，这样CMake会检查系统上给定语言编译器。当使用源文件列表添加目标时，CMake将根据文件扩展名选择适当地编译器。因此，以.c结尾的文件使用C编译器编译，而以.f90结尾的文件(如果需要预处理，可以使用.F90)将使用Fortran编译器编译。类似地，对于C++， .cpp或.cxx扩展将触发C++编译器。我们只列出了C/C++和Fortran语言的一些可能的、有效的文件扩展名，但是CMake可以识别更多的扩展名。如果您的项目中的文件扩展名，由于某种原因不在可识别的扩展名之列，该怎么办？源文件属性可以用来告诉CMake在特定的源文件上使用哪个编译器，就像这样：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_source_files_properties</span>(my_source_file.axx</span><br><span class="line">  PROPERTIES</span><br><span class="line">      LANGUAGE CXX</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>那链接器呢？CMake如何确定目标的链接器语言？对于不混合编程语言的目标很简单：通过生成目标文件的编译器命令调用链接器即可。如果目标混合了多个语言，就像示例中一样，则根据在语言混合中，优先级最高的语言来选择链接器语言。比如，我们的示例中混合了Fortran和C，因此Fortran语言比C语言具有更高的优先级，因此使用Fortran用作链接器语言。当混合使用Fortran和C++时，后者具有更高的优先级，因此C++被用作链接器语言。就像编译器语言一样，我们可以通过目标相应的LINKER_LANGUAGE属性，强制CMake为我们的目标使用特定的链接器语言:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(my_target</span><br><span class="line">  PROPERTIES</span><br><span class="line">      LINKER_LANGUAGE Fortran</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<h2 id="使用Fortran库构建C-C-项目"><a href="#使用Fortran库构建C-C-项目" class="headerlink" title="使用Fortran库构建C/C++项目"></a>使用Fortran库构建C/C++项目</h2><p>第3章第4节，展示了如何检测Fortran编写的BLAS和LAPACK线性代数库，以及如何在C++代码中使用它们。这里，将重新讨论这个方式，但这次的角度有所不同：较少地关注检测外部库，会更深入地讨论混合C++和Fortran的方面，以及名称混乱的问题。</p>
<h3 id="准备工作-34"><a href="#准备工作-34" class="headerlink" title="准备工作"></a>准备工作</h3><p>本示例中，我们将重用第3章第4节源代码。虽然，我们不会修改源码或头文件，但我们会按照第7章“结构化项目”中，讨论的建议修改项目树结构，并得到以下源代码结构:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── README.md</span><br><span class="line">└── src</span><br><span class="line">      ├── CMakeLists.txt</span><br><span class="line">      ├── linear-algebra.cpp</span><br><span class="line">      └── math</span><br><span class="line">            ├── CMakeLists.txt</span><br><span class="line">            ├── CxxBLAS.cpp</span><br><span class="line">            ├── CxxBLAS.hpp</span><br><span class="line">            ├── CxxLAPACK.cpp</span><br><span class="line">            └── CxxLAPACK.hpp</span><br></pre></td></tr></table></figure></p>
<p>这里，收集了BLAS和LAPACK的所有包装器，它们提供了src/math下的数学库了，主要程序为linear-algebra.cpp。因此，所有源都在src子目录下。我们还将CMake代码分割为三个CMakeLists.txt文件，现在来讨论这些文件。</p>
<h3 id="具体实施-38"><a href="#具体实施-38" class="headerlink" title="具体实施"></a>具体实施</h3><p>这个项目混合了C++(作为该示例的主程序语言)和C(封装Fortran子例程所需的语言)。在根目录下的CMakeLists.txt文件中，我们需要做以下操作:</p>
<p>声明一个混合语言项目，并选择C++标准：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">02</span> LANGUAGES CXX C Fortran)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用GNUInstallDirs模块来设置CMake将静态和动态库，以及可执行文件保存的标准目录。我们还指示CMake将Fortran编译的模块文件放在modules目录下:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(GNUInstallDirs)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_Fortran_MODULE_DIRECTORY <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/modules)</span><br></pre></td></tr></table></figure></p>
<p>然后，进入下一个子目录:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></figure></p>
<p>子文件src/CMakeLists.txt添加了另一个目录math，其中包含线性代数包装器。在src/math/CMakeLists.txt中，我们需要以下操作:</p>
<p>调用find_package来获取BLAS和LAPACK库的位置:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(BLAS REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(LAPACK REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>包含FortranCInterface.cmake模块，并验证Fortran、C和C++编译器是否兼容:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FortranCInterface)</span><br><span class="line">FortranCInterface_VERIFY(CXX)</span><br></pre></td></tr></table></figure></p>
<p>我们还需要生成预处理器宏来处理BLAS和LAPACK子例程的名称问题。同样，FortranCInterface通过在当前构建目录中生成一个名为fc_mangl.h的头文件来提供协助:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FortranCInterface_HEADER(</span><br><span class="line">  fc_mangle.h</span><br><span class="line">  MACRO_NAMESPACE <span class="string">&quot;FC_&quot;</span></span><br><span class="line">  SYMBOLS DSCAL DGESV</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>接下来，添加了一个库，其中包含BLAS和LAPACK包装器的源代码。我们还指定要找到头文件和库的目录。注意PUBLIC属性，它允许其他依赖于math的目标正确地获得它们的依赖关系:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">math</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">math</span></span><br><span class="line">  PRIVATE</span><br><span class="line">    CxxBLAS.cpp</span><br><span class="line">    CxxLAPACK.cpp</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">math</span></span><br><span class="line">  PUBLIC</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">math</span></span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="variable">$&#123;LAPACK_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>回到src/CMakeLists.txt，我们最终添加了一个可执行目标，并将其链接到BLAS/LAPACK包装器的数学库:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(linear-algebra <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(linear-algebra</span><br><span class="line">  PRIVATE</span><br><span class="line">      linear-algebra.cpp</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(linear- algebra</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="keyword">math</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-38"><a href="#工作原理-38" class="headerlink" title="工作原理"></a>工作原理</h3><p>使用find_package确定了要链接到的库。方法和之前一样，需要确保程序能够正确地调用它们定义的函数。第3章第4节中，我们面临的问题是编译器的名称符号混乱。我们使用FortranCInterface模块来检查所选的C和C++编译器与Fortran编译器的兼容性。我们还使用FortranCInterface_HEADER函数生成带有宏的头文件，以处理Fortran子例程的名称混乱。并通过以下代码实现:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FortranCInterface_HEADER(</span><br><span class="line">  fc_mangle.h</span><br><span class="line">  MACRO_NAMESPACE <span class="string">&quot;FC_&quot;</span></span><br><span class="line">  SYMBOLS DSCAL DGESV</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这个命令将生成fc_mangl.h头文件，其中包含从Fortran编译器推断的名称混乱宏，并将其保存到当前二进制目录<code>CMAKE_CURRENT_BINARY_DIR</code>中。我们小心地将<code>CMAKE_CURRENT_BINARY_DIR</code>设置为数学目标的包含路径。生成的fc_mangle.h如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FC_HEADER_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FC_HEADER_INCLUDED</span></span><br><span class="line"><span class="comment">/* Mangling for Fortran global symbols without underscores. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FC_GLOBAL(name,NAME) name##_</span></span><br><span class="line"><span class="comment">/* Mangling for Fortran global symbols with underscores. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FC_GLOBAL_(name,NAME) name##_</span></span><br><span class="line"><span class="comment">/* Mangling for Fortran module symbols without underscores. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FC_MODULE(mod_name,name, mod_NAME,NAME) __##mod_name##_MOD_##name</span></span><br><span class="line"><span class="comment">/* Mangling for Fortran module symbols with underscores. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FC_MODULE_(mod_name,name, mod_NAME,NAME) __##mod_name##_MOD_##name</span></span><br><span class="line"><span class="comment">/* Mangle some symbols automatically. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSCAL FC_GLOBAL(dscal, DSCAL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGESV FC_GLOBAL(dgesv, DGESV)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>本例中的编译器使用下划线进行错误处理。由于Fortran不区分大小写，子例程可能以小写或大写出现，这就说明将这两种情况传递给宏的必要性。注意，CMake还将为隐藏在Fortran模块后面的符号生成宏。</p>
<p>NOTE:现在，BLAS和LAPACK的许多实现都在Fortran子例程附带了一个C的包装层。这些包装器已经标准化，分别称为CBLAS和LAPACKE。</p>
<p>由于已经将源组织成库目标和可执行目标，所以我们应该对目标的PUBLIC、INTERFACE和PRIVATE可见性属性的使用进行评论。与源文件一样，包括目录、编译定义和选项，当与<code>target_link_libraries</code>一起使用时，这些属性的含义是相同的:</p>
<ul>
<li>使用PRIVATE属性，库将只链接到当前目标，而不链接到使用它的任何其他目标。</li>
<li>使用INTERFACE属性，库将只链接到使用当前目标作为依赖项的目标。</li>
<li>使用PUBLIC属性，库将被链接到当前目标，以及将其作为依赖项使用的任何其他目标。</li>
</ul>
<h1 id="编写安装程序"><a href="#编写安装程序" class="headerlink" title="编写安装程序"></a>编写安装程序</h1><h2 id="安装项目"><a href="#安装项目" class="headerlink" title="安装项目"></a>安装项目</h2><p>第一个示例中，将介绍我们的小项目和一些基本概念，这些概念也将在后面的示例中使用。安装文件、库和可执行文件是一项非常基础的任务，但是也可能会带来一些缺陷。我们将带您了解这些问题，并展示如何使用CMake有效地避开这些缺陷。</p>
<h3 id="准备工作-35"><a href="#准备工作-35" class="headerlink" title="准备工作"></a>准备工作</h3><p>第1章第3节的示例，几乎复用：只添加对UUID库的依赖。这个依赖是有条件的，如果没有找到UUID库，我们将通过预处理程序排除使用UUID库的代码。项目布局如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── src</span><br><span class="line">│    ├── CMakeLists.txt</span><br><span class="line">│    ├── hello-world.cpp</span><br><span class="line">│    ├── Message.cpp</span><br><span class="line">│    └── Message.hpp</span><br><span class="line">└── tests</span><br><span class="line">    └── CMakeLists.txt</span><br></pre></td></tr></table></figure></p>
<p>我们已经看到，有三个CMakeLists.txt，一个是主CMakeLists.txt，另一个是位于src目录下的，还有一个是位于test目录下的。</p>
<p>Message.hpp头文件包含以下内容:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Message</span>(<span class="type">const</span> std::string &amp;m) : <span class="built_in">message_</span>(m) &#123;&#125;</span><br><span class="line">  <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, Message &amp;obj)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.<span class="built_in">printObject</span>(os);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string message_;</span><br><span class="line">  <span class="function">std::ostream &amp;<span class="title">printObject</span><span class="params">(std::ostream &amp;os)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::string <span class="title">getUUID</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>Message.cpp中有相应的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Message.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_UUID</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uuid/uuid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">Message::printObject</span><span class="params">(std::ostream &amp;os)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  os &lt;&lt; <span class="string">&quot;This is my very nice message: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  os &lt;&lt; message_ &lt;&lt; std::endl;</span><br><span class="line">  os &lt;&lt; <span class="string">&quot;...and here is its UUID: &quot;</span> &lt;&lt; <span class="built_in">getUUID</span>();</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_UUID</span></span><br><span class="line"><span class="function">std::string <span class="title">getUUID</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uuid_t</span> uuid;</span><br><span class="line">  <span class="built_in">uuid_generate</span>(uuid);</span><br><span class="line">  <span class="type">char</span> uuid_str[<span class="number">37</span>];</span><br><span class="line">  <span class="built_in">uuid_unparse_lower</span>(uuid, uuid_str);</span><br><span class="line">  <span class="built_in">uuid_clear</span>(uuid);</span><br><span class="line">  <span class="function">std::string <span class="title">uuid_cxx</span><span class="params">(uuid_str)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> uuid_cxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function">std::string <span class="title">getUUID</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Ooooops, no UUID for you!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">最后，示例hello-world.cpp内容如下:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Message.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Message <span class="title">say_hello</span><span class="params">(<span class="string">&quot;Hello, CMake World!&quot;</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; say_hello &lt;&lt; std::endl;</span><br><span class="line">  <span class="function">Message <span class="title">say_goodbye</span><span class="params">(<span class="string">&quot;Goodbye, CMake World&quot;</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; say_goodbye &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-39"><a href="#具体实施-39" class="headerlink" title="具体实施"></a>具体实施</h3><p>我们先来看一下主CMakeLists.txt:</p>
<p>声明CMake最低版本，并定义一个C++11项目。请注意，我们已经为我们的项目设置了一个版本，在project中使用VERSION进行指定:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake 3.6 needed for IMPORTED_TARGET option</span></span><br><span class="line"><span class="comment"># to pkg_search_module</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.6</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span></span><br><span class="line">LANGUAGES CXX</span><br><span class="line">VERSION <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; General set up &gt;&gt;&gt;</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></p>
<p>用户可以通过<code>CMAKE_INSTALL_PREFIX</code>变量定义安装目录。CMake会给这个变量设置一个默认值：Windows上的C:\Program Files和Unix上的/usr/local。我们将会打印安装目录的信息：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Project will be installed to $&#123;CMAKE_INSTALL_PREFIX&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，我们更喜欢以Release的方式配置项目。用户可以通过CMAKE_BUILD_TYPE设置此变量，从而改变配置类型，我们将检查是否存在这种情况。如果没有，将设置为默认值:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_BUILD_TYPE Release CACHE <span class="keyword">STRING</span> <span class="string">&quot;Build type&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Build type set to $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>接下来，告诉CMake在何处构建可执行、静态和动态库目标。便于在用户不打算安装项目的情况下，访问这些构建目标。这里使用标准CMake的GNUInstallDirs.cmake模块。这将确保的项目布局的合理性和可移植性：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(GNUInstallDirs)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>)</span><br></pre></td></tr></table></figure></p>
<p>虽然，前面的命令配置了构建目录中输出的位置，但是需要下面的命令来配置可执行程序、库以及安装前缀中包含的文件的位置。它们大致遵循相同的布局，但是我们定义了新的<code>INSTALL_LIBDIR</code>、<code>INSTALL_BINDIR</code>、<code>INSTALL_INCLUDEDIR</code>和<code>INSTALL_CMAKEDIR</code>变量。当然，也可以覆盖这些变量：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Offer the user the choice of overriding the installation directories</span></span><br><span class="line"><span class="keyword">set</span>(INSTALL_LIBDIR <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span> CACHE PATH <span class="string">&quot;Installation directory for libraries&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(INSTALL_BINDIR <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span> CACHE PATH <span class="string">&quot;Installation directory for executables&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(INSTALL_INCLUDEDIR <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span> CACHE PATH <span class="string">&quot;Installation directory for header files&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(WIN32 <span class="keyword">AND</span> <span class="keyword">NOT</span> CYGWIN)</span><br><span class="line">    <span class="keyword">set</span>(DEF_INSTALL_CMAKEDIR CMake)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(DEF_INSTALL_CMAKEDIR share/cmake/<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">set</span>(INSTALL_CMAKEDIR <span class="variable">$&#123;DEF_INSTALL_CMAKEDIR&#125;</span> CACHE PATH <span class="string">&quot;Installation directory for CMake files&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>报告组件安装的路径:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Report to user</span></span><br><span class="line"><span class="keyword">foreach</span>(p LIB BIN <span class="keyword">INCLUDE</span> CMAKE)</span><br><span class="line">  <span class="keyword">file</span>(TO_NATIVE_PATH <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;INSTALL_$&#123;p&#125;</span>DIR&#125; _path )</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Installing $&#123;p&#125; components to $&#123;_path&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">unset</span>(_path)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure></p>
<p>主CMakeLists.txt文件中的最后一个指令添加src子目录，启用测试，并添加tests子目录：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"><span class="keyword">add_subdirectory</span>(tests)</span><br></pre></td></tr></table></figure></p>
<p>现在我们继续分析src/CMakeLists.txt，其定义了构建的实际目标：</p>
<p>我们的项目依赖于UUID库：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Search for pkg-config and UUID</span></span><br><span class="line"><span class="keyword">find_package</span>(PkgConfig QUIET)</span><br><span class="line"><span class="keyword">if</span>(PKG_CONFIG_FOUND)</span><br><span class="line">  pkg_search_module(UUID uuid IMPORTED_TARGET)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">TARGET</span> PkgConfig::UUID)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Found libuuid&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(UUID_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>我们希望建立一个动态库，将该目标声明为message-shared:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span>-shared SHARED <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>这个目标由target_sources命令指定:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/<span class="keyword">Message</span>.cpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>我们为目标声明编译时定义和链接库。请注意，所有这些都是PUBLIC，以确保所有依赖的目标将正确继承它们:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">target_compile_definitions</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PUBLIC</span><br><span class="line">      $&lt;$&lt;BOOL:<span class="variable">$&#123;UUID_FOUND&#125;</span>&gt;:HAVE_UUID&gt;</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PUBLIC</span><br><span class="line">      $&lt;$&lt;BOOL:<span class="variable">$&#123;UUID_FOUND&#125;</span>&gt;:PkgConfig::UUID&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>然后设置目标的附加属性:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PROPERTIES</span><br><span class="line">    POSITION_INDEPENDENT_CODE <span class="number">1</span></span><br><span class="line">    SOVERSION <span class="variable">$&#123;PROJECT_VERSION_MAJOR&#125;</span></span><br><span class="line">    OUTPUT_NAME <span class="string">&quot;message&quot;</span></span><br><span class="line">    DEBUG_POSTFIX <span class="string">&quot;_d&quot;</span></span><br><span class="line">    PUBLIC_HEADER <span class="string">&quot;Message.hpp&quot;</span></span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">    WINDOWS_EXPORT_ALL_SYMBOLS <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，为“Hello, world”程序添加可执行目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-world_wDSO hello-world.cpp)</span><br></pre></td></tr></table></figure></p>
<p>hello-world_wDSO可执行目标，会链接到动态库：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(hello-world_wDSO</span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="keyword">message</span>-shared</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>src/CMakeLists.txt文件中，还包含安装指令。考虑这些之前，我们需要设置可执行文件的RPATH：</p>
<p>使用CMake路径操作，我们可以设置message_RPATH变量。这将为GNU/Linux和macOS设置适当的RPATH:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RPATH</span><br><span class="line"><span class="keyword">file</span>(RELATIVE_PATH _rel <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;INSTALL_BINDIR&#125;</span> <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>)</span><br><span class="line"><span class="keyword">if</span>(APPLE)</span><br><span class="line">    <span class="keyword">set</span>(_rpath <span class="string">&quot;@loader_path/$&#123;_rel&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(_rpath <span class="string">&quot;\$ORIGIN/$&#123;_rel&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">file</span>(TO_NATIVE_PATH <span class="string">&quot;$&#123;_rpath&#125;/$&#123;INSTALL_LIBDIR&#125;&quot;</span> message_RPATH)</span><br></pre></td></tr></table></figure></p>
<p>现在，可以使用这个变量来设置可执行目标hello-world_wDSO的RPATH(通过目标属性实现)。我们也可以设置额外的属性，稍后会对此进行更多的讨论:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(hello-world_wDSO</span><br><span class="line">  PROPERTIES</span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">    SKIP_BUILD_RPATH <span class="keyword">OFF</span></span><br><span class="line">    BUILD_WITH_INSTALL_RPATH <span class="keyword">OFF</span></span><br><span class="line">    INSTALL_RPATH <span class="string">&quot;$&#123;message_RPATH&#125;&quot;</span></span><br><span class="line">    INSTALL_RPATH_USE_LINK_PATH <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>终于可以安装库、头文件和可执行文件了！使用CMake提供的install命令来指定安装位置。注意，路径是相对的，我们将在后续进一步讨论这一点:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS</span><br><span class="line">    <span class="keyword">message</span>-shared</span><br><span class="line">    hello-world_wDSO</span><br><span class="line">  ARCHIVE</span><br><span class="line">    DESTINATION <span class="variable">$&#123;INSTALL_LIBDIR&#125;</span></span><br><span class="line">    COMPONENT lib</span><br><span class="line">  RUNTIME</span><br><span class="line">    DESTINATION <span class="variable">$&#123;INSTALL_BINDIR&#125;</span></span><br><span class="line">    COMPONENT bin</span><br><span class="line">  LIBRARY</span><br><span class="line">    DESTINATION <span class="variable">$&#123;INSTALL_LIBDIR&#125;</span></span><br><span class="line">    COMPONENT lib</span><br><span class="line">  PUBLIC_HEADER</span><br><span class="line">    DESTINATION <span class="variable">$&#123;INSTALL_INCLUDEDIR&#125;</span>/<span class="keyword">message</span></span><br><span class="line">    COMPONENT dev</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>tests目录中的CMakeLists.txt文件包含简单的指令，以确保“Hello, World”可执行文件能够正确运行：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME test_shared</span><br><span class="line">  <span class="keyword">COMMAND</span> $&lt;TARGET_FILE:hello-world_wDSO&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>现在让我们配置、构建和安装项目，并查看结果。添加安装指令时，CMake就会生成一个名为install的新目标，该目标将运行安装规则:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -G<span class="string">&quot;Unix Makefiles&quot;</span> -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/Software/recipe-01</span><br><span class="line">$ cmake --build . --target install</span><br></pre></td></tr></table></figure></p>
<p>GNU/Linux构建目录的内容如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">build</span><br><span class="line">├── bin</span><br><span class="line">│    └── hello-world_wDSO</span><br><span class="line">├── CMakeCache.txt</span><br><span class="line">├── CMakeFiles</span><br><span class="line">├── cmake_install.cmake</span><br><span class="line">├── CTestTestfile.cmake</span><br><span class="line">├── install_manifest.txt</span><br><span class="line">├── lib64</span><br><span class="line">│    ├── libmessage.so -&gt; libmessage.so.1</span><br><span class="line">│    └── libmessage.so.1</span><br><span class="line">├── Makefile</span><br><span class="line">├── src</span><br><span class="line">├── Testing</span><br><span class="line">└── tests</span><br></pre></td></tr></table></figure></p>
<p>另一方面，在安装位置，可以找到如下的目录结构:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$HOME/Software/recipe-01/</span><br><span class="line">├── bin</span><br><span class="line">│    └── hello-world_wDSO</span><br><span class="line">├── include</span><br><span class="line">│    └── message</span><br><span class="line">│        └── Message.hpp</span><br><span class="line">└── lib64</span><br><span class="line">    ├── libmessage.so -&gt; libmessage.so.1</span><br><span class="line">    └── libmessage.so.1</span><br></pre></td></tr></table></figure></p>
<p>这意味着安装指令中给出的位置，是相对于用户给定的CMAKE_INSTALL_PREFIX路径。</p>
<h3 id="工作原理-39"><a href="#工作原理-39" class="headerlink" title="工作原理"></a>工作原理</h3><p>这个示例有三个要点我们需要更详细地讨论：</p>
<ul>
<li>使用GNUInstallDirs.cmake定义目标安装的标准位置</li>
<li>在动态库和可执行目标上设置的属性，特别是RPATH的处理</li>
<li>安装指令</li>
</ul>
<p>GNUInstallDirs.cmake模块所做的就是定义这样一组变量，这些变量是安装不同类型文件的子目录的名称。在例子中，使用了以下内容:</p>
<ul>
<li><code>*CMAKE_INSTALL_BINDIR</code>：这将用于定义用户可执行文件所在的子目录，即所选安装目录下的bin目录。</li>
<li><code>CMAKE_INSTALL_LIBDIR</code>：这将扩展到目标代码库(即静态库和动态库)所在的子目录。在64位系统上，它是lib64，而在32位系统上，它只是lib。</li>
<li><code>CMAKE_INSTALL_INCLUDEDIR</code>：最后，我们使用这个变量为C头文件获取正确的子目录，该变量为include。</li>
</ul>
<p>然而，用户可能希望覆盖这些选项。我们允许在主CMakeLists.txt文件中使用以下方式覆盖选项:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Offer the user the choice</span></span><br><span class="line">of overriding the installation directories</span><br><span class="line"><span class="keyword">set</span>(INSTALL_LIBDIR <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span> CACHE PATH</span><br><span class="line"><span class="string">&quot;Installation directory for libraries&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(INSTALL_BINDIR <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span> CACHE PATH</span><br><span class="line"><span class="string">&quot;Installation directory for executables&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(INSTALL_INCLUDEDIR <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span> CACHE</span><br><span class="line">PATH <span class="string">&quot;Installation directory for header files&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>这重新定义了在项目中使用的<code>INSTALL_BINDIR</code>、<code>INSTALL_LIBDIR</code>和<code>INSTALL_INCLUDEDIR</code>变量。我们还定义了<code>INSTALL_CMAKEDIR</code>变量，但它所扮演的角色将在接下来的几个示例中详细讨论。</p>
<p>在动态库目标上设置的属性，需要设置以下内容:</p>
<ul>
<li><code>POSITION_INDEPENDENT_CODE 1</code>：设置生成位置无关代码所需的编译器标志。</li>
<li><code>SOVERSION $&#123;PROJECT_VERSION_MAJOR&#125;</code> : 这是动态库提供的应用程序编程接口(API)版本。在设置语义版本之后，将其设置为与项目的主版本一致。CMake目标也有一个版本属性，可以用来指定目标的构建版本。注意，SOVERSION和VERSION有所不同：随着时间的推移，提供相同API的多个构建版本。本例中，我们不关心这种的粒度控制：仅使用SOVERSION属性设置API版本就足够了，CMake将为我们将VERSION设置为相同的值。</li>
<li><code>OUTPUT_NAME &quot;message&quot;</code>：这告诉CMake库的名称message，而不是目标message-shared的名称，libmessage.so.1将在构建时生成。从前面给出的构建目录和安装目录的也可以看出，libmessage.so的符号链接也将生成。</li>
<li><code>DEBUG_POSTFIX &quot;_d&quot;</code>：这告诉CMake，如果我们以Debug配置构建项目，则将_d后缀添加到生成的动态库。</li>
<li><code>PUBLIC_HEADER &quot;Message.hpp&quot;</code>：我们使用这个属性来设置头文件列表(本例中只有一个头文件)，声明提供的API函数。这主要用于macOS上的动态库目标，也可以用于其他操作系统和目标。</li>
<li><code>MACOSX_RPATH ON</code>：这将动态库的install_name部分(目录)设置为macOS上的@rpath。</li>
<li><code>WINDOWS_EXPORT_ALL_SYMBOLS ON</code>：这将强制在Windows上编译以导出所有符号。注意，这通常不是一个好的方式，我们将在第2节中展示如何生成导出头文件，以及如何在不同的平台上保证符号的可见性。</li>
</ul>
<p>现在讨论一下RPATH。我们将hello-world_wDSO可执行文件链接到libmessage.so.1，这意味着在执行时，将加载动态库。因此，有关库位置的信息需要在某个地方进行编码，以便加载程序能够成功地完成其工作。</p>
<p>GNU/Linux上，库的定位需要将路径附加到<code>LD_LIBRARY_PATH</code>环境变量中。注意，这很可能会污染系统中所有应用程序的链接器路径，并可能导致符号冲突。</p>
<p>设置动态对象的RPATH时，应该选择哪个路径？我们需要确保可执行文件总是找到正确的动态库，不管它是在构建树中运行还是在安装树中运行。这需要通过设置hello-world_wDSO目标的RPATH相关属性来实现的，通过<code>$ORIGIN</code>(在GNU/Linux上)变量来查找与可执行文件本身位置相关的路径:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Prepare RPATH</span></span><br><span class="line"><span class="keyword">file</span>(RELATIVE_PATH _rel <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;INSTALL_BINDIR&#125;</span> <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>)</span><br><span class="line"><span class="keyword">if</span>(APPLE)</span><br><span class="line">    <span class="keyword">set</span>(_rpath <span class="string">&quot;@loader_path/$&#123;_rel&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(_rpath <span class="string">&quot;\$ORIGIN/$&#123;_rel&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">file</span>(TO_NATIVE_PATH <span class="string">&quot;$&#123;_rpath&#125;/$&#123;INSTALL_LIBDIR&#125;&quot;</span> message_RPATH)</span><br></pre></td></tr></table></figure></p>
<p>当设置了message_RPATH变量，目标属性将完成剩下的工作:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(hello-world_wDSO</span><br><span class="line">    PROPERTIES</span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">    SKIP_BUILD_RPATH <span class="keyword">OFF</span></span><br><span class="line">    BUILD_WITH_INSTALL_RPATH <span class="keyword">OFF</span></span><br><span class="line">    INSTALL_RPATH <span class="string">&quot;$&#123;message_RPATH&#125;&quot;</span></span><br><span class="line">    INSTALL_RPATH_USE_LINK_PATH <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>让我们详细研究一下这个命令：</p>
<ul>
<li><code>SKIP_BUILD_RPATH OFF</code>：告诉CMake生成适当的RPATH，以便能够在构建树中运行可执行文件。</li>
<li><code>UILD_WITH_INSTALL_RPATH OFF</code>：关闭生成可执行目标，使其RPATH调整为与安装树的RPATH相同。在构建树中不运行可执行文件。</li>
<li><code>INSTALL_RPATH &quot;$&#123;message_RPATH&#125;&quot;</code>：将已安装的可执行目标的RPATH设置为先前的路径。</li>
<li><code>INSTALL_RPATH_USE_LINK_PATH ON</code>：告诉CMake将链接器搜索路径附加到可执行文件的RPATH中。</li>
</ul>
<p>最后，看一下安装指令。我们需要安装一个可执行文件、一个库和一个头文件。可执行文件和库是构建目标，因此我们使用安装命令的TARGETS选项。可以同时设置多个目标的安装规则：CMake知道它们是什么类型的目标，无论其是可执行程序库、动态库，还是静态库:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS</span><br><span class="line">    <span class="keyword">message</span>-shared</span><br><span class="line">    hello-world_wDSO</span><br></pre></td></tr></table></figure></p>
<p>可执行文件将安装在<code>RUNTIME DESTINATION</code>，将其设置为<code>$&#123;INSTALL_BINDIR&#125;</code>。动态库安装到<code>LIBRARY_DESTINATION</code>，将其设置为<code>$&#123;INSTALL_LIBDIR&#125;</code>。静态库将安装到<code>ARCHIVE DESTINATION</code>，将其设置为<code>$&#123;INSTALL_LIBDIR&#125;</code>:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ARCHIVE</span><br><span class="line">  DESTINATION <span class="variable">$&#123;INSTALL_LIBDIR&#125;</span></span><br><span class="line">  COMPONENT lib</span><br><span class="line">RUNTIME</span><br><span class="line">  DESTINATION <span class="variable">$&#123;INSTALL_BINDIR&#125;</span></span><br><span class="line">  COMPONENT bin</span><br><span class="line">LIBRARY</span><br><span class="line">  DESTINATION <span class="variable">$&#123;INSTALL_LIBDIR&#125;</span></span><br><span class="line">  COMPONENT lib</span><br></pre></td></tr></table></figure></p>
<p>注意，这里不仅指定了DESTINATION，还指定了COMPONENT。使用cmake —build . —target install安装命令，所有组件会按预期安装完毕。然而，有时只安装其中一些可用的。这就是COMPONENT关键字帮助我们做的事情。例如，当只要求安装库，我们可以执行以下步骤:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -D COMPONENT=lib -P cmake_install.cmake</span><br></pre></td></tr></table></figure></p>
<p>自从Message.hpp头文件设置为项目的公共头文件，我们可以使用PUBLIC_HEADER关键字将其与其他目标安装到选择的目的地:${INSTALL_INCLUDEDIR}/message。库用户现在可以包含头文件：#include <message/Message.hpp>，这需要在编译时，使用-I选项将正确的头文件查找路径位置传递给编译器。</p>
<p>安装指令中的各种目标地址会被解释为相对路径，除非使用绝对路径。但是相对于哪里呢？根据不同的安装工具而不同，而CMake可以去计算目标地址的绝对路径。当使用<code>cmake --build . --target install</code>，路径将相对于<code>CMAKE_INSTALL_PREFIX</code>计算。但当使用CPack时，绝对路径将相对于<code>CPACK_PACKAGING_INSTALL_PREFIX</code>计算。CPack的用法将在第11章中介绍。</p>
<h2 id="生成输出头文件"><a href="#生成输出头文件" class="headerlink" title="生成输出头文件"></a>生成输出头文件</h2><p>设想一下，当我们的小型库非常受欢迎时，许多人都在使用它。然而，一些客户希望在安装时使用静态库，而另一些客户也注意到所有符号在动态库中都是可见的。最佳方式是规定动态库只公开最小的符号，从而限制代码中定义的对象和函数对外的可见性。我们希望在默认情况下，动态库定义的所有符号都对外隐藏。这将使得项目的贡献者，能够清楚地划分库和外部代码之间的接口，因为他们必须显式地标记所有要在项目外部使用的符号。因此，我们需要完成以下工作：</p>
<ul>
<li>使用同一组源文件构建动态库和静态库</li>
<li>确保正确分隔动态库中符号的可见性</li>
</ul>
<h3 id="准备工作-36"><a href="#准备工作-36" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们仍将使用与前一个示例中基本相同的代码，但是我们需要修改src/CMakeLists.txt和Message.hpp头文件。后者将包括新的、自动生成的头文件messageExport.h:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;messageExport.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">message_EXPORT</span> Message</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Message</span>(<span class="type">const</span> std::string &amp;m) : <span class="built_in">message_</span>(m) &#123;&#125;</span><br><span class="line">  <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, Message &amp;obj)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.<span class="built_in">printObject</span>(os);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string message_;</span><br><span class="line">  <span class="function">std::ostream &amp;<span class="title">printObject</span><span class="params">(std::ostream &amp;os)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::string <span class="title">getUUID</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>Message类的声明中引入了message_EXPORT预处理器指令，这个指令将让编译器生成对库的用户可见的符号。</p>
<h3 id="具体实施-40"><a href="#具体实施-40" class="headerlink" title="具体实施"></a>具体实施</h3><p>除了项目的名称外，主CMakeLists.txt文件没有改变。首先，看看src子目录中的CMakeLists.txt文件，所有工作实际上都在这里进行。我们将重点展示对之前示例的修改之处:</p>
<p>为消息传递库声明SHARED库目标及其源。注意，编译定义和链接库没有改变:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span>-shared SHARED <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/<span class="keyword">Message</span>.cpp</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_compile_definitions</span>(<span class="keyword">message</span>-shared</span><br><span class="line">    PUBLIC</span><br><span class="line">      $&lt;$&lt;BOOL:<span class="variable">$&#123;UUID_FOUND&#125;</span>&gt;:HAVE_UUID&gt;</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PUBLIC</span><br><span class="line">      $&lt;$&lt;BOOL:<span class="variable">$&#123;UUID_FOUND&#125;</span>&gt;:PkgConfig::UUID&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>设置目标属性。将<code>$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;/messageExport.h</code>头文件添加到公共头列表中，作为PUBLIC_HEADER目标属性的参数。<code>CXX_VISIBILITY_PRESET</code>置和<code>VISIBILITY_INLINES_HIDDEN</code>属性将在下一节中讨论:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PROPERTIES</span><br><span class="line">    POSITION_INDEPENDENT_CODE <span class="number">1</span></span><br><span class="line">    CXX_VISIBILITY_PRESET hidden</span><br><span class="line">    VISIBILITY_INLINES_HIDDEN <span class="number">1</span></span><br><span class="line">    SOVERSION <span class="variable">$&#123;PROJECT_VERSION_MAJOR&#125;</span></span><br><span class="line">    OUTPUT_NAME <span class="string">&quot;message&quot;</span></span><br><span class="line">    DEBUG_POSTFIX <span class="string">&quot;_d&quot;</span></span><br><span class="line">    PUBLIC_HEADER <span class="string">&quot;Message.hpp;$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;/messageExport.h&quot;</span></span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>包含GenerateExportHeader.cmake模块并调用generate_export_header函数，这将在构建目录的子目录中生成messageExport.h头文件。我们将稍后会详细讨论这个函数和生成的头文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(GenerateExportHeader)</span><br><span class="line">generate_export_header(<span class="keyword">message</span>-shared</span><br><span class="line">  BASE_NAME <span class="string">&quot;message&quot;</span></span><br><span class="line">  EXPORT_MACRO_NAME <span class="string">&quot;message_EXPORT&quot;</span></span><br><span class="line">  EXPORT_FILE_NAME <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;/messageExport.h&quot;</span></span><br><span class="line">  DEPRECATED_MACRO_NAME <span class="string">&quot;message_DEPRECATED&quot;</span></span><br><span class="line">  NO_EXPORT_MACRO_NAME <span class="string">&quot;message_NO_EXPORT&quot;</span></span><br><span class="line">  STATIC_DEFINE <span class="string">&quot;message_STATIC_DEFINE&quot;</span></span><br><span class="line">  NO_DEPRECATED_MACRO_NAME <span class="string">&quot;message_NO_DEPRECATED&quot;</span></span><br><span class="line">  DEFINE_NO_DEPRECATED</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>当要更改符号的可见性(从其默认值-隐藏值)时，都应该包含导出头文件。我们已经在Message.hpp头文件例这样做了，因为想在库中公开一些符号。现在将<code>$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;</code>目录作为message-shared目标的PUBLIC包含目录列出：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;INSTALL_INCLUDEDIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>现在，可以将注意力转向静态库的生成：</p>
<p>添加一个库目标来生成静态库。将编译与静态库相同的源文件，以获得此动态库目标：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span>-static STATIC <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">message</span>-static</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/<span class="keyword">Message</span>.cpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>设置编译器定义，包含目录和链接库，就像我们为动态库目标所做的一样。但请注意，我们添加了message_STATIC_DEFINE编译时宏定义，为了确保我们的符号可以适当地暴露:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(<span class="keyword">message</span>-static</span><br><span class="line">  PUBLIC</span><br><span class="line">      message_STATIC_DEFINE</span><br><span class="line">      $&lt;$&lt;BOOL:<span class="variable">$&#123;UUID_FOUND&#125;</span>&gt;:HAVE_UUID&gt;</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">message</span>-static</span><br><span class="line">      PUBLIC</span><br><span class="line">      <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;INSTALL_INCLUDEDIR&#125;</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">message</span>-static</span><br><span class="line">  PUBLIC</span><br><span class="line">      $&lt;$&lt;BOOL:<span class="variable">$&#123;UUID_FOUND&#125;</span>&gt;:PkgConfig::UUID&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>还设置了message-static目标的属性:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(<span class="keyword">message</span>-static</span><br><span class="line">  PROPERTIES</span><br><span class="line">    POSITION_INDEPENDENT_CODE <span class="number">1</span></span><br><span class="line">    ARCHIVE_OUTPUT_NAME <span class="string">&quot;message&quot;</span></span><br><span class="line">    DEBUG_POSTFIX <span class="string">&quot;_sd&quot;</span></span><br><span class="line">    RELEASE_POSTFIX <span class="string">&quot;_s&quot;</span></span><br><span class="line">    PUBLIC_HEADER <span class="string">&quot;Message.hpp;$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;/messageExport.h&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>除了链接到消息动态库目标的hello-world_wDSO可执行目标之外，还定义了另一个可执行目标hello-world_wAR，这个链接指向静态库:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-world_wAR hello-world.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello-world_wAR</span><br><span class="line">    PUBLIC</span><br><span class="line">        <span class="keyword">message</span>-static</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p>
<p>安装指令现在多了message-static和hello-world_wAR目标，其他没有改变:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS</span><br><span class="line">    <span class="keyword">message</span>-shared</span><br><span class="line">    <span class="keyword">message</span>-static</span><br><span class="line">    hello-world_wDSO</span><br><span class="line">    hello-world_wAR</span><br><span class="line">  ARCHIVE</span><br><span class="line">    DESTINATION <span class="variable">$&#123;INSTALL_LIBDIR&#125;</span></span><br><span class="line">    COMPONENT lib</span><br><span class="line">  RUNTIME</span><br><span class="line">    DESTINATION <span class="variable">$&#123;INSTALL_BINDIR&#125;</span></span><br><span class="line">    COMPONENT bin</span><br><span class="line">  LIBRARY</span><br><span class="line">    DESTINATION <span class="variable">$&#123;INSTALL_LIBDIR&#125;</span></span><br><span class="line">    COMPONENT lib</span><br><span class="line">  PUBLIC_HEADER</span><br><span class="line">    DESTINATION <span class="variable">$&#123;INSTALL_INCLUDEDIR&#125;</span>/<span class="keyword">message</span></span><br><span class="line">    COMPONENT dev</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-40"><a href="#工作原理-40" class="headerlink" title="工作原理"></a>工作原理</h3><p>此示例演示了，如何设置动态库的符号可见性。最好的方式是在默认情况下隐藏所有符号，显式地只公开那些需要使用的符号。这需要分为两步实现。首先，需要指示编译器隐藏符号。当然，不同的编译器将有不同的可用选项，并且直接在CMakeLists.txt中设置这些选项并不是是跨平台的。CMake通过在动态库目标上设置两个属性，提供了一种健壮的跨平台方法来设置符号的可见性：</p>
<ul>
<li><code>CXX_VISIBILITY_PRESET hidden</code>：这将隐藏所有符号，除非显式地标记了其他符号。当使用GNU编译器时，这将为目标添加-fvisibility=hidden标志。</li>
<li><code>VISIBILITY_INLINES_HIDDEN 1</code>：这将隐藏内联函数的符号。如果使用GNU编译器，这对应于-fvisibility-inlines-hidden</li>
</ul>
<p>Windows上，这都是默认行为。实际上，我们需要在前面的示例中通过设置WINDOWS_EXPORT_ALL_SYMBOLS属性为ON来覆盖它。</p>
<p>如何标记可见的符号？这由预处理器决定，因此需要提供相应的预处理宏，这些宏可以扩展到所选平台上，以便编译器能够理解可见性属性。CMake中有现成的GenerateExportHeader.cmake模块。这个模块定义了generate_export_header函数，我们调用它的过程如下：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(GenerateExportHeader)</span><br><span class="line">generate_export_header(<span class="keyword">message</span>-shared</span><br><span class="line">  BASE_NAME <span class="string">&quot;message&quot;</span></span><br><span class="line">  EXPORT_MACRO_NAME <span class="string">&quot;message_EXPORT&quot;</span></span><br><span class="line">  EXPORT_FILE_NAME <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;/messageExport.h&quot;</span></span><br><span class="line">  DEPRECATED_MACRO_NAME <span class="string">&quot;message_DEPRECATED&quot;</span></span><br><span class="line">  NO_EXPORT_MACRO_NAME <span class="string">&quot;message_NO_EXPORT&quot;</span></span><br><span class="line">  STATIC_DEFINE <span class="string">&quot;message_STATIC_DEFINE&quot;</span></span><br><span class="line">  NO_DEPRECATED_MACRO_NAME <span class="string">&quot;message_NO_DEPRECATED&quot;</span></span><br><span class="line">  DEFINE_NO_DEPRECATED</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>该函数生成messageExport.h头文件，其中包含预处理器所需的宏。根据EXPORT_FILE_NAME选项的请求，在目录${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}中生成该文件。如果该选项为空，则头文件将在当前二进制目录中生成。这个函数的第一个参数是现有的目标(示例中是message- shared)，函数的基本调用只需要传递现有目标的名称即可。可选参数，用于细粒度的控制所有生成宏，也可以传递：</p>
<ul>
<li>BASE_NAME：设置生成的头文件和宏的名称。</li>
<li>EXPORT_MACRO_NAME：设置导出宏的名称。</li>
<li>EXPORT_FILE_NAME：设置导出头文件的名称。</li>
<li>DEPRECATED_MACRO_NAME：设置弃用宏的名称。这是用来标记将要废弃的代码，如果客户使用该宏定义，编译器将发出一个将要废弃的警告。</li>
<li>NO_EXPORT_MACRO_NAME：设置不导出宏的名字。</li>
<li>STATIC_DEFINE：用于定义宏的名称，以便使用相同源编译静态库时使用。</li>
<li>NO_DEPRECATED_MACRO_NAME：设置宏的名称，在编译时将“将要废弃”的代码排除在外。</li>
<li>DEFINE_NO_DEPRECATED：指示CMake生成预处理器代码，以从编译中排除“将要废弃”的代码。</li>
</ul>
<p>GNU/Linux上，使用GNU编译器，CMake将生成以下messageExport.h头文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef message_EXPORT_H</span></span><br><span class="line"><span class="comment">#define message_EXPORT_H</span></span><br><span class="line"><span class="comment">#ifdef message_STATIC_DEFINE</span></span><br><span class="line"><span class="comment"># define message_EXPORT</span></span><br><span class="line"><span class="comment"># define message_NO_EXPORT</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment"># ifndef message_EXPORT</span></span><br><span class="line"><span class="comment"># ifdef message_shared_EXPORTS</span></span><br><span class="line">/* We are building this library */</span><br><span class="line"><span class="comment"># define message_EXPORT __attribute__((visibility(&quot;default&quot;)))</span></span><br><span class="line"><span class="comment"># else</span></span><br><span class="line">/* We are using this library */</span><br><span class="line"><span class="comment"># define message_EXPORT __attribute__((visibility(&quot;default&quot;)))</span></span><br><span class="line"><span class="comment"># endif</span></span><br><span class="line"><span class="comment"># endif</span></span><br><span class="line"><span class="comment"># ifndef message_NO_EXPORT</span></span><br><span class="line"><span class="comment"># define message_NO_EXPORT __attribute__((visibility(&quot;hidden&quot;)))</span></span><br><span class="line"><span class="comment"># endif</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifndef message_DEPRECATED</span></span><br><span class="line"><span class="comment"># define message_DEPRECATED __attribute__ ((__deprecated__))</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifndef message_DEPRECATED_EXPORT</span></span><br><span class="line"><span class="comment"># define message_DEPRECATED_EXPORT message_EXPORT message_DEPRECATED</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#ifndef message_DEPRECATED_NO_EXPORT</span></span><br><span class="line"><span class="comment"># define message_DEPRECATED_NO_EXPORT message_NO_EXPORT message_DEPRECATED</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if 1 /* DEFINE_NO_DEPRECATED */</span></span><br><span class="line"><span class="comment"># ifndef message_NO_DEPRECATED</span></span><br><span class="line"><span class="comment"># define message_NO_DEPRECATED</span></span><br><span class="line"><span class="comment"># endif</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以使用message_EXPORT宏，预先处理用户公开类和函数。弃用可以通过在前面加上message_DEPRECATED宏来实现。</p>
<p>从messageExport.h头文件的内容可以看出，所有符号都应该在静态库中可见，这就是message_STATIC_DEFINE宏起了作用。当声明了目标，我们就将其设置为编译时定义。静态库的其他目标属性如下:</p>
<ul>
<li>ARCHIVE_OUTPUT_NAME “message”：这将确保库文件的名称是message，而不是message-static。</li>
<li>DEBUG_POSTFIX “_sd”：这将把给定的后缀附加到库名称中。当目标构建类型为Release时，为静态库添加”_sd”后缀。</li>
<li>RELEASE_POSTFIX “_s”：这与前面的属性类似，当目标构建类型为Release时，为静态库添加后缀“_s”。</li>
</ul>
<h2 id="输出目标"><a href="#输出目标" class="headerlink" title="输出目标"></a>输出目标</h2><p>可以假设，消息库在开源社区取得了巨大的成功。人们非常喜欢它，并在自己的项目中使用它将消息打印到屏幕上。用户特别喜欢每个打印的消息都有惟一的标识符。但用户也希望，当他们编译并安装了库，库就能更容易找到。这个示例将展示CMake如何让我们导出目标，以便其他使用CMake的项目可以轻松地获取它们。</p>
<h3 id="准备工作-37"><a href="#准备工作-37" class="headerlink" title="准备工作"></a>准备工作</h3><p>源代码与之前的示例一致，项目结构如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmake</span><br><span class="line">│    └── messageConfig.cmake.in</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── src</span><br><span class="line">│    ├── CMakeLists.txt</span><br><span class="line">│    ├── hello- world.cpp</span><br><span class="line">│    ├── Message.cpp</span><br><span class="line">│    └── Message.hpp</span><br><span class="line">└── tests</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── use_target</span><br><span class="line">        ├── CMakeLists.txt</span><br><span class="line">        └── use_message.cpp</span><br></pre></td></tr></table></figure></p>
<p>注意，cmake子目录中添加了一个messageConfig.cmake.in。这个文件将包含导出的目标，还添加了一个测试来检查项目的安装和导出是否按预期工作。</p>
<h3 id="具体实施-41"><a href="#具体实施-41" class="headerlink" title="具体实施"></a>具体实施</h3><p>同样，主CMakeLists.txt文件相对于前一个示例来说没有变化。移动到包含我们的源代码的子目录src中：</p>
<p>需要找到UUID库，可以重用之前示例中的代码：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Search for pkg-config and UUID</span></span><br><span class="line"><span class="keyword">find_package</span>(PkgConfig QUIET)</span><br><span class="line"><span class="keyword">if</span>(PKG_CONFIG_FOUND)</span><br><span class="line">    pkg_search_module(UUID uuid IMPORTED_TARGET)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">TARGET</span> PkgConfig::UUID)</span><br><span class="line">        <span class="keyword">message</span>(STATUS <span class="string">&quot;Found libuuid&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(UUID_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>接下来，设置动态库目标并生成导出头文件：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span>-shared SHARED <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">include</span>(GenerateExportHeader)</span><br><span class="line">generate_export_header(<span class="keyword">message</span>-shared</span><br><span class="line">  BASE_NAME <span class="string">&quot;message&quot;</span></span><br><span class="line">  EXPORT_MACRO_NAME <span class="string">&quot;message_EXPORT&quot;</span></span><br><span class="line">  EXPORT_FILE_NAME <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;/messageExport.h&quot;</span></span><br><span class="line">  DEPRECATED_MACRO_NAME <span class="string">&quot;message_DEPRECATED&quot;</span></span><br><span class="line">  NO_EXPORT_MACRO_NAME <span class="string">&quot;message_NO_EXPORT&quot;</span></span><br><span class="line">  STATIC_DEFINE <span class="string">&quot;message_STATIC_DEFINE&quot;</span></span><br><span class="line">  NO_DEPRECATED_MACRO_NAME <span class="string">&quot;message_NO_DEPRECATED&quot;</span></span><br><span class="line">  DEFINE_NO_DEPRECATED</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PRIVATE</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/<span class="keyword">Message</span>.cpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>为目标设置了PUBLIC和INTERFACE编译定义。注意$<INSTALL_INTERFACE:...>生成器表达式的使用：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(<span class="keyword">message</span>-shared</span><br><span class="line">PUBLIC</span><br><span class="line">    $&lt;$&lt;BOOL:<span class="variable">$&#123;UUID_FOUND&#125;</span>&gt;:HAVE_UUID&gt;</span><br><span class="line">INTERFACE</span><br><span class="line">    $&lt;INSTALL_INTERFACE:USING_message&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>链接库和目标属性与前一个示例一样：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">message</span>-static</span><br><span class="line">  PUBLIC</span><br><span class="line">      $&lt;$&lt;BOOL:<span class="variable">$&#123;UUID_FOUND&#125;</span>&gt;:PkgConfig::UUID&gt;</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="keyword">message</span>-static</span><br><span class="line">    PROPERTIES</span><br><span class="line">    POSITION_INDEPENDENT_CODE <span class="number">1</span></span><br><span class="line">    ARCHIVE_OUTPUT_NAME <span class="string">&quot;message&quot;</span></span><br><span class="line">    DEBUG_POSTFIX <span class="string">&quot;_sd&quot;</span></span><br><span class="line">    RELEASE_POSTFIX <span class="string">&quot;_s&quot;</span></span><br><span class="line">    PUBLIC_HEADER <span class="string">&quot;Message.hpp;$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;/messageExport.h&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>可执行文件的生成，与前一个示例中使用的命令完全相同：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-world_wDSO hello-world.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello-world_wDSO</span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="keyword">message</span>-shared</span><br><span class="line">  )</span><br><span class="line"><span class="comment"># Prepare RPATH</span></span><br><span class="line"><span class="keyword">file</span>(RELATIVE_PATH _rel <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;INSTALL_BINDIR&#125;</span> <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>)</span><br><span class="line"><span class="keyword">if</span>(APPLE)</span><br><span class="line">    <span class="keyword">set</span>(_rpath <span class="string">&quot;@loader_path/$&#123;_rel&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(_rpath <span class="string">&quot;\$ORIGIN/$&#123;_rel&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">file</span>(TO_NATIVE_PATH <span class="string">&quot;$&#123;_rpath&#125;/$&#123;INSTALL_LIBDIR&#125;&quot;</span> message_RPATH)</span><br><span class="line"><span class="keyword">set_target_properties</span>(hello-world_wDSO</span><br><span class="line">  PROPERTIES</span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">    SKIP_BUILD_RPATH <span class="keyword">OFF</span></span><br><span class="line">    BUILD_WITH_INSTALL_RPATH <span class="keyword">OFF</span></span><br><span class="line">    INSTALL_RPATH <span class="string">&quot;$&#123;message_RPATH&#125;&quot;</span></span><br><span class="line">    INSTALL_RPATH_USE_LINK_PATH <span class="keyword">ON</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">add_executable</span>(hello-world_wAR hello-world.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello-world_wAR</span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="keyword">message</span>-static</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>现在，来看看安装规则：</p>
<p>因为CMake可以正确地将每个目标放在正确的地方，所以把目标的安装规则都列在一起。这次，添加了EXPORT关键字，这样CMake将为目标生成一个导出的目标文件：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS</span><br><span class="line">    <span class="keyword">message</span>-shared</span><br><span class="line">    <span class="keyword">message</span>-static</span><br><span class="line">    hello-world_wDSO</span><br><span class="line">    hello-world_wAR</span><br><span class="line">  <span class="keyword">EXPORT</span></span><br><span class="line">      messageTargets</span><br><span class="line">  ARCHIVE</span><br><span class="line">    DESTINATION <span class="variable">$&#123;INSTALL_LIBDIR&#125;</span></span><br><span class="line">    COMPONENT lib</span><br><span class="line">  RUNTIME</span><br><span class="line">    DESTINATION <span class="variable">$&#123;INSTALL_BINDIR&#125;</span></span><br><span class="line">    COMPONENT bin</span><br><span class="line">  LIBRARY</span><br><span class="line">    DESTINATION <span class="variable">$&#123;INSTALL_LIBDIR&#125;</span></span><br><span class="line">    COMPONENT lib</span><br><span class="line">  PUBLIC_HEADER</span><br><span class="line">    DESTINATION <span class="variable">$&#123;INSTALL_INCLUDEDIR&#125;</span>/<span class="keyword">message</span></span><br><span class="line">    COMPONENT dev</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>自动生成的导出目标文件称为messageTargets.cmake，需要显式地指定它的安装规则。这个文件的目标是INSTALL_CMAKEDIR，在主CMakeLists.txt文件中定义:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  <span class="keyword">EXPORT</span></span><br><span class="line">      messageTargets</span><br><span class="line">  NAMESPACE</span><br><span class="line">      <span class="string">&quot;message::&quot;</span></span><br><span class="line">  DESTINATION</span><br><span class="line">      <span class="variable">$&#123;INSTALL_CMAKEDIR&#125;</span></span><br><span class="line">  COMPONENT</span><br><span class="line">      dev</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，需要生成正确的CMake配置文件。这些将确保下游项目能够找到消息库导出的目标。为此，首先包括CMakePackageConfigHelpers.cmake标准模块：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CMakePackageConfigHelpers)</span><br></pre></td></tr></table></figure></p>
<p>让CMake为我们的库，生成一个包含版本信息的文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">write_basic_package_version_file(</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/messageConfigVersion.cmake</span><br><span class="line">  VERSION <span class="variable">$&#123;PROJECT_VERSION&#125;</span></span><br><span class="line">      COMPATIBILITY SameMajorVersion</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>使用configure_package_config_file函数，我们生成了实际的CMake配置文件。这是基于模板cmake/messageConfig.cmake.in文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configure_package_config_file(</span><br><span class="line">  <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake/messageConfig.cmake.in</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/messageConfig.cmake</span><br><span class="line">  INSTALL_DESTINATION <span class="variable">$&#123;INSTALL_CMAKEDIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，为这两个自动生成的配置文件设置了安装规则:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  FILES</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/messageConfig.cmake</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/messageConfigVersion.cmake</span><br><span class="line">  DESTINATION</span><br><span class="line">      <span class="variable">$&#123;INSTALL_CMAKEDIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>cmake/messageConfig.cmake的内容是什么？该文件的顶部有相关的说明，可以作为用户文档供使用者查看。让我们看看实际的CMake命令:</p>
<p>占位符将使用configure_package_config_file命令进行替换:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PACKAGE_INIT@</span><br></pre></td></tr></table></figure></p>
<p>包括为目标自动生成的导出文件:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/messageTargets.cmake&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>检查静态库和动态库，以及两个“Hello, World”可执行文件是否带有CMake提供的check_required_components函数：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">check_required_components(</span><br><span class="line">    <span class="string">&quot;message-shared&quot;</span></span><br><span class="line">    <span class="string">&quot;message-static&quot;</span></span><br><span class="line">    <span class="string">&quot;message-hello-world_wDSO&quot;</span></span><br><span class="line">    <span class="string">&quot;message-hello-world_wAR&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>检查目标PkgConfig::UUID是否存在。如果没有，我们再次搜索UUID库(只在非Windows操作系统下有效):<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> WIN32)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">TARGET</span> PkgConfig::UUID)</span><br><span class="line">    <span class="keyword">find_package</span>(PkgConfig REQUIRED QUIET)</span><br><span class="line">    pkg_search_module(UUID REQUIRED uuid IMPORTED_TARGET)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>测试一下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/Software/recipe-03 ..</span><br><span class="line">$ cmake --build . --target install</span><br></pre></td></tr></table></figure></p>
<p>安装树应该如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$HOME/Software/recipe-03/</span><br><span class="line">├── bin</span><br><span class="line">│    ├── hello-world_wAR</span><br><span class="line">│    └── hello-world_wDSO</span><br><span class="line">├── include</span><br><span class="line">│    └── message</span><br><span class="line">│        ├── messageExport.h</span><br><span class="line">│        └── Message.hpp</span><br><span class="line">├── lib64</span><br><span class="line">│    ├── libmessage_s.a</span><br><span class="line">│    ├── libmessage.so -&gt; libmessage.so.1</span><br><span class="line">│    └── libmessage.so.1</span><br><span class="line">└── share</span><br><span class="line">    └── cmake</span><br><span class="line">        └── recipe-03</span><br><span class="line">            ├── messageConfig.cmake</span><br><span class="line">            ├── messageConfigVersion.cmake</span><br><span class="line">            ├── messageTargets.cmake</span><br><span class="line">            └── messageTargets-release.cmake</span><br></pre></td></tr></table></figure></p>
<p>出现了一个share子目录，其中包含我们要求CMake自动生成的所有文件。现在开始，消息库的用户可以在他们自己的CMakeLists.txt文件中找到消息库，只要他们设置message_DIR的CMake变量，指向安装树中的share/cmake/message目录:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(<span class="keyword">message</span> <span class="number">1</span> CONFIG REQUIRED)</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-41"><a href="#工作原理-41" class="headerlink" title="工作原理"></a>工作原理</h3><p>这个示例涵盖了很多领域。对于构建系统将要执行的操作，CMake目标是一个非常有用的抽象概念。使用PRIVATE、PUBLIC和INTERFACE关键字，我们可以设置项目中的目标进行交互。在实践中，这允许我们定义目标A的依赖关系，将如何影响目标B(依赖于A)。如果库维护人员提供了适当的CMake配置文件，那么只需很少的CMake命令就可以轻松地解决所有依赖关系。</p>
<p>这个问题可以通过遵循message-static、message-shared、hello-world_wDSO和hello-world_wAR目标概述的模式来解决。我们将单独分析message-shared目标的CMake命令，这里只是进行一般性讨论：</p>
<p>生成目标在项目构建中列出其依赖项。对UUID库的链接是 message-shared的PUBLIC需求，因为它将用于在项目中构建目标和在下游项目中构建目标。编译时宏定义和包含目录需要在PUBLIC级或INTERFACE级目标上进行设置。它们实际上是在项目中构建目标时所需要的，其他的只与下游项目相关。此外，其中一些只有在项目安装之后才会相关联。这里使用了$<BUILD_INTERFACE:...>和$<INSTALL_INTERFACE:...>生成器表达式。只有消息库外部的下游目标才需要这些，也就是说，只有在安装了目标之后，它们才会变得可见。我们的例子中，应用如下:</p>
<p>只有在项目中使用了message-shared库，那么<code>$&lt;BUILD_INTERFACE:$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;&gt;</code>才会扩展成<code>$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;</code></p>
<p>只有在message-shared库在另一个构建树中，作为一个已导出目标，那么<code>$&lt;INSTALL_INTERFACE:$&#123;INSTALL_INCLUDEDIR&#125;&gt;</code>将会扩展成<code>$&#123;INSTALL_INCLUDEDIR&#125;</code></p>
<p>描述目标的安装规则，包括生成文件的名称。</p>
<p>描述CMake生成的导出文件的安装规则messageTargets.cmake文件将安装到INSTALL_CMAKEDIR。目标导出文件的安装规则的名称空间选项，将把给定字符串前置到目标的名称中，这有助于避免来自不同项目的目标之间的名称冲突。INSTALL_CMAKEDIR变量是在主CMakeLists.txt文件中设置的:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(WIN32 <span class="keyword">AND</span> <span class="keyword">NOT</span> CYGWIN)</span><br><span class="line">    <span class="keyword">set</span>(DEF_INSTALL_CMAKEDIR CMake)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(DEF_INSTALL_CMAKEDIR share/cmake/<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">set</span>(INSTALL_CMAKEDIR <span class="variable">$&#123;DEF_INSTALL_CMAKEDIR&#125;</span> CACHE PATH <span class="string">&quot;Installation directory for CMake files&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>CMakeLists.txt的最后一部分生成配置文件。包括CMakePackageConfigHelpers.cmake模块，分三步完成:</p>
<p>调用write_basic_package_version_file函数生成一个版本文件包。宏的第一个参数是版本控制文件的路径：messageConfigVersion.cmake。版本格式为Major.Minor.Patch，并使用PROJECT_VERSION指定版本，还可以指定与库的新版本的兼容性。例子中，当库具有相同的主版本时，为了保证兼容性，使用了相同的SameMajorVersion参数。</p>
<p>接下来，配置模板文件messageConfig.cmake.in，该文件位于cmake子目录中。</p>
<p>最后，为新生成的文件设置安装规则。两者都将安装在INSTALL_CMAKEDIR下。</p>
<h2 id="安装超级构建"><a href="#安装超级构建" class="headerlink" title="安装超级构建"></a>安装超级构建</h2><p>我们的消息库取得了巨大的成功，许多其他程序员都使用它，并且非常满意。也希望在自己的项目中使用它，但是不确定如何正确地管理依赖关系。可以用自己的代码附带消息库的源代码，但是如果该库已经安装在系统上了应该怎么做呢？第8章，展示了超级构建的场景，但是不确定如何安装这样的项目。本示例将带您了解安装超级构建的安装细节。</p>
<h3 id="准备工作-38"><a href="#准备工作-38" class="headerlink" title="准备工作"></a>准备工作</h3><p>此示例将针对消息库，构建一个简单的可执行链接。项目布局如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── cmake</span><br><span class="line">│    ├── install_hook.cmake.in</span><br><span class="line">│    └── print_rpath.py</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── external</span><br><span class="line">│    └── upstream</span><br><span class="line">│        ├── CMakeLists.txt</span><br><span class="line">│        └── message</span><br><span class="line">│            └── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── use_message.cpp</span><br></pre></td></tr></table></figure></p>
<p>主CMakeLists.txt文件配合超级构建，external子目录包含处理依赖项的CMake指令。cmake子目录包含一个Python脚本和一个模板CMake脚本。这些将用于安装方面的微调，CMake脚本首先进行配置，然后调用Python脚本打印use_message可执行文件的RPATH:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  patcher = sys.argv[<span class="number">1</span>]</span><br><span class="line">  elfobj = sys.argv[<span class="number">2</span>]</span><br><span class="line">  tools = &#123;<span class="string">&#x27;patchelf&#x27;</span>: <span class="string">&#x27;--print-rpath&#x27;</span>, <span class="string">&#x27;chrpath&#x27;</span>: <span class="string">&#x27;--list&#x27;</span>, <span class="string">&#x27;otool&#x27;</span>: <span class="string">&#x27;-L&#x27;</span>&#125;</span><br><span class="line">  <span class="keyword">if</span> patcher <span class="keyword">not</span> <span class="keyword">in</span> tools.keys():</span><br><span class="line">  <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Unknown tool &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(patcher))</span><br><span class="line">  cmd = shlex.split(<span class="string">&#x27;&#123;:s&#125; &#123;:s&#125; &#123;:s&#125;&#x27;</span>.<span class="built_in">format</span>(patcher, tools[patcher], elfobj))</span><br><span class="line">  rpath = subprocess.run(</span><br><span class="line">      cmd,</span><br><span class="line">      bufsize=<span class="number">1</span>,</span><br><span class="line">      stdout=subprocess.PIPE,</span><br><span class="line">      stderr=subprocess.PIPE,</span><br><span class="line">      universal_newlines=<span class="literal">True</span>)</span><br><span class="line">  <span class="built_in">print</span>(rpath.stdout)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure></p>
<p>使用平台原生工具可以轻松地打印RPATH，稍后我们将在本示例中讨论这些工具。</p>
<p>最后，src子目录包含项目的CMakeLists.txt和源文件。use_message.cpp源文件包含以下内容:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USING_message</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;message/Message.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">messaging</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Message <span class="title">say_hello</span><span class="params">(<span class="string">&quot;Hello, World! From a client of yours!&quot;</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; say_hello &lt;&lt; std::endl;</span><br><span class="line">  <span class="function">Message <span class="title">say_goodbye</span><span class="params">(<span class="string">&quot;Goodbye, World! From a client of yours!&quot;</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; say_goodbye &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">messaging</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, World! From a client of yours!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Goodbye, World! From a client of yours!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">messaging</span>();</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="具体实施-42"><a href="#具体实施-42" class="headerlink" title="具体实施"></a>具体实施</h3><p>我们将从主CMakeLists.txt文件开始，它用来协调超级构建:</p>
<p>与之前的示例相同。首先声明一个C++11项目，设置了默认安装路径、构建类型、目标的输出目录，以及安装树中组件的布局:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.6</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">04</span></span><br><span class="line">  LANGUAGES CXX</span><br><span class="line">  VERSION <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">  )</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; General set up &gt;&gt;&gt;</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_BUILD_TYPE Release CACHE <span class="keyword">STRING</span> <span class="string">&quot;Build type&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Build type set to $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Project will be installed to $&#123;CMAKE_INSTALL_PREFIX&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">include</span>(GNUInstallDirs)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span><br><span class="line">  <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY</span><br><span class="line">  <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY</span><br><span class="line">  <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>)</span><br><span class="line"><span class="comment"># Offer the user the choice of overriding the installation directories</span></span><br><span class="line"><span class="keyword">set</span>(INSTALL_LIBDIR <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span> CACHE PATH <span class="string">&quot;Installation directory for libraries&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(INSTALL_BINDIR <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span> CACHE PATH <span class="string">&quot;Installation directory for executables&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(INSTALL_INCLUDEDIR <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span> CACHE PATH <span class="string">&quot;Installation directory for header files&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(WIN32 <span class="keyword">AND</span> <span class="keyword">NOT</span> CYGWIN)</span><br><span class="line">  <span class="keyword">set</span>(DEF_INSTALL_CMAKEDIR CMake)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">set</span>(DEF_INSTALL_CMAKEDIR share/cmake/<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">set</span>(INSTALL_CMAKEDIR <span class="variable">$&#123;DEF_INSTALL_CMAKEDIR&#125;</span> CACHE PATH <span class="string">&quot;Installation directory for CMake files&quot;</span>)</span><br><span class="line"><span class="comment"># Report to user</span></span><br><span class="line"><span class="keyword">foreach</span>(p LIB BIN <span class="keyword">INCLUDE</span> CMAKE)</span><br><span class="line">  <span class="keyword">file</span>(TO_NATIVE_PATH <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;INSTALL_$&#123;p&#125;</span>DIR&#125; _path )</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Installing $&#123;p&#125; components to $&#123;_path&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">unset</span>(_path)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure></p>
<p>设置了EP_BASE目录属性，这将为超构建中的子项目设置布局。所有子项目都将在CMAKE_BINARY_DIR的子项目文件夹下生成:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_property</span>(DIRECTORY PROPERTY EP_BASE <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/subprojects)</span><br></pre></td></tr></table></figure></p>
<p>然后，声明STAGED_INSTALL_PREFIX变量。这个变量指向构建目录下的stage子目录，项目将在构建期间安装在这里。这是一种沙箱安装过程，让我们有机会检查整个超级构建的布局:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(STAGED_INSTALL_PREFIX <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/stage)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;PROJECT_NAME&#125; staged install: $&#123;STAGED_INSTALL_PREFIX&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>添加external/upstream子目录。其中包括使用CMake指令来管理我们的上游依赖关系，在我们的例子中，就是消息库:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(external/upstream)</span><br></pre></td></tr></table></figure></p>
<p>然后，包含ExternalProject.cmake标准模块:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(ExternalProject)</span><br></pre></td></tr></table></figure></p>
<p>将自己的项目作为外部项目添加，调用ExternalProject_Add命令。SOURCE_DIR用于指定源位于src子目录中。我们会选择适当的CMake参数来配置我们的项目。这里，使用<code>STAGED_INSTALL_PREFIX</code>作为子项目的安装目录:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ExternalProject_Add(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_core</span><br><span class="line">  DEPENDS</span><br><span class="line">    message_external</span><br><span class="line">  SOURCE_DIR</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src</span><br><span class="line">  CMAKE_ARGS</span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=<span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span></span><br><span class="line">    -DCMAKE_BUILD_TYPE=<span class="variable">$&#123;CMAKE_BUILD_TYPE&#125;</span></span><br><span class="line">    -DCMAKE_CXX_COMPILER=<span class="variable">$&#123;CMAKE_CXX_COMPILER&#125;</span></span><br><span class="line">    -DCMAKE_CXX_FLAGS=<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span></span><br><span class="line">    -DCMAKE_CXX_STANDARD=<span class="variable">$&#123;CMAKE_CXX_STANDARD&#125;</span></span><br><span class="line">    -DCMAKE_CXX_EXTENSIONS=<span class="variable">$&#123;CMAKE_CXX_EXTENSIONS&#125;</span></span><br><span class="line">    -DCMAKE_CXX_STANDARD_REQUIRED=<span class="variable">$&#123;CMAKE_CXX_STANDARD_REQUIRED&#125;</span></span><br><span class="line">    -Dmessage_DIR=<span class="variable">$&#123;message_DIR&#125;</span></span><br><span class="line">  CMAKE_CACHE_ARGS</span><br><span class="line">    -DCMAKE_PREFIX_PATH:PATH=<span class="variable">$&#123;CMAKE_PREFIX_PATH&#125;</span></span><br><span class="line">  BUILD_ALWAYS</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>现在，为use_message添加一个测试，并由recipe-04_core构建。这将运行use_message可执行文件的安装，即位于构建树中的安装:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME</span><br><span class="line">      check_use_message</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">      <span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;INSTALL_BINDIR&#125;</span>/use_message</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，可以声明安装规则。因为所需要的东西都已经安装在暂存区域中，我们只要将暂存区域的内容复制到安装目录即可:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  DIRECTORY</span><br><span class="line">      <span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span>/</span><br><span class="line">  DESTINATION</span><br><span class="line">      .</span><br><span class="line">  USE_SOURCE_PERMISSIONS</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>使用SCRIPT参数声明一个附加的安装规则。CMake脚本的install_hook.cmake将被执行，但只在GNU/Linux和macOS上执行。这个脚本将打印已安装的可执行文件的RPATH，并运行它。我们将在下一节详细地讨论这个问题：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(UNIX)</span><br><span class="line">  <span class="keyword">set</span>(PRINT_SCRIPT <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/cmake/print_rpath.py&quot;</span>)</span><br><span class="line">  <span class="keyword">configure_file</span>(cmake/install_hook.cmake.in install_hook.cmake @ONLY)</span><br><span class="line">  <span class="keyword">install</span>(</span><br><span class="line">    SCRIPT</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/install_hook.cmake</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p><code>-Dmessage_DIR=$&#123;message_DIR&#125;</code>已作为CMake参数传递给项目，这将正确设置消息库依赖项的位置。message_DIR的值在external/upstream/message目录下的CMakeLists.txt文件中定义。这个文件处理依赖于消息库，让我们看看是如何处理的:</p>
<p>首先，搜索并找到包。用户可能已经在系统的某个地方安装了，并在配置时传递了message_DIR:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(<span class="keyword">message</span> <span class="number">1</span> CONFIG QUIET)</span><br></pre></td></tr></table></figure></p>
<p>如果找到了消息库，我们将向用户报告目标的位置和版本，并添加一个虚拟的message_external目标。这里，需要虚拟目标来正确处理超构建的依赖关系:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(message_FOUND)</span><br><span class="line">  <span class="keyword">get_property</span>(_loc <span class="keyword">TARGET</span> <span class="keyword">message</span>::<span class="keyword">message</span>-shared PROPERTY LOCATION)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Found message: $&#123;_loc&#125; (found version $&#123;message_VERSION&#125;)&quot;</span>)</span><br><span class="line">  <span class="keyword">add_library</span>(message_external INTERFACE) <span class="comment"># dummy</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有找到这个库，我们将把它添加为一个外部项目，从在线Git存储库下载它，然后编译它。安装路径、构建类型和安装目录布局都是由主CMakeLists.txt文件设置，C++编译器和标志也是如此。项目将安装到STAGED_INSTALL_PREFIX下，然后进行测试:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">include</span>(ExternalProject)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Suitable message could not be located, Building message instead.&quot;</span>)</span><br><span class="line">  ExternalProject_Add(message_external</span><br><span class="line">    GIT_REPOSITORY</span><br><span class="line">      https://github.com/dev-cafe/<span class="keyword">message</span>.git</span><br><span class="line">    GIT_TAG</span><br><span class="line">      master</span><br><span class="line">    UPDATE_COMMAND</span><br><span class="line">      <span class="string">&quot;&quot;</span></span><br><span class="line">    CMAKE_ARGS</span><br><span class="line">      -DCMAKE_INSTALL_PREFIX=<span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span></span><br><span class="line">      -DCMAKE_BUILD_TYPE=<span class="variable">$&#123;CMAKE_BUILD_TYPE&#125;</span></span><br><span class="line">      -DCMAKE_CXX_COMPILER=<span class="variable">$&#123;CMAKE_CXX_COMPILER&#125;</span></span><br><span class="line">    CMAKE_CACHE_ARGS</span><br><span class="line">      -DCMAKE_CXX_FLAGS:<span class="keyword">STRING</span>=<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span></span><br><span class="line">    TEST_AFTER_INSTALL</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    DOWNLOAD_NO_PROGRESS</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    LOG_CONFIGURE</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    LOG_BUILD</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    LOG_INSTALL</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，将message_DIR目录进行设置，为指向新构建的messageConfig.cmake文件指明安装路径。注意，这些路径被保存到CMakeCache中:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span>(WIN32 <span class="keyword">AND</span> <span class="keyword">NOT</span> CYGWIN)</span><br><span class="line">    <span class="keyword">set</span>(DEF_message_DIR <span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span>/CMake)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(DEF_message_DIR <span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span>/share/cmake/<span class="keyword">message</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">file</span>(TO_NATIVE_PATH <span class="string">&quot;$&#123;DEF_message_DIR&#125;&quot;</span> DEF_message_DIR)</span><br><span class="line">  <span class="keyword">set</span>(message_DIR <span class="variable">$&#123;DEF_message_DIR&#125;</span></span><br><span class="line">    CACHE PATH <span class="string">&quot;Path to internally built messageConfig.cmake&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>我们终于准备好编译我们自己的项目，并成功地将其链接到消息库(无论是系统上已有的消息库，还是新构建的消息库)。由于这是一个超级构建，src子目录下的代码是一个完全独立的CMake项目:</p>
<p>声明一个C++11项目：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.6</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">04</span>_core</span><br><span class="line">  LANGUAGES CXX</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">include</span>(GNUInstallDirs)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span><br><span class="line">  <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY</span><br><span class="line">  <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY</span><br><span class="line">  <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>)</span><br></pre></td></tr></table></figure></p>
<p>尝试找到消息库。超级构建中，正确设置message_DIR:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(<span class="keyword">message</span> <span class="number">1</span> CONFIG REQUIRED)</span><br><span class="line"><span class="keyword">get_property</span>(_loc <span class="keyword">TARGET</span> <span class="keyword">message</span>::<span class="keyword">message</span>-shared PROPERTY LOCATION)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Found message: $&#123;_loc&#125; (found version $&#123;message_VERSION&#125;)&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>添加可执行目标use_message，该目标由use_message.cpp源文件创建，并连接到message::message-shared目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(use_message use_message.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(use_message</span><br><span class="line">  PUBLIC</span><br><span class="line">      <span class="keyword">message</span>::<span class="keyword">message</span>-shared</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>为use_message设置目标属性。再次对RPATH进行设置:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Prepare RPATH</span></span><br><span class="line"><span class="keyword">file</span>(RELATIVE_PATH _rel <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span> <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>)</span><br><span class="line"><span class="keyword">if</span>(APPLE)</span><br><span class="line">  <span class="keyword">set</span>(_rpath <span class="string">&quot;@loader_path/$&#123;_rel&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">set</span>(_rpath <span class="string">&quot;\$ORIGIN/$&#123;_rel&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">file</span>(TO_NATIVE_PATH <span class="string">&quot;$&#123;_rpath&#125;/$&#123;CMAKE_INSTALL_LIBDIR&#125;&quot;</span> use_message_RPATH)</span><br><span class="line"><span class="keyword">set_target_properties</span>(use_message</span><br><span class="line">  PROPERTIES</span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">    SKIP_BUILD_RPATH <span class="keyword">OFF</span></span><br><span class="line">    BUILD_WITH_INSTALL_RPATH <span class="keyword">OFF</span></span><br><span class="line">    INSTALL_RPATH <span class="string">&quot;$&#123;use_message_RPATH&#125;&quot;</span></span><br><span class="line">    INSTALL_RPATH_USE_LINK_PATH <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，为use_message目标设置了安装规则:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS</span><br><span class="line">      use_message</span><br><span class="line">  RUNTIME</span><br><span class="line">    DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span></span><br><span class="line">    COMPONENT bin</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>现在瞧瞧CMake脚本模板install_hook.cmake.in的内容：</p>
<p>CMake脚本在我们的主项目范围之外执行，因此没有定义变量或目标的概念。因此，需要设置变量来保存已安装的use_message可执行文件的完整路径。注意使用@INSTALL_BINDIR@，它将由configure_file解析：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(_executable <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/@INSTALL_BINDIR@/use_message)</span><br></pre></td></tr></table></figure></p>
<p>需要找到平台本机可执行工具，使用该工具打印已安装的可执行文件的RPATH。我们将搜索chrpath、patchelf和otool。当找到已安装的程序时，向用户提供有用的状态信息，并且退出搜索：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(_patcher)</span><br><span class="line"><span class="keyword">list</span>(APPEND _patchers chrpath patchelf otool)</span><br><span class="line"><span class="keyword">foreach</span>(p IN LISTS _patchers)</span><br><span class="line">  <span class="keyword">find_program</span>(<span class="variable">$&#123;p&#125;</span>_FOUND</span><br><span class="line">    NAMES</span><br><span class="line">      <span class="variable">$&#123;p&#125;</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable">$&#123;p&#125;</span>_FOUND)</span><br><span class="line">    <span class="keyword">set</span>(_patcher <span class="variable">$&#123;p&#125;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;ELF patching tool $&#123;_patcher&#125; FOUND&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span>()</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure></p>
<p>检查_patcher变量是否为空，这意味着PatchELF工具是否可用。当为空时，我们要进行的操作将会失败，所以会发出一个致命错误，提醒用户需要安装PatchELF工具:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> _patcher)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;ELF patching tool NOT FOUND!\nPlease install one of chrpath, patchelf or otool&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>当PatchELF工具找到了，则继续。我们调用Python脚本print_rpath.py，将_executable变量作为参数传递给execute_process：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED QUIET)</span><br><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">    <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> @PRINT_SCRIPT@ <span class="string">&quot;$&#123;_patcher&#125;&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;_executable&#125;&quot;</span></span><br><span class="line">  RESULT_VARIABLE _res</span><br><span class="line">  OUTPUT_VARIABLE _out</span><br><span class="line">  ERROR_VARIABLE _err</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>检查_res变量的返回代码。如果执行成功，将打印_out变量中捕获的标准输出流。否则，打印退出前捕获的标准输出和错误流:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span>(_res <span class="keyword">EQUAL</span> <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;RPATH for $&#123;_executable&#125; is $&#123;_out&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Something went wrong!&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Standard output from print_rpath.py: $&#123;_out&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Standard error from print_rpath.py: $&#123;_err&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;$&#123;_patcher&#125; could NOT obtain RPATH for $&#123;_executable&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>再使用execute_process来运行已安装的use_message可执行目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;_executable&#125;</span></span><br><span class="line">  RESULT_VARIABLE _res</span><br><span class="line">  OUTPUT_VARIABLE _out</span><br><span class="line">  ERROR_VARIABLE _err</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>最后，向用户报告execute_process的结果:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_res <span class="keyword">EQUAL</span> <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Running $&#123;_executable&#125;:\n $&#123;_out&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Something went wrong!&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Standard output from running $&#123;_executable&#125;:\n $&#123;_out&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Standard error from running $&#123;_executable&#125;:\n $&#123;_err&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Something went wrong with $&#123;_executable&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理-42"><a href="#工作原理-42" class="headerlink" title="工作原理"></a>工作原理</h3><p>CMake工具箱中，超级构建是非常有用的模式。它通过将复杂的项目划分为更小、更容易管理的子项目来管理它们。此外，可以使用CMake作为构建项目的包管理器。CMake可以搜索依赖项，如果在系统上找不到依赖项，则重新构建它们。这里需要三个CMakeLists.txt文件：</p>
<ul>
<li>主CMakeLists.txt文件包含项目和依赖项共享的设置，还包括我们自己的项目(作为外部项目)。本例中，我们选择的名称为<code>$&#123;PROJECT_NAME&#125;_core</code>；也就是recipe-04_core，因为项目名称recipe-04用于超级构建。</li>
<li>外部CMakeLists.txt文件将尝试查找上游依赖项，并在导入目标和构建目标之间进行切换，这取决于是否找到了依赖项。对于每个依赖项，最好有单独的子目录，其中包含一个CMakeLists.txt文件。</li>
<li>最后，我们项目的CMakeLists.txt文件，可以构建一个独立的CMake项目。在原则上，我们可以自己配置和构建它，而不需要超级构建提供的依赖关系管理工具。</li>
</ul>
<p>当对消息库的依赖关系未得到满足时，将首先考虑超级构建:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/Software/recipe-04 ..</span><br></pre></td></tr></table></figure></p>
<p>让CMake查找库，这是我们得到的输出:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- The CXX compiler identification is GNU 7.3.0</span><br><span class="line">-- Check for working CXX compiler: /nix/store/gqg2vrcq7krqi9rrl6pphvsg81sb8pjw-gcc-wrapper-7.3.0/bin/g++</span><br><span class="line">-- Check for working CXX compiler: /nix/store/gqg2vrcq7krqi9rrl6pphvsg81sb8pjw-gcc-wrapper-7.3.0/bin/g++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Project will be installed to /home/roberto/Software/recipe-04</span><br><span class="line">-- Build type set to Release</span><br><span class="line">-- Installing LIB components to /home/roberto/Software/recipe-04/lib64</span><br><span class="line">-- Installing BIN components to /home/roberto/Software/recipe-04/bin</span><br><span class="line">-- Installing INCLUDE components to /home/roberto/Software/recipe-04/include</span><br><span class="line">-- Installing CMAKE components to /home/roberto/Software/recipe-04/share/cmake/recipe-04</span><br><span class="line">-- recipe-04 staged install: /home/roberto/Workspace/robertodr/cmake-cookbook/chapter-10/recipe-04/cxx-example/build/stage</span><br><span class="line">-- Suitable message could not be located, Building message instead.</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/roberto/Workspace/robertodr/cmake-cookbook/chapter-10/recipe-04/cxx-example/build</span><br></pre></td></tr></table></figure></p>
<p>根据指令，CMake报告如下:</p>
<p>安装将分阶段进入构建树。分阶段安装是对实际安装过程进行沙箱化的一种方法。作为开发人员，这对于在运行安装命令之前检查所有库、可执行程序和文件是否安装在正确的位置非常有用。对于用户来说，可在构建目录中给出了相同的结构。这样，即使没有运行正确的安装，我们的项目也可以立即使用。</p>
<p>系统上没有找到合适的消息库。然后，CMake将运行在构建项目之前构建库所提供的命令，以满足这种依赖性。</p>
<p>如果库已经位于系统的已知位置，我们可以将<code>-Dmessage_DIR</code>选项传递给CMake:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/Software/use_message -Dmessage_DIR=<span class="variable">$HOME</span>/Software/message/share/cmake/message ..</span><br></pre></td></tr></table></figure></p>
<p>事实上，这个库已经找到并导入。我们对自己的项目进行建造操作:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- The CXX compiler identification is GNU 7.3.0</span><br><span class="line">-- Check for working CXX compiler: /nix/store/gqg2vrcq7krqi9rrl6pphvsg81sb8pjw-gcc-wrapper-7.3.0/bin/g++</span><br><span class="line">-- Check for working CXX compiler: /nix/store/gqg2vrcq7krqi9rrl6pphvsg81sb8pjw-gcc-wrapper-7.3.0/bin/g++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Project will be installed to /home/roberto/Software/recipe-04</span><br><span class="line">-- Build type set to Release</span><br><span class="line">-- Installing LIB components to /home/roberto/Software/recipe-04/lib64</span><br><span class="line">-- Installing BIN components to /home/roberto/Software/recipe-04/bin</span><br><span class="line">-- Installing INCLUDE components to /home/roberto/Software/recipe-04/include</span><br><span class="line">-- Installing CMAKE components to /home/roberto/Software/recipe-04/share/cmake/recipe-04</span><br><span class="line">-- recipe-04 staged install: /home/roberto/Workspace/robertodr/cmake-cookbook/chapter-10/recipe-04/cxx-example/build/stage</span><br><span class="line">-- Checking for one of the modules &#x27;uuid&#x27;</span><br><span class="line">-- Found message: /home/roberto/Software/message/lib64/libmessage.so.1 (found version 1.0.0)</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/roberto/Workspace/robertodr/cmake-cookbook/chapter-10/recipe-04/cxx-example/build</span><br></pre></td></tr></table></figure></p>
<p>项目的最终安装规则是，将安装文件复制到CMAKE_INSTALL_PREFIX:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  DIRECTORY</span><br><span class="line">      <span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span>/</span><br><span class="line">  DESTINATION</span><br><span class="line">      .</span><br><span class="line">  USE_SOURCE_PERMISSIONS</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>注意使用.而不是绝对路径<code>$&#123;CMAKE_INSTALL_PREFIX&#125;</code>，这样CPack工具就可以正确理解该规则。</p>
<p>recipe-04_core项目构建一个简单的可执行目标，该目标链接到消息动态库。正如本章前几节所讨论，为了让可执行文件正确运行，需要正确设置RPATH。本章的第1节展示了，如何在CMake的帮助下实现这一点，同样的模式在CMakeLists.txt中被重用，用于创建use_message的可执行目标:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(RELATIVE_PATH _rel <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span> <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>)</span><br><span class="line"><span class="keyword">if</span>(APPLE)</span><br><span class="line">  <span class="keyword">set</span>(_rpath <span class="string">&quot;@loader_path/$&#123;_rel&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">set</span>(_rpath <span class="string">&quot;\$ORIGIN/$&#123;_rel&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">file</span>(TO_NATIVE_PATH <span class="string">&quot;$&#123;_rpath&#125;/$&#123;CMAKE_INSTALL_LIBDIR&#125;&quot;</span> use_message_RPATH)</span><br><span class="line"><span class="keyword">set_target_properties</span>(use_message</span><br><span class="line">  PROPERTIES</span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">    SKIP_BUILD_RPATH <span class="keyword">OFF</span></span><br><span class="line">    BUILD_WITH_INSTALL_RPATH <span class="keyword">OFF</span></span><br><span class="line">    INSTALL_RPATH <span class="string">&quot;$&#123;use_message_RPATH&#125;&quot;</span></span><br><span class="line">    INSTALL_RPATH_USE_LINK_PATH <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>为了检查这是否合适，可以使用本机工具打印已安装的可执行文件的RPATH。我们将对该工具的调用，封装到Python脚本中，并将其进一步封装到CMake脚本中。最后，使用SCRIPT关键字将CMake脚本作为安装规则调用:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(UNIX)</span><br><span class="line">  <span class="keyword">set</span>(PRINT_SCRIPT <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/cmake/print_rpath.py&quot;</span>)</span><br><span class="line">  <span class="keyword">configure_file</span>(cmake/install_hook.cmake.in install_hook.cmake @ONLY)</span><br><span class="line">  <span class="keyword">install</span>(</span><br><span class="line">    SCRIPT</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/install_hook.cmake</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>脚本是在安装最后进行执行:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build build --target install</span><br></pre></td></tr></table></figure></p>
<p>GNU/Linux系统上，我们将看到以下输出:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Install the project...</span><br><span class="line">-- Install configuration: <span class="string">&quot;Release&quot;</span></span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/.</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./lib64</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./lib64/libmessage.so</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./lib64/libmessage_s.a</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./lib64/libmessage.so.1</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./include</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./include/message</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./include/message/Message.hpp</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./include/message/messageExport.h</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./share</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./share/cmake</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./share/cmake/message</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./share/cmake/message/messageTargets-release.cmake</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./share/cmake/message/messageConfigVersion.cmake</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./share/cmake/message/messageConfig.cmake</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./share/cmake/message/messageTargets.cmake</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./bin</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./bin/hello-world_wAR</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./bin/use_message</span><br><span class="line">-- Installing: /home/roberto/Software/recipe-04/./bin/hello-world_wDSO</span><br><span class="line">-- ELF patching tool chrpath FOUND</span><br><span class="line">-- RPATH <span class="keyword">for</span> /home/roberto/Software/recipe-04/bin/use_message is /home/roberto/Software/recipe-04/bin/use_message: RUNPATH=<span class="variable">$ORIGIN</span>/../lib64:/home/roberto/Workspace/robertodr/cmake-cookbook/chapter-10/recipe-04/cxx-example/build/stage/lib64:/nix/store/di389pfcw2krnmh8nmkn55d1rnzmba37-CMake-Cookbook/lib64:/nix/store/di389pfcw2krnmh8nmkn55d1rnzmba37-CMake-Cookbook/lib:/nix/store/mjs2b8mmid86lvbzibzdlz8w5yrjgcnf-util-linux-2.31.1/lib:/nix/store/2kcrj1ksd2a14bm5sky182fv2xwfhfap-glibc-2.26-131/lib:/nix/store/4zd34747fz0ggzzasy4icgn3lmy89pra-gcc-7.3.0-lib/lib</span><br><span class="line">-- Running /home/roberto/Software/recipe-04/bin/use_message:</span><br><span class="line">This is my very <span class="built_in">nice</span> message:</span><br><span class="line">Hello, World! From a client of yours!</span><br><span class="line">...and here is its UUID: a8014bf7-5dfa-45e2-8408-12e9a5941825</span><br><span class="line">This is my very <span class="built_in">nice</span> message:</span><br><span class="line">Goodbye, World! From a client of yours!</span><br><span class="line">...and here is its UUID: ac971ef4-7606-460f-9144-1ad96f713647</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%A7%AF%E7%B4%AF/" rel="tag"># 积累</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/27/%E4%B9%B0%E6%88%BF%E8%A6%81%E7%82%B9/" rel="prev" title="买房要点">
      <i class="fa fa-chevron-left"></i> 买房要点
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/03/cuda%E6%95%99%E7%A8%8B%E5%8A%A0%E4%BB%A3%E7%A0%81/" rel="next" title="CUDA教程">
      CUDA教程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%93"><span class="nav-number">1.</span> <span class="nav-text">从可执行文件到库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E5%8D%95%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.</span> <span class="nav-text">将单个源文件编译为可执行文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.1.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD"><span class="nav-number">1.1.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">切换生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.2.3.</span> <span class="nav-text">如何工作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%92%8C%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">1.3.</span> <span class="nav-text">构建和链接静态库和动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="nav-number">1.3.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.4.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%A5%E6%8E%A7%E5%88%B6%E7%BC%96%E8%AF%91"><span class="nav-number">1.4.</span> <span class="nav-text">用条件句控制编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2"><span class="nav-number">1.4.2.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E7%94%A8%E6%88%B7%E6%98%BE%E7%A4%BA%E9%80%89%E9%A1%B9"><span class="nav-number">1.5.</span> <span class="nav-text">向用户显示选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-4"><span class="nav-number">1.5.1.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-3"><span class="nav-number">1.5.2.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-1"><span class="nav-number">1.5.3.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.6.</span> <span class="nav-text">指定编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-5"><span class="nav-number">1.6.1.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-4"><span class="nav-number">1.6.2.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-2"><span class="nav-number">1.6.3.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.</span> <span class="nav-text">切换构建类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-6"><span class="nav-number">1.7.1.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-5"><span class="nav-number">1.7.2.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E9%A1%B9"><span class="nav-number">1.8.</span> <span class="nav-text">设置编译器选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-3"><span class="nav-number">1.8.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-7"><span class="nav-number">1.8.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C-1"><span class="nav-number">1.8.3.</span> <span class="nav-text">如何工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-3"><span class="nav-number">1.8.4.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E8%AF%AD%E8%A8%80%E8%AE%BE%E5%AE%9A%E6%A0%87%E5%87%86"><span class="nav-number">1.9.</span> <span class="nav-text">为语言设定标准</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-4"><span class="nav-number">1.9.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-8"><span class="nav-number">1.9.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-6"><span class="nav-number">1.9.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-4"><span class="nav-number">1.9.4.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">1.10.</span> <span class="nav-text">使用控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-5"><span class="nav-number">1.10.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-9"><span class="nav-number">1.10.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-7"><span class="nav-number">1.10.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E7%8E%AF%E5%A2%83"><span class="nav-number">2.</span> <span class="nav-text">检测环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.1.</span> <span class="nav-text">检测操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-10"><span class="nav-number">2.1.1.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-8"><span class="nav-number">2.1.2.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E4%B8%8E%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-number">2.2.</span> <span class="nav-text">处理与平台相关的源代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-6"><span class="nav-number">2.2.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-11"><span class="nav-number">2.2.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-9"><span class="nav-number">2.2.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-number">2.3.</span> <span class="nav-text">处理与编译器相关的源代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-7"><span class="nav-number">2.3.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-12"><span class="nav-number">2.3.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-10"><span class="nav-number">2.3.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.</span> <span class="nav-text">检测处理器体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-8"><span class="nav-number">2.4.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-13"><span class="nav-number">2.4.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-11"><span class="nav-number">2.4.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-5"><span class="nav-number">2.4.4.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="nav-number">2.5.</span> <span class="nav-text">检测处理器指令集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-9"><span class="nav-number">2.5.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E6%96%BD"><span class="nav-number">2.5.2.</span> <span class="nav-text">如何实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-12"><span class="nav-number">2.5.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BAEigen%E5%BA%93%E4%BD%BF%E8%83%BD%E5%90%91%E9%87%8F%E5%8C%96"><span class="nav-number">2.6.</span> <span class="nav-text">为Eigen库使能向量化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-10"><span class="nav-number">2.6.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E6%96%BD-1"><span class="nav-number">2.6.2.</span> <span class="nav-text">如何实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-13"><span class="nav-number">2.6.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%A4%96%E9%83%A8%E5%BA%93%E5%92%8C%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">检测外部库和程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8BPython%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-number">3.1.</span> <span class="nav-text">检测Python解释器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-14"><span class="nav-number">3.1.1.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-14"><span class="nav-number">3.1.2.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8BPython%E5%BA%93"><span class="nav-number">3.2.</span> <span class="nav-text">检测Python库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-11"><span class="nav-number">3.2.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-15"><span class="nav-number">3.2.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-15"><span class="nav-number">3.2.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-6"><span class="nav-number">3.2.4.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8BPython%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85"><span class="nav-number">3.3.</span> <span class="nav-text">检测Python模块和包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-12"><span class="nav-number">3.3.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-16"><span class="nav-number">3.3.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-16"><span class="nav-number">3.3.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8BBLAS%E5%92%8CLAPACK%E6%95%B0%E5%AD%A6%E5%BA%93"><span class="nav-number">3.4.</span> <span class="nav-text">检测BLAS和LAPACK数学库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-13"><span class="nav-number">3.4.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-17"><span class="nav-number">3.4.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-17"><span class="nav-number">3.4.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8BOpenMP%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">3.5.</span> <span class="nav-text">检测OpenMP的并行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-14"><span class="nav-number">3.5.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-18"><span class="nav-number">3.5.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-18"><span class="nav-number">3.5.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8BMPI%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">3.6.</span> <span class="nav-text">检测MPI的并行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-15"><span class="nav-number">3.6.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-19"><span class="nav-number">3.6.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-19"><span class="nav-number">3.6.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%A4%96%E9%83%A8%E5%BA%93-%E2%85%A0-%E4%BD%BF%E7%94%A8pkg-config"><span class="nav-number">3.7.</span> <span class="nav-text">检测外部库:Ⅰ. 使用pkg-config</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-16"><span class="nav-number">3.7.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-20"><span class="nav-number">3.7.2.</span> <span class="nav-text">具体实施</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="nav-number">4.</span> <span class="nav-text">创建和运行测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">4.1.</span> <span class="nav-text">创建一个简单的单元测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-17"><span class="nav-number">4.2.</span> <span class="nav-text">准备工作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-21"><span class="nav-number">4.2.1.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-20"><span class="nav-number">4.2.2.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-7"><span class="nav-number">4.2.3.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Google-Test%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">4.3.</span> <span class="nav-text">使用Google Test库进行单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-18"><span class="nav-number">4.3.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-22"><span class="nav-number">4.3.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-21"><span class="nav-number">4.3.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E6%9D%A5%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E7%BC%BA%E9%99%B7"><span class="nav-number">4.4.</span> <span class="nav-text">使用动态分析来检测内存缺陷</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-19"><span class="nav-number">4.4.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-23"><span class="nav-number">4.4.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-22"><span class="nav-number">4.4.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%97%B6%E5%92%8C%E6%9E%84%E5%BB%BA%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">5.</span> <span class="nav-text">配置时和构建时的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.</span> <span class="nav-text">使用平台无关的文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-20"><span class="nav-number">5.1.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-24"><span class="nav-number">5.1.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-23"><span class="nav-number">5.1.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%97%B6%E8%BF%90%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4"><span class="nav-number">5.2.</span> <span class="nav-text">配置时运行自定义命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-25"><span class="nav-number">5.2.1.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-24"><span class="nav-number">5.2.2.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%97%B6%E8%BF%90%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4-%E2%85%A0-%E4%BD%BF%E7%94%A8add-custom-command"><span class="nav-number">5.3.</span> <span class="nav-text">构建时运行自定义命令:Ⅰ. 使用add_custom_command</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-21"><span class="nav-number">5.3.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-26"><span class="nav-number">5.3.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-25"><span class="nav-number">5.3.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%97%B6%E4%B8%BA%E7%89%B9%E5%AE%9A%E7%9B%AE%E6%A0%87%E8%BF%90%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4"><span class="nav-number">5.4.</span> <span class="nav-text">构建时为特定目标运行自定义命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-22"><span class="nav-number">5.4.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-27"><span class="nav-number">5.4.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-26"><span class="nav-number">5.4.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A2%E7%A9%B6%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E5%91%BD%E4%BB%A4"><span class="nav-number">5.5.</span> <span class="nav-text">探究编译和链接命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-23"><span class="nav-number">5.5.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-28"><span class="nav-number">5.5.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-27"><span class="nav-number">5.5.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%BA%90%E7%A0%81"><span class="nav-number">6.</span> <span class="nav-text">生成源码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%97%B6%E7%94%9F%E6%88%90%E6%BA%90%E7%A0%81"><span class="nav-number">6.1.</span> <span class="nav-text">配置时生成源码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-24"><span class="nav-number">6.1.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-29"><span class="nav-number">6.1.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-28"><span class="nav-number">6.1.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E9%A1%B9%E7%9B%AE%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E4%BB%A5%E4%BE%BF%E6%8A%A5%E5%91%8A"><span class="nav-number">6.2.</span> <span class="nav-text">记录项目版本信息以便报告</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-25"><span class="nav-number">6.2.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E6%96%BD-2"><span class="nav-number">6.2.2.</span> <span class="nav-text">如何实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-29"><span class="nav-number">6.2.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%97%B6%E8%AE%B0%E5%BD%95Git-Hash%E5%80%BC"><span class="nav-number">6.3.</span> <span class="nav-text">配置时记录Git Hash值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-26"><span class="nav-number">6.3.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-30"><span class="nav-number">6.3.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-30"><span class="nav-number">6.3.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="nav-number">7.</span> <span class="nav-text">构建项目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E9%87%8D%E7%94%A8%E4%BB%A3%E7%A0%81"><span class="nav-number">7.1.</span> <span class="nav-text">使用函数和宏重用代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-27"><span class="nav-number">7.1.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-31"><span class="nav-number">7.1.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-31"><span class="nav-number">7.1.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-8"><span class="nav-number">7.1.4.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86CMake%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%88%90%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.</span> <span class="nav-text">将CMake源代码分成模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-28"><span class="nav-number">7.2.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-32"><span class="nav-number">7.2.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-32"><span class="nav-number">7.2.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-9"><span class="nav-number">7.2.4.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%87%BD%E6%95%B0%E6%9D%A5%E6%B5%8B%E8%AF%95%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%87%E5%BF%97"><span class="nav-number">7.3.</span> <span class="nav-text">编写函数来测试和设置编译器标志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-29"><span class="nav-number">7.3.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-33"><span class="nav-number">7.3.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-33"><span class="nav-number">7.3.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-10"><span class="nav-number">7.3.4.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%88%96%E5%AE%8F"><span class="nav-number">7.4.</span> <span class="nav-text">用指定参数定义函数或宏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-30"><span class="nav-number">7.4.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-34"><span class="nav-number">7.4.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-34"><span class="nav-number">7.4.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-11"><span class="nav-number">7.4.4.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F"><span class="nav-number">7.5.</span> <span class="nav-text">重新定义函数和宏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-31"><span class="nav-number">7.5.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-35"><span class="nav-number">7.5.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-35"><span class="nav-number">7.5.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BA%9F%E5%BC%83%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%8F%E5%92%8C%E5%8F%98%E9%87%8F"><span class="nav-number">7.6.</span> <span class="nav-text">使用废弃函数、宏和变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-32"><span class="nav-number">7.6.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-36"><span class="nav-number">7.6.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-36"><span class="nav-number">7.6.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E6%B7%B7%E5%90%88%E9%A1%B9%E7%9B%AE"><span class="nav-number">8.</span> <span class="nav-text">语言混合项目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8C-C-%E5%BA%93%E6%9E%84%E5%BB%BAFortran%E9%A1%B9%E7%9B%AE"><span class="nav-number">8.1.</span> <span class="nav-text">使用C&#x2F;C++库构建Fortran项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-33"><span class="nav-number">8.1.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-37"><span class="nav-number">8.1.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-37"><span class="nav-number">8.1.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-12"><span class="nav-number">8.1.4.</span> <span class="nav-text">更多信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Fortran%E5%BA%93%E6%9E%84%E5%BB%BAC-C-%E9%A1%B9%E7%9B%AE"><span class="nav-number">8.2.</span> <span class="nav-text">使用Fortran库构建C&#x2F;C++项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-34"><span class="nav-number">8.2.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-38"><span class="nav-number">8.2.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-38"><span class="nav-number">8.2.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F"><span class="nav-number">9.</span> <span class="nav-text">编写安装程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E9%A1%B9%E7%9B%AE"><span class="nav-number">9.1.</span> <span class="nav-text">安装项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-35"><span class="nav-number">9.1.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-39"><span class="nav-number">9.1.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-39"><span class="nav-number">9.1.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E8%BE%93%E5%87%BA%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">9.2.</span> <span class="nav-text">生成输出头文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-36"><span class="nav-number">9.2.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-40"><span class="nav-number">9.2.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-40"><span class="nav-number">9.2.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E7%9B%AE%E6%A0%87"><span class="nav-number">9.3.</span> <span class="nav-text">输出目标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-37"><span class="nav-number">9.3.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-41"><span class="nav-number">9.3.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-41"><span class="nav-number">9.3.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E8%B6%85%E7%BA%A7%E6%9E%84%E5%BB%BA"><span class="nav-number">9.4.</span> <span class="nav-text">安装超级构建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-38"><span class="nav-number">9.4.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-42"><span class="nav-number">9.4.2.</span> <span class="nav-text">具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-42"><span class="nav-number">9.4.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
