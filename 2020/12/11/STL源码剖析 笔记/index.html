<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第一章：STL概论和版本简介STL六大组件 容器：各种数据结构，如：vector、list、deque、set、map、主要用来存放数据。 算法：各种常见算法，如：sort、search、copy、erase 迭代器：扮演算法和容器中的中介。迭代器是一种将operator*、operator-&gt;、operator++、operator--等指针相关操作予以重载的class template。">
<meta property="og:type" content="article">
<meta property="og:title" content="STL 源码剖析 笔记">
<meta property="og:url" content="http://yoursite.com/2020/12/11/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="第一章：STL概论和版本简介STL六大组件 容器：各种数据结构，如：vector、list、deque、set、map、主要用来存放数据。 算法：各种常见算法，如：sort、search、copy、erase 迭代器：扮演算法和容器中的中介。迭代器是一种将operator*、operator-&gt;、operator++、operator--等指针相关操作予以重载的class template。">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1607703761.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608811144.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608949666.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608949943.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608952882.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608952929.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608954958.jpg">
<meta property="og:image" content="http://yoursite.com/2020/12/11/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%E7%AC%94%E8%AE%B0/1608955300.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608957050.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608959629.jpg">
<meta property="og:image" content="http://yoursite.com/img/20180524164335567.png">
<meta property="og:image" content="http://yoursite.com/img/1608959630.png">
<meta property="og:image" content="http://yoursite.com/img/1609574454.png">
<meta property="og:image" content="http://yoursite.com/2020/12/11/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%E7%AC%94%E8%AE%B0/1609581571.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609589397.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609589884.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609590017.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609590056.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609590082.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609590834.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609591356.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609603712.png">
<meta property="og:image" content="http://yoursite.com/img/1609605134.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609605212.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609640774.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609641339.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609641622.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609641867.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609645158.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609645423.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609646609.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609646690.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609732832.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609733154.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210104160923.png">
<meta property="og:image" content="http://yoursite.com/img/1609759644.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609762206.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609764727.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609765004.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609767703.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609767737.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609849157.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609849605.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609927285.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609934235.png">
<meta property="og:image" content="http://yoursite.com/img/1610004677.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610346576.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610357891.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610358110.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610358139.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610358159.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610542684.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610542923.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610543021.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610543888.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610544166.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610544209.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610544261.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610544307.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610593476.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610593588.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610593775.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610593860.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610594128.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610595244.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610595463.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610595681.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610595745.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610595857.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610604585.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610605328.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610605767.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610692930.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610693433.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610693726.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610695096.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610695460.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610695483.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610695566.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610696018.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610763366.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610775737.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610775889.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610775917.jpg">
<meta property="article:published_time" content="2020-12-11T01:13:00.000Z">
<meta property="article:modified_time" content="2022-12-26T08:53:58.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1607703761.jpg">

<link rel="canonical" href="http://yoursite.com/2020/12/11/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>STL 源码剖析 笔记 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/11/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STL 源码剖析 笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-11 09:13:00" itemprop="dateCreated datePublished" datetime="2020-12-11T09:13:00+08:00">2020-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 16:53:58" itemprop="dateModified" datetime="2022-12-26T16:53:58+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第一章：STL概论和版本简介"><a href="#第一章：STL概论和版本简介" class="headerlink" title="第一章：STL概论和版本简介"></a>第一章：STL概论和版本简介</h1><h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><ol>
<li>容器：各种数据结构，如：vector、list、deque、set、map、主要用来存放数据。</li>
<li>算法：各种常见算法，如：sort、search、copy、erase</li>
<li>迭代器：扮演算法和容器中的中介。迭代器是一种将<code>operator*</code>、<code>operator-&gt;</code>、<code>operator++</code>、<code>operator--</code>等指针相关操作予以重载的class template。所有的容器均有自己独特的迭代器，实现对容器内数据的访问</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。仿函数是一种重载了<code>operator()</code>的class或class template。一般指针函数可视为狭义的仿函数。</li>
<li>配接器（adapters）: 修饰容器、仿函数、迭代器接口。例如STL提供的queue和stack，虽然看似容器，但是只能算一种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应。</li>
<li>配置器（allocators）：负责空间配置和管理，配置器是一个实现了动态空间配置、空间管理、空间释放的class template.</li>
</ol>
<h3 id="各组件间的关系"><a href="#各组件间的关系" class="headerlink" title="各组件间的关系"></a>各组件间的关系</h3><p><img src="/img/1607703761.jpg" alt=""></p>
<p>由于STL已成为C++标准程序库的大脉系，因此：目前所有的C++编译器一定支持有一份STL。STL并非以二进制代码面貌出现，而是以源代码面貌供应。某些STL版本同时存在具扩展名和无扩展名的两份文件，例如Visual C++的版本同时具备<code>&lt;vectorr.h&gt;</code>和<code>&lt;vector&gt;</code>。某些STL版本只存在具扩展名的头文件，例如C++ Builder的RaugeWave版本只有<code>&lt;vector.h&gt;</code>。某些STL版本不仅有一线装配，还有二线装配，例如GNU C++的SGI版本不但有一线的<code>&lt;vector.h&gt;</code>和<code>&lt;vector&gt;</code>，还有二线的<code>&lt;stl_vector.h&gt;</code>。</p>
<p>Container通过Allocator取得数据储存空间，Algorithm通过Iterator存取Container内容，Functor可以协助Algorithm完成不同的策略变化，Adapter可以修饰或套接Functor。</p>
<h2 id="SGI-STL头文件分布"><a href="#SGI-STL头文件分布" class="headerlink" title="SGI STL头文件分布"></a>SGI STL头文件分布</h2><ul>
<li>C++标准规范下的C头文件：cstdio，csyflib，cstring，…</li>
<li>C++标准程序库中不属于STL范畴者：stream，string，…</li>
<li>STL标准头文件(无扩展名)：vector，deque，list，map，…</li>
<li>C++标准定案前，HP所规范的STL头文件：vector.h，deque.h，list.h，…</li>
<li>SGI STL内部文件(STL真正实现与此)：stl_vector.h，stl_deque.h，stl_algo.h，…</li>
</ul>
<p>不同的编译器对C++语言的支持程度不尽相同。作为一个希望具备广泛移植能力的程序库，SGI STL准备了一个环境组态文件<code>&lt;stl_config.h&gt;</code>，其中定义了许多常量，标示某些组态的成立与否，所有STL头文件都会直接或间接包含这个组态文件，并以条件式写法，让预处理器根据各个常量决定取舍哪一段程序代码，例如：<br><img src="/img/1608811144.jpg" alt=""></p>
<p><code>&lt;stl_config.h&gt;</code>文件起始处有一份常量定义说明，针对各家不同的编译器及可能的版本给予常量设定。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Filename:    stl_config.h  </span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Copyright (c) 1996-1997 </span></span><br><span class="line"><span class="comment"> * Silicon Graphics Computer Systems, Inc. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Permission to use, copy, modify, distribute and sell this software </span></span><br><span class="line"><span class="comment"> * and its documentation for any purpose is hereby granted without fee, </span></span><br><span class="line"><span class="comment"> * provided that the above copyright notice appear in all copies and </span></span><br><span class="line"><span class="comment"> * that both that copyright notice and this permission notice appear </span></span><br><span class="line"><span class="comment"> * in supporting documentation.  Silicon Graphics makes no </span></span><br><span class="line"><span class="comment"> * representations about the suitability of this software for any </span></span><br><span class="line"><span class="comment"> * purpose.  It is provided &quot;as is&quot; without express or implied warranty. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span> This is an internal header file, included by other STL headers. </span></span><br><span class="line"><span class="comment"> *   You should not attempt to use it directly. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_CONFIG_H  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STL_CONFIG_H  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//  本配置文件功能表:  </span></span><br><span class="line"><span class="comment">//  (1)  如果不编译器没有定义bool, true, false则定义  </span></span><br><span class="line"><span class="comment">//  (2)  如果编译器不支持drand48()函数则定义__STL_NO_DRAND48  </span></span><br><span class="line"><span class="comment">//       注: drand48产生双精度的伪随机数, 因为采用了48bit计算, 故名drand48  </span></span><br><span class="line"><span class="comment">//  (3)  如果编译器不支持static members of template classes(模板类静态成员),  </span></span><br><span class="line"><span class="comment">//       则定义__STL_STATIC_TEMPLATE_MEMBER_BUG  </span></span><br><span class="line"><span class="comment">//  (4)  如果编译器不支持&#x27;typename&#x27;关键字, 则将&#x27;typename&#x27;定义为空(null macro)  </span></span><br><span class="line"><span class="comment">//  (5)  如果编译器支持partial specialization of class templates(模板类偏特化),  </span></span><br><span class="line"><span class="comment">//       则定义__STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line"><span class="comment">//       参考文献: http://msdn.microsoft.com/en-us/library/9w7t3kf1(v=VS.71).aspx  </span></span><br><span class="line"><span class="comment">//  (6)  如果编译器支持partial ordering of function templates(模板函数特化优先级),  </span></span><br><span class="line"><span class="comment">//       则定义__STL_FUNCTION_TMPL_PARTIAL_ORDER  </span></span><br><span class="line"><span class="comment">//       参考资料: http://msdn.microsoft.com/zh-cn/library/zaycz069.aspx  </span></span><br><span class="line"><span class="comment">//  (7)  如果编译器支持calling a function template by providing its template  </span></span><br><span class="line"><span class="comment">//       arguments explicitly(显式指定调用模板函数的模板参数)  </span></span><br><span class="line"><span class="comment">//       则定义__STL_EXPLICIT_FUNCTION_TMPL_ARGS  </span></span><br><span class="line"><span class="comment">//  (8)  如果编译器支持template members of classes(类模板成员),  </span></span><br><span class="line"><span class="comment">//       则定义__STL_MEMBER_TEMPLATES  </span></span><br><span class="line"><span class="comment">//  (9)  如果编译器不支持&#x27;explicit&#x27;关键字, 则将&#x27;explicit&#x27;定义为空(null macro)  </span></span><br><span class="line"><span class="comment">//  (10) 如果编译器不能根据前一个模板参数设定后面的默认模板参数,  </span></span><br><span class="line"><span class="comment">//       则定义__STL_LIMITED_DEFAULT_TEMPLATES  </span></span><br><span class="line"><span class="comment">//  (11) 如果编译器处理模板函数的non-type模板参数类型推断有困难,  </span></span><br><span class="line"><span class="comment">//       则定义__STL_NON_TYPE_TMPL_PARAM_BUG  </span></span><br><span class="line"><span class="comment">//  (12) 如果编译器不支持迭代器使用&#x27;-&gt;&#x27;操作符,  </span></span><br><span class="line"><span class="comment">//       则定义__SGI_STL_NO_ARROW_OPERATOR  </span></span><br><span class="line"><span class="comment">//  (13) 如果编译器(在当前编译模式下)支持异常,  </span></span><br><span class="line"><span class="comment">//       则定义__STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="comment">//  (14) 如果我们将STL放进命名空间中,  </span></span><br><span class="line"><span class="comment">//       则定义__STL_USE_NAMESPACES  </span></span><br><span class="line"><span class="comment">//  (15) 如果本STL在SGI的编译器上编译, 并且用户没有选择pthreads或者no threads,  </span></span><br><span class="line"><span class="comment">//       则默认使用__STL_SGI_THREADS  </span></span><br><span class="line"><span class="comment">//       注: POSIX thread 简称为pthread, Posix线程是一个POSIX标准线程.  </span></span><br><span class="line"><span class="comment">//  (16) 如果本STL在Win32平台的编译器上使用多线程模式编译,  </span></span><br><span class="line"><span class="comment">//       则定义__STL_WIN32THREADS  </span></span><br><span class="line"><span class="comment">//  (17) 适当的定义命名空间相关的宏(__STD, __STL_BEGIN_NAMESPACE, 等)  </span></span><br><span class="line"><span class="comment">//  (18) 适当的定义异常相关的宏(__STL_TRY, __STL_UNWIND, 等)  </span></span><br><span class="line"><span class="comment">//  (19) 根据是否定义__STL_ASSERTIONS, 将__stl_assert定义为断言或者空(null macro)  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _PTHREADS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_PTHREADS  </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 如果编译器不提供本STL需要的一些功能,则定义__STL_NEED_XXX  </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__)  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> !defined(_BOOL)  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_NEED_BOOL  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> !defined(_TYPENAME_IS_KEYWORD)  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_NEED_TYPENAME  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">ifdef</span> _PARTIAL_SPECIALIZATION_OF_CLASS_TEMPLATES  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">ifdef</span> _MEMBER_TEMPLATES  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> !defined(_EXPLICIT_IS_KEYWORD)  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_NEED_EXPLICIT  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">ifdef</span> __EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> (_COMPILER_VERSION &gt;= 721) &amp;&amp; defined(_NAMESPACES)  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_USE_NAMESPACES  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> !defined(_NOTHREADS) &amp;&amp; !defined(__STL_PTHREADS)  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_SGI_THREADS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __GNUC__  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">include</span> <span class="string">&lt;_G_config.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> __GNUC__ &lt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 8)  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_STATIC_TEMPLATE_MEMBER_BUG  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_NEED_TYPENAME  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_NEED_EXPLICIT  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">else</span>  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line">    <span class="comment">/* glibc pre 2.0 is very buggy. We have to disable thread for it. </span></span><br><span class="line"><span class="comment">       It should be upgraded to glibc 2.0 or later. */</span>  </span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> !defined(_NOTHREADS) &amp;&amp; __GLIBC__ &gt;= 2 &amp;&amp; defined(_G_USING_THUNKS)  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_PTHREADS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">ifdef</span> __EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Sun C++ compiler  </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__SUNPRO_CC)  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NEED_BOOL  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NEED_TYPENAME  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NEED_EXPLICIT  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__COMO__)  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_USE_NAMESPACES  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// _MSC_VER 定义微软编译器的版本  </span></span><br><span class="line"><span class="comment">// MS VC++ 10.0 _MSC_VER = 1600  </span></span><br><span class="line"><span class="comment">// MS VC++ 9.0 _MSC_VER = 1500  </span></span><br><span class="line"><span class="comment">// MS VC++ 8.0 _MSC_VER = 1400  </span></span><br><span class="line"><span class="comment">// MS VC++ 7.1 _MSC_VER = 1310  </span></span><br><span class="line"><span class="comment">// MS VC++ 7.0 _MSC_VER = 1300  </span></span><br><span class="line"><span class="comment">// MS VC++ 6.0 _MSC_VER = 1200  </span></span><br><span class="line"><span class="comment">// MS VC++ 5.0 _MSC_VER = 1100  </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(_MSC_VER)  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> _MSC_VER &gt; 1000  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">include</span> <span class="string">&lt;yvals.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">else</span>  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_NEED_BOOL  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NO_DRAND48  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NEED_TYPENAME  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> _MSC_VER &lt; 1100  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_NEED_EXPLICIT  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NON_TYPE_TMPL_PARAM_BUG  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">ifdef</span> _CPPUNWIND  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">ifdef</span> _MT  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_WIN32THREADS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__BORLANDC__)  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NO_DRAND48  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NEED_TYPENAME  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_LIMITED_DEFAULT_TEMPLATES  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NON_TYPE_TMPL_PARAM_BUG  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">ifdef</span> _CPPUNWIND  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">ifdef</span> __MT__  </span></span><br><span class="line"><span class="meta">#     <span class="keyword">define</span> __STL_WIN32THREADS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__STL_NEED_BOOL)  </span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> <span class="type">bool</span>;  </span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> true 1  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> false 0  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_NEED_TYPENAME  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> typename  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_NEED_EXPLICIT  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> explicit  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NULL_TMPL_ARGS <span class="string">&lt;&gt;</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NULL_TMPL_ARGS  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_TEMPLATE_NULL template<span class="string">&lt;&gt;</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_TEMPLATE_NULL  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// __STL_NO_NAMESPACES is a hook so that users can disable namespaces  </span></span><br><span class="line"><span class="comment">// without having to edit library headers.  </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__STL_USE_NAMESPACES) &amp;&amp; !defined(__STL_NO_NAMESPACES)  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STD std  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_BEGIN_NAMESPACE namespace std &#123;  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_END_NAMESPACE &#125;  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_USE_NAMESPACE_FOR_RELOPS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE namespace std &#123;  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_END_RELOPS_NAMESPACE &#125;  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STD_RELOPS std  </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STD  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_BEGIN_NAMESPACE  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_END_NAMESPACE  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">undef</span>  __STL_USE_NAMESPACE_FOR_RELOPS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_END_RELOPS_NAMESPACE  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STD_RELOPS  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_TRY try  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_CATCH_ALL catch(...)  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_RETHROW throw  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NOTHROW throw()  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_UNWIND(action) catch(...) &#123; action; throw; &#125;  </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span>  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_TRY  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_CATCH_ALL <span class="keyword">if</span> (false)  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_RETHROW  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_NOTHROW  </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> __STL_UNWIND(action)  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_ASSERTIONS  </span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __stl_assert(expr) \  </span></span><br><span class="line">    <span class="keyword">if</span> (!(expr)) &#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s:%d STL assertion failure: %s\n&quot;</span>, \  </span><br><span class="line">              __FILE__, __LINE__, <span class="meta"># expr); abort(); &#125;  </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __stl_assert(expr)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_CONFIG_H */</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Local Variables:  </span></span><br><span class="line"><span class="comment">// mode:C++  </span></span><br><span class="line"><span class="comment">// End:</span></span><br></pre></td></tr></table></figure></p>
<h2 id="可能困惑的C-语法"><a href="#可能困惑的C-语法" class="headerlink" title="可能困惑的C++语法"></a>可能困惑的C++语法</h2><h3 id="stl-config-h中的各种组态（configuration）"><a href="#stl-config-h中的各种组态（configuration）" class="headerlink" title="stl_config.h中的各种组态（configuration）"></a>stl_config.h中的各种组态（configuration）</h3><p>组态3<code>__STL_STATIC_TEMPLATE_MEMBER_BUG</code>。如果编译器无法处理static member of template classes(模板类静态成员)就定义<br>。即对于模板类中，模板类型不同时的静态变量不同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> _data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> test&lt;<span class="type">int</span>&gt;::_data=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> test&lt;<span class="type">char</span>&gt;::_data=<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>组态5<code>__STL_CLASS_PARTIAL_SPECIALIZATION</code>。如果编译器支持 partial specialization of class templates(模板类偏特化)就定义。在模板类一般化设计之外（全特化），针对某些template做特殊设计。“所谓的partial specialization的另一个意思是提供另一份template定义式,而其本身仍是templatized”。全特化就是所有的模板都为具体的类。<code>T*</code>特化允许用指针类型匹配的模式（也只能匹配指针类型）。<code>const T*</code>特化允许使用指向const的指针类型匹配（也只能匹配指向const的指针）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般化设计，非特化情况均使用这个</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>,<span class="keyword">class</span> <span class="title class_">O</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span>&#123;</span><br><span class="line">	<span class="built_in">test</span>() &#123; cout &lt;&lt; <span class="string">&quot;I, O&quot;</span> &lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊化设计1（偏特化1）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span> &lt;T* ,T*&gt; &#123;</span><br><span class="line">	<span class="built_in">test</span>() &#123; cout &lt;&lt; <span class="string">&quot;T* ,T*&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊化设计2（偏特化2）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span> &lt;<span class="type">const</span> T* ,T*&gt; &#123;</span><br><span class="line">	<span class="built_in">test</span>() &#123; cout &lt;&lt; <span class="string">&quot;const T* ,T*&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	test&lt;<span class="type">int</span>, <span class="type">char</span>&gt; obj1;         <span class="comment">//I, O</span></span><br><span class="line">	test&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt; obj2;        <span class="comment">//T*, T*</span></span><br><span class="line">	test&lt;<span class="type">const</span> <span class="type">int</span>*, <span class="type">int</span>*&gt; obj3;  <span class="comment">//const T*, T*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>组态6<code>__STL_FUNCTION_TMPL_PARTIAL_ORDER</code>。如果编译器支持partial ordering of function templates或者说partial specialization of function templates就定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vec &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">void</span> <span class="built_in">swap</span>(vec&lt;T, Alloc&gt;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;swap1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="built_in">swap</span>(vec&lt;T, Alloc&gt;&amp; a, vec&lt;T, Alloc&gt;&amp; b) &#123; a.<span class="built_in">swap</span>(b); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vec&lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>组态8<code>__STL_MEMBER_TEMPLATES</code>。如果编译器支持template members of classes（模板类内嵌套模板） 就定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">vec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> I&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">insert</span><span class="params">(iterator position, I first, I last)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;insert()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">5</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	vec&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">	vec&lt;<span class="type">int</span>&gt;::iterator ite;</span><br><span class="line">	a.<span class="built_in">insert</span>(ite, ia, ia + <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>组态10<code>__STL_LIMITED_DEFAULT_TEMPLATES</code>。如果编译器支持一个template参数可以根据前一个template的参数设置就定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc,<span class="type">size_t</span> BufSiz=<span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">deque</span>() &#123; cout &lt;&lt; <span class="built_in">deque</span>() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Sequence</span>=deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">stack</span>() &#123; cout &lt;&lt; <span class="string">&quot;Stack&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Sequence c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>组态11<code>__STL_NON_TYPE_TMPL_PARAM_BUG</code>。测试类模板是否使用非类型模板参数（non-type template parameters） 。当以类型(type)作为模板参数的时候，代码中未决定的是类型；</p>
<p>当以一般的数字(non-type)作为模板参数的时候，代码中待定的内容便是某些数值。使用者这种模板必须要显示指定数值，模板才能实例化。通常它们只能是常数整数（constant integral values ）包括枚举，或者是指向外部链接的指针。不能把float，class-type类型的对象，内部链接(internal linkage )对象,作为非类型模板参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc,<span class="type">size_t</span> BufSiz=<span class="number">0</span>&gt;  <span class="comment">//BufSiz即为非类型模板。</span></span><br><span class="line"><span class="keyword">class</span> deque &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">deque</span>() &#123; cout &lt;&lt; <span class="built_in">deque</span>() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>__STL_NULL_TMPL_ARGS</code>。直接理解为若允许<strong>bound friend template(约束模板友元)</strong>则定义为 &lt;&gt; ，否则为空。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> ooperator== __STL_NULL_TMPL_ARGS(<span class="type">const</span> stack&amp;,<span class="type">const</span> stack&amp;);</span><br></pre></td></tr></table></figure><br>展开后变成<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> ooperator== &lt;&gt;(<span class="type">const</span> stack&amp;,<span class="type">const</span> stack&amp;);</span><br></pre></td></tr></table></figure><br><strong>bound friend template(约束模板友元)</strong>即友元类型取决于类被初始化时的类型，但程序必须在类外为友元提供模板定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Sequence</span>=deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack &#123;</span><br><span class="line">	<span class="comment">//最标准的写法</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== &lt;T&gt;(<span class="type">const</span> stack&lt;T&gt;&amp;, <span class="type">const</span> stack&lt;T&gt;&amp;);</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; &lt;T&gt;(<span class="type">const</span> stack&lt;T&gt;&amp;, <span class="type">const</span> stack&lt;T&gt;&amp;);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//参数列表中的&lt;T&gt;实际上可以忽略</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== &lt;T&gt;(<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; &lt;T&gt;(<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//当可以从参数中推断出模板类型时，可以改用&lt;&gt;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== &lt;&gt;(<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; &lt;&gt;(<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//下面用法是错误的！</span></span><br><span class="line">	<span class="comment">//friend bool operator== (const stack&amp;, const stack&amp;);</span></span><br><span class="line">	<span class="comment">//friend bool operator&lt; (const stack&amp;, const stack&amp;);</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">stack</span>() &#123; cout &lt;&lt; <span class="string">&quot;Stack&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Sequence c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义部分懒得写了，但必须要写！</span></span><br></pre></td></tr></table></figure></p>
<p><code>__STL_TEMPLATE_NULL</code>即<code>template &lt;&gt;</code>显示的模板特化 。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#	 <span class="keyword">define</span> __STL_TEMPLATE_NULL template<span class="string">&lt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#	 <span class="keyword">define</span> __STL_TEMPLATE_NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>模板特化(class template explicit specialization)</strong>即指定一种或多种模板形参的实际值或实际类型，作为特殊情况。（与模板类型偏特化不同！）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&#123; ...&#125;;<span class="comment">//非特化情况均使用这个</span></span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">char</span>&gt; &#123; ... &#125;;<span class="comment">//特化char情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>&gt; <span class="keyword">struct</span> <span class="title class_">hash</span> &#123; &#125;;<span class="comment">//非特化情况均使用这个</span></span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>&gt; &#123; ... &#125;;<span class="comment">//特化char情况</span></span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;unsgned <span class="type">char</span>&gt; &#123; ... &#125;;<span class="comment">//特化unsigned char情况</span></span><br></pre></td></tr></table></figure></p>
<p>经展开后：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&#123; ...&#125;;<span class="comment">//非特化情况均使用这个</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">char</span>&gt; &#123; ... &#125;;<span class="comment">//特化char情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>&gt; <span class="keyword">struct</span> <span class="title class_">hash</span> &#123; &#125;;<span class="comment">//非特化情况均使用这个</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>&gt; &#123; ... &#125;;<span class="comment">//特化char情况</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;unsgned <span class="type">char</span>&gt; &#123; ... &#125;;<span class="comment">//特化unsigned char情况</span></span><br></pre></td></tr></table></figure></p>
<h3 id="临时对象的产生与应用"><a href="#临时对象的产生与应用" class="headerlink" title="临时对象的产生与应用"></a>临时对象的产生与应用</h3><p>刻意制造一些临时对象，在类型名之后直接加一对()，并指定初值，使用时相当于调用该类的临时对象的()操作。常用于仿函数与算法的搭配上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; elem)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">plus</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ai</span><span class="params">(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;)</span></span>;</span><br><span class="line">	for_each(ai.<span class="built_in">begin</span>(), ai.<span class="built_in">end</span>(), <span class="built_in">print</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	<span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">print</span>&lt;<span class="type">int</span>&gt;()(<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;()(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后一行便是产生“function template具现体”<code>print&lt;int&gt;</code>的一个临时对象。这个对象将被传入进<code>for_each()</code>中。</p>
<h3 id="静态常量整数成员在class内部直接初始化"><a href="#静态常量整数成员在class内部直接初始化" class="headerlink" title="静态常量整数成员在class内部直接初始化"></a>静态常量整数成员在class内部直接初始化</h3><p>如果class内含const static integral data member，那么根据C++规格，我们可以在class之内直接给予初值。所谓integral泛指所有的整数型别（包括浮点数），不单只是指int，下面是一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> _datai=<span class="number">1.2</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> _datal=<span class="number">3L</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> _datac=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datai&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datal&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datac&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般，非const的static数据成员是不能在类的内部初始化，但是，我们可以为静态成员提供const整数类型的类内初始值。</p>
<p>例如，下面的情况会报错：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> _datai=<span class="number">1.2</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> _datal=<span class="number">3L</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> _datac=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datai&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datal&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datac&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果加了const 或者constexpr之后，就可以在类内进行初始化了。</p>
<p>对于static成员，如果在类的内部提供了一个初值，则成员在类外的定义不能再指定一个初始值了。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> _datai=<span class="number">1.2</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> _datal=<span class="number">3L</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> _datac=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> testClass&lt;T&gt;::_datai=<span class="number">8.8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datai&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datal&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datac&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的情况是允许的，直接在定义的时候提供初始值或者在类内提供初始值之后只在类外定义但不提供初始值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> _datai;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> _datal=<span class="number">3L</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> _datac=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> testClass&lt;T&gt;::_datai=<span class="number">8.8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datai&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datal&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datac&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>或者<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> _datai=<span class="number">1.2</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">long</span> _datal=<span class="number">3L</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> _datac=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> testClass&lt;T&gt;::_datai;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datai&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datal&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;testClass&lt;<span class="type">int</span>&gt;::_datac&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="increment-decrement-dereference操作符"><a href="#increment-decrement-dereference操作符" class="headerlink" title="increment/decrement/dereference操作符"></a>increment/decrement/dereference操作符</h3><p>increment/dereference操作符在迭代器的实现上占有非常重要的地位，因为任何一个迭代器都必须实现出前进（increment，operator++）和取值（dereference，operator*）功能，前者还分为前置式（prefix）和后置式（Postfix）两种。有写迭代器具备双向移动功能，那么就必须再提供decrement操作符（也分前置式和后置式），下面是一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">INT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> INT&amp; i);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">INT</span>(<span class="type">int</span> i):<span class="built_in">m_i</span>(i)&#123;&#125;</span><br><span class="line">    INT&amp; <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        ++(<span class="keyword">this</span>-&gt;m_i);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> INT <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        INT temp=*<span class="keyword">this</span>;</span><br><span class="line">        ++(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INT&amp; <span class="keyword">operator</span>--()</span><br><span class="line">    &#123;</span><br><span class="line">        --(<span class="keyword">this</span>-&gt;m_i);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> INT <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        INT temp=*<span class="keyword">this</span>;</span><br><span class="line">        --(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>&amp;)m_i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> INT &amp;i)</span><br><span class="line">&#123;</span><br><span class="line">    os&lt;&lt;<span class="string">&#x27;[&#x27;</span>&lt;&lt;i.m_i&lt;&lt;<span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">INT <span class="title">I</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;I++;</span><br><span class="line">    cout&lt;&lt;++I;</span><br><span class="line">    cout&lt;&lt;I--;</span><br><span class="line">    cout&lt;&lt;--I;</span><br><span class="line">    cout&lt;&lt;*I;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="前闭后开区间表示法"><a href="#前闭后开区间表示法" class="headerlink" title="前闭后开区间表示法"></a>前闭后开区间表示法</h3><p>任何一个STL算法，都需要获得由一对迭代器（泛型指针）所标示的区间，用以表示操作范围，这一对迭代器所标示的是个所谓的前闭后开区间，以[first,last)表示，也就是说，整个实际范围从first开始，直到last-1.迭代器last所指的是“最后一个元素的下一位置”。这种off by one（偏移一格，或说pass the end）的标示法，带来了很多方便，例如下面两个STL算法的循环设计，就显得干净利落：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> T&amp;value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(first!=last&amp;&amp;*first!=value) ++first;</span><br><span class="line">    <span class="keyword">return</span> first; <span class="comment">//返回迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>,<span class="keyword">class</span> <span class="title class_">Function</span>&gt;</span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator first,InputIterator last,Function f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;first!=last;++first)</span><br><span class="line">        <span class="built_in">f</span>(*first);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="function-call-操作符"><a href="#function-call-操作符" class="headerlink" title="function call 操作符"></a>function call 操作符</h3><p>函数调用操作（C++语法中的左右小括号）也可以被重载。</p>
<p>许多STL算法都提供了两个版本，一个用于一般情况（例如排序时以递增方式排列），一个用于特殊情况（例如排序时由使用者指定以何种特殊关系进行排列），像这种情况，需要用户指定某个条件或某个策略，而条件或策略的背后由一整组操作构成，便需要某种特殊的东西来代表这“一整组操作”。</p>
<p>代表“一整组操作“的，当然是函数，过去C语言时代，欲将函数当做参数传递，唯有通过函数指针才能达成，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* elem1,<span class="type">const</span> <span class="type">void</span>* elem2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ia[<span class="number">10</span>]=&#123;<span class="number">32</span>,<span class="number">92</span>,<span class="number">67</span>,<span class="number">58</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">25</span>,<span class="number">52</span>,<span class="number">59</span>,<span class="number">54</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        cout&lt;&lt;ia[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">qsort</span>(ia,<span class="built_in">sizeof</span>(ia)/<span class="built_in">sizeof</span>(<span class="type">int</span>),<span class="built_in">sizeof</span>(<span class="type">int</span>),fcmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        cout&lt;&lt;ia[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* elem1,<span class="type">const</span> <span class="type">void</span>* elem2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *i1=(<span class="type">const</span> <span class="type">int</span>*)elem1;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *i2=(<span class="type">const</span> <span class="type">int</span>*)elem2;</span><br><span class="line">    <span class="keyword">if</span>(*i1&lt;*i2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*i1==*i2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*i1&gt;*i2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是函数指针有缺点，最重要的是它无法持有自己的状态（所谓局部状态，local states），也无法达到组件技术中的可适配性（adaptability）——也就是无法再将某些修饰条件加诸于其上面而改变其状态。</p>
<p>为此，STL算法的特殊版本所接受的所谓“条件”或“策略”或“一整组操作”，都以仿函数形式呈现。所谓仿函数（functor）就是使用起来像函数一样的东西。如果你针对么某个class进行<code>operator()</code>重载，它就是一个仿函数，至于要成为一个可配接的仿函数，还需要做一些额外的努力。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//注意，不能使用using namespace std 不然plus和minus会有歧义</span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">plus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x,<span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">minus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x,<span class="type">const</span> T&amp; y)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> x-y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    plus&lt;<span class="type">int</span>&gt; plusObj;</span><br><span class="line">    minus&lt;<span class="type">int</span>&gt; minusObj;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">plusObj</span>(<span class="number">3</span>,<span class="number">5</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">minusObj</span>(<span class="number">3</span>,<span class="number">5</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//注意下面的调用，不要忘记调用默认构造函数的小括号以及函数对象调用参数的小括号</span></span><br><span class="line">　　<span class="comment">//以下直接产生仿函数的临时对象（第一对小括号），并调用之（第二对小括号）</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;()(<span class="number">43</span>,<span class="number">50</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;()(<span class="number">43</span>,<span class="number">50</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><p>以STL的运用角度而言，空间配置器是最不需要介绍的东西，它总是隐藏在一切组件（更具体地说是指容器，container）的背后，默默工作，默默付出。但若以STL的实现角度而言，第一个需要介绍的就是空间配置器，因为整个STL的操作对象（所有的数据）都存放在容器之内，而容器一定需要配置空间以置放资料。</p>
<p>为什么不说allocator是内存配置器而说它是空间配置器呢？因为空间不一定是内存，空间也可以是磁盘或其它辅助存储介质。是的，你可以一个allocator，直接向硬盘取空间，以下介绍的是SGI STL提供的配置器，配置的对象是内存。</p>
<h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><p>根据STL的规范，以下是allocator的必要接口：</p>
<ul>
<li><code>allocator::value_type</code></li>
<li><code>allocator::pointer</code></li>
<li><code>allocator::const_pointer</code></li>
<li><code>allocator::reference</code></li>
<li><code>allocator::const_reference</code></li>
<li><code>allocator::size_type</code></li>
<li><code>allocator::difference_type</code></li>
<li><code>allocator::rebind</code>：一个嵌套的class template，<code>class rebind&lt;U&gt;</code>拥有唯一的成员other，那是一个typedef，代表<code>allocator&lt;U&gt;</code></li>
<li><code>allocator::allocator()</code>：default constuctor</li>
<li><code>allocator::allocator(const allocator&amp;)</code>：copy constructor</li>
<li><code>template&lt;class U&gt;allocator::allocator(const allocator&lt;U&gt;&amp;)</code>：泛化的copy constructor</li>
<li><code>allocator::~allocator()</code>：destructor</li>
<li><code>pointer allocator::address(reference x)const</code>：返回某个对象的地址，算式<code>a.address(x)</code>等同于<code>&amp;x</code></li>
<li><code>const_pointer allocator::address(const_reference x)const</code>：返回某个const对象的地址，算式<code>a.address(x)</code>等同于<code>&amp;x</code></li>
<li><code>pointer allocator::allocate(size_type n,const void* =0)</code>：配置空间，足以存储n个T对象，第二参数是个提示，实际上可能会利用它来增进区域性，或完全忽略之</li>
<li><code>void allocator::deallocate(pointer p,size_type n)</code>：归还先前配置的空间</li>
<li><code>size_type allocator::max_size() const</code>：返回可成功分配的最大量</li>
<li><code>void allocator::construct(pointer p,const T&amp; x)</code>：等同于<code>new((void*)p) T(x)</code></li>
<li><code>void allocator::destroy(pointer p)</code>：等同于<code>p-&gt;~T()</code></li>
</ul>
<h3 id="设计一个简单的空间配置器-JJ-allocator"><a href="#设计一个简单的空间配置器-JJ-allocator" class="headerlink" title="设计一个简单的空间配置器, JJ::allocator"></a>设计一个简单的空间配置器, JJ::allocator</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> JJ</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> T* _allocate(<span class="type">ptrdiff_t</span> size, T*)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">	T* tmp = (T*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size *<span class="built_in">sizeof</span>(T))));</span><br><span class="line">	<span class="keyword">if</span> (tmp == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cerr &lt;&lt; <span class="string">&quot;out of memory!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _deallocate(T* buffer)</span><br><span class="line">&#123;</span><br><span class="line">	::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _construct(T1* p,<span class="type">const</span> T2&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">new</span>(p) <span class="built_in">T1</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _destroy(T* ptr)</span><br><span class="line">&#123;</span><br><span class="line">	ptr-&gt;<span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T* const_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T&amp; const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rebind</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n, <span class="type">const</span> <span class="type">void</span> *hint=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _allocate((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_deallocate(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer p, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_construct(p,value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_destroy(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (pointer)&amp;x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (const_pointer)&amp;x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_type</span>(UINT_MAX/<span class="built_in">sizeof</span>(T));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	vector&lt;<span class="type">int</span>,JJ::allocator&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ivv</span>(ia,ia<span class="number">+5</span>);</span><br><span class="line">	vector&lt;<span class="type">int</span>,std::allocator&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">iv</span>(ia,ia<span class="number">+5</span>);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; iv.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	std::cout &lt;&lt; iv[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具备次配置力的-SGI-空间配置器"><a href="#具备次配置力的-SGI-空间配置器" class="headerlink" title="具备次配置力的 SGI 空间配置器"></a>具备次配置力的 SGI 空间配置器</h2><p>SGI STL的配置器与众不同，它与标准规范不同，其名称是alloc而非allocator。如果要在程序中明白采用SGI配置器，那么应该这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>, std::alloc&gt; iv; <span class="comment">//gcc编译器</span></span><br></pre></td></tr></table></figure></p>
<p>配置器名字为alloc，不接受任何参数。标准配置器的名字是allocator，而且可以接受参数。比如VC中写法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt; iv; <span class="comment">//VC编译器</span></span><br></pre></td></tr></table></figure></p>
<p>SGI STL的每一个容器都已经指定了缺省配置其alloc。我们很少需要自己去指定空间配置器。比如vector容器的声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="SGI标准的空间配置器allocator"><a href="#SGI标准的空间配置器allocator" class="headerlink" title="SGI标准的空间配置器allocator"></a>SGI标准的空间配置器allocator</h3><p>其实SGI也定义了一个符合部分标准，名为allocator的配置器，但是它自己不使用，也不建议我们使用，主要原因是效率不佳。它只是把C++的操作符<code>::operator new</code>和<code>::operator delete</code>做了一层简单的封装而已。下面仅仅贴出代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFALLOC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFALLOC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algobase.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//仅仅是简单的封装了operator new</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T* <span class="title">allocate</span><span class="params">(<span class="type">ptrdiff_t</span> size, T*)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">    T* tmp = (T*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size * <span class="built_in">sizeof</span>(T))));</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;out of memory&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仅仅是简单的封装了operator::delete</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T* buffer)</span> </span>&#123;</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T&amp; const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> ::<span class="built_in">allocate</span>((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p)</span> </span>&#123; ::<span class="built_in">deallocate</span>(p); &#125;</span><br><span class="line">    <span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span> </span>&#123; <span class="keyword">return</span> (pointer)&amp;x; &#125;</span><br><span class="line">    <span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (const_pointer)&amp;x; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">init_page_size</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">size_type</span>(<span class="number">1</span>), <span class="built_in">size_type</span>(<span class="number">4096</span>/<span class="built_in">sizeof</span>(T))); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">size_type</span>(<span class="number">1</span>), <span class="built_in">size_type</span>(UINT_MAX/<span class="built_in">sizeof</span>(T))); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* pointer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="SGI特殊的空间配置器std-alloc"><a href="#SGI特殊的空间配置器std-alloc" class="headerlink" title="SGI特殊的空间配置器std::alloc"></a>SGI特殊的空间配置器std::alloc</h3><p>一般而言，我们所习惯的C++内存配置器操作和释放操作时这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FOO</span> &#123; ...&#125;;</span><br><span class="line">FOO* pf=<span class="keyword">new</span> FOO;  <span class="comment">//配置内存，然后构造对象</span></span><br><span class="line"><span class="keyword">delete</span> pf;  <span class="comment">//将对象析构，然后释放内存</span></span><br></pre></td></tr></table></figure><br>这其中的new算式内含两个阶段操作：</p>
<ol>
<li>调用<code>::operator new</code>配置内存</li>
<li>调用<code>FOO::FOO()</code>构造对象内容</li>
</ol>
<p>delete算式也内含两个阶段操作：</p>
<ol>
<li>调用<code>FOO::~FOO()</code>对对象析构</li>
<li>调用<code>::operator delete</code>释放内存</li>
</ol>
<p>为了精密分工，SGI allocator将两个阶段分开：</p>
<p>内存配置操作由<code>alloc:allocate</code>负责，内存释放由<code>alloc:deallocate</code>负责；对象构造操作由<code>::contructor()</code>负责，对象析构由<code>::destroy()</code>负责。</p>
<p>STL标准告诉我们，配置器定义在头文件<code>&lt;memory&gt;</code>中，它里面又包括两个文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_alloc.h&gt;</span>		<span class="comment">// 负责内存空间的配置和器释放</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_construct.h&gt;</span>		<span class="comment">// 负责对象的构造和析构</span></span></span><br></pre></td></tr></table></figure><br>内存空间的配置/释放与对象内容的构造/析构，分别落在这两个文件身上。其中<code>&lt;stl_construct.h&gt;</code>定义了两个基本函数：构造用的<code>construct()</code>和析构用的<code>destroy()</code>。</p>
<p>下图显示了其结构：<br><img src="/img/1608949666.jpg" alt=""></p>
<h3 id="构造函数析构的基本工具：construct-和destroy"><a href="#构造函数析构的基本工具：construct-和destroy" class="headerlink" title="构造函数析构的基本工具：construct()和destroy()"></a>构造函数析构的基本工具：construct()和destroy()</h3><p>下面是<code>&lt;stl_constuct.h&gt;</code>的部分内容：</p>
<p>函数<code>construct()</code>使用了定位new操作符，其源代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">construct</span><span class="params">(T1* p, <span class="type">const</span> T2&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> (p) <span class="built_in">T1</span>(value);     <span class="comment">// 定为new操作符placement new; 在指针p所指处构造对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数destroy则有两个版本。</p>
<p>第一个版本较简单，接受一个指针作为参数，直接调用对象的析构函数即可，其源代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* pointer)</span> </span>&#123;</span><br><span class="line">    pointer-&gt;~<span class="built_in">T</span>();    <span class="comment">// 调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第二个版本，其参数接受两个迭代器，将两个迭代器所指范围内的所有对象析构掉。而且，它采用了一种特别的技术：依据元素的型别，判断其是否有trivial destructor（无用的析构函数）进行不同的处理。这也是为了效率考虑。因为如果每个对象的析构函数都是trivial的，那么调用这些毫无作用的析构函数会对效率造成影响。</p>
<p>下面看其源代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是 destroy() 第二版本，接受两个迭代器。它会设法找出元素的数值型別，</span></span><br><span class="line"><span class="comment">// 进而利用 __type_traits&lt;&gt; 求取最适当措施。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">  __destroy(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素的数值型別（value type）是否有 trivial destructor，分别调用上面的函数进行不同的处理</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy(ForwardIterator first, ForwardIterator last, T*) &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">  __destroy_aux(first, last, <span class="built_in">trivial_destructor</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的数值型別（value type）有 trivial destructor…</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator, ForwardIterator, __true_type) &#123;&#125;<span class="comment">//不调用析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的数值型別（value type）有 non-trivial destructor…</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first &lt; last; ++first)</span><br><span class="line">    <span class="built_in">destroy</span>(&amp;*first);<span class="comment">//调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第二版本还针对迭代器为<code>char*</code>和<code>wchar_t*</code>定义了特化版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>*)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">wchar_t</span>*, <span class="type">wchar_t</span>*)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>图二显示了这两个函数的结构和功能。他们被包含在头文件<code>stl_construct.h</code>中。<br><img src="/img/1608949943.jpg" alt=""></p>
<p>这两个作为构造、析构之用的函数被设计为全局函数，符合STL的规范。此外，STL还规定配置器必须拥有名为<code>construct()</code>和<code>destroy()</code>的两个成员函数。</p>
<p>上述<code>construct()</code>接收一个指针p和一个初值value，该函数的用途就是将初值设定到指针所指的空间上。C++的<code>placement new</code>运算可用来完成这一任务。</p>
<p><code>destroy()</code>有两个版本，第一版本接受一个指针，准备将该指针所指之物析构掉。这很简单，直接调用该对象的析构函数即可。第二版本接受first和last迭代器，准备将[first,last)范围内的所以对象析构掉。我们不知道这个范围有多大，万一很大，而每个对象的析构函数都无关痛痒（所谓的trivial destructor），那么一次次调用这些无关痛痒的析构函数，对效率是一种伤害。因此，这里先利用<code>value_type()</code>获得迭代器所指对象的型别，再利用<code>_type_traits&lt;T&gt;</code>判断该型别的析构函数是否无关痛痒。若是（<code>_true_type</code>），则什么也不做就结束；若否，（<code>_false_type</code>），这才以循环方式巡访整个范围，并在循环中每经历一个对象就调用一个版本的<code>destroy()</code>。</p>
<h3 id="空间的配置和释放，std-alloc"><a href="#空间的配置和释放，std-alloc" class="headerlink" title="空间的配置和释放，std::alloc"></a>空间的配置和释放，std::alloc</h3><p>对象构造前的空间配置和对象析构后的空间释放，由<code>&lt;stl_alloc.h&gt;</code>负责，SGI对此的设计哲学如下：</p>
<ul>
<li>向system heap要求空间</li>
<li>考虑多线程状态</li>
<li>考虑内存不足时的应变措施</li>
<li>考虑过多“小型区块”可能造成的内存碎片问题</li>
</ul>
<p>C++的内存配置基本操作是<code>::operator new()</code>，内存释放基本操作是<code>::operator delete()</code>。这两个全局函数相当于C的<code>malloc()</code>和<code>free()</code>函数。是的，正是如此，SGI正是以<code>malloc()</code>和<code>free()</code>完成内存的配置和释放。</p>
<p>考虑到小型区块所可能造成的内存碎片问题。SGI设计了双层配置器，第一级配置器直接使用<code>malloc()</code>和<code>free()</code>，第二级配置器则视情况采用不同的策略；当配置区块超过128bytes时，视之为“足够大”，便调用第一级配置器；当配置区块小于128bytes时，视之为“过小”，为了降低额外负担，便采用复杂的memory pool整理方式，而不再求助于第一级配置器。整个设计究竟是开放第一级配置器或是同时开放第二级配置器，取决于<code>_USE_MALLOC</code>是否被定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_MALLOC </span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;<span class="comment">//令 alloc为第一级配置器</span></span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc; </span><br><span class="line"><span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line">... </span><br><span class="line"><span class="comment">//令 alloc 为第二级配置器 </span></span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ! __USE_MALLOC */</span> </span></span><br></pre></td></tr></table></figure><br>其中<code>__malloc_alloc_template</code>就是第一级配置器，<code>__default_alloc_template</code>就是第二级配置器。</p>
<p>无论alloc被定义为第一级或者是第二级配置器，SGI还为它包装一个接口如下，使配置器的接口能够符合STL规格：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::<span class="built_in">allocate</span>(n * <span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> (T*) Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">                </span>&#123; Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其内部四个成员函数其实都是弹单纯的转调用，调用传递给配置器（可能是第一级也可能是第二级）的成员函数。这个接口使配置器的配置单位从bytes转为个别元素的大小（<code>sizeof(T)</code>）。SGI STL容器全都用这个<code>simple_alloc</code>接口。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; <span class="comment">// 缺省使用alloc为配置器</span></span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (...)</span><br><span class="line">            data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一、二级配置器的关系如下：<br><img src="/img/1608952882.jpg" alt=""></p>
<p>第一级和第二级配置器的包装接口和运用方式如下：<br><img src="/img/1608952929.jpg" alt=""></p>
<h3 id="第一级配置器-malloc-alloc-template剖析"><a href="#第一级配置器-malloc-alloc-template剖析" class="headerlink" title="第一级配置器__malloc_alloc_template剖析"></a>第一级配置器__malloc_alloc_template剖析</h3><p>首先我们观察第一级配置器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0 </span></span><br><span class="line"><span class="meta">#   <span class="keyword">include</span> <span class="string">&lt;new&gt;</span> </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span>  __THROW_BAD_ALLOC throw bad_alloc </span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> !defined(__THROW_BAD_ALLOC) </span></span><br><span class="line"><span class="meta">#   <span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span> </span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span>  __THROW_BAD_ALLOC cerr &lt;&lt; <span class="string">&quot;out of memory&quot;</span> &lt;&lt; endl; exit(1) </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// malloc-based allocator. 通常比稍后介绍的 default alloc 速度慢， </span></span><br><span class="line"><span class="comment">//一般而言是 thread-safe，并且对于空间的运用比较高效（efficient）。 </span></span><br><span class="line"><span class="comment">//以下是第一级配置器。 </span></span><br><span class="line"><span class="comment">//注意，无「template 型别参数」。至于「非型别参数」inst，完全没派上用场。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;   </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span> &#123; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="comment">//以下都是函式指标，所代表的函式将用来处理内存不足的情况。 </span></span><br><span class="line"><span class="comment">// oom : out of memory. </span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span> *, <span class="type">size_t</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">void</span>  *result =<span class="built_in">malloc</span>(n);<span class="comment">//第一级配置器直接使用 malloc() </span></span><br><span class="line">    <span class="comment">// 以下，无法满足需求时，改用 oom_malloc() </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_malloc</span>(n); </span><br><span class="line">    <span class="keyword">return</span>  result; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* n */</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//第一级配置器直接使用 free() </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">reallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* old_sz */</span>, <span class="type">size_t</span> new_sz)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">void</span>  *  result  =<span class="built_in">realloc</span>(p, new_sz);<span class="comment">//第一级配置器直接使用 rea</span></span><br><span class="line">    <span class="comment">// 以下，无法满足需求时，改用 oom_realloc() </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_realloc</span>(p, new_sz); </span><br><span class="line">    <span class="keyword">return</span>  result; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//以下模拟 C++的 set_new_handler(). 换句话说，你可以透过它， </span></span><br><span class="line"><span class="comment">//指定你自己的 out-of-memory handler </span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="type">void</span> (*f)()))</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">void</span>  (*  old)()  =  __malloc_alloc_oom_handler; </span><br><span class="line">__malloc_alloc_oom_handler = f; </span><br><span class="line">    <span class="keyword">return</span>(old); </span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// malloc_alloc out-of-memory handling </span></span><br><span class="line"><span class="comment">//初值为 0。有待客端设定。 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt; </span><br><span class="line"><span class="built_in">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">void</span>  (* my_malloc_handler)(); </span><br><span class="line">    <span class="type">void</span>  *result; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (;;)  &#123; </span><br><span class="line">        <span class="comment">//不断尝试释放、配置、再释放、再配置… </span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler; </span><br><span class="line">        <span class="keyword">if</span>  (<span class="number">0</span>  ==  my_malloc_handler)  &#123;  __THROW_BAD_ALLOC; &#125; </span><br><span class="line">        (*my_malloc_handler)();<span class="comment">//呼叫处理例程，企图释放内存。 </span></span><br><span class="line">        result = <span class="built_in">malloc</span>(n);  <span class="comment">//再次尝试配置内存。 </span></span><br><span class="line">        <span class="keyword">if</span>  (result)  <span class="keyword">return</span>(result); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_realloc</span>(<span class="type">void</span> *p, <span class="type">size_t</span> n) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">void</span>  (* my_malloc_handler)(); </span><br><span class="line">    <span class="type">void</span>  *result; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;)  &#123;  <span class="comment">//不断尝试释放、配置、再释放、再配置… </span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler; </span><br><span class="line">        <span class="keyword">if</span>  (<span class="number">0</span>  ==  my_malloc_handler)  &#123;  __THROW_BAD_ALLOC; &#125; </span><br><span class="line">        (*my_malloc_handler)();<span class="comment">//呼叫处理例程，企图释放内存。 </span></span><br><span class="line">        result = <span class="built_in">realloc</span>(p, n);<span class="comment">//再次尝试配置内存。 </span></span><br><span class="line">        <span class="keyword">if</span>  (result)  <span class="keyword">return</span>(result); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//注意，以下直接将参数 inst指定为 0。 </span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc; </span><br></pre></td></tr></table></figure></p>
<p>第一级配置器直接使用<code>malloc()</code>，<code>free()</code>，<code>realloc()</code>等C函数执行实际的内存配置、释放、重配置操作，并实现出类似C++ new handler机制。它有独特的out-of-memory内存处理机制：在抛出<code>std::bad_alloc</code>异常之前，调用内存不足处理例程尝试释放空间，如果用户没有定义相应的内存不足处理例程，那么还是会抛出异常。</p>
<p>所谓C++ new handler机制是，你可以要求系统在内存配置要求无法被满足时，调用一个你所指定的函数。换句话说，一旦::operator new无法完成任务，在丢出<code>std::bad_alloc</code>异常状态之前，会先调用由客户端指定的处理例程，该处理例程通常即被称为new-handler。new-handler解决内存不足的做法有特定的模式。</p>
<p>请注意，SGI第一级配置器的<code>allocate()</code>和<code>realloc()</code>都是在调用<code>malloc()</code>和<code>realloc()</code>不成功后，改调用<code>oom_malloc()</code>和<code>oom_realloc()</code>。后两者都有内循环，不断调用“内存不足处理例程”，期望在某次调用之后，获得足够的内存而圆满完成任务。但如果“内存不足处理例程”并未被客户端设定，<code>oom_malloc()</code>和<code>oom_realloc()</code>便老实不客气地调用<code>__THROW_BAD_ALLOC</code>，丢出<code>bad_alloc</code>异常信息，或利用<code>exit(1)</code>硬生生中止程序。</p>
<p>记住，设计“内存不足处理例程”是客端的责任，设定“内存不足处理例程”也是客端的责任。</p>
<h3 id="第二级配置器-default-alloc-template剖析"><a href="#第二级配置器-default-alloc-template剖析" class="headerlink" title="第二级配置器__default_alloc_template剖析"></a>第二级配置器__default_alloc_template剖析</h3><p>相比第一级配置器，第二级配置器多了一些机制，避免小额区块造成内存的碎片。不仅仅是碎片的问题，配置时的额外负担也是一个大问题。因为区块越小，额外负担所占的比例就越大。</p>
<p>额外负担是指<strong>动态分配内存块的时候，位于其头部的额外信息，包括记录内存块大小的信息以及内存保护区（判断是否越界）</strong>。要想了解详细信息，请参考MSVC或者其他malloc实现。</p>
<p>SGI STL第二级配置器具体实现思想如下：</p>
<ul>
<li>如果要分配的区块大于128bytes，则移交给第一级配置器处理。</li>
<li>如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的自由链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中——是的，别忘了，配置器除了负责配置，也负责回收。</li>
</ul>
<p>在第二级配置器中，小额区块内存需求大小都被上调至8的倍数，比如需要分配的大小是30bytes，就自动调整为32bytes。系统中总共维护16个free-lists，各自管理大小为8,16，…，128bytes的小额区块。</p>
<p>为了维护链表，需要额外的指针，为了避免造成另外一种额外的负担，这里采用了一种技术：用union表示链表节点结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">      <span class="keyword">union</span> <span class="title class_">obj</span> * free_list_link;<span class="comment">//指向下一个节点</span></span><br><span class="line">      <span class="type">char</span> client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>union能够实现一物二用的效果，当节点所指的内存块是空闲块时，obj被视为一个指针，指向另一个节点。当节点已被分配时，被视为一个指针，指向实际区块。</p>
<p><img src="/img/1608954958.jpg" alt=""></p>
<p>下面是第二级配置器的部分实现内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN=<span class="number">8</span>&#125;; <span class="comment">//小型区块的上调上界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES=<span class="number">128</span>&#125;;  <span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS=__MAX_BYRES/__ALIGN&#125;;  <span class="comment">//free-lists个数</span></span><br></pre></td></tr></table></figure></p>
<p>以下是第二级配置器总体实现代码概览：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 實際上我們應該使用 static const int x = N</span></span><br><span class="line">  <span class="comment">// 來取代 enum &#123; x = N &#125;, 但目前支援該性質的編譯器還不多。</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __SUNPRO_CC</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">__PRIVATE:</span><br><span class="line">  <span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">        <span class="keyword">union</span> <span class="title class_">obj</span> * free_list_link;</span><br><span class="line">        <span class="type">char</span> client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this. */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __SUNPRO_CC</span></span><br><span class="line">    <span class="type">static</span> obj * __VOLATILE free_list[]; </span><br><span class="line">        <span class="comment">// Specifying a size results in duplicate def for 4.1</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    <span class="type">static</span> obj * __VOLATILE free_list[__NFREELISTS]; </span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="function"><span class="type">static</span>  <span class="type">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>)/__ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an object of size n, and optionally adds to size n free list.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">refill</span><span class="params">(<span class="type">size_t</span> n)</span></span>;</span><br><span class="line">  <span class="comment">// Allocates a chunk for nobjs of size &quot;size&quot;.  nobjs may be reduced</span></span><br><span class="line">  <span class="comment">// if it is inconvenient to allocate the requested number.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> &amp;nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chunk allocation state.</span></span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> *start_free;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> *end_free;</span><br><span class="line">  <span class="type">static</span> <span class="type">size_t</span> heap_size;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span></span>&#123;...&#125;</span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">reallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> old_sz, <span class="type">size_t</span> new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>;<span class="comment">//内存池起始位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;<span class="comment">//内存池结束位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj * __VOLATILE</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt; ::free_list[</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __SUNPRO_CC</span></span><br><span class="line">    __NFREELISTS</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    __default_alloc_template&lt;threads, inst&gt;::__NFREELISTS</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="空间配置函数allocate"><a href="#空间配置函数allocate" class="headerlink" title="空间配置函数allocate()"></a>空间配置函数allocate()</h3><p><code>__default_alloc_template</code>拥有配置器的标准接口函数<code>allocate()</code>，此函数首先判断区块大小，要分配的区块小于128bytes，调用第一级配置器。否则，向对应的free-list寻求帮助。对应的free list有可用的区块，直接拿过来用。如果没有可用的区块，调用函数<code>refill()</code>为`free list重新填充空间。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    obj * __VOLATILE * my_free_list;</span><br><span class="line">    obj * __RESTRICT result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        <span class="keyword">return</span>(malloc_alloc::<span class="built_in">allocate</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">    <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">    <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">    <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#       <span class="keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">        <span class="comment">/*REFERENCED*/</span></span><br><span class="line">        lock lock_instance;</span><br><span class="line"><span class="meta">#       <span class="keyword">endif</span></span></span><br><span class="line">    result = *my_free_list;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n));</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    *my_free_list = result -&gt; free_list_link;</span><br><span class="line">    <span class="keyword">return</span> (result);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是，每次都是从对应的free list的头部取出可用的内存块。图示如下：<br><img src="1608955300.jpg" alt=""></p>
<h3 id="空间释放函数"><a href="#空间释放函数" class="headerlink" title="空间释放函数"></a>空间释放函数</h3><p>身为一个配置器，<code>__default_alloc_template</code>拥有配置器的标准接口函数<code>deallocate()</code>，此函数首先判断区块大小，大于128bytes调用第一级配置器。否则，找出对应的free list，将区块回收。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 不可以为0</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj *q = (obj *)p;</span><br><span class="line">    obj * <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于128就调用一级配置器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        malloc_alloc::<span class="built_in">deallocate</span>(p, n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找对应的free list</span></span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">    <span class="comment">// 调整free list，收回区块</span></span><br><span class="line">    q-&gt;free_list_link = *my_free_list;</span><br><span class="line">    *my_free_list = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1608957050.jpg" alt=""></p>
<h3 id="为free-list填充空间"><a href="#为free-list填充空间" class="headerlink" title="为free list填充空间"></a>为free list填充空间</h3><p>当发现对应的free list没有可用的空闲区块时，就需要调用<code>refill()</code>函数重新填充空间。新的空间将取自于内存池（将经由<code>chunk_alloc()</code>完成）。缺省取得20个新节点（新区块），但万一内存池空间不足，获得的节点数（区块数）可能小于20，内存池的管理后面会讲到。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns an object of size n, and optionally adds to size n free list.*/</span></span><br><span class="line"><span class="comment">/* We assume that n is properly aligned.                                */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">refill</span>(<span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//调用chunk_alloc()，尝试取得nobjs个区块作为free list的新节点，注意参数nobjs是pass by reference</span></span><br><span class="line">    <span class="type">char</span> * chunk = <span class="built_in">chunk_alloc</span>(n, nobjs);</span><br><span class="line">    obj * __VOLATILE * my_free_list;</span><br><span class="line">    obj * result;</span><br><span class="line">    obj * current_obj, * next_obj;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);</span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">      result = (obj *)chunk;</span><br><span class="line">      *my_free_list = next_obj = (obj *)(chunk + n);</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) &#123;<span class="comment">//将各节点串接起来（注意，索引为0的返回给客端使用）</span></span><br><span class="line">        current_obj = next_obj;</span><br><span class="line">        next_obj = (obj *)((<span class="type">char</span> *)next_obj + n);</span><br><span class="line">        <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">            current_obj -&gt; free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current_obj -&gt; free_list_link = next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>从内存池中取空间供free list使用，是<code>chunk_alloc()</code>的工作。具体实现思想如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span><br><span class="line"><span class="comment">/* the malloc heap too much.                                            */</span></span><br><span class="line"><span class="comment">/* We assume that size is properly aligned.                             */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span>*</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::<span class="built_in">chunk_alloc</span>(<span class="type">size_t</span> size, <span class="type">int</span>&amp; nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * result;</span><br><span class="line">    <span class="type">size_t</span> total_bytes = size * nobjs;</span><br><span class="line">    <span class="type">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123;</span><br><span class="line">        nobjs = bytes_left/size;</span><br><span class="line">        total_bytes = size * nobjs;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);<span class="comment">//注意此处申请的空间的大小</span></span><br><span class="line">        <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            obj * __VOLATILE * my_free_list =</span><br><span class="line">                        free_list + <span class="built_in">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line"></span><br><span class="line">            ((obj *)start_free) -&gt; free_list_link = *my_free_list;</span><br><span class="line">            *my_free_list = (obj *)start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        start_free = (<span class="type">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            obj * __VOLATILE * my_free_list, *p;</span><br><span class="line">            <span class="comment">// Try to make do with what we have.  That can&#x27;t</span></span><br><span class="line">            <span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;</span><br><span class="line">                my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i);</span><br><span class="line">                p = *my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;</span><br><span class="line">                    *my_free_list = p -&gt; free_list_link;</span><br><span class="line">                    start_free = (<span class="type">char</span> *)p;</span><br><span class="line">                    end_free = start_free + i;</span><br><span class="line">                    <span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">                    <span class="comment">// right free list.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        end_free = <span class="number">0</span>;    <span class="comment">// In case of exception.</span></span><br><span class="line">            start_free = (<span class="type">char</span> *)malloc_alloc::<span class="built_in">allocate</span>(bytes_to_get);</span><br><span class="line">            <span class="comment">// This should either throw an</span></span><br><span class="line">            <span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">            <span class="comment">// succeeded.</span></span><br><span class="line">        &#125;</span><br><span class="line">        heap_size += bytes_to_get;</span><br><span class="line">        end_free = start_free + bytes_to_get;</span><br><span class="line">        <span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>chunk_alloc()</code>函数以<code>end_free - start_free</code>来判断内存池的数量：</p>
<ul>
<li>内存池剩余空间完全满足20个区块的需求量，则直接取出对应大小的空间。</li>
<li>内存池剩余空间不能完全满足20个区块的需求量，但是足够供应一个及一个以上的区块，则取出能够满足条件的区块个数的空间。</li>
<li>内存池剩余空间不能满足一个区块的大小，则需要利用<code>malloc()</code>从heap中配置内存，为内存池注入活水。</li>
</ul>
<p>举个例子，见图2-7，假设程序一开始，客端就调用<code>chunk_alloc(32,2O)</code>，于是<code>malloc()</code>配置40个32 bytes区块，其中第1个交出，另19个交给<code>free_list[3]</code>维护，余20个留给内存池。接下来客端调用<code>chunk_alloc(64,20)</code>，此时<code>free_1ist[7]</code>空空如也，必须向内存池要求支持，内存池只够供应<code>(32*20)/M = 10</code>个64 bytes区块，就把这10个区块返回，第1个交给客端、余9个由<code>free_list[7]</code>维护。此时内存池全空，接下来再调用<code>chunk_alloc(96, 20)</code>，此时<code>free_list[11]</code>空空如也，必须向内存池要求支持，而内存池此时也是空的，于是以<code>malloc()</code>配置40+n（附加量）个96 bytes区块， 其中第1个交出，另19个交给<code>free_list[11]</code>维护，余20+n（附加量）个区块留给内存池。</p>
<p>万一山穷水尽，整个system heap空问都不够了（以至无法为内存池注入活水源头），<code>malloc()</code>行动失败，<code>chunk_alloc()</code>就四处寻找有无“尚有未用区块，且区块够大”之free lists。找到了就挖一块交出，找不到就调用第一级配置器，第一级配置器其实也是使用<code>malloc()</code>来配置内存，但它有out-of-memory处理机制（类似new-handler机制），或许有机会释放其它的内存拿来此处使用。如果可以，就成功，否则发出<code>bad_alloc</code>异常。 </p>
<p>以上便是整个第二级空间配置器的设计。 </p>
<p><img src="/img/1608959629.jpg" alt=""></p>
<p>回想一些那个提供配置器标准接口的simple_alloc：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>SGI容器通常以这种方式来使用配置器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt; <span class="comment">//缺省使用alloc配置器</span></span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//专属之空间配置器，每次配置一个元素大小</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中第二个template参数所使用的缺省参数alloc，可以是第一级配置器也可以是第二级配置器。不过，SGI STL已经把它设为第二级配置器。</p>
<h3 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate()"></a>deallocate()</h3><p>如果需要回收的区块大于128bytes，则调用第一级配置器。如果需要回收的区块小于128bytes，找到对应的free-list，将区块回收。注意是将区块放入free -list的头部。SGI STL源代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    obj *q = (obj *)p;</span><br><span class="line">    obj * __VOLATILE * my_free_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        malloc_alloc::<span class="built_in">deallocate</span>(p, n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">    <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">        <span class="comment">/*REFERENCED*/</span></span><br><span class="line">        lock lock_instance;</span><br><span class="line"><span class="meta">#       <span class="keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">    q -&gt; free_list_link = *my_free_list;</span><br><span class="line">    *my_free_list = q;</span><br><span class="line">    <span class="comment">// lock is released here</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h2><p>STL定义有五个全局函数，作用于未初始化空间上，这样的功能对于容器的实现很有帮助。前两个函数是用于构造的<code>construct()</code>和用于析构的<code>destroy()</code>，另三个函数是<code>uninitialized_copy()</code>，<code>uninitialized_fill()</code>，<code>uninitialized_fill_n</code>，分别对应于高层次函数<code>copy()</code>、<code>fill()</code>、<code>fill_n()</code>——这些都是STL算法。</p>
<h3 id="uninitialized-copy"><a href="#uninitialized-copy" class="headerlink" title="uninitialized_copy"></a>uninitialized_copy</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>,<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function">ForwardIterator <span class="title">uninitialized_copy</span><span class="params">(InputIterator first,InputIterator last,ForwardIterator result)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>uninitialized_copy()</code>使我们能够将内存的配置和对象的构造行为分离开来，如果作为输出目的地的<code>[result,result+(last-first))</code>范围内的每一个迭代器都指向为初始化区域，则<code>uninitialized_copy()</code>会使用copy constructor，给身为输入来源之<code>[first,last)</code>范围内的每一个对象产生一份复制品，放进输出范围中。换句话说，针对输入范围内的每一个迭代器i，该函数会调用<code>construct(&amp;*(result+(i-first)),*i)</code>，产生<code>*i</code>的复制品，放置于输出范围的相对位置上。</p>
<p>如果你需要实现一个容器，<code>uninitialized_copy()</code>这样的函数会为你带来很大的帮助，因为容器的全区间构造函数通常以两个步骤完成：</p>
<ul>
<li>配置内存块，足以包含范围内的所有元素</li>
<li>使用<code>uninitialized_copy()</code>，在该内存区块上构造元素。</li>
</ul>
<p>C++标志规格书要求<code>uninitialized_copy()</code>具有“commit or rollback”语意，意思是要么“构造出所有必要的元素”，要么（当有任何一个copy constructor失败时）“不构造任何东西。</p>
<h3 id="uninitialized-fill"><a href="#uninitialized-fill" class="headerlink" title="uninitialized_fill"></a>uninitialized_fill</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function">ForwardIterator <span class="title">uninitialized_fill</span><span class="params">(ForwardIterator first,ForwardIterator last,<span class="type">const</span> T&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>uninitialized_fill()</code>也能够使我们将内存配置与对象的构造行为分离开来。如果<code>[first,last)</code>范围内的每个迭代器都指向未初始化的内存，那么<code>uninitialized_fill()</code>会在该范围内产生x（上式第三个参数）的复制品。换句话说，<code>uninitialized_fill()</code>会针对操作范围内的每个迭代器<code>i</code>，调用<code>construct(&amp;*i,x)</code>，在i所指之处产生x的复制品。</p>
<p>与<code>uninitialized_copy()</code>一样，<code>uninitialized_fill()</code>必须具备“commit or rollback”语意，换句话说，它要么产生出所有必要元素，要么不产生任何元素，如果有任何一个copy constructor丢出异常（exception），<code>uninitialized_fill()</code>，必须能够将已产生的所有元素析构掉。</p>
<h3 id="uninitialized-fill-n"><a href="#uninitialized-fill-n" class="headerlink" title="uninitialized_fill_n"></a>uninitialized_fill_n</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>,<span class="keyword">class</span> <span class="title class_">Size</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function">ForwardIterator <span class="title">uninitialized_fill_n</span><span class="params">(ForwardIterator first,Size n,<span class="type">const</span> T&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>uninitialized_fill_n()</code>能使我们将内存配置与对象构造行为分离开来，它会为指定范围内的所有元素设定相同的初值。</p>
<p>如果<code>[first,first+n)</code>范围内的每一个迭代器都指向未初始化的内存，那么<code>uninitialized_fill_n()</code>会调用 copy constructor，在该范围内产生<code>x</code>（上式第三个参数——的复制品。也就是说，面对<code>[first,first+n)</code>范围内的每个迭代器<code>i</code>，<code>uninitialized_fill_n()</code>会调用<code>construct(&amp;*i,x)</code>，在对应位置产生x的复制品。</p>
<p><code>uninitialized_fill_n()</code>也具有“commit or rollback”语意：要么产生所有必要的元素，否则就不产生任何元素。如果任何一个copy constructor丢出异常（exception），<code>uninitialized_fill_n()</code>必须析构已产生的所有元素。</p>
<p>以下分别介绍这三个函数的实现法，其中所呈现的<code>iterators</code>（迭代器）、<code>value_type()</code>、<code>_type_traits</code>、<code>_true_type</code>、<code>_false_type</code>、<code>is_POD_type</code>等实现技术，都在后面介绍。</p>
<h4 id="uninitialized-fill-n-1"><a href="#uninitialized-fill-n-1" class="headerlink" title="uninitialized_fill_n()"></a>uninitialized_fill_n()</h4><p>本函数接受三个参数：</p>
<ul>
<li>迭代器first指向欲初始化空间的起始处；n表示欲初始化空间的大小；x表示初值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>,<span class="keyword">class</span> <span class="title class_">Size</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardInterator <span class="title">uninitialized_fill_n</span><span class="params">(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑是，首先萃取出迭代器first的value_type，然后判断是否是POD型别：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardInterator __uninitialized_fill_n(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, T1*) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, <span class="built_in">is_POD</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>POD意为Plain Old Data，也就是标量型别，或传统的C struct型别，可以用最有效率的初值填写手法，而对non_POD型别采取最保险的做法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果copy construction等同于assignment，而且destructor是trivial，以下就有效</span></span><br><span class="line"><span class="comment">// 如果是POD型别，执行流程就会转进到以下函数，这借由function template的参数推导机制而得</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>,<span class="keyword">class</span> <span class="title class_">Size</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardInterator __uninitialized_fill_n_aux(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, __true_type) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fill_n</span>(first, n, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不是POD型别，就会转进到以下函数，这借由function template的参数推导机制而得</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>,<span class="keyword">class</span> <span class="title class_">Size</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardInterator __uninitialized_fill_n_aux(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, __false_type) &#123;</span><br><span class="line">    ForwardIterator cur = first;</span><br><span class="line">    <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; --n, ++ cur)</span><br><span class="line">        <span class="built_in">construct</span>(&amp;*cur, x);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="uninitialized-copy-1"><a href="#uninitialized-copy-1" class="headerlink" title="uninitialized_copy()"></a>uninitialized_copy()</h4><p><code>uninitialized_copy()</code>接受三个函数：</p>
<ul>
<li>迭代器first指向输入端的起始位置</li>
<li>迭代器last指向输入端的结束位置</li>
<li>迭代器rsult指向输出端（欲初始化空间）的起始处</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardInterator <span class="title">uninitialized_copy</span><span class="params">(InputIterator first, InputIterator last, ForwardIterator result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_copy(first, last, result, <span class="built_in">value_type</span>(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑是，首先萃取出迭代器result的value_type，然后判断是否是POD型别：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardInterator __uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result, T*) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::is_POD_type is_POD;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_copy_aux(first, last, result, <span class="built_in">is_POD</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>POD可以用最有效率的初值填写手法，而对non_POD型别采取最保险的做法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果copy construction等同于assignment，而且destructor是trivial，以下就有效</span></span><br><span class="line"><span class="comment">// 如果是POD型别，执行流程就会转进到以下函数，这借由function template的参数推导机制而得</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardInterator __uninitialized_copy_aux(InputIterator first, InputIterator last, ForwardIterator result, __true_type) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">copy</span>(first, last, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不是POD型别，就会转进到以下函数，这借由function template的参数推导机制而得</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line">ForwardInterator __uninitialized_copy_aux(InputIterator first, InputIterator last, ForwardIterator result, __false_type) &#123;</span><br><span class="line">    ForwardIterator cur = first;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++ first, ++ cur)</span><br><span class="line">        <span class="built_in">construct</span>(&amp;*cur, *first);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>针对<code>char*</code>和<code>wchar_t*</code>两种型别，可以采用最具效率的做法<code>memmove</code>执行复制行为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">uninitialized_copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* first, <span class="type">const</span> <span class="type">char</span>* last, <span class="type">char</span>* result)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memmove</span>(rseult, first, last-first);</span><br><span class="line">    <span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">wchar_t</span>* <span class="title">uninitialized_copy</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* first, <span class="type">const</span> <span class="type">wchar_t</span>* last, <span class="type">wchar_t</span>* result)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memmove</span>(rseult, first, <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * (last-first));</span><br><span class="line">    <span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="uninitialized-fill-n-2"><a href="#uninitialized-fill-n-2" class="headerlink" title="uninitialized_fill_n()"></a>uninitialized_fill_n()</h4><p>本函数接受三个参数：</p>
<ul>
<li>迭代器first指向欲初始化空间的起始处；</li>
<li>迭代器last指向输出端的结束处；</li>
<li>x表示初值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">uninitialized_fill</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    __uninitialized_fill(first, last, x, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑是，首先萃取出迭代器first的value_type，然后判断是否是POD型别：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __uninitialized_fill(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x, T1*) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_fill_aux(first, last, x, <span class="built_in">is_POD</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>POD意为Plain Old Data，也就是标量型别，或传统的C struct型别，可以用最有效率的初值填写手法，而对non_POD型别采取最保险的做法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果copy construction等同于assignment，而且destructor是trivial，以下就有效</span></span><br><span class="line"><span class="comment">// 如果是POD型别，执行流程就会转进到以下函数，这借由function template的参数推导机制而得</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x, __true_type) &#123;</span><br><span class="line">    <span class="built_in">fill</span>(first, last, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不是POD型别，就会转进到以下函数，这借由function template的参数推导机制而得</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>,<span class="keyword">class</span> <span class="title class_">Size</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x, __false_type) &#123;</span><br><span class="line">    ForwardIterator cur = first;</span><br><span class="line">    <span class="keyword">for</span> (; cur != last; ++ cur)</span><br><span class="line">        <span class="built_in">construct</span>(&amp;*cur, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20180524164335567.png" alt=""></p>
<h1 id="迭代器概念与traits编程技法"><a href="#迭代器概念与traits编程技法" class="headerlink" title="迭代器概念与traits编程技法"></a>迭代器概念与traits编程技法</h1><p>迭代器是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。</p>
<h2 id="迭代器设计思维——STL关键所在"><a href="#迭代器设计思维——STL关键所在" class="headerlink" title="迭代器设计思维——STL关键所在"></a>迭代器设计思维——STL关键所在</h2><p>不论是泛型思维或STL的实际运用，迭代器都扮演这重要的角色。STL的中心思想在于：将数据容器和算法分开，彼此独立设计，最后再以一贴胶着剂将它们撮合在一起。容器和算法的泛型化，从技术的角度来看是并不困难，C++的class template和function templates可分别达成目标。</p>
<p>以下是容器、算法、迭代器的合作展示，以算法<code>find()</code>为例，它接受两个迭代器和一个“搜索目标”：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(first=!last&amp;&amp;*first!=value)</span><br><span class="line">       ++first;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>只要给出不同的迭代器，<code>find()</code>便能够对不同的容器进行直接操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> arraySize=<span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> ia[arraySize]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivect</span><span class="params">(ia,ia+arraySize)</span></span>;</span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">ilist</span><span class="params">(ia,ia+arraySize)</span></span>;</span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">ideque</span><span class="params">(ia,ia+arraySize)</span></span>;</span><br><span class="line">    <span class="comment">//注意算法和成员方法的区别</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it1=<span class="built_in">find</span>(ivect.<span class="built_in">begin</span>(),ivect.<span class="built_in">end</span>(),<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(it1!=ivect.<span class="built_in">end</span>())</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;4 found. &quot;</span>&lt;&lt;*it1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;4 not found.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it2=<span class="built_in">find</span>(ilist.<span class="built_in">begin</span>(),ilist.<span class="built_in">end</span>(),<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(it2==ilist.<span class="built_in">end</span>())</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;6 not found. &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;6 found. &quot;</span>&lt;&lt;*it2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;::iterator it3=<span class="built_in">find</span>(ideque.<span class="built_in">begin</span>(),ideque.<span class="built_in">end</span>(),<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(it3==ideque.<span class="built_in">end</span>())</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;8 not found.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;8 found. &quot;</span>&lt;&lt;*it3&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从上面的例子看来，迭代器似乎依附于在容器之下，是吗？有没有独立而泛用的迭代器？我们又该如何自行设计特殊的迭代器？</p>
<h2 id="迭代器是一种smart-pointer"><a href="#迭代器是一种smart-pointer" class="headerlink" title="迭代器是一种smart pointer"></a>迭代器是一种smart pointer</h2><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见也最重要的便是内容提领（dereference）和成员访问（member access），因此，迭代器最重要的编程工作就是对<code>operator*</code>和<code>operator-&gt;</code>进行重载工作。关于这一点，C++标准库有一个<code>auto_ptr</code>可供我们参考。这是一个用来包含原生指针的对象，声名狼藉的内存泄露问题可借此获得解决。<code>auto_ptr</code>用法如下，和原生指针一模一样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;jjhou&quot;</span>))</span></span>;</span><br><span class="line">    cout&lt;&lt;*ps&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ps-&gt;<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"><span class="comment">//离开前不需要delete，auto_ptr会自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数第一行的意思是，以<code>new</code>动态配置一个初值为”jjhou”的string对象，并将所得的结果（一个原生指针）作为<code>auto_ptr&lt;string&gt;</code>对象的初值。注意，<code>auto_ptr</code>尖括号内放的是”原生指针所指对象“的型别，而不是原生指针的型别。</p>
<p><code>auto_ptr</code>的源代码在头文件<code>&lt;memory&gt;</code>中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:autoptr.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(T *p=<span class="number">0</span>)</span>:pointee(p) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">auto_ptr</span><span class="params">(auto_ptr&lt;U&gt;&amp; rhs)</span>:pointee(rhs.release()) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123;<span class="keyword">delete</span> pointee;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">    auto_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(auto_ptr&lt;U&gt; &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>!=rhs) <span class="built_in">reset</span>(ths.<span class="built_in">release</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *pointee;&#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> pointee;&#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> pointee;&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>有了模仿对象，现在我们来为list（链表）设计一个迭代器，假设list及其节点的结构如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListItem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ListItem</span>(T value):_value(value), _next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNext</span><span class="params">(ListItem&lt;T&gt; *newNode)</span> </span>&#123;</span><br><span class="line">        _next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListItem* <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _value;</span><br><span class="line">    ListItem* _next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单链表类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">List</span>():_size(<span class="number">0</span>) &#123;</span><br><span class="line">        _front = _end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_front</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        ListItem&lt;T&gt; *newNode = <span class="keyword">new</span> <span class="built_in">ListItem</span>&lt;T&gt;(value);</span><br><span class="line">        <span class="keyword">if</span>(_size == <span class="number">0</span>) &#123;</span><br><span class="line">            _end = _front = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode -&gt; <span class="built_in">setNext</span>(_front);</span><br><span class="line">            _front = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_end</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        ListItem&lt;T&gt; *newNode = <span class="keyword">new</span> <span class="built_in">ListItem</span>&lt;T&gt;(value);</span><br><span class="line">        <span class="keyword">if</span>(_size == <span class="number">0</span>) &#123;</span><br><span class="line">            _end = _front = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            _end -&gt; <span class="built_in">setNext</span>(newNode);</span><br><span class="line">            _end = _end -&gt; <span class="built_in">getNext</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListItem&lt;T&gt;* temp = _front;</span><br><span class="line">        <span class="keyword">while</span>(temp != _end -&gt; <span class="built_in">getNext</span>()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp -&gt; <span class="built_in">value</span>());</span><br><span class="line">            temp = temp -&gt; <span class="built_in">getNext</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, _size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListItem&lt;T&gt;*<span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListItem&lt;T&gt;*<span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _end;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListItem&lt;T&gt;* _end;</span><br><span class="line">    ListItem&lt;T&gt;* _front;</span><br><span class="line">    <span class="type">long</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//迭代器类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListIter</span></span><br><span class="line">&#123;</span><br><span class="line">    Item* ptr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ListIter</span>(Item* p = <span class="number">0</span>):<span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    Item&amp; <span class="keyword">operator</span>* () <span class="type">const</span> &#123;<span class="keyword">return</span> *ptr;&#125;</span><br><span class="line">    Item* <span class="keyword">operator</span> -&gt; () <span class="type">const</span> &#123;<span class="keyword">return</span> ptr;&#125;</span><br><span class="line">    </span><br><span class="line">    ListIter&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ptr = ptr -&gt; <span class="built_in">getNext</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListIter <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        ListIter tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ListIter&amp; i)<span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr == i.ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ListIter&amp; i)<span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr != i.ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">find</span>(ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; &amp;begin, ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; &amp;end, <span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; first = begin;</span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; last = end;</span><br><span class="line">    <span class="keyword">while</span>( first != last -&gt; <span class="built_in">getNext</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(first -&gt; <span class="built_in">value</span>() != value)</span><br><span class="line">        &#123;</span><br><span class="line">            first++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end -&gt; <span class="built_in">getNext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并且加上测试程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;<span class="type">int</span>&gt; m_ListItor;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ListItor.<span class="built_in">insert_front</span>(i);</span><br><span class="line">        m_ListItor.<span class="built_in">insert_end</span>(i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m_ListItor.<span class="built_in">display</span>();        <span class="comment">//5 4 3 2 1 0 2 3 4 5 6 7</span></span><br><span class="line">    </span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">begin</span>(m_ListItor.<span class="built_in">front</span>());</span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">end</span>(m_ListItor.<span class="built_in">back</span>());</span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; iter;</span><br><span class="line">    </span><br><span class="line">    iter = <span class="built_in">find</span>(begin, end, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(iter == end -&gt; <span class="built_in">getNext</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, iter -&gt; <span class="built_in">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    iter = <span class="built_in">find</span>(begin, end, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(iter == end -&gt; <span class="built_in">getNext</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, iter -&gt; <span class="built_in">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上可以看出，为了完成一个针对List而设计的迭代器，我们必须暴露太多有关于<code>List</code>实现细节，在<code>main</code>函数中制作<code>begin()</code>和<code>end()</code>两个迭代器，我们暴露了<code>ListItem</code>，在<code>ListIter class</code>中为了达成operator++，我们暴露了<code>ListItem</code>的操作函数<code>getNext()</code>，如果不是为了迭代器，<code>ListItem</code>是要完全隐藏起来不曝光的。换句话说只有对<code>ListItem</code>的实现细节特别了解，才能设计出迭代器，既然这无法避免，干脆把迭代器的设计工作交给 List 的设计者，如此一来，所有实现细节反而不被使用者发现，这也是为什么 STL 的每一种容器都有自己专属的迭代器的原因。</p>
<h2 id="迭代器相应型别"><a href="#迭代器相应型别" class="headerlink" title="迭代器相应型别"></a>迭代器相应型别</h2><p>在算法运用迭代器的时候，很可能用到起相应型别（即迭代器所指之物的型别），但C++支持sizeof ，并无typeof。<strong>可以利用function template的参数推导机制</strong>。</p>
<ol>
<li>函数参数的情况<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_impl</span><span class="params">(I iter,T t)</span></span>&#123;</span><br><span class="line">    T tmp;<span class="comment">//这里解决了问题，T就是迭代器所指之物的类型</span></span><br><span class="line">　　<span class="comment">//…………</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(I iter)</span></span>&#123;</span><br><span class="line">    <span class="built_in">func_impl</span>(iter,*iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">func</span>(&amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们以<code>func()</code>为对外接口，却把实际操作全部置于<code>func_impl()</code>之中。由于<code>func_impl()</code>是一个function template，一旦被调用，编译器会自动进行template参数推导，于是导出型别，顺利解决了问题。迭代器相应型别(associated types)不只是“迭代器所指对象的型别”一种而已。根据经验，最常用的相应型别有五种，然而并非任何情况下任何一种都可利用上述的template参数推导机制来取得，我们需要更全面的解法。</p>
<h2 id="Traits编程技法——STL源代码门钥"><a href="#Traits编程技法——STL源代码门钥" class="headerlink" title="Traits编程技法——STL源代码门钥"></a>Traits编程技法——STL源代码门钥</h2><p>迭代器所指对象的型别，称为该迭代器的value type，上述的参数型别推导技巧虽然可用于value，却非全面可用：万一value type必须用于函数的传回值，就束手无策了，毕竟函数的”template参数推导机制”推而导之的只是参数，无法推导函数的返回值类型。</p>
<p>声明内嵌类型是个好主意：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    T* ptr;</span><br><span class="line">    <span class="built_in">MyIter</span>(T* p=<span class="number">0</span>):<span class="built_in">ptr</span>(p)&#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> I::value_type<span class="comment">//I::value_type编译器不知道代表一个型别或是一个成员函数或是一个数据成员，关键词typename用以告诉编译器这是一个型别</span></span><br><span class="line"><span class="built_in">func</span>(I ite)&#123;</span><br><span class="line">    <span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">MyIter&lt;<span class="type">int</span>&gt; <span class="title">ite</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">8</span>))</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">func</span>(ite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>func()</code>的返回类型必须加上关键词，因为是一个template参数，在它被编译器具现化之前，编译器对此一无所悉，换句话说，编译器此时并不知道<code>MyIter&lt;T&gt;::value_type</code>代表的是一个型别或是一个member function或是一个data member。关键词的用意在于告诉编译器这是一个型别，如此才能顺利通过编译。但是并不是所有迭代器都是class，原生指针就不是，如果不是就无法为它定义内嵌型别，但STL（以及整个泛型思维）绝对必须接受原生指针作为一种迭代器，所以上面这样还不够。template partial speciahzation可以做到。</p>
<h3 id="Partial-Specialization（偏特化）的意义"><a href="#Partial-Specialization（偏特化）的意义" class="headerlink" title="Partial Specialization（偏特化）的意义"></a>Partial Specialization（偏特化）的意义</h3><p>如果class template 拥有一个以上的template参数，我们可以针对其中某个（或数个，但非全部）template参数进行特化工作。换句话说，我们可以在泛化设计中提供一个特化版本（也就是将泛化版本中的某些template参数赋予明确的指定）。例如，面对以下这么一个class template：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; ... &#125;; <span class="comment">// 这个泛化版本允许接受T为任何类型</span></span><br></pre></td></tr></table></figure></p>
<p>我们便很容易接受它有一个形式如下的partial specialization<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T* &#123; ... &#125;; <span class="comment">// 这个泛化版本允许接受T为原生指针的情况</span></span><br></pre></td></tr></table></figure></p>
<p>有了这项利器，我们便可以解决前述“内嵌型别”未能解决的问题。先前的问题是，原生指针并非class，因此无法为它们定义内嵌型别。现在，我们可以针对“迭代器之template参数为指针”者，设计特别版的迭代器。</p>
<p>下面这个class template专门用来“萃取”迭代器的特性，而value type正是迭代器的特性之一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span>	<span class="title class_">iterator_traits</span><span class="comment">//traits 意为“特性”</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::vlue_type value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个所谓的traits，其意义是，如果I定义自己的value type，那么通过这个traits的作用，萃取出来的value_type就是<code>I::value_type</code>。换句话说，如果I定义有自己的value type ，那个<code>func()</code>可以改写成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iteraotr_traits&lt;T&gt;::value_type<span class="comment">//这一整行是函数返回值</span></span><br><span class="line">	<span class="built_in">func</span>(T ite)</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但这除了多了一层间接性，好处是traits可以拥有特化版本。现在，我们令<code>iterator_traites</code>拥有一个partial specializations如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>于是，原生指针<code>int*</code>虽然不是一种class type ，亦可通过traits取其value type。这就解决了先前的问题。但是注意针对“指向常数对象的指针（pointer-to-const）”，下面这个式子得到什么结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator_traits&lt;<span class="type">const</span> <span class="type">int</span>*&gt;::value_type</span><br></pre></td></tr></table></figure><br>获得的是const int而非int。我们希望利用这种机制来声明一个暂时变量，使其型别与迭代器的value type相同，而现在，声明一个无法复制的暂时变量，没什么用！因此，如果迭代器是一个pointer-to-const，我们应该设法令其value type为一个non-const型别。只需要另外设计一个特化版本就可以解决问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;&#123;<span class="comment">//偏特化版—当迭代器是一个pointer-to-const</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;<span class="comment">//萃取出来的型别应该是T，而非const T</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>现在，不论面对的是迭代器MyIter，或是原生指针<code>*int</code>或<code>const int*</code>，都可以通过traits取出正确的（我们所期望的）value type。</p>
<p>下图说明了traits所扮演的“特性萃取机”角色，萃取各个迭代器的特性。这里所谓的迭代器特性，指的是迭代器的相应型别。当然，若要这个“特性萃取机”traits嫩够有效运作，每一个迭代器必须遵守约定，自行以内嵌型别定义的方式定义出相应型别。这是一个约定，谁不遵守约定，谁就不能兼容STL这个大家庭。<br><img src="/img/1608959630.png" alt=""></p>
<p>根据经验，最常用到的迭代器相应型别有五种：<code>value type</code>，<code>difference type</code>，<code>pointer</code>，<code>reference</code>，iterator categoly<code>。如果你希望你所开发的容器能与STL水乳交融，一定要为你的容器的迭代器定义这五种相应型别。“特性萃取机”traits会很忠实地将其原汁原味榨取出来：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temp1ate &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">itarator_traits</span> &#123; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference; </span><br></pre></td></tr></table></figure></code>iterator_traits`必须针对传入的型别为pointer及pointer-to-const者，设计特化版本，稍后数节为你展示如何进行。</p>
<h3 id="迭代器相应型别之一：value-type"><a href="#迭代器相应型别之一：value-type" class="headerlink" title="迭代器相应型别之一：value type"></a>迭代器相应型别之一：value type</h3><p>所谓value type，是指<strong>迭代器所指对象的型别</strong>。任何一个打算与STL算法有完美搭配的class，都应该定义自己的value type内嵌型别，例如STL中的vector定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// nested type 定义</span></span><br><span class="line">  <span class="keyword">typedef</span> T                 value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type*       pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type*       iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp;       reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span>         s  ize_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>         difference_type;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="迭代器相应型别之二：difference-type"><a href="#迭代器相应型别之二：difference-type" class="headerlink" title="迭代器相应型别之二：difference type"></a>迭代器相应型别之二：difference type</h3><p>difference type用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。如果一个泛型算法提供计数功能，例如STL的<code>count()</code>，其传回值就必须使用迭代器的diference type：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">count</span> <span class="params">(I first, I last, <span class="type">const</span> T&amp; value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;first!=last;++first)</span><br><span class="line">        <span class="keyword">if</span>(*first == value)</span><br><span class="line">            ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>针对相应型别difference type，traits的如下两个特化版本，以C++内建的<code>ptrdiff_L</code>作为原生指针的difference type：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对原生指针偏特化版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> ptrdiff_L difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对原生的pointer-to-const设计的偏特化版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>现在，任何时候我们需要任何迭代器I的difference type，可以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type;</span><br></pre></td></tr></table></figure></p>
<h3 id="迭代器相应型别之三：reference-type"><a href="#迭代器相应型别之三：reference-type" class="headerlink" title="迭代器相应型别之三：reference type"></a>迭代器相应型别之三：reference type</h3><p>从“迭代器所指之物的内容是否允许改变”的角度观之，迭代器分为两种：<strong>不允许改变“所指对象之内容”者</strong>，称为constant iterators，例如<code>const int* pic</code>；<strong>允许改变“所指对象之内容”者</strong>，称为 mutable iterators，例如<code>int* pi</code>。 当我们对一个 mutable iterators做解引用时，获得的应该是个左值（lvalue） ,可以被赋值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pci = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">9</span>);</span><br><span class="line">*pi = <span class="number">7</span>;  <span class="comment">// 对mutable iterator及逆行操作，获得的是左值，允许赋值</span></span><br><span class="line">*pci = <span class="number">1</span>; <span class="comment">// 这个操作不被允许，pci是constant iterator，提领pci所得结果是个右值，不能赋值。</span></span><br></pre></td></tr></table></figure></p>
<p>在 C++中，<strong>函数如果要返回左值，都是以by reference的方式进行</strong>，所以当p是个mutable iterators时，如果其value type是T，那么<code>*p</code>的型别不应该是T，应该是<code>T&amp;</code>。将此道理扩充，如果p是一个 constant iterators，其value type是 T，那么<code>*p</code>的型别不应该是const T，而应该是<code>const T&amp;</code>。<code>*p</code>的型别，即所谓的reference type。 </p>
<h3 id="迭代器相应型别之四：pointer-type"><a href="#迭代器相应型别之四：pointer-type" class="headerlink" title="迭代器相应型别之四：pointer type"></a>迭代器相应型别之四：pointer type</h3><p>pointers和 references 在C++中有非常密切的关连。 如果“传回一个左值，令它代表p所指之物”是可能的，那么“传回一个左值，令它代表p所指之物的位址”也一定可以。 我们能够传回一个 pointer，指向迭代器所指之物。 </p>
<p>这些相应型别已在先前的ListIter class中出现过：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Item&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">Item* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125;</span><br></pre></td></tr></table></figure><br><code>Item&amp;</code>便是ListIter的reference type而<code>Item*</code>便是其pointer type。</p>
<p>现在把reference type和pointer type这两个相应型别加入traits内：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer   pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对原生指针偏特化版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对原生的pointer-to-const设计的偏特化版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="迭代器相应型别之五：iterator-category"><a href="#迭代器相应型别之五：iterator-category" class="headerlink" title="迭代器相应型别之五：iterator_category"></a>迭代器相应型别之五：iterator_category</h3><p>最后一个（第五个）迭代器的相应型别会引发较大规模的写代码工程。在那之前，我必须先讨论迭代器的分类。</p>
<p>根据移动特性与施行操作，迭代器被分为五类：</p>
<ul>
<li>Input lterator：这种迭代器所指的对象，不允许外界改变。只读（read only）。</li>
<li>Output terator：唯写（write only）。</li>
<li>Forward lterator：允许“写入型”算法（例如<code>replace()</code>）在此种迭代器所形成的区间上进行读写操作。</li>
<li>Bidirectiona lterator：可双向移动。某些算法需要逆向走访某个迭代器区间（例如逆向拷贝某范围内的元素），可以使用Biairectional lterators。</li>
<li>Random Access lterator：前四种迭代器都只供应一部分指针算术能力（前三种支持<code>operator++</code>，第四种再加上<code>operator--</code>），第五种则涵盖所有指针算术能力，包括<code>p+n</code>，<code>p-n</code>，<code>p[n]</code>，<code>p1-p2</code>，<code>p1&lt;p2</code>。</li>
</ul>
<p>迭代器的分类与从属关系如下图所示：<br><img src="/img/1609574454.png" alt=""></p>
<p>设计算法时，如果可能，我们尽量针对上图中某种迭代器提供一个明确定义，并针对更强化的某种迭代器提供另一定义，这样才能在不同情况下提供最大效率。假设有个算法接受 Forward Iterator，你以 Random Access Iterator 喂给它，也可用，但是可用不一定最佳。</p>
<p>下面以<code>advanced()</code>函数为例，介绍各类迭代器的性能差异。该函数有两个参数，迭代器p和数值n，函数内部将p累进n次，下面有三个定义，一个针对Input iterator，一个针对Bidirectional iterator，另一个针对Random Access iterator。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> Distance&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advanced_II</span><span class="params">(InputIterator&amp; i, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//单向 逐一前进</span></span><br><span class="line">	<span class="keyword">while</span>(n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterator, <span class="keyword">class</span> Distance&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advanced_BI</span><span class="params">(BidirectionalIterator&amp; i, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//双向 逐一前进</span></span><br><span class="line">	<span class="keyword">if</span>(n&gt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">while</span>(n--) ++i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">while</span>(n++) --i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomAccessIterator, <span class="keyword">class</span> Distance&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advanced_RAI</span><span class="params">(RandomAccessIterator&amp; i,Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//双向 跳跃前进</span></span><br><span class="line">	i += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当程序调用<code>advance()</code>时，应该调用哪一份函数定义呢？通常会将三者合一，下面是一种做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advanced</span><span class="params">(InputIterator&amp; i, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_random_access_iterator</span>(i))<span class="comment">//有待设计</span></span><br><span class="line">        <span class="built_in">advanced_RAI</span>(i,n);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">is_bidirectional_iterator</span>(i))<span class="comment">//有待设计</span></span><br><span class="line">        <span class="built_in">advanced_BI</span>(i,n);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">advanced_II</span>(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是上述处理方式，会在程序执行期间才能决定使用哪个处理函数，影响程序效率。最好能够在编译期就选择正确的版本，重载函数机制可以实现该目标。我们可以给<code>advanced()</code>添加第三个参数，即“迭代器类型”这个参数，然后利用traits萃取出迭代器的种类。下面五个classes，即代表五种迭代器类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure><br>这些classes只作为标记用，所以不需要任何成员。重新设计<code>__advance()</code>，然后利用第三参数重新定义上面的<code>advance()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advanced(InputIterator&amp; i, Distance n, input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//单向 逐一前进</span></span><br><span class="line">	<span class="keyword">while</span>(n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这是一个单纯的传递调用参数（triv forwarding function） 稍后讨论如何免除之</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advanced(ForwardIterator&amp; i, Distance n, forward_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//单纯的进行传递调用</span></span><br><span class="line">	<span class="built_in">advance</span>(i,n,input_iterator_tag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advanced(BidirectionalIterator&amp; i, Distance n, bidirectional_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//双向 逐一前进</span></span><br><span class="line">	<span class="keyword">if</span>(n&gt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">while</span>(n--) ++i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">while</span>(n++) --i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advanced(RandomAccessIterator&amp; i, Distance n, random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//双向 跳跃前进</span></span><br><span class="line">	i += n;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对外开放的上层接口，调用上述各个重载的<code>__advance()</code>。这一上层接口只需两个参数，当它准备将工作转给上述的<code>__advance()</code>时，才自行加上第三参数：迭代器类型。因此，这个上层函数必须有能力从它所获得的迭代器中推导出其类型——这份工作自然交给traits机制：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> Distance&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advanced</span><span class="params">(InputIterator&amp; i, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__advance(i,n,iterator_traits&lt;InputIterator&gt;::<span class="built_in">iterator_categoty</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>iterator_traits&lt;InputIterator&gt;::iterator_categoty()</code>将产生一个临时对象，其类别应该为前述5个迭代器类型之一。根据这个类别编译器决定调用哪个<code>__advance()</code>重载函数。</p>
<p>任何一个迭代器，其类型永远应该落在“该迭代器所隶属之各种类型中”，最强化的那个。同时，STL算法命名规则：<strong>以算法所能接受之最低阶迭代器类型，来为其迭代器型别参数命名</strong>，因此<code>advance()</code>中template参数名称为<code>InputIterator</code>。</p>
<h4 id="消除“单纯传递调用的函数”"><a href="#消除“单纯传递调用的函数”" class="headerlink" title="消除“单纯传递调用的函数”"></a>消除“单纯传递调用的函数”</h4><p>由于各个迭代器之间存在着继承关系，“传递调用”的行为模式自然存在，即如果不重载Forward Iterators或BidirectionalIterator时，统统都会传递调用InputIterator版的函数。</p>
<h2 id="std-iterator的保证"><a href="#std-iterator的保证" class="headerlink" title="std::iterator的保证"></a>std::iterator的保证</h2><p>任何迭代器都应该提供五个内嵌相应类别，以利于traits萃取。STL提供了一个iteratots class如下，如果每个新设计的迭代器都继承自它，则可以保证符合STL规范（即需要提供五个迭代器相应的类型）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Category</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span> = <span class="type">ptrdiff_t</span>,</span><br><span class="line">          <span class="keyword">class</span> Pointer = T*, <span class="keyword">class</span> Reference = T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator &#123;</span><br><span class="line">  <span class="keyword">typedef</span> Category  iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T         value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Distance  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> Pointer   pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>iterator class 不含成员，纯粹只是类型定义，所以继承它不会造成任何负担。由于后三个参数都有默认值，新的迭代器只需提供前两个参数即可。</p>
<h2 id="SGI-STL的私房菜：-type-traits"><a href="#SGI-STL的私房菜：-type-traits" class="headerlink" title="SGI STL的私房菜：__type_traits"></a>SGI STL的私房菜：__type_traits</h2><p>traits编程技法很棒，适度弥补了 C++ 语言本身的不足。 STL只对迭代器加以规范，制定出<code>iterator_traits</code>这样的东西。 SGI 把这种技法进一步扩大到迭代器以外的世界，于是有了所谓的<code>__type_traits</code>。 </p>
<p><code>iterator_traits</code>负责萃取迭代器的特性， <code>__type_traits</code>则负责萃取型别（type）的特性。 型别特性是指：这个型别是否具备non-trivial defalt ctor ？是否具备 non-trivial copy ctor？是否具备 non-trivial assignment operator？是否具备 non-trivial dtor？如果答案是否定的，我们在对这个型别进行建构、解构、拷贝、赋值等动作时，就可以采用最有效率的措施，而采用内存直接处理动作如<code>malloc()</code>、<code>memcpy()</code>等等，获得最高效率。这对于大规模而动作频繁的容器，有着显著的效率提升！</p>
<p><code>type_traits</code>提供了一种机制，允许针对不同的型别属性，在编译时期完成函数派送决定，如果我们事先知道是否有trivial copy constructor，便能够帮助我们确定是否可以使用<code>memcpy()</code>或<code>memmove()</code>。</p>
<p>根据<code>iterator_traits</code>得来的经验，我们希望程序中可以这样运用<code>__type_traits&lt;T&gt;</code>，<code>T</code>代表任意型别：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__type_traits&lt;T&gt;::has_trivial_default_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_copy_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_assignment_operator</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_destructor</span><br><span class="line">__type_traits&lt;T&gt;::is_POD_type</span><br></pre></td></tr></table></figure><br>上述式子应该传回：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__true_type</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__false_type</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><br>利用其响应结果进行类型推断。</p>
<p>为了达成上述五个式子，<code>__type_traits</code>应该定义一些<code>typedefs</code>，其值不是<code>_true_type</code>就是<code>_false_type</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span> &#123; </span><br><span class="line">   <span class="keyword">typedef</span> __true_type     this_dummy_member_must_be_first;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>SGI把所有内嵌型别都定义为<code>_false_type</code>为了定义出最保守的值，然后再针对每一个标量型别（scalar types)设计适当的<code>_type_traits</code>特化版本，这样就解决了问题。上述<code>_type_traits</code>可以接受任何型别的参数，五个typedefs将经由以下管道获得实值：</p>
<ul>
<li>一般具现体（gerera1 instantiation），内含对所有型别都必定有效的保守值。上述各个has_trivial_xxx型别都被定义为<code>_false_type</code>，就是对所有型别都必定有效的保守值。</li>
<li>经过声明的特化版本，例如<code>&lt;type_traits.h&gt;</code>内对所有C++标量型别（scalar types）提供了对应的特化声明。稍后展示</li>
<li>某些编译器会自动为所有型别提供适当的特化版本</li>
</ul>
<p>以下是<code>&lt;type_traits.h&gt;</code>对所有C++标量类型所定义的<code>__type_traits</code>特化版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">char</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 上述还有针对其他数据类型的定义</span></span><br><span class="line"><span class="comment">// 以下针对原生指针设计__type_traits偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;T*&gt; &#123;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>前面第二章提到过的<code>uninitialized_fill_n</code>等函数就在实现中使用了<code>__type_traits</code>机制。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n,</span><br><span class="line">                                              <span class="type">const</span> T&amp; x) &#123;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, <span class="built_in">vaule_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数以x为蓝本，自迭代器first开始构造n个元素，首先以<code>value_type()</code>萃取出迭代器first的value_type，再利用<code>__type_traits</code>判断该类型是否为POD类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n,</span><br><span class="line">                                              <span class="type">const</span> T&amp; x, T1*) &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, <span class="built_in">is_POD</span>());</span><br><span class="line">                                    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不是POD型别 就会派送（dispatch）到这里</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ForwardIterator</span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n,</span><br><span class="line">                           <span class="type">const</span> T&amp; x, __false_type) &#123;</span><br><span class="line">  ForwardIterator cur = first;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++cur)</span><br><span class="line">      <span class="built_in">construct</span>(&amp;*cur, x);<span class="comment">//需要逐个进行构造</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是POD型别 就会派送到这里 下两行是源文件所附注解</span></span><br><span class="line"><span class="comment">//如果copy construction 等同于 assignment 而且有 trivival destructor</span></span><br><span class="line"><span class="comment">//以下就有效</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator</span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n,</span><br><span class="line">                           <span class="type">const</span> T&amp; x, __true_type) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fill_n</span>(first, n, x);	<span class="comment">//交由高阶函数执行 </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//以下定义于&lt;stl_algobase.h&gt;中的fill_n()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">OutputIter</span>, <span class="keyword">class</span> <span class="title class_">_Size</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function">OutputIter <span class="title">fill_n</span><span class="params">(OutputIter first, Size n, <span class="type">const</span> Tp&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++first)</span><br><span class="line">    *first = value;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个例子是<code>copy()</code>全局函数（泛型算法之一〕，这个函数有非常多的特化〔specialization）与强化（refinement）版本。最基本的想法是这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝一个数组，其元素为任意型别，视情况采用最有效率的拷贝手段 </span></span><br><span class="line"><span class="keyword">template</span> &lt;c1ass T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">copy</span><span class="params">(T* source, T* destination, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">copy</span>(source, destination, n, <span class="keyword">typename</span> __type_traits&lt;T&gt;:::<span class="built_in">has_trivial_copy_constructor</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝一个数组，其元素型别拥有non-trivial copy constructors</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(T* source, T* destination, <span class="type">int</span> n, __false_type)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// 拷贝一个数组，其元素型别拥有trivial copy constructors</span></span><br><span class="line"><span class="comment">// 可借助memcpy()完成工作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(T* source, T* destination, <span class="type">int</span> n, __true_type)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上只是针对“函数参数为原生指针”的情况而做的设计。</p>
<p>如果你是SGI STL的用户，你可以在自己的程序中充分运用这个<code>__type_traits</code>，假设我自行定义了一个shape c1ass，<code>__type_traits</code>会对它产生什么效应呢？如果编译器够厉害，<code>__type_traits</code>针对shape萃取出来的每一个特性，其结果将取决于我的Shape是否有trivial default ctor，或triviai copy ctor，或trivial assignment operator, 或trivial dtor而定。但对大部分缺乏这种特异功能的编译器而言，<strong>type_traits针对Shape萃取出来的每一个特性都是`</strong>false_type<code>，即使shape是个POD型别。这样的结果当然过于保守、但是别无选择，除非我针对shape,自行设计一个</code>__type_traits`特化版本，明白地告诉编译器以下事实（举例）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;Shape&gt; &#123; </span><br><span class="line">   <span class="keyword">typedef</span> __true_type     has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一个简单的判断标准是，如果class内含指针成员，并且对它进行动态内存配置，那么这个class就要实现出自己的non-trival-xxx。</p>
<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="容器的概观与分类"><a href="#容器的概观与分类" class="headerlink" title="容器的概观与分类"></a>容器的概观与分类</h2><p>容器，置物之所也。研究数据的特定排列方式，以利于搜寻或排序或其他特殊目的，这一专门学科称为数据结构。几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。</p>
<p>SGI STL的各个容器（本图以内缩方式来表达基层与衍生层的关系）。<br><img src="1609581571.jpg" alt=""></p>
<p>这里所谓的<strong>衍生</strong>，并非派生关系，而是内含关系。例如，heap内含一个vector，priority-queue内含一个heap，stack和queue都内含一个deque，set/map/multiset/multimap都内含一个RB-tree，hash_set/hash_map/hash_multiset/hash_multimap都内含一个hashtabe。</p>
<h2 id="vector概述"><a href="#vector概述" class="headerlink" title="vector概述"></a>vector概述</h2><p>vector的数据安排以及操作方式，与array非常相似。两者的唯一差别在于空间的运用的灵活性。array是静态空间，一旦配置了就不能改变；vector的动态空间 ，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。vector的实现技术，关键在于对其大小的控制以及重新配置时的数据移动效率。</p>
<p>vector的内部定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator; <span class="comment">// SGI STL 空间配置器接口</span></span><br><span class="line">  iterator start;               <span class="comment">// 表示目前使用空间的头</span></span><br><span class="line">  iterator finish;              <span class="comment">// 表示目前使用空间的尾</span></span><br><span class="line">  iterator end_of_storage;      <span class="comment">// 表示目前可用空间的尾</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert_aux</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;           <span class="comment">// 释放空间</span></span><br><span class="line">    <span class="keyword">if</span> (start) data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage - start);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    start = <span class="built_in">allocate_and_fill</span>(n, value);</span><br><span class="line">    finish = start + n;</span><br><span class="line">    end_of_storage = finish;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 各种迭代器</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// size、max_size、capacity、empty</span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>) / <span class="built_in">sizeof</span>(T); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">  <span class="comment">// 重载 []</span></span><br><span class="line">  reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125;</span><br><span class="line">  const_reference <span class="keyword">operator</span>[](size_type n) <span class="type">const</span> &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 构造函数，大都调用 fill_initialize</span></span><br><span class="line">  <span class="built_in">vector</span>() : <span class="built_in">start</span>(<span class="number">0</span>), <span class="built_in">finish</span>(<span class="number">0</span>), <span class="built_in">end_of_storage</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">vector</span>(size_type n, <span class="type">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line">  <span class="built_in">vector</span>(<span class="type">int</span> n, <span class="type">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line">  <span class="built_in">vector</span>(<span class="type">long</span> n, <span class="type">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123; <span class="built_in">fill_initialize</span>(n, <span class="built_in">T</span>()); &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">vector</span>() &#123; </span><br><span class="line">    <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">    <span class="built_in">deallocate</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 首尾元素</span></span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(finish, x);</span><br><span class="line">      ++finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 插入操作</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    size_type n = position - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage &amp;&amp; position == <span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(finish, x);</span><br><span class="line">      ++finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>() + n;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 删除最尾端元素</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    --finish;</span><br><span class="line">    <span class="built_in">destroy</span>(finish);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//清除某位置上的元素</span></span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position + <span class="number">1</span> != <span class="built_in">end</span>())</span><br><span class="line">      <span class="built_in">copy</span>(position + <span class="number">1</span>, finish, position); <span class="comment">// 后续元素往前移动</span></span><br><span class="line">    --finish;</span><br><span class="line">    <span class="built_in">destroy</span>(finish);</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 清除迭代器所指定的区间的元素</span></span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">    iterator i = <span class="built_in">copy</span>(last, finish, first);</span><br><span class="line">    <span class="built_in">destroy</span>(i, finish);</span><br><span class="line">    finish = finish - (last - first);</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 重新设置 vector 大小，若设置值 new_size 大于当前 size，在尾端插入 x</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; <span class="built_in">size</span>()) </span><br><span class="line">      <span class="built_in">erase</span>(<span class="built_in">begin</span>() + new_size, <span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">insert</span>(<span class="built_in">end</span>(), new_size - <span class="built_in">size</span>(), x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span> </span>&#123; <span class="built_in">resize</span>(new_size, <span class="built_in">T</span>()); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 配置空间并填满内容，其中__STL_TRY、__STL_UNWIND 为异常相关的宏，在 stl_config.h 中定义</span></span><br><span class="line">  <span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    iterator result = data_allocator::<span class="built_in">allocate</span>(n);</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">uninitialized_fill_n</span>(result, n, x);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(data_allocator::<span class="built_in">deallocate</span>(result, n));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="vector-的迭代器"><a href="#vector-的迭代器" class="headerlink" title="vector 的迭代器"></a>vector 的迭代器</h3><p>vector 维护的是一个连续的线性空间，所以不论其元素型别如何，普通指针都可以作为 vector 的迭代器而满足所有必要条件，因为 vector 迭代器所需要的操作行为，如<code>operator*</code>，<code>operator-&gt;</code>，<code>operator++</code>，<code>operator–</code>，<code>operator+</code>，<code>operator-</code>，<code>operator+=</code>，<code>operator-=</code>，普通指针天生就具备。vector 支持随机存取，而普通指针正有这样的能力。所以，vector 提供的是 Random Access Iterators。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T             value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type*   iterator;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>根据定义，如果客户端写出这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator ivite;</span><br><span class="line">vector&lt;Shape&gt;::iterator svite;</span><br></pre></td></tr></table></figure><br>ivite 型别就是<code>int*</code>，svite 的型别就是<code>Shape*</code>。</p>
<h3 id="vector数据结构"><a href="#vector数据结构" class="headerlink" title="vector数据结构"></a>vector数据结构</h3><p>vector采用线性连续空间的数据结构。它以两个迭代器start和finish分别指向配置的来的连续空间中目前已被使用的范围，并以迭代器<code>end_of_storage</code>指向整块连续空间（含备用空间）的尾端:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;  </span><br><span class="line"><span class="keyword">class</span> vector&#123;  </span><br><span class="line">...  </span><br><span class="line"><span class="keyword">protected</span> :  </span><br><span class="line">      iterator start ; <span class="comment">//表示目前使用空间的头  </span></span><br><span class="line">      iterator finish ; <span class="comment">// 表示目前使用空间的尾  </span></span><br><span class="line">      iterator end_of_storage ; <span class="comment">//表示目前可用空间的尾  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>为了降低空间配置时的速度成本，vector 实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。这便是容量（capacity）的概念。添加新元素时，如果超出当时的容量，则容量会扩充至两倍，如果两倍容量仍不足，就扩充至足够大的容量。上述容量的扩张必须经历“重新配置、元素移动、释放空间”等过程。vector数据插入过程的示意图如下:<br><img src="/img/1609589397.jpg" alt=""></p>
<h3 id="vector构造与内存管理"><a href="#vector构造与内存管理" class="headerlink" title="vector构造与内存管理"></a>vector构造与内存管理</h3><p>vector缺省使用alloc作为空间配置器，并据此另外定义了一个data_allocator，为的是更方便以元素大小为配置单位：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;  </span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>于是，<code>data_allocator::allocate(n)</code>表示配置n个元素空间。</p>
<p>vector提供许多constructors，其中一个允许我们指定空间大小及初值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(size_type n, <span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill_initialize</span><span class="params">(n, value)</span> </span>&#123;</span><br><span class="line">    start = <span class="built_in">allocate_and_fill</span>(n, value);</span><br><span class="line">    finish = start + n;</span><br><span class="line">    end_of_storage = finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置而后填充</span></span><br><span class="line"><span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    iterator result = data_allocator::<span class="built_in">allocate</span>(n);</span><br><span class="line">    <span class="built_in">uninitialized_fill_n</span>(result, n, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><code>uninitialized_fill_n()</code>会根据第一参数的类型决定使用算法<code>fill_n</code>或反复调用<code>construct()</code>完成任务。</p>
<p>当我们以<code>push_back()</code>将新元素插入vector尾端时，该函数先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器finish，使vector变大。如果没有备用空间，就扩充空间（重新配置、移动数据、释放原空间）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(finish, x);</span><br><span class="line">      ++finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;  </span><br><span class="line">  <span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="type">const</span> T&amp;x)&#123;  </span><br><span class="line">      <span class="keyword">if</span> (finish != end_of_storage)&#123;<span class="comment">//还有备用空间  </span></span><br><span class="line">          <span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>)); <span class="comment">//在备用空间起始处构造一个元素，以vector最后一个元素值为其初值  </span></span><br><span class="line">          ++finish; <span class="comment">//调整finish迭代器  </span></span><br><span class="line">          T x_copy = x;  </span><br><span class="line">          <span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);  </span><br><span class="line">          *position = x_copy;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">else</span>&#123;<span class="comment">//没有备用空间  </span></span><br><span class="line">          <span class="type">const</span> size_type old_size = <span class="built_in">size</span>();  </span><br><span class="line">          <span class="type">const</span> size_type new_size = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;  </span><br><span class="line">          iterator new_start = data_allocator::<span class="built_in">allocate</span>(new_size);  </span><br><span class="line">          iterator new_finish = new_start;  </span><br><span class="line">          <span class="keyword">try</span>&#123;  </span><br><span class="line">              new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);<span class="comment">//将原vector的内容拷贝到新vector  </span></span><br><span class="line">              <span class="built_in">construct</span>(new_finish, x);  </span><br><span class="line">              ++new_finish;  </span><br><span class="line">              new_finish = <span class="built_in">uninitialzed_copy</span>(position, finish, new_finish);<span class="comment">//将安插点的原内容也拷贝过来  </span></span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="built_in">catch</span> (excetion e)&#123;  </span><br><span class="line">              <span class="built_in">destroy</span>(new_start, new_finish);<span class="comment">//如果发生异常，析构移动的元素，释放新空间  </span></span><br><span class="line">              data_allocator::<span class="built_in">deallocate</span>(new_start, new_size);</span><br><span class="line">              <span class="keyword">throw</span>;</span><br><span class="line">          &#125;<span class="comment">//析构并释放原空间  </span></span><br><span class="line">          <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());  </span><br><span class="line">          <span class="built_in">deallocator</span>();  </span><br><span class="line">          start = new_start; <span class="comment">//调整迭代器  </span></span><br><span class="line">          finish = new_finish;  </span><br><span class="line">          end_of_storage = new_start + new_size;<span class="comment">//调整迭代器  </span></span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure><br>补充：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterator1, <span class="keyword">class</span> BidirectionalIterator2&gt;</span></span><br><span class="line"><span class="function">  BidirectionalIterator2 <span class="title">copy_backward</span> <span class="params">( BidirectionalIterator1 first,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         BidirectionalIterator1 last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         BidirectionalIterator2 result)</span>； </span></span><br><span class="line"><span class="function"> 参数:</span></span><br><span class="line"><span class="function">       first, last</span></span><br><span class="line"><span class="function">       指出被复制的元素的区间范围[first，last).</span></span><br><span class="line"><span class="function">       result</span></span><br><span class="line"><span class="function">       指出复制到目标区间的具体位置[result-(last-first),result)</span></span><br><span class="line"><span class="function"> 返回值：</span></span><br><span class="line"><span class="function">        返回一个迭代器，指出已被复制元素区间的起始位置</span></span><br></pre></td></tr></table></figure></p>
<p>所谓动态增加大小，并不是在原空间之后接续空间（因为无法包装原空间之后尚有可配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原来内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。</p>
<h3 id="vector的元素操作"><a href="#vector的元素操作" class="headerlink" title="vector的元素操作"></a>vector的元素操作</h3><p><code>pop_back()</code>实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;</span><br><span class="line">      --finish;            <span class="comment">//将尾端标记往前移一格，表示放弃尾端元素</span></span><br><span class="line">      <span class="built_in">destory</span>(finish);     <span class="comment">//finish原来指向容器尾部[strat,finish),--后指向最后一个元素，然后析构</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><code>erase()</code>实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除[first,last]中的所有元素</span></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>&#123;</span><br><span class="line">     iterator i=<span class="built_in">copy</span>(last,finish,first);</span><br><span class="line">     <span class="built_in">destroy</span>(i,finish);</span><br><span class="line">     finish=finish-(last-first);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//清除某个位置上的元素</span></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(position<span class="number">+1</span>!=<span class="built_in">end</span>())</span><br><span class="line">         <span class="built_in">copoy</span>(position<span class="number">+1</span>,finish,position);</span><br><span class="line">     --finish;</span><br><span class="line">     <span class="built_in">destory</span>(finish);</span><br><span class="line">     <span class="keyword">return</span> position;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//清除所有元素</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;<span class="built_in">erase</span>(<span class="built_in">begin</span>(),<span class="built_in">end</span>());&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609589884.jpg" alt=""></p>
<p><code>copy()</code>函数具体实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InputIterator 版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> OutputIterator __copy(InputIterator first, InputIterator last, OutputIterator result, input_iterator_tag)&#123;</span><br><span class="line"><span class="comment">//如果只是 InputIterator 的话，以迭代器赞同与否，决定循环是否继续、速度慢</span></span><br><span class="line"><span class="keyword">for</span>( ; first != last; ++result, ++first)</span><br><span class="line">*result = *first;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>即<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; last != finish; ++first, ++last)</span><br><span class="line">*first = *last;  <span class="comment">//即将last开始的元素接到first后面</span></span><br></pre></td></tr></table></figure></p>
<p><code>insert()</code>实现，根据备用空间和插入元素的多少分为以下三种情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, size_type n, <span class="type">const</span> T&amp; x) &#123;</span><br><span class="line">  <span class="comment">// 当 n != 0 才进行以下所有操作</span></span><br><span class="line">  <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 备用空间大于等于新增元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size_type</span>(end_of_storage - finish) &gt;= n) &#123;</span><br><span class="line">      T x_copy = x;</span><br><span class="line">      <span class="type">const</span> size_type elems_after = finish - position;</span><br><span class="line">      iterator old_finish = finish;</span><br><span class="line">      <span class="comment">// 针对插入点后现有元素与新增元素个数的数量采取不同的操作</span></span><br><span class="line">      <span class="comment">// 插入点后现有元素个数大于新增元素个数</span></span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; n) &#123;</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(finish - n, finish, finish);</span><br><span class="line">        finish += n;</span><br><span class="line">        <span class="built_in">copy_backward</span>(position, old_finish - n, old_finish);</span><br><span class="line">        <span class="built_in">fill</span>(position, position + n, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 插入点后现有元素个数小于等于新增元素个数</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">uninitialized_fill_n</span>(finish, n - elems_after, x_copy);</span><br><span class="line">        finish += n - elems_after;</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(position, old_finish, finish);</span><br><span class="line">        finish += elems_after;</span><br><span class="line">        <span class="built_in">fill</span>(position, old_finish, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 备用空间小于新增元素个数（必须配置额外的内存）</span></span><br><span class="line">      <span class="comment">// 首先决定新长度：旧长度的2倍，或者旧长度+新增元素个数</span></span><br><span class="line">      <span class="type">const</span> size_type old_size = <span class="built_in">size</span>();        </span><br><span class="line">      <span class="type">const</span> size_type len = old_size + <span class="built_in">max</span>(old_size, n);</span><br><span class="line">      <span class="comment">// 配置新的 vector 空间</span></span><br><span class="line">      iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">      iterator new_finish = new_start;</span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_fill_n</span>(new_finish, n, x);</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="keyword">ifdef</span>  __STL_USE_EXCEPTIONS </span></span><br><span class="line">      <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">// 如有异常发生，实现 commit or rollback 语义</span></span><br><span class="line">        <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">      <span class="comment">// 清除并释放旧的 vector</span></span><br><span class="line">      <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">      <span class="built_in">deallocate</span>();</span><br><span class="line">      <span class="comment">// 调整迭代器</span></span><br><span class="line">      start = new_start;</span><br><span class="line">      finish = new_finish;</span><br><span class="line">      end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609590017.jpg" alt=""><br><img src="/img/1609590056.jpg" alt=""><br><img src="/img/1609590082.jpg" alt=""></p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h2 id="list概述"><a href="#list概述" class="headerlink" title="list概述"></a>list概述</h2><p>相比于vector的连续线性空间，list显得更为复杂；但list每次插入或删除一个元素时，就将配置或释放一个元素。因此，list对于空间的运用有绝对的精准，一点也不浪费。对于任何位置的插入或元素删除，list永远是常数时间。</p>
<h3 id="list的节点"><a href="#list的节点" class="headerlink" title="list的节点"></a>list的节点</h3><p>下面是STL list的节点结构，显然是一个双向链表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span> &#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">void</span>* void_pointer; </span><br><span class="line">	void_pointer prev; <span class="comment">//型别为void*,其实可设为__list_node&lt;T&gt;*</span></span><br><span class="line">	void_pointer next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h3><p>list中的元素由于都是节点，不保证在存储空间中连续存在。list迭代器必须有能力指向list的节点，并有能力正确递增递减取值存取等操作。其迭代器递增时取用的是下一个节点，递减时取用上一个节点，取值时取的是节点的数据值，成员存取时取用的是节点的成员。</p>
<p>由于list是双向链表，迭代器必须具备前移、后移的能力，因此，list提供的是Bidirectional Iterators；list的插入和接合操作都不会导致原有迭代器失效，但vector的插入可能造成存储空间重新分配，导致原有的迭代器全部失效。甚至list的删除操作也只有指向被删除元素的那个迭代器失效，其他迭代器不受影响。<br><img src="/img/1609590834.jpg" alt=""></p>
<p>以下是list迭代器的设计：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, P&amp;, T*&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> bidirectionla_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    link_type node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constrcutor</span></span><br><span class="line">    __list_iterator(link_type x) : <span class="built_in">node</span>(x) &#123;&#125;</span><br><span class="line">    __list_iterator() &#123;&#125;</span><br><span class="line">    __list_iterator(<span class="type">const</span> iterator&amp; x) : <span class="built_in">node</span>(x.node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line"></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    </span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123; <span class="comment">//运算符前置++的重载</span></span><br><span class="line">        node = (link_type)((*node).next);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="comment">//运算符后置++的重载</span></span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123; <span class="comment">//运算符前置--的重载</span></span><br><span class="line">        node = (link_type)((*node).prev);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123; <span class="comment">//运算符后置--的重载</span></span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        --*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="list的数据结构"><a href="#list的数据结构" class="headerlink" title="list的数据结构"></a>list的数据结构</h3><p>SGI list是一个双向链表，而且是一个环状双向链表:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; <span class="comment">//缺省使用alloc为配置器:w</span></span><br><span class="line"><span class="keyword">class</span> list&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	__list_node&lt;T&gt; list_node ;</span><br><span class="line"><span class="keyword">public</span>  :</span><br><span class="line">	<span class="keyword">typedef</span>	list_node* link_type ;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	link_type node ; <span class="comment">//只要一个指针，便可以表示整个环状双向链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果让指针 node 指向刻意置于尾端的一个空白节点， node 便能符合 STL 对于“前闭后开”区间的要求，成为 last 迭代器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取首元素，node是尾端的一个空节点</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span>  </span>&#123;  <span class="keyword">return</span>  (link_type) ((*node).next); &#125;</span><br><span class="line"><span class="comment">//取尾元素的下一个，即node</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span>     </span>&#123;  <span class="keyword">return</span> node;  &#125;</span><br><span class="line"><span class="comment">//为空，说明只有node</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span>  </span>&#123;  <span class="keyword">return</span> node-&gt;next == node; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span>  <span class="type">const</span> </span>&#123;</span><br><span class="line">	size_type result = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">distance</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), result);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span>    </span>&#123;  <span class="keyword">return</span> *(--<span class="built_in">end</span>());  &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609591356.jpg" alt=""></p>
<h3 id="list的构造与内存管理"><a href="#list的构造与内存管理" class="headerlink" title="list的构造与内存管理"></a>list的构造与内存管理</h3><p>list采用<code>list_node_allocator</code>来配置节点空间，以下四个函数分别用来配置、释放、构造、销毁一个节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; <span class="comment">//缺省使用alloc为配置器:w</span></span><br><span class="line"><span class="keyword">class</span> list&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	__list_node&lt;T&gt; list_node ;</span><br><span class="line">    <span class="comment">//专属之空间配置器，每次配置一个节点大小</span></span><br><span class="line">	<span class="keyword">typedef</span>	simple_alloc&lt;list_node,Alloc&gt; list_node_allocator;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>list_node_allocator(n)</code>表示配置n个节点空间，配置、释放、构造、销毁。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置一个节点</span></span><br><span class="line"><span class="function">link_type <span class="title">get_node</span><span class="params">()</span> 	</span>&#123; <span class="keyword">return</span> list_node_allocator::<span class="built_in">allocate</span>(); &#125;  </span><br><span class="line"><span class="comment">//释放一个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span>	</span>&#123; list_node_deallocator::<span class="built_in">deallocate</span>(p); &#125;</span><br><span class="line"><span class="comment">//产生一个节点，带有元素值</span></span><br><span class="line"><span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> T&amp; x)</span>  </span>&#123;</span><br><span class="line">	link_type p = <span class="built_in">get_node</span>();</span><br><span class="line">	<span class="built_in">construct</span>(&amp;p-&gt;data, x);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁一个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">destroy</span>(&amp;p-&gt;data);</span><br><span class="line">	<span class="built_in">put_node</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>list提供了默认的构造函数，使得可以创建一个空list：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">list</span>()   &#123;  <span class="built_in">empty_initialize</span>();  &#125;   <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">empty_initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		node = <span class="built_in">get_node</span>();       <span class="comment">//配置一个节点空间</span></span><br><span class="line">		node-&gt;next = node;</span><br><span class="line">		node-&gt;prev = node;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们以<code>push_back()</code>将新元素插入list尾端时，此函数内部调用<code>insert()</code>，<code>insert()</code>是一个重载函数，最简单的一种如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span></span>&#123;<span class="comment">//在迭代器position所指位置插入一个节点，内容为x</span></span><br><span class="line">	link_type tmp = <span class="built_in">create_node</span>(x);</span><br><span class="line">	tmp-&gt;next = position.node;</span><br><span class="line">	tmp-&gt;prev = position.node-&gt;prev;</span><br><span class="line">	(<span class="built_in">link_type</span>(position.node-&gt;prev))-&gt;next = tmp;</span><br><span class="line">    position.node-&gt;prev =tmp;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当连续插入5个节点之后，list的状态如图，如果希望在list内部的某处插入新节点，首先必须确定插入位置，例如希望在数据为3的节点处插入一个数据值为99的节点，可以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ilite = <span class="built_in">find</span>(li.begin, li.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (ilite != <span class="number">0</span>)</span><br><span class="line">    il.<span class="built_in">insert</span>(ilite, <span class="number">99</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609603712.png" alt=""></p>
<h3 id="list的元素操作"><a href="#list的元素操作" class="headerlink" title="list的元素操作"></a>list的元素操作</h3><p><code>push_front()</code>函数：将新元素插入于list头端，内部调用<code>insert()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp;x)</span>  </span>&#123; <span class="built_in">insert</span>(<span class="built_in">begin</span>(),x); &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>push_back()</code>函数：将新元素插入于list尾端，内部调用<code>insert()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span>   </span>&#123;  <span class="built_in">insert</span>(<span class="built_in">end</span>(),x); &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>erase()</code>函数：移除迭代器position所指节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">    link_type next_node=<span class="built_in">link_type</span>(position.node-&gt;next);</span><br><span class="line">    link_type prev_node=<span class="built_in">link_type</span>(position.node-&gt;prev);</span><br><span class="line">    prev_node-&gt;next=next_node;</span><br><span class="line">    next_node-&gt;prev=prev_node;</span><br><span class="line">    <span class="built_in">destroy_node</span>(position.node);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(next_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pop_front()</code>函数：移除头结点，内部调用<code>erase()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span>  </span>&#123;  <span class="built_in">erase</span>(<span class="built_in">begin</span>());  &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pop_back()</code>函数：移除尾结点，内部调用<code>erase()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;</span><br><span class="line">    iterator i = <span class="built_in">end</span>();</span><br><span class="line">    <span class="built_in">erase</span>(--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>clear()</code>函数：清除所有节点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;  </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">clear</span>()  </span><br><span class="line">&#123;  </span><br><span class="line">  link_type cur = (link_type) node-&gt;next;<span class="comment">//node原来指向list的end,node-&gt;next为begin  </span></span><br><span class="line">  <span class="keyword">while</span> (cur != node)  </span><br><span class="line">  &#123;  </span><br><span class="line">    link_type tmp = cur;  </span><br><span class="line">    cur = (link_type) cur-&gt;next;  </span><br><span class="line">    <span class="built_in">destroy_node</span>(tmp);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 恢复node原始状态  </span></span><br><span class="line">  node-&gt;next = node;  </span><br><span class="line">  node-&gt;prev = node;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>remove()</code>：将数值为value的所有元素移除<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">remove</span>(<span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last = <span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span>(first != end) &#123;</span><br><span class="line">        iterator next = first;</span><br><span class="line">        ++ next;</span><br><span class="line">        <span class="keyword">if</span> (*first == value) </span><br><span class="line">            <span class="built_in">erase</span>(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>transfer()</code>迁移函数：将[ frirst , last ) 内所有元素移动到position之前。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position != last) &#123;</span><br><span class="line">      (*(<span class="built_in">link_type</span>((*last.node).prev))).next = position.node; <span class="comment">//(1)</span></span><br><span class="line">      (*(<span class="built_in">link_type</span>((*first.node).prev))).next = last.node;    <span class="comment">//(2)</span></span><br><span class="line">      (*(<span class="built_in">link_type</span>((*position.node).prev))).next = first.node;<span class="comment">//(3)</span></span><br><span class="line">      link_type tmp = <span class="built_in">link_type</span>((*position.node).prev);       <span class="comment">//(4)</span></span><br><span class="line">      (*position.node).prev = (*last.node).prev;              <span class="comment">//(5)</span></span><br><span class="line">      (*last.node).prev = (*first.node).prev;                 <span class="comment">//(6)</span></span><br><span class="line">      (*first.node).prev = tmp;                               <span class="comment">//(7)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609605134.jpg" alt=""></p>
<p>list公开提供的是所谓的接合操作splice，<code>splice</code>结合操作将连续范围的元素从一个list移动到另一个list的某个定点。<br><img src="/img/1609605212.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iv[<span class="number">5</span>] = &#123; <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">ilist2</span><span class="params">(iv,iv<span class="number">+5</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//目前，ilist的内容为 0 2 99 3 4</span></span><br><span class="line">ite = <span class="built_in">find</span>(ilist.<span class="built_in">begin</span>(),ilist.<span class="built_in">end</span>(),<span class="number">99</span>);</span><br><span class="line">ilist.<span class="built_in">splice</span>(ite,ilist2);  <span class="comment">// 0 2 5 6 7 8 9 99 3 4</span></span><br><span class="line">ilist.<span class="built_in">reverse</span>();           <span class="comment">// 4 3 99 9 8 7 6 5 2 0</span></span><br><span class="line">ilist.<span class="built_in">sort</span>();              <span class="comment">// 0 2 3 4 5 6 7 8 9 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表x移动到position所指位置之前  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp; x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!x.<span class="built_in">empty</span>())  </span><br><span class="line">        <span class="built_in">transfer</span>(position, x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 将链表中i指向的内容移动到position之前  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;, iterator i)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     iterator j = i;  </span><br><span class="line">     ++j;  </span><br><span class="line">     <span class="keyword">if</span> (position == i || position == j) <span class="keyword">return</span>;  </span><br><span class="line">     <span class="built_in">transfer</span>(position, i, j);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是<code>merge()</code>、<code>reverse()</code>、<code>sort()</code>的源代码，有了<code>transfer()</code>在手，这些操作都不难完成<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">merge</span>(list&lt;T, Alloc&gt;&amp; x) &#123;</span><br><span class="line">    iterator first1 = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last1 = <span class="built_in">end</span>();</span><br><span class="line">    iterator first2 = x.<span class="built_in">begin</span>();</span><br><span class="line">    iterator last2 = x.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(first1 != last1 &amp;&amp; first2 != last2) </span><br><span class="line">        <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">            iterator next = first2;</span><br><span class="line">            <span class="built_in">transfer</span>(first1, first2, ++next);</span><br><span class="line">            first2 = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++first1;</span><br><span class="line">    <span class="keyword">if</span> (first2 != last2)</span><br><span class="line">        transfer)last1, first2, last2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>reverse()</code>将<code>*this</code>的内容逆向重置<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">reverse</span>() &#123;</span><br><span class="line">    <span class="comment">// 以下判断，如果是空链表，或仅有一个元素，就不操作</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    iteratro first = <span class="built_in">begin</span>();</span><br><span class="line">    ++first;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="built_in">end</span>()) &#123;</span><br><span class="line">        iterator old = first;</span><br><span class="line">        ++ first;</span><br><span class="line">        <span class="built_in">transfer</span>(<span class="built_in">begin</span>(), old, first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>list不能使用STL算法sort()，必须使用自己的sort()：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">sort</span>() &#123;</span><br><span class="line">    <span class="comment">// 以下判断，如果是空链表，或仅有一个元素，就不操作</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    list&lt;T, Alloc&gt; carry;</span><br><span class="line">    list&lt;T, Alloc&gt; counter[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> fill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        carry.<span class="built_in">splice</span>(carry.<span class="built_in">begin</span>(), *<span class="keyword">this</span>, <span class="built_in">begin</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; fill &amp;&amp; !counter[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            counter[i].<span class="built_in">merge</span>(carry);</span><br><span class="line">            carry.<span class="built_in">swap</span>(counter[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        carry.<span class="built_in">swap</span>(counter[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == fill)</span><br><span class="line">            ++ fill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; fill; i ++)</span><br><span class="line">        counter[i].<span class="built_in">merge</span>(counter[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">swap</span>(counter[fill<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque（double-ended queue，双端队列）是一种具有队列和栈的性质的数据结构。相比于vector单向开口的连续线性空间而言，deque则是一种双向开口的连续线性空间，可以在头尾两端分别做元素的插入和删除操作。虽然vector从技术层面也可以对头部操作，但是效率极低。<br><img src="/img/1609640774.jpg" alt=""></p>
<p>deque与vector的最大差异在于：</p>
<ol>
<li>deque可以在常数时间内完成对头部元素的插入或删除操作；</li>
<li>deque没有容量的概念，它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。deque没有必要提供所谓的空间保留reserve功能。</li>
</ol>
<p>虽然deque也提供Random Access Iterator，但它的迭代器并不是普通指针，其复杂度和vector不同。除非必要我们应该选择vector而不是deque。对deque进行排序操作，为了得到最高效率，可先将deque复制一个vector，将vector排序后再复制回deque。</p>
<h3 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h3><p>deque由一段一段的定量连续空间构成。一旦有必要在dequer前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。</p>
<p>deque采用一块所谓的map作为主控。这里所谓<strong>map是一小块连续空间</strong>，其中每个元素(此处称为一个节点，node)都是指针，指向另一段(较大的)连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	T value_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	value_type* pointer ;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	<span class="comment">//元素的指针的指针(pointer of pointer of T)</span></span><br><span class="line">	<span class="keyword">typedef</span>	pointer* map_pointer ; <span class="comment">//其实就是T**</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	map_pointer map ; <span class="comment">//指向map,map是块连续空间，其内的每个元素</span></span><br><span class="line">					  <span class="comment">//都是一个指针(称为节点)，指向一块缓冲区</span></span><br><span class="line">	size_type map_size ;<span class="comment">//map内可容纳多少指针</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>map其实是一个<code>T**</code>，所指之物是另一个指针，指向类型为T的一块空间。<br><img src="/img/1609641339.jpg" alt=""></p>
<h3 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h3><p>deque是分段连续空间，维持“整体连续”假象的任务，落在迭代器的<code>operator++</code>和<code>operator--</code>两个运算子上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span>&#123; <span class="comment">//未继承std::iterator</span></span><br><span class="line">	<span class="keyword">typedef</span>	__deque_iterator&lt;T,T&amp;,T*,BufSize&gt;	iterator ;</span><br><span class="line">	<span class="keyword">typedef</span>	__deque_iterator&lt;T,<span class="type">const</span> T&amp;,<span class="type">const</span> T*,BufSize&gt;	const_iterator ;</span><br><span class="line">	<span class="function"><span class="type">static</span>	<span class="type">size_t</span>	<span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(BufSize,<span class="built_in">sizeof</span>(T)) ;&#125; </span><br><span class="line"> </span><br><span class="line">	<span class="comment">//未继承std::iterator，所以必须自行撰写五个必要的迭代器相应型别</span></span><br><span class="line">	<span class="keyword">typedef</span>	random_access_iterator_tag	iterator_category ;</span><br><span class="line">	<span class="keyword">typedef</span>	T	value_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	Ptr	pointer ;</span><br><span class="line">	<span class="keyword">typedef</span>	Ref	reference ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="type">size_t</span>	size_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="type">ptrdiff_t</span>	difference_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	T**	map_pointer ;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">typedef</span>	__deque_iterator	self ;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//保持与容器的联结</span></span><br><span class="line">	T *cut ; <span class="comment">//此迭代器所指之缓冲区中的现行(current)元素</span></span><br><span class="line">	T *first ; <span class="comment">//此迭代器所指之缓冲区的头</span></span><br><span class="line">	T *last ;	<span class="comment">//此迭代器所指之缓冲区的尾(含备用空间)</span></span><br><span class="line">	map_pointer node ; <span class="comment">//指向管控中心</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中用来决定缓冲区大小的函数<code>buffer_size()</code>调用<code>__deque_buf_size()</code>，后者是一个全局函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果n不为0，传回n，表示buffer size由用户定义</span></span><br><span class="line"><span class="comment">// 如果n为0，表示buffer size使用默认值，那么</span></span><br><span class="line"><span class="comment">//   如果sz(元素大小，sizeof(value_type))小于512，传回512/sz</span></span><br><span class="line"><span class="comment">//   如果sz不小于512，传回1</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __deque_buf_size(<span class="type">size_t</span> n, <span class="type">size_t</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span>/sz) : <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609641622.jpg" alt=""></p>
<p>假设现在我们产生1个<code>deque&lt;int&gt;</code>，并令其缓冲区大小为32，于是每个缓冲区可容纳<code>32/sizeof(int)=4</code>个元素：经过某些操作之后，deque拥有20个元素，那么其<code>begin()</code>和<code>end()</code>所传回的两个迭代器应该如图4-12所示。这两个迭代器事实上一直保持在deque内，名为start和finish，稍后在deque数据结构中便可看到。<br><img src="/img/1609641867.jpg" alt=""></p>
<p>20个元素需要<code>20/8=3</code>个缓冲区，所以map之内运用了三个节点。迭代器start内的cur指针当然指向缓冲区的第一个兀素，迭代器finish内的指针当然指向缓冲区的最后元素（的下一位置）。注意，最后1个缓冲区尚有备用空间。稍后如果有新元素要插入于尾端，可直接拿此备用空间来使用。</p>
<p>下面是deque迭代器的几个关键行为．由于迭代器内对各种指针运算都进行了重载操作，所以各种指针运算如加、减、前进、后退都不能直观视之。其中最关键的就是：一旦行进时遇到缓冲区边缘，要特别当心，视前进或后退而定，可能需要调用<code>set_node()</code>跳一个缓冲区。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;</span><br><span class="line">    node = new_node;</span><br><span class="line">    first = *new_node;</span><br><span class="line">    last = first + <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下各个重载运算子是__deque_iterator&lt;&gt;成功运作的关踺</span></span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*(); &#125;</span><br><span class="line"></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ++ cur;  <span class="comment">//切换至下一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (cur == last) &#123; <span class="comment">// 如果已达所在缓冲区的尾端</span></span><br><span class="line">        <span class="built_in">set_node</span>(node + <span class="number">1</span>); <span class="comment">//就切换至下一节点（亦即缓冲区）</span></span><br><span class="line">        cur = first;   <span class="comment">// 的第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; </span><br><span class="line"><span class="comment">// 后置式标准写法</span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; operaeor--() &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == first) &#123; <span class="comment">// 如果已达所在缓冲区的头端，</span></span><br><span class="line">        <span class="built_in">set_node</span>(node - <span class="number">1</span>); <span class="comment">// 就切涣至前一节点（亦即缓冲区）</span></span><br><span class="line">        cur = last; <span class="comment">// 的最后一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    -- cur; <span class="comment">//切换至前一个元素</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 后置标准写法</span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    -- *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下实现随机存取．迭代器可以直接跳跃n个距离</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">    difference_type offset = n + (cur - first);</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()))</span><br><span class="line">        <span class="comment">// 目标位置在同一缓冲区内</span></span><br><span class="line">        cur += n;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 标的位不在同一缓冲区内</span></span><br><span class="line">        difference_type node_offset = offset &gt; <span class="number">0</span> ? offset/<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) : -<span class="built_in">difference_type</span>((-offset<span class="number">-1</span>)/<span class="built_in">buffer_size</span>()) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 切换至正确的节点〈亦即缓冲区）</span></span><br><span class="line">        <span class="built_in">set_node</span>(node + node_offset);</span><br><span class="line">        <span class="comment">// 切换至正确的元素</span></span><br><span class="line">        cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp += n; <span class="comment">// 调用operator+=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;</span><br><span class="line"><span class="comment">// 以上利用operator+= 来完成operator-=</span></span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span> &#123;</span><br><span class="line">    slef tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp -= n; <span class="comment">// 调用operator-=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下实现随机存取。迭代器可以直接跳跃n个距离</span></span><br><span class="line">reference <span class="keyword">operator</span>[] (difference_type n) <span class="type">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</span><br><span class="line"><span class="comment">// 以上调用operator*, operator+</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!= (<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h3><p>deque除了维护一个指向map的指针外，也维护start，finish两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素(的下一个位置)。此外，也必须记住目前的map大小，因为一旦map提供的节点不足，就必须重新配置更大的一块map。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	T	value_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	value_type*	pointer ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="type">size_t</span>	size_type ;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	__deque_iterator&lt;T,T&amp;,T*,BufSiz&gt; iterator ;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	<span class="comment">//元素的指针的指针(pointer of pointer of T)</span></span><br><span class="line">	<span class="keyword">typedef</span>	pointer*	map_pointer ;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator	start ; <span class="comment">//表现第一节点</span></span><br><span class="line">	iterator	finish ; <span class="comment">//表现最后一个节点</span></span><br><span class="line">	map_pointer	map ; <span class="comment">//指向map,map是块连续空间，其每个元素都是个指针，指向一个节点(缓冲区)</span></span><br><span class="line">	size_type	map_size ; <span class="comment">//map内有多少指针</span></span><br><span class="line">	...</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure></p>
<h3 id="deque的构造与内存管理"><a href="#deque的构造与内存管理" class="headerlink" title="deque的构造与内存管理"></a>deque的构造与内存管理</h3><p>以程序实现来初步了解deque的构造和内存管理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">alloc</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ideq</span>(<span class="number">20</span>, <span class="number">9</span>);</span><br><span class="line">	<span class="comment">//deque&lt;int,alloc,8&gt; ideq(20, 9);//在linux下不支持alloc</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ideq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        ideq.<span class="built_in">push_back</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ideq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    ideq.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ideq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    ideq.<span class="built_in">push_front</span>(<span class="number">99</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ideq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    ideq.<span class="built_in">push_front</span>(<span class="number">98</span>);</span><br><span class="line">    ideq.<span class="built_in">push_front</span>(<span class="number">97</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ideq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    deque&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt;::iterator itr;</span><br><span class="line">    itr = <span class="built_in">find</span>(ideq.<span class="built_in">begin</span>(), ideq.<span class="built_in">end</span>(), <span class="number">99</span>);</span><br><span class="line">    cout &lt;&lt; *itr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *(itr._M_cur) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">[root@<span class="number">192</span> <span class="number">4</span>_STL_sequence_container]# ./<span class="number">4</span>_4_5_deque-test                         </span><br><span class="line">size=<span class="number">20</span></span><br><span class="line"><span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">size=<span class="number">23</span></span><br><span class="line"><span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">size=<span class="number">24</span></span><br><span class="line"><span class="number">99</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">size=<span class="number">25</span></span><br><span class="line"><span class="number">97</span> <span class="number">98</span> <span class="number">99</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">size=<span class="number">27</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure></p>
<p>一开始声明一个deque：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">deque&lt;<span class="type">int</span>, alloc, 32&gt; <span class="title">ideq</span><span class="params">(<span class="number">20</span>, <span class="number">9</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其缓冲区为32bytes，并令其保留20个元素空间，每个元素初值为9。现在，deque的情况如图4-12。</p>
<p>deque自行定义了2个专属的空间配置器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 每次配置一个元素大小</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">    <span class="comment">// 每次配置一个指针大小</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</span><br></pre></td></tr></table></figure></p>
<p>并提供一个constructor：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>(<span class="type">int</span> n,<span class="type">const</span> value_type&amp; value):<span class="built_in">start</span>(),<span class="built_in">finish</span>(),<span class="built_in">map</span>(<span class="number">0</span>),<span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其内调用的<code>fill_initialize()</code>负责产生并安排好deque的结构，并将元素的初值设定妥当。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">fill_initialize</span>(size_type n, <span class="type">const</span> value_type&amp; value) &#123; </span><br><span class="line">    <span class="comment">//负责产生并安排好deque的结构，并将元素的初值设定好</span></span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(n); <span class="comment">//把deque的结构都安排好</span></span><br><span class="line">    map_pointer cur;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">        <span class="comment">//已经获得空间,为每个节点缓冲区设定初值</span></span><br><span class="line">        <span class="keyword">for</span>(cur = start.node; cur &lt; finish.node; ++cur) &#123;</span><br><span class="line">            <span class="built_in">uninitialized_fill</span>(*cur, *cur+<span class="built_in">buffer_size</span>(), value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个节点的设定稍有不同（尾端可能有备用空间，不必设初值）</span></span><br><span class="line">        <span class="built_in">uninitialized_fill</span>(finish.first, finish.cur, value);</span><br><span class="line">    &#125; <span class="built_in">catch</span>( ... ) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>create_map_and_nodes()</code>负责产生并安排好deque的结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">creat_map_and_nodes</span>(size_type num_elements)</span><br><span class="line">&#123;   <span class="comment">//产生并安排好deque的结构</span></span><br><span class="line">    size_type num_nodes=num_elements/<span class="built_in">buffer_size</span>()<span class="number">+1</span>; </span><br><span class="line">    <span class="comment">//一个map要管理几个节点，最少8个，最多是“所需节点数+2”，前后各预留一个，扩充时用</span></span><br><span class="line">    map_size=<span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(),num_nodes<span class="number">+2</span>);</span><br><span class="line">    map=map_allocator::<span class="built_in">allocate</span>(map_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下令nstart和finish指向map所拥有的全部节点的最中央区段</span></span><br><span class="line">    <span class="comment">// 保持在最中央，可使头尾两端的扩充能量一样大，每个节点对应一个缓冲区</span></span><br><span class="line">    map_pointer nstart=map+(map_size-num_nodes)/<span class="number">2</span>;</span><br><span class="line">    map_pointer nfinish=nstart+num_nodes<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    map_pointer cur;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">        <span class="comment">// 为map的每个节点配置缓冲区，所有缓冲区加起来就是deque的可用空间</span></span><br><span class="line">        <span class="keyword">for</span>(cur=nstart; cur &lt;= nfinish; cur++)</span><br><span class="line">        &#123;</span><br><span class="line">            *cur=<span class="built_in">allocate_node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为deque内的两个迭代器start和end设置正确内容</span></span><br><span class="line">    start.<span class="built_in">set_node</span>(nstart);</span><br><span class="line">    finish.<span class="built_in">set_node</span>(nfinish);</span><br><span class="line">    start.cur=start.first;</span><br><span class="line">    finish.cur=finish.first+num_elements%<span class="built_in">buffer_size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来范例程序为每个元素重新设置值。在尾端插入三个元素<br><img src="/img/1609645158.jpg" alt=""></p>
<h3 id="deque的元素操作"><a href="#deque的元素操作" class="headerlink" title="deque的元素操作"></a>deque的元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> value_type &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish.cur, t);</span><br><span class="line">        ++finish.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//需要配置新的缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push_back_aux</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果尾端只剩一个元素备用空间，<code>push_back()</code>调用<code>push_back_aux()</code>，先配置一块新的缓冲区，再设妥新元素内容，然后更改迭代器finish状态。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_back_aux</span>(<span class="type">const</span> value_type &amp;t) <span class="comment">//只剩最后一个缓冲区的最后一个备用缓冲区</span></span><br><span class="line">&#123;                                       <span class="comment">//先配置一块新的缓冲区，再设新元素内容，更改迭代器finish的状态</span></span><br><span class="line">    value_type t_copy = t;</span><br><span class="line">    <span class="built_in">reserve_map_at_back</span>();                <span class="comment">//若符合某种条件，则必须重换一个map</span></span><br><span class="line">    *(finish.node + <span class="number">1</span>) = <span class="built_in">allocate_node</span>(); <span class="comment">//配置一新缓冲区</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish.cur, t_copy);</span><br><span class="line">        finish.<span class="built_in">set_node</span>(finish.node + <span class="number">1</span>);</span><br><span class="line">        finish.cur = finish.first;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">deallocate_node</span>(*(finish.node + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在deque的状态如图：<br><img src="/img/1609645423.jpg" alt=""></p>
<p>接下来范例程序在deque的前端插入一个新元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ideq.<span class="built_in">push_front</span>(<span class="number">99</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>push_front()</code>的操作如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.first) &#123; <span class="comment">// 第一缓冲区尚有空间</span></span><br><span class="line">        <span class="built_in">construct</span>(start.cur - <span class="number">1</span>, t); <span class="comment">// 直接在备用空间上构造元素</span></span><br><span class="line">        -- start.cur; <span class="comment">// 调整第一缓冲区的使用状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">push_front_aux</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_front_aux</span>(<span class="type">const</span> value_type &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    value_type t_copy = t;</span><br><span class="line">    <span class="built_in">reserve_map_at_front</span>();</span><br><span class="line">    *(start.node - <span class="number">1</span>) = <span class="built_in">allocate_node</span>();</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">        start.<span class="built_in">set_node</span>(start.node - <span class="number">1</span>);</span><br><span class="line">        start.cur = start.last - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">construct</span>(start.cur, t_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);</span><br><span class="line">        start.cur = start.first;</span><br><span class="line">        <span class="built_in">deallocate_node</span>(*(start.node - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一开始调用<code>reserve_map_at_front()</code>，判断是否需要扩充map，如果有则付诸行动。后续流程配置了一块新缓冲区，并直接将节点安置在现有的map中，设定新元素，改变迭代器的状态：<br><img src="/img/1609646609.jpg" alt=""></p>
<p>接下来插入两个新的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ideq.<span class="built_in">push_front</span>(<span class="number">98</span>);</span><br><span class="line">ideq.<span class="built_in">push_front</span>(<span class="number">97</span>);</span><br></pre></td></tr></table></figure><br>这一次，由于第一缓冲区有备用空间，<code>push_front()</code>可以在备用空间上构造新元素：<br><img src="/img/1609646690.jpg" alt=""></p>
<p><code>reserve_map_at_back()</code>和<code>reserve_map_at_front()</code>决定map是否需要整治：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve_map_at_back</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - map)) <span class="comment">//map尾端的节点备用空间不足</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//换一个map（配置更大的，拷贝原来的，释放原来的）</span></span><br><span class="line">        <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve_map_at_front</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add &gt; start.node - map)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">reallocate_map</span>(size_type node_to_add, <span class="type">bool</span> add_at_front) &#123;</span><br><span class="line">    size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;</span><br><span class="line">    size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line"></span><br><span class="line">    map_pointer new_nstart;</span><br><span class="line">    <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;</span><br><span class="line">        new_nstart = map + (map_size - new_num_nodes) / <span class="number">2</span> + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (new_nstart &lt; start.node)</span><br><span class="line">            <span class="built_in">copy</span>(start.node, finish.node<span class="number">+1</span>, new_nstart);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">copy_backward</span>(start.node, finish.node<span class="number">+1</span>, new_nstart+old_num_nodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        size_type new_map_size = map + <span class="built_in">max</span>(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//配置一块空间，准备给新map使用</span></span><br><span class="line">        map_pointer new_map = allocator::<span class="built_in">allocate</span>(new_map_size);</span><br><span class="line">        new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span> + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//把原nap内容拷贝过来</span></span><br><span class="line">        <span class="built_in">copy</span>(start.node, finish.node<span class="number">+1</span>, new_nstart);</span><br><span class="line">        <span class="comment">// 释放原map</span></span><br><span class="line">        map_allocator::<span class="built_in">deallocate</span>(map, map_size);</span><br><span class="line">        <span class="comment">// 设定新的起始地址与大小</span></span><br><span class="line">        map = new_map;</span><br><span class="line">        map_size = new_map_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新设定迭代器start和finish</span></span><br><span class="line">    start.<span class="built_in">set_node</span>(new_nstart);</span><br><span class="line">    finish.<span class="built_in">set_node</span>(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>pop是将元素拿掉：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.first)</span><br><span class="line">    &#123;</span><br><span class="line">        --finish.cur;</span><br><span class="line">        <span class="built_in">destroy</span>(finish.cur); <span class="comment">//将最后元素析构,左开右闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//最后缓冲区没有任何元素</span></span><br><span class="line">        <span class="built_in">pop_back_aux</span>(); <span class="comment">//这里将进行缓冲区的释放工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back_aux</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;                                  <span class="comment">//finish.cur==finish.first 释放该缓冲区</span></span><br><span class="line">    <span class="built_in">deallocate_node</span>(finish.first); <span class="comment">//释放最后一个缓冲区</span></span><br><span class="line">    finish.<span class="built_in">set_node</span>(finish.node - <span class="number">1</span>);</span><br><span class="line">    finish.cur = finish.last - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">destroy</span>(finish.cur); <span class="comment">//析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(start.cur);</span><br><span class="line">        ++start.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">pop_front_aux</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front_aux</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">destory</span>(start.cur);</span><br><span class="line">    <span class="built_in">deallocate_node</span>(start.last);</span><br><span class="line">    start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);</span><br><span class="line">    start.cur = start.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clear用来清除整个deque。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">destory</span>(*node, *node + <span class="built_in">buffer_size</span>());            <span class="comment">//析构元素</span></span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(*node, <span class="built_in">buffer_size</span>()); <span class="comment">//释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (start.node != finish.node) <span class="comment">//至少有两个缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(start.cur, start.last);</span><br><span class="line">        <span class="built_in">destroy</span>(finish.first, finish.cur);</span><br><span class="line">        <span class="comment">//保留头缓冲区</span></span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(finish.first, <span class="built_in">buffer_size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(start.cur, finish.cur);</span><br><span class="line">    &#125;</span><br><span class="line">    finish = start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面这个例子是<code>clear()</code>，用来清除某个元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除pos所指的元素．pos为清除点</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line">    iterator next = pos;</span><br><span class="line">    ++next;</span><br><span class="line">    difference_type index = pos - start; <span class="comment">// 清除点之前的元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)) &#123;         <span class="comment">// 如果清除点之前的元素比较少，</span></span><br><span class="line">        <span class="built_in">copy_backward</span>(start, pos, next); <span class="comment">// 就移动清除点之前的元素</span></span><br><span class="line">        <span class="built_in">pop_front</span>();                     <span class="comment">// 移动完毕，最前一个元素冗余，去除之</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                               <span class="comment">// 清除点之后的元素比较少，</span></span><br><span class="line">        <span class="built_in">copy</span>(next, finish, pos);         <span class="comment">// 就移动清除点之后的元素</span></span><br><span class="line">        <span class="built_in">pop_back</span>();                      <span class="comment">// 移动完毕，最后一个元素冗余，去除之</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面这个例子是<code>erase()</code>，用来清除<code>[first, last]</code>区间内的所有元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;Class T, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">eraee</span>(iterator first, iterator last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        difference_type n = last - first;</span><br><span class="line">        difference_type elems_before = first - start;</span><br><span class="line">        <span class="keyword">if</span> (elems_before &lt; (<span class="built_in">size</span>() - n) / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">copy_backward</span>(start, first, last);</span><br><span class="line">            iterator new_start = start + n;</span><br><span class="line">            <span class="built_in">destroy</span>(start, new_start);</span><br><span class="line">            <span class="comment">// 以下将冗余的缓冲区释放</span></span><br><span class="line">            <span class="keyword">for</span>(map_pointer cur = start.node; cur &lt; new_start.node; ++cur)</span><br><span class="line">                data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">            start = new_start; <span class="comment">//设定deque的新起点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">copy</span>(last, finish, first);</span><br><span class="line">            iterator new_finish = finish - n;</span><br><span class="line">            <span class="built_in">destroy</span>(new_finish, finish);</span><br><span class="line">            <span class="comment">// 以下将冗余的缓冲区释放</span></span><br><span class="line">            <span class="keyword">for</span>(map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)</span><br><span class="line">                data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">            finish = new_finish; <span class="comment">//设定deque的新尾点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start + elems_before;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后一个例子是insert。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position.cur == start.cur) &#123;</span><br><span class="line">        <span class="built_in">push_front</span>(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123;</span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        -- tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type&amp; x) &#123;</span><br><span class="line">    difference_type index = pos - start;</span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">push_front</span>(<span class="built_in">front</span>());</span><br><span class="line">        iterator front1 = start;</span><br><span class="line">        ++ front1;</span><br><span class="line">        iterator front2 = front1;</span><br><span class="line">        ++ front2;</span><br><span class="line">        pos = start + index;</span><br><span class="line">        iterator pos1 = pos;</span><br><span class="line">        ++ pos1;</span><br><span class="line">        <span class="built_in">copy</span>(front2, pos1, front1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">        iterator back1 = finish;</span><br><span class="line">        -- back1;</span><br><span class="line">        iterator back2 = back1;</span><br><span class="line">        -- back2;</span><br><span class="line">        pos = start + index;</span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="stack概述"><a href="#stack概述" class="headerlink" title="stack概述"></a>stack概述</h3><p>stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口。stack允许新增元素，移除元素、取得最顶端元素，但不允许有遍历行为。若以deque为底部结构并封闭其头端开口，便轻而易举地形成了一个stack。同时，也可以使用list作为底层实现，它也是具有双向开口的数据结构。由于stack系以底部容器完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，称为adapter(配接器)。因此，STL stack往往不被称为container，而被归类为container adapter。</p>
<p>因为stack的所有元素的进出都必须符合“先进后出”的条件，即只有stack顶端的元素，才会被外界取用，所以stack不提供走访功能，也不提供迭代器。</p>
<h3 id="stack-完整定义"><a href="#stack-完整定义" class="headerlink" title="stack 完整定义"></a>stack 完整定义</h3><p>SGI STL以deque作为缺省情况下的stack底部结构。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> stack&#123;</span><br><span class="line">    <span class="comment">// __STL_NULL_TMPL_ARGS展开为&lt;&gt;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS(<span class="type">const</span> stack&amp; , <span class="type">const</span> stack&amp;) ;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS(<span class="type">const</span> stack&amp; , <span class="type">const</span> stack&amp;) ;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::value_type value_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::size_type size_type ;	</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::reference reference ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::const_reference	const_reference ;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence e ; <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="comment">//以下完全利用Sequence c 的操作，完成stack的操作</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>() ;&#125; </span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line">	<span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">	<span class="comment">//deque是两头可进出，stack是末端进，末端出。</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_back</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> stack&lt;T, Sequence&gt;&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> stack&lt;T, Sequence&gt;&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="以list作为stack的底部容器"><a href="#以list作为stack的底部容器" class="headerlink" title="以list作为stack的底部容器"></a>以list作为stack的底部容器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; istack;</span><br><span class="line">    <span class="comment">//stack&lt;int&gt; istack; //缺省时使用deque</span></span><br><span class="line">    istack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    istack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    istack.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    istack.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; istack.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">//4</span></span><br><span class="line">    cout &lt;&lt; istack.<span class="built_in">top</span>() &lt;&lt; endl;    <span class="comment">//7</span></span><br><span class="line"> </span><br><span class="line">    istack.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; istack.<span class="built_in">top</span>() &lt;&lt; endl;    <span class="comment">//5</span></span><br><span class="line">    istack.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; istack.<span class="built_in">top</span>() &lt;&lt; endl;    <span class="comment">//3</span></span><br><span class="line">    istack.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; istack.<span class="built_in">top</span>() &lt;&lt; endl;    <span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; istack.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">//1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="queue概述"><a href="#queue概述" class="headerlink" title="queue概述"></a>queue概述</h3><p>queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口。queue允许新增元素、移除元素、从最底端加入元素、取得最顶端元素，但不允许遍历行为，也不提供迭代器。若以deque为底部结构并封闭其头端入口和尾部出口，便轻而易举地形成了一个queue。同时，也可以使用list作为底层实现，它也是具有双向开口的数据结构。因为queue的所有元素的进出都必须符合“先进先出”的条件，queue不提供走访功能，也不提供迭代器。</p>
<p>由于queue系以底部容器完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，称为adapter(配接器)。因此，STL queue往往不被称为container，而被归类为container adapter。</p>
<h3 id="queue-完整定义"><a href="#queue-完整定义" class="headerlink" title="queue 完整定义"></a>queue 完整定义</h3><p>SGI STL以deque作为缺省情况下的queue底部结构。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> queue&#123;</span><br><span class="line">    <span class="comment">// __STL_NULL_TMPL_ARGS展开为&lt;&gt;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS(<span class="type">const</span> queue&amp; , <span class="type">const</span> queue&amp;) ;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS(<span class="type">const</span> queue&amp; , <span class="type">const</span> queue&amp;) ;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::value_type value_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::size_type size_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::reference reference ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::const_reference const_reference ;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	Sequence c ; <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="comment">//以下完全利用Sequence c的操作，完成queue的操作</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">	<span class="comment">//deque是两头可进出，queue是末端进，前端出。</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type &amp;x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x) ;&#125; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_front</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> queue&lt;T, Sequence&gt;&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> queue&lt;T, Sequence&gt;&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="以list作为queue的底部容器"><a href="#以list作为queue的底部容器" class="headerlink" title="以list作为queue的底部容器"></a>以list作为queue的底部容器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; iqueue;</span><br><span class="line">	<span class="comment">//queue&lt;int&gt; iqueue; //缺省时使用deque</span></span><br><span class="line">    iqueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    iqueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    iqueue.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    iqueue.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; iqueue.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">//4</span></span><br><span class="line">    cout &lt;&lt; iqueue.<span class="built_in">front</span>() &lt;&lt; endl;  <span class="comment">//1</span></span><br><span class="line"> </span><br><span class="line">    iqueue.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; iqueue.<span class="built_in">front</span>() &lt;&lt; endl;   <span class="comment">//3</span></span><br><span class="line">    iqueue.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; iqueue.<span class="built_in">front</span>() &lt;&lt; endl;   <span class="comment">//5</span></span><br><span class="line">    iqueue.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; iqueue.<span class="built_in">front</span>() &lt;&lt; endl;   <span class="comment">//7</span></span><br><span class="line">    cout &lt;&lt; iqueue.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">//1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="heap概述"><a href="#heap概述" class="headerlink" title="heap概述"></a>heap概述</h2><p>heap并不归属于STL容器组件，扮演priority queue的助手，binary max heap适合作为priority queue的底层机制，priority queue允许用户以任意次序将元素推入容器，但是取出是一定是优先权最高（数值最高）的元素先出来。binary heap是一种complete binary tree（完全二叉树），整棵binary tree除了最底层的叶子节点外是填满的，而最底层的叶子节点由左至右不得有空隙。</p>
<p>complete binary tree整棵树内没有任何节点漏洞，这就可以利用array来存储completebinary tree的所有节点，将array的#0元素保留，那么当complete binary tree的某个节点位于array的i处时，其左子节点必位于array的2i处，右子节点必位于array的2i+1处，父节点必位于i/2处。我们需要的是一个array和一组heap算法，array的缺点是无法动态改变大小，以vector代替array是更好的选择。</p>
<p>根据元素排列方式，heap分为max-heap和min-heap两种，前者每个节点的键值都大于或等于其子节点的值，后者每个节点的键值都小于或等于其子节点的值。max-heap中最大值在根节点，min-heap最小值在根节点。底层存储结构为vector或者array。STL 供应的是max-heap。heap的所有元素都必须遵循特别的排列规则，所以heap不提供遍历功能，也不提供迭代器。</p>
<h3 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h3><h4 id="push-heap算法"><a href="#push-heap算法" class="headerlink" title="push_heap算法"></a>push_heap算法</h4><p>push_heap算法：将新加入的元素放在最下层的叶节点，即vector的<code>end()</code>处，还需满足max-heap条件，执行所谓的percolate up(上溯)过程，即不断比较新节点和其父节点，如果键值比父节点大，就父子节点对换位置，最终将其放到合适的位置。举例如下：<br><img src="/img/1609732832.jpg" alt=""></p>
<p>下面是<code>push_heap</code>的实现细节，该函数接受两个迭代器，用来表达一个heap底部容器的头尾，并且新元素已经插入到底部容器的最尾端，如果不符合这两个条件，<code>push_heap</code>的执行结果不可预期。代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomAccessIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这个函数被调用时，新元素已经放在底部容器的最尾端</span></span><br><span class="line">        _push_heap_aux(first,last,<span class="built_in">distance_type</span>(first),<span class="built_in">value_type</span>(first));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> _push_heap_aux(RandomAccessIterator first,RandomAccessIterator last,Distance*,T*)</span><br><span class="line">    &#123;_push_heap(first ,<span class="built_in">Distance</span>((last-first)<span class="number">-1</span>),<span class="built_in">Distance</span>(<span class="number">0</span>),<span class="built_in">T</span>(*(last<span class="number">-1</span>)));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一下这组push_back()不允许指定大小比较标准</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">     <span class="type">void</span> _push_heap(RandomAccessIterator first,Distance holeIndex,Distance topIndex,T value)</span><br><span class="line">    &#123;</span><br><span class="line">        Distance parent=(holeIndex<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//找出父节点</span></span><br><span class="line">        <span class="keyword">while</span>(holeIndex&gt;topIndex&amp;&amp;*(first+parent)&lt;value)&#123;</span><br><span class="line">        <span class="comment">//未到达顶端，父节点小于新值,使用&lt;,所以STL heap是个max_heap。</span></span><br><span class="line">             *(first+holeIndex)=*(first +parent)<span class="comment">//父值下移</span></span><br><span class="line">            holeIndex=parent;<span class="comment">//调整位置，向上提升至父节点</span></span><br><span class="line">            parent=(holeIndex<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//找到新的父节点。</span></span><br><span class="line">        &#125;<span class="comment">//持续到顶端，或者满足heap的特性就停止了。</span></span><br><span class="line">         *(first+holeIndex)=value;<span class="comment">//找到它应该处于的位置，插入操作结束。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h4><p>如图所示的是pop heap算法的实际操演情况。既然身为max-heap，最大值必然在根节点。pop操作取走根节点（其实是移至底部容器vector的最后一个元素）之后，为了满足complete binary tree的条件，必须将最下一层最右边的叶节点拿掉，现在我们的任务是为这个被拿掉的节点找一个适当的位置。</p>
<p>为满足max-heap的条件（每个节点的键值都大于或等于其子节点键值）, 我们执行一个所谓的percolate down（下溯）程序：将根节点（最大值被取走后，形成一个“洞”）填人上述那个失去生存空间的叶节点值，再将它拿来和其两个子节点比较键值（key），并与较大子节点对调位置、如此一直下放，直到这个“洞” 的键值大于左右两个子节点，或直到下放至叶节点为止：<br><img src="/img/1609733154.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;<span class="comment">//提供首尾两个迭代器，否则结果不可预知。</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">       __pop_heap_aux(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">   <span class="keyword">inline</span> <span class="type">void</span> __pop_heap_aux(RandomAccessIterator first,</span><br><span class="line">       RandomAccessIterator last, T*) &#123;</span><br><span class="line">       __pop_heap(first, last - <span class="number">1</span>, last - <span class="number">1</span>, <span class="built_in">T</span>(*(last - <span class="number">1</span>)), <span class="built_in">distance_type</span>(first));</span><br><span class="line">       <span class="comment">// pop动作的結果为底层容器的第一個元素。因此，首先设定欲调整值为尾值，然后將首值調至 </span></span><br><span class="line">       <span class="comment">// 尾节点（所以以上將迭代器result设为last-1）。然后重整 [first, last-1)，</span></span><br><span class="line">       <span class="comment">// 使之重新成一個合格的 heap。</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">   <span class="keyword">inline</span> <span class="type">void</span> __pop_heap(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">       RandomAccessIterator result, T value, Distance*) &#123;</span><br><span class="line">       *result = *first; <span class="comment">// 設定尾值为首值，于是尾值即是結果，</span></span><br><span class="line">       <span class="comment">// 可由调用底层容器之 pop_back() 取出尾值。</span></span><br><span class="line">       __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">       <span class="comment">// 以上欲重新調整 heap，洞号为 0，欲調整值为value。</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">   <span class="type">void</span> __adjust_heap(RandomAccessIterator first, Distance holeIndex,</span><br><span class="line">       Distance len, T value) &#123;</span><br><span class="line">       Distance topIndex = holeIndex;</span><br><span class="line">       Distance secondChild = <span class="number">2</span> * holeIndex + <span class="number">2</span>;    <span class="comment">// 洞节点之右子节点</span></span><br><span class="line">       <span class="keyword">while</span> (secondChild &lt; len) &#123;</span><br><span class="line">           <span class="comment">// 比较洞节点之左右兩个子值，然后以 secondChild 代表较大子节点。</span></span><br><span class="line">           <span class="keyword">if</span> (*(first + secondChild) &lt; *(first + (secondChild - <span class="number">1</span>)))</span><br><span class="line">               secondChild--;</span><br><span class="line">           <span class="comment">// Percolate down：令较大大子值为洞值，再令洞号下移至较大子节点处。</span></span><br><span class="line">           *(first + holeIndex) = *(first + secondChild);</span><br><span class="line">           holeIndex = secondChild;</span><br><span class="line">           <span class="comment">// 找出新洞节点的右子节点</span></span><br><span class="line">           secondChild = <span class="number">2</span> * (secondChild + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">if</span> (secondChild == len) &#123; <span class="comment">// 沒有右子节点，只有左子节点</span></span><br><span class="line">           <span class="comment">// Percolate down：令左子值为洞值，再令洞号下移至左子节点处。</span></span><br><span class="line">           *(first + holeIndex) = *(first + (secondChild - <span class="number">1</span>));</span><br><span class="line">           holeIndex = secondChild - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 將欲调整值填入目前的洞号內。注意，此時肯定滿足次序特性。</span></span><br><span class="line">       <span class="comment">// 依侯捷之见，下面直接改為 *(first + holeIndex) = value; 应该可以。</span></span><br><span class="line">       __push_heap(first, holeIndex, topIndex, value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//此时的最大元素只是被放置在了底部容器的尾端，并未被取走，所以要取值，可以使用底部容器提供的back()操作函数，如果要移除，使用pop_back().</span></span><br></pre></td></tr></table></figure>
<p>注意：pop_heap后，最大元素只是被置于底层容器的最尾部，尚未被取走。如果取值，可用back函数；如果移除，可用pop_back函数。 </p>
<h4 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h4><p>既然每次pop_heap都将最大值放到vector的末尾，那么如果每次都缩小pop_heap的参数范围（从后向前缩减一个与元素），那么最终得到的vector将是一个递增序列。<br><img src="/img/20210104160923.png" alt=""><br><img src="/img/1609759644.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下这个sort_heap()不允许指定「大小比较标准」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以下，每執行一次 pop_heap()，極值（在STL heap中為極大值）即被放在尾端。</span></span><br><span class="line">        <span class="comment">// 扣除尾端再執行一次 pop_heap()，次極值又被放在新尾端。一直下去，最後即得</span></span><br><span class="line">        <span class="comment">// 排序結果。</span></span><br><span class="line">        <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">pop_heap</span>(first, last--); <span class="comment">// 每執行 pop_heap() 一次，操作範圍即退縮一格。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h3><p>make_heap将一段现有的数据转化成一个heap，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 將 [first,last)排列为一个heap。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">        __make_heap(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下這組 make_heap() 不允許指定「大小比較標準」。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,</span><br><span class="line">        Distance*) &#123;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) <span class="keyword">return</span>;    <span class="comment">// 如果長度為 0 或 1，不必重新排列。</span></span><br><span class="line">        Distance len = last - first;</span><br><span class="line">        <span class="comment">// 找出第一個需要重排的子樹頭部，以 parent 標示出。由於任何葉節點都不需執行 </span></span><br><span class="line">        <span class="comment">// perlocate down，所以有以下計算。parent 命名不佳，名為 holeIndex 更好。</span></span><br><span class="line">        Distance parent = (len - <span class="number">2</span>) / <span class="number">2</span>;<span class="comment">//找出第一个有子节点的节点</span></span><br><span class="line">     </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 重排以 parent 為首的子樹。len 是為了讓 __adjust_heap() 判斷操作範圍</span></span><br><span class="line">            __adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent)));<span class="comment">//下溯程序</span></span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="number">0</span>) <span class="keyword">return</span>;    <span class="comment">// 排序到根節點，程序就結束。</span></span><br><span class="line">            parent--;                    <span class="comment">// （重排之子樹的）頭部向前一個節點，迭代过程，排序完一个就接着排序前一个。</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="heap测试实例"><a href="#heap测试实例" class="headerlink" title="heap测试实例"></a>heap测试实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// test heap (以vector完成)</span></span><br><span class="line">        <span class="type">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(ia, ia + <span class="number">9</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">make_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;       <span class="comment">// 9 5 8 3 4 0 2 3 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">        ivec.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">push_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;       <span class="comment">// 9 5 8 3 4 0 2 3 1 4</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">pop_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>());</span><br><span class="line">        cout &lt;&lt; ivec.<span class="built_in">back</span>() &lt;&lt; endl;     <span class="comment">// 9</span></span><br><span class="line">        ivec.<span class="built_in">pop_back</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;     <span class="comment">// 8 7 4 3 5 0 2 3 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">sort_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;    <span class="comment">// 0 1 2 3 3 4 5 7 8 </span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// test heap (以array完成)</span></span><br><span class="line">        <span class="type">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">make_heap</span>(ia, ia<span class="number">+9</span>);</span><br><span class="line">        <span class="comment">// array无法动态改变大小，因此不可以对满载的 array做 push_heap()动作。</span></span><br><span class="line">        <span class="comment">//因为那得先在 array尾端增加㆒个元素。</span></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">sort_heap</span>(ia, ia<span class="number">+9</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; ia[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 0 1 2 3 3 4 5 8 9</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">make_heap</span>(ia, ia<span class="number">+9</span>);</span><br><span class="line">        <span class="built_in">pop_heap</span>(ia, ia<span class="number">+9</span>); </span><br><span class="line">        cout &lt;&lt; ia[<span class="number">8</span>] &lt;&lt; endl;     <span class="comment">// 9</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// test heap (底层以 array完成) </span></span><br><span class="line">        <span class="type">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>&#125;; </span><br><span class="line">        <span class="built_in">make_heap</span>(ia, ia<span class="number">+6</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i) </span><br><span class="line">            cout &lt;&lt; ia[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;  <span class="comment">// 7 6 5 1 2 4</span></span><br><span class="line">        cout &lt;&lt; endl; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="priority-queue概述"><a href="#priority-queue概述" class="headerlink" title="priority_queue概述"></a>priority_queue概述</h2><p>priority_queue是一个拥有权值观念的queue，它允许加入新元素，移除旧元素，审视元素值等功能．只允许在尾部加入元素，并从头部取出元素，除此之外别无其他存取元素的途径。priority_queue缺省情况下是以vector为底层容器，再加上<strong>max-heap处理规则</strong>，STL priority_queue往往不被归类为Container(容器)，而被归类为container adapter。priority_queue的所有元素，进出都有一定规则，只有queue顶端的元素，才有机会被外界取用。它不提供遍历功能，也不提供迭代器。<br><img src="/img/1609762206.jpg" alt=""></p>
<h3 id="priority-queue-完整定义"><a href="#priority-queue-完整定义" class="headerlink" title="priority_queue 完整定义"></a>priority_queue 完整定义</h3><p>priority_queue完全以底部容器为根据，再加上heap处理规则，所以实现很简单，缺省情况下是以vector为底部容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt;,</span><br><span class="line">	<span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;        <span class="comment">//底层容器</span></span><br><span class="line">	Compare comp; <span class="comment">//元素大小比较标准</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="type">const</span> Compare&amp; x)</span> : c() comp(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">//用到heap泛型算法作为其实现</span></span><br><span class="line">	<span class="comment">//定义一个priority_queue实则是一个建堆的过程</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">	<span class="built_in">priority_queue</span>( InputIterator first,  InputIterator last, <span class="type">const</span> Compare&amp; x)</span><br><span class="line">	  : <span class="built_in">c</span> (first, last), <span class="built_in">comp</span>(x) &#123; </span><br><span class="line">        <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">priority_queue</span>( InputIterator first,  InputIterator last)</span><br><span class="line">	  : <span class="built_in">c</span> (first, last) &#123; </span><br><span class="line">        <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span>  </span>&#123;</span><br><span class="line">		__STL_TRY &#123;</span><br><span class="line">		<span class="comment">//先利用底层容器的	push_back将新元素推入末端，再重排heap</span></span><br><span class="line">			c.<span class="built_in">push_back</span>(x);</span><br><span class="line">			<span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">		&#125;</span><br><span class="line">		__STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		__STL_TRY &#123;</span><br><span class="line">		<span class="comment">//先从heap内取出一个元素，并不是简单的弹出，而是重排heap，然后在以底层容器的pop_back取得被弹出的元素</span></span><br><span class="line">			<span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">			c.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		__STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="priority-queue测试实例"><a href="#priority-queue测试实例" class="headerlink" title="priority_queue测试实例"></a>priority_queue测试实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test priority queue</span></span><br><span class="line">    <span class="type">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">ipq</span><span class="params">(ia, ia + <span class="number">9</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ipq.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ipq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; ipq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(!ipq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; ipq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        ipq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">————————————————————————————————————————————————————————————————————</span><br><span class="line">[root@<span class="number">192</span> <span class="number">4</span>_STL_sequence_container]# ./<span class="number">4</span>_8_4_pqueue-test</span><br><span class="line">size=<span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="slist概述"><a href="#slist概述" class="headerlink" title="slist概述"></a>slist概述</h2><p>SGI STL另提供一个单向链表slist。slist和list的主要差别在于，前者的迭代器属于单向的Forward Iterator，后者的迭代器属于双向的BidirectionalIterator。slist的功能自然也受到一些限制，不过单向链表所耗用的空间更小，某些操作更快，不失为一种选择。slist和list共同的特点是，插入删除等操作不会造成原有的迭代器失效。</p>
<p>根据STL的习惯，插入操作会将新元素插入于指定位置之前。作为单向链表，slist没有任何方便的方法可以回头定出前一个位置，因此它必须从头找起。为此，slist特别提供了<code>insert_after</code>和<code>erase_after</code>函数供灵活调用。</p>
<h3 id="slist的节点"><a href="#slist的节点" class="headerlink" title="slist的节点"></a>slist的节点</h3><p>slist节点和其迭代器的设计，运用了继承关系：<br><img src="/img/1609764727.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_node_base</span> &#123;</span><br><span class="line">    __slist_node_base *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_node</span> : <span class="keyword">public</span> __slist_node_base</span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> __slist_node_base* __slist_make_link(__slist_node_base* prev_node, __slist_node_base* new_node) &#123;</span><br><span class="line">    <span class="comment">// 令new节点的下一节点为prev节点的下一节点</span></span><br><span class="line">    new_node-&gt;next = prev_node-&gt;next;</span><br><span class="line">    prev_node-&gt;next = new_node;</span><br><span class="line">    <span class="keyword">return</span> new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __slist_size(__slist_node_base* node) &#123;</span><br><span class="line">    <span class="type">size_t</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; node != <span class="number">0</span>; node = node-&gt;next)</span><br><span class="line">        ++ result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slist的迭代器"><a href="#slist的迭代器" class="headerlink" title="slist的迭代器"></a>slist的迭代器</h3><p><img src="/img/1609765004.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向链表的迭代器基本结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_iterator_base</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line"></span><br><span class="line">    __slist_node_base* node;</span><br><span class="line">    __slist_iterator_base(__slist_node_base*x) : <span class="built_in">node</span>(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123;node = node-&gt;next;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> __slist_iterator_base&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node == x.node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> __slist_iterator_base&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node != x.node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表的迭代器结构</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_iterator</span> : <span class="keyword">public</span> __slist_iterator_base </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_iteratror&lt;T, T&amp;, T*&gt;  iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_iteratror&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_iteratror&lt;T, Ref, Ptr&gt; self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_node&lt;T&gt; list_node;</span><br><span class="line"></span><br><span class="line">    __slist_iterator(list_node* x) : __slist_iterator_base(x) &#123;&#125;</span><br><span class="line">    <span class="comment">// 调用slist&lt;T&gt;::end()时会造成__slist_iterator(0)，于是调用上述函数</span></span><br><span class="line">    __slist_iterator() : __slist_iterator_base(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    __slist_iterator(<span class="type">const</span> iterator&amp; x) : __slist_iterator_base(x.node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> ((list_node*) node)-&gt;data; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">incr</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">incr</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slist的数据结构"><a href="#slist的数据结构" class="headerlink" title="slist的数据结构"></a>slist的数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> slist</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	T	value_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	value_type*	pointer ; </span><br><span class="line">	<span class="keyword">typedef</span>	<span class="type">const</span>	value_type*	const_pointer ;</span><br><span class="line">	<span class="keyword">typedef</span>	value_type&amp;	reference ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="type">const</span> value_type&amp; const_reference ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="type">size_t</span>	size_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="type">ptrdiff_t</span>	difference_type ;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">typedef</span>	__slist_iterator&lt;T,T&amp;,T*&gt;	iterator ;</span><br><span class="line">	<span class="keyword">typedef</span>	__slist_iterator&lt;T,<span class="type">const</span> T&amp;,<span class="type">const</span> T*&gt; const_iterator ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	__slist_node&lt;T&gt;	list_node ;</span><br><span class="line">	<span class="keyword">typedef</span>	__slist_node_base	list_node_base ;</span><br><span class="line">	<span class="keyword">typedef</span>	__slist_iterator_base	iterator_base ;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;list_node,Alloc&gt; list_node_allocator ;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">static</span>	list_node* <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		list_node* node = list_node_allocator:;<span class="built_in">allocate</span>() ; <span class="comment">//配置空间</span></span><br><span class="line">		__STL_TRY&#123;</span><br><span class="line">			<span class="built_in">construct</span>(&amp;node-&gt;data,x) ;</span><br><span class="line">			node-&gt;next = <span class="number">0</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		__STL_UNWIND(list_node_allocator:;<span class="built_in">deallocate</span>(node)) ;</span><br><span class="line">		<span class="keyword">return</span> node ;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy_node</span><span class="params">(list_node* node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">destroy</span>(&amp;node-&gt;data) ; <span class="comment">//将元素析构	</span></span><br><span class="line">		list_node_allocator::<span class="built_in">deallocate</span>(node) ; <span class="comment">//释放空间</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">	list_node_base head  ; <span class="comment">//头部。注意，它不是指针，是实物</span></span><br><span class="line">			</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">slist</span>() &#123;head.next = <span class="number">0</span> ;&#125; </span><br><span class="line">	~<span class="built_in">slist</span>()&#123;<span class="built_in">clear</span>() ;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>((list_node*)head.next) ;&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">iteator</span>(<span class="number">0</span>) ;&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="type">const</span> __slist_size(head.next) ;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> head.next == <span class="number">0</span> ;&#125; </span><br><span class="line"> </span><br><span class="line">	<span class="comment">//两个slist互换：只要将head交换互指即可</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(slist &amp;L)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		list_node_base* tmp = head.next;</span><br><span class="line">		head.next = L.head.next ;</span><br><span class="line">		L.head.next = tmp ;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="comment">//取头部元素</span></span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ((list_node*)head.next)-&gt;data ;&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//从头部插入元素(新元素成为slist的第一个元素)</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		__slist_make_link(&amp;head,<span class="built_in">create_node</span>(x)) ;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//注意,没有push_back()</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//从头部取走元素(删除之)。修改head</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		list_node* node = (list_node*)head.next ;</span><br><span class="line">		head.next = node-&gt;next ;</span><br><span class="line">		<span class="built_in">destroy_node</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line">	.....</span><br><span class="line">&#125;  ;</span><br></pre></td></tr></table></figure>
<h3 id="slist的测试实例"><a href="#slist的测试实例" class="headerlink" title="slist的测试实例"></a>slist的测试实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 4slist-test.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// mingw64没有这个库</span></span><br><span class="line"><span class="comment">//#include &lt;slist&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    slist&lt;<span class="type">int</span>&gt; islist;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; islist.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    islist.<span class="built_in">push_front</span>(<span class="number">9</span>); </span><br><span class="line">    islist.<span class="built_in">push_front</span>(<span class="number">1</span>); </span><br><span class="line">    islist.<span class="built_in">push_front</span>(<span class="number">2</span>); </span><br><span class="line">    islist.<span class="built_in">push_front</span>(<span class="number">3</span>); </span><br><span class="line">    islist.<span class="built_in">push_front</span>(<span class="number">4</span>); </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; islist.<span class="built_in">size</span>() &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    slist&lt;<span class="type">int</span>&gt;::iterator ite =islist.<span class="built_in">begin</span>(); </span><br><span class="line">    slist&lt;<span class="type">int</span>&gt;::iterator ite2=islist.<span class="built_in">end</span>(); </span><br><span class="line">    <span class="keyword">for</span>(; ite != ite2; ++ite) </span><br><span class="line">        cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>;  <span class="comment">// 4 3 2 1 9</span></span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    ite = <span class="built_in">find</span>(islist.<span class="built_in">begin</span>(), islist.<span class="built_in">end</span>(), <span class="number">1</span>); <span class="comment">//使用STL的find函数，可以找到1之前的那个迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (ite!=<span class="number">0</span>) </span><br><span class="line">        islist.<span class="built_in">insert</span>(ite, <span class="number">99</span>); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; islist.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// size=6</span></span><br><span class="line">    cout &lt;&lt; *ite &lt;&lt; endl;     <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line">    ite =islist.<span class="built_in">begin</span>(); </span><br><span class="line">    ite2=islist.<span class="built_in">end</span>(); </span><br><span class="line">    <span class="keyword">for</span>(; ite != ite2; ++ite) </span><br><span class="line">        cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 4 3 2 99 1 9 </span></span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    ite = <span class="built_in">find</span>(islist.<span class="built_in">begin</span>(), islist.<span class="built_in">end</span>(), <span class="number">3</span>); </span><br><span class="line">    <span class="keyword">if</span> (ite!=<span class="number">0</span>) </span><br><span class="line">        cout &lt;&lt; *(islist.<span class="built_in">erase</span>(ite)) &lt;&lt; endl;  <span class="comment">// 2</span></span><br><span class="line"> </span><br><span class="line">    ite =islist.<span class="built_in">begin</span>(); </span><br><span class="line">    ite2=islist.<span class="built_in">end</span>(); </span><br><span class="line">    <span class="keyword">for</span>(; ite != ite2; ++ite) </span><br><span class="line">        cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>;    <span class="comment">// 4 2 99 1 9</span></span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/1609767703.jpg" alt=""><br><img src="/img/1609767737.jpg" alt=""></p>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>insert函数的实现如下，<code>__slist_previous</code>函数可以根据头节点<code>_M_head</code>和位置节点<code>__pos</code>找到<code>__pos</code>之前的那个节点，然后调用<code>_M_insert_after</code>函数，实际调用<code>__slist_make_link</code>，在<code>__pos-1</code>节点后创建以<code>__x</code>为值的节点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">islist.<span class="built_in">insert</span>(ite, <span class="number">99</span>); </span><br><span class="line"> </span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator __pos, <span class="type">const</span> value_type&amp; __x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(_M_insert_after(__slist_previous(&amp;<span class="keyword">this</span>-&gt;_M_head,</span><br><span class="line">                                                     __pos._M_node),</span><br><span class="line">                    __x));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> _Slist_node_base* __slist_previous(_Slist_node_base* __head,</span><br><span class="line">                 <span class="type">const</span> _Slist_node_base* __node)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (__head &amp;&amp; __head-&gt;_M_next != __node)</span><br><span class="line">    __head = __head-&gt;_M_next;</span><br><span class="line">  <span class="keyword">return</span> __head;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">_Node* _M_insert_after(_Node_base* __pos, <span class="type">const</span> value_type&amp; __x) &#123;</span><br><span class="line">    <span class="keyword">return</span> (_Node*) (__slist_make_link(__pos, _M_create_node(__x)));</span><br></pre></td></tr></table></figure></p>
<h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><p>根据“数据在容器中的排列”特性，容器可概分为序列式（sequence）和关联式（associative）两种。标准的STL关联式容器分为set（集合〕和map（映射表）两大类：以及这两大类的衍生体multi-set（多键集合）和multimap（多键映射表）。这些容器的底层机制均以RB-tree（红黑树）完成。RB-tree也是一个独立容器，但并不开放给外界使用。</p>
<h2 id="RB-tree概述"><a href="#RB-tree概述" class="headerlink" title="RB-tree概述"></a>RB-tree概述</h2><p>首先介绍一下基本概念，二叉树：任何节点最多只有两个子节点，这两个子节点分别称为左子节点和右子节点。二叉搜索树：任何节点的键值一定大于其左子树中的每一个节点的键值，小于其右子树中的每一个节点的键值。所谓的RB-tree不仅是二叉搜索树，而且必须满足以下规则：</p>
<ul>
<li>每个节点不是红色就是黑色。</li>
<li>根节点为黑色。</li>
<li>如果节点为红色，其子节点必须为黑色。</li>
<li>任意一个节点到到NULL（树尾端）的任何路径，所含之黑色节点数必须相同。</li>
</ul>
<p>根据规则4，新增节点必须为红色；根据规则3，新增节点之父节点必须为黑色。当新增节点根据二叉搜索树的规则到达其插入点时，却未能符合上述条件时，就必须调整颜色并旋转树形，如下图：<br><img src="/img/1609849157.jpg" alt=""></p>
<p>插入节点，会导致不满足RB-tree的规则条件，经历左旋和右旋等操作，使得重新满足规则。</p>
<h3 id="RB-tree节点设计"><a href="#RB-tree节点设计" class="headerlink" title="RB-tree节点设计"></a>RB-tree节点设计</h3><p>RB-tree的节点和迭代器都是双层结构，RB-tree迭代器的前进和后退操作，都是调用基础迭代器的increment和decrement实现的。RB-tree的极值通过minimum和maximum可以方便地查找到，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>;     <span class="comment">// 红色为0</span></span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>; <span class="comment">// 黑色为1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"> </span><br><span class="line">  color_type color;     <span class="comment">// 节点颜色，红色或黑色</span></span><br><span class="line">  base_ptr parent;      <span class="comment">// 该指针指向其父节点</span></span><br><span class="line">  base_ptr left;        <span class="comment">// 指向左节点</span></span><br><span class="line">  base_ptr right;       <span class="comment">// 指向右节点</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	 <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left; <span class="comment">//一直向左走，找到最小值</span></span><br><span class="line">	 <span class="keyword">return</span> x;                            </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right; <span class="comment">//一直向右走，找到最大值</span></span><br><span class="line">    <span class="keyword">return</span> x;                           </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node</span> : <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  Value value_field;   <span class="comment">//节点值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="RB-tree的迭代器"><a href="#RB-tree的迭代器" class="headerlink" title="RB-tree的迭代器"></a>RB-tree的迭代器</h3><p>为了更大的弹性，RB-tree迭代器实现为两层，下图即为双层节点结构和双层迭代器结构之间的关系，<code>__rb_tree_node</code>继承自<code>__rb_tree_node_base</code>，<code>__rb_tree_iterator</code>继承自<code>__rb_tree_base_iterator</code>。<br><img src="/img/1609849605.jpg" alt=""></p>
<p>RB-tree迭代器属于双向迭代器，但不具备随机定位能力，其提领操作和成员访问操作与list十分近似，较为特殊的是其前进和后退操作：注意，RB-tree迭代器的前进操作<code>operator()++</code>调用了基层迭代器的<code>increment()</code>，RB-tree迭代器的后退操作<code>operator--()</code>则调用了基层迭代器的<code>decrement()</code>。前进或后退的举止行为完全依据二叉搜索树的节点排列法则，再加上实现上的某些特殊技巧。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基层迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_base_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	base_ptr node; <span class="comment">//与容器之间生成一个连结关系</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;right != <span class="number">0</span>) &#123;</span><br><span class="line">			node = node-&gt;right;</span><br><span class="line">			<span class="keyword">while</span>(node-&gt;left != <span class="number">0</span>)</span><br><span class="line">				node = node-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果有右子节点。状况（1），就向右走。然后一直往左子树走到底，即是解答 </span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 没有右子节点。状况（2），找出父节点。如果现行节点本身是个右子节点，就一直上溯，直到“不为右子节点”止 </span></span><br><span class="line">			base_ptr y = node-&gt;parent;</span><br><span class="line">			<span class="keyword">while</span>(node == y-&gt;right) &#123;</span><br><span class="line">				node = y;</span><br><span class="line">				y = y-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right != y)</span><br><span class="line">				node = y;</span><br><span class="line">			<span class="comment">// 若此时的右子节点不等于此时的父节点，状况（3）此时的父节点即为解答。否则此时的node为解答。状况（4）</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以下其实可实现于operator--内，因为再无他处会调用此函数了</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;color == ＿rb_tree_red &amp;&amp; node-&gt;parent-&gt;parent == node)</span><br><span class="line">			node = node-&gt;right;</span><br><span class="line">		<span class="comment">// 如果是红节点、且父节点的父节点等于自己，状况（1）右子节点即为解答</span></span><br><span class="line">		<span class="comment">// 以上情况发生于node为header时（亦即node为end()时）</span></span><br><span class="line">		<span class="comment">// 注意，header之右子节点即mostright，指向整棵树的max节点</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;left != <span class="number">0</span>) &#123;</span><br><span class="line">			base_ptr y = node-&gt;left;</span><br><span class="line">			<span class="keyword">while</span>(y-&gt;right != <span class="number">0</span>)</span><br><span class="line">				y = y-&gt;right;</span><br><span class="line">			node = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果有左子节点。状况（2）令y指向左子节点。当y有右子节点时，一直往右子节点走到底，最后即为答案</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			base_ptr y = node-&gt;parent;</span><br><span class="line">			<span class="keyword">while</span> (node == y-&gt;left) &#123;</span><br><span class="line">				node = y;</span><br><span class="line">				y = y-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			node = y;</span><br><span class="line">		<span class="comment">// 既非根节点，亦无左子节点，状况（3）找出父节点。当现行节点身为左子节点，一直交替往上走，直到现行节点不为左子节点</span></span><br><span class="line">		<span class="comment">// 此时之父节点即为答案</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_iterator</span> : <span class="keyword">public</span> __rb_tree_base_iterator </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt; iterator; </span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, <span class="type">const</span> value&amp;, <span class="type">const</span> value*&gt; const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Ref, Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line"></span><br><span class="line">	__rb_tree_iterator()&#123;&#125;</span><br><span class="line">	__rb_tree_iterator(link_type x) &#123; node = x; &#125;</span><br><span class="line">	__rb_tree_iterator (<span class="type">const</span> iterator&amp; it) &#123; node = it.node; &#125;</span><br><span class="line"></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">link_type</span>(node)-&gt;value_field; &#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">		pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span> <span class="comment">/*_SGI_STL_NO_ARROW_OPERATOR*/</span> </span></span><br><span class="line">	</span><br><span class="line">	selt&amp; <span class="keyword">operator</span>++()&#123; <span class="built_in">increment</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		self tmp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="built_in">increment</span>(); </span><br><span class="line">		<span class="keyword">return</span> tmp; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>--() &#123;<span class="built_in">decrement</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">		self tmp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="built_in">decrement</span>();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609927285.jpg" alt=""></p>
<h3 id="RB-tree数据结构"><a href="#RB-tree数据结构" class="headerlink" title="RB-tree数据结构"></a>RB-tree数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stl_tree.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_INTERNAL_TREE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SGI_STL_INTERNAL_TREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Red-black tree（红黑树）class，用来当做SLT关联容器的底层机制（如set，multiset，map，</span></span><br><span class="line"><span class="comment">multimap）。里面所用的insertion和deletion方法以Cormen, Leiserson 和 Riveset所著的</span></span><br><span class="line"><span class="comment">《算法导论》一书为基础，但是有以下两点不同:</span></span><br><span class="line"><span class="comment">(1)header不仅指向root，也指向红黑树的最左节点，以便用常数时间实现begin()，并且也指向红黑树的最右边节点，以便</span></span><br><span class="line"><span class="comment">set相关泛型算法（如set_union等等）可以有线性时间实现。</span></span><br><span class="line"><span class="comment">(2)当一个即将被删除的节点有两个孩子节点时，它的successor（后继）node is relinked into its place, ranther than copied,</span></span><br><span class="line"><span class="comment">如此一来唯一失效的（invalidated）的迭代器就只是那些referring to the deleted node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_algobase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_alloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_construct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_function.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>,</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> rb_tree &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//这里没有定义iterator，在后面定义</span></span><br><span class="line">	<span class="keyword">typedef</span> Key key_type;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">allocate</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; rb_tree_node_allocator::<span class="built_in">deallocate</span>(p); &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">		link_type tmp = <span class="built_in">get_node</span>();			<span class="comment">// 配置空间</span></span><br><span class="line">		__STL_TRY&#123;</span><br><span class="line">			<span class="built_in">construct</span>(&amp;tmp-&gt;value_field, x);	<span class="comment">// 构建内容</span></span><br><span class="line">		&#125;</span><br><span class="line">		__STL_UNWIND(<span class="built_in">put_node</span>(tmp));</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span> </span>&#123;	<span class="comment">// 复制一个节点（值和颜色）</span></span><br><span class="line">		link_type tmp = <span class="built_in">create_node</span>(x-&gt;value_field);</span><br><span class="line">		tmp-&gt;color = x-&gt;color;</span><br><span class="line">		tmp-&gt;left = <span class="number">0</span>;</span><br><span class="line">		tmp-&gt;right = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">destroy</span>(&amp;p-&gt;value_field);		<span class="comment">// 析构内容</span></span><br><span class="line">		<span class="built_in">put_node</span>(p);		                <span class="comment">// 释放内存</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// RB-tree 只以三个资料表现</span></span><br><span class="line">	size_type node_count; <span class="comment">// 追踪记录树的大小（节点总数）</span></span><br><span class="line">	link_type header;     <span class="comment">//这个是实现上的一个技巧</span></span><br><span class="line">	Compare key_compare;	 <span class="comment">// 节点的键值比较判断准则。是个函数 function object。</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//以下三个函数用来方便取得header的成员</span></span><br><span class="line">	<span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)header-&gt;parent; &#125;</span><br><span class="line">	<span class="function">link_type&amp; <span class="title">leftmost</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)header-&gt;left; &#125;</span><br><span class="line">	<span class="function">link_type&amp; <span class="title">rightmost</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)header-&gt;right; &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//以下六个函数用来方便取得节点x的成员。x为函数参数</span></span><br><span class="line">	<span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> x-&gt;value_field; &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x)); &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(x-&gt;color); &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//和上面六个作用相同，注意x参数类型不同。一个是基类指针，一个是派生类指针</span></span><br><span class="line">	<span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> ((link_type)x)-&gt;value_field; &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(<span class="built_in">link_type</span>(x))); &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(<span class="built_in">link_type</span>(x)-&gt;color); &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//找最大值和最小值。node class 有这个功能函数</span></span><br><span class="line">	<span class="function"><span class="type">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type)__rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type)__rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, reference, pointer&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, const_reference, const_pointer&gt;</span><br><span class="line">		const_iterator;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">	<span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">	<span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;iterator, value_type, reference,</span><br><span class="line">		difference_type&gt;</span><br><span class="line">		reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;const_iterator, value_type,</span><br><span class="line">		const_reference, difference_type&gt;</span><br><span class="line">		const_reverse_iterator;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span> </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	iterator __insert(base_ptr x, base_ptr y, <span class="type">const</span> value_type&amp; v);</span><br><span class="line">	link_type __copy(link_type x, link_type p);</span><br><span class="line">	<span class="type">void</span> __erase(link_type x);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		header = <span class="built_in">get_node</span>();	<span class="comment">// 产生一个节点空间，令header指向它</span></span><br><span class="line">		<span class="built_in">color</span>(header) = __rb_tree_red; <span class="comment">// 令 header 尾红色，用來区 header  </span></span><br><span class="line">		<span class="comment">// 和 root（在 iterator.operator++ 中）</span></span><br><span class="line">		<span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">leftmost</span>() = header;	<span class="comment">// 令 header 的左孩子为自己。</span></span><br><span class="line">		<span class="built_in">rightmost</span>() = header;	<span class="comment">// 令 header 的右孩子为自己。</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认构造函数                           // allocation/deallocation</span></span><br><span class="line">	<span class="built_in">rb_tree</span>(<span class="type">const</span> Compare&amp; comp = <span class="built_in">Compare</span>())</span><br><span class="line">		: <span class="built_in">node_count</span>(<span class="number">0</span>), <span class="built_in">key_compare</span>(comp) &#123;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 以另一个 rb_tree  x 初始化</span></span><br><span class="line">	<span class="built_in">rb_tree</span>(<span class="type">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x)</span><br><span class="line">		: <span class="built_in">node_count</span>(<span class="number">0</span>), <span class="built_in">key_compare</span>(x.key_compare)</span><br><span class="line">	&#123;</span><br><span class="line">		header = <span class="built_in">get_node</span>();</span><br><span class="line">		<span class="built_in">color</span>(header) = __rb_tree_red;</span><br><span class="line">		<span class="keyword">if</span> (x.<span class="built_in">root</span>() == <span class="number">0</span>) &#123;	<span class="comment">//  如果 x 空树</span></span><br><span class="line">			<span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">leftmost</span>() = header;</span><br><span class="line">			<span class="built_in">rightmost</span>() = header;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;	<span class="comment">//  x 不是空树</span></span><br><span class="line">			__STL_TRY&#123;</span><br><span class="line">			<span class="built_in">root</span>() = __copy(x.<span class="built_in">root</span>(), header);		<span class="comment">// 拷贝红黑树x </span></span><br><span class="line">		&#125;</span><br><span class="line">			__STL_UNWIND(<span class="built_in">put_node</span>(header));</span><br><span class="line">			<span class="built_in">leftmost</span>() = <span class="built_in">minimum</span>(<span class="built_in">root</span>());	<span class="comment">// 令 header 的左孩子为最小节点</span></span><br><span class="line">			<span class="built_in">rightmost</span>() = <span class="built_in">maximum</span>(<span class="built_in">root</span>());	<span class="comment">// 令 header 的右孩子为最大节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		node_count = x.node_count;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">rb_tree</span>() &#123;</span><br><span class="line">		<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">put_node</span>(header);</span><br><span class="line">	&#125;</span><br><span class="line">	rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp;</span><br><span class="line">		<span class="keyword">operator</span>=(<span class="type">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// accessors:</span></span><br><span class="line">	<span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> key_compare; &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leftmost</span>(); &#125;		<span class="comment">// RB 树的起始为最左（最小节点）</span></span><br><span class="line">	<span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leftmost</span>(); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;	<span class="comment">// RB 树的终节点为header所指处</span></span><br><span class="line">	<span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line">	<span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">end</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line">	<span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">begin</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node_count == <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node_count; &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; t)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//RB-tree只有三个资料表现成员，所以两颗RB-tree互换时，只需互换3个成员</span></span><br><span class="line">		__STD::<span class="built_in">swap</span>(header, t.header);</span><br><span class="line">		__STD::<span class="built_in">swap</span>(node_count, t.node_count);</span><br><span class="line">		__STD::<span class="built_in">swap</span>(key_compare, t.key_compare);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// insert/erase</span></span><br><span class="line">	<span class="comment">// 将 x 安插到 RB-tree 中（保持节点值独一无二）。</span></span><br><span class="line">	<span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">	<span class="comment">// 将 x 安插到 RB-tree 中（允许重复节点）</span></span><br><span class="line">	<span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">iterator <span class="title">insert_unique</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">	<span class="function">iterator <span class="title">insert_equal</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_unique</span><span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_equal</span><span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_unique</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type* first, <span class="type">const</span> value_type* last)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_equal</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type* first, <span class="type">const</span> value_type* last)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>;</span><br><span class="line">	<span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type* first, <span class="type">const</span> key_type* last)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node_count != <span class="number">0</span>) &#123;</span><br><span class="line">			__erase(<span class="built_in">root</span>());</span><br><span class="line">			<span class="built_in">leftmost</span>() = header;</span><br><span class="line">			<span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">rightmost</span>() = header;</span><br><span class="line">			node_count = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 集合（set）的各种操作行为</span></span><br><span class="line">	<span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">	<span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">	<span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">	<span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">	<span class="function">pair&lt;const_iterator, const_iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Debugging.</span></span><br><span class="line">	<span class="type">bool</span> __rb_verify() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x,</span><br><span class="line">	<span class="type">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; y) &#123;</span><br><span class="line">	<span class="keyword">return</span> x.<span class="built_in">size</span>() == y.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">equal</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), y.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt; 运算符，使用的是STL泛型算法lexicographical_compare</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x, <span class="type">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; y) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">lexicographical_compare</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), y.<span class="built_in">begin</span>(), y.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x,</span></span></span><br><span class="line"><span class="params"><span class="function">	rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; y)</span> </span>&#123;</span><br><span class="line">	x.<span class="built_in">swap</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_FUNCTION_TMPL_PARTIAL_ORDER */</span></span></span><br><span class="line"><span class="comment">//重载赋值运算符=</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp;</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::</span><br><span class="line"><span class="keyword">operator</span>=(<span class="type">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;x) &#123;<span class="comment">//防止自身赋值</span></span><br><span class="line">		<span class="comment">// Note that Key may be a constant type.</span></span><br><span class="line">		<span class="built_in">clear</span>();<span class="comment">//先清除</span></span><br><span class="line">		node_count = <span class="number">0</span>;</span><br><span class="line">		key_compare = x.key_compare;</span><br><span class="line">		<span class="keyword">if</span> (x.<span class="built_in">root</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">leftmost</span>() = header;</span><br><span class="line">			<span class="built_in">rightmost</span>() = header;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">root</span>() = __copy(x.<span class="built_in">root</span>(), header);</span><br><span class="line">			<span class="built_in">leftmost</span>() = <span class="built_in">minimum</span>(<span class="built_in">root</span>());</span><br><span class="line">			<span class="built_in">rightmost</span>() = <span class="built_in">maximum</span>(<span class="built_in">root</span>());</span><br><span class="line">			node_count = x.node_count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KoV</span>, <span class="keyword">class</span> <span class="title class_">Cmp</span>, <span class="keyword">class</span> <span class="title class_">Al</span>&gt; <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">II</span>&gt;</span><br><span class="line"><span class="type">void</span> rb_tree&lt;K, V, KoV, Cmp, Al&gt;::<span class="built_in">insert_equal</span>(II first, II last) &#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		<span class="built_in">insert_equal</span>(*first);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KoV</span>, <span class="keyword">class</span> <span class="title class_">Cmp</span>, <span class="keyword">class</span> <span class="title class_">Al</span>&gt; <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">II</span>&gt;</span><br><span class="line"><span class="type">void</span> rb_tree&lt;K, V, KoV, Cmp, Al&gt;::<span class="built_in">insert_unique</span>(II first, II last) &#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		<span class="built_in">insert_unique</span>(*first);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KoV</span>, <span class="keyword">class</span> <span class="title class_">Cmp</span>, <span class="keyword">class</span> <span class="title class_">Al</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">rb_tree&lt;K, V, KoV, Cmp, Al&gt;::<span class="built_in">insert_equal</span>(<span class="type">const</span> V* first, <span class="type">const</span> V* last) &#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		<span class="built_in">insert_equal</span>(*first);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KoV</span>, <span class="keyword">class</span> <span class="title class_">Cmp</span>, <span class="keyword">class</span> <span class="title class_">Al</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">rb_tree&lt;K, V, KoV, Cmp, Al&gt;::<span class="built_in">insert_equal</span>(const_iterator first,</span><br><span class="line">const_iterator last) &#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		<span class="built_in">insert_equal</span>(*first);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KoV</span>, <span class="keyword">class</span> <span class="title class_">Cmp</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">rb_tree&lt;K, V, KoV, Cmp, A&gt;::<span class="built_in">insert_unique</span>(<span class="type">const</span> V* first, <span class="type">const</span> V* last) &#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		<span class="built_in">insert_unique</span>(*first);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">KoV</span>, <span class="keyword">class</span> <span class="title class_">Cmp</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">rb_tree&lt;K, V, KoV, Cmp, A&gt;::<span class="built_in">insert_unique</span>(const_iterator first,</span><br><span class="line">const_iterator last) &#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		<span class="built_in">insert_unique</span>(*first);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="RB-tree的构造与内存管理"><a href="#RB-tree的构造与内存管理" class="headerlink" title="RB-tree的构造与内存管理"></a>RB-tree的构造与内存管理</h3><p>下面是RB-tree所定义的专属空间配置器<code>rb_tree_node_allocator</code>，每次可恰恰配置一个节点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> rb_tree &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;</span><br></pre></td></tr></table></figure></p>
<p>rb-tree的构造方式有两种，一种是以现有的rb-tree构造一个新的rb-tree，另一种是构造一个空空如也的新树。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rb_tree&lt;<span class="type">int</span>, <span class="type">int</span>, identity&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt; itree;</span><br></pre></td></tr></table></figure><br>然后调用构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rb_tree</span>(<span class="type">const</span> Compare&amp; comp = <span class="built_in">Compare</span>()) : <span class="built_in">node_count</span>(<span class="number">0</span>), <span class="built_in">key_compare</span>(comp) &#123; <span class="built_in">init</span>(); &#125;</span><br></pre></td></tr></table></figure><br>其中的<code>init()</code>是一个关键点<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	header = <span class="built_in">get_node</span>();	<span class="comment">// 产生一个节点空间，令header指向它</span></span><br><span class="line">	<span class="built_in">color</span>(header) = __rb_tree_red; <span class="comment">// 令 header 尾红色，用來区 header  </span></span><br><span class="line">	<span class="comment">// 和 root（在 iterator.operator++ 中）</span></span><br><span class="line">	<span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">leftmost</span>() = header;	<span class="comment">// 令 header 的左孩子为自己。</span></span><br><span class="line">	<span class="built_in">rightmost</span>() = header;	<span class="comment">// 令 header 的右孩子为自己。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>STL为根节点再设计了一个父节点：<br><img src="/img/1609934235.png" alt=""></p>
<h3 id="RB-tree的元素操作"><a href="#RB-tree的元素操作" class="headerlink" title="RB-tree的元素操作"></a>RB-tree的元素操作</h3><p>RB-tree提供两种插入操作：<code>insert_unique()</code>和<code>insert_equal()</code>，前者标识被插入节点的键值（key）在整棵树中必须独一无二（因此，如果整棵树中已存在相同的键值，插入操作就不会真正进行），后者标识被插入节点的键值在整棵树中可以重复，因此，无论如何插入都会成功（除非空间不足导致配置失败）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 安插新值；允许键值重复。返回新插入节点的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_equal</span>(<span class="type">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">	link_type y = header;</span><br><span class="line">	link_type x = <span class="built_in">root</span>();</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="number">0</span>) &#123;		<span class="comment">// 从根节点开始，向下寻找适当安插位置</span></span><br><span class="line">		y = x;</span><br><span class="line">		x = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)) ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __insert(x, y, v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">不允许键值重复，否则安插无效。</span></span><br><span class="line"><span class="comment">返回值是个pair，第一个元素是个RB-tree迭代器，指向新增节点。</span></span><br><span class="line"><span class="comment">第二个元素表示安插是否成功。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">pair&lt;<span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator, <span class="type">bool</span>&gt;</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_unique</span>(<span class="type">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">	link_type y = header;</span><br><span class="line">	link_type x = <span class="built_in">root</span>();  <span class="comment">//从根节点开始</span></span><br><span class="line">	<span class="type">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="number">0</span>) &#123; 		<span class="comment">// 从根节点开始向下寻找适当安插位置</span></span><br><span class="line">		y = x;</span><br><span class="line">		comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)); <span class="comment">// v 键值小于目前节点的键值？</span></span><br><span class="line">		x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);	<span class="comment">// 遇「大」往左，遇「小于或等于」往右</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//离开while循环之后，y所指即为安插点的父节点，x必为叶子节点</span></span><br><span class="line"> </span><br><span class="line">	iterator j = <span class="built_in">iterator</span>(y);   <span class="comment">// 令迭代器j指向安插点之父节点 y</span></span><br><span class="line">	<span class="keyword">if</span> (comp)	<span class="comment">//如果离开while循环时comp为真，表示 父节点键值&gt;v ，将安插在左孩子处</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="built_in">begin</span>())   <span class="comment">// 如果j是最左节点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(__insert(x, y, v), <span class="literal">true</span>);</span><br><span class="line">	<span class="comment">// 以上，x 为安插点，y 为安插点之父节点，v 为新值。</span></span><br><span class="line">	<span class="keyword">else</span>	<span class="comment">// 否则（安插点之父节点不是最左节点）</span></span><br><span class="line">		--j;	<span class="comment">// 调整 j，回头准备测试...</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node), <span class="built_in">KeyOfValue</span>()(v)))</span><br><span class="line">		<span class="comment">// 小于新值（表示遇「小」，将安插于右侧）</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(__insert(x, y, v), <span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//若运行到这里，表示键值有重复，不应该插入</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Val</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Val, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Val, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_unique</span>(iterator position,</span><br><span class="line"><span class="type">const</span> Val&amp; v) &#123;</span><br><span class="line">	<span class="keyword">if</span> (position.node == header-&gt;left) <span class="comment">// begin()</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(position.node)))</span><br><span class="line">		<span class="keyword">return</span> __insert(position.node, position.node, v);</span><br><span class="line">	<span class="comment">// first argument just needs to be non-null </span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">insert_unique</span>(v).first;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (position.node == header) <span class="comment">// end()</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(<span class="built_in">rightmost</span>()), <span class="built_in">KeyOfValue</span>()(v)))</span><br><span class="line">		<span class="keyword">return</span> __insert(<span class="number">0</span>, <span class="built_in">rightmost</span>(), v);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">insert_unique</span>(v).first;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		iterator before = position;</span><br><span class="line">		--before;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(before.node), <span class="built_in">KeyOfValue</span>()(v))</span><br><span class="line">			&amp;&amp; <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(position.node)))</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">right</span>(before.node) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> __insert(<span class="number">0</span>, before.node, v);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> __insert(position.node, position.node, v);</span><br><span class="line">		<span class="comment">// first argument just needs to be non-null </span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">insert_unique</span>(v).first;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Val</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Val, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Val, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_equal</span>(iterator position,</span><br><span class="line"><span class="type">const</span> Val&amp; v) &#123;</span><br><span class="line">	<span class="keyword">if</span> (position.node == header-&gt;left) <span class="comment">// begin()</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(position.node)))</span><br><span class="line">		<span class="keyword">return</span> __insert(position.node, position.node, v);</span><br><span class="line">	<span class="comment">// first argument just needs to be non-null </span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">insert_equal</span>(v);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (position.node == header) <span class="comment">// end()</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(<span class="built_in">rightmost</span>())))</span><br><span class="line">		<span class="keyword">return</span> __insert(<span class="number">0</span>, <span class="built_in">rightmost</span>(), v);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">insert_equal</span>(v);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		iterator before = position;</span><br><span class="line">		--before;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(before.node))</span><br><span class="line">			&amp;&amp; !<span class="built_in">key_compare</span>(<span class="built_in">key</span>(position.node), <span class="built_in">KeyOfValue</span>()(v)))</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">right</span>(before.node) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> __insert(<span class="number">0</span>, before.node, v);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> __insert(position.node, position.node, v);</span><br><span class="line">		<span class="comment">// first argument just needs to be non-null </span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">insert_equal</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真正的插入程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::</span><br><span class="line">__insert(base_ptr x_, base_ptr y_, <span class="type">const</span> Value&amp; v) &#123;</span><br><span class="line">	<span class="comment">//参数x_为新值安插点，参数y_为安插点之父节点，参数v 为新值</span></span><br><span class="line">	link_type x = (link_type)x_;</span><br><span class="line">	link_type y = (link_type)y_;</span><br><span class="line">	link_type z;</span><br><span class="line">	<span class="comment">//key_compare是键值得比较准则，是个函数或函数指针</span></span><br><span class="line">	<span class="keyword">if</span> (y == header || x != <span class="number">0</span> || <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(y))) &#123;</span><br><span class="line">		z = <span class="built_in">create_node</span>(v);  <span class="comment">// 产生一个新节点</span></span><br><span class="line">		<span class="built_in">left</span>(y) = z;          <span class="comment">// 这使得当y为header时，leftmost()=z</span></span><br><span class="line">		<span class="keyword">if</span> (y == header) &#123;</span><br><span class="line">			<span class="built_in">root</span>() = z;</span><br><span class="line">			<span class="built_in">rightmost</span>() = z;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="built_in">leftmost</span>())	<span class="comment">// 如果y为最左节点</span></span><br><span class="line">			<span class="built_in">leftmost</span>() = z;           	<span class="comment">// 维护leftmost()，使它永远指向最左节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		z = <span class="built_in">create_node</span>(v);</span><br><span class="line">		<span class="built_in">right</span>(y) = z;				<span class="comment">// 令新节点成为安插点之父节点y的右孩子</span></span><br><span class="line">		<span class="keyword">if</span> (y == <span class="built_in">rightmost</span>())</span><br><span class="line">			<span class="built_in">rightmost</span>() = z;          	<span class="comment">// 维护rightmost()，使它永远指向最右节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">parent</span>(z) = y;		<span class="comment">// 设定新节点的父节点</span></span><br><span class="line">	<span class="built_in">left</span>(z) = <span class="number">0</span>;		<span class="comment">// 设定新孩子节点的左孩子</span></span><br><span class="line">	<span class="built_in">right</span>(z) = <span class="number">0</span>; 		<span class="comment">// 设定新孩子节点的右孩子</span></span><br><span class="line">	<span class="comment">// 新节点的颜色将在 __rb_tree_rebalance() 设定并调整</span></span><br><span class="line">	__rb_tree_rebalance(z, header-&gt;parent);	<span class="comment">// 参数一为新增节点，参数二为root</span></span><br><span class="line">	++node_count;		<span class="comment">// 节点数增加</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">iterator</span>(z);	<span class="comment">// 返回迭代器，指向新增节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set的特性是，所有元素都会根据元素的键值自动排序，set的元素不像map那样可以同时拥有实值和键值，set元素的键值就是实值，实值就是键值，且不允许两个元素有相同的键值。set具有以下特点：</p>
<ul>
<li>不能通过set的迭代器改变set的元素，set iterators被定义为底层RB-tree的const_iterators，杜绝写入操作。</li>
<li>客户端对set进行元素新增或者删除操作时，操作之前的所有迭代器在操作后都依然有效，被删除的元素的迭代器例外。</li>
</ul>
<p>STL特别提供了一组set/multiset相关算法，包括交集、联集、差集、对称差集。STL set以RB-tree为底层机制，set的操作几乎都是转调用RB-tree的函数而已。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;, <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> set &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// typedefs:</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Key value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">  <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">  struct identity : public unary_function&lt;T, T&gt; &#123;</span></span><br><span class="line"><span class="comment">    const T&amp; operator()(const T&amp; x) const &#123; return x; &#125;</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, </span><br><span class="line">                  identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">  rep_type t;  <span class="comment">// red-black tree representing set</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocation/deallocation</span></span><br><span class="line">	<span class="comment">// 注意，set一定使用RB-tree的insert_unique()，而非insert_equal()</span></span><br><span class="line">	<span class="comment">// multiset才使用RB-tree的insert_equal()</span></span><br><span class="line">	<span class="comment">// 因为set不许相同键值存在</span></span><br><span class="line">	<span class="built_in">set</span>() : <span class="built_in">t</span>(<span class="built_in">Compare</span>()) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">	<span class="title">set</span><span class="params">(InputIterator first, InputIterator last)</span> : t(Compare()) &#123;</span>t.<span class="built_in">insert_unique</span>(first, last);&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">	<span class="title">set</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; comp)</span> : t(comp) &#123;</span>t.<span class="built_in">insert_unique</span>(first, last);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">set</span>(<span class="type">const</span> set&lt;Key, Compare, Alloc&gt;&amp; x) : <span class="built_in">t</span>(x.t) &#123;&#125;</span><br><span class="line">	set&lt;Key, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set&lt;Key, Compare, Alloc&gt;&amp; x) &#123;</span><br><span class="line">		t = x.t;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// accessors:</span></span><br><span class="line">	<span class="comment">//转调用RB-tree的操作行为</span></span><br><span class="line">	<span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">	<span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">value_compare</span>(t.<span class="built_in">key_comp</span>()); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">end</span>(); &#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rbegin</span>(); &#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rend</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(set&lt;Key, Compare, Alloc&gt;&amp; x)</span> </span>&#123;t.<span class="built_in">swap</span>(x.t);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert/erase </span></span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;iterator, <span class="type">bool</span>&gt; pair_iterator_bool;</span><br><span class="line">	<span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">		pair&lt;<span class="keyword">typename</span> rep_type::iterator, <span class="type">bool</span>&gt; p = t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;((p.first, p.second);</span><br><span class="line">	&#125;</span><br><span class="line">	iterator <span class="built_in">insert</span>(iterator position, <span class="type">const</span> value_type&amp; x) &#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator; </span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">insert_unique</span>((rep_iterator&amp;)position, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt; </span><br><span class="line">	<span class="type">void</span> <span class="built_in">insert</span>(InputIterator first, InputIterator last) &#123;</span><br><span class="line">		t.<span class="built_in">insert_unique</span>(first, last); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">erase</span>(iterator position) &#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator; </span><br><span class="line">		t.<span class="built_in">erase</span>((rep_iterator&amp;)position);</span><br><span class="line">	&#125; </span><br><span class="line">	size_type <span class="built_in">erase</span>(<span class="type">const</span> key_type&amp; x) &#123; <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> <span class="built_in">erase</span>(iterator first, iterator last) &#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator; </span><br><span class="line">		t.<span class="built_in">erase</span>((rep_iterators&amp;)first, (rep_iterator&amp;)last); </span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="type">void</span> <span class="built_in">clear</span>() ( t.<span class="built_in">clear</span>(); &#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// set operations:</span></span><br><span class="line">	iterator <span class="built_in">find</span>(<span class="type">const</span> key_type&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> t.<span class="built_in">find</span>(x); &#125;</span><br><span class="line">	size_type <span class="built_in">count</span>(<span class="type">const</span> key_type&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> t.<span class="built_in">count</span>(x); &#125; </span><br><span class="line">	iterator <span class="built_in">lowerbound</span>(<span class="type">const</span> key_type&amp; x) <span class="type">const</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x); </span><br><span class="line">	&#125;</span><br><span class="line">	iterator <span class="built_in">upper_bound</span>(<span class="type">const</span> key_type&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> t.<span class="built_in">upppr_bonnd</span>(x); &#125;</span><br><span class="line">	pair&lt;iterator, iterator&gt; <span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">		t.<span class="built_in">equal_range</span>(x); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 以下的 STL_NULL_TMPL_ARCS 被定义为&lt;&gt;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> set&amp;, <span class="type">const</span> set&amp;);</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> set&amp;, <span class="type">const</span> set&amp;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> Compare, <span class="keyword">class</span> Alloc&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> set&lt;Key, Compare, Alloc&gt;&amp; x, <span class="type">const</span> set&lt;Key, Compare, Alloc&gt;&amp; y) &#123; </span><br><span class="line">		<span class="keyword">return</span> x.t == y.t; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> Compare, <span class="keyword">class</span> Alloc&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> set&lt;Key, Compare, Alloc&gt;&amp; x, <span class="type">const</span> set&lt;Key, Compare, Alloc&gt;&amp; y) &#123; </span><br><span class="line">		<span class="keyword">return</span> x.t &lt; y.t; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 5set-test.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; iset&#123;ia, ia + <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iset.<span class="built_in">size</span>() &lt;&lt; endl;         <span class="comment">//size=5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3 count =&quot;</span> &lt;&lt; iset.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl;   <span class="comment">//3 count =1</span></span><br><span class="line">    iset.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iset.<span class="built_in">size</span>() &lt;&lt; endl;         <span class="comment">//size=5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3 count =&quot;</span> &lt;&lt; iset.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl;   <span class="comment">//3 count =1</span></span><br><span class="line"> </span><br><span class="line">    iset.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iset.<span class="built_in">size</span>() &lt;&lt; endl;         <span class="comment">//size=6</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5 count =&quot;</span> &lt;&lt; iset.<span class="built_in">count</span>(<span class="number">5</span>) &lt;&lt; endl;   <span class="comment">//5 count =1</span></span><br><span class="line"> </span><br><span class="line">    iset.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iset.<span class="built_in">size</span>() &lt;&lt; endl;        <span class="comment">//size=5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3 count =&quot;</span> &lt;&lt; iset.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl;  <span class="comment">//3 count =1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1 count =&quot;</span> &lt;&lt; iset.<span class="built_in">count</span>(<span class="number">1</span>) &lt;&lt; endl;  <span class="comment">//1 count =0</span></span><br><span class="line"> </span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator ite1 = iset.<span class="built_in">begin</span>();</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator ite2 = iset.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">for</span> (; ite1 != ite2; ++ite1) &#123;</span><br><span class="line">        cout &lt;&lt; *ite1;                             <span class="comment">//02345</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用STL算法find可以搜索元素，但不推荐</span></span><br><span class="line">    ite1 = <span class="built_in">find</span>(iset.<span class="built_in">begin</span>(), iset.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (ite1 != iset.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3 found&quot;</span> &lt;&lt; endl;                <span class="comment">//3 found</span></span><br><span class="line"> </span><br><span class="line">    ite1 = <span class="built_in">find</span>(iset.<span class="built_in">begin</span>(), iset.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ite1 == iset.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1 not found&quot;</span> &lt;&lt; endl;            <span class="comment">//1 not found</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 关联式容器应使用专用的find函数搜索更有效率</span></span><br><span class="line">    ite1 = iset.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (ite1 != iset.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3 found&quot;</span> &lt;&lt; endl;                <span class="comment">//3 found</span></span><br><span class="line"> </span><br><span class="line">    ite1 = iset.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ite1 == iset.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1 not found&quot;</span> &lt;&lt; endl;            <span class="comment">//1 not found</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// *ite1 = 9; // 修改失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><p>multiset的特性及用法和set完全相同，唯一的差别在于它允许键值重复，因为它的插入操作采用的是RB-tree的insert_equal()。测试程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span> &#125;;</span><br><span class="line">	<span class="function">multiset&lt;<span class="type">int</span>&gt; <span class="title">iset</span><span class="params">(begin(ia), end(ia))</span></span>;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iset.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">//size=6</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3 count=&quot;</span> &lt;&lt; iset.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl;<span class="comment">//3 count=1</span></span><br><span class="line"> </span><br><span class="line">	iset.<span class="built_in">insert</span>(<span class="number">3</span>); <span class="comment">//和set区别的地方</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iset.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//size=7</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3 count=&quot;</span> &lt;&lt; iset.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl;<span class="comment">//3 count=2</span></span><br><span class="line"> </span><br><span class="line">	iset.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iset.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//size=8</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3 count=&quot;</span> &lt;&lt; iset.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl;<span class="comment">//3 count=2</span></span><br><span class="line"> </span><br><span class="line">	iset.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iset.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//size=7</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1 count=&quot;</span> &lt;&lt; iset.<span class="built_in">count</span>(<span class="number">1</span>) &lt;&lt; endl;<span class="comment">//1 count=0</span></span><br><span class="line"> </span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = iset.<span class="built_in">begin</span>(); it != iset.<span class="built_in">end</span>(); ++it)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//2 3 3 4 5 6 7</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	it = iset.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (it != iset.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;3 found&quot;</span> &lt;&lt; endl;<span class="comment">//3 found</span></span><br><span class="line"> </span><br><span class="line">	it = iset.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == iset.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1 not found&quot;</span> &lt;&lt; endl;<span class="comment">//1 not found </span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="map概述"><a href="#map概述" class="headerlink" title="map概述"></a>map概述</h2><p>map的特性是，所有元素都会根据元素的键值自动排序，map的所有元素都是pair，pair的第一元素是键值，第二元素是实值。map具有以下特点：</p>
<ul>
<li>不能通过map的迭代器改变map的键值，但通过map的迭代器能改变map的实值。因此map的iterators既不是一种const iterators，也不是一种mutable iterators。</li>
<li>客户端对map进行元素新增或者删除操作时，操作之前的所有迭代器在操作后都依然有效，被删除的元素的迭代器例外。</li>
<li>map不允许两个元素拥有相同的键值。</li>
</ul>
<p>下面是pair的定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">	<span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">	<span class="keyword">typedef</span> T2 second_type;</span><br><span class="line"> </span><br><span class="line">	T1 first;</span><br><span class="line">	T2 second;</span><br><span class="line">	<span class="built_in">pair</span>() : <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>()) &#123;&#125;</span><br><span class="line">	<span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a, <span class="type">const</span> T2&amp; b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>从上可以看出，pair 包含两个类型（可以相同，也可以不相同）的公共元素。<br>map同set一样，都是关联式容器，内部元素的实值都会根据其键值来进行排序（set 的实值就是键值），所以都不能任意改变元素的键值，但是map可以任意改变元素的实值，我们所有操作的前提以及是否被允许，要看是否会影响到map元素的排序规则。</p>
<p>同样map和multimap 也是以RB-tree 为底层机制，几乎所有的map操作行为，都只是转调用RB-tree的操作行为而已。</p>
<p>set 和 map的内部结构即元素的存储都是RB-tree，set 中，RB-tree的节点内容是单一元素，而map中，节点内容则是一个pair <code>&lt;key，value&gt;</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">map</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// typedefs:</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">typedef</span> Key key_type; <span class="comment">//键值型别</span></span><br><span class="line">	<span class="keyword">typedef</span> T data_type;  <span class="comment">//实值型别</span></span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;<span class="type">const</span> Key, T&gt; value_type;  <span class="comment">//元素性别（键值/实值）</span></span><br><span class="line">	<span class="keyword">typedef</span> Compare key_compare;  <span class="comment">//键值比较函数</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//定义一个函数，其作用就是调用“元素比较函数”</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">value_compare</span></span><br><span class="line">		: <span class="keyword">public</span> binary_function&lt;value_type, value_type, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">map</span>&lt;Key, T, Compare, Alloc&gt;;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		Compare comp;</span><br><span class="line">		<span class="built_in">value_compare</span>(Compare c) : <span class="built_in">comp</span>(c) &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//重载</span></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> value_type&amp; x, <span class="type">const</span> value_type&amp; y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">comp</span>(x.first, y.first);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree&lt;key_type, value_type,</span><br><span class="line">		select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">	rep_type t;  <span class="comment">// 以RB-tree为底层实现，所有元素(pair)存放在RB-tree节点中</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//两种类型的都有，因为map允许用户通过迭代器修改元素的实值</span></span><br><span class="line">	<span class="keyword">typedef</span> rep_type::pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::const_reference const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::iterator iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::const_iterator const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::reverse_iterator reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::size_type size_type;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::difference_type difference_type;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// allocation/deallocation</span></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">map</span>() : <span class="built_in">t</span>(<span class="built_in">Compare</span>()) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">map</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp) &#123;</span>&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*map一定使用底层RB-tree 的insert_unique()*/</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">map</span>(<span class="type">const</span> map&lt;Key, T, Compare, Alloc&gt;&amp; x) : <span class="built_in">t</span>(x.t) &#123;&#125;</span><br><span class="line">	map&lt;Key, T, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map&lt;Key, T, Compare, Alloc&gt;&amp; x)</span><br><span class="line">	&#123;</span><br><span class="line">		t = x.t;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// accessors:</span></span><br><span class="line">	<span class="comment">//转调用RB-tree的操作行为</span></span><br><span class="line">	<span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">	<span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">value_compare</span>(t.<span class="built_in">key_comp</span>()); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">end</span>(); &#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">end</span>(); &#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rbegin</span>(); &#125;</span><br><span class="line">	<span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rbegin</span>(); &#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rend</span>(); &#125;</span><br><span class="line">	<span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rend</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">	<span class="comment">/*下面这个下标操作符重载函数是的map支持元素的直接存取，索引值是元素的key*/</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; k) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first)).second;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(map&lt;Key, T, Compare, Alloc&gt;&amp; x)</span> </span>&#123; t.<span class="built_in">swap</span>(x.t); &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// insert/erase</span></span><br><span class="line">	<span class="comment">//都是调用底层RB-tree的操作行为</span></span><br><span class="line">	<span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(x); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(position, x);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123; t.<span class="built_in">erase</span>(position); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">erase</span>(x); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123; t.<span class="built_in">erase</span>(first, last); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// map operations:</span></span><br><span class="line">	<span class="comment">/*返回一个迭代器指向键值为key的元素，如果没找到就返回end()*/</span></span><br><span class="line">	<span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">find</span>(x); &#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">find</span>(x); &#125;</span><br><span class="line">	<span class="comment">/*返回键值等于key的元素的个数*/</span></span><br><span class="line">	<span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">count</span>(x); &#125;</span><br><span class="line">	<span class="comment">/*返回一个迭代器，指向键值&gt;=key的第一个元素*/</span></span><br><span class="line">	<span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x); &#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*返回一个迭代器，指向键值&gt;key的第一个元素*/</span></span><br><span class="line">	<span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x); &#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*返回键值为key的元素的第一个可安插位置和最后一个可安插位置，也就是“键值==key”的元素区间*/</span></span><br><span class="line">	<span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">pair&lt;const_iterator, const_iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> map&amp;, <span class="type">const</span> map&amp;);</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> map&amp;, <span class="type">const</span> map&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*运算符重载，几乎有所有的操作行为都是调用RB-tree的操作行为</span></span><br><span class="line"><span class="comment">事实上，包括set在内的关联式容器内部都是以RB-tree方式存放的*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> map&lt;Key, T, Compare, Alloc&gt;&amp; x,</span><br><span class="line">	<span class="type">const</span> map&lt;Key, T, Compare, Alloc&gt;&amp; y) &#123;</span><br><span class="line">	<span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> map&lt;Key, T, Compare, Alloc&gt;&amp; x,</span><br><span class="line">	<span class="type">const</span> map&lt;Key, T, Compare, Alloc&gt;&amp; y) &#123;</span><br><span class="line">	<span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通常，关联式容器并不提供元素的直接存取，你必须依靠迭代器，不过 map 内部的下标操作符重载函数使得其支持元素的直接存取，看看它是怎么实现的<br>这是map作为关联式容器特殊的地方（multimap没有哦）</p>
<h3 id="map测试程序"><a href="#map测试程序" class="headerlink" title="map测试程序"></a>map测试程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; stuMap;</span><br><span class="line">    </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;————————————————————插入操作—————————————————&quot;</span>&lt;&lt;endl;</span><br><span class="line">	stuMap[<span class="number">1001</span>]=<span class="string">&quot;Jason&quot;</span>;</span><br><span class="line">	stuMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1002</span>,<span class="string">&quot;Helen&quot;</span>));</span><br><span class="line">	stuMap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1003</span>,<span class="string">&quot;Steve&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt;::const_iterator iter = stuMap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; iter != stuMap.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt; iter-&gt;first &lt;&lt;<span class="string">&quot; name:&quot;</span>&lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;————————————————————取值操作—————————————————&quot;</span>&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;stuMap[1004]:&quot;</span>&lt;&lt;stuMap[<span class="number">1004</span>]&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用at会进行关键字检查，因此下面语句会报错</span></span><br><span class="line">	<span class="comment">//stuMap.at(1005) = &quot;Bob&quot;;</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;————————————————————查找操作—————————————————&quot;</span>&lt;&lt;endl;</span><br><span class="line">	iter = stuMap.<span class="built_in">find</span>(<span class="number">1001</span>);</span><br><span class="line">	<span class="keyword">if</span> (iter!=stuMap.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;1001 found name:&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	iter = stuMap.<span class="built_in">find</span>(<span class="number">1005</span>);</span><br><span class="line">	<span class="keyword">if</span> ( iter==stuMap.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;1005 not found&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;————————————————————容量查询—————————————————&quot;</span>&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;stuMap empty state is &quot;</span>&lt;&lt;boolalpha&lt;&lt;stuMap.<span class="built_in">empty</span>()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;stuMap size is &quot;</span>&lt;&lt;boolalpha&lt;&lt;stuMap.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;stuMap.count(1008) is &quot;</span>&lt;&lt;boolalpha&lt;&lt;stuMap.<span class="built_in">count</span>(<span class="number">1008</span>)&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;————————————————————删除操作—————————————————&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;before delete&quot;</span>&lt;&lt;endl;</span><br><span class="line">	iter = stuMap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; iter != stuMap.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt; iter-&gt;first &lt;&lt;<span class="string">&quot; name:&quot;</span>&lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	stuMap.<span class="built_in">erase</span>(<span class="number">1004</span>);</span><br><span class="line">	</span><br><span class="line">	iter = stuMap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; iter != stuMap.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(iter-&gt;second==<span class="string">&quot;Helen&quot;</span>)	</span><br><span class="line">		&#123;</span><br><span class="line">			stuMap.<span class="built_in">erase</span>(iter);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;after delete&quot;</span>&lt;&lt;endl;</span><br><span class="line">	iter = stuMap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; iter != stuMap.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt; iter-&gt;first &lt;&lt;<span class="string">&quot; name:&quot;</span>&lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="number">192</span> <span class="number">5</span>_STL_associated_container]# ./<span class="number">5</span>_4_map-test</span><br><span class="line">————————————————————插入操作—————————————————</span><br><span class="line">id:<span class="number">1001</span> name:Jason</span><br><span class="line">id:<span class="number">1002</span> name:Helen</span><br><span class="line">id:<span class="number">1003</span> name:Steve</span><br><span class="line">————————————————————取值操作—————————————————</span><br><span class="line">stuMap[<span class="number">1004</span>]:</span><br><span class="line">————————————————————查找操作—————————————————</span><br><span class="line"><span class="number">1001</span> found name:Jason</span><br><span class="line"><span class="number">1005</span> <span class="keyword">not</span> found</span><br><span class="line">————————————————————容量查询—————————————————</span><br><span class="line">stuMap empty state is <span class="literal">false</span></span><br><span class="line">stuMap size is <span class="number">4</span></span><br><span class="line">stuMap.<span class="built_in">count</span>(<span class="number">1008</span>) is <span class="number">0</span></span><br><span class="line">————————————————————删除操作—————————————————</span><br><span class="line">before <span class="keyword">delete</span></span><br><span class="line">id:<span class="number">1001</span> name:Jason</span><br><span class="line">id:<span class="number">1002</span> name:Helen</span><br><span class="line">id:<span class="number">1003</span> name:Steve</span><br><span class="line">id:<span class="number">1004</span> name:</span><br><span class="line">after <span class="keyword">delete</span></span><br><span class="line">id:<span class="number">1001</span> name:Jason</span><br><span class="line">id:<span class="number">1003</span> name:Steve</span><br></pre></td></tr></table></figure></p>
<h2 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h2><p>hashtable在插入，删除，搜寻等操作上具有＂常数平均时间＂的表现，而且这种表现以统计为基础，不依赖输入元素的随机性。（二叉搜索树具有对数平均时间的表现，是建立在输入数据有足够随机性的基础上。）</p>
<p>hash table 可提供对任何有名项的存取操作和删除操作。由于操作对象是有名项，所以hashtable可被视为一种字典结构（dictionary）。举个例子，如果所有元素时16-bits且不带有正负号的整数，范围为0-65535，则可以通过配置一个array拥有65536个元素，对应位置记录元素出现个数，添加A[i]++，删除A[i]—，查找A[i]==0判断。但是进一步，如果所有元素是32-bits，那大小必须是2^32=4GB，那直接分配这么大的空间就不太实际。再进一步，如果元素时字符串，每个字符用7-bits数值(ASCII)表示，这种方法就更不可取了。</p>
<p>为了解决上述问题，引入了hash funtion的概念。hashfuntion可以将某一元素映射为一个“大小可接受之索引”，即大数映射成小数。hashtable通过hashfunction将元素映射到不同的位置，但当不同的元素通过hash function映射到相同位置时，便产生了＂碰撞＂问题．解决碰撞问题的方法主要有线性探测，二次探测，开链法等．</p>
<ul>
<li>线性探测：当hash function计算出某个元素的插入位置，而该位置的空间已不可用时，循序往下寻找下一个可用位置(到达尾端时绕到头部继续寻找)，会产生primary clustering（一次聚集）问题。</li>
<li>二次探测：当hash function计算出某个元素的插入位置为H，而该位置的空间已经被占用，就尝试用H+１²、H+2²…，会产生secondary clustering(二次聚集)问题。</li>
<li>开链：在每一个表格元素中维护一个list：hash function为我们分配某个list，在那个list上进行元素的插入，删除，搜寻等操作．SGI STL解决碰撞问题的方法就是此方法。</li>
</ul>
<p>下面以开链法完成hash table的图形表述，hash table 表格内的元素为桶子（bucket），每个bucket都维护一个链表，来解决哈希碰撞，如下所示：<br><img src="/img/1610004677.jpg" alt=""></p>
<p>下面看一下 hashtable 的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hastabl_node</span></span><br><span class="line">&#123;</span><br><span class="line">	__hastable_node* next;</span><br><span class="line">	Value val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以下是hash table的迭代器的定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">ExtractKey</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_iterator</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; hashtable;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_const_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> Value* pointer;</span><br><span class="line"> </span><br><span class="line">  node* cur;    <span class="comment">//迭代器目前所指之节点</span></span><br><span class="line">  hashtable* ht;   <span class="comment">//保持容器的连结关系</span></span><br><span class="line">  ...</span><br><span class="line">  __hashtable_iterator(node* n, hashtable* tab) : <span class="built_in">cur</span>(n), <span class="built_in">ht</span>(tab) &#123;&#125;</span><br><span class="line">  __hashtable_iterator() &#123;&#125;</span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> cur-&gt;val; &#125; </span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125; </span><br><span class="line">  iterator&amp; <span class="keyword">operator</span>++(); </span><br><span class="line">  iterator <span class="keyword">operator</span>++(<span class="type">int</span>); </span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator&amp; it) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == it.cur; &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; it) <span class="type">const</span> &#123; <span class="keyword">return</span> cur != it.cur; &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意hashtable迭代器必须永远维系着与整个buckets vector的关系，并记录目前所指的节点。其前进操作是首先尝试从目前所指的节点出发，前进一个位置〔节点），由于节点被安置于st内，所以利用节点的next指针即可轻易达成前进操作，如果目前节点正巧是list的尾端，就跳至下一个bucket身上，那正是指向下一个bucket的头部节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, Class ExK, <span class="keyword">class</span> <span class="title class_">EqK</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iteratorc&lt;V, K, HF, ExK, EqK, A&gt;&amp; </span><br><span class="line">__hashtable_iteratorc&lt;V, K, HF, ExK, EqK, A&gt;::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> node* old = cur;</span><br><span class="line">	cur = cur-&gt;next; <span class="comment">//如果存在，就是它。否则进入以下流程</span></span><br><span class="line">	<span class="keyword">if</span>(!cur) &#123; </span><br><span class="line">	<span class="comment">//根据元素值，定位出下一个bucket，其起头处就是我们的目的地</span></span><br><span class="line">		size_type bucket = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line">		<span class="keyword">while</span> (!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.<span class="built_in">size</span>())</span><br><span class="line">			cur = ht-&gt;buckets[bucket];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, Class ExK, <span class="keyword">class</span> <span class="title class_">EqK</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> __hashtable_iteratorc&lt;V, K, HF, ExK, EqK, A&gt; </span><br><span class="line">__hashtable_iteratorc&lt;V, K, HF, ExK, EqK, A&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>hashtable没有逆向操作（operator—()）。</p>
<h3 id="hashtable的数据结构"><a href="#hashtable的数据结构" class="headerlink" title="hashtable的数据结构"></a>hashtable的数据结构</h3><p>下图是hashtable的定义摘要，其中可见bucket聚合体以vector完成，以利动态扩充：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>, <span class="keyword">class</span> <span class="title class_">ExtractKey</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>, <span class="keyword">class</span> <span class="title class_">ExtractKey</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> HashFcn hasher;</span><br><span class="line">	<span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	hasher hash;</span><br><span class="line">	key_equal equals;</span><br><span class="line">	ExtractKey get_key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;node, Alloc&gt; node_allocator;</span><br><span class="line"></span><br><span class="line">	vector&lt;node*, Alloc&gt; buckets;</span><br><span class="line">	size_type num_elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> buckets.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>虽然开链法不要求表格大小必须为质数，但是SGI STL仍然以质数来设计表格大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//表格大小必须为质数，从下述28个质数中取最接近的</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> __stl_num_primes = <span class="number">28</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_prime_list[__stl_num_primes] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">53</span>,         <span class="number">97</span>,           <span class="number">193</span>,         <span class="number">389</span>,       <span class="number">769</span>,</span><br><span class="line">  <span class="number">1543</span>,       <span class="number">3079</span>,         <span class="number">6151</span>,        <span class="number">12289</span>,     <span class="number">24593</span>,</span><br><span class="line">  <span class="number">49157</span>,      <span class="number">98317</span>,        <span class="number">196613</span>,      <span class="number">393241</span>,    <span class="number">786433</span>,</span><br><span class="line">  <span class="number">1572869</span>,    <span class="number">3145739</span>,      <span class="number">6291469</span>,     <span class="number">12582917</span>,  <span class="number">25165843</span>,</span><br><span class="line">  <span class="number">50331653</span>,   <span class="number">100663319</span>,    <span class="number">201326611</span>,   <span class="number">402653189</span>, <span class="number">805306457</span>, </span><br><span class="line">  <span class="number">1610612741</span>, <span class="number">3221225473ul</span>, <span class="number">4294967291ul</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 获取桶的数量 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_next_prime(<span class="type">unsigned</span> <span class="type">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>* first = __stl_prime_list;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>* last = __stl_prime_list + __stl_num_primes;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>* pos = <span class="built_in">lower_bound</span>(first, last, n); <span class="comment">//&gt;=</span></span><br><span class="line">  <span class="keyword">return</span> pos == last ? *(last - <span class="number">1</span>) : *pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总共可以有多少个buckets</span></span><br><span class="line"><span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __stl_prime_list(__stl_num_promes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="hashtable的构造与内存管理"><a href="#hashtable的构造与内存管理" class="headerlink" title="hashtable的构造与内存管理"></a>hashtable的构造与内存管理</h3><p>节点配置函数和节点释放函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">new_node</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> </span>&#123;</span><br><span class="line">	node* n = node_allocator::<span class="built_in">allocate</span>();</span><br><span class="line">	n-&gt;next = <span class="number">0</span>;</span><br><span class="line">	__STL_TRY &#123;</span><br><span class="line">		<span class="built_in">construct</span>(&amp;n-&gt;val, obj);</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	__STL_UNWIND(node_allocator::<span class="built_in">deallocate</span>(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_node</span><span class="params">(node* n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">destroy</span>(&amp;n-&gt;val);</span><br><span class="line">	node_allocator::<span class="built_in">deallocate</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们初始构造一个拥有50个节点的hashtable如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;value,key,hash-func,extract-key,equal-key,allocator&gt;</span></span><br><span class="line"><span class="comment">// 注意：hashtable没有提供default constructor</span></span><br><span class="line">hashtable&lt;<span class="type">int</span>, <span class="type">int</span>, hash&lt;<span class="type">int</span>&gt;, identity&lt;<span class="type">int</span>&gt;, equal_to&lt;<span class="type">int</span>&gt;, alloc&gt; <span class="built_in">iht</span>(<span class="number">50</span>, <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;(), <span class="built_in">equal_to</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">cout&lt;&lt;iht.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;iht.<span class="built_in">bucket_count</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure></p>
<p>上述定义调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hashtable</span>(size_type n,</span><br><span class="line">          <span class="type">const</span> HashFcn&amp;    hf,</span><br><span class="line">          <span class="type">const</span> EqualKey&amp;   eql)</span><br><span class="line">  : <span class="built_in">hash</span>(hf), <span class="built_in">equals</span>(eql), <span class="built_in">get_key</span>(<span class="built_in">ExtractKey</span>()), <span class="built_in">num_elements</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">initialize_buckets</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先初始化三个仿函数，然后调用 initialize_buckets 来初始化hashtable。initialize_buckets 函数定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cost size_type n_buckets = <span class="built_in">next_size</span>(n);</span><br><span class="line">  buckets.<span class="built_in">reserve</span>(n_buckets);</span><br><span class="line">  buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(), n_buckets, (node*) <span class="number">0</span>);</span><br><span class="line">  num_elements = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先确定 bucket 的数量，然后通过 reserve 初始化，然后再通过 insert 将所有的 bucket 初始化为 NULL。最后将元素个数填为0（其中的 buckets 是一个 vector）。</p>
<p>hashtable 的插入 跟 RB-tree 的插入类似，有两种插入方法 insert_unique 和 insert_equal ，意思也是一样的，insert_unique 不允许有重复值，而 insert_equal 允许有重复值。因为都会用到是否需要重建表格的判断，我们先来整理这一部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">resize</span>(size_type num_elements_hint)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//判断 “表格重建与否” 是拿元素个数和 bucket vector 的大小来比，如果前者大于后者，就重建表格</span></span><br><span class="line">	<span class="comment">//所以 每个 bucket list 的最大容量和 bucket vector 的大小相同</span></span><br><span class="line">	<span class="type">const</span> size_type old_n = buckets.<span class="built_in">size</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>( num_elements_hint &gt; old_n )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> size_type n = <span class="built_in">next_size</span>(num_elements_hint); <span class="comment">//next_size 底层调用 __stl_next_prime()</span></span><br><span class="line">		<span class="keyword">if</span>( n &gt; old_n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">vector&lt;node*,A&gt; <span class="title">tmp</span><span class="params">(n, (node*) <span class="number">0</span>)</span></span>;		<span class="comment">//设立新的 buckets</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//以下是处理每一个旧的 bucket</span></span><br><span class="line">			<span class="keyword">for</span>( size_type bucket = <span class="number">0</span>; bucket &lt; old_n; ++bucket )</span><br><span class="line">			&#123;</span><br><span class="line">				node* first = buckets[bucket];		<span class="comment">//指向节点所对应之串行的起始节点</span></span><br><span class="line">				<span class="keyword">while</span>( first )						<span class="comment">//串行还没结束</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//找出当前节点应该放在 新buckets 的哪一个位置</span></span><br><span class="line">					size_type new_bucket = <span class="built_in">bkt_num</span>(first-&gt;val, n);</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//以下就是对新旧表格的处理，同时还要维护好 first 指针</span></span><br><span class="line">					buckets[bucket] = first-&gt;next; <span class="comment">// 令旧bucket指向其所对应串行的下一个节点</span></span><br><span class="line">					first-&gt;next = tmp[new_bucket]; <span class="comment">// 将当前节点插入到新bucket中，成为其对应串行的第一个节点</span></span><br><span class="line">					tmp[new_bucket] = first;</span><br><span class="line">					first = buckets[bucket]; <span class="comment">// 回到旧bucket所指的待处理串行，准备处理下一个节点</span></span><br><span class="line">				&#125;</span><br><span class="line">				buckets.<span class="built_in">swap</span>( tmp );				<span class="comment">//vector::swap 函数，新旧两个buckets对调，对调之后释放tmp内存</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在来看一下 insert_unique 函数，需要注意的是插入时，新节点直接插入到链表的头节点，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在不需要重建表格的情况插入新节点，键值不允许重复<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_unique_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj);	<span class="comment">//决定 obj 应位于 buckets 的那一个链表中</span></span><br><span class="line">	node* first = buckets[n];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历当前链表，如果发现有相同的键值，就不插入，立刻返回</span></span><br><span class="line">	<span class="keyword">for</span>( node* cur = first; cur; cur = cur-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( <span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(obj)) )</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//离开以上循环（或根本未进入循环）时，first指向 bucket 所指链表的头节点</span></span><br><span class="line">	node* tmp = <span class="built_in">new_node</span>(obj);		<span class="comment">//产生新节点</span></span><br><span class="line">	tmp-&gt;next = first;</span><br><span class="line">	buckets[n] = tmp;				<span class="comment">//令新节点为链表的第一个节点</span></span><br><span class="line">	++num_elements;					<span class="comment">//节点个数累加1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;( <span class="built_in">iterator</span>(tmp,<span class="keyword">this</span>), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>resize()</code>如果有必要就得做表格重建工作:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(1)令旧bucket指向其所对应之链表的下一个节点（以便迭代处理）</span></span><br><span class="line">buckets[bucket】 = first-&gt;next;</span><br><span class="line"><span class="comment">// (2)(3) 将当前节点插人到新bucket内，成为其对应链表的第一个节点</span></span><br><span class="line">first-&gt;next = tmp[new_bucket];</span><br><span class="line">tmp[new_bucket] = first;</span><br><span class="line"><span class="comment">// (4) 回到旧bucket所指的待处理链表，准备处理下一个节点</span></span><br><span class="line">first = buckets[bucket];</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1610346576.jpg" alt=""></p>
<p>允许重复插入的 insert_equal，需要注意的是插入时，重复节点插入到相同节点的后面，新节点还是插入到链表的头节点，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">resize</span>( num_elements + <span class="number">1</span> ); <span class="comment">//判断是否 需要重建表格，如需要就扩充</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">insert_equal_noresize</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::iterator</span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">insert_equal_noresize</span>(<span class="type">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj);	<span class="comment">//决定 obj 应位于 buckets 的那一个链表中</span></span><br><span class="line">	node* first = buckets[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前链表，如果发现有相同的键值，就马上插入，立刻返回</span></span><br><span class="line">    <span class="keyword">for</span>( node* cur = first; cur; cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>( <span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(obj)) )</span><br><span class="line">    	&#123;</span><br><span class="line">    		node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">    		tmp-&gt;next = cur-&gt;next;		<span class="comment">//新节点插入当前节点位置之后</span></span><br><span class="line">    		cur-&gt;next = tmp;</span><br><span class="line">    		++num_elements;</span><br><span class="line">    		<span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    	</span><br><span class="line">    <span class="comment">//运行到这里，表示没有发现重复的键值</span></span><br><span class="line">    node* tmp = <span class="built_in">new_node</span>(obj);		<span class="comment">//产生新节点</span></span><br><span class="line">    tmp-&gt;next = first;</span><br><span class="line">    buckets[n] = tmp;				<span class="comment">//令新节点为链表的第一个节点</span></span><br><span class="line">    ++num_elements;					<span class="comment">//节点个数累加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>首先找到指定的bucket，然后从第二个元素开始遍历，如果节点的 key 等于指定的 key，将将其删除。最后再检查第一个元素的 key，如果等于指定的 key，那么就将其删除。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::size_type </span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">erase</span>(<span class="type">const</span> key_type&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> size_type n = <span class="built_in">bkt_num_key</span>(key);</span><br><span class="line">  node* first = buckets[n];</span><br><span class="line">  size_type erased = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    node* cur = first;</span><br><span class="line">    node* next = cur-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(next-&gt;val), key)) &#123;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        <span class="built_in">delete_node</span>(next);</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        ++erased;</span><br><span class="line">        --num_elements;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(first-&gt;val), key)) &#123;</span><br><span class="line">      buckets[n] = first-&gt;next;</span><br><span class="line">      <span class="built_in">delete_node</span>(first);</span><br><span class="line">      ++erased;</span><br><span class="line">      --num_elements;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> erased;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>( size_type i = <span class="number">0</span>; i&lt;buckets.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		node* cur = buckets[i];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将 bucket list 中的每一个节点删除掉</span></span><br><span class="line">		<span class="keyword">while</span>( cur != <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			node* next = cur-&gt;next;</span><br><span class="line">			<span class="built_in">delete_node</span>(cur);</span><br><span class="line">			cur = next;</span><br><span class="line">		&#125;</span><br><span class="line">		buckets[i] = <span class="number">0</span>; 	<span class="comment">//令bucket内容为null指针</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	num_elements = <span class="number">0</span>;		<span class="comment">//令总节点个数为 0</span></span><br><span class="line">	<span class="comment">//注意：buckets vector 并未释放掉空间，扔保留原来大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制操作 copy_from，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">copy_from</span>(<span class="type">const</span> hashtable&amp; ht)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//先清除己方的 buckets vector</span></span><br><span class="line">	buckets.<span class="built_in">clear</span>();</span><br><span class="line">	buckets.<span class="built_in">reserve</span>(ht.buckets.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从己方的 buckets vector 尾端开始，插入 n 个元素，其值为 null 指针</span></span><br><span class="line">	buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(), ht.buckets.<span class="built_in">size</span>(),  (node*)<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//真正的执行复制操作</span></span><br><span class="line">	<span class="keyword">for</span>(size_type i = <span class="number">0</span>; i &lt; ht.buckets.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( <span class="type">const</span> node* cur = ht.bucktes[i] ）</span><br><span class="line">		&#123;</span><br><span class="line">			node* copy = <span class="built_in">new_node</span>(cur-&gt;val);</span><br><span class="line">			buckets[i] = copy;</span><br><span class="line">			<span class="keyword">for</span>(node* next = cur-&gt;next; next; cur = next, next = cur-&gt;next)</span><br><span class="line">			&#123;</span><br><span class="line">				copy-&gt;next = <span class="built_in">new_node</span>(next-&gt;val);</span><br><span class="line">				copy = copy-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="hash-set"><a href="#hash-set" class="headerlink" title="hash_set"></a>hash_set</h2><p>虽然STL只规范复杂度与接口，并不规范实现方法，但STL set多半以RB-tree为底层机制。SGI则是在STL标准规格之外另又提供了一个所谓的hash_set，以hashtable为底层机制。由于hash_set所供应的操作接口， hashtable都提供了，所以几乎所有的hash_set操作行为，都只是转调用hashtable的操作行为而己。 </p>
<p>运用set，为的是能够快速搜寻元素。这一点，不论其底层是RB-tree或是hash table、都可以达成任务。但是请注意，RB-tree有自动排序功能而hashtable没有，反应出来的结果就是，set的元素有自动排序功能而hash_set没有。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Value&gt;,</span><br><span class="line">                <span class="keyword">class</span> EqualKey = equal_to&lt;Value&gt;, <span class="keyword">class</span> Alloc=alloc&gt;</span><br><span class="line">    <span class="keyword">class</span> hash_set</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> hashtable&lt;Value, Value, HashFcn, identity&lt;Value&gt;,</span><br><span class="line">                            EqualKey, Alloc&gt; ht;</span><br><span class="line">        ht rep;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;         <span class="comment">//hashtable中: typedef HashFcn hasher</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equel key_equel;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator iterator;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line">        </span><br><span class="line">        <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">        <span class="function">key_equel <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//各种构造函数 ,不给定大小的话默认值为100,实际上找到的质数为193</span></span><br><span class="line">        <span class="built_in">hash_set</span>() : <span class="built_in">rep</span>(<span class="number">100</span>,<span class="built_in">hasher</span>(), <span class="built_in">key_equel</span>())&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">hash_set</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equel()) &#123;</span>&#125;</span><br><span class="line">        <span class="built_in">hash_set</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equel</span>()) &#123;&#125;</span><br><span class="line">        <span class="built_in">hash_set</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equel&amp; eql)</span><br><span class="line">            : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">        <span class="title">hash_set</span><span class="params">(InputIterator f, InputIterator l)</span></span></span><br><span class="line"><span class="function">        : rep(<span class="number">100</span>, hasher(), key_equel()) &#123;</span> rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">        <span class="title">hash_set</span><span class="params">(InputIterator f, InputIterator l, size_type n)</span></span></span><br><span class="line"><span class="function">        : rep(n, hasher(), key_equel()) &#123;</span> rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">        <span class="title">hash_set</span><span class="params">(InputIterator f, InputIterator l, size_type n, <span class="type">const</span> hasher&amp; hf)</span></span></span><br><span class="line"><span class="function">        : rep(n, hf, key_equel()) &#123;</span> rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">        <span class="title">hash_set</span><span class="params">(InputIterator f, InputIterator l, size_type n, <span class="type">const</span> hasher&amp; hf</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> key_equel&amp; eql)</span></span></span><br><span class="line"><span class="function">        : rep(n, hf, eql) &#123;</span> rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">size</span>();&#125;</span><br><span class="line">        <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_set&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">        <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_set&amp;, <span class="type">const</span> hash_set&amp;);</span><br><span class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">           pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="type">bool</span>&gt; p =rep.<span class="built_in">insert_unique</span>(obj);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">        <span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f,l); &#125;</span><br><span class="line">        <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="type">bool</span>&gt; p = rep.<span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//相等的key的位置(是一个左闭右开的区间)，由迭代器给出</span></span><br><span class="line">        <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span>    <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">        <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">        <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//class</span></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">        <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> hash_set&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; hs1,</span><br><span class="line">                               <span class="type">const</span> hash_set&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; hs2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> has<span class="number">1.</span>rep == has<span class="number">2.</span>rep;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hash-map"><a href="#hash-map" class="headerlink" title="hash_map"></a>hash_map</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Value&gt;,</span><br><span class="line"><span class="keyword">class</span> EqualKey = equal_to&lt;Value&gt;, <span class="keyword">class</span> Alloc=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> hash_map</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;pair&lt;<span class="type">const</span> Key, T&gt;, Key, HashFcn,</span><br><span class="line">                        select1st&lt;pair&lt;<span class="type">const</span> Key, T&gt;, EqualKey, Alloc&gt; ht;</span><br><span class="line"></span><br><span class="line">    ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">    <span class="keyword">typedef</span> T data_type;</span><br><span class="line">    <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;         <span class="comment">//hashtable中: typedef HashFcn hasher</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equel key_equel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">    <span class="function">key_equel <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各种构造函数 ,不给定大小的话默认值为100,实际上找到的质数为193</span></span><br><span class="line">    <span class="built_in">hash_map</span>() : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equel</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">hash_map</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equel()) &#123;</span>&#125;</span><br><span class="line">    <span class="built_in">hash_map</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equel</span>()) &#123;&#125;</span><br><span class="line">    <span class="built_in">hash_map</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equel&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">hash_map</span><span class="params">(InputIterator f, InputIterator l)</span></span></span><br><span class="line"><span class="function">    : rep(<span class="number">100</span>, hasher(), key_equel()) &#123;</span> rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">hash_map</span><span class="params">(InputIterator f, InputIterator l, size_type n)</span></span></span><br><span class="line"><span class="function">    : rep(n, hasher(), key_equel()) &#123;</span> rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">hash_map</span><span class="params">(InputIterator f, InputIterator l, size_type n, <span class="type">const</span> hasher&amp; hf)</span></span></span><br><span class="line"><span class="function">    : rep(n, hf, key_equel()) &#123;</span> rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">hash_map</span><span class="params">(InputIterator f, InputIterator l, size_type n, <span class="type">const</span> hasher&amp; hf</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> key_equel&amp; eql)</span></span></span><br><span class="line"><span class="function">    : rep(n, hf, eql) &#123;</span> rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_map&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_map&amp;, <span class="type">const</span> hash_map&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     <span class="comment">//之前在set中就想过 为什么不直接返回 在map中看到时直接返回了，</span></span><br><span class="line">        <span class="comment">//不是像set中一样还要先申请一个临时变量 再返回临时变量</span></span><br><span class="line">        <span class="comment">//经过一番努力，发现：set的iterator是const_iterator，因为set不能更改值嘛</span></span><br><span class="line">        <span class="comment">//所以需要进行转化，所以set那里会复杂一些</span></span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">insert_unique</span>(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f,l); &#125;</span><br><span class="line">    <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  rep.<span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key);&#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">return</span> rep.<span class="built_in">find_or_insert</span>(<span class="built_in">value_type</span>(key, <span class="built_in">T</span>())).second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相等的key的位置(是一个左闭右开的区间)，由迭代器给出</span></span><br><span class="line">    <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>    <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> hash_map&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; hm1,</span><br><span class="line">                           <span class="type">const</span> hash_map&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; hm2)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">return</span> has<span class="number">1.</span>rep == has<span class="number">2.</span>rep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="hash-multiset"><a href="#hash-multiset" class="headerlink" title="hash_multiset"></a>hash_multiset</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Value&gt;,</span><br><span class="line"><span class="keyword">class</span> EqualKey = equal_to&lt;Value&gt;, <span class="keyword">class</span> Alloc=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> hash_multiset</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> hash_multiset&lt;Value, Value, HashFcn, identity&lt;Value&gt;,</span><br><span class="line">    EqualKey, Alloc&gt; ht;</span><br><span class="line"></span><br><span class="line">    ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;         <span class="comment">//hashtable中: typedef HashFcn hasher</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equel key_equel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">    <span class="function">key_equel <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各种构造函数 ,不给定大小的话默认值为100,实际上找到的质数为193</span></span><br><span class="line">    <span class="built_in">hash_multiset</span>() : <span class="built_in">rep</span>(<span class="number">100</span>,<span class="built_in">hasher</span>(), <span class="built_in">key_equel</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">hash_multiset</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equel()) &#123;</span>&#125;</span><br><span class="line">    <span class="built_in">hash_multiset</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equel</span>()) &#123;&#125;</span><br><span class="line">    <span class="built_in">hash_multiset</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equel&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">hash_multiset</span><span class="params">(InputIterator f, InputIterator l)</span></span></span><br><span class="line"><span class="function">    : rep(<span class="number">100</span>, hasher(), key_equel()) &#123;</span> rep.<span class="built_in">insert_equal</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">hash_multiset</span><span class="params">(InputIterator f, InputIterator l, size_type n)</span></span></span><br><span class="line"><span class="function">    : rep(n, hasher(), key_equel()) &#123;</span> rep.<span class="built_in">insert_equal</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">hash_multiset</span><span class="params">(InputIterator f, InputIterator l, size_type n, <span class="type">const</span> hasher&amp; hf)</span></span></span><br><span class="line"><span class="function">    : rep(n, hf, key_equel()) &#123;</span> rep.<span class="built_in">insert_equal</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">hash_multiset</span><span class="params">(InputIterator f, InputIterator l, size_type n, <span class="type">const</span> hasher&amp; hf</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> key_equel&amp; eql)</span></span></span><br><span class="line"><span class="function">    : rep(n, hf, eql) &#123;</span> rep.<span class="built_in">insert_equal</span>(f, l); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_multiset&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_multiset&amp;, <span class="type">const</span> hash_multiset&amp;);</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> rep.<span class="built_in">insert_equal</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_equal</span>(f,l); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> rep.<span class="built_in">insert_equal_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相等的key的位置(是一个左闭右开的区间)，由迭代器给出</span></span><br><span class="line">    <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>    <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> hash_multiset&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; hs1,</span><br><span class="line">                           <span class="type">const</span> hash_multiset&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; hs2)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">return</span> has<span class="number">1.</span>rep == has<span class="number">2.</span>rep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="hash-multimap"><a href="#hash-multimap" class="headerlink" title="hash_multimap"></a>hash_multimap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Value&gt;,</span><br><span class="line"><span class="keyword">class</span> EqualKey = equal_to&lt;Value&gt;, <span class="keyword">class</span> Alloc=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> hash_multimap</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;pair&lt;<span class="type">const</span> Key, T&gt;, Key, HashFcn,</span><br><span class="line">    select1st&lt;pair&lt;<span class="type">const</span> Key, T&gt;, EqualKey, Alloc&gt; ht;</span><br><span class="line"></span><br><span class="line">    ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">    <span class="keyword">typedef</span> T data_type;</span><br><span class="line">    <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;         <span class="comment">//hashtable中: typedef HashFcn hasher</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equel key_equel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">    <span class="function">key_equel <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各种构造函数 ,不给定大小的话默认值为100,实际上找到的质数为193</span></span><br><span class="line">    <span class="built_in">hash_multimap</span>() : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equel</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">hash_multimap</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equel()) &#123;</span>&#125;</span><br><span class="line">    <span class="built_in">hash_multimap</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equel</span>()) &#123;&#125;</span><br><span class="line">    <span class="built_in">hash_multimap</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equel&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">hash_multimap</span><span class="params">(InputIterator f, InputIterator l)</span></span></span><br><span class="line"><span class="function">    : rep(<span class="number">100</span>, hasher(), key_equel()) &#123;</span> rep.<span class="built_in">insert_equal</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">hash_multimap</span><span class="params">(InputIterator f, InputIterator l, size_type n)</span></span></span><br><span class="line"><span class="function">    : rep(n, hasher(), key_equel()) &#123;</span> rep.<span class="built_in">insert_equal</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">hash_multimap</span><span class="params">(InputIterator f, InputIterator l, size_type n, <span class="type">const</span> hasher&amp; hf)</span></span></span><br><span class="line"><span class="function">    : rep(n, hf, key_equel()) &#123;</span> rep.<span class="built_in">insert_equal</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">hash_multimap</span><span class="params">(InputIterator f, InputIterator l, size_type n, <span class="type">const</span> hasher&amp; hf</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> key_equel&amp; eql)</span></span></span><br><span class="line"><span class="function">    : rep(n, hf, eql) &#123;</span> rep.<span class="built_in">insert_equal</span>(f, l); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_multimap&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_multimap&amp;, <span class="type">const</span> hash_multimap&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> rep.<span class="built_in">insert_equal</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_equal</span>(f,l); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  rep.<span class="built_in">insert_equal_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相等的key的位置(是一个左闭右开的区间)，由迭代器给出</span></span><br><span class="line">    <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>    <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> hash_multimap&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; hm1,</span><br><span class="line">                           <span class="type">const</span> hash_multimap&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; hm2)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">return</span> has<span class="number">1.</span>rep == has<span class="number">2.</span>rep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="算法概观"><a href="#算法概观" class="headerlink" title="算法概观"></a>算法概观</h2><p>算法，问题之解法也。以有限的步骤，解决逻辑或数学上的问题，这一专门科目称为算法。STL 正是将极具复用价值的算法进行封装，包含sort,find,copy等函数。</p>
<h3 id="STL算法总览"><a href="#STL算法总览" class="headerlink" title="STL算法总览"></a>STL算法总览</h3><p>表格中凡是不在STL标准规格之列的SGI专属算法，都以*加以标识。<br><img src="/img/1610357891.jpg" alt=""><br><img src="/img/1610358110.jpg" alt=""><br><img src="/img/1610358139.jpg" alt=""><br><img src="/img/1610358159.jpg" alt=""></p>
<p>所有的STL算法都作用在迭代器 [first,last) 所标出来的区间上。根据是否改变操作对象的值，可以分为 <strong>质变算法</strong>（mutating algorithms）和 <strong>非质变算法</strong> （nomutating algorithms）。</p>
<p>质变算法，是指运算过程中会更改区间内元素的内容的算法。比如，拷贝（copy），互换（swap），替换（replace），填写（fill），删除（remove），排列组合（permutation），分割（partition），随机重排（random shuffling），排序（sort）等。</p>
<p>非质变算法，是指运算过程中不会更改区间内元素的内容的算法。比如，查找（find），匹配（search），计数（count），巡访（for_each），比较（equal,mismatch），寻找极值（max,min）等。但是在for_each算法上应用一个会改变元素内容的仿函数，所在元素必然会改变：</p>
<h3 id="算法的泛化过程"><a href="#算法的泛化过程" class="headerlink" title="算法的泛化过程"></a>算法的泛化过程</h3><p>如何将算法独立于其所处理的数据结构之外，不受数据结构的约束？关键在于，要把操作对象的型别加以抽象化，把操作对象的标示法和区间目标的移动行为抽象化，整个算法也就在一个抽象层面上工作了。整个过程称为算法的泛型化（generalized），简称泛化。</p>
<p>以简单的循序查找为例，编写find()函数，在array中寻找特定值。面对整数array，写出如下程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">find</span><span class="params">(<span class="type">int</span>* arrayHead, <span class="type">int</span> arraySize, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i&lt;arraySize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrayHead[i] == value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> &amp;(arrayHead[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述find()函数写法暴露了太多的实现细节（例如arraySize），为了让find()适用于所有类型的容器，其操作应该更抽象化些。让find()接受两个指针作为参数，标示一个操作区间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">find</span><span class="params">(<span class="type">int</span>* begin, <span class="type">int</span>*end, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(begin !=end &amp;&amp; *begin != value)</span><br><span class="line">        ++begin;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于find()函数之内并无任何操作是针对特定整数array而发的，所以我们可以把它改成一个template：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">find</span><span class="params">(T* begin, T* end, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意，以下用到了operator!=, operator*, operator++</span></span><br><span class="line">    <span class="keyword">while</span> (begin != end &amp;&amp; *begin != value)</span><br><span class="line">        ++begin;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 注意，以下返回操作用会引发copy行为</span></span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上述代码中，传入的指针必须支持以下四种操作行为：</p>
<ul>
<li>inequality 判断不相等</li>
<li>dereferencelm 提领</li>
<li>prefix increment 前置式递增</li>
<li>copy 复制</li>
</ul>
<p>上述操作符可以被重载（overload），find()函数就可以从原生（native）指针的思想框框中跳脱出来。我们可以设计一个class，拥有原生指针的行为，这就是迭代器（iterator）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">find</span><span class="params">(Iterator begin, Iterator end, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(begin != end &amp;&amp; *begin != value)</span><br><span class="line">        ++begin;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>至此，便是完全泛型化的find()函数。</p>
<h2 id="数值算法"><a href="#数值算法" class="headerlink" title="数值算法"></a>数值算法</h2><p>C++ STL 的数值算法(Numeric algorithms)是一组对容器元素进行数值计算的模板函数，包括容器元素求和 accumulate 、两序列元素的内积 inner_product 、容器元素的一系列部分元素和 partial_sum 、容器每对相邻元素的差adjacent_difference。其头文件为<code>&lt;numeric&gt;</code>，测试实例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 6numeric.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// minus&lt;int&gt;()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   <span class="comment">// ostream_iterator</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 0+1+2+3...</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">accumulate</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">0</span>) &lt;&lt; endl; </span><br><span class="line">    <span class="comment">//0是初值，T accumulate(InputIterator first, InputIterator last, T init)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0-1-2-3</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">accumulate</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 10 + 1*1 + 2*2 + ...</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">inner_product</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv.<span class="built_in">begin</span>(), <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 10 - 1+1 - 2+2 - ...</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">inner_product</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv.<span class="built_in">begin</span>(), <span class="number">10</span>,</span><br><span class="line">        <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;(), <span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将迭代器绑定到cout，作为输出用</span></span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">oite</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1 3 6 10 15 累计和</span></span><br><span class="line">    <span class="built_in">partial_sum</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), oite);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1 -1 -4 -8 -13 累计差</span></span><br><span class="line">    <span class="built_in">partial_sum</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), oite, <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1 1 1 1 1     new #n = #n - #n-1</span></span><br><span class="line">    <span class="built_in">adjacent_difference</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), oite);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1 3 5 7 9      new #n = op(#n, #n-1)</span></span><br><span class="line">    <span class="built_in">adjacent_difference</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), oite, <span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// mingw c++ 中stl没有power实现</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; power(10, 3) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; power(10, 3, plus&lt;int&gt;()) &lt;&lt; endl;</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">iota</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), n); <span class="comment">// 填入n, n+1, n+2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iv.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; iv[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@192 6_STL_algorithms] ./6_3_1_numeric</span><br><span class="line">15</span><br><span class="line">-15</span><br><span class="line">65</span><br><span class="line">-20</span><br><span class="line">1 3 6 10 15</span><br><span class="line">1 -1 -4 -8 -13</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 3 5 7 9</span><br><span class="line">3 4 5 6 7 [</span><br></pre></td></tr></table></figure></p>
<h3 id="accumlate"><a href="#accumlate" class="headerlink" title="accumlate"></a>accumlate</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	函数名：accumulate</span></span><br><span class="line"><span class="comment">*	功能：  将指定区间内的元素累加</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 版本1，算法缺省行为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; first++)</span><br><span class="line">	&#123;</span><br><span class="line">		init = init + *first;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 版本2，接收外界传入一个仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; first != last; first++)</span><br><span class="line">	&#123;</span><br><span class="line">		init = <span class="built_in">binary_op</span>(init, *first);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="adjacent-differencee"><a href="#adjacent-differencee" class="headerlink" title="adjacent_differencee"></a>adjacent_differencee</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	函数名：	adjacent_differencee</span></span><br><span class="line"><span class="comment">*	功能：	计算[first,last)中相邻元素的差额，首元素内容不变</span></span><br><span class="line"><span class="comment">*	说明：	与partial_sum互为逆运算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 版本1，算法缺省行为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> result;	<span class="comment">// 区间内容为空直接返回result</span></span><br><span class="line">	&#125;</span><br><span class="line">	*result = *first;	<span class="comment">// 首先记录第一个元素(即原容器中第一个元素内容不变)</span></span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::value_type value = *first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)	<span class="comment">// 之后的元素为本位置-前一个位置的值</span></span><br><span class="line">	&#123;</span><br><span class="line">		T tmp = *first;</span><br><span class="line">		*++first = tmp - value;</span><br><span class="line">		value = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 版本2，接收外界传入一个仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">(InputIterator first, InputIterator last, </span></span></span><br><span class="line"><span class="params"><span class="function">									OutputIterator result, BinaryOperation binary_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> result;	<span class="comment">// 区间内容为空直接返回result</span></span><br><span class="line">	&#125;</span><br><span class="line">	*result = *first;	<span class="comment">// 首先记录第一个元素(即原容器中第一个元素内容不变)</span></span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::value_type value = *first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)	</span><br><span class="line">	&#123;</span><br><span class="line">		T tmp = *first;</span><br><span class="line">		*++first = <span class="built_in">binary_op</span>(tmp, value);</span><br><span class="line">		value = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="partial-sum"><a href="#partial-sum" class="headerlink" title="partial_sum"></a>partial_sum</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	函数名：	partial_sum</span></span><br><span class="line"><span class="comment">*	功能：	计算[first,last)中相邻元素的差额，首元素内容不变</span></span><br><span class="line"><span class="comment">*	说明：	与adjacent_difference互为逆运算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 版本1，算法缺省行为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">partial_sum</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> result;	<span class="comment">// 区间内容为空直接返回result</span></span><br><span class="line">	&#125;</span><br><span class="line">	*result = *first;	<span class="comment">// 首先记录第一个元素(即原容器中第一个元素内容不变)</span></span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::value_type value = *first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)	<span class="comment">// 之后的元素为本位置+前一个位置的值</span></span><br><span class="line">	&#123;</span><br><span class="line">		value = value + *first;</span><br><span class="line">		*++result = value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 版本2，接收外界传入一个仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">partial_sum</span><span class="params">(InputIterator first, InputIterator last, </span></span></span><br><span class="line"><span class="params"><span class="function">							OutputIterator result, BinaryOperation binary_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> result;	<span class="comment">// 区间内容为空直接返回result</span></span><br><span class="line">	&#125;</span><br><span class="line">	*result = *first;	<span class="comment">// 首先记录第一个元素(即原容器中第一个元素内容不变)</span></span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::value_type value = *first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)	</span><br><span class="line">	&#123;</span><br><span class="line">		value = <span class="built_in">binary_op</span>(value, *first);</span><br><span class="line">		*++result = value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="power"><a href="#power" class="headerlink" title="power"></a>power</h3><p>考虑x^23，可以先从x -&gt;x^2 -&gt; x^4 -&gt; x^8 -&gt; x^16 取result1 = x^16，然后23-16=7。<br>我们只要计算x^7再与result1相乘就可以得到x^23。对于x^7也可以采用这种方法</p>
<p>取result2 = x^4，然后7-4=3，只要计算x^3再与result2相乘就可以得到x^7。由此可以将x^23写成x^16 <em> x^4</em> x^2 <em> x，即23=16+4+2+1，而23 = 10111(二进制)，所以只要将n化为二进制并由低位到高位依次判断如果第i位为1，则result </em>=x^(2^i)。</p>
<p>此函数可以在相乘O(logN)次内计算x的n次幂，且避免了重复计算。但还可以作进一步的优化，如像48=110000(二进制)这种低位有很多0的数，可以先过滤掉低位的0再进行计算，这样也会提高一些效率。程序如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	函数名：	power</span></span><br><span class="line"><span class="comment">*	功能：	对自己进行某种运算n次，缺省值是乘方</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 版本1，算法缺省行为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Integer</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">power</span><span class="params">(T x, Integer n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">power</span>(x,n,<span class="built_in">multiplies</span>&lt;T&gt;());	<span class="comment">// multiplies&lt;T&gt;()是一个仿函数的临时对象，意为相乘</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 版本2，如果指定为乘方运算，则当n &gt;= 0时返回x^n</span></span><br><span class="line"><span class="comment">// MonoidOperation必须满足结合律，可不满足交换律</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Integer</span>, <span class="keyword">class</span> <span class="title class_">MonoidOperation</span> op&gt;</span><br><span class="line"><span class="function">T <span class="title">power</span><span class="params">(T x, Integer n, MonoidOperation op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)	<span class="comment">// 直接返回1也行</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">identity_element</span>(op);	<span class="comment">// 取出证同元素</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>	<span class="comment">// 过滤低位的0</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			n &gt;&gt;= <span class="number">1</span>;	<span class="comment">// n右移一位</span></span><br><span class="line">			x = <span class="built_in">op</span>(x, x);	<span class="comment">// x = x op x;</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	T result = x;</span><br><span class="line">	n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = <span class="built_in">op</span>(x, x);</span><br><span class="line">		<span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			result = <span class="built_in">op</span>(result, x);</span><br><span class="line">		&#125;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="inner-product"><a href="#inner-product" class="headerlink" title="inner_product"></a>inner_product</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	函数名：	inner_product</span></span><br><span class="line"><span class="comment">*	功能：	计算[first1,last1)和[first2,first2+(last1 - first1))的一般内积</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 版本1，算法缺省行为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">inner_product</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">				InputIterator2 first2, T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 以第一序列为依据，将两个序列都走一遍</span></span><br><span class="line">	<span class="keyword">for</span> (; first1 != last1; ++first1, ++first2)</span><br><span class="line">	&#123;</span><br><span class="line">		init = init + (*first1 * *first2);	<span class="comment">//执行两个序列的一般内积</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, </span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">BinaryOperation1</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation2</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">inner_product</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">				InputIterator2 first2, T init, </span></span></span><br><span class="line"><span class="params"><span class="function">				BinaryOperation1 binary_op1, BinaryOperation2 binary_op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 以第一序列为依据，将两个序列都走一遍</span></span><br><span class="line">	<span class="keyword">for</span> (; first1 != last1; ++first1, ++first2)</span><br><span class="line">	&#123;</span><br><span class="line">		init = <span class="built_in">binary_op1</span>(init, <span class="built_in">binary_op2</span>(*first1, *first2));	<span class="comment">//执行两个序列的一般内积</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	函数名：	iota</span></span><br><span class="line"><span class="comment">*	功能：	在区间[first,last)填入value,value+1,value+2,value+3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iota</span><span class="params">(ForwardIterator first, ForwardIterator last, T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first != last)</span><br><span class="line">	&#123;</span><br><span class="line">		*first = value++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法<stl_algobase.h></h2><p>STL标准中没有区分基本算法或复杂算法，单SGI把常用的一些算法（equal，fill，fill_n，iter_swap，lexicographical_compare，max，min，mismatch，swap，copy，copy_backward，copy_n）定义在<code>&lt;stl_algobase.h&gt;</code>只中，其他算法定义在<code>&lt;stl_algo.h&gt;</code>中。</p>
<p>equal作用：判断[first,last)区间两个元素是否相同，第二个迭代器多出来的元素不予考虑。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIter1</span>, <span class="keyword">class</span> <span class="title class_">_InputIter2</span>&gt;<span class="comment">//版本1</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(_InputIter1 __first1, _InputIter1 __last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                  _InputIter2 __first2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; __first1 != __last1; ++__first1, ++__first2)<span class="comment">//遍历区间[first，last)元素</span></span><br><span class="line">    <span class="keyword">if</span> (*__first1 != *__first2)<span class="comment">//只有有一个不相等返回false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIter1</span>, <span class="keyword">class</span> <span class="title class_">_InputIter2</span>, <span class="keyword">class</span> <span class="title class_">_BinaryPredicate</span>&gt;<span class="comment">//版本2</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(_InputIter1 __first1, _InputIter1 __last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                  _InputIter2 __first2, _BinaryPredicate __binary_pred)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; __first1 != __last1; ++__first1, ++__first2)</span><br><span class="line">    <span class="keyword">if</span> (!__binary_pred(*__first1, *__first2))<span class="comment">//两个元素执行二元操作符</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fill作用：将指定区间元素改为新值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_ForwardIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(_ForwardIter __first, _ForwardIter __last, <span class="type">const</span> _Tp&amp; __value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)<span class="comment">//遍历整个区间</span></span><br><span class="line">    *__first = __value;<span class="comment">//指定新值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fill_n作用：将指定区间前n个元素改为新值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_OutputIter</span>, <span class="keyword">class</span> <span class="title class_">_Size</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function">_OutputIter <span class="title">fill_n</span><span class="params">(_OutputIter __first, _Size __n, <span class="type">const</span> _Tp&amp; __value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; __n &gt; <span class="number">0</span>; --__n, ++__first)</span><br><span class="line">    *__first = __value;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>iter_swap作用：将两个迭代器所指对象调换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_ForwardIter1</span>, <span class="keyword">class</span> <span class="title class_">_ForwardIter2</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __iter_swap(_ForwardIter1 __a, _ForwardIter2 __b, _Tp*) &#123;</span><br><span class="line">  _Tp __tmp = *__a;</span><br><span class="line">  *__a = *__b;</span><br><span class="line">  *__b = __tmp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_ForwardIter1</span>, <span class="keyword">class</span> <span class="title class_">_ForwardIter2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">iter_swap</span><span class="params">(_ForwardIter1 __a, _ForwardIter2 __b)</span> </span>&#123;</span><br><span class="line">  __iter_swap(__a, __b, __VALUE_TYPE(__a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>iter_swap()</code>是“迭代器之value type派上用场的一个好例子。是的，该函数必须知道迭代器的value type，才能够据此声明一个对象，用来暂时存放迭代器所指对象。为此，上述源代码特别设计了一个双层构造，第一层调用第二层：并多出一个额外的参数<code>value_type(a)</code>。这么一来，第二层就有value type可以用了。乍见之下你可能会对这个额外参数在调用端和接受端的型别感到讶异，调用端是<code>value_type(a)</code>，接受端却是<code>T*</code>。只要找出<code>value_type()</code>的定义瞧瞧，就一点也不奇怪了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type* <span class="title">value_type</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种双层构造在SGI STL源代码中十分普遍。其实这并非必要，直接这么写就行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">iter_swap</span><span class="params">(ForwardIterator1 a, ForwardIterator2 b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;ForwardIterator1&gt;::value_type tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>lexicographical_compare作用：以“字典排列方式”对两个序列[first1, last1)和[first2, last2)进行比较。比较操作针对两序列中的对应位置上的元素进行，并持续直到：</p>
<ul>
<li>某组对应元素彼此不相等；</li>
<li>同时到达last1和last2（当两序列的大小相同）；</li>
<li>到达last1或last2（当两序列的大小不同）</li>
</ul>
<p>当这个函数在对应位置上发现第一组不相等的元素时，有下列几种可能：</p>
<ul>
<li>如果第一序列的元素较小，返回true，否则返回false；</li>
<li>如果到达last1而尚未到达last2，返回true；</li>
<li>如果到达llast2而尚未到达last1，返回false；</li>
<li>如果同时到达last1和last2（换句话说所有元素都匹配），返回false。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典序比较, 非常类似字符串的比较</span></span><br><span class="line"><span class="comment">// 具体比较方式参见STL文档, 另外strcmp()也可以参考</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lexicographical_compare</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">			     InputIterator2 first2, InputIterator2 last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first1 != last1 &amp;&amp; first2 != last2; ++first1, ++first2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first1 &lt; *first2)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first1 == last1 &amp;&amp; first2 != last2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 二元判别式自己指定, 其余同上</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lexicographical_compare</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">			     InputIterator2 first2, InputIterator2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">			     Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first1 != last1 &amp;&amp; first2 != last2; ++first1, ++first2)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*first1, *first2))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*first2, *first1))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first1 == last1 &amp;&amp; first2 != last2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 针对字符串的特化, 针对原生指针const unsigned char*，效率至上</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">lexicographical_compare</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* first1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* first2,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> len1 = last1 - first1;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> len2 = last2 - first2;</span><br><span class="line">  <span class="comment">//memcmp标准C函数</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> result = <span class="built_in">memcmp</span>(first1, first2, <span class="built_in">min</span>(len1, len2));</span><br><span class="line">  <span class="keyword">return</span> result != <span class="number">0</span> ? result &lt; <span class="number">0</span> : len1 &lt; len2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 针对字符串的特化, 针对原生指针const char*，效率至上</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">lexicographical_compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* first1, <span class="type">const</span> <span class="type">char</span>* last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> <span class="type">char</span>* first2, <span class="type">const</span> <span class="type">char</span>* last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CHAR_MAX == SCHAR_MAX</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lexicographical_compare</span>((<span class="type">const</span> <span class="type">signed</span> <span class="type">char</span>*) first1,</span><br><span class="line">                                 (<span class="type">const</span> <span class="type">signed</span> <span class="type">char</span>*) last1,</span><br><span class="line">                                 (<span class="type">const</span> <span class="type">signed</span> <span class="type">char</span>*) first2,</span><br><span class="line">                                 (<span class="type">const</span> <span class="type">signed</span> <span class="type">char</span>*) last2);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lexicographical_compare</span>((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*) first1,</span><br><span class="line">                                 (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*) last1,</span><br><span class="line">                                 (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*) first2,</span><br><span class="line">                                 (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*) last2);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 一句话概括, 这个是strcmp()的泛化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lexicographical_compare_3way</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 InputIterator2 first2, InputIterator2 last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first1 &lt; *first2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ++first1; ++first2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (first2 == last2) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(first1 == last1);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 特换版本, 效率决定一切</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">lexicographical_compare_3way</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* first1,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* first2,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">ptrdiff_t</span> len1 = last1 - first1;</span><br><span class="line">  <span class="type">const</span> <span class="type">ptrdiff_t</span> len2 = last2 - first2;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> result = <span class="built_in">memcmp</span>(first1, first2, <span class="built_in">min</span>(len1, len2));</span><br><span class="line">  <span class="keyword">return</span> result != <span class="number">0</span> ? result : (len1 == len2 ? <span class="number">0</span> : (len1 &lt; len2 ? <span class="number">-1</span> : <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lexicographical_compare_3way</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* first1, <span class="type">const</span> <span class="type">char</span>* last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> <span class="type">char</span>* first2, <span class="type">const</span> <span class="type">char</span>* last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CHAR_MAX == SCHAR_MAX</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lexicographical_compare_3way</span>(</span><br><span class="line">				(<span class="type">const</span> <span class="type">signed</span> <span class="type">char</span>*) first1,</span><br><span class="line">                                (<span class="type">const</span> <span class="type">signed</span> <span class="type">char</span>*) last1,</span><br><span class="line">                                (<span class="type">const</span> <span class="type">signed</span> <span class="type">char</span>*) first2,</span><br><span class="line">                                (<span class="type">const</span> <span class="type">signed</span> <span class="type">char</span>*) last2);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lexicographical_compare_3way</span>((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*) first1,</span><br><span class="line">                                      (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*) last1,</span><br><span class="line">                                      (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*) first2,</span><br><span class="line">                                      (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*) last2);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="max"><a href="#max" class="headerlink" title="max"></a>max</h3><p>去两个对象中的较大值，有两个版本，版本一使用对象类型T所提供的greater-than判断大小，版本二使用仿函数comp判断大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, Compare comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">comp</span>(a, b) ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="min"><a href="#min" class="headerlink" title="min"></a>min</h3><p>max和min非常简单了, 由于返回的是引用, 因此可以嵌套使用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b &lt; a ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, Compare comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">comp</span>(b, a) ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch"></a>mismatch</h3><p>用来平行比较两个序列，指出两者之间的第一个不匹配点：返回一对迭代器，分别指向两序列中的不匹配点，如下图，如果两序列的所有对应元素都匹配，返回的便是两序列各自的iast迭代器。缺省情况下是以equality操作符来比较元素。但第二版本允许用户指定比较操作。如果第二序列的元素个数比第一序列多，多出 来的元素忽略不计。如果第几序列的元素个数比第一序列少，会发生未可预期的行为。</p>
<p><img src="/img/1610542684.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line"><span class="function">pair&lt;InputIterator1, InputIterator2&gt; <span class="title">mismatch</span><span class="params">(InputIterator1 first1,</span></span></span><br><span class="line"><span class="params"><span class="function">					      InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">					      InputIterator2 first2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 遍历区间, 寻找失配点</span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; *first1 == *first2) &#123;</span><br><span class="line">    ++first1;</span><br><span class="line">    ++first2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pair</span>&lt;InputIterator1, InputIterator2&gt;(first1, first2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供用户自定义的二元判别式, 其余同上</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function">pair&lt;InputIterator1, InputIterator2&gt; <span class="title">mismatch</span><span class="params">(InputIterator1 first1,</span></span></span><br><span class="line"><span class="params"><span class="function">					      InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">					      InputIterator2 first2,</span></span></span><br><span class="line"><span class="params"><span class="function">					      BinaryPredicate binary_pred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; <span class="built_in">binary_pred</span>(*first1, *first2)) &#123;</span><br><span class="line">    ++first1;</span><br><span class="line">    ++first2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pair</span>&lt;InputIterator1, InputIterator2&gt;(first1, first2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>交换对调两个对象内容<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换a和b的值</span></span><br><span class="line"><span class="comment">//这里采用引用传参</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T tmp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p><code>copy()</code>是一个调用频率非常高的函数，所以SGI STL的copy算法用尽各种办法，包括函数重载(function overloading)、型别特性(type traits)、偏特化(partial specialization)编程技巧，无所不用其极地加强效率。下图是整个<code>copy()</code>操作的脉络。<br><img src="/img/1610542923.jpg" alt=""></p>
<p>copy算法将输入区间[first, last)内的元素复制到result指向的输出区间内，赋值操作是向前推进的。如果输入区间和输出区间重叠，复制顺序需要多加讨论。当result位于[first, last)之内时，也就是说，如果输出区间的首部与输入区间重叠，copy的结果可能不正确，建议选用copy_backward；如果输出区间的尾部如输入区间重叠，copy_backward的结果可能不正确，建议选用copy。当然，如果两区间完全不重叠，copy和copy_backward都可以选用。<br><img src="/img/1610543021.jpg" alt=""></p>
<p>copy算法根据输出迭代器的特性决定是否调用<code>memmove()</code>来执行任务，<code>memmove()</code>会先将整个输入区间的内容复制下来，然后再复制到输入区间。这种情况下，即使输入区间和输出区间有重叠时，copy的结果也是正确的。这也回答了上文中提调的，为什么result位于[first, last)之内时，copy的结果只是“可能不正确”。</p>
<p>copy为输出区间内的元素赋予新值，而不是产生新元素，它不能改变输出区间的长度。换句话说，copy不能用来直接将元素插入到空容器中。如果你想要将元素插入序列之中，要么使用序列容器的insert成员函数，要么使用copy算法并搭配insert_iterator。</p>
<p>下面是copy算法唯三的对外接口，包括一个完全泛化版本和两个重载函数，重载函数针对原生指针<code>const char*</code>和<code>const wchar_t*</code>进行内存直接拷贝操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator</span></span><br><span class="line"><span class="function"><span class="title">copy</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> __copy_dispatch&lt;InputIterator, OutputIterator&gt;()(first, last, result); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* first, <span class="type">const</span> <span class="type">char</span>* last, <span class="type">char</span>* result)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">memmove</span>(result, first, last - first); </span><br><span class="line">    <span class="keyword">return</span> result + (last - first); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">wchar_t</span>* <span class="title">copy</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* first, <span class="type">const</span> <span class="type">wchar_t</span>* last, <span class="type">wchar_t</span>* result)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">memmove</span>(result, first, last - first); </span><br><span class="line">    <span class="keyword">return</span> result + (last - first); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>copy()</code>函数的泛化版本中调用了一个<code>__copy_dispatch()</code>的仿函数，此仿函数有一个完全泛化版本和两个偏特化版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__copy_dispatch</span> &#123;  </span><br><span class="line">    <span class="function">OutputIterator <span class="title">operator</span><span class="params">()</span></span>&#123;InputIterator first, InputIterator last, OutputIterator result) &#123;  </span><br><span class="line">        <span class="keyword">return</span> __copy(first, last, result, <span class="built_in">iterator_category</span>(first);</span><br><span class="line">&#125; ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> __copy_dispatch&lt;T*, T*&gt; &#123;  </span><br><span class="line">    T* <span class="built_in">operator</span>()(T* first, T* last, T* result) &#123;  </span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_assignment_operator t;  </span><br><span class="line">        <span class="keyword">return</span> <span class="type">__copy_t</span>(first, last, result, <span class="built_in">t</span>());  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;  </span><br><span class="line"><span class="keyword">struct</span> __copy_dispatch&lt;<span class="type">const</span> T*, T*&gt; &#123;  </span><br><span class="line">    T* <span class="built_in">operator</span>()(T* first, T* last, T* result) &#123;  </span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_asssignment_operator t;  </span><br><span class="line">        <span class="keyword">return</span> <span class="type">__copy_t</span>(first, last, result, <span class="built_in">t</span>());  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure></p>
<p><code>__copy_dispatch()</code>的完全泛化版本根据迭代器种类的不同，调用不同的<code>__copy()</code>，为的是不同的迭代器使用的循环条件不同，有快慢之别<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> OutputIterator __copy(InputIterator first, InputIterator last, </span><br><span class="line">OutputIterator result, input_iterator_tag) &#123; </span><br><span class="line">    <span class="keyword">for</span>( ; first != last; ++first, ++result) </span><br><span class="line">        *result = *first; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> OutputIterator __copy(RandomAccessIterator first, RandomAccessIterator last, </span><br><span class="line">OutputIterator result, random_access_iterator_tag) &#123; </span><br><span class="line">    __return __copy_d(first, last, result, <span class="built_in">distance_type</span>(first)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> OutputIterator __copy_d(RandomAccessIterator first, RandomAccessIterator last, </span><br><span class="line">OutputIterator result, Distance*) &#123; </span><br><span class="line">    <span class="comment">// 以n决定循环次数，速度快 </span></span><br><span class="line">    <span class="keyword">for</span>(Distance n = last - first; n &gt; <span class="number">0</span>; --n, ++result, ++first) &#123; </span><br><span class="line">        *result = *first; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p>这两个偏特化版本是在“参数为原生指针形式”的前提下，利用<code>__type_traits&lt;&gt;</code>编程技巧来探测指针所指向之物是否有trivial assignment operator. 如果指针所指对象拥有trivial assignment operator，则可以通过<code>memmove()</code>进行复制，速度要比利用赋值操作赋快许多。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> T* <span class="type">__copy_t</span>(<span class="type">const</span> T* first, <span class="type">const</span> T* last, T* result, __true_type)  &#123; </span><br><span class="line">    <span class="built_in">memmove</span>(result, first, <span class="built_in">sizeof</span>(T) *(last - first); </span><br><span class="line">    <span class="keyword">return</span> result + (last - first); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; </span><br><span class="line"><span class="keyword">inline</span> T* <span class="type">__copy_t</span>(<span class="type">const</span> T* first, <span class="type">const</span> T* last, T* result, __false_type) &#123; </span><br><span class="line">    <span class="keyword">return</span> __copy_d(first, last, result, (<span class="type">ptrdiff_t</span> *)<span class="number">0</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h3 id="copy-backward"><a href="#copy-backward" class="headerlink" title="copy_backward"></a>copy_backward</h3><p><code>copy_backward()</code>的实现与<code>copy()</code>极为相似，不同是它将[first, last)区间内的每一个元素，以逆行的方向复制到，以result-1为起点，方向同样为逆行的区间上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator1</span>, <span class="keyword">class</span> <span class="title class_">BidirectionalIterator2</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> BidirectionalIterator2 __copy_backward(BidirectionalIterator1 first,</span><br><span class="line">                                              BidirectionalIterator1 last,</span><br><span class="line">                                              BidirectionalIterator2 result)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last) *--result = *--last;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个算法的考虑以及实现的技巧与copy十分类似，其操作示意如图，将[first, last)区间内的每一个元素，以逆行的方向复制到，以result-1为起点，方向同样为逆行的区间上。返回一个迭代器<code>result-(last-first)</code>。<code>copy_backward</code>所接受的迭代器必须是BidirectionIterators才能够“倒行逆施”。<br><img src="/img/1610543888.jpg" alt=""></p>
<h2 id="set相关算法"><a href="#set相关算法" class="headerlink" title="set相关算法"></a>set相关算法</h2><p>STL提供了4个set相关的算法，分别是并集（union）、交集（intersection）、差集（difference）和对称差集（symmetric difference），这4个算法接受的set必须是有序区间，都至少接受4个参数，分别表示两个set区间。一般而言，set算法前4个参数分别表示两个区间，第五个参数表示存放结果的区间的起始位置。</p>
<h3 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h3><p>求两个集合的并集，能够造出S1 U S2，此集合内含S1或S2内的每一个元素。如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现max(m, n)次。返回值为一个迭代器，指向输出区间的尾端。是一种稳定操作，输入区间内的每个元素相对顺序都不会改变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并集，求存在于[first1, last1)或存在于[first2, last2)内的所有元素  </span></span><br><span class="line"><span class="comment">//注意：输入区间必须是已排序  </span></span><br><span class="line"><span class="comment">//版本一,默认是operator&lt;操作的排序方式  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;  </span><br><span class="line"><span class="function">OutputIterator <span class="title">set_union</span><span class="params">(InputIterator1 first1, InputIterator1 last1,  </span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator2 first2, InputIterator2 last2,  </span></span></span><br><span class="line"><span class="params"><span class="function">    OutputIterator result)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//两个区间都尚未到达区间尾端，执行以下操作  </span></span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;  </span><br><span class="line">        <span class="comment">/*在两区间内分别移动迭代器，首先将元素较小者(假设为A区)记录在目标区result，</span></span><br><span class="line"><span class="comment">        移动A区迭代器使其前进；同时另一个区的迭代器不变。然后进行一次新的比较， </span></span><br><span class="line"><span class="comment">        记录较小值，移动迭代器...直到两区间中有一个到达尾端。</span></span><br><span class="line"><span class="comment">        若元素相等， 默认取第一区间元素到目标区result，同时移动两个迭代器.*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (*first1 &lt; *first2) &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1) &#123;  </span><br><span class="line">            *result = *first2;  </span><br><span class="line">            ++first2;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++first2;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ++result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/*只要两区间之中有一个区间到达尾端，就结束上面的while循环</span></span><br><span class="line"><span class="comment">    以下将尚未到达尾端的区间剩余的元素拷贝到目标区 </span></span><br><span class="line"><span class="comment">    此刻，[first1, last1)和[first2, last2)至少有一个是空区间*/</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//版本二,用户根据仿函数comp指定排序规则  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>&gt;  </span><br><span class="line"><span class="function">OutputIterator <span class="title">set_union</span><span class="params">(InputIterator1 first1, InputIterator1 last1,  </span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator2 first2, InputIterator2 last2,  </span></span></span><br><span class="line"><span class="params"><span class="function">    OutputIterator result, Compare comp)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comp</span>(*first1, *first2)) &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">comp</span>(*first2, *first1)) &#123;  </span><br><span class="line">            *result = *first2;  </span><br><span class="line">            ++first2;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++first2;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ++result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>图解如下：<br><img src="/img/1610544166.jpg" alt=""></p>
<h3 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h3><p>求两个集合的交集，此集合内含同时出现于S1和S2内的每一个元素。如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现min(m, n)次，并且全部来自S1。</p>
<p>返回值为一个迭代器，指向输出区间的尾端。</p>
<p>是一种稳定操作，输入区间内的每个元素相对顺序都不会改变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交集，求存在于[first1, last1)且存在于[first2, last2)内的所有元素  </span></span><br><span class="line"><span class="comment">//注意：输入区间必须是已排序  </span></span><br><span class="line"><span class="comment">//版本一,默认是operator&lt;操作的排序方式  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;  </span><br><span class="line"><span class="function">OutputIterator <span class="title">set_intersection</span><span class="params">(InputIterator1 first1, InputIterator1 last1,  </span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator2 first2, InputIterator2 last2,  </span></span></span><br><span class="line"><span class="params"><span class="function">    OutputIterator result)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//若两个区间都尚未到达尾端，则执行以下操作  </span></span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)  </span><br><span class="line">        <span class="comment">//在两个区间分别移动迭代器，直到遇到相等元素，记录到目标区  </span></span><br><span class="line">        <span class="comment">//继续移动迭代器...直到两区间之中有一区到达尾端  </span></span><br><span class="line">        <span class="keyword">if</span> (*first1 &lt; *first2)  </span><br><span class="line">            ++first1;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1)  </span><br><span class="line">            ++first2;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++first2;  </span><br><span class="line">            ++result;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<p>图解如下：<br><img src="/img/1610544209.jpg" alt=""></p>
<h3 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h3><p>求两个集合的差集，此集合内含出现于S1但不出现于S2内的元素。如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现max(n-m, 0)次，并且全部来自S1。</p>
<p>返回值为一个迭代器，指向输出区间的尾端。</p>
<p>是一种稳定操作，输入区间内的每个元素相对顺序都不会改变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//差集，求存在于[first1, last1)且不存在于[first2, last2)内的所有元素  </span></span><br><span class="line"><span class="comment">//注意：输入区间必须是已排序  </span></span><br><span class="line"><span class="comment">//版本一，默认是operator&lt;操作的排序方式  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;  </span><br><span class="line"><span class="function">OutputIterator <span class="title">set_difference</span><span class="params">(InputIterator1 first1, InputIterator1 last1,  </span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator2 first2, InputIterator2 last2,  </span></span></span><br><span class="line"><span class="params"><span class="function">    OutputIterator result)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//若两个区间都尚未到达尾端，则执行以下操作  </span></span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)  </span><br><span class="line">        <span class="comment">/*在两个区间分别移动迭代器，当第一区间元素等于第二区</span></span><br><span class="line"><span class="comment">        间元素时，表示两区间共同存在该元素，则同时移动迭代器； </span></span><br><span class="line"><span class="comment">        当第一区间元素大于第二区间元素时，就让第二区间迭代器前进； </span></span><br><span class="line"><span class="comment">        第一区间元素小于第二区间元素时，把第一区间元素记录到目标区 </span></span><br><span class="line"><span class="comment">        继续移动迭代器...直到两区间之中有到达尾端*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (*first1 &lt; *first2) &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++result;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1)  </span><br><span class="line">            ++first2;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++first2;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="comment">//把第一区间剩余的元素(若有剩余)复制到目标区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">copy</span>(first1, last1, result);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<p>图解如下：<br><img src="/img/1610544261.jpg" alt=""></p>
<h3 id="set-symmetric-difference"><a href="#set-symmetric-difference" class="headerlink" title="set_symmetric_difference"></a>set_symmetric_difference</h3><p>求两个集合的对称差集(s1-s2)∪(s2-s1)，此集合内含出现于S1但不出现于S2内的元素，以及出现于S2但不出现于S1内的每一个元素。如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现|n-m|次。</p>
<p>返回值为一个迭代器，指向输出区间的尾端。</p>
<p>是一种稳定操作，输入区间内的每个元素相对顺序都不会改变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对称差集，求存在于[first1, last1)但不存在于[first2, </span></span><br><span class="line"><span class="comment">//last2)内的所有元素以及出现在[first2, last2)但不出现在</span></span><br><span class="line"><span class="comment">//[first1, last1)的所有元素  </span></span><br><span class="line"><span class="comment">//注意：输入区间必须是已排序  </span></span><br><span class="line"><span class="comment">//版本一，默认是operator&lt;操作的排序方式  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;  </span><br><span class="line"><span class="function">OutputIterator <span class="title">set_symmetric_difference</span><span class="params">(InputIterator1 first1,  </span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator1 last1,  </span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator2 first2,  </span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator2 last2,  </span></span></span><br><span class="line"><span class="params"><span class="function">    OutputIterator result)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//若两个区间都尚未到达尾端，则执行下面的操作  </span></span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)  </span><br><span class="line">        <span class="comment">/*在两区间内分别移动迭代器。当两区间内的元素相等，就让两区同时前进； </span></span><br><span class="line"><span class="comment">        当两区间内的元素不等，就记录较小值于目标区，并令较小值所在区间前进*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (*first1 &lt; *first2) &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++result;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1) &#123;  </span><br><span class="line">            *result = *first2;  </span><br><span class="line">            ++first2;  </span><br><span class="line">            ++result;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++first2;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));  </span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure></p>
<p>图解如下：<br><img src="/img/1610544307.jpg" alt=""></p>
<h3 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">display</span>&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span></span>&#123;  </span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="type">int</span> ia[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span> &#125;;  </span><br><span class="line">    <span class="type">int</span> ib[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span> &#125;;  </span><br><span class="line">    <span class="function">multiset&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(begin(ia), end(ia))</span></span>;  </span><br><span class="line">    <span class="function">multiset&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(begin(ib), end(ib))</span></span>;  </span><br><span class="line"> </span><br><span class="line">    for_each(s<span class="number">1.</span><span class="built_in">begin</span>(), s<span class="number">1.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line">    for_each(s<span class="number">2.</span><span class="built_in">begin</span>(), s<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line"> </span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;::iterator first1 = s<span class="number">1.</span><span class="built_in">begin</span>();  </span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;::iterator last1 = s<span class="number">1.</span><span class="built_in">end</span>();  </span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;::iterator first2 = s<span class="number">2.</span><span class="built_in">begin</span>();  </span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;::iterator last2 = s<span class="number">2.</span><span class="built_in">end</span>();  </span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;union of s1 and s2:&quot;</span>;  </span><br><span class="line">    <span class="built_in">set_union</span>(first1, last1, first2, last2, <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;intersection of s1 and s2:&quot;</span>;  </span><br><span class="line">    <span class="built_in">set_intersection</span>(first1, last1, first2, last2, <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;difference of s1 and s2:&quot;</span>;  </span><br><span class="line">    <span class="built_in">set_difference</span>(first1, last1, first2, last2, <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;symmetric differenceof s1 and s2:&quot;</span>;  </span><br><span class="line">    <span class="built_in">set_symmetric_difference</span>(first1, last1, first2, last2, <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h2><h3 id="单纯的数据处理"><a href="#单纯的数据处理" class="headerlink" title="单纯的数据处理"></a>单纯的数据处理</h3><p>测试程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">display</span> &#123; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数，一元谓词</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">even</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">2</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还是一个仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">even_by_two</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _x += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> even_by_two::_x = <span class="number">0</span>; <span class="comment">// 类内声明类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="keyword">sizeof</span>(ia) / <span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出相邻元素值相等的第一个元素</span></span><br><span class="line">    cout &lt;&lt; *<span class="built_in">adjacent_find</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 找出相邻元素值相等的第一个元素</span></span><br><span class="line">    cout &lt;&lt; *<span class="built_in">adjacent_find</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">equal_to</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出元素值为6的元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">count</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 找出元素值小于7的元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">count_if</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">7</span>)) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出元素值为4的元素所在位置</span></span><br><span class="line">    cout &lt;&lt; *<span class="built_in">find</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 找出元素值大于2的第一个元素所在位置</span></span><br><span class="line">    cout &lt;&lt; *<span class="built_in">find_if</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">2</span>)) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出子序列所出现的最后一个位置，加3</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv2</span><span class="params">(ia + <span class="number">6</span>, ia + <span class="number">8</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; *(<span class="built_in">find_end</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv<span class="number">2.</span><span class="built_in">begin</span>(), iv<span class="number">2.</span><span class="built_in">end</span>()) + <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出子序列所出现的第一个位置，加3</span></span><br><span class="line">    cout &lt;&lt; *(<span class="built_in">find_first_of</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv<span class="number">2.</span><span class="built_in">begin</span>(), iv<span class="number">2.</span><span class="built_in">end</span>()) + <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代iv 每个元素进行display</span></span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下写法错误，generate的第三个参数是仿函数，本身不得有任何参数</span></span><br><span class="line">    <span class="comment">// generate(iv.begin(), iv.end(), bind2nd(plus&lt;int&gt;(), 3)); // error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代iv2，对每个元素进行even_by_two</span></span><br><span class="line">    <span class="built_in">generate</span>(iv<span class="number">2.</span><span class="built_in">begin</span>(), iv<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">even_by_two</span>());</span><br><span class="line">    for_each(iv<span class="number">2.</span><span class="built_in">begin</span>(), iv<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 迭代指定区间，对每个元素进行even_by_two</span></span><br><span class="line">    <span class="built_in">generate_n</span>(iv<span class="number">2.</span><span class="built_in">begin</span>(), <span class="number">3</span>, <span class="built_in">even_by_two</span>());</span><br><span class="line">    for_each(iv<span class="number">2.</span><span class="built_in">begin</span>(), iv<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除（但不删除）元素6，尾端可能有残余数据（可以使用erase）</span></span><br><span class="line">    <span class="built_in">remove</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">6</span>);</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除（但不删除）元素6，结果置于另一区间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv3</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">    <span class="built_in">remove_copy</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv<span class="number">3.</span><span class="built_in">begin</span>(), <span class="number">6</span>);</span><br><span class="line">    for_each(iv<span class="number">3.</span><span class="built_in">begin</span>(), iv<span class="number">3.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除（但不删除）元素6，尾端可能有残余数据</span></span><br><span class="line">    <span class="built_in">remove_if</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">6</span>));</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除（但不删除）小于7的元素，结果置于另一区间</span></span><br><span class="line">    <span class="built_in">remove_copy_if</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv<span class="number">3.</span><span class="built_in">begin</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">7</span>));</span><br><span class="line">    for_each(iv<span class="number">3.</span><span class="built_in">begin</span>(), iv<span class="number">3.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有的元素值6，改为元素值3</span></span><br><span class="line">    <span class="built_in">replace</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有的元素值3，改为元素值5，结果置于另一区间</span></span><br><span class="line">    <span class="built_in">replace_copy</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv<span class="number">3.</span><span class="built_in">begin</span>(), <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    for_each(iv<span class="number">3.</span><span class="built_in">begin</span>(), iv<span class="number">3.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有小于5的元素值，改为元素值2</span></span><br><span class="line">    <span class="built_in">replace_if</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">5</span>), <span class="number">2</span>);</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有等于8的元素值，改为元素值9，结果置于另一区间</span></span><br><span class="line">    <span class="built_in">replace_copy_if</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv<span class="number">3.</span><span class="built_in">begin</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">equal_to</span>&lt;<span class="type">int</span>&gt;(), <span class="number">8</span>), <span class="number">9</span>);</span><br><span class="line">    for_each(iv<span class="number">3.</span><span class="built_in">begin</span>(), iv<span class="number">3.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆向重排每一个元素</span></span><br><span class="line">    <span class="built_in">reverse</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>());</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    <span class="comment">// 逆向重排每一个元素，结果置于另一区间</span></span><br><span class="line">    <span class="built_in">reverse_copy</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv<span class="number">3.</span><span class="built_in">begin</span>());</span><br><span class="line">    for_each(iv<span class="number">3.</span><span class="built_in">begin</span>(), iv<span class="number">3.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转（互换元素）[first, middle]和[middle, last]</span></span><br><span class="line">    <span class="built_in">rotate</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">begin</span>() + <span class="number">4</span>, iv.<span class="built_in">end</span>());</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    <span class="comment">// 旋转（互换元素）[first, middle]和[middle, last]</span></span><br><span class="line">    <span class="comment">// 结果置于另一区间</span></span><br><span class="line">    <span class="built_in">rotate_copy</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">begin</span>() + <span class="number">5</span>, iv.<span class="built_in">end</span>(), iv<span class="number">3.</span><span class="built_in">begin</span>());</span><br><span class="line">    for_each(iv<span class="number">3.</span><span class="built_in">begin</span>(), iv<span class="number">3.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找某个子序列的第一次出现地点</span></span><br><span class="line">    <span class="type">int</span> ia2[<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv4</span><span class="params">(ia2, ia2 + <span class="number">2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">search</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv<span class="number">4.</span><span class="built_in">begin</span>(), iv<span class="number">4.</span><span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 查找连续出现2个8的子序列起点</span></span><br><span class="line">    cout &lt;&lt; *<span class="built_in">search_n</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">8</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 查找连续出现3个小于8的子序列起点</span></span><br><span class="line">    cout &lt;&lt; *<span class="built_in">search_n</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">3</span>, <span class="number">8</span>, <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将区间元素互换，第二区间个数不应小于第一区间个数</span></span><br><span class="line">    <span class="built_in">swap_ranges</span>(iv<span class="number">4.</span><span class="built_in">begin</span>(), iv<span class="number">4.</span><span class="built_in">end</span>(), iv.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    for_each(iv<span class="number">4.</span><span class="built_in">begin</span>(), iv<span class="number">4.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变区间的值，全部减2，原地搬运</span></span><br><span class="line">    <span class="built_in">transform</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv.<span class="built_in">begin</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;(), <span class="number">2</span>));</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变区间的值，令 第二区间的元素值加到第一区间上</span></span><br><span class="line">    <span class="built_in">transform</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), iv.<span class="built_in">begin</span>(), iv.<span class="built_in">begin</span>(), <span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// *******************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv5</span><span class="params">(ia, ia + <span class="keyword">sizeof</span>(ia) / <span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv6</span><span class="params">(ia + <span class="number">4</span>, ia + <span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv7</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    for_each(iv<span class="number">5.</span><span class="built_in">begin</span>(), iv<span class="number">5.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    for_each(iv<span class="number">6.</span><span class="built_in">begin</span>(), iv<span class="number">6.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(iv<span class="number">5.</span><span class="built_in">begin</span>(), iv<span class="number">5.</span><span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">min_element</span>(iv<span class="number">5.</span><span class="built_in">begin</span>(), iv<span class="number">5.</span><span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否iv6内的所有元素都出现于iv5中</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">includes</span>(iv<span class="number">5.</span><span class="built_in">begin</span>(), iv<span class="number">5.</span><span class="built_in">end</span>(), iv<span class="number">6.</span><span class="built_in">begin</span>(), iv<span class="number">6.</span><span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将两个序列合并，必须有序</span></span><br><span class="line">    <span class="built_in">merge</span>(iv<span class="number">5.</span><span class="built_in">begin</span>(), iv<span class="number">5.</span><span class="built_in">end</span>(), iv<span class="number">6.</span><span class="built_in">begin</span>(), iv<span class="number">6.</span><span class="built_in">end</span>(), iv<span class="number">7.</span><span class="built_in">begin</span>());</span><br><span class="line">    for_each(iv<span class="number">7.</span><span class="built_in">begin</span>(), iv<span class="number">7.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符合条件的元素放在容器前端，其他放后端</span></span><br><span class="line">    <span class="built_in">partition</span>(iv<span class="number">7.</span><span class="built_in">begin</span>(), iv<span class="number">7.</span><span class="built_in">end</span>(), <span class="built_in">even</span>());</span><br><span class="line">    for_each(iv<span class="number">7.</span><span class="built_in">begin</span>(), iv<span class="number">7.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除连续重复元素</span></span><br><span class="line">    <span class="built_in">unique</span>(iv<span class="number">5.</span><span class="built_in">begin</span>(), iv<span class="number">5.</span><span class="built_in">end</span>());</span><br><span class="line">    for_each(iv<span class="number">5.</span><span class="built_in">begin</span>(), iv<span class="number">5.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    <span class="comment">// 去除连续重复元素，结果置于另一区间</span></span><br><span class="line">    <span class="built_in">unique_copy</span>(iv<span class="number">5.</span><span class="built_in">begin</span>(), iv<span class="number">5.</span><span class="built_in">end</span>(), iv<span class="number">7.</span><span class="built_in">begin</span>());</span><br><span class="line">    for_each(iv<span class="number">7.</span><span class="built_in">begin</span>(), iv<span class="number">7.</span><span class="built_in">end</span>(), <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h3><p>找出第一组满足条件的相邻元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> last;</span><br><span class="line">  ForwardIterator next = first;</span><br><span class="line">  <span class="keyword">while</span>(++next != last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first == *next) <span class="keyword">return</span> first;</span><br><span class="line">    first = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>查找某个元素出现的数目。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Size</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value,</span></span></span><br><span class="line"><span class="params"><span class="function">           Size&amp; n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span> (*first == value)</span><br><span class="line">      ++n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h3><p>返回仿函数计算结果为true的元素的个数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>, <span class="keyword">class</span> <span class="title class_">Size</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count_if</span><span class="params">(InputIterator first, InputIterator last, Predicate pred,</span></span></span><br><span class="line"><span class="params"><span class="function">              Size&amp; n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pred</span>(*first))</span><br><span class="line">      ++n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找第一个匹配的元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last &amp;&amp; *first != value) ++first;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h3><p>查找第一个使仿函数为true的元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find_if</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                      Predicate pred)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last &amp;&amp; !<span class="built_in">pred</span>(*first)) ++first;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="find-end"><a href="#find-end" class="headerlink" title="find_end"></a>find_end</h3><p>在序列一的区间内查找序列二的最后一次出现点。要求完全匹配的序列，即连续出现的序列2。可以利用正向查找，每次向后查找，记录上次找的的位置，最后没有找到了，那么上次找到的位置就是最后一次。也可以利用逆向迭代器从后向前找到第一次出现的位置。上层函数为dispatch function。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator1</span></span><br><span class="line"><span class="function"><span class="title">find_end</span><span class="params">(ForwardIterator1 first1, ForwardIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">         ForwardIterator2 first2, ForwardIterator2 last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator1&gt;::iterator_category</span><br><span class="line">          category1;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator2&gt;::iterator_category</span><br><span class="line">          category2;</span><br><span class="line">  <span class="keyword">return</span> __find_end(first1, last1, first2, last2, <span class="built_in">category1</span>(), <span class="built_in">category2</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">  <span class="keyword">return</span> __find_end(first1, last1, first2, last2,</span><br><span class="line">                    forward_iterator_tag(), forward_iterator_tag());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator1</span></span><br><span class="line"><span class="function"><span class="title">find_end</span><span class="params">(ForwardIterator1 first1, ForwardIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">         ForwardIterator2 first2, ForwardIterator2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">         BinaryPredicate comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator1&gt;::iterator_category</span><br><span class="line">          category1;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator2&gt;::iterator_category</span><br><span class="line">          category2;</span><br><span class="line">  <span class="keyword">return</span> __find_end(first1, last1, first2, last2, <span class="built_in">category1</span>(), <span class="built_in">category2</span>(),</span><br><span class="line">                    comp);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">  <span class="keyword">return</span> __find_end(first1, last1, first2, last2,</span><br><span class="line">                    forward_iterator_tag(), forward_iterator_tag(),</span><br><span class="line">                    comp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种常见的技巧，令函数传递过程中产生迭代器类型的临时对象，再利用编译器的参数推导机制自动调用某个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line">ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,</span><br><span class="line">                            ForwardIterator2 first2, ForwardIterator2 last2,</span><br><span class="line">                            forward_iterator_tag, forward_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (first2 == last2)</span><br><span class="line">    <span class="keyword">return</span> last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    ForwardIterator1 result = last1;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      ForwardIterator1 new_result = <span class="built_in">search</span>(first1, last1, first2, last2);</span><br><span class="line">      <span class="keyword">if</span> (new_result == last1)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        result = new_result;</span><br><span class="line">        first1 = new_result;</span><br><span class="line">        ++first1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line">ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,</span><br><span class="line">                            ForwardIterator2 first2, ForwardIterator2 last2,</span><br><span class="line">                            forward_iterator_tag, forward_iterator_tag,</span><br><span class="line">                            BinaryPredicate comp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (first2 == last2)</span><br><span class="line">    <span class="keyword">return</span> last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    ForwardIterator1 result = last1;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      ForwardIterator1 new_result = <span class="built_in">search</span>(first1, last1, first2, last2, comp);</span><br><span class="line">      <span class="keyword">if</span> (new_result == last1)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        result = new_result;</span><br><span class="line">        first1 = new_result;</span><br><span class="line">        ++first1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find_end for bidirectional iterators.  Requires partial specialization.</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator1</span>, <span class="keyword">class</span> <span class="title class_">BidirectionalIterator2</span>&gt;</span><br><span class="line">BidirectionalIterator1</span><br><span class="line">__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,</span><br><span class="line">           BidirectionalIterator2 first2, BidirectionalIterator2 last2,</span><br><span class="line">           bidirectional_iterator_tag, bidirectional_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;BidirectionalIterator1&gt; reviter1;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;BidirectionalIterator2&gt; reviter2;</span><br><span class="line"></span><br><span class="line">  <span class="function">reviter1 <span class="title">rlast1</span><span class="params">(first1)</span></span>;</span><br><span class="line">  <span class="function">reviter2 <span class="title">rlast2</span><span class="params">(first2)</span></span>;</span><br><span class="line">  reviter1 rresult = <span class="built_in">search</span>(<span class="built_in">reviter1</span>(last1), rlast1, <span class="built_in">reviter2</span>(last2), rlast2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rresult == rlast1)</span><br><span class="line">    <span class="keyword">return</span> last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    BidirectionalIterator1 result = rresult.<span class="built_in">base</span>();</span><br><span class="line">    <span class="built_in">advance</span>(result, -<span class="built_in">distance</span>(first2, last2));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator1</span>, <span class="keyword">class</span> <span class="title class_">BidirectionalIterator2</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line">BidirectionalIterator1</span><br><span class="line">__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,</span><br><span class="line">           BidirectionalIterator2 first2, BidirectionalIterator2 last2,</span><br><span class="line">           bidirectional_iterator_tag, bidirectional_iterator_tag,</span><br><span class="line">           BinaryPredicate comp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;BidirectionalIterator1&gt; reviter1;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;BidirectionalIterator2&gt; reviter2;</span><br><span class="line"></span><br><span class="line">  <span class="function">reviter1 <span class="title">rlast1</span><span class="params">(first1)</span></span>;</span><br><span class="line">  <span class="function">reviter2 <span class="title">rlast2</span><span class="params">(first2)</span></span>;</span><br><span class="line">  reviter1 rresult = <span class="built_in">search</span>(<span class="built_in">reviter1</span>(last1), rlast1, <span class="built_in">reviter2</span>(last2), rlast2,</span><br><span class="line">                            comp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rresult == rlast1)</span><br><span class="line">    <span class="keyword">return</span> last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    BidirectionalIterator1 result = rresult.<span class="built_in">base</span>();</span><br><span class="line">    <span class="built_in">advance</span>(result, -<span class="built_in">distance</span>(first2, last2));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="find-first-of"><a href="#find-first-of" class="headerlink" title="find_first of"></a>find_first of</h3><p>找到序列2中的任何一个元素在序列一中出现的位置。不需要完全配匹配序列2，任何一个元素出现都可以。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find_first_of</span><span class="params">(InputIterator first1, InputIterator last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ForwardIterator first2, ForwardIterator last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first1 != last1; ++first1)</span><br><span class="line">    <span class="keyword">for</span> (ForwardIterator iter = first2; iter != last2; ++iter)</span><br><span class="line">      <span class="keyword">if</span> (*first1 == *iter)</span><br><span class="line">        <span class="keyword">return</span> first1;</span><br><span class="line">  <span class="keyword">return</span> last1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find_first_of</span><span class="params">(InputIterator first1, InputIterator last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ForwardIterator first2, ForwardIterator last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                            BinaryPredicate comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first1 != last1; ++first1)</span><br><span class="line">    <span class="keyword">for</span> (ForwardIterator iter = first2; iter != last2; ++iter)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">comp</span>(*first1, *iter))</span><br><span class="line">        <span class="keyword">return</span> first1;</span><br><span class="line">  <span class="keyword">return</span> last1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><p>将仿函数施加于区间内的每个元素之上。不能够改变元素内容，返回值被忽略。可以用于打印元素的值等。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Function</span>&gt;</span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator first, InputIterator last, Function f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="built_in">f</span>(*first);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>将仿函数的运算结果赋值给区间内的每一个元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Generator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate</span><span class="params">(ForwardIterator first, ForwardIterator last, Generator gen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    *first = <span class="built_in">gen</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="generate-n"><a href="#generate-n" class="headerlink" title="generate_n"></a>generate_n</h3><p>将仿函数的运算结果赋值给迭代器first开始的n个元素上<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">Generator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">generate_n</span><span class="params">(OutputIterator first, Size n, Generator gen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++first)</span><br><span class="line">    *first = <span class="built_in">gen</span>();</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p>判断序列二S2是否“涵盖于”序列一S1。S1和S2都必须是有序集合：其中的元素都可重复（不必唯一）。所谓涵盖，意思是“S2的每一个元素都出现于S1”。由于判断两个元素是否相等，必须以less或greater运算为依据（当S1元素不小于S2元素且S2元素不小于S1元素，两者即相等；或说当S1元素不大于S2元素且S2元素不大于S1元素，两者即相等），因此配合着两个序列S1和S2的排序方式（递增或递减），includes算法可供用户选择采用less或greater进行两元素的大小比较（comparison）。 </p>
<p>换句话说，如果S1和S2是递增排序（以operator&lt;执行比较操作），includes 算法应该这么使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">includes</span>(S<span class="number">1.</span><span class="built_in">begin</span>(), S<span class="number">1.</span><span class="built_in">end</span>(), S<span class="number">2.</span><span class="built_in">begin</span>(), S<span class="number">2.</span><span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>这和下一行完全相同：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">includes</span>(S<span class="number">1.</span><span class="built_in">begin</span>(), S<span class="number">1.</span><span class="built_in">end</span>(), S<span class="number">2.</span><span class="built_in">begin</span>(), S<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure><br>然而如果S1和S2是递减排序（以operator&gt;执行比较操作），includes算法应该这么使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">includes</span>(S<span class="number">1.</span><span class="built_in">begin</span>(), S<span class="number">1.</span><span class="built_in">end</span>(), S<span class="number">2.</span><span class="built_in">begin</span>(), S<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure><br>注意，S1或S2内的元素都可以重复，这种情况下所谓, S1内含一个S2子集合”的定义是：假设某元素在S2出现n次，在S1出现m次。那么如果m &lt; n, 此算法会返回false。<br><img src="/img/1610593476.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">includes</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">              InputIterator2 first2, InputIterator2 last2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*first1 &lt; *first2)</span><br><span class="line">      ++first1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ++first1, ++first2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> first2 == last2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">includes</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">              InputIterator2 first2, InputIterator2 last2, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*first2, *first1))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">comp</span>(*first1, *first2))</span><br><span class="line">      ++first1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ++first1, ++first2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> first2 == last2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="max-element"><a href="#max-element" class="headerlink" title="max_element"></a>max_element</h3><p>返回区间内最大的元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">max_element</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">  ForwardIterator result = first;</span><br><span class="line">  <span class="keyword">while</span> (++first != last)</span><br><span class="line">    <span class="keyword">if</span> (*result &lt; *first) result = first;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">max_element</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                            Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">  ForwardIterator result = first;</span><br><span class="line">  <span class="keyword">while</span> (++first != last)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*result, *first)) result = first;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>将两个有序序列融合成一个序列，三个序列都是有序的。返回指向结果序列的尾后元素。<br><img src="/img/1610593588.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">merge</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                     InputIterator2 first2, InputIterator2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                     OutputIterator result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">      *result = *first2;</span><br><span class="line">      ++first2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *result = *first1;</span><br><span class="line">      ++first1;</span><br><span class="line">    &#125;</span><br><span class="line">    ++result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">merge</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                     InputIterator2 first2, InputIterator2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                     OutputIterator result, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*first2, *first1)) &#123;</span><br><span class="line">      *result = *first2;</span><br><span class="line">      ++first2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *result = *first1;</span><br><span class="line">      ++first1;</span><br><span class="line">    &#125;</span><br><span class="line">    ++result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="min-element"><a href="#min-element" class="headerlink" title="min_element"></a>min_element</h3><p>返回序列中数值最小的元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">min_element</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">  ForwardIterator result = first;</span><br><span class="line">  <span class="keyword">while</span> (++first != last)</span><br><span class="line">    <span class="keyword">if</span> (*first &lt; *result) result = first;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">min_element</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                            Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">  ForwardIterator result = first;</span><br><span class="line">  <span class="keyword">while</span> (++first != last)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*first, *result)) result = first;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><p>对区间进行重新排列，所有被仿函数判定为true的元素被放倒区间的前端，被判定为false的元素被放到区间的后端。这个算法并不保留元素的原始相对位置。需要保留原始相对位置，应使用stable_partition。算法实现类似于快排，先从前向后找到一个false,再从后向前找到一个true，然后交换。<br><img src="/img/1610593775.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">BidirectionalIterator <span class="title">partition</span><span class="params">(BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                                BidirectionalIterator last, Predicate pred)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (first == last)</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">pred</span>(*first))</span><br><span class="line">        ++first;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    --last;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (first == last)</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">pred</span>(*last))</span><br><span class="line">        --last;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">iter_swap</span>(first, last);</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>移除区间内与value相等的元素。并不是真正移除，容器大小并未改变。只是将不相等的元素重新赋值到原区间上，所以会在原来有多余的元素。返回在重新整理后的元素的下一位置<br><img src="/img/1610593860.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">remove</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  first = <span class="built_in">find</span>(first, last, value);</span><br><span class="line">  ForwardIterator next = first;</span><br><span class="line">  <span class="keyword">return</span> first == last ? first : <span class="built_in">remove_copy</span>(++next, last, first, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove-copy"><a href="#remove-copy" class="headerlink" title="remove_copy"></a>remove_copy</h3><p>移除区间内所有与value相等的元素；它并不真正从容器中删除那些元素（换句话说，原容器没有任何改变），而是将结果复制到一个以result标示起始位置的容器身上，新容器可以和原容器重叠，但如果对新容器实际给值时、 超越了旧容器的大小，会产生无法预期的结果。返回值OuputIterator指出被复制的最后元素的下一位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">remove_copy</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                           OutputIterator result, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span> (*first != value) &#123;</span><br><span class="line">      *result = *first;</span><br><span class="line">      ++result;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="remove-if"><a href="#remove-if" class="headerlink" title="remove_if"></a>remove_if</h3><p>移除[first, last)区间内所有被仿函数pred核定为true的元素。它并不真正从容器中删除那些元素（换句话说，容器大小并未改变），每一个不符合pred条件的元素都会被轮番赋值给first之后的空间。返回值ForwardIterator标示出重新整理后的最后元素的下一位置，此算法会留有一些残余数据，如果要删除那些残余数据，可将返回的迭代器交给区间所在之容器的erase() member function。<br><img src="/img/1610594128.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">remove_if</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Predicate pred)</span> </span>&#123;</span><br><span class="line">  first = <span class="built_in">find_if</span>(first, last, pred);</span><br><span class="line">  ForwardIterator next = first;</span><br><span class="line">  <span class="keyword">return</span> first == last ? first : <span class="built_in">remove_copy_if</span>(++next, last, first, pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove-copy-if"><a href="#remove-copy-if" class="headerlink" title="remove_copy_if"></a>remove_copy_if</h3><p>移除区间内所有与value相等的元素；它并不真正从容器中删除那些元素（换句话说，原容器没有任何改变），而是将结果复制到一个以result标示起始位置的容器身上，新容器可以和原容器重叠，但如果对新容器实际给值时、 超越了旧容器的大小，会产生无法预期的结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">remove_copy_if</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                              OutputIterator result, Predicate pred)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">pred</span>(*first)) &#123;</span><br><span class="line">      *result = *first;</span><br><span class="line">      ++result;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>将区间内的所有元素用新元素取代<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; old_value,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> T&amp; new_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span> (*first == old_value) *first = new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="replace-copy"><a href="#replace-copy" class="headerlink" title="replace_copy"></a>replace_copy</h3><p>与replace类似，只不过复制到其他容器上。新容器可以与原容器重叠<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">replace_copy</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                            OutputIterator result, <span class="type">const</span> T&amp; old_value,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> T&amp; new_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first, ++result)</span><br><span class="line">    *result = *first == old_value ? new_value : *first;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h3><p>移除区间内被仿函数判定为true的元素。原理与replace类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace_if</span><span class="params">(ForwardIterator first, ForwardIterator last, Predicate pred,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> T&amp; new_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pred</span>(*first)) *first = new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="replace-copy-if"><a href="#replace-copy-if" class="headerlink" title="replace_copy_if"></a>replace_copy_if</h3><p>与replace_if类似，但是新序列复制到result所指的区间内。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">replace_copy_if</span><span class="params">(Iterator first, Iterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                               OutputIterator result, Predicate pred,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> T&amp; new_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first, ++result)</span><br><span class="line">    *result = <span class="built_in">pred</span>(*first) ? new_value : *first;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>将序列的元素在原容器中颠倒重排。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="type">void</span> __reverse(BidirectionalIterator first, BidirectionalIterator last,</span><br><span class="line">               bidirectional_iterator_tag) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> (first == last || first == --last)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">iter_swap</span>(first++, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="type">void</span> __reverse(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">               random_access_iterator_tag) &#123;</span><br><span class="line">  <span class="keyword">while</span> (first &lt; last) <span class="built_in">iter_swap</span>(first++, --last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">reverse</span><span class="params">(BidirectionalIterator first, BidirectionalIterator last)</span> </span>&#123;</span><br><span class="line">  __reverse(first, last, <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="reverse-copy"><a href="#reverse-copy" class="headerlink" title="reverse_copy"></a>reverse_copy</h3><p>将序列颠倒重排，将结果置于另一序列<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">reverse_copy</span><span class="params">(BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                            BidirectionalIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                            OutputIterator result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">    --last;</span><br><span class="line">    *result = *last;</span><br><span class="line">    ++result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h3><p>以middle为中心将序列旋转，middle所指的元素将会变成第一个元素。<code>rotate()</code>可以交换两个长度不同的区间，<code>swap_range()</code>只能交换长度相同的。<br><img src="/img/1610595244.jpg" alt=""></p>
<p><img src="/img/1610595463.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(ForwardIterator first, ForwardIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                   ForwardIterator last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == middle || middle == last) <span class="keyword">return</span>;</span><br><span class="line">  __rotate(first, middle, last, <span class="built_in">distance_type</span>(first),</span><br><span class="line">           <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __rotate(ForwardIterator first, ForwardIterator middle,</span><br><span class="line">              ForwardIterator last, Distance*, forward_iterator_tag) &#123;</span><br><span class="line">  <span class="keyword">for</span> (ForwardIterator i = middle; ;) &#123;</span><br><span class="line">    <span class="built_in">iter_swap</span>(first, i);</span><br><span class="line">    ++first;</span><br><span class="line">    ++i;</span><br><span class="line">    <span class="keyword">if</span> (first == middle) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == last) <span class="keyword">return</span>;</span><br><span class="line">      middle = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == last)</span><br><span class="line">      i = middle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __rotate(BidirectionalIterator first, BidirectionalIterator middle,</span><br><span class="line">              BidirectionalIterator last, Distance*,</span><br><span class="line">              bidirectional_iterator_tag) &#123;</span><br><span class="line">  <span class="built_in">reverse</span>(first, middle);</span><br><span class="line">  <span class="built_in">reverse</span>(middle, last);</span><br><span class="line">  <span class="built_in">reverse</span>(first, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __rotate(RandomAccessIterator first, RandomAccessIterator middle,</span><br><span class="line">              RandomAccessIterator last, Distance*,</span><br><span class="line">              random_access_iterator_tag) &#123;</span><br><span class="line">  Distance n = __gcd(last - first, middle - first);</span><br><span class="line">  <span class="keyword">while</span> (n--)</span><br><span class="line">    __rotate_cycle(first, last, first + n, middle - first,</span><br><span class="line">                   <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">EuclideanRingElement</span>&gt;</span><br><span class="line">EuclideanRingElement __gcd(EuclideanRingElement m, EuclideanRingElement n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    EuclideanRingElement t = m % n;</span><br><span class="line">    m = n;</span><br><span class="line">    n = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __rotate_cycle(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">                    RandomAccessIterator initial, Distance shift, T*) &#123;</span><br><span class="line">  T value = *initial;</span><br><span class="line">  RandomAccessIterator ptr1 = initial;</span><br><span class="line">  RandomAccessIterator ptr2 = ptr1 + shift;</span><br><span class="line">  <span class="keyword">while</span> (ptr2 != initial) &#123;</span><br><span class="line">    *ptr1 = *ptr2;</span><br><span class="line">    ptr1 = ptr2;</span><br><span class="line">    <span class="keyword">if</span> (last - ptr2 &gt; shift)</span><br><span class="line">      ptr2 += shift;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ptr2 = first + (shift - (last - ptr2));</span><br><span class="line">  &#125;</span><br><span class="line">  *ptr1 = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-copy"><a href="#rotate-copy" class="headerlink" title="rotate_copy"></a>rotate_copy</h3><p>和rotate类似，将结果置于另一序列<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">rotate_copy</span><span class="params">(ForwardIterator first, ForwardIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                           ForwardIterator last, OutputIterator result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">copy</span>(first, middle, <span class="built_in">copy</span>(middle, last, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>在序列1中查找序列2的首次出现点，序列1中要求序列2完全匹配，不能间隔。不存在就返回last1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator1 <span class="title">search</span><span class="params">(ForwardIterator1 first1, ForwardIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                               ForwardIterator2 first2, ForwardIterator2 last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __search(first1, last1, first2, last2, <span class="built_in">distance_type</span>(first1),</span><br><span class="line">                  <span class="built_in">distance_type</span>(first2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>, <span class="keyword">class</span> <span class="title class_">Distance1</span>, <span class="keyword">class</span> <span class="title class_">Distance2</span>&gt;</span><br><span class="line">ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1,</span><br><span class="line">                          ForwardIterator2 first2, ForwardIterator2 last2,</span><br><span class="line">                          BinaryPredicate binary_pred, Distance1*, Distance2*) &#123;</span><br><span class="line">  Distance1 d1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(first1, last1, d1);</span><br><span class="line">  Distance2 d2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(first2, last2, d2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (d1 &lt; d2) <span class="keyword">return</span> last1;</span><br><span class="line"></span><br><span class="line">  ForwardIterator1 current1 = first1;</span><br><span class="line">  ForwardIterator2 current2 = first2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current2 != last2)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">binary_pred</span>(*current1, *current2)) &#123;</span><br><span class="line">      ++current1;</span><br><span class="line">      ++current2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (d1 == d2)</span><br><span class="line">        <span class="keyword">return</span> last1;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        current1 = ++first1;</span><br><span class="line">        current2 = first2;</span><br><span class="line">        --d1;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> first1;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h3 id="search-n"><a href="#search-n" class="headerlink" title="search_n"></a>search_n</h3><p>和search类似，查找连续n个符合条件的元素形成的子序列。<br><img src="/img/1610595681.jpg" alt=""><br><img src="/img/1610595745.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Integer</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">search_n</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Integer count, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    first = <span class="built_in">find</span>(first, last, value);</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">      Integer n = count - <span class="number">1</span>;</span><br><span class="line">      ForwardIterator i = first;</span><br><span class="line">      ++i;</span><br><span class="line">      <span class="keyword">while</span> (i != last &amp;&amp; n != <span class="number">0</span> &amp;&amp; *i == value) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        --n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        first = <span class="built_in">find</span>(i, last, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Integer</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">search_n</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Integer count, <span class="type">const</span> T&amp; value,</span></span></span><br><span class="line"><span class="params"><span class="function">                         BinaryPredicate binary_pred)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">binary_pred</span>(*first, value)) <span class="keyword">break</span>;</span><br><span class="line">      ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">      Integer n = count - <span class="number">1</span>;</span><br><span class="line">      ForwardIterator i = first;</span><br><span class="line">      ++i;</span><br><span class="line">      <span class="keyword">while</span> (i != last &amp;&amp; n != <span class="number">0</span> &amp;&amp; <span class="built_in">binary_pred</span>(*i, value)) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        --n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i != last) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">binary_pred</span>(*i, value)) <span class="keyword">break</span>;</span><br><span class="line">          ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        first = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="swap-range"><a href="#swap-range" class="headerlink" title="swap_range"></a>swap_range</h3><p>将两个长度相同的序列交换。两个序列可以在同一容器，也可在不同容器。如果第一个序列长度小于第二个或者两个序列有重叠，结果不可预期。<br>返回第二个序列最后一个交换元素的下一位置<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator2 <span class="title">swap_ranges</span><span class="params">(ForwardIterator1 first1, ForwardIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                             ForwardIterator2 first2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2)</span><br><span class="line">    <span class="built_in">iter_swap</span>(first1, first2);</span><br><span class="line">  <span class="keyword">return</span> first2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>将仿函数作用于每一个元素身上，并以其结果产生出一个新序列<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">UnaryOperation</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                         OutputIterator result, UnaryOperation op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first, ++result)</span><br><span class="line">    *result = <span class="built_in">op</span>(*first);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                         InputIterator2 first2, OutputIterator result,</span></span></span><br><span class="line"><span class="params"><span class="function">                         BinaryOperation binary_op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2, ++result)</span><br><span class="line">    *result = <span class="built_in">binary_op</span>(*first1, *first2);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><p>移除相邻的重复元素。类似于remove，并不是真正移除，而是将不重复的元素重新赋值于区间上。因为区间大小并未改变，所以尾部会有残余数据。算法是稳定的，所有你保留下来的元素其相对位置不变。<br><img src="/img/1610595857.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">unique</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">  first = <span class="built_in">adjacent_find</span>(first, last);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unique_copy</span>(first, last, first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unique-copy"><a href="#unique-copy" class="headerlink" title="unique_copy"></a>unique_copy</h3><p>与unique类似，将结果复制到另一区间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">unique_copy</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  OutputIterator result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">return</span> __unique_copy(first, last, result, <span class="built_in">iterator_category</span>(result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line">ForwardIterator __unique_copy(InputIterator first, InputIterator last,</span><br><span class="line">                              ForwardIterator result, forward_iterator_tag) &#123;</span><br><span class="line">  *result = *first;</span><br><span class="line">  <span class="keyword">while</span> (++first != last)</span><br><span class="line">    <span class="keyword">if</span> (*result != *first) *++result = *first;</span><br><span class="line">  <span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> OutputIterator __unique_copy(InputIterator first, InputIterator last,</span><br><span class="line">                                    OutputIterator result,</span><br><span class="line">                                    output_iterator_tag) &#123;</span><br><span class="line">  <span class="keyword">return</span> __unique_copy(first, last, result, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">OutputIterator __unique_copy(InputIterator first, InputIterator last,</span><br><span class="line">                             OutputIterator result, T*) &#123;</span><br><span class="line">  T value = *first;</span><br><span class="line">  *result = value;</span><br><span class="line">  <span class="keyword">while</span> (++first != last)</span><br><span class="line">    <span class="keyword">if</span> (value != *first) &#123;</span><br><span class="line">      value = *first;</span><br><span class="line">      *++result = value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><p>lower_bound 二分查找的一个版本，在已排序区间中查找value。如果区间中有该元素，则返回迭代器，指向第一个该元素。如果没有改元素，则返回一个不小于value的元素。返回值为：在不破坏排序的情况下，可插入value的位置。<br><img src="/img/1610604585.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">lower_bound</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __lower_bound(first, last, value, <span class="built_in">distance_type</span>(first),</span><br><span class="line">                       <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">lower_bound</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> T&amp; value, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __lower_bound(first, last, value, comp, <span class="built_in">distance_type</span>(first),</span><br><span class="line">                       <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,</span><br><span class="line">                              <span class="type">const</span> T&amp; value, Compare comp, Distance*,</span><br><span class="line">                              forward_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    Distance len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(first, last, len);</span><br><span class="line">    Distance half;</span><br><span class="line">    ForwardIterator middle;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        middle = first; <span class="comment">//对于前向迭代器才需要用这种方式寻找位置，对于随机访问迭代器可以直接+ </span></span><br><span class="line">        first = <span class="built_in">advance</span>(middle, half);</span><br><span class="line">        <span class="keyword">if</span>(*middle &lt; value)</span><br><span class="line">        &#123;</span><br><span class="line">            first = middle + <span class="number">1</span>;</span><br><span class="line">            ++first;</span><br><span class="line">            len = len - half - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//即使是相等，还需要迭代，因为要找出相等的元素中最前一个的位置 </span></span><br><span class="line">        &#123;</span><br><span class="line">            len = half;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">RandomAccessIterator __lower_bound(RandomAccessIterator first,</span><br><span class="line">                                   RandomAccessIterator last,</span><br><span class="line">                                   <span class="type">const</span> T&amp; value, Compare comp, Distance*,</span><br><span class="line">                                   random_access_iterator_tag) &#123;</span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance half;</span><br><span class="line">  RandomAccessIterator middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first + half;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*middle, value)) &#123;</span><br><span class="line">      first = middle + <span class="number">1</span>;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      len = half;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h3><p>upper_bound 和上述函数类似，寻找的是符合条件的位置的上限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __upper_bound(first, last, value, <span class="built_in">distance_type</span>(first),</span><br><span class="line">                       <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> T&amp; value, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __upper_bound(first, last, value, comp, <span class="built_in">distance_type</span>(first),</span><br><span class="line">                       <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,</span><br><span class="line">                              <span class="type">const</span> T&amp; value, Distance*,</span><br><span class="line">                              forward_iterator_tag) &#123;</span><br><span class="line">  Distance len = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(first, last, len);</span><br><span class="line">  Distance half;</span><br><span class="line">  ForwardIterator middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first;</span><br><span class="line">    <span class="built_in">advance</span>(middle, half);</span><br><span class="line">    <span class="keyword">if</span> (value &lt; *middle)</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      first = middle;</span><br><span class="line">      ++first;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">RandomAccessIterator __upper_bound(RandomAccessIterator first,</span><br><span class="line">                                   RandomAccessIterator last, <span class="type">const</span> T&amp; value,</span><br><span class="line">                                   Distance*, random_access_iterator_tag) &#123;</span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance half;</span><br><span class="line">  RandomAccessIterator middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first + half;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; *middle)</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      first = middle + <span class="number">1</span>;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,</span><br><span class="line">                              <span class="type">const</span> T&amp; value, Compare comp, Distance*,</span><br><span class="line">                              forward_iterator_tag) &#123;</span><br><span class="line">  Distance len = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(first, last, len);</span><br><span class="line">  Distance half;</span><br><span class="line">  ForwardIterator middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first;</span><br><span class="line">    <span class="built_in">advance</span>(middle, half);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(value, *middle))</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      first = middle;</span><br><span class="line">      ++first;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">RandomAccessIterator __upper_bound(RandomAccessIterator first,</span><br><span class="line">                                   RandomAccessIterator last,</span><br><span class="line">                                   <span class="type">const</span> T&amp; value, Compare comp, Distance*,</span><br><span class="line">                                   random_access_iterator_tag) &#123;</span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance half;</span><br><span class="line">  RandomAccessIterator middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first + half;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(value, *middle))</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      first = middle + <span class="number">1</span>;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><p>算法binary_search是一种二分查找法，试图在已排序的[first, last)中寻找元素value。如果[first, last)内有等同于value的元素，便返回true， 否则返回false。</p>
<p>返回单纯的bool或许不能满足你，前面所介绍的lower_bound和upper_bound能够提供额外的信息。事实上binary_search便是利用lower_bound先找出“假设value存在的话，应该出现的位置”。然后再对比该位置上的值是 否为我们所要查找的目标，并返回对比结果。 </p>
<p>正式地说，当且仅当(if and only if) [first, last)中存在一个迭代器i使<code>*i &lt; vlaue</code>和<code>value &lt; *i</code>皆不为真，返回true。 </p>
<p>函数实现原理如下：在当前序列中，从尾端往前寻找两个相邻元素，前一个记为<em>i，后一个记为</em>ii，并且满足<em>i &lt; </em>ii。然后再从尾端寻找另一个元素<em>j，如果满足</em>i &lt; *j，即将第i个元素与第j个元素对调，并将第ii个元素之后（包括ii）的所有元素颠倒排序，即求出下一个序列了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  ForwardIterator i = <span class="built_in">lower_bound</span>(first, last, value);</span><br><span class="line">  <span class="keyword">return</span> i != last &amp;&amp; !(value &lt; *i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value,</span></span></span><br><span class="line"><span class="params"><span class="function">                   Compare comp)</span> </span>&#123;</span><br><span class="line">  ForwardIterator i = <span class="built_in">lower_bound</span>(first, last, value, comp);</span><br><span class="line">  <span class="keyword">return</span> i != last &amp;&amp; !<span class="built_in">comp</span>(value, *i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="next-permutation-prev-permutation"><a href="#next-permutation-prev-permutation" class="headerlink" title="next_permutation/prev_permutation"></a>next_permutation/prev_permutation</h3><p>STL中提供了2个计算排列组合关系的算法。分别是next_permucation和prev_permutaion。</p>
<p>next_permutation是用来计算下一个（next）字典序排列的组合，而prev_permutation用来计算上一个（prev）字典序的排列组合。</p>
<p>字典排序是指排列组合中，按照大小由小到大的排序，例如123的排列组着，字典排序为123,132,213,231,312,321。<br><img src="/img/1610605328.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                      BidirectionalIterator last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  BidirectionalIterator i = first;</span><br><span class="line">  ++i;</span><br><span class="line">  <span class="keyword">if</span> (i == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  i = last;</span><br><span class="line">  --i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    BidirectionalIterator ii = i;</span><br><span class="line">    --i;</span><br><span class="line">    <span class="keyword">if</span> (*i &lt; *ii) &#123;</span><br><span class="line">      BidirectionalIterator j = last;</span><br><span class="line">      <span class="keyword">while</span> (!(*i &lt; *--j));</span><br><span class="line">      <span class="built_in">iter_swap</span>(i, j);</span><br><span class="line">      <span class="built_in">reverse</span>(ii, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == first) &#123;</span><br><span class="line">      <span class="built_in">reverse</span>(first, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(BidirectionalIterator first, BidirectionalIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                      Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  BidirectionalIterator i = first;</span><br><span class="line">  ++i;</span><br><span class="line">  <span class="keyword">if</span> (i == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  i = last;</span><br><span class="line">  --i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    BidirectionalIterator ii = i;</span><br><span class="line">    --i;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*i, *ii)) &#123;</span><br><span class="line">      BidirectionalIterator j = last;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">comp</span>(*i, *--j));</span><br><span class="line">      <span class="built_in">iter_swap</span>(i, j);</span><br><span class="line">      <span class="built_in">reverse</span>(ii, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == first) &#123;</span><br><span class="line">      <span class="built_in">reverse</span>(first, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prev_permutation</span><span class="params">(BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                      BidirectionalIterator last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  BidirectionalIterator i = first;</span><br><span class="line">  ++i;</span><br><span class="line">  <span class="keyword">if</span> (i == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  i = last;</span><br><span class="line">  --i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    BidirectionalIterator ii = i;</span><br><span class="line">    --i;</span><br><span class="line">    <span class="keyword">if</span> (*ii &lt; *i) &#123;</span><br><span class="line">      BidirectionalIterator j = last;</span><br><span class="line">      <span class="keyword">while</span> (!(*--j &lt; *i));</span><br><span class="line">      <span class="built_in">iter_swap</span>(i, j);</span><br><span class="line">      <span class="built_in">reverse</span>(ii, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == first) &#123;</span><br><span class="line">      <span class="built_in">reverse</span>(first, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prev_permutation</span><span class="params">(BidirectionalIterator first, BidirectionalIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                      Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  BidirectionalIterator i = first;</span><br><span class="line">  ++i;</span><br><span class="line">  <span class="keyword">if</span> (i == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  i = last;</span><br><span class="line">  --i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    BidirectionalIterator ii = i;</span><br><span class="line">    --i;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*ii, *i)) &#123;</span><br><span class="line">      BidirectionalIterator j = last;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">comp</span>(*--j, *i));</span><br><span class="line">      <span class="built_in">iter_swap</span>(i, j);</span><br><span class="line">      <span class="built_in">reverse</span>(ii, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == first) &#123;</span><br><span class="line">      <span class="built_in">reverse</span>(first, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h3><p>将区间内的元素随机重排，获得N!种全排列中的任意一种</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">                      Distance*) &#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_NO_DRAND48</span></span><br><span class="line">    <span class="built_in">iter_swap</span>(i, first + <span class="built_in">Distance</span>(<span class="built_in">rand</span>() % ((i - first) + <span class="number">1</span>)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">iter_swap</span>(i, first + <span class="built_in">Distance</span>(<span class="built_in">lrand48</span>() % ((i - first) + <span class="number">1</span>)));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">random_shuffle</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                           RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  __random_shuffle(first, last, <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">RandomNumberGenerator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">random_shuffle</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                    RandomNumberGenerator&amp; rand)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)</span><br><span class="line">    <span class="built_in">iter_swap</span>(i, first + <span class="built_in">rand</span>((i - first) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="partial-sort-partial-sort-copy"><a href="#partial-sort-partial-sort-copy" class="headerlink" title="partial_sort/partial_sort_copy"></a>partial_sort/partial_sort_copy</h3><p>本算法接受一个middle迭代器（位于序列[first, last)之内），然后重新安排[first, last)，使序列中的middle-first个最小元素以递增顺序排序， 置于[first, middle)内、其余last-middle个元素安置于[middle, last)中， 不保证有任何特定顺序。 </p>
<p>使用sort算法，同样能保证较小的N个元素以递增顺序置于[first, first+N)中， </p>
<p>partial_sort的任务是找出middle-first个最小元素，因此，首先界定出区间[first, middle)，并利用<code>make_heap()</code>将它组织成一个 max-heap，然后就可以将[middle, last)中的每一个元素拿来与max-heap的最大值比较（max-heap的最大值就在第一个元素身上，轻松可以获得）：如果小于该最大值，则互换位置并保持max-heap状态。<br><img src="/img/1610605767.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,</span><br><span class="line">                    RandomAccessIterator last, T*) &#123;</span><br><span class="line">  <span class="built_in">make_heap</span>(first, middle);</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = middle; i &lt; last; ++i)</span><br><span class="line">    <span class="keyword">if</span> (*i &lt; *first)</span><br><span class="line">      __pop_heap(first, middle, i, <span class="built_in">T</span>(*i), <span class="built_in">distance_type</span>(first));</span><br><span class="line">  <span class="built_in">sort_heap</span>(first, middle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">partial_sort</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                         RandomAccessIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                         RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  __partial_sort(first, middle, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,</span><br><span class="line">                    RandomAccessIterator last, T*, Compare comp) &#123;</span><br><span class="line">  <span class="built_in">make_heap</span>(first, middle, comp);</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = middle; i &lt; last; ++i)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*i, *first))</span><br><span class="line">      __pop_heap(first, middle, i, <span class="built_in">T</span>(*i), comp, <span class="built_in">distance_type</span>(first));</span><br><span class="line">  <span class="built_in">sort_heap</span>(first, middle, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">partial_sort</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                         RandomAccessIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                         RandomAccessIterator last, Compare comp)</span> </span>&#123;</span><br><span class="line">  __partial_sort(first, middle, last, <span class="built_in">value_type</span>(first), comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>partial_sort</code>有一个姊妹，就是<code>partial_sort_copy</code>，它将（last-first）个最小元素排序后的结果置于（rsult_first, result_last）中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">RandomAccessIterator __partial_sort_copy(InputIterator first,</span><br><span class="line">                                         InputIterator last,</span><br><span class="line">                                         RandomAccessIterator result_first,</span><br><span class="line">                                         RandomAccessIterator result_last,</span><br><span class="line">                                         Distance*, T*) &#123;</span><br><span class="line">  <span class="keyword">if</span> (result_first == result_last) <span class="keyword">return</span> result_last;</span><br><span class="line">  RandomAccessIterator result_real_last = result_first;</span><br><span class="line">  <span class="keyword">while</span>(first != last &amp;&amp; result_real_last != result_last) &#123;</span><br><span class="line">    *result_real_last = *first;</span><br><span class="line">    ++result_real_last;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">make_heap</span>(result_first, result_real_last);</span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first &lt; *result_first)</span><br><span class="line">      __adjust_heap(result_first, <span class="built_in">Distance</span>(<span class="number">0</span>),</span><br><span class="line">                    <span class="built_in">Distance</span>(result_real_last - result_first), <span class="built_in">T</span>(*first));</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort_heap</span>(result_first, result_real_last);</span><br><span class="line">  <span class="keyword">return</span> result_real_last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> RandomAccessIterator</span></span><br><span class="line"><span class="function"><span class="title">partial_sort_copy</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator result_first,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator result_last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __partial_sort_copy(first, last, result_first, result_last,</span><br><span class="line">                             <span class="built_in">distance_type</span>(result_first), <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">RandomAccessIterator __partial_sort_copy(InputIterator first,</span><br><span class="line">                                         InputIterator last,</span><br><span class="line">                                         RandomAccessIterator result_first,</span><br><span class="line">                                         RandomAccessIterator result_last,</span><br><span class="line">                                         Compare comp, Distance*, T*) &#123;</span><br><span class="line">  <span class="keyword">if</span> (result_first == result_last) <span class="keyword">return</span> result_last;</span><br><span class="line">  RandomAccessIterator result_real_last = result_first;</span><br><span class="line">  <span class="keyword">while</span>(first != last &amp;&amp; result_real_last != result_last) &#123;</span><br><span class="line">    *result_real_last = *first;</span><br><span class="line">    ++result_real_last;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">make_heap</span>(result_first, result_real_last, comp);</span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*first, *result_first))</span><br><span class="line">      __adjust_heap(result_first, <span class="built_in">Distance</span>(<span class="number">0</span>),</span><br><span class="line">                    <span class="built_in">Distance</span>(result_real_last - result_first), <span class="built_in">T</span>(*first),</span><br><span class="line">                    comp);</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort_heap</span>(result_first, result_real_last, comp);</span><br><span class="line">  <span class="keyword">return</span> result_real_last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> RandomAccessIterator</span></span><br><span class="line"><span class="function"><span class="title">partial_sort_copy</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator result_first,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator result_last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __partial_sort_copy(first, last, result_first, result_last, comp,</span><br><span class="line">                             <span class="built_in">distance_type</span>(result_first), <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>STL所提供的各式各样算法中，<code>sort()</code>是最复杂最庞大的一个，这个算法接受两个RandomAccessIterator（随机存取迭代器），然后将区间内的所有元素以渐增方式由小到大重新排列，第二个版本则允许用户指定一个仿函数(functor), 作为排序标准。STL的所有关系型容器(associative containers）都拥有自动排序功能（底层结构采用RB - tree），所以不需要用到这个sort算法。至于序列式容器(sequence containers）中的stacks、queue和priority-queue都有特别的出入口，不允许用户对元素排序。剩下vector、 deque和list，前两者的迭代器属于RandormAccessIterators，适合使用sort算法，list的迭代器则属于BidirectionalIterators，不在STL标准之列的slist，其迭代器属于ForwardIterators，都不适合使用sort算法。如果要对list或slist排序，应该使用它们自己提供的member functions sort()。</p>
<p>STL的sort算法，数据量大时采用Quick分段递归排序，一旦分段后的数据量小于某个门槛，为了避免QuickSort的递归调用带来过大的额外负荷，就改用InsertionSort.如果递归层次过深，还会改用HeapSort，以下分别介绍OuickSort和lnsertionSort，然后再整合起来介绍STL sort。</p>
<h4 id="InsertionSort"><a href="#InsertionSort" class="headerlink" title="InsertionSort"></a>InsertionSort</h4><p>Insertionsort以双层循环的形式进行，外循环遍历整个序列，每次迭代决定出一个子区间；内循环遍历子区间，将子区间内的每一个“逆转对（inversion)”倒转过来。“逆转对”是指任何两个迭代器i、j，<code>i &lt; j</code>而<code>*i &gt; *j</code>。一旦不存在“逆转对”，序列即排序完毕。这个算法的复杂度为O(N2)，说起来并不理想，但是当数据量很少时，却有不错的效果，原因是实现上有一些技巧，而且不像其它较为复杂的排序算法有着诸如递归调用等操作带来的额外负荷。<br><img src="/img/1610692930.jpg" alt=""></p>
<p>SGISTL的lnsertionsort两个版本，版本一使用以渐增力式排序，也就是说，以<code>operator&lt;</code>为两元素比较的函数，版本二允许用户指定一个仿函数，作为两元素比较的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="type">void</span> __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) &#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)</span><br><span class="line">    __linear_insert(first, i, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __insertion_sort(RandomAccessIterator first,</span><br><span class="line">                      RandomAccessIterator last, Compare comp) &#123;</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)</span><br><span class="line">    __linear_insert(first, i, <span class="built_in">value_type</span>(first), comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __linear_insert(RandomAccessIterator first,</span><br><span class="line">                            RandomAccessIterator last, T*) &#123;</span><br><span class="line">  T value = *last;</span><br><span class="line">  <span class="keyword">if</span> (value &lt; *first) &#123;</span><br><span class="line">    <span class="built_in">copy_backward</span>(first, last, last + <span class="number">1</span>);</span><br><span class="line">    *first = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __unguarded_linear_insert(last, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __linear_insert(RandomAccessIterator first,</span><br><span class="line">                            RandomAccessIterator last, T*, Compare comp) &#123;</span><br><span class="line">  T value = *last;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">comp</span>(value, *first)) &#123;</span><br><span class="line">    <span class="built_in">copy_backward</span>(first, last, last + <span class="number">1</span>);</span><br><span class="line">    *first = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __unguarded_linear_insert(last, value, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __unguarded_linear_insert(RandomAccessIterator last, T value) &#123;</span><br><span class="line">  RandomAccessIterator next = last;</span><br><span class="line">  --next;</span><br><span class="line">  <span class="keyword">while</span> (value &lt; *next) &#123;</span><br><span class="line">    *last = *next;</span><br><span class="line">    last = next;</span><br><span class="line">    --next;</span><br><span class="line">  &#125;</span><br><span class="line">  *last = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __unguarded_linear_insert(RandomAccessIterator last, T value,</span><br><span class="line">                               Compare comp) &#123;</span><br><span class="line">  RandomAccessIterator next = last;</span><br><span class="line">  --next;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">comp</span>(value , *next)) &#123;</span><br><span class="line">    *last = *next;</span><br><span class="line">    last = next;</span><br><span class="line">    --next;</span><br><span class="line">  &#125;</span><br><span class="line">  *last = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述函数之所以命名为<code>unguarded_x</code>是因为，一般的Insertion Sort在内循环原本需要做两次判断，判断是否相邻两元素是“逆转对”；同时也判断循环的行进是否超过边界。但由于上述所示的源代码会导致最小值必然在内循环子区间的最边缘，所以两个判断可合为一个判断，所以称为unguarded。省下一个判断操作，乍见之下无足轻重，但是在大数据量的情况下，影响还是可观的，毕竟这是一 个非常根本的算法核心，在大数据量的情况，执行次数非常惊人。 </p>
<h3 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h3><p>如果我们拿Insertion Sort来处理大量数据，其O(N2)的复杂度就令人摇头了。大数据量的情形下有许多更好的排序算法可供选择。正如其名称所昭示，Quick Sort 是目前已知最快的排序法，平均复杂度为O(N logN)，最坏情况下将达O(N2)，不过IntroSort（极类似median-of-three QuickSort的一种排序算法〕可将最坏情况（分割时产生一个空的子区间）推进到O(N logN)。</p>
<p>快排的步骤：</p>
<ol>
<li>如果s的元素是0或者1，结束</li>
<li>取s 中任何一个元素，当做枢纽v</li>
<li>将s 分割为l r两部分，使l内的元素都小于等于v，r内的元素都大于v</li>
<li>对l，r递归执行快排</li>
</ol>
<p><img src="/img/1610693433.jpg" alt=""></p>
<p>media-of-three partitioning 取头尾中央三个位置的值的中值作为v</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> T&amp; __median(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, <span class="type">const</span> T&amp; c) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">    <span class="keyword">if</span> (b &lt; c)</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; c)</span><br><span class="line">      <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; c)</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (b &lt; c)</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Partitioining（分割）方法不只一种，以下叙述既简单又有良好成效的做法。令头端迭代器first向尾部移动，尾端迭代器last向头部移动。当<code>*first</code>大于或等于枢轴时 就停下来，当<code>*last</code>小于或等于枢轴时也停下来，然后检验两个迭代器是否交错。如果first仍然在左而last仍然在右，就将两者元素互换，然后各自调整一个位置（向中央逼近），再继续进行相同的行为。如果发现两个迭代器交错了，表示整个序列已经调整完毕，以此时的first为轴，将序列分为左右两半，左半部所有元素值都小于或等于枢轴，右半部所有元素值都大于或等于枢轴。<br><img src="/img/1610693726.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">RandomAccessIterator __unguarded_partition(RandomAccessIterator first,</span><br><span class="line">                                           RandomAccessIterator last,</span><br><span class="line">                                           T pivot) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (*first &lt; pivot) ++first;</span><br><span class="line">    --last;</span><br><span class="line">    <span class="keyword">while</span> (pivot &lt; *last) --last;</span><br><span class="line">    <span class="keyword">if</span> (!(first &lt; last)) <span class="keyword">return</span> first;</span><br><span class="line">    <span class="built_in">iter_swap</span>(first, last);</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line">RandomAccessIterator __unguarded_partition(RandomAccessIterator first,</span><br><span class="line">                                           RandomAccessIterator last,</span><br><span class="line">                                           T pivot, Compare comp) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">comp</span>(*first, pivot)) ++first;</span><br><span class="line">    --last;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">comp</span>(pivot, *last)) --last;</span><br><span class="line">    <span class="keyword">if</span> (!(first &lt; last)) <span class="keyword">return</span> first;</span><br><span class="line">    <span class="built_in">iter_swap</span>(first, last);</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>面对一个只有十来个元素的小型序列，使用像Quick Sort这样复杂而需要大量运算的排序法不划算，在小数据量的情况下，甚至简单如Insertion Sort者也可能快过Quick Sort―因为Quick Sort会为了极小的子序 列而产生许多的函数递归调用。鉴于这种情况，适度评估序列的大小，然后决定采用Quick Sort或Insertion Sort是值得采纳的一种优化措施。然而究竟多小的序列才应该断然改用Insertion Sort呢？并无定论，5-2O都可能导致差不多的结果。实际的最佳值因设备而异。</p>
<p>final insertion sort 优化措施永不嫌多，只要我们不是贸然行事。如果我们令某个大小以下的序列滞留在“几近排序但尚未完成”的状态、最后再以一次Insertion Sort将所有这些“几近排序但尚未竞全功”的子序列做一次完整的排序，其效率一般认为会比“将所有子序列彻底排序”更好。这是因为Insertion Sort在面对“几近排序”的序列时、有很好的表现。</p>
<p>introsort：不当的枢轴选择导致Quick Sort恶化为O(N2)，Introspective Sorting（内省排序）当分割行为有恶化为二次行为时，能够自我侦测，转而改用Heap Sort。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    __introsort_loop(first, last, <span class="built_in">value_type</span>(first), __lg(last - first) * <span class="number">2</span>);</span><br><span class="line">    __final_insertion_sort(first, last);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                 Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    __introsort_loop(first, last, <span class="built_in">value_type</span>(first), __lg(last - first) * <span class="number">2</span>,</span><br><span class="line">                     comp);</span><br><span class="line">    __final_insertion_sort(first, last, comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中的<code>__lg()</code>用于控制分割恶化的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Size</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> Size __lg(Size n) &#123;</span><br><span class="line">  Size k;</span><br><span class="line">  <span class="keyword">for</span> (k = <span class="number">0</span>; n &gt; <span class="number">1</span>; n &gt;&gt;= <span class="number">1</span>) ++k;</span><br><span class="line">  <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>元素为40个时，<code>__introsort_loop()</code>的最后一个参数为5*2，意思是最多允许10层分割。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Size</span>&gt;</span><br><span class="line"><span class="type">void</span> __introsort_loop(RandomAccessIterator first,</span><br><span class="line">                      RandomAccessIterator last, T*,</span><br><span class="line">                      Size depth_limit) &#123;</span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth_limit == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">partial_sort</span>(first, last, last);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --depth_limit;</span><br><span class="line">    RandomAccessIterator cut = __unguarded_partition</span><br><span class="line">      (first, last, <span class="built_in">T</span>(__median(*first, *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">                               *(last - <span class="number">1</span>))));</span><br><span class="line">    __introsort_loop(cut, last, <span class="built_in">value_type</span>(first), depth_limit);</span><br><span class="line">    last = cut;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __introsort_loop(RandomAccessIterator first,</span><br><span class="line">                      RandomAccessIterator last, T*,</span><br><span class="line">                      Size depth_limit, Compare comp) &#123;</span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth_limit == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">partial_sort</span>(first, last, last, comp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --depth_limit;</span><br><span class="line">    RandomAccessIterator cut = __unguarded_partition</span><br><span class="line">      (first, last, <span class="built_in">T</span>(__median(*first, *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">                               *(last - <span class="number">1</span>), comp)), comp);</span><br><span class="line">    __introsort_loop(cut, last, <span class="built_in">value_type</span>(first), depth_limit, comp);</span><br><span class="line">    last = cut;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>函数一开始就判断序列大小，<code>__stl_threshold</code>是个全局整型常数，定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> __stl_threshold - <span class="number">16</span>;</span><br></pre></td></tr></table></figure></p>
<p>通过元素个数检验之后，再检查分割层次，如果分割层次超过指定值，就改用<code>partition_sort()</code>。都通过了这些检验之后，便进入与Quick Sort完全相同的程序：以median-of-3方法确定枢轴位置，然后调用<code>__unguarded_partition()</code>找出分割点，然后针对左右段落递归进行IntroSort</p>
<p>当<code>__introsort_loop()</code>结束，[first, last)内有多个“元素个数少于16”的子序列，每个子序列都有相当程度的排序，但尚未完全排序（因为元素个数一旦小于<code>__stl_threshold</code>，就被中止进一步的排序操作。回到母函数<code>sort()</code>，再进入<code>final_insertion_sort()</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="type">void</span> __final_insertion_sort(RandomAccessIterator first,</span><br><span class="line">                            RandomAccessIterator last) &#123;</span><br><span class="line">  <span class="keyword">if</span> (last - first &gt; __stl_threshold) &#123;</span><br><span class="line">    __insertion_sort(first, first + __stl_threshold);</span><br><span class="line">    __unguarded_insertion_sort(first + __stl_threshold, last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __insertion_sort(first, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __final_insertion_sort(RandomAccessIterator first,</span><br><span class="line">                            RandomAccessIterator last, Compare comp) &#123;</span><br><span class="line">  <span class="keyword">if</span> (last - first &gt; __stl_threshold) &#123;</span><br><span class="line">    __insertion_sort(first, first + __stl_threshold, comp);</span><br><span class="line">    __unguarded_insertion_sort(first + __stl_threshold, last, comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __insertion_sort(first, last, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __unguarded_insertion_sort_aux(RandomAccessIterator first,</span><br><span class="line">                                    RandomAccessIterator last, T*) &#123;</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = first; i != last; ++i)</span><br><span class="line">    __unguarded_linear_insert(i, <span class="built_in">T</span>(*i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __unguarded_insertion_sort(RandomAccessIterator first,</span><br><span class="line">                                RandomAccessIterator last) &#123;</span><br><span class="line">  __unguarded_insertion_sort_aux(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __unguarded_insertion_sort_aux(RandomAccessIterator first,</span><br><span class="line">                                    RandomAccessIterator last,</span><br><span class="line">                                    T*, Compare comp) &#123;</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = first; i != last; ++i)</span><br><span class="line">    __unguarded_linear_insert(i, <span class="built_in">T</span>(*i), comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __unguarded_insertion_sort(RandomAccessIterator first,</span><br><span class="line">                                       RandomAccessIterator last,</span><br><span class="line">                                       Compare comp) &#123;</span><br><span class="line">  __unguarded_insertion_sort_aux(first, last, <span class="built_in">value_type</span>(first), comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range"></a>equal_range</h3><p>是二分查找法的一个版本，试图在已排序的[first, last)中寻找value，它返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插人的第一个位置（亦即lower_bound），j则是在不破坏次序的前提下，value可插人的最后一个位置（亦即upper_bound）。因此，[i ,j)内的每个元素都等同于value，而且[i, j)是[fisrt, last)之中符合此一性质的最大子区间。<br><img src="/img/1610695096.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">pair&lt;ForwardIterator, ForwardIterator&gt;</span><br><span class="line">__equal_range(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value,</span><br><span class="line">              Distance*, forward_iterator_tag) &#123;</span><br><span class="line">  Distance len = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(first, last, len);</span><br><span class="line">  Distance half;</span><br><span class="line">  ForwardIterator middle, left, right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first;</span><br><span class="line">    <span class="built_in">advance</span>(middle, half);</span><br><span class="line">    <span class="keyword">if</span> (*middle &lt; value) &#123;</span><br><span class="line">      first = middle;</span><br><span class="line">      ++first;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; *middle)</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      left = <span class="built_in">lower_bound</span>(first, middle, value);</span><br><span class="line">      <span class="built_in">advance</span>(first, len);</span><br><span class="line">      right = <span class="built_in">upper_bound</span>(++middle, first, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">pair</span>&lt;ForwardIterator, ForwardIterator&gt;(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pair</span>&lt;ForwardIterator, ForwardIterator&gt;(first, first);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">pair&lt;RandomAccessIterator, RandomAccessIterator&gt;</span><br><span class="line">__equal_range(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">              <span class="type">const</span> T&amp; value, Distance*, random_access_iterator_tag) &#123;</span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance half;</span><br><span class="line">  RandomAccessIterator middle, left, right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first + half;</span><br><span class="line">    <span class="keyword">if</span> (*middle &lt; value) &#123;</span><br><span class="line">      first = middle + <span class="number">1</span>;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; *middle)</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      left = <span class="built_in">lower_bound</span>(first, middle, value);</span><br><span class="line">      right = <span class="built_in">upper_bound</span>(++middle, first + len, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">pair</span>&lt;RandomAccessIterator, RandomAccessIterator&gt;(left,</span><br><span class="line">                                                              right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pair</span>&lt;RandomAccessIterator, RandomAccessIterator&gt;(first, first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;ForwardIterator, ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="title">equal_range</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __equal_range(first, last, value, <span class="built_in">distance_type</span>(first),</span><br><span class="line">                       <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">pair&lt;ForwardIterator, ForwardIterator&gt;</span><br><span class="line">__equal_range(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value,</span><br><span class="line">              Compare comp, Distance*, forward_iterator_tag) &#123;</span><br><span class="line">  Distance len = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(first, last, len);</span><br><span class="line">  Distance half;</span><br><span class="line">  ForwardIterator middle, left, right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first;</span><br><span class="line">    <span class="built_in">advance</span>(middle, half);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*middle, value)) &#123;</span><br><span class="line">      first = middle;</span><br><span class="line">      ++first;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">comp</span>(value, *middle))</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      left = <span class="built_in">lower_bound</span>(first, middle, value, comp);</span><br><span class="line">      <span class="built_in">advance</span>(first, len);</span><br><span class="line">      right = <span class="built_in">upper_bound</span>(++middle, first, value, comp);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">pair</span>&lt;ForwardIterator, ForwardIterator&gt;(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pair</span>&lt;ForwardIterator, ForwardIterator&gt;(first, first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">pair&lt;RandomAccessIterator, RandomAccessIterator&gt;</span><br><span class="line">__equal_range(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">              <span class="type">const</span> T&amp; value, Compare comp, Distance*,</span><br><span class="line">              random_access_iterator_tag) &#123;</span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance half;</span><br><span class="line">  RandomAccessIterator middle, left, right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first + half;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*middle, value)) &#123;</span><br><span class="line">      first = middle + <span class="number">1</span>;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">comp</span>(value, *middle))</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      left = <span class="built_in">lower_bound</span>(first, middle, value, comp);</span><br><span class="line">      right = <span class="built_in">upper_bound</span>(++middle, first + len, value, comp);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">pair</span>&lt;RandomAccessIterator, RandomAccessIterator&gt;(left,</span><br><span class="line">                                                              right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pair</span>&lt;RandomAccessIterator, RandomAccessIterator&gt;(first, first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;ForwardIterator, ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="title">equal_range</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value,</span></span></span><br><span class="line"><span class="params"><span class="function">            Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __equal_range(first, last, value, comp, <span class="built_in">distance_type</span>(first),</span><br><span class="line">                       <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="inplace-merge"><a href="#inplace-merge" class="headerlink" title="inplace_merge"></a>inplace_merge</h3><p>应用于有序区间，把两个连接在一起且各自有序的序列合并成一个序列，仍保持有序。稳定操作，保持相对次序不变，如果有相同元素，第一个序列的排在前面。内部实现时根据有无缓冲不同处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">inplace_merge</span><span class="params">(BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BidirectionalIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BidirectionalIterator last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == middle || middle == last) <span class="keyword">return</span>;</span><br><span class="line">  __inplace_merge_aux(first, middle, last, <span class="built_in">value_type</span>(first),</span><br><span class="line">                      <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">inplace_merge</span><span class="params">(BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BidirectionalIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BidirectionalIterator last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == middle || middle == last) <span class="keyword">return</span>;</span><br><span class="line">  __inplace_merge_aux(first, middle, last, <span class="built_in">value_type</span>(first),</span><br><span class="line">                      <span class="built_in">distance_type</span>(first), comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __inplace_merge_aux(BidirectionalIterator first,</span><br><span class="line">                                BidirectionalIterator middle,</span><br><span class="line">                                BidirectionalIterator last, T*, Distance*) &#123;</span><br><span class="line">  Distance len1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(first, middle, len1);</span><br><span class="line">  Distance len2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(middle, last, len2);</span><br><span class="line"></span><br><span class="line">  <span class="function">temporary_buffer&lt;BidirectionalIterator, T&gt; <span class="title">buf</span><span class="params">(first, last)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (buf.<span class="built_in">begin</span>() == <span class="number">0</span>)</span><br><span class="line">    __merge_without_buffer(first, middle, last, len1, len2);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __merge_adaptive(first, middle, last, len1, len2,</span><br><span class="line">                     buf.<span class="built_in">begin</span>(), <span class="built_in">Distance</span>(buf.<span class="built_in">size</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __inplace_merge_aux(BidirectionalIterator first,</span><br><span class="line">                                BidirectionalIterator middle,</span><br><span class="line">                                BidirectionalIterator last, T*, Distance*,</span><br><span class="line">                                Compare comp) &#123;</span><br><span class="line">  Distance len1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(first, middle, len1);</span><br><span class="line">  Distance len2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(middle, last, len2);</span><br><span class="line"></span><br><span class="line">  <span class="function">temporary_buffer&lt;BidirectionalIterator, T&gt; <span class="title">buf</span><span class="params">(first, last)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (buf.<span class="built_in">begin</span>() == <span class="number">0</span>)</span><br><span class="line">    __merge_without_buffer(first, middle, last, len1, len2, comp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __merge_adaptive(first, middle, last, len1, len2,</span><br><span class="line">                     buf.<span class="built_in">begin</span>(), <span class="built_in">Distance</span>(buf.<span class="built_in">size</span>()),</span><br><span class="line">                     comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有缓冲区的话效率会好很多：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">Pointer</span>&gt;</span><br><span class="line"><span class="type">void</span> __merge_adaptive(BidirectionalIterator first,</span><br><span class="line">                      BidirectionalIterator middle,</span><br><span class="line">                      BidirectionalIterator last, Distance len1, Distance len2,</span><br><span class="line">                      Pointer buffer, Distance buffer_size) &#123;</span><br><span class="line">  <span class="keyword">if</span> (len1 &lt;= len2 &amp;&amp; len1 &lt;= buffer_size) &#123;</span><br><span class="line">    Pointer end_buffer = <span class="built_in">copy</span>(first, middle, buffer);</span><br><span class="line">    <span class="built_in">merge</span>(buffer, end_buffer, middle, last, first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (len2 &lt;= buffer_size) &#123;</span><br><span class="line">    Pointer end_buffer = <span class="built_in">copy</span>(middle, last, buffer);</span><br><span class="line">    __merge_backward(first, middle, buffer, end_buffer, last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    BidirectionalIterator first_cut = first;</span><br><span class="line">    BidirectionalIterator second_cut = middle;</span><br><span class="line">    Distance len11 = <span class="number">0</span>;</span><br><span class="line">    Distance len22 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) &#123;</span><br><span class="line">      len11 = len1 / <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">advance</span>(first_cut, len11);</span><br><span class="line">      second_cut = <span class="built_in">lower_bound</span>(middle, last, *first_cut);</span><br><span class="line">      <span class="built_in">distance</span>(middle, second_cut, len22);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      len22 = len2 / <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">advance</span>(second_cut, len22);</span><br><span class="line">      first_cut = <span class="built_in">upper_bound</span>(first, middle, *second_cut);</span><br><span class="line">      <span class="built_in">distance</span>(first, first_cut, len11);</span><br><span class="line">    &#125;</span><br><span class="line">    BidirectionalIterator new_middle =</span><br><span class="line">      __rotate_adaptive(first_cut, middle, second_cut, len1 - len11,</span><br><span class="line">                        len22, buffer, buffer_size);</span><br><span class="line">    __merge_adaptive(first, first_cut, new_middle, len11, len22, buffer,</span><br><span class="line">                     buffer_size);</span><br><span class="line">    __merge_adaptive(new_middle, second_cut, last, len1 - len11,</span><br><span class="line">                     len2 - len22, buffer, buffer_size);</span><br><span class="line">  &#125;                  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">Pointer</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __merge_adaptive(BidirectionalIterator first,</span><br><span class="line">                      BidirectionalIterator middle,</span><br><span class="line">                      BidirectionalIterator last, Distance len1, Distance len2,</span><br><span class="line">                      Pointer buffer, Distance buffer_size, Compare comp) &#123;</span><br><span class="line">  <span class="keyword">if</span> (len1 &lt;= len2 &amp;&amp; len1 &lt;= buffer_size) &#123;</span><br><span class="line">    Pointer end_buffer = <span class="built_in">copy</span>(first, middle, buffer);</span><br><span class="line">    <span class="built_in">merge</span>(buffer, end_buffer, middle, last, first, comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (len2 &lt;= buffer_size) &#123;</span><br><span class="line">    Pointer end_buffer = <span class="built_in">copy</span>(middle, last, buffer);</span><br><span class="line">    __merge_backward(first, middle, buffer, end_buffer, last, comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    BidirectionalIterator first_cut = first;</span><br><span class="line">    BidirectionalIterator second_cut = middle;</span><br><span class="line">    Distance len11 = <span class="number">0</span>;</span><br><span class="line">    Distance len22 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) &#123;</span><br><span class="line">      len11 = len1 / <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">advance</span>(first_cut, len11);</span><br><span class="line">      second_cut = <span class="built_in">lower_bound</span>(middle, last, *first_cut, comp);</span><br><span class="line">      <span class="built_in">distance</span>(middle, second_cut, len22);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      len22 = len2 / <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">advance</span>(second_cut, len22);</span><br><span class="line">      first_cut = <span class="built_in">upper_bound</span>(first, middle, *second_cut, comp);</span><br><span class="line">      <span class="built_in">distance</span>(first, first_cut, len11);</span><br><span class="line">    &#125; </span><br><span class="line">    BidirectionalIterator new_middle =</span><br><span class="line">      __rotate_adaptive(first_cut, middle, second_cut, len1 - len11,</span><br><span class="line">                        len22, buffer, buffer_size);</span><br><span class="line">    __merge_adaptive(first, first_cut, new_middle, len11, len22, buffer,</span><br><span class="line">                     buffer_size, comp);</span><br><span class="line">    __merge_adaptive(new_middle, second_cut, last, len1 - len11,</span><br><span class="line">                     len2 - len22, buffer, buffer_size, comp);</span><br><span class="line">  &#125;                  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1610695460.jpg" alt=""><br><img src="/img/1610695483.jpg" alt=""></p>
<p>缓冲区不足以容纳一个序列时，以递归分割的方式，让处理长度减半，看能否容纳于缓冲区中。<br><img src="/img/1610695566.jpg" alt=""></p>
<p>然后执行旋转操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator1</span>, <span class="keyword">class</span> <span class="title class_">BidirectionalIterator2</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">BidirectionalIterator1 __rotate_adaptive(BidirectionalIterator1 first,</span><br><span class="line">                                         BidirectionalIterator1 middle,</span><br><span class="line">                                         BidirectionalIterator1 last,</span><br><span class="line">                                         Distance len1, Distance len2,</span><br><span class="line">                                         BidirectionalIterator2 buffer,</span><br><span class="line">                                         Distance buffer_size) &#123;</span><br><span class="line">  BidirectionalIterator2 buffer_end;</span><br><span class="line">  <span class="keyword">if</span> (len1 &gt; len2 &amp;&amp; len2 &lt;= buffer_size) &#123;</span><br><span class="line">    buffer_end = <span class="built_in">copy</span>(middle, last, buffer);</span><br><span class="line">    <span class="built_in">copy_backward</span>(first, middle, last);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">copy</span>(buffer, buffer_end, first);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len1 &lt;= buffer_size) &#123;</span><br><span class="line">    buffer_end = <span class="built_in">copy</span>(first, middle, buffer);</span><br><span class="line">    <span class="built_in">copy</span>(middle, last, first);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">copy_backward</span>(buffer, buffer_end, last);</span><br><span class="line">  &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">    <span class="built_in">rotate</span>(first, middle, last);</span><br><span class="line">    <span class="built_in">advance</span>(first, len2);</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h3><p>重新排列区间，使迭代器nth 所指向的元素与整个区间内排序后，同一位置的元素同值。保证nth-last 中没有任何一个元素不大于 first-nth 中的元素</p>
<p>不断用首尾中央三点中值为枢纽之分割法，将序列分割成更小的子序列，如果nth 落入左子序列， 就继续分割左子序列，如果落在右子序列就分割右子序列，最后对小于3的序列进行排序<br><img src="/img/1610696018.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __nth_element(RandomAccessIterator first, RandomAccessIterator nth,</span><br><span class="line">                   RandomAccessIterator last, T*) &#123;</span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    RandomAccessIterator cut = __unguarded_partition</span><br><span class="line">      (first, last, <span class="built_in">T</span>(__median(*first, *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">                               *(last - <span class="number">1</span>))));</span><br><span class="line">    <span class="keyword">if</span> (cut &lt;= nth)</span><br><span class="line">      first = cut;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      last = cut;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(first, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomAccessIterator first, RandomAccessIterator nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                        RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  __nth_element(first, nth, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __nth_element(RandomAccessIterator first, RandomAccessIterator nth,</span><br><span class="line">                   RandomAccessIterator last, T*, Compare comp) &#123;</span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    RandomAccessIterator cut = __unguarded_partition</span><br><span class="line">      (first, last, <span class="built_in">T</span>(__median(*first, *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">                               *(last - <span class="number">1</span>), comp)), comp);</span><br><span class="line">    <span class="keyword">if</span> (cut &lt;= nth)</span><br><span class="line">      first = cut;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      last = cut;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(first, last, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomAccessIterator first, RandomAccessIterator nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                 RandomAccessIterator last, Compare comp)</span> </span>&#123;</span><br><span class="line">  __nth_element(first, nth, last, <span class="built_in">value_type</span>(first), comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge_sort"></a>merge_sort</h3><p>归并排序，需要额外的内存，内存之间的拷贝需要时间，但是实现简单。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator1</span>, <span class="keyword">class</span> <span class="title class_">RandomAccessIterator2</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __merge_sort_loop(RandomAccessIterator1 first,</span><br><span class="line">                       RandomAccessIterator1 last,</span><br><span class="line">                       RandomAccessIterator2 result, Distance step_size) &#123;</span><br><span class="line">  Distance two_step = <span class="number">2</span> * step_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (last - first &gt;= two_step) &#123;</span><br><span class="line">    result = <span class="built_in">merge</span>(first, first + step_size,</span><br><span class="line">                   first + step_size, first + two_step, result);</span><br><span class="line">    first += two_step;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  step_size = <span class="built_in">min</span>(<span class="built_in">Distance</span>(last - first), step_size);</span><br><span class="line">  <span class="built_in">merge</span>(first, first + step_size, first + step_size, last, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator1</span>, <span class="keyword">class</span> <span class="title class_">RandomAccessIterator2</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __merge_sort_loop(RandomAccessIterator1 first,</span><br><span class="line">                       RandomAccessIterator1 last,</span><br><span class="line">                       RandomAccessIterator2 result, Distance step_size,</span><br><span class="line">                       Compare comp) &#123;</span><br><span class="line">  Distance two_step = <span class="number">2</span> * step_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (last - first &gt;= two_step) &#123;</span><br><span class="line">    result = <span class="built_in">merge</span>(first, first + step_size,</span><br><span class="line">                   first + step_size, first + two_step, result, comp);</span><br><span class="line">    first += two_step;</span><br><span class="line">  &#125;</span><br><span class="line">  step_size = <span class="built_in">min</span>(<span class="built_in">Distance</span>(last - first), step_size);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">merge</span>(first, first + step_size, first + step_size, last, result, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h1><h2 id="仿函数概述"><a href="#仿函数概述" class="headerlink" title="仿函数概述"></a>仿函数概述</h2><p>仿函数也叫作函数对象，是一种<strong>具有函数特质的对象</strong>，调用者可以像函数一样地调用这些对象，被调用者则以对象所定义的function call operator扮演函数的实质角色。就实现观点而言，仿函数其实上就是一个“行为类似函数”的对象。为了“行为类似函数”，其类别定义中必须自定义function call 运算子（<code>operator()</code>）。STL中仿函数代替函数指针的原因在于函数指针不能满足STL对抽象性的要求，也不能满足软件积木的要求，函数指针无法与STL其他组件搭配。</p>
<p>STL仿函数的分类，若以操作数的个数划分，可以分为一元和二元仿函数；若以功能划分，可以分为算术运算（Arithmetic）、关系运算（Rational）、逻辑运算（Logical）三大类。其头文件为<code>&lt;functional&gt;</code>。</p>
<h2 id="可配接的关键"><a href="#可配接的关键" class="headerlink" title="可配接的关键"></a>可配接的关键</h2><p>STL仿函数应该有能力被函数适配器修饰，就像积木一样串接，然而，为了拥有配接能力，每个仿函数都必须定义自己的associative types（主要用来表示函数参数类型和返回值类型），就想迭代器如果要融入整个STL大家庭，也必须按照规定定义自己的5个相应的类型一样，这些assocaiative type是为了让配接器可以取得仿函数的某些信息，当然，这些associative type都只是一些typedef，所有必要操作在编译器就全部完成了，对程序的执行效率没有任何影响，不会带来额外的负担。</p>
<p>仿函数的相应类型主要用来表现函数参数类型和传回值类型，为了方便起见<code>&lt;stl_functional.h&gt;</code>定义了两个类classes，分别代表一元仿函数和二元仿函数。其中没有任何data members或member functions，唯有一些类型定义，任何仿函数只要依个人需求选择继承其中一个class，便自动拥有了那些相应类型，也自动拥有了配接能力。</p>
<h3 id="unary-function"><a href="#unary-function" class="headerlink" title="unary_function"></a>unary_function</h3><p><code>unary_function</code>用来呈现一元函数的参数类型和返回值类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//STL规定，每一个Adaptable Unary Function都应继承此类别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unary_function</span> &#123;</span><br><span class="line">	<span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一旦某个仿函数继承了<code>unary_function</code>，其用户便可以这样取得仿函数的参数类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">negate</span> : <span class="keyword">public</span> unary_function&lt;T, T&gt; &#123;</span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> -x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下配接器用来表示某个仿函数的逻辑负值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unary_negate</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Predicate::argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="binary-function"><a href="#binary-function" class="headerlink" title="binary_function"></a>binary_function</h3><p><code>binary_function</code>用来呈现二元函数的第一参数型别、第二参数型别及返回值型别。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//STL规定，每一个Adaptable Binary Function都应继承此类别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binary_function</span> &#123;</span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一旦某个仿函数继承了<code>binary_function</code>，其用户便可以这样取得仿函数的参数类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">plus</span> : <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x+y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下配接器用来表示某个仿函数的逻辑负值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binder1st</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Operation op;</span><br><span class="line">  <span class="keyword">typename</span> Operation::first_argument_type value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">typename</span> Operation::result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation::second_argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="算术类仿函数"><a href="#算术类仿函数" class="headerlink" title="算术类仿函数"></a>算术类仿函数</h2><p>STL内建算术类仿函数：加法：<code>plus&lt;T&gt;</code>，减法：<code>minus&lt;T&gt;</code>，乘法：<code>multiplies&lt;T&gt;</code>，除法：<code>divides&lt;T&gt;</code>，取模：<code>modulus&lt;T&gt;</code>，取反：<code>negate&lt;T&gt;</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">plus</span> : <span class="keyword">public</span> binary_function&lt;T,T,T&gt; &#123;</span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">minus</span> : <span class="keyword">public</span> binary_function&lt;T,T,T&gt; &#123;</span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">multiplies</span> : <span class="keyword">public</span> binary_function&lt;T,T,T&gt; &#123;</span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divides</span> : <span class="keyword">public</span> binary_function&lt;T,T,T&gt; &#123;</span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">modulus</span> : <span class="keyword">public</span> binary_function&lt;T,T,T&gt; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x % y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">negate</span> : <span class="keyword">public</span> unary_function&lt;T,T&gt; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> -x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>测试程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 产生仿函数实体</span></span><br><span class="line">    plus&lt;<span class="type">int</span>&gt; plusobj;</span><br><span class="line">    minus&lt;<span class="type">int</span>&gt; minusobj;</span><br><span class="line">    multiplies&lt;<span class="type">int</span>&gt; multipliesobj;</span><br><span class="line">    divides&lt;<span class="type">int</span>&gt; dividesobj;</span><br><span class="line">    modulus&lt;<span class="type">int</span>&gt; modulusobj;</span><br><span class="line">    negate&lt;<span class="type">int</span>&gt; negateobj;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用对象完成函数功能</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">plusobj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl; 		 <span class="comment">//8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">minusobj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;		 <span class="comment">//-2</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">multipliesobj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">//15</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dividesobj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;    <span class="comment">//0</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">modulusobj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;    <span class="comment">//3</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">negateobj</span>(<span class="number">3</span>) &lt;&lt; endl;		 <span class="comment">//-3</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 直接使用仿函数的临时对象完成函数功能</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">multiplies</span>&lt;<span class="type">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">divides</span>&lt;<span class="type">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">modulus</span>&lt;<span class="type">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">negate</span>&lt;<span class="type">int</span>&gt;()(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不会这么单纯的使用仿函数，主要用途是搭配STL算法，以下式子表示要以1为基本元素，对vector iv中的每个元素进行乘法操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">1</span>, <span class="built_in">multiplies</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure></p>
<h3 id="证同元素-identity-element"><a href="#证同元素-identity-element" class="headerlink" title="证同元素(identity element)"></a>证同元素(identity element)</h3><p>所谓“运算op的证同元素(identity element)”，意思是数值A若与该元素做op运算会得到A自己。加法的证同元素为0，因为任何元素加上0仍为自己。乘法的证同元素为1,因为任何元素乘以1仍为自己。</p>
<p>请注意，这些函数并非STL标准规格中的一员。但许多STL实现都有它们：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">identity_element</span><span class="params">(plus&lt;T&gt;)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">T</span>(<span class="number">0</span>);&#125; <span class="comment">//SGI STL并未实际运用这个函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">identity_element</span><span class="params">(muitiplies&lt;T&gt;)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">T</span>(<span class="number">1</span>);&#125; </span><br></pre></td></tr></table></figure></p>
<h2 id="关系运算类仿函数"><a href="#关系运算类仿函数" class="headerlink" title="关系运算类仿函数"></a>关系运算类仿函数</h2><p>STL内建关系类仿函数：等于：<code>equal_to&lt;T&gt;</code>，不等于：<code>not_equal_to&lt;T&gt;</code>，大于：<code>greater&lt;T&gt;</code>，大于等于：<code>greater_equal&lt;T&gt;</code>，小于：<code>less&lt;T&gt;</code>，小于等于：<code>less_equal&lt;T&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">equal_to</span> : <span class="keyword">public</span> binary_function&lt;T,T,<span class="type">bool</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x == y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">not_equal_to</span> : <span class="keyword">public</span> binary_function&lt;T,T,<span class="type">bool</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x != y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greater</span> : <span class="keyword">public</span> binary_function&lt;T,T,<span class="type">bool</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> : <span class="keyword">public</span> binary_function&lt;T,T,<span class="type">bool</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &lt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greater_equal</span> : <span class="keyword">public</span> binary_function&lt;T,T,<span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &gt;= y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less_equal</span> : <span class="keyword">public</span> binary_function&lt;T,T,<span class="type">bool</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &lt;= y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 产生仿函数实体</span></span><br><span class="line">    equal_to&lt;<span class="type">int</span>&gt; equal_to_obj;</span><br><span class="line">    not_equal_to&lt;<span class="type">int</span>&gt; not_equal_to_obj;</span><br><span class="line">    greater&lt;<span class="type">int</span>&gt; greater_obj;</span><br><span class="line">    greater_equal&lt;<span class="type">int</span>&gt; greater_equal_obj;</span><br><span class="line">    less&lt;<span class="type">int</span>&gt; less_obj;</span><br><span class="line">    less_equal&lt;<span class="type">int</span>&gt; less_equal_obj;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用对象完成函数功能</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">equal_to_obj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;			<span class="comment">//0</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">not_equal_to_obj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;		<span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">greater_obj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;			<span class="comment">//0</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">greater_equal_obj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;	<span class="comment">//0</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">less_obj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;				<span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">less_equal_obj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;		<span class="comment">//1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 直接使用仿函数的临时对象完成函数功能</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">equal_to</span>&lt;<span class="type">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">not_equal_to</span>&lt;<span class="type">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">greater_equal</span>&lt;<span class="type">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不会这么单纯的使用仿函数，主要用途是搭配STL算法，以下式子表示要以递增次序对vector iv排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure></p>
<h2 id="逻辑运算类仿函数"><a href="#逻辑运算类仿函数" class="headerlink" title="逻辑运算类仿函数"></a>逻辑运算类仿函数</h2><p>STL内建逻辑类仿函数：逻辑运算And：<code>logical_and&lt;T&gt;</code>，逻辑运算Or：<code>logical_or&lt;T&gt;</code>，逻辑运算Not：<code>logical_not&lt;T&gt;</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">logical_and</span> : <span class="keyword">public</span> binary_function&lt;T,T,<span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &amp;&amp; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">logical_or</span> : <span class="keyword">public</span> binary_function&lt;T,T,<span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x || y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">logical_not</span> : <span class="keyword">public</span> unary_function&lt;T,<span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> !x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>测试程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 产生仿函数实体</span></span><br><span class="line">    logical_and&lt;<span class="type">int</span>&gt; and_obj;</span><br><span class="line">    logical_or&lt;<span class="type">int</span>&gt; or_obj;</span><br><span class="line">    logical_not&lt;<span class="type">int</span>&gt; not_obj;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用对象完成函数功能</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">and_obj</span>(<span class="literal">true</span>, <span class="literal">true</span>) &lt;&lt; endl;	<span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">or_obj</span>(<span class="literal">true</span>, <span class="literal">false</span>) &lt;&lt; endl;	<span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">not_obj</span>(<span class="literal">true</span>) &lt;&lt; endl;			<span class="comment">//0</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 直接使用仿函数的临时对象完成函数功能</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">logical_and</span>&lt;<span class="type">int</span>&gt;()(<span class="literal">true</span>, <span class="literal">true</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">logical_or</span>&lt;<span class="type">int</span>&gt;()(<span class="literal">true</span>, <span class="literal">false</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">logical_not</span>&lt;<span class="type">int</span>&gt;()(<span class="literal">true</span>) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不会这么单纯的使用仿函数，主要用途是搭配STL算法。</p>
<h2 id="证同、选择、投射"><a href="#证同、选择、投射" class="headerlink" title="证同、选择、投射"></a>证同、选择、投射</h2><p>以下介绍的仿函数，都只是将其参数原封不动地传回。其中某些仿函数对传回的参数有刻意的选择，或者刻意的忽略。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 证同函数，任何函数经过后不会改变，用于set rb_tree keyOfValue op</span></span><br><span class="line"><span class="comment">// identity is an extensions: it is not part of the standard.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Identity</span> : <span class="keyword">public</span> unary_function&lt;_Tp,_Tp&gt; &#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> _Tp&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> _Tp&amp; __x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt; <span class="keyword">struct</span> <span class="title class_">identity</span> : <span class="keyword">public</span> _Identity&lt;_Tp&gt; &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 选择函数，返回pair第一元素，用于map rb_tree keyOfValue op</span></span><br><span class="line"><span class="comment">// select1st and select2nd are extensions: they are not part of the standard.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Pair</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Select1st</span> : <span class="keyword">public</span> unary_function&lt;_Pair, <span class="keyword">typename</span> _Pair::first_type&gt; &#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="keyword">typename</span> _Pair::first_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> _Pair&amp; __x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __x.first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 选择函数，返回pair第二元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Pair</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Select2nd</span> : <span class="keyword">public</span> unary_function&lt;_Pair, <span class="keyword">typename</span> _Pair::second_type&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="keyword">typename</span> _Pair::second_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> _Pair&amp; __x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __x.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Pair</span>&gt; <span class="keyword">struct</span> <span class="title class_">select1st</span> : <span class="keyword">public</span> _Select1st&lt;_Pair&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Pair</span>&gt; <span class="keyword">struct</span> <span class="title class_">select2nd</span> : <span class="keyword">public</span> _Select2nd&lt;_Pair&gt; &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 传回一个忽略另一个</span></span><br><span class="line"><span class="comment">// project1st and project2nd are extensions: they are not part of the standard</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Arg1</span>, <span class="keyword">class</span> <span class="title class_">_Arg2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Project1st</span> : <span class="keyword">public</span> binary_function&lt;_Arg1, _Arg2, _Arg1&gt; &#123;</span><br><span class="line">  <span class="function">_Arg1 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> _Arg1&amp; __x, <span class="type">const</span> _Arg2&amp;)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Arg1</span>, <span class="keyword">class</span> <span class="title class_">_Arg2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Project2nd</span> : <span class="keyword">public</span> binary_function&lt;_Arg1, _Arg2, _Arg2&gt; &#123;</span><br><span class="line">  <span class="function">_Arg2 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> _Arg1&amp;, <span class="type">const</span> _Arg2&amp; __y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Arg1</span>, <span class="keyword">class</span> <span class="title class_">_Arg2</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">project1st</span> : <span class="keyword">public</span> _Project1st&lt;_Arg1, _Arg2&gt; &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Arg1</span>, <span class="keyword">class</span> <span class="title class_">_Arg2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">project2nd</span> : <span class="keyword">public</span> _Project2nd&lt;_Arg1, _Arg2&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h1><p>配接器（adapters）在 STL 组件的灵活组合运用功能上，扮演着轴承、转换器的角色。Adapter 这个概念，事实上是一种设计模式。《Design Patterns》一书提到 23 个最普及的设计模式，其中对 adapter 样式的定义如下：将一个 class 的接口转换为另一个 class 的接口，使原本因接口不兼容而不能合作的 classes，可以一起运作。</p>
<h2 id="配接器之概观与分类"><a href="#配接器之概观与分类" class="headerlink" title="配接器之概观与分类"></a>配接器之概观与分类</h2><p>STL 所提供的各种配接器中，改变容器（containers）接口者，我们称为 container adapter，改变迭代器（iterators）接口者，我们称之为 iterator adapter，改变仿函数（functors）接口者，我们称为 function adapter。</p>
<h3 id="容器配接器"><a href="#容器配接器" class="headerlink" title="容器配接器"></a>容器配接器</h3><p>STL 提供的两个容器 queue 和 stack，其实都只不过是一种配接器，底层由deque构成。stack和queue是两个容器配接器，底层默认由deque构成。stack封住了所有的deque对外接口，只开放符合stack原则的几个函数；queue封住了所有的deque对外接口，只开放符合queue原则的几个函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> ,<span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence  c ; <span class="comment">//底层容器</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> ,<span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence  c ; <span class="comment">//底层容器</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="迭代器配接器"><a href="#迭代器配接器" class="headerlink" title="迭代器配接器"></a>迭代器配接器</h3><p>STL 提供了许多应用于迭代器身上的配接器，包括 insert iterators，reverse iterators，iostream iterators。</p>
<h4 id="insert-iterators"><a href="#insert-iterators" class="headerlink" title="insert iterators"></a>insert iterators</h4><p><code>insert iterators</code>包括尾端插入的<code>back_insert_iterator</code>，头端插入的<code>front_insert_iterator</code>和可任意位置插入的<code>insert_iterator</code>。主要观念是，每个insert iterators内部都维护有一个容器；容器有自己的迭代器，当客户端对insert iterators做赋值操作时，就在insert iterators中转为对该容器的迭代器做插入操作，其他的迭代器功能则被关闭（例如operator++、operator—、operator*）。<br><img src="/img/1610763366.jpg" alt=""></p>
<p>迭代器源码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器配接器，用来将迭代器的赋值操作替换为插入操作</span></span><br><span class="line"><span class="comment">// 从容器尾端插入</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">back_insert_iterator</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Container* container; <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Container          container_type;</span><br><span class="line">  <span class="keyword">typedef</span> output_iterator_tag iterator_category; <span class="comment">// 注意类型，只写</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                reference;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 与容器绑定起来</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">back_insert_iterator</span><span class="params">(_Container&amp; __x)</span> : container(&amp;__x) &#123;</span>&#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp;</span><br><span class="line">  <span class="keyword">operator</span>=(<span class="type">const</span> <span class="keyword">typename</span> _Container::value_type&amp; __value) &#123; </span><br><span class="line">    container-&gt;<span class="built_in">push_back</span>(__value); <span class="comment">// 这里是替换成插入操作</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以下不起作用，关闭功能</span></span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Container</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> output_iterator_tag</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> back_insert_iterator&lt;_Container&gt;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">output_iterator_tag</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Container</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> back_insert_iterator&lt;_Container&gt; <span class="title">back_inserter</span><span class="params">(_Container&amp; __x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">back_insert_iterator</span>&lt;_Container&gt;(__x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 迭代器配接器，用来将迭代器的赋值操作替换为插入操作</span></span><br><span class="line"><span class="comment">// 从容器头端插入</span></span><br><span class="line"><span class="comment">// 不适用于vector，因为vector没有push_front</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">front_insert_iterator</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Container* container;  <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Container          container_type;</span><br><span class="line">  <span class="keyword">typedef</span> output_iterator_tag iterator_category; <span class="comment">// 注意类型，只写</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                reference;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">front_insert_iterator</span><span class="params">(_Container&amp; __x)</span> : container(&amp;__x) &#123;</span>&#125;</span><br><span class="line">  front_insert_iterator&lt;_Container&gt;&amp;</span><br><span class="line">  <span class="keyword">operator</span>=(<span class="type">const</span> <span class="keyword">typename</span> _Container::value_type&amp; __value) &#123; </span><br><span class="line">    container-&gt;<span class="built_in">push_front</span>(__value); <span class="comment">// 替换成插入操作</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关闭以下功能</span></span><br><span class="line">  front_insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  front_insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  front_insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Container</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> output_iterator_tag</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> front_insert_iterator&lt;_Container&gt;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">output_iterator_tag</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Container</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> front_insert_iterator&lt;_Container&gt; <span class="title">front_inserter</span><span class="params">(_Container&amp; __x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">front_insert_iterator</span>&lt;_Container&gt;(__x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 迭代器配接器，用来将迭代器的赋值操作替换为插入操作</span></span><br><span class="line"><span class="comment">// 从容器随机插入</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">insert_iterator</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Container* container;  <span class="comment">// 底层容器</span></span><br><span class="line">  <span class="keyword">typename</span> _Container::iterator iter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Container          container_type;</span><br><span class="line">  <span class="keyword">typedef</span> output_iterator_tag iterator_category; <span class="comment">// 类型只写</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                reference;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">insert_iterator</span>(_Container&amp; __x, <span class="keyword">typename</span> _Container::iterator __i) </span><br><span class="line">    : <span class="built_in">container</span>(&amp;__x), <span class="built_in">iter</span>(__i) &#123;&#125;</span><br><span class="line">  insert_iterator&lt;_Container&gt;&amp;</span><br><span class="line">  <span class="keyword">operator</span>=(<span class="type">const</span> <span class="keyword">typename</span> _Container::value_type&amp; __value) &#123; </span><br><span class="line">    iter = container-&gt;<span class="built_in">insert</span>(iter, __value); <span class="comment">// 调用insert</span></span><br><span class="line">    ++iter; <span class="comment">// 使insert iterator永远随其目标贴身移动</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关闭功能</span></span><br><span class="line">  insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Container</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> output_iterator_tag</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> insert_iterator&lt;_Container&gt;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">output_iterator_tag</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Container</span>, <span class="keyword">class</span> <span class="title class_">_Iterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> </span></span><br><span class="line"><span class="function">insert_iterator&lt;_Container&gt; <span class="title">inserter</span><span class="params">(_Container&amp; __x, _Iterator __i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Container::iterator __iter;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">insert_iterator</span>&lt;_Container&gt;(__x, __iter(__i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="reverse-iterators"><a href="#reverse-iterators" class="headerlink" title="reverse iterators"></a>reverse iterators</h4><p>reverse iterators将迭代器的移动行为倒转。 当迭代器被逆转，虽然实体位置不变，但逻辑位置必须改变，主要是为了配合迭代器区间的“前闭后开“习惯。</p>
<p>源码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Iterator</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">reverse_iterator</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Iterator current;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_Iterator&gt;::iterator_category</span><br><span class="line">          iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_Iterator&gt;::value_type</span><br><span class="line">          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_Iterator&gt;::difference_type</span><br><span class="line">          difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_Iterator&gt;::pointer</span><br><span class="line">          pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_Iterator&gt;::reference</span><br><span class="line">          reference;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">typedef</span> _Iterator iterator_type;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_Iterator&gt; _Self;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">reverse_iterator</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">reverse_iterator</span><span class="params">(iterator_type __x)</span> : current(__x) &#123;</span>&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">reverse_iterator</span>(<span class="type">const</span> _Self&amp; __x) : <span class="built_in">current</span>(__x.current) &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Iter</span>&gt;</span><br><span class="line">  <span class="built_in">reverse_iterator</span>(<span class="type">const</span> reverse_iterator&lt;_Iter&gt;&amp; __x)</span><br><span class="line">    : <span class="built_in">current</span>(__x.<span class="built_in">base</span>()) &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">    </span><br><span class="line">  <span class="function">iterator_type <span class="title">base</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> current; &#125;</span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">    _Iterator __tmp = current;</span><br><span class="line">    <span class="keyword">return</span> *--__tmp;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"> </span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    --current;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --current;</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    ++current;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++current;</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  _Self <span class="keyword">operator</span>+(difference_type __n) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _Self(current - __n);</span><br><span class="line">  &#125;</span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>+=(difference_type __n) &#123;</span><br><span class="line">    current -= __n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>-(difference_type __n) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _Self(current + __n);</span><br><span class="line">  &#125;</span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>-=(difference_type __n) &#123;</span><br><span class="line">    current += __n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  reference <span class="keyword">operator</span>[](difference_type __n) <span class="type">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + __n); &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="stream-iterators"><a href="#stream-iterators" class="headerlink" title="stream iterators"></a>stream iterators</h4><p>stream iterators可以将迭代器绑定到某个stream对象身上。绑定一个istream object，其实就是在istream iterator内部维护一个istream member，客户端对这个迭代器做的operator++操作，会被导引调用内部所含的那个istream member的输入操作。绑定一个ostream object，就是在ostream iterator内部维护一个ostream member，客户端对这个迭代器做的operator=操作，会被导引调用内部所含的那个ostream member的输出操作。</p>
<p>源码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, </span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">_CharT</span> = <span class="type">char</span>, <span class="keyword">class</span> _Traits = char_traits&lt;_CharT&gt;,</span><br><span class="line">          <span class="keyword">class</span> _Dist = <span class="type">ptrdiff_t</span>&gt; </span><br><span class="line"><span class="keyword">class</span> istream_iterator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _CharT                         char_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Traits                        traits_type;</span><br><span class="line">  <span class="keyword">typedef</span> basic_istream&lt;_CharT, _Traits&gt; istream_type;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">typedef</span> input_iterator_tag             iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp                            value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Dist                          difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Tp*                     pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Tp&amp;                     reference;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">istream_iterator</span>() : _M_stream(<span class="number">0</span>), _M_ok(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">istream_iterator</span>(istream_type&amp; __s) : _M_stream(&amp;__s) &#123; _M_read(); &#125;</span><br><span class="line"> </span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> _M_value; &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"> </span><br><span class="line">  istream_iterator&amp; <span class="keyword">operator</span>++() &#123; </span><br><span class="line">    _M_read(); </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  istream_iterator <span class="keyword">operator</span>++(<span class="type">int</span>)  &#123;</span><br><span class="line">    istream_iterator __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_read();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">bool</span> _M_equal(<span class="type">const</span> istream_iterator&amp; __x) <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> (_M_ok == __x._M_ok) &amp;&amp; (!_M_ok || _M_stream == __x._M_stream); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  istream_type* _M_stream;</span><br><span class="line">  _Tp _M_value;</span><br><span class="line">  <span class="type">bool</span> _M_ok;</span><br><span class="line"> </span><br><span class="line">  <span class="type">void</span> _M_read() &#123;</span><br><span class="line">    _M_ok = (_M_stream &amp;&amp; *_M_stream) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (_M_ok) &#123;</span><br><span class="line">      *_M_stream &gt;&gt; _M_value;</span><br><span class="line">      _M_ok = *_M_stream ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">_CharT</span> = <span class="type">char</span>, <span class="keyword">class</span> _Traits = char_traits&lt;_CharT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> ostream_iterator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _CharT                         char_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Traits                        traits_type;</span><br><span class="line">  <span class="keyword">typedef</span> basic_ostream&lt;_CharT, _Traits&gt; ostream_type;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">typedef</span> output_iterator_tag            iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                           value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                           difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                           pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                           reference;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">ostream_iterator</span>(ostream_type&amp; __s) : _M_stream(&amp;__s), _M_string(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">ostream_iterator</span>(ostream_type&amp; __s, <span class="type">const</span> _CharT* __c) </span><br><span class="line">    : _M_stream(&amp;__s), _M_string(__c)  &#123;&#125;</span><br><span class="line">  ostream_iterator&lt;_Tp&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> _Tp&amp; __value) &#123; </span><br><span class="line">    *_M_stream &lt;&lt; __value;</span><br><span class="line">    <span class="keyword">if</span> (_M_string) *_M_stream &lt;&lt; _M_string;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ostream_iterator&lt;_Tp&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  ostream_iterator&lt;_Tp&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125; </span><br><span class="line">  ostream_iterator&lt;_Tp&gt;&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ostream_type* _M_stream;</span><br><span class="line">  <span class="type">const</span> _CharT* _M_string;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span> <span class="comment">// for iterator adapters</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// for copy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将outite绑定到cout，每次对outite指派一个元素，就后接一个“ ”</span></span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">outite</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">id</span><span class="params">(ia, ia + <span class="number">6</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将所有元素拷贝到outite，即cout</span></span><br><span class="line">    <span class="built_in">copy</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), outite);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将ia[]的部分元素拷贝到id内，使用front_insert_iterator</span></span><br><span class="line">    <span class="comment">// front_insert_iterator会将assign操作给push_front操作</span></span><br><span class="line">    <span class="comment">// vector不支持push_front操作，所以不以vector做示范对象</span></span><br><span class="line">    <span class="built_in">copy</span>(ia + <span class="number">1</span>, ia + <span class="number">2</span>, <span class="built_in">front_inserter</span>(id));</span><br><span class="line">    <span class="built_in">copy</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), outite);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将ia[]的部分元素拷贝到id内，使用back_insert_iterator</span></span><br><span class="line">    <span class="built_in">copy</span>(ia + <span class="number">1</span>, ia + <span class="number">2</span>, <span class="built_in">back_inserter</span>(id));</span><br><span class="line">    <span class="built_in">copy</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), outite);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 搜寻元素5所在位置</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;::iterator ite = <span class="built_in">find</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 将ia[]的部分元素拷贝到id内，使用insert_iterator</span></span><br><span class="line">    <span class="built_in">copy</span>(ia + <span class="number">1</span>, ia + <span class="number">2</span>, <span class="built_in">inserter</span>(id, ite));</span><br><span class="line">    <span class="built_in">copy</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), outite);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将所有元素逆向拷贝到outite</span></span><br><span class="line">    <span class="comment">// rbegin()和rend()与reverse_iterator有关</span></span><br><span class="line">    <span class="built_in">copy</span>(id.<span class="built_in">rbegin</span>(), id.<span class="built_in">rend</span>(), outite);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将inite绑定到cin，将元素拷贝到inite，知道eos出现</span></span><br><span class="line">    <span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">inite</span><span class="params">(cin)</span>, eos</span>; <span class="comment">// eos: end-of-stream</span></span><br><span class="line">    <span class="built_in">copy</span>(inite, eos, <span class="built_in">inserter</span>(id, id.<span class="built_in">begin</span>()));</span><br><span class="line">    <span class="comment">// 输入数字，停止时可以输入任意字符</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">copy</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), outite);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@192 8_STL_adapter]# ./8_1_2_iterator-adapter</span><br><span class="line">0 1 2 3 4 5</span><br><span class="line">1 0 1 2 3 4 5</span><br><span class="line">1 0 1 2 3 4 5 1</span><br><span class="line">1 0 1 2 3 4 1 5 1</span><br><span class="line">1 5 1 4 3 2 1 0 1</span><br><span class="line">1 2 3 e // 输入数字，停止时可以输入任意字符</span><br><span class="line">1 2 3 1 0 1 2 3 4 1 5 1 </span><br></pre></td></tr></table></figure></p>
<h4 id="function-adapter"><a href="#function-adapter" class="headerlink" title="function adapter"></a>function adapter</h4><p>仿函数配接操作包括绑定(bind)、否定(negate)、组合(compose)、以及对一般函数或成员函数的修饰。仿函数配接器的价值在于，通过它们之间的绑定、组合、修饰能力，几乎可以创造出各种可能的表达式，配合STL算法。例如，我们可能希望找出某个序列中所有不小于12的元素个数。虽然“不小于” 就是“大于或等于”，我们因此可以选择STL内建的仿函数<code>greater_equal</code>。但如果希望完全遵循题目语意（在某些更复杂的情况下，这可能是必要的），坚持找出“不小于”12的元素个数，可以这么做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">12</span>))</span><br></pre></td></tr></table></figure><br>这个式子将<code>less&lt;int&gt;()</code>的第二参数系结（绑定）为12，再加上否定操作，便形成了“不小于12”的语意，整个凑和成为一个表达式（expression），可与任何 “可接受表达式为参数”之算法搭配。</p>
<p>再举一个例子，假设我们希望对序列中的每一个元素都做某个特殊运算，这个运算的数学表达式为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="built_in">g</span>(elem)) </span><br></pre></td></tr></table></figure><br>其中f和g都是数学函数，那么可以这么写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">compose</span>(<span class="built_in">f</span>(x), <span class="built_in">g</span>(y));</span><br></pre></td></tr></table></figure><br>例如我们希望将容器内的每一个元素v进行<code>(v+2)*3</code>的操作，我们可以令<code>f(x)=x*3, g(y)=y+2</code>，并写下这样的式子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">compose1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">multiplies</span>&lt;<span class="type">int</span>&gt;(), <span class="number">3</span>), <span class="built_in">bind2nd</span>(<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;(), <span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>由于仿函数就是“将function call操作符重载”的一种class，而任何算法接受一个仿函数时，总是在其演算过程中调用该仿函数的operator()，这使得不具备仿函数之形、却有真函数之实的飞一般函数”和“成员函数（member functions）”感到为难。STL又提供了为数众多的配接器，使“一般函数”和“成员函数”得以无缝隙地与其它配接器或算法结合起。</p>
<p>请注意，所有期望获得配接能力的组件，本身都必须是可配接的。换句话说，一元仿函数必须继承自unary_function，二元仿函数必须继承自binary_function，成员函数必须以mem_fun处理过，一般函数必须以ptr_fun处理过。<br><img src="/img/1610775737.jpg" alt=""></p>
<p><img src="/img/1610775889.jpg" alt=""></p>
<p><img src="/img/1610775917.jpg" alt=""></p>
<p>每一个仿函数配接器内藏了一个member object，其型别等同于它所要配接的对象。</p>
<p>使用场景：</p>
<ul>
<li>对返回值进行逻辑否定：not1，not2</li>
<li>对参数进行绑定：bind1st，bind2nd</li>
<li>用于函数合成：compose1，compose2</li>
<li>用于函数指针：ptr_fun</li>
<li>用于成员函数指针：mem_fun，mem_fun_ref</li>
</ul>
<p>count_if的实例测试程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// compose1在mingw中没有，所以把定义搬了过来</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Operation1</span>, <span class="keyword">class</span> <span class="title class_">_Operation2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unary_compose</span></span><br><span class="line">  : <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> _Operation2::argument_type,</span><br><span class="line">                          <span class="keyword">typename</span> _Operation1::result_type&gt; </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Operation1 _M_fn1;</span><br><span class="line">  _Operation2 _M_fn2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">unary_compose</span>(<span class="type">const</span> _Operation1&amp; __x, <span class="type">const</span> _Operation2&amp; __y) </span><br><span class="line">    : _M_fn1(__x), _M_fn2(__y) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">typename</span> _Operation1::result_type</span></span><br><span class="line"><span class="function">  <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> _Operation2::argument_type&amp; __x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_fn1(_M_fn2(__x));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Operation1</span>, <span class="keyword">class</span> <span class="title class_">_Operation2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> unary_compose&lt;_Operation1,_Operation2&gt; </span></span><br><span class="line"><span class="function"><span class="title">compose1</span><span class="params">(<span class="type">const</span> _Operation1&amp; __fn1, <span class="type">const</span> _Operation2&amp; __fn2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unary_compose</span>&lt;_Operation1,_Operation2&gt;(__fn1, __fn2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Int</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// explicit 只能修改只有一个参数的类构造函数，</span></span><br><span class="line">    <span class="comment">// 或是除了第一个参数外其他参数都有默认值的情况</span></span><br><span class="line">    <span class="comment">// 表明该构造函数是显示的而非隐式的</span></span><br><span class="line">    <span class="comment">// 作用是禁止类构造函数的隐式自动转换</span></span><br><span class="line">    <span class="comment">// implicit 表示隐式，类构造函数默认声明为隐式</span></span><br><span class="line">    <span class="comment">// google c++规范与effective c++都推荐使用explicit声明</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Int</span><span class="params">(<span class="type">int</span> i)</span> : m_i(i) &#123;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; m_i &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将outite绑定到cout，每次对outite指派一个元素，就后接一个“ ”</span></span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">outite</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">2</span>, <span class="number">21</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">23</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="number">6</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 找出不小于12的元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">count_if</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(),</span><br><span class="line">                     <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">12</span>)));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 令每个元素v执行(v+2)*3然后输往outite</span></span><br><span class="line">    <span class="built_in">transform</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), outite,</span><br><span class="line">              <span class="built_in">compose1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">multiplies</span>&lt;<span class="type">int</span>&gt;(), <span class="number">3</span>),</span><br><span class="line">                       <span class="built_in">bind2nd</span>(<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;(), <span class="number">2</span>)));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将所有元素拷贝到outite</span></span><br><span class="line">    <span class="built_in">copy</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), outite);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 1. 使用函数指针搭配stl算法</span></span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2. 以修饰过的一般函数搭配stl算法</span></span><br><span class="line">    for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">ptr_fun</span>(print));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Int <span class="title">t1</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">t2</span><span class="params">(<span class="number">7</span>)</span>, <span class="title">t3</span><span class="params">(<span class="number">20</span>)</span>, <span class="title">t4</span><span class="params">(<span class="number">14</span>)</span>, <span class="title">t5</span><span class="params">(<span class="number">68</span>)</span></span>;</span><br><span class="line">    vector&lt;Int&gt; Iv;</span><br><span class="line">    Iv.<span class="built_in">push_back</span>(t1);</span><br><span class="line">    Iv.<span class="built_in">push_back</span>(t2);</span><br><span class="line">    Iv.<span class="built_in">push_back</span>(t3);</span><br><span class="line">    Iv.<span class="built_in">push_back</span>(t4);</span><br><span class="line">    Iv.<span class="built_in">push_back</span>(t5);</span><br><span class="line">    <span class="comment">// 3. 以修饰过的成员函数搭配stl算法</span></span><br><span class="line">    for_each(Iv.<span class="built_in">begin</span>(), Iv.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Int::print1));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@192 8_STL_adapter]# ./8_1_3_functor-adapter</span><br><span class="line">4</span><br><span class="line">12 69 42 27 63 75</span><br><span class="line">2 21 12 7 19 23</span><br><span class="line">2 21 12 7 19 23</span><br><span class="line">2 21 12 7 19 23</span><br><span class="line">[3][7][20][14][68][</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/16/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2cpp%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/" rel="prev" title="深度探索C++对象模型 笔记">
      <i class="fa fa-chevron-left"></i> 深度探索C++对象模型 笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_%E9%87%8F%E5%8C%96%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95%20%E7%AC%94%E8%AE%B01/" rel="next" title="计算机体系结构 量化研究方法 笔记1">
      计算机体系结构 量化研究方法 笔记1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9ASTL%E6%A6%82%E8%AE%BA%E5%92%8C%E7%89%88%E6%9C%AC%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">第一章：STL概论和版本简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="nav-number">1.1.</span> <span class="nav-text">STL六大组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.1.</span> <span class="nav-text">各组件间的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SGI-STL%E5%A4%B4%E6%96%87%E4%BB%B6%E5%88%86%E5%B8%83"><span class="nav-number">1.2.</span> <span class="nav-text">SGI STL头文件分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E5%9B%B0%E6%83%91%E7%9A%84C-%E8%AF%AD%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">可能困惑的C++语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stl-config-h%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E7%BB%84%E6%80%81%EF%BC%88configuration%EF%BC%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">stl_config.h中的各种组态（configuration）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%A7%E7%94%9F%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">1.3.2.</span> <span class="nav-text">临时对象的产生与应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E6%95%B4%E6%95%B0%E6%88%90%E5%91%98%E5%9C%A8class%E5%86%85%E9%83%A8%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.3.</span> <span class="nav-text">静态常量整数成员在class内部直接初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#increment-decrement-dereference%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">1.3.4.</span> <span class="nav-text">increment&#x2F;decrement&#x2F;dereference操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E9%97%AD%E5%90%8E%E5%BC%80%E5%8C%BA%E9%97%B4%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">1.3.5.</span> <span class="nav-text">前闭后开区间表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#function-call-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">1.3.6.</span> <span class="nav-text">function call 操作符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">空间配置器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.</span> <span class="nav-text">空间配置器的标准接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8-JJ-allocator"><span class="nav-number">2.1.1.</span> <span class="nav-text">设计一个简单的空间配置器, JJ::allocator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E5%A4%87%E6%AC%A1%E9%85%8D%E7%BD%AE%E5%8A%9B%E7%9A%84-SGI-%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">具备次配置力的 SGI 空间配置器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SGI%E6%A0%87%E5%87%86%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8allocator"><span class="nav-number">2.2.1.</span> <span class="nav-text">SGI标准的空间配置器allocator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SGI%E7%89%B9%E6%AE%8A%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8std-alloc"><span class="nav-number">2.2.2.</span> <span class="nav-text">SGI特殊的空间配置器std::alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%90%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%EF%BC%9Aconstruct-%E5%92%8Cdestroy"><span class="nav-number">2.2.3.</span> <span class="nav-text">构造函数析构的基本工具：construct()和destroy()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E9%87%8A%E6%94%BE%EF%BC%8Cstd-alloc"><span class="nav-number">2.2.4.</span> <span class="nav-text">空间的配置和释放，std::alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8-malloc-alloc-template%E5%89%96%E6%9E%90"><span class="nav-number">2.2.5.</span> <span class="nav-text">第一级配置器__malloc_alloc_template剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8-default-alloc-template%E5%89%96%E6%9E%90"><span class="nav-number">2.2.6.</span> <span class="nav-text">第二级配置器__default_alloc_template剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%87%BD%E6%95%B0allocate"><span class="nav-number">2.2.7.</span> <span class="nav-text">空间配置函数allocate()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%87%8A%E6%94%BE%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.8.</span> <span class="nav-text">空间释放函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BAfree-list%E5%A1%AB%E5%85%85%E7%A9%BA%E9%97%B4"><span class="nav-number">2.2.9.</span> <span class="nav-text">为free list填充空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="nav-number">2.2.10.</span> <span class="nav-text">内存池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deallocate"><span class="nav-number">2.2.11.</span> <span class="nav-text">deallocate()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-number">2.3.</span> <span class="nav-text">内存基本处理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#uninitialized-copy"><span class="nav-number">2.3.1.</span> <span class="nav-text">uninitialized_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uninitialized-fill"><span class="nav-number">2.3.2.</span> <span class="nav-text">uninitialized_fill</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uninitialized-fill-n"><span class="nav-number">2.3.3.</span> <span class="nav-text">uninitialized_fill_n</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#uninitialized-fill-n-1"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">uninitialized_fill_n()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#uninitialized-copy-1"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">uninitialized_copy()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#uninitialized-fill-n-2"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">uninitialized_fill_n()</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A6%82%E5%BF%B5%E4%B8%8Etraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">迭代器概念与traits编程技法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4%E2%80%94%E2%80%94STL%E5%85%B3%E9%94%AE%E6%89%80%E5%9C%A8"><span class="nav-number">3.1.</span> <span class="nav-text">迭代器设计思维——STL关键所在</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E4%B8%80%E7%A7%8Dsmart-pointer"><span class="nav-number">3.2.</span> <span class="nav-text">迭代器是一种smart pointer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E5%9E%8B%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">迭代器相应型别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95%E2%80%94%E2%80%94STL%E6%BA%90%E4%BB%A3%E7%A0%81%E9%97%A8%E9%92%A5"><span class="nav-number">3.4.</span> <span class="nav-text">Traits编程技法——STL源代码门钥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Partial-Specialization%EF%BC%88%E5%81%8F%E7%89%B9%E5%8C%96%EF%BC%89%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">3.4.1.</span> <span class="nav-text">Partial Specialization（偏特化）的意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E5%9E%8B%E5%88%AB%E4%B9%8B%E4%B8%80%EF%BC%9Avalue-type"><span class="nav-number">3.4.2.</span> <span class="nav-text">迭代器相应型别之一：value type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E5%9E%8B%E5%88%AB%E4%B9%8B%E4%BA%8C%EF%BC%9Adifference-type"><span class="nav-number">3.4.3.</span> <span class="nav-text">迭代器相应型别之二：difference type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E5%9E%8B%E5%88%AB%E4%B9%8B%E4%B8%89%EF%BC%9Areference-type"><span class="nav-number">3.4.4.</span> <span class="nav-text">迭代器相应型别之三：reference type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E5%9E%8B%E5%88%AB%E4%B9%8B%E5%9B%9B%EF%BC%9Apointer-type"><span class="nav-number">3.4.5.</span> <span class="nav-text">迭代器相应型别之四：pointer type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E5%9E%8B%E5%88%AB%E4%B9%8B%E4%BA%94%EF%BC%9Aiterator-category"><span class="nav-number">3.4.6.</span> <span class="nav-text">迭代器相应型别之五：iterator_category</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E9%99%A4%E2%80%9C%E5%8D%95%E7%BA%AF%E4%BC%A0%E9%80%92%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E2%80%9D"><span class="nav-number">3.4.6.1.</span> <span class="nav-text">消除“单纯传递调用的函数”</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-iterator%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="nav-number">3.5.</span> <span class="nav-text">std::iterator的保证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SGI-STL%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C%EF%BC%9A-type-traits"><span class="nav-number">3.6.</span> <span class="nav-text">SGI STL的私房菜：__type_traits</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">序列式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A6%82%E8%A7%82%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.</span> <span class="nav-text">容器的概观与分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector%E6%A6%82%E8%BF%B0"><span class="nav-number">4.2.</span> <span class="nav-text">vector概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.2.1.</span> <span class="nav-text">vector 的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.2.</span> <span class="nav-text">vector数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.2.3.</span> <span class="nav-text">vector构造与内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector%E7%9A%84%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">4.2.4.</span> <span class="nav-text">vector的元素操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list"><span class="nav-number">4.3.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list%E6%A6%82%E8%BF%B0"><span class="nav-number">4.4.</span> <span class="nav-text">list概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#list%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">4.4.1.</span> <span class="nav-text">list的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.4.2.</span> <span class="nav-text">list的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.4.3.</span> <span class="nav-text">list的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.4.4.</span> <span class="nav-text">list的构造与内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list%E7%9A%84%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">4.4.5.</span> <span class="nav-text">list的元素操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque"><span class="nav-number">4.5.</span> <span class="nav-text">deque</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#deque%E7%9A%84%E4%B8%AD%E6%8E%A7%E5%99%A8"><span class="nav-number">4.5.1.</span> <span class="nav-text">deque的中控器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.5.2.</span> <span class="nav-text">deque的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.5.3.</span> <span class="nav-text">deque的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.5.4.</span> <span class="nav-text">deque的构造与内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque%E7%9A%84%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">4.5.5.</span> <span class="nav-text">deque的元素操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stack"><span class="nav-number">4.6.</span> <span class="nav-text">stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stack%E6%A6%82%E8%BF%B0"><span class="nav-number">4.6.1.</span> <span class="nav-text">stack概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack-%E5%AE%8C%E6%95%B4%E5%AE%9A%E4%B9%89"><span class="nav-number">4.6.2.</span> <span class="nav-text">stack 完整定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5list%E4%BD%9C%E4%B8%BAstack%E7%9A%84%E5%BA%95%E9%83%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">4.6.3.</span> <span class="nav-text">以list作为stack的底部容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#queue"><span class="nav-number">4.7.</span> <span class="nav-text">queue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#queue%E6%A6%82%E8%BF%B0"><span class="nav-number">4.7.1.</span> <span class="nav-text">queue概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue-%E5%AE%8C%E6%95%B4%E5%AE%9A%E4%B9%89"><span class="nav-number">4.7.2.</span> <span class="nav-text">queue 完整定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5list%E4%BD%9C%E4%B8%BAqueue%E7%9A%84%E5%BA%95%E9%83%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">4.7.3.</span> <span class="nav-text">以list作为queue的底部容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#heap%E6%A6%82%E8%BF%B0"><span class="nav-number">4.8.</span> <span class="nav-text">heap概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#heap%E7%AE%97%E6%B3%95"><span class="nav-number">4.8.1.</span> <span class="nav-text">heap算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#push-heap%E7%AE%97%E6%B3%95"><span class="nav-number">4.8.1.1.</span> <span class="nav-text">push_heap算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pop-heap"><span class="nav-number">4.8.1.2.</span> <span class="nav-text">pop_heap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sort-heap"><span class="nav-number">4.8.1.3.</span> <span class="nav-text">sort_heap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#make-heap"><span class="nav-number">4.8.2.</span> <span class="nav-text">make_heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B"><span class="nav-number">4.8.3.</span> <span class="nav-text">heap测试实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#priority-queue%E6%A6%82%E8%BF%B0"><span class="nav-number">4.9.</span> <span class="nav-text">priority_queue概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-queue-%E5%AE%8C%E6%95%B4%E5%AE%9A%E4%B9%89"><span class="nav-number">4.9.1.</span> <span class="nav-text">priority_queue 完整定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-queue%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B"><span class="nav-number">4.9.2.</span> <span class="nav-text">priority_queue测试实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slist%E6%A6%82%E8%BF%B0"><span class="nav-number">4.10.</span> <span class="nav-text">slist概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#slist%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">4.10.1.</span> <span class="nav-text">slist的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slist%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.10.2.</span> <span class="nav-text">slist的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slist%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.10.3.</span> <span class="nav-text">slist的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slist%E7%9A%84%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B"><span class="nav-number">4.10.4.</span> <span class="nav-text">slist的测试实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insert"><span class="nav-number">4.10.5.</span> <span class="nav-text">insert</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">关联式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RB-tree%E6%A6%82%E8%BF%B0"><span class="nav-number">5.1.</span> <span class="nav-text">RB-tree概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RB-tree%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.1.1.</span> <span class="nav-text">RB-tree节点设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RB-tree%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">5.1.2.</span> <span class="nav-text">RB-tree的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RB-tree%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.3.</span> <span class="nav-text">RB-tree数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RB-tree%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.1.4.</span> <span class="nav-text">RB-tree的构造与内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RB-tree%E7%9A%84%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.5.</span> <span class="nav-text">RB-tree的元素操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set"><span class="nav-number">5.2.</span> <span class="nav-text">set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#multiset"><span class="nav-number">5.2.1.</span> <span class="nav-text">multiset</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map%E6%A6%82%E8%BF%B0"><span class="nav-number">5.3.</span> <span class="nav-text">map概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.3.1.</span> <span class="nav-text">map测试程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashtable"><span class="nav-number">5.4.</span> <span class="nav-text">hashtable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hashtable%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.4.1.</span> <span class="nav-text">hashtable的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashtable%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.4.2.</span> <span class="nav-text">hashtable的构造与内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">5.4.3.</span> <span class="nav-text">删除元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash-set"><span class="nav-number">5.5.</span> <span class="nav-text">hash_set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash-map"><span class="nav-number">5.6.</span> <span class="nav-text">hash_map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash-multiset"><span class="nav-number">5.7.</span> <span class="nav-text">hash_multiset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash-multimap"><span class="nav-number">5.8.</span> <span class="nav-text">hash_multimap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%82"><span class="nav-number">6.1.</span> <span class="nav-text">算法概观</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#STL%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88"><span class="nav-number">6.1.1.</span> <span class="nav-text">STL算法总览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%B3%9B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">6.1.2.</span> <span class="nav-text">算法的泛化过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">数值算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#accumlate"><span class="nav-number">6.2.1.</span> <span class="nav-text">accumlate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#adjacent-differencee"><span class="nav-number">6.2.2.</span> <span class="nav-text">adjacent_differencee</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#partial-sum"><span class="nav-number">6.2.3.</span> <span class="nav-text">partial_sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#power"><span class="nav-number">6.2.4.</span> <span class="nav-text">power</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inner-product"><span class="nav-number">6.2.5.</span> <span class="nav-text">inner_product</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iota"><span class="nav-number">6.2.6.</span> <span class="nav-text">iota</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">基本算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#max"><span class="nav-number">6.3.1.</span> <span class="nav-text">max</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#min"><span class="nav-number">6.3.2.</span> <span class="nav-text">min</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mismatch"><span class="nav-number">6.3.3.</span> <span class="nav-text">mismatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swap"><span class="nav-number">6.3.4.</span> <span class="nav-text">swap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy"><span class="nav-number">6.3.5.</span> <span class="nav-text">copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy-backward"><span class="nav-number">6.3.6.</span> <span class="nav-text">copy_backward</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.</span> <span class="nav-text">set相关算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set-union"><span class="nav-number">6.4.1.</span> <span class="nav-text">set_union</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-intersection"><span class="nav-number">6.4.2.</span> <span class="nav-text">set_intersection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-difference"><span class="nav-number">6.4.3.</span> <span class="nav-text">set_difference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-symmetric-difference"><span class="nav-number">6.4.4.</span> <span class="nav-text">set_symmetric_difference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="nav-number">6.4.5.</span> <span class="nav-text">应用实例：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95"><span class="nav-number">6.5.</span> <span class="nav-text">其他算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%BA%AF%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="nav-number">6.5.1.</span> <span class="nav-text">单纯的数据处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#adjacent-find"><span class="nav-number">6.5.2.</span> <span class="nav-text">adjacent_find</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count"><span class="nav-number">6.5.3.</span> <span class="nav-text">count</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count-if"><span class="nav-number">6.5.4.</span> <span class="nav-text">count_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find"><span class="nav-number">6.5.5.</span> <span class="nav-text">find</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-if"><span class="nav-number">6.5.6.</span> <span class="nav-text">find_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-end"><span class="nav-number">6.5.7.</span> <span class="nav-text">find_end</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-first-of"><span class="nav-number">6.5.8.</span> <span class="nav-text">find_first of</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-each"><span class="nav-number">6.5.9.</span> <span class="nav-text">for_each</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#generate"><span class="nav-number">6.5.10.</span> <span class="nav-text">generate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#generate-n"><span class="nav-number">6.5.11.</span> <span class="nav-text">generate_n</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#includes"><span class="nav-number">6.5.12.</span> <span class="nav-text">includes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#max-element"><span class="nav-number">6.5.13.</span> <span class="nav-text">max_element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merge"><span class="nav-number">6.5.14.</span> <span class="nav-text">merge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#min-element"><span class="nav-number">6.5.15.</span> <span class="nav-text">min_element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#partition"><span class="nav-number">6.5.16.</span> <span class="nav-text">partition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove"><span class="nav-number">6.5.17.</span> <span class="nav-text">remove</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-copy"><span class="nav-number">6.5.18.</span> <span class="nav-text">remove_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-if"><span class="nav-number">6.5.19.</span> <span class="nav-text">remove_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-copy-if"><span class="nav-number">6.5.20.</span> <span class="nav-text">remove_copy_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replace"><span class="nav-number">6.5.21.</span> <span class="nav-text">replace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replace-copy"><span class="nav-number">6.5.22.</span> <span class="nav-text">replace_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replace-if"><span class="nav-number">6.5.23.</span> <span class="nav-text">replace_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replace-copy-if"><span class="nav-number">6.5.24.</span> <span class="nav-text">replace_copy_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reverse"><span class="nav-number">6.5.25.</span> <span class="nav-text">reverse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reverse-copy"><span class="nav-number">6.5.26.</span> <span class="nav-text">reverse_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rotate"><span class="nav-number">6.5.27.</span> <span class="nav-text">rotate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rotate-copy"><span class="nav-number">6.5.28.</span> <span class="nav-text">rotate_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search"><span class="nav-number">6.5.29.</span> <span class="nav-text">search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search-n"><span class="nav-number">6.5.30.</span> <span class="nav-text">search_n</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swap-range"><span class="nav-number">6.5.31.</span> <span class="nav-text">swap_range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transform"><span class="nav-number">6.5.32.</span> <span class="nav-text">transform</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique"><span class="nav-number">6.5.33.</span> <span class="nav-text">unique</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-copy"><span class="nav-number">6.5.34.</span> <span class="nav-text">unique_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lower-bound"><span class="nav-number">6.5.35.</span> <span class="nav-text">lower_bound</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#upper-bound"><span class="nav-number">6.5.36.</span> <span class="nav-text">upper_bound</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-search"><span class="nav-number">6.5.37.</span> <span class="nav-text">binary_search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#next-permutation-prev-permutation"><span class="nav-number">6.5.38.</span> <span class="nav-text">next_permutation&#x2F;prev_permutation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#random-shuffle"><span class="nav-number">6.5.39.</span> <span class="nav-text">random_shuffle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#partial-sort-partial-sort-copy"><span class="nav-number">6.5.40.</span> <span class="nav-text">partial_sort&#x2F;partial_sort_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort"><span class="nav-number">6.5.41.</span> <span class="nav-text">sort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InsertionSort"><span class="nav-number">6.5.41.1.</span> <span class="nav-text">InsertionSort</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quick-Sort"><span class="nav-number">6.5.42.</span> <span class="nav-text">Quick Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equal-range"><span class="nav-number">6.5.43.</span> <span class="nav-text">equal_range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inplace-merge"><span class="nav-number">6.5.44.</span> <span class="nav-text">inplace_merge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nth-element"><span class="nav-number">6.5.45.</span> <span class="nav-text">nth_element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merge-sort"><span class="nav-number">6.5.46.</span> <span class="nav-text">merge_sort</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">仿函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E6%A6%82%E8%BF%B0"><span class="nav-number">7.1.</span> <span class="nav-text">仿函数概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%85%8D%E6%8E%A5%E7%9A%84%E5%85%B3%E9%94%AE"><span class="nav-number">7.2.</span> <span class="nav-text">可配接的关键</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#unary-function"><span class="nav-number">7.2.1.</span> <span class="nav-text">unary_function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-function"><span class="nav-number">7.2.2.</span> <span class="nav-text">binary_function</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">7.3.</span> <span class="nav-text">算术类仿函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%81%E5%90%8C%E5%85%83%E7%B4%A0-identity-element"><span class="nav-number">7.3.1.</span> <span class="nav-text">证同元素(identity element)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">7.4.</span> <span class="nav-text">关系运算类仿函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">7.5.</span> <span class="nav-text">逻辑运算类仿函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%81%E5%90%8C%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8A%95%E5%B0%84"><span class="nav-number">7.6.</span> <span class="nav-text">证同、选择、投射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%85%8D%E6%8E%A5%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">配接器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E6%8E%A5%E5%99%A8%E4%B9%8B%E6%A6%82%E8%A7%82%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-number">8.1.</span> <span class="nav-text">配接器之概观与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%85%8D%E6%8E%A5%E5%99%A8"><span class="nav-number">8.1.1.</span> <span class="nav-text">容器配接器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%85%8D%E6%8E%A5%E5%99%A8"><span class="nav-number">8.1.2.</span> <span class="nav-text">迭代器配接器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#insert-iterators"><span class="nav-number">8.1.2.1.</span> <span class="nav-text">insert iterators</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reverse-iterators"><span class="nav-number">8.1.2.2.</span> <span class="nav-text">reverse iterators</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stream-iterators"><span class="nav-number">8.1.2.3.</span> <span class="nav-text">stream iterators</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="nav-number">8.1.2.4.</span> <span class="nav-text">测试程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#function-adapter"><span class="nav-number">8.1.2.5.</span> <span class="nav-text">function adapter</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
