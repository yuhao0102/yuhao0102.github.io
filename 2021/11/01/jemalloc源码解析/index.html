<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="jemalloc是一个通用的malloc(3)实现，着重于减少内存碎片和提高并发性能，在许多项目中都有用到，比如Rust和Redis。 背景知识内存的来源Linux提供了几个系统调用用于分配内存:  brk()：调整program break，改变data segment的大小。 mmap()：在进程的虚拟地址空间中创建新的内存映射。内存分配器一般使用该系统调用创建私有匿名映射分配内存，内核会以p">
<meta property="og:type" content="article">
<meta property="og:title" content="jemalloc源码解析">
<meta property="og:url" content="http://yoursite.com/2021/11/01/jemalloc%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="jemalloc是一个通用的malloc(3)实现，着重于减少内存碎片和提高并发性能，在许多项目中都有用到，比如Rust和Redis。 背景知识内存的来源Linux提供了几个系统调用用于分配内存:  brk()：调整program break，改变data segment的大小。 mmap()：在进程的虚拟地址空间中创建新的内存映射。内存分配器一般使用该系统调用创建私有匿名映射分配内存，内核会以p">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/20211102100900.png">
<meta property="og:image" content="http://yoursite.com/img/c2dv3kuw94.png">
<meta property="og:image" content="http://yoursite.com/img/20211102100901.png">
<meta property="og:image" content="http://yoursite.com/img/20211102100902.png">
<meta property="og:image" content="http://yoursite.com/img/20211102100903.png">
<meta property="og:image" content="http://yoursite.com/img/20211102100904.png">
<meta property="og:image" content="http://yoursite.com/img/v2-92f9c4741a626e4a48a9ca987d36b82c_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-4ce3efe4b89f927df4b4c0cfbd588558_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-07d44c859efbc6ac177b27793acb96e8_1440w.jpg">
<meta property="article:published_time" content="2021-11-01T15:57:00.000Z">
<meta property="article:modified_time" content="2022-12-26T07:40:51.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/20211102100900.png">

<link rel="canonical" href="http://yoursite.com/2021/11/01/jemalloc%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>jemalloc源码解析 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/01/jemalloc%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          jemalloc源码解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-01 23:57:00" itemprop="dateCreated datePublished" datetime="2021-11-01T23:57:00+08:00">2021-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 15:40:51" itemprop="dateModified" datetime="2022-12-26T15:40:51+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>jemalloc</code>是一个通用的<code>malloc(3)</code>实现，着重于减少内存碎片和提高并发性能，在许多项目中都有用到，比如<code>Rust</code>和<code>Redis</code>。</p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="内存的来源"><a href="#内存的来源" class="headerlink" title="内存的来源"></a>内存的来源</h2><p><code>Linux</code>提供了几个系统调用用于分配内存:</p>
<ul>
<li><code>brk()</code>：调整<code>program break</code>，改变<code>data segment</code>的大小。</li>
<li><code>mmap()</code>：在进程的虚拟地址空间中创建新的内存映射。内存分配器一般使用该系统调用创建私有匿名映射分配内存，内核会以<code>page size</code>大小倍数来分配，<code>page size</code>一般为 4096 字节。</li>
</ul>
<p>对应的释放内存也有几种方式:</p>
<ul>
<li><code>brk()</code>：既可以增大也可以缩小。</li>
<li><code>munmap()</code>：解除映射。</li>
<li><code>madvise()</code>：该系统调用会告诉操作系统这块内存之后会如何使用，由操作系统进行处理。释放时，会使用<code>MADV_DONTNEED</code>或 <code>MADV_FREE</code>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MADV_DONTNEED</span><br><span class="line">           Do not expect access in the near future.  (For the time being,</span><br><span class="line">           the application is finished with the given range, so the</span><br><span class="line">           kernel can free resources associated with it.)</span><br><span class="line"></span><br><span class="line">           After a successful MADV_DONTNEED operation, the semantics of</span><br><span class="line">           memory access in the specified region are changed: subsequent</span><br><span class="line">           accesses of pages in the range will succeed, but will result</span><br><span class="line">           in either repopulating the memory contents from the up-to-date</span><br><span class="line">           contents of the underlying mapped file (for shared file</span><br><span class="line">           mappings, shared anonymous mappings, and shmem-based</span><br><span class="line">           techniques such as System V shared memory segments) or zero-</span><br><span class="line">           fill-on-demand pages for anonymous private mappings.</span><br><span class="line"></span><br><span class="line">           Note that, when applied to shared mappings, MADV_DONTNEED</span><br><span class="line">           might not lead to immediate freeing of the pages in the range.</span><br><span class="line">           The kernel is free to delay freeing the pages until an</span><br><span class="line">           appropriate moment.  The resident set size (RSS) of the</span><br><span class="line">           calling process will be immediately reduced however.</span><br><span class="line"></span><br><span class="line">           MADV_DONTNEED cannot be applied to locked pages, Huge TLB</span><br><span class="line">           pages, or VM_PFNMAP pages.  (Pages marked with the kernel-</span><br><span class="line">           internal VM_PFNMAP flag are special memory areas that are not</span><br><span class="line">           managed by the virtual memory subsystem.  Such pages are</span><br><span class="line">           typically created by device drivers that map the pages into</span><br><span class="line">           user space.)</span><br></pre></td></tr></table></figure>
<p>可以看出来，对于私有匿名映射会立即释放，而在之后再次访问这块内存时，不需要重新分配。</p>
<h2 id="False-cache-line-sharing"><a href="#False-cache-line-sharing" class="headerlink" title="False cache line sharing"></a>False cache line sharing</h2><p>为了减少存储器访问延迟，<code>CPU</code>中会有本地<code>Cache</code>，<code>Cache</code>被划分为<code>cache line</code>，大小一般为<code>64B</code>。<code>CPU</code>访问内存时，会首先将内存缓存在<code>cache line</code>中。 在多处理器系统中，每个<code>CPU</code>都有自己的本地<code>Cache</code>，会导致数据多副本，也就带来了一致性问题：多个<code>CPU</code>的<code>cache line</code>中有相同地址的内存。需要实现<code>Cache Coherence Protocol</code>来解决这个问题。现代处理器一般使用<code>MESI</code>协议实现<code>Cache Coherence</code>，这会带来通讯耗时、总线压力、导致<code>cache line</code>的抖动，影响性能。</p>
<p>避免这个问题主要有下面几个方法：</p>
<ul>
<li><code>__declspec (align(64))</code>：变量起始地址按<code>cache line</code>对齐</li>
<li>当使用数组或结构体时，不仅需要起始地址对齐，还需要<code>padding</code>，使得数组元素或结构体大小为<code>cache line</code>倍数</li>
<li>避免多线程使用相近地址的内存，多使用局部变量</li>
</ul>
<h2 id="内存着色"><a href="#内存着色" class="headerlink" title="内存着色"></a>内存着色</h2><p>现代<code>CPU</code>的<code>Cache</code>映射策略有很多，如组相联、全相联、直接相联。不同地址的内存有可能映射到相同的<code>cache line</code>(主要发生在地址对齐的情况，如不同对象的地址按照<code>page size</code>对齐)，如果频繁交替访问映射到相同<code>cache line</code>的内存，就会造成<code>cache line</code>的颠簸。 内存着色通过给对象地址增加<code>cache line</code>大小倍数的偏移，从而映射到不同的<code>cache line</code>，来避免上面的问题。</p>
<h2 id="为什么需要内存分配器"><a href="#为什么需要内存分配器" class="headerlink" title="为什么需要内存分配器"></a>为什么需要内存分配器</h2><p>因为<code>mmap()</code>按照<code>page size</code>进行分配，一般是 4096 字节，若每次分配时都调用一次会造成极大的内存浪费，并且性能不好。若由程序员自己管理<code>page</code>，容易出错且性能不好，所以<code>glibc</code>中提供了标准<code>malloc(3)</code>供程序员使用。</p>
<h2 id="内存分配器的目标"><a href="#内存分配器的目标" class="headerlink" title="内存分配器的目标"></a>内存分配器的目标</h2><p>内存分配器的目标主要有2个：</p>
<ul>
<li>减少内存碎片，包括内部碎片和外部碎片:<ul>
<li>内部碎片：分配出去的但没有使用到的内存，比如需要 32 字节，分配了 40 字节，多余的 8 字节就是内部碎片。</li>
<li>外部碎片：大小不合适导致无法分配出去的内存，比如一直申请 16 字节的内存，但是内存分配器中保存着部分 8 字节的内存，一直分配不出去。</li>
</ul>
</li>
<li>提高性能:<ul>
<li>单线程性能</li>
<li>多线程性能</li>
</ul>
</li>
</ul>
<p><code>jemalloc</code>和<code>tcmalloc</code>都是对<code>glibc</code>中的优化，目的也是为了减少内存碎片和提高性能。</p>
<h1 id="常用内存分配器算法"><a href="#常用内存分配器算法" class="headerlink" title="常用内存分配器算法"></a>常用内存分配器算法</h1><h2 id="Dynamic-memory-allocation"><a href="#Dynamic-memory-allocation" class="headerlink" title="Dynamic memory allocation"></a>Dynamic memory allocation</h2><p>首先分配一整块内存，然后按需从这块内存中分配。一般会在分配出的内存前面保存<code>metadata</code>，还会维护<code>freelist</code>用于查找空闲内存。但这会导致比较严重的外部碎片:<br><img src="/img/20211102100900.png" alt=""></p>
<h2 id="Buddy-memory-allocation"><a href="#Buddy-memory-allocation" class="headerlink" title="Buddy memory allocation"></a>Buddy memory allocation</h2><p>以<code>Binary buddy algorithm</code>为例：同样从一块内存中分配，但此时不是按需分配大小，而是这块内存不断分成一半，直到到达目标大小或者下界。在释放的时候，会和之前分裂的且空闲的进行合并。 一般会用有序结构如红黑树，来存储不同大小的<code>buddy block</code>，这样分配和合并时可以快速查找合适的内存。</p>
<p>这种算法能够有效减少外部碎片，但内部碎片很严重，<code>Binary buddy algorithm</code>最严重会带来 50% 的内部碎片。</p>
<h2 id="Slab-allocation"><a href="#Slab-allocation" class="headerlink" title="Slab allocation"></a>Slab allocation</h2><p>对象的初始化和释放往往比内存的分配和释放代价大，基于此发明了<code>slab</code>。<code>slab</code>会提前分配一块内存，然后将这块连续内存划分为大小相同的<code>slots</code>，使用相应的数据结构记录每个<code>slots</code>的分配状况，如<code>bitmap</code>。 当需要分配时，就查找对应大小的<code>slab</code>，分配出一个空闲<code>slot</code>，而释放时就是把这个<code>slot</code>标记为空闲。</p>
<p><code>slab</code>的<code>size classes</code>影响碎片的产生，需要精心选择：</p>
<ul>
<li><code>size classes</code>太稀疏会导致内部碎片</li>
<li><code>size classes</code>太密集又会导致外部碎片</li>
</ul>
<h1 id="jemalloc-源码分析"><a href="#jemalloc-源码分析" class="headerlink" title="jemalloc 源码分析"></a>jemalloc 源码分析</h1><p><code>Redis</code>一般不使用<code>glibc</code>中默认的内存分配器，在编译时可以指定使用自带的<code>jemalloc</code>，版本为 4.0.3，编译参数如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-lg-quantum=3 --with-jemalloc-prefix=je_ --enable-cc-silence CFLAGS=&quot;-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops &quot; LDFLAGS=&quot;&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>--with-lg-quantum=&lt;lg-quantum&gt;</code>：Base 2 log of minimum allocation alignment. 8字节对齐</li>
<li><code>--with-jemalloc-prefix=&lt;prefix&gt;</code>：Prefix to prepend to all public APIs.</li>
<li><code>--disable-cc-silence</code>：Do not silence irrelevant compiler warnings.</li>
</ol>
<p><code>jemalloc</code>可以在编译时配置也支持运行时配置，配置项可以查看文档，可配置的有 page size、chunksize、quantum 等。配置支持 4 种方式:</p>
<ul>
<li><code>/etc/malloc.conf</code> 符号链接</li>
<li><code>MALLOC_OPTIONS</code> 环境变量</li>
<li><code>_malloc_options</code> 全局变量</li>
<li><code>je_mallctl()</code> 在代码里进行配置</li>
</ul>
<p><img src="/img/c2dv3kuw94.png" alt=""></p>
<h2 id="1-Some-structures"><a href="#1-Some-structures" class="headerlink" title="1 - Some structures"></a>1 - Some structures</h2><h3 id="page"><a href="#page" class="headerlink" title="page"></a>page</h3><p>最底层是从操作系统申请内存，由<code>pages.h/pages.c</code>封装了跨平台实现，<code>Linux</code>中使用<code>mmap(2)</code>。主要关注下面几个函数:</p>
<ul>
<li><code>pages_map()</code>：调用<code>mmap()</code>分配可读可写、私有匿名映射。</li>
<li><code>pages_unmap()</code>：调用<code>mummap()</code>删除指定范围的映射。</li>
<li><code>pages_trim()</code>：<code>trim</code>头尾部分的内存映射，用于内存对齐。</li>
<li><code>pages_purge()</code>：调用<code>madvise()</code>清除(purge)部分内存页，也就是释放。</li>
</ul>
<p><code>mmap()</code>会以<code>page size</code>的倍数分配内存，匿名映射会初始化为0，私有映射采用 COW 策略。</p>
<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>每当内存不够用了，<code>jemalloc</code>会以<code>chunk</code>为单位从操作系统申请内存，大小为<code>page size</code>倍数，默认为 2 MiB，分配的函数为<code>chunk_alloc_mmap()</code>。<code>chunk_alloc_map()</code>会调用<code>pages_map()</code>分配地址按<code>chunk_size</code>对齐的内存，既可以避免 false cache line sharing，也可以在常量时间内得到起始地址。 但是<code>pages_map()</code>不能保证对齐，首先会调用<code>pages_map()</code>分配一块内存查看是否对齐，若没对齐，会重新多分配一些内存，然后调用<code>pages_trim()</code>截取两端使内存对齐 ，所以可能会有多次<code>mmap()</code>和<code>munmap()</code>的过程。</p>
<p><code>chunk</code>分配出来需要进行管理，每个<code>chunk</code>会分配一个头部<code>extent_node_t</code>记录其中的信息，如:</p>
<ul>
<li><code>en_arena</code>：负责该<code>chunk</code>的<code>arena</code>(后面介绍)。</li>
<li><code>en_addr</code>：该<code>chunk</code>的起始地址。<br>  <code>chunk</code>分配出来会插入到<code>chunks_rtree(radix tree)</code>中，保存<code>chunk</code>地址到<code>extent_node_t</code>的映射，以便能快速从地址找到<code>node</code>，方便后面<code>huge object</code>的释放。</li>
</ul>
<h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p><code>jemalloc</code>不可能只使用栈空间或全局变量，内部也需要动态分配一些内存。<code>base.h/base.c</code>实现了内部使用的内存分配器。</p>
<p><code>base</code>通过地址对齐和<code>padding</code>避免 false cache line sharing：<code>chunk</code>会按照<code>chunksize</code>地址对齐，且分配的大小会<code>padding</code>到<code>cache line</code>大小倍数。</p>
<p><code>base</code>以<code>chunk</code>为单位申请内存，记录<code>chunk</code>信息的<code>extent_node_t</code>使用<code>chunk</code>的起始内存:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">extent_node_t</span> *</span><br><span class="line"><span class="title function_">base_chunk_alloc</span><span class="params">(<span class="type">size_t</span> minsize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">extent_node_t</span> *node;</span><br><span class="line">	<span class="type">size_t</span> csize, nsize;</span><br><span class="line">	<span class="type">void</span> *addr;</span><br><span class="line"></span><br><span class="line">	assert(minsize != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* 尝试从 base_nodes 中复用 node */</span></span><br><span class="line">	node = base_node_try_alloc();</span><br><span class="line">	<span class="comment">/* Allocate enough space to also carve a node out if necessary. */</span></span><br><span class="line">        <span class="comment">// 需要分配的 node 的内存</span></span><br><span class="line">	nsize = (node == <span class="literal">NULL</span>) ? CACHELINE_CEILING(<span class="keyword">sizeof</span>(<span class="type">extent_node_t</span>)) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 多分配 node size，也按照 chunk size 对齐</span></span><br><span class="line">	csize = CHUNK_CEILING(minsize + nsize);</span><br><span class="line">        <span class="comment">// 内部调用 chunk_alloc_mmap()</span></span><br><span class="line">	addr = chunk_alloc_base(csize);</span><br><span class="line">	<span class="keyword">if</span> (addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">			base_node_dalloc(node);</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	base_mapped += csize;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用 chunk 的起始内存</span></span><br><span class="line">		node = (<span class="type">extent_node_t</span> *)addr;</span><br><span class="line">		addr = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)addr + nsize);</span><br><span class="line">		csize -= nsize;</span><br><span class="line">		<span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">			base_allocated += nsize;</span><br><span class="line">			base_resident += PAGE_CEILING(nsize);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	extent_node_init(node, <span class="literal">NULL</span>, addr, csize, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">return</span> (node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>base</code>使用<code>extent_node_t</code>组成的红黑树<code>base_avail_szad</code>管理<code>chunk</code>。每次需要分配时，会从红黑树中查找内存大小相同或略大的、地址最低的<code>node</code>，然后从<code>node</code>负责的<code>chunk</code>中分配内存，剩下的内存会继续由该<code>node</code>负责，修改大小和地址后再次插入到红黑树中；若该<code>node</code>负责的内存全部分配完了，会将该<code>node</code>添加到链表头<code>base_nodes</code>，留待后续分配时复用。当没有合适的<code>node</code>时，会新分配<code>chunk</code>大小倍数的内存，由<code>node</code>负责，这个<code>node</code>优先从链表<code>base_nodes</code>中分配，也可能是新分配的连续内存的起始位置构成的<code>node</code>。</p>
<p><code>base_alloc()</code>：从<code>base_avail_szad</code>中查找大小相同或略大的、地址最低的<code>extent_node_t</code>，再从<code>chunk</code>里分配内存。如果没有合适的内存，会先调用<code>base_chunk_alloc()</code>分配<code>chunk</code>大小倍数的内存，返回负责这块内存的<code>node</code>，然后进行分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ret = extent_node_addr_get(node); <span class="comment">/* node 中用于分配内存的起始地址 */</span></span><br><span class="line"><span class="keyword">if</span> (extent_node_size_get(node) &gt; csize) &#123;</span><br><span class="line">    extent_node_addr_set(node, (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)ret + csize)); <span class="comment">/* 起始地址增加 csize，表明之前的内存被分配出去 */</span></span><br><span class="line">    extent_node_size_set(node, extent_node_size_get(node) - csize); <span class="comment">/* 内存大小减少 */</span></span><br><span class="line">    extent_tree_szad_insert(&amp;base_avail_szad, node); <span class="comment">/* 按照大小、地址顺序插入到红黑树 */</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* 这种情况只发生在 extent_node_size_get(node) == csize 这种情况。</span></span><br><span class="line"><span class="comment">     * 此时该 node 负责的内存已经全部分配了，会将该 node 插入到一个链表中去，备用。</span></span><br><span class="line"><span class="comment">     * 该链表用嵌入式实现，在 node 的起始内存存放下一个 node 的地址，节省空间 */</span></span><br><span class="line">    base_node_dalloc(node);</span><br></pre></td></tr></table></figure>
<p>为了减少内存浪费，<code>base_nodes</code>链表缓存了之前分配的<code>extent_node_t</code>，<code>base_nodes</code>指向链表头，<code>base_node_dalloc()</code>将<code>node</code>添加到表头，而<code>base_node_try_alloc()</code>移除表头。 采用嵌入式实现，比较晦涩:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">extent_node_t</span> *</span><br><span class="line"><span class="title function_">base_node_try_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">extent_node_t</span> *node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (base_nodes == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 返回链表头</span></span><br><span class="line">	node = base_nodes;</span><br><span class="line">        <span class="comment">// base_nodes 指向下一个 node</span></span><br><span class="line">	base_nodes = *(<span class="type">extent_node_t</span> **)node;</span><br><span class="line">	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(node, <span class="keyword">sizeof</span>(<span class="type">extent_node_t</span>));</span><br><span class="line">	<span class="keyword">return</span> (node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* base_mtx must be held. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">base_node_dalloc</span><span class="params">(<span class="type">extent_node_t</span> *node)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(node, <span class="keyword">sizeof</span>(<span class="type">extent_node_t</span>));</span><br><span class="line">        <span class="comment">// 将 base_nodes 指向的地址保存在 node 的指向的内存起始处</span></span><br><span class="line">        <span class="comment">// 形成一个 node 的链表，base_nodes 指向链表头，内存起始处为</span></span><br><span class="line">        <span class="comment">// 下一个 node 的地址</span></span><br><span class="line">	*(<span class="type">extent_node_t</span> **)node = base_nodes;</span><br><span class="line">	base_nodes = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p><code>arena</code>是<code>jemalloc</code>中最重要的部分，内存大多数由<code>arena</code>管理，分配算法是<code>Buddy allocation</code>和<code>Slab allocation</code>的组合:</p>
<ul>
<li><code>chunk</code>使用<code>Buddy allocation</code>划分为不同大小的<code>run</code>。</li>
<li><code>run</code>使用<code>Slab allocation</code>划分为固定大小的<code>region</code>，大部分内存分配直接查找对应的<code>run</code>，从中分配空闲的<code>region</code>，释放就是标记<code>region</code>为空闲。</li>
<li><code>run</code>被释放会和空闲的、相邻的<code>run</code>进行合并。当合并为整个<code>chunk</code>时，若发现有相邻的空闲<code>chunk</code>，也会进行合并。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* This arena&#x27;s index within the arenas array. */</span></span><br><span class="line">	<span class="type">unsigned</span>		ind;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of threads currently assigned to this arena.  This field is</span></span><br><span class="line"><span class="comment">	 * protected by arenas_lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span>		nthreads;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There are three classes of arena operations from a locking</span></span><br><span class="line"><span class="comment">	 * perspective:</span></span><br><span class="line"><span class="comment">	 * 1) Thread assignment (modifies nthreads) is protected by arenas_lock.</span></span><br><span class="line"><span class="comment">	 * 2) Bin-related operations are protected by bin locks.</span></span><br><span class="line"><span class="comment">	 * 3) Chunk- and run-related operations are protected by this mutex.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">malloc_mutex_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	<span class="type">arena_stats_t</span>		stats;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * List of tcaches for extant threads associated with this arena.</span></span><br><span class="line"><span class="comment">	 * Stats from these are merged incrementally, and at exit if</span></span><br><span class="line"><span class="comment">	 * opt_stats_print is enabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ql_head(<span class="type">tcache_t</span>)	tcache_ql;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>		prof_accumbytes;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * PRNG state for cache index randomization of large allocation base</span></span><br><span class="line"><span class="comment">	 * pointers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint64_t</span>		offset_state;</span><br><span class="line"></span><br><span class="line">	<span class="type">dss_prec_t</span>		dss_prec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In order to avoid rapid chunk allocation/deallocation when an arena</span></span><br><span class="line"><span class="comment">	 * oscillates right on the cusp of needing a new chunk, cache the most</span></span><br><span class="line"><span class="comment">	 * recently freed chunk.  The spare is left in the arena&#x27;s chunk trees</span></span><br><span class="line"><span class="comment">	 * until it is deleted.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * There is one spare chunk per arena, rather than one spare total, in</span></span><br><span class="line"><span class="comment">	 * order to avoid interactions between multiple threads that could make</span></span><br><span class="line"><span class="comment">	 * a single spare inadequate.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">arena_chunk_t</span>		*spare;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Minimum ratio (log base 2) of nactive:ndirty. */</span></span><br><span class="line">	<span class="type">ssize_t</span>			lg_dirty_mult;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* True if a thread is currently executing arena_purge(). */</span></span><br><span class="line">	<span class="type">bool</span>			purging;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of pages in active runs and huge regions. */</span></span><br><span class="line">        <span class="comment">// 已经分配出的 page 个数</span></span><br><span class="line">	<span class="type">size_t</span>			nactive;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Current count of pages within unused runs that are potentially</span></span><br><span class="line"><span class="comment">	 * dirty, and for which madvise(... MADV_DONTNEED) has not been called.</span></span><br><span class="line"><span class="comment">	 * By tracking this, we can institute a limit on how much dirty unused</span></span><br><span class="line"><span class="comment">	 * memory is mapped for each arena.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// runs_dirty 中的page数目(包含 chunk)</span></span><br><span class="line">	<span class="type">size_t</span>			ndirty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Size/address-ordered tree of this arena&#x27;s available runs.  The tree</span></span><br><span class="line"><span class="comment">	 * is used for first-best-fit run allocation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// 红黑树</span></span><br><span class="line">	<span class="type">arena_avail_tree_t</span>	runs_avail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Unused dirty memory this arena manages.  Dirty memory is conceptually</span></span><br><span class="line"><span class="comment">	 * tracked as an arbitrarily interleaved LRU of dirty runs and cached</span></span><br><span class="line"><span class="comment">	 * chunks, but the list linkage is actually semi-duplicated in order to</span></span><br><span class="line"><span class="comment">	 * avoid extra arena_chunk_map_misc_t space overhead.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   LRU-----------------------------------------------------------MRU</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *        /-- arena ---\</span></span><br><span class="line"><span class="comment">	 *        |            |</span></span><br><span class="line"><span class="comment">	 *        |            |</span></span><br><span class="line"><span class="comment">	 *        |------------|                             /- chunk -\</span></span><br><span class="line"><span class="comment">	 *   ...-&gt;|chunks_cache|&lt;---------------------------&gt;|  /----\ |&lt;--...</span></span><br><span class="line"><span class="comment">	 *        |------------|                             |  |node| |</span></span><br><span class="line"><span class="comment">	 *        |            |                             |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |            |    /- run -\    /- run -\   |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |            |    |       |    |       |   |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |            |    |       |    |       |   |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |------------|    |-------|    |-------|   |  |----| |</span></span><br><span class="line"><span class="comment">	 *   ...-&gt;|runs_dirty  |&lt;--&gt;|rd     |&lt;--&gt;|rd     |&lt;----&gt;|rd  |&lt;----...</span></span><br><span class="line"><span class="comment">	 *        |------------|    |-------|    |-------|   |  |----| |</span></span><br><span class="line"><span class="comment">	 *        |            |    |       |    |       |   |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |            |    |       |    |       |   |  \----/ |</span></span><br><span class="line"><span class="comment">	 *        |            |    \-------/    \-------/   |         |</span></span><br><span class="line"><span class="comment">	 *        |            |                             |         |</span></span><br><span class="line"><span class="comment">	 *        |            |                             |         |</span></span><br><span class="line"><span class="comment">	 *        \------------/                             \---------/</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// 空闲的 dirty run 会存在这，用于 purge</span></span><br><span class="line">	<span class="type">arena_runs_dirty_link_t</span>	runs_dirty;</span><br><span class="line">        <span class="comment">// 都是 runs_dirty 中存在的，是为了保存脏的 chunk</span></span><br><span class="line">	<span class="type">extent_node_t</span>		chunks_cache;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Extant huge allocations. */</span></span><br><span class="line">	ql_head(<span class="type">extent_node_t</span>)	huge;</span><br><span class="line">	<span class="comment">/* Synchronizes all huge allocation/update/deallocation. */</span></span><br><span class="line">	<span class="type">malloc_mutex_t</span>		huge_mtx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Trees of chunks that were previously allocated (trees differ only in</span></span><br><span class="line"><span class="comment">	 * node ordering).  These are used when allocating chunks, in an attempt</span></span><br><span class="line"><span class="comment">	 * to re-use address space.  Depending on function, different tree</span></span><br><span class="line"><span class="comment">	 * orderings are needed, which is why there are two trees with the same</span></span><br><span class="line"><span class="comment">	 * contents.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// 用于复用 chunk</span></span><br><span class="line">        <span class="comment">// 2种树的内容一样，order 不同</span></span><br><span class="line">	<span class="type">extent_tree_t</span>		chunks_szad_cached;</span><br><span class="line">	<span class="type">extent_tree_t</span>		chunks_ad_cached;</span><br><span class="line">	<span class="type">extent_tree_t</span>		chunks_szad_retained;</span><br><span class="line">	<span class="type">extent_tree_t</span>		chunks_ad_retained;</span><br><span class="line"></span><br><span class="line">	<span class="type">malloc_mutex_t</span>		chunks_mtx;</span><br><span class="line">	<span class="comment">/* Cache of nodes that were allocated via base_alloc(). */</span></span><br><span class="line">	ql_head(<span class="type">extent_node_t</span>)	node_cache;</span><br><span class="line">	<span class="type">malloc_mutex_t</span>		node_cache_mtx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* User-configurable chunk hook functions. */</span></span><br><span class="line">    <span class="comment">// chunk_hooks_default</span></span><br><span class="line">	<span class="type">chunk_hooks_t</span>		chunk_hooks;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bins is used to store trees of free regions. */</span></span><br><span class="line">	<span class="type">arena_bin_t</span>		bins[NBINS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整体的结构图如下，忽略了很多细节：<br><img src="/img/20211102100901.png" alt=""></p>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p><code>small classes</code>从<code>run</code>中使用<code>slab</code>算法分配，每个<code>run</code>对应一块连续的内存，大小为<code>page size</code>倍数，划分为等大小的<code>region</code>，分配时就从<code>run</code>中分配一个空闲<code>region</code>，释放时就标记该<code>region</code>为空闲，留待之后分配。</p>
<p><code>arena_run_t</code>记录了<code>run</code>的分配情况:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_run_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Index of bin this run is associated with. */</span></span><br><span class="line">	<span class="type">szind_t</span>		binind;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of free regions in run. */</span></span><br><span class="line">	<span class="type">unsigned</span>	nfree;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per region allocated/deallocated bitmap. */</span></span><br><span class="line">        <span class="comment">// 记录 run 中 region 的分配情况，每 bit 对应1个 region</span></span><br><span class="line">	<span class="type">bitmap_t</span>	bitmap[BITMAP_GROUPS_MAX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在看一下如何从<code>run</code>中分配:</p>
<ul>
<li>首先设置<code>bitmap</code>中第一个未设置的并返回，也就是要分配的<code>region id</code></li>
<li>返回对应的<code>region</code>，具体的地址计算后面再来看</li>
<li><code>nfree--</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE_C <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_run_reg_alloc</span><span class="params">(<span class="type">arena_run_t</span> *run, <span class="type">arena_bin_info_t</span> *bin_info)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line">	<span class="type">unsigned</span> regind;</span><br><span class="line">	<span class="type">arena_chunk_map_misc_t</span> *miscelm;</span><br><span class="line">	<span class="type">void</span> *rpages;</span><br><span class="line"></span><br><span class="line">	assert(run-&gt;nfree &gt; <span class="number">0</span>);</span><br><span class="line">	assert(!bitmap_full(run-&gt;bitmap, &amp;bin_info-&gt;bitmap_info));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set first unset 并 返回</span></span><br><span class="line">	regind = bitmap_sfu(run-&gt;bitmap, &amp;bin_info-&gt;bitmap_info);</span><br><span class="line">	miscelm = arena_run_to_miscelm(run);</span><br><span class="line">	rpages = arena_miscelm_to_rpages(miscelm);</span><br><span class="line">        <span class="comment">// 获取 run 中对应的 region，返回</span></span><br><span class="line">	ret = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)rpages + (<span class="type">uintptr_t</span>)bin_info-&gt;reg0_offset +</span><br><span class="line">	    (<span class="type">uintptr_t</span>)(bin_info-&gt;reg_interval * regind));</span><br><span class="line">	run-&gt;nfree--;</span><br><span class="line">	<span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放是相反的过程:</p>
<ul>
<li>首先获取该<code>ptr</code>的<code>region id</code></li>
<li><code>unset</code>对应的<code>bitmap</code></li>
<li><code>nfree++</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE_C <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_run_reg_dalloc</span><span class="params">(<span class="type">arena_run_t</span> *run, <span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">arena_chunk_t</span> *chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(run);</span><br><span class="line">	<span class="type">size_t</span> pageind = ((<span class="type">uintptr_t</span>)ptr - (<span class="type">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE;</span><br><span class="line">	<span class="type">size_t</span> mapbits = arena_mapbits_get(chunk, pageind);</span><br><span class="line">	<span class="type">szind_t</span> binind = arena_ptr_small_binind_get(ptr, mapbits);</span><br><span class="line">	<span class="type">arena_bin_info_t</span> *bin_info = &amp;arena_bin_info[binind];</span><br><span class="line">	<span class="type">unsigned</span> regind = arena_run_regind(run, bin_info, ptr);</span><br><span class="line"></span><br><span class="line">	assert(run-&gt;nfree &lt; bin_info-&gt;nregs);</span><br><span class="line">	<span class="comment">/* Freeing an interior pointer can cause assertion failure. */</span></span><br><span class="line">	assert(((<span class="type">uintptr_t</span>)ptr -</span><br><span class="line">	    ((<span class="type">uintptr_t</span>)arena_miscelm_to_rpages(arena_run_to_miscelm(run)) +</span><br><span class="line">	    (<span class="type">uintptr_t</span>)bin_info-&gt;reg0_offset)) %</span><br><span class="line">	    (<span class="type">uintptr_t</span>)bin_info-&gt;reg_interval == <span class="number">0</span>);</span><br><span class="line">	assert((<span class="type">uintptr_t</span>)ptr &gt;=</span><br><span class="line">	    (<span class="type">uintptr_t</span>)arena_miscelm_to_rpages(arena_run_to_miscelm(run)) +</span><br><span class="line">	    (<span class="type">uintptr_t</span>)bin_info-&gt;reg0_offset);</span><br><span class="line">	<span class="comment">/* Freeing an unallocated pointer can cause assertion failure. */</span></span><br><span class="line">	assert(bitmap_get(run-&gt;bitmap, &amp;bin_info-&gt;bitmap_info, regind));</span><br><span class="line"></span><br><span class="line">	bitmap_unset(run-&gt;bitmap, &amp;bin_info-&gt;bitmap_info, regind);</span><br><span class="line">	run-&gt;nfree++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p><code>jemalloc</code>中<code>small size classes</code>都使用<code>slab</code>算法分配，所以会有多种不同的<code>run</code>。<code>bin</code>管理相同类型的<code>run</code>，<code>bin_info</code>记录了对应的<code>run</code>的内存格式。</p>
<p><code>bin_info_init()</code>根据<code>size classes</code>初始化<code>small class bins</code>的信息<code>arena_bin_info[NBINS]</code>。数组中每个元素记录了<code>bin</code>对应的<code>run</code>的信息:</p>
<ul>
<li><code>reg_size</code>：每个<code>region</code>的大小，对应着<code>small size classes</code>大小</li>
<li><code>run_size</code>：<code>bin</code>对应的整个<code>run</code>的大小，<code>page_size</code>的倍数，一般为<code>reg_size</code>和<code>page_size</code>的最小公倍数，但是不能超过<code>arena_maxrun</code>。</li>
<li><code>nregs</code>：该<code>run</code>中<code>region</code>的个数</li>
<li><code>reg0_offset</code>：第一个<code>region</code>距离<code>run</code>起始地址的偏移</li>
</ul>
<p>还有一些其他的信息，主要用于<code>debug</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read-only information associated with each element of arena_t&#x27;s bins array</span></span><br><span class="line"><span class="comment"> * is stored separately, partly to reduce memory usage (only one copy, rather</span></span><br><span class="line"><span class="comment"> * than one per arena), but mainly to avoid false cacheline sharing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Each run has the following layout:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *               /--------------------\</span></span><br><span class="line"><span class="comment"> *               | pad?               |</span></span><br><span class="line"><span class="comment"> *               |--------------------|</span></span><br><span class="line"><span class="comment"> *               | redzone            |</span></span><br><span class="line"><span class="comment"> *   reg0_offset | region 0           |</span></span><br><span class="line"><span class="comment"> *               | redzone            |</span></span><br><span class="line"><span class="comment"> *               |--------------------| \</span></span><br><span class="line"><span class="comment"> *               | redzone            | |</span></span><br><span class="line"><span class="comment"> *               | region 1           |  &gt; reg_interval</span></span><br><span class="line"><span class="comment"> *               | redzone            | /</span></span><br><span class="line"><span class="comment"> *               |--------------------|</span></span><br><span class="line"><span class="comment"> *               | ...                |</span></span><br><span class="line"><span class="comment"> *               | ...                |</span></span><br><span class="line"><span class="comment"> *               | ...                |</span></span><br><span class="line"><span class="comment"> *               |--------------------|</span></span><br><span class="line"><span class="comment"> *               | redzone            |</span></span><br><span class="line"><span class="comment"> *               | region nregs-1     |</span></span><br><span class="line"><span class="comment"> *               | redzone            |</span></span><br><span class="line"><span class="comment"> *               |--------------------|</span></span><br><span class="line"><span class="comment"> *               | alignment pad?     |</span></span><br><span class="line"><span class="comment"> *               \--------------------/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * reg_interval has at least the same minimum alignment as reg_size; this</span></span><br><span class="line"><span class="comment"> * preserves the alignment constraint that sa2u() depends on.  Alignment pad is</span></span><br><span class="line"><span class="comment"> * either 0 or redzone_size; it is present only if needed to align reg0_offset.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><code>bin</code>的结构如下:</p>
<ul>
<li><code>runcur</code>：指向有空闲<code>region</code>且地址最低的<code>run</code></li>
<li><code>runs</code>：红黑树，管理有空闲<code>region</code>的<code>run</code>，按照<code>run</code>的地址排序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_bin_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All operations on runcur, runs, and stats require that lock be</span></span><br><span class="line"><span class="comment">	 * locked.  Run allocation/deallocation are protected by the arena lock,</span></span><br><span class="line"><span class="comment">	 * which may be acquired while holding one or more bin locks, but not</span></span><br><span class="line"><span class="comment">	 * vise versa.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">malloc_mutex_t</span>	lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Current run being used to service allocations of this bin&#x27;s size</span></span><br><span class="line"><span class="comment">	 * class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">arena_run_t</span>	*runcur;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Tree of non-full runs.  This tree is used when looking for an</span></span><br><span class="line"><span class="comment">	 * existing run when runcur is no longer usable.  We choose the</span></span><br><span class="line"><span class="comment">	 * non-full run that is lowest in memory; this policy tends to keep</span></span><br><span class="line"><span class="comment">	 * objects packed well, and it can also help reduce the number of</span></span><br><span class="line"><span class="comment">	 * almost-empty chunks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// 红黑树 non-full runs，按照地址排序</span></span><br><span class="line">	<span class="type">arena_run_tree_t</span> runs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bin statistics. */</span></span><br><span class="line">	<span class="type">malloc_bin_stats_t</span> stats;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>来看下如何从<code>bin</code>中分配<code>run</code>:</p>
<ul>
<li>若<code>runcur != NULL</code>，则从该<code>run</code>分配</li>
<li>从<code>runs</code>中查找地址最低的<code>run</code>，分配</li>
</ul>
<p>当从<code>run</code>中释放<code>region</code>时，根据<code>run</code>的状态会有不同的操作:</p>
<ul>
<li>若该<code>run</code>原先已满，则会调用<code>arena_bin_lower_run()</code>设置为<code>runcur</code>或者插入到<code>runs</code>中</li>
<li>若该<code>run</code>之前有空闲空间，说明是<code>runcur</code>或已经在<code>runs</code>中，此时无特殊处理</li>
<li>若该<code>run</code>释放<code>region</code>后已空，则会将该<code>run</code>与<code>bin</code>解除关系，返回到<code>arena</code>中，后面再来看这种情况</li>
</ul>
<p><code>bin-&gt;runcur</code>指向的永远是地址最低的<code>run</code>，目的是减少<code>active pages</code>。</p>
<h3 id="chunk-1"><a href="#chunk-1" class="headerlink" title="chunk"></a>chunk</h3><p><code>chunk</code>是<code>jemalloc</code>中申请内存的基本单位。<code>arena</code>中有如下元素管理<code>chunk</code>:</p>
<ul>
<li><code>spare</code>：缓存最近空闲的<code>chunk</code>，为了避免频繁的<code>chunk</code>分配和释放</li>
<li><code>chunks_szad_cached/chunks_ad_cached</code>：<code>extent_node_t</code>的红黑树，缓存之前分配的、空闲的<code>chunk</code>，数据一样，只是顺序不同:</li>
<li><code>szad</code>：按照<code>size</code>、<code>address</code>排序</li>
<li><code>ad</code>：按照<code>address</code>排序</li>
<li><code>chunks_szad_retained/chunks_ad_retained</code>：<code>extent_node_t</code>的红黑树，缓存已经被释放的、空闲的<code>chunk</code>，在后面<code>purge</code>阶段会看到</li>
</ul>
<p>现在来看一下<code>chunk</code>的申请过程:</p>
<ul>
<li>若<code>spare != NULL</code>，则返回<code>spare</code></li>
<li>从<code>cached</code>中查找</li>
<li>从<code>retained</code>中查找</li>
<li>调用<code>chunk_alloc_mmap()</code>新分配一个<code>chunk</code></li>
</ul>
<p>第2、3步会调用<code>chunk_recycle()</code>实施伙伴算法的分裂过程：从对应的树中进行分配指定大小的<code>chunk</code>，<code>chunk</code>起始地址会按<code>chunk_size</code>对齐。因为需要对齐且大小不一定相等，所以前后需要进行裁剪，<code>leadsize</code>和<code>trailsize</code>也会重新插入树中，留待之后的分配使用。</p>
<p>相对应的，<code>chunk</code>释放过程如下:</p>
<ul>
<li>若<code>spare == NULL</code>，则设置为<code>spare</code></li>
<li>将原先的<code>spare</code>插入到<code>cached</code>中，设置为<code>spare</code></li>
</ul>
<p>第2步会调用<code>chunk_record()</code>实施伙伴算法的合并过程：会查找连续地址空间的前后的<code>chunk</code>在不在树中，如果在的话会进行合并，然后再插入到树中。</p>
<h3 id="arena-chunk-t"><a href="#arena-chunk-t" class="headerlink" title="arena_chunk_t"></a>arena_chunk_t</h3><p><code>run</code>从<code>chunk</code>中分配，同样采用伙伴算法。一整个<code>chunk</code>的内存分为4个部分:</p>
<ul>
<li><code>extent_node_t</code>：记录<code>chunk</code>的状态，用于之后管理<code>chunk</code></li>
<li><code>arena_chunk_map_bits_t</code>：一一对应<code>chunk</code>内每个<code>page</code>，记录从<code>chunk</code>分配出去的<code>run</code>的大小和信息、记录<code>page</code>的分配状态。</li>
<li><code>arena_chunk_map_misc_t</code>：一一对应<code>chunk</code>内每个<code>page</code>对应的<code>run</code></li>
<li><code>page</code>：大小为 4096B</li>
</ul>
<p>这些记录<code>chunk</code>信息的<code>header</code>存放在每个<code>chunk</code>起始地址处，所以会占用掉部分内存。这些<code>header</code>和<code>chunk</code>中的<code>page</code>个数有关，而<code>chunk</code>中减去<code>header</code>的内存又和<code>page</code>的个数有关，所以<code>arena_boot()</code>中使用循环计算<code>header</code>占用的<code>page</code>个数(map_bias):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Compute the header size such that it is large enough to contain the</span></span><br><span class="line"><span class="comment">* page map.  The page map is biased to omit entries for the header</span></span><br><span class="line"><span class="comment">* itself, so some iteration is necessary to compute the map bias.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 1) Compute safe header_size and map_bias values that include enough</span></span><br><span class="line"><span class="comment">*    space for an unbiased page map.</span></span><br><span class="line"><span class="comment">* 2) Refine map_bias based on (1) to omit the header pages in the page</span></span><br><span class="line"><span class="comment">*    map.  The resulting map_bias may be one too small.</span></span><br><span class="line"><span class="comment">* 3) Refine map_bias based on (2).  The result will be &gt;= the result</span></span><br><span class="line"><span class="comment">*    from (2), and will always be correct.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">map_bias = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="type">size_t</span> header_size = offsetof(<span class="type">arena_chunk_t</span>, map_bits) +</span><br><span class="line">        ((<span class="keyword">sizeof</span>(<span class="type">arena_chunk_map_bits_t</span>) +</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="type">arena_chunk_map_misc_t</span>)) * (chunk_npages-map_bias));</span><br><span class="line">    map_bias = (header_size + PAGE_MASK) &gt;&gt; LG_PAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>header</code>使用连续内存存放而不是每个<code>page</code>头部存放有如下好处:</p>
<ul>
<li>提高<code>header</code>的缓存局部性</li>
<li>提高<code>page</code>中分配出去的缓存局部性</li>
<li>可以减少<code>rss</code>占用，因为操作系统按照<code>page</code>管理虚拟地址，若每个空闲<code>page</code>都有些<code>header</code>占用，会使一整个<code>page</code>驻留在内存中</li>
</ul>
<p><code>arena_chunk_map_bits_t</code>在64位系统上，共有<code>64bits</code>，记录了<code>chunk</code>内每个<code>page</code>的分配情况，这些信息用于快速的查找<code>metadata</code>。对于不同状态的<code>page</code>有不同的格式:</p>
<ul>
<li>未分配<code>page</code>：连续、未分配的<code>page</code>会作为一个整体，由起始<code>page</code>对应的<code>run</code>进行管理。首尾<code>page</code>对应的<code>arena_chunk_map_bits_t</code>中会设置连续的空闲<code>page</code>的数量，中间的<code>page</code>不设置。同时，管理这些空闲<code>page</code>的<code>run</code>会插入到<code>runs_avail</code>中，该<code>run</code>的大小就是整个空闲<code>page</code>的大小(从<code>arena_chunk_map_bits_t</code>中获取)</li>
<li>已分配的<code>run</code>对应的<code>page</code>：每个<code>page</code>会设置该<code>page</code>是<code>run</code>中第几个<code>page</code>(<code>run page offset</code>)，并且设置<code>run</code>对应的<code>bin id</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Run address (or size) and various flags are stored together.  The bit</span></span><br><span class="line"><span class="comment">* layout looks like (assuming 32-bit system):</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   ???????? ???????? ???nnnnn nnndumla</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ? : Unallocated: Run address for first/last pages, unset for internal</span></span><br><span class="line"><span class="comment">*                  pages.</span></span><br><span class="line"><span class="comment">*     Small: Run page offset.</span></span><br><span class="line"><span class="comment">*     Large: Run page count for first page, unset for trailing pages.</span></span><br><span class="line"><span class="comment">* n : binind for small size class, BININD_INVALID for large size class.</span></span><br><span class="line"><span class="comment">* d : dirty?</span></span><br><span class="line"><span class="comment">* u : unzeroed?</span></span><br><span class="line"><span class="comment">* m : decommitted?</span></span><br><span class="line"><span class="comment">* l : large?</span></span><br><span class="line"><span class="comment">* a : allocated?</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Following are example bit patterns for the three types of runs.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* p : run page offset (这个page是run中第几个page (offset))</span></span><br><span class="line"><span class="comment">* s : run size (连续的空闲 page 个数)</span></span><br><span class="line"><span class="comment">* n : binind for size class; large objects set these to BININD_INVALID(该 page 对应的 bin Id)</span></span><br><span class="line"><span class="comment">* x : don&#x27;t care</span></span><br><span class="line"><span class="comment">* - : 0</span></span><br><span class="line"><span class="comment">* + : 1</span></span><br><span class="line"><span class="comment">* [DUMLA] : bit set</span></span><br><span class="line"><span class="comment">* [dumla] : bit unset</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Unallocated (clean):</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++dum-a</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxx-Uxxx</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++dUm-a</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Unallocated (dirty):</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++D-m-a</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++D-m-a</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Small:</span></span><br><span class="line"><span class="comment">*     pppppppp pppppppp pppnnnnn nnnd---A</span></span><br><span class="line"><span class="comment">*     pppppppp pppppppp pppnnnnn nnn----A</span></span><br><span class="line"><span class="comment">*     pppppppp pppppppp pppnnnnn nnnd---A</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Large:</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span></span><br><span class="line"><span class="comment">*     -------- -------- ---+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Large (sampled, size &lt;= LARGE_MINCLASS):</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sssnnnnn nnnD--LA</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span></span><br><span class="line"><span class="comment">*     -------- -------- ---+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Large (not sampled, size == LARGE_MINCLASS):</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span></span><br><span class="line"><span class="comment">*     -------- -------- ---+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>arena_chunk_map_misc_t</code>顾名思义，有很多用途，主要用于记录<code>run</code>的<code>metadata</code>。<code>run</code>大小是<code>page size</code>倍数，每个<code>run</code>会由起始<code>page</code>对应的<code>arena_chunk_map_misc_t</code>中的<code>run</code>管理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_chunk_map_misc_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Linkage for run trees.  There are two disjoint uses:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1) arena_t&#x27;s runs_avail tree.</span></span><br><span class="line"><span class="comment">	 * 2) arena_run_t conceptually uses this linkage for in-use non-full</span></span><br><span class="line"><span class="comment">	 *    runs, rather than directly embedding linkage.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rb_node(<span class="type">arena_chunk_map_misc_t</span>)		rb_link;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* Linkage for list of dirty runs. */</span></span><br><span class="line">		<span class="type">arena_runs_dirty_link_t</span>		rd;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Profile counters, used for large object runs. */</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">			<span class="type">void</span>				*prof_tctx_pun;</span><br><span class="line">			<span class="type">prof_tctx_t</span>			*prof_tctx;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Small region run metadata. */</span></span><br><span class="line">		<span class="type">arena_run_t</span>			run;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来看一下如何从<code>chunk</code>中分配<code>run</code>。</p>
<p>第一个<code>chunk</code>是调用<code>chunk_alloc_mmap()</code>分配的，然后调用<code>arena_mapbits_unallocated_set()</code>设置首尾<code>page</code>对应的<code>arena_chunk_map_bits_t</code>，然后将整个空闲<code>chunk</code>作为大小为<code>arena_maxrun</code>的空闲<code>run</code>插入到<code>runs_avail</code>中:<br><img src="/img/20211102100902.png" alt=""></p>
<p>然后调用<code>arena_run_split_small()</code>将该<code>run</code>分解为对应的<code>bin</code>管理的<code>run</code>:</p>
<ul>
<li>从<code>run</code>中分配出需要的<code>page</code>，多余的<code>page</code>会设置首尾<code>page</code>对应的<code>map_bits</code>，再次插入到<code>avail_runs</code>中留待后续分配</li>
<li>设置分配出去的<code>run</code>对应的<code>map_bits</code>，返回分配出去的第一个<code>page</code>对应的<code>misc</code>中的<code>run</code></li>
<li>之后<code>run</code>就会有对应的<code>bin</code>进行管理</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">arena_run_split_small</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_run_t</span> *run, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">    <span class="type">szind_t</span> binind)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">arena_chunk_t</span> *chunk;</span><br><span class="line">	<span class="type">arena_chunk_map_misc_t</span> *miscelm;</span><br><span class="line">	<span class="type">size_t</span> flag_dirty, flag_decommitted, run_ind, need_pages, i;</span><br><span class="line"></span><br><span class="line">	assert(binind != BININD_INVALID);</span><br><span class="line"></span><br><span class="line">	chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(run);</span><br><span class="line">	miscelm = arena_run_to_miscelm(run);</span><br><span class="line">	run_ind = arena_miscelm_to_pageind(miscelm);</span><br><span class="line">	flag_dirty = arena_mapbits_dirty_get(chunk, run_ind);</span><br><span class="line">	flag_decommitted = arena_mapbits_decommitted_get(chunk, run_ind);</span><br><span class="line">        <span class="comment">// size 是 bin 对应的 run_size </span></span><br><span class="line">	need_pages = (size &gt;&gt; LG_PAGE);</span><br><span class="line">	assert(need_pages &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag_decommitted != <span class="number">0</span> &amp;&amp; arena-&gt;chunk_hooks.commit(chunk, chunksize,</span><br><span class="line">	    run_ind &lt;&lt; LG_PAGE, size, arena-&gt;ind))</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	arena_run_split_remove(arena, chunk, run_ind, flag_dirty,</span><br><span class="line">	    flag_decommitted, need_pages);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置分配出去的 page 对应的 map_bits</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; need_pages; i++) &#123;</span><br><span class="line">		<span class="type">size_t</span> flag_unzeroed = arena_mapbits_unzeroed_get(chunk,</span><br><span class="line">		    run_ind+i);</span><br><span class="line">		arena_mapbits_small_set(chunk, run_ind+i, i, binind,</span><br><span class="line">		    flag_unzeroed);</span><br><span class="line">		<span class="keyword">if</span> (config_debug &amp;&amp; flag_dirty == <span class="number">0</span> &amp;&amp; flag_unzeroed == <span class="number">0</span>)</span><br><span class="line">			arena_run_page_validate_zeroed(chunk, run_ind+i);</span><br><span class="line">	&#125;</span><br><span class="line">	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED((<span class="type">void</span> *)((<span class="type">uintptr_t</span>)chunk +</span><br><span class="line">	    (run_ind &lt;&lt; LG_PAGE)), (need_pages &lt;&lt; LG_PAGE));</span><br><span class="line">	<span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 run_ind 对应 run 中分配出 need_pages，剩余的再次插入到 avail_runs 中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_run_split_remove</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">size_t</span> run_ind,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> flag_dirty, <span class="type">size_t</span> flag_decommitted, <span class="type">size_t</span> need_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> total_pages, rem_pages;</span><br><span class="line"></span><br><span class="line">	assert(flag_dirty == <span class="number">0</span> || flag_decommitted == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	total_pages = arena_mapbits_unallocated_size_get(chunk, run_ind) &gt;&gt;</span><br><span class="line">	    LG_PAGE;</span><br><span class="line">	assert(arena_mapbits_dirty_get(chunk, run_ind+total_pages<span class="number">-1</span>) ==</span><br><span class="line">	    flag_dirty);</span><br><span class="line">	assert(need_pages &lt;= total_pages);</span><br><span class="line">	rem_pages = total_pages - need_pages;</span><br><span class="line"></span><br><span class="line">	arena_avail_remove(arena, chunk, run_ind, total_pages);</span><br><span class="line">	<span class="keyword">if</span> (flag_dirty != <span class="number">0</span>)</span><br><span class="line">		arena_run_dirty_remove(arena, chunk, run_ind, total_pages);</span><br><span class="line">	arena_cactive_update(arena, need_pages, <span class="number">0</span>);</span><br><span class="line">	arena-&gt;nactive += need_pages;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Keep track of trailing unused pages for later use. */</span></span><br><span class="line">	<span class="keyword">if</span> (rem_pages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">size_t</span> flags = flag_dirty | flag_decommitted;</span><br><span class="line">		<span class="type">size_t</span> flag_unzeroed_mask = (flags == <span class="number">0</span>) ?  CHUNK_MAP_UNZEROED :</span><br><span class="line">		    <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置 run 对应的 page 的信息，设置开头和结尾的 page 对应的 map_bits 的</span></span><br><span class="line">            <span class="comment">// 未分配内存大小</span></span><br><span class="line">		arena_mapbits_unallocated_set(chunk, run_ind+need_pages,</span><br><span class="line">		    (rem_pages &lt;&lt; LG_PAGE), flags |</span><br><span class="line">		    (arena_mapbits_unzeroed_get(chunk, run_ind+need_pages) &amp;</span><br><span class="line">		    flag_unzeroed_mask));</span><br><span class="line">		arena_mapbits_unallocated_set(chunk, run_ind+total_pages<span class="number">-1</span>,</span><br><span class="line">		    (rem_pages &lt;&lt; LG_PAGE), flags |</span><br><span class="line">		    (arena_mapbits_unzeroed_get(chunk, run_ind+total_pages<span class="number">-1</span>) &amp;</span><br><span class="line">		    flag_unzeroed_mask));</span><br><span class="line">		<span class="keyword">if</span> (flag_dirty != <span class="number">0</span>) &#123;</span><br><span class="line">			arena_run_dirty_insert(arena, chunk, run_ind+need_pages,</span><br><span class="line">			    rem_pages);</span><br><span class="line">		&#125;</span><br><span class="line">		arena_avail_insert(arena, chunk, run_ind+need_pages, rem_pages);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20211102100903.png" alt=""></p>
<p>当<code>bin</code>中有完全空闲的<code>run</code>时，会返回给<code>arena</code>管理:</p>
<ul>
<li>调用<code>arena_dissociate_bin_run()</code>解除该<code>run</code>和<code>bin</code>的关系:</li>
<li>若该<code>run</code>为<code>bin-&gt;runcur</code>，设置<code>bin-&gt;runcur =NULL</code></li>
<li>从<code>bin-&gt;runs</code>中移除</li>
<li>调用<code>arena_run_coalesce()</code>尝试合并相邻的空闲<code>run</code></li>
<li>将<code>run</code>插入到<code>avail_runs</code>中</li>
<li>若该<code>run</code>大小已经达到<code>arena_maxrun</code>，表明整个<code>chunk</code>都是空闲的，调用<code>arena_chunk_dalloc()</code>释放<code>run</code></li>
</ul>
<h2 id="2-Basic-structures"><a href="#2-Basic-structures" class="headerlink" title="2 - Basic structures"></a>2 - Basic structures</h2><p>相对于Dl, Je引入了更多更复杂的分配结构，如arena，chunk，bin，run，region，tcache等等。其中有些类似Dl，但更多的具有不同含义，本节将对它们做一一介绍。</p>
<h3 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1 - Overview"></a>2.1 - Overview</h3><p>首先，先给出一个整体的概念。Je对内存划分按照如下由高到低的顺序，</p>
<ol>
<li>内存是由一定数量的arenas进行管理。</li>
<li>一个arena被分割成若干chunks，后者主要负责记录bookkeeping.</li>
<li>chunk内部又包含着若干runs，作为分配小块内存的基本单元。</li>
<li>run由pages组成，最终被划分成一定数量的regions,</li>
<li>对于small size的分配请求来说，这些region就相当于user memory.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    Arena #0</span><br><span class="line">+----------------------------------------------------------------------------+</span><br><span class="line">|                                                                            |</span><br><span class="line">|    Chunk #0                             Chunk #1                           |</span><br><span class="line">|  +---------------------------------+  +---------------------------------+  |</span><br><span class="line">|  |                                 |  |                                 |  |</span><br><span class="line">|  |   Run #0          Run #1        |  |   Run #0          Run #1        |  |</span><br><span class="line">|  | +-------------+ +-------------+ |  | +-------------+ +-------------+ |  |</span><br><span class="line">|  | |             | |             | |  | |             | |             | |  |</span><br><span class="line">|  | |   Page      | |   Page      | |  | |   Page      | |   Page      | |  |</span><br><span class="line">|  | | +---------+ | | +---------+ | |  | | +---------+ | | +---------+ | |  |</span><br><span class="line">|  | | |         | | | |         | | |  | | |         | | | |         | | |  |</span><br><span class="line">|  | | | Regions | | | | Regions | | |  | | | Regions | | | | Regions | | |  |</span><br><span class="line">|  | | |[] [] [] | | | |[] [] [] | | |  | | |[] [] [] | | | |[] [] [] | | |  |</span><br><span class="line">|  | | |         | | | |         | | |  | | |         | | | |         | | |  |</span><br><span class="line">|  | | +---------+ | | +---------+ | |  | | +---------+ | | +---------+ | |  |  </span><br><span class="line">|  | |             | |             | |  | |             | |             | |  |</span><br><span class="line">|  | |   Page      | |   Page      | |  | |   Page      | |   Page      | |  |</span><br><span class="line">|  | | +---------+ | | +---------+ | |  | | +---------+ | | +---------+ | |  |</span><br><span class="line">|  | | |         | | | |         | | |  | | |         | | | |         | | |  |</span><br><span class="line">|  | | | ...     | | | | ...     | | |  | | | ...     | | | | ...     | | |  |</span><br><span class="line">|  | | +---------+ | | +---------+ | |  | | +---------+ | | +---------+ | |  |</span><br><span class="line">|  | +-------------+ +-------------+ |  | +-------------+ +-------------+ |  |</span><br><span class="line">|  +---------------------------------+  +---------------------------------+  |</span><br><span class="line">+----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Arena-arena-t"><a href="#2-2-Arena-arena-t" class="headerlink" title="2.2 - Arena (arena_t)"></a>2.2 - Arena (arena_t)</h3><p>如前所述，Arena是Je中最大或者说最顶层的基础结构。这个概念其实上是针对”对称多处理机(SMP)”产生的。在SMP中，导致性能劣化的一个重要原因在于”false sharing”导致cache-line失效。</p>
<p>为了解决cache-line共享问题，同时保证更少的内部碎片(internal fragmentation)，Je使用了arena。</p>
<h4 id="2-2-1-CPU-Cache-Line"><a href="#2-2-1-CPU-Cache-Line" class="headerlink" title="2.2.1 - CPU Cache-Line"></a>2.2.1 - CPU Cache-Line</h4><p>Cache是嵌入到cpu内部的一组SRAM，速度是主存的N倍，但造价较高，因此一般容量很小。有些cpu设计了容量逐级逐渐增大的多级cache，但速度逐级递减。多级处理更复杂，但原理类似，为了简化，仅讨论L1 data cache。</p>
<p>cache同主存进行数据交换有一个最小粒度，称为cache-line，通常这个值为64。例如在一个ILP32的机器上，一次cache交换可以读写连续16个int型数据。因此当访问数组#0元素时，后面15个元素也被同时”免费”读到了cache中，这对于数组的连续访问是非常有利的。</p>
<p>然而这种免费加载不总是会带来好处，有时候甚至起到反效果，所谓”false sharing”。试想两个线程A和B分别执行在不同的cpu核心中并分别操作各自上下文中的变量x和y，如果因为某种原因(比如x，y可能位于同一个class内部，或者分别是数组中的两个相邻元素)，两者位于相同的cache-line中，则在两个core的L1 cache里都存在x和y的副本。</p>
<p>倘若线程A修改了x的值，就会导致在B中的x与A中看到的不一致。尽管这个变量x对B可能毫无用处，但cpu为了保证前后的正确和一致性，只能判定core #1的cache失效。因此core #0必须将cache-line回写到主存，然后core #1再重新加载cache-line，反之亦然。如果恰好两个线程交替操作同一cache-line中的数据，将对cache将造成极大的损害，导致严重的性能退化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+        +-----------------------+</span><br><span class="line">| core #0               |        | core #1               |</span><br><span class="line">|                       |        |                       |</span><br><span class="line">|  +----------+         |        |  +----------+         |</span><br><span class="line">|  | ThreadA  |         |        |  | ThreadB  |         |</span><br><span class="line">|  +----------+         |        |  +----------+         |</span><br><span class="line">|        |              |        |        |              |</span><br><span class="line">|    +---+              |        |        |              |</span><br><span class="line">|    |                  |        |        |              |</span><br><span class="line">|    v        D-cache   |        |        v     D-cache  |</span><br><span class="line">|  +-----------------+  |        |  +-----------------+  |</span><br><span class="line">|  | x&#x27;| y | ... ... | &lt;---+  +---&gt; | x | y&#x27;| ... ... |  |</span><br><span class="line">|  |-----------------|  |  |  |  |  |-----------------|  |</span><br><span class="line">|  |    ... ...      |  |  |  |  |  |    ... ...      |  |</span><br><span class="line">|  |    ... ...      |  |  |  |  |  |    ... ...      |  |</span><br><span class="line">|  |    ... ...      |  |  |  |  |  |    ... ...      |  |</span><br><span class="line">|  +-----------------+  |  |  |  |  +-----------------+  |</span><br><span class="line">+-----------------------+  |  |  +-----------------------+</span><br><span class="line">                           |  |  </span><br><span class="line">                    +------+  |</span><br><span class="line">                    |         |</span><br><span class="line">                    v         v</span><br><span class="line">   memory   +-----------------------------</span><br><span class="line">            | ... | x | y |     ... ...     </span><br><span class="line">            +-----------------------------</span><br></pre></td></tr></table></figure>
<p>说到底，从程序的角度看，变量是独立的地址单元，但在CPU看来则是以cache-line为整体的单元。单独的变量竞争可以在代码中增加同步来解决，而cache-line的竞争是透明的，不可控的，只能被动由CPU仲裁。这种观察角度和处理方式的区别，正是false sharing的根源。</p>
<h4 id="2-2-2-Arena原理"><a href="#2-2-2-Arena原理" class="headerlink" title="2.2.2 - Arena原理"></a>2.2.2 - Arena原理</h4><p>回到memory allocator的话题上。对于一个多线程+多CPU核心的运行环境，传统分配器中大量开销被浪费在lock contention和false sharing上，随着线程数量和核心数量增多，这种分配压力将越来越大。</p>
<p>针对多线程，一种解决方法是将一把global lock分散成很多与线程相关的lock。而针对多核心，则要尽量把不同线程下分配的内存隔离开，避免不同线程使用同一个cache-line的情况。按照上面的思路，一个较好的实现方式就是引入arena。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+---------+     +---------+     +---------+     +---------+     +---------+</span><br><span class="line">| threadA |     | threadB |     | threadC |     | threadD |     | threadE |     </span><br><span class="line">+---------+     +---------+     +---------+     +---------+     +---------+</span><br><span class="line">     |               |               |               |               |</span><br><span class="line">     |               +---------------|---------------|---------+     |</span><br><span class="line">     +------------------+    +-------+        +------+         |     |</span><br><span class="line">      +-----------------|----|----------------|----------------|-----+  </span><br><span class="line">      |                 |    |                |                |</span><br><span class="line">      v                 v    v                v                v</span><br><span class="line">+----------+        +----------+        +----------+        +----------+     </span><br><span class="line">|          |        |          |        |          |        |          |</span><br><span class="line">| Arena #0 |        | Arena #1 |        | Arena #2 |        | Arena #3 |</span><br><span class="line">|          |        |          |        |          |        |          |</span><br><span class="line">+----------+        +----------+        +----------+        +----------+</span><br></pre></td></tr></table></figure>
<p>Je将内存划分成若干数量的arenas，线程最终会与某一个arena绑定。比如上图中的threadA和B就分别绑定到arena #1和#3上。由于两个arena在地址空间上几乎不存在任何联系，就可以在无锁的状态下完成分配。同样由于空间不连续，落到同一个cache-line中的几率也很小，保证了各自独立。</p>
<p>由于arena的数量有限，因此不能保证所有线程都能独占arena，比如，图中threadA和C就都绑定到了arena1上。分享同一个arena的所有线程，由该arena内部的lock保持同步。</p>
<p>Je将arena保存到一个数组中，该数组全局记录了所有arenas，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_t</span>            **arenas;</span><br></pre></td></tr></table></figure></p>
<p>事实上，该数组是动态分配的，arenas仅仅是一个数组指针。默认情况下arenas数组的长度与如下变量相关，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span>    narenas_total;</span><br><span class="line"><span class="type">unsigned</span>    narenas_auto;</span><br><span class="line"><span class="type">size_t</span>        opt_narenas = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>而它们又与当前cpu核心数量相关。核心数量记录在另外一个全局变量<code>ncpus</code>里，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span>    ncpus;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>ncpus</code>等于1，则有且仅有一个arena，如果大于1，则默认arenas的数量为<code>ncpus</code>的四倍。即双核下8个arena，四核下16个arena，依此类推。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p ncpus</span><br><span class="line">$<span class="number">20</span> = <span class="number">4</span></span><br><span class="line">(gdb) p narenas_total</span><br><span class="line">$<span class="number">21</span> = <span class="number">16</span></span><br></pre></td></tr></table></figure></p>
<p>jemalloc变体很多，不同变体对arenas的数量有所调整，比如firefox中arena固定为1，而android被限定为最大不超过2. 这个限制被写到android jemalloc的mk文件中。</p>
<h4 id="2-2-3-choose-arena"><a href="#2-2-3-choose-arena" class="headerlink" title="2.2.3 - choose_arena"></a>2.2.3 - choose_arena</h4><p>最早引入arena并非由Je首创，但早期线程与arena绑定是通过hash线程id实现的，相对来说随机性比较强。Je改进了绑定的算法，使之更加科学合理。</p>
<p>Je中线程与arena绑定由函数<code>choose_arena</code>完成，被绑定的arena记录在该线程的tls中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="type">arena_t</span> *</span><br><span class="line"><span class="title function_">choose_arena</span><span class="params">(<span class="type">arena_t</span> *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">// xf: 通常情况下线程所绑定的arena记录在arenas_tls中</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = *arenas_tsd_get()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// xf: 如果当前thread未绑定arena，则为其指定一个，并保存到tls</span></span><br><span class="line">        ret = choose_arena_hard();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初次搜索<code>arenas_tsd_get</code>可能找不到该函数在何处被定义。实际上，Je使用了一组宏，来生成一个函数族，以达到类似函数模板的目的。<code>tsd</code>相关的函数族被定义在<code>tsd.h</code>中。</p>
<ol>
<li><code>malloc_tsd_protos</code> - 定义了函数声明，包括初始化函数boot, get/set函数</li>
<li><code>malloc_tsd_externs</code> - 定义变量声明，包括tls，初始化标志等等</li>
<li><code>malloc_tsd_data</code> - tls变量定义</li>
<li><code>malloc_tsd_funcs</code> - 定义了1中声明函数的实现。</li>
</ol>
<p>与<code>arena tsd</code>相关的函数和变量声明如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">malloc_tsd_protos(JEMALLOC_ATTR(unused), arenas, <span class="type">arena_t</span> *)</span><br><span class="line">malloc_tsd_externs(arenas, <span class="type">arena_t</span> *)</span><br><span class="line">malloc_tsd_data(, arenas, <span class="type">arena_t</span> *, <span class="literal">NULL</span>)</span><br><span class="line">malloc_tsd_funcs(JEMALLOC_ALWAYS_INLINE, arenas, <span class="type">arena_t</span> *, <span class="literal">NULL</span>, arenas_cleanup)</span><br></pre></td></tr></table></figure></p>
<p>当线程还未与任何arena绑定时，会进一步通过<code>choose_arena_hard</code>寻找一个合适的<code>arena</code>进行绑定。Je会遍历arenas数组，并按照优先级由高到低的顺序挑选，</p>
<ol>
<li>如果找到当前线程绑定数为0的arena，则优先使用它。</li>
<li>如果当前已初始化arena中没有线程绑定数为0的，则优先使用剩余空的数组位置构造一个新的arena. 需要说明的是，arenas数组遵循lazy create原则，初始状态整个数组只有0号元素是被初始化的，其他的slot位置都是null指针。因此随着新的线程不断创造出来，arena数组也被逐渐填满。</li>
<li>如果1，2两条都不满足，则选择当前绑定数最小的，且slot位置更靠前的一个arena。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_t</span> * <span class="title function_">choose_arena_hard</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (narenas_auto &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        first_null = narenas_auto;</span><br><span class="line">        <span class="comment">// xf: 循环遍历所有arenas，找到绑定thread数量最小的arena，并记录</span></span><br><span class="line">        <span class="comment">// first_null索引值</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; narenas_auto; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arenas[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arenas[i]-&gt;nthreads &lt;</span><br><span class="line">                    arenas[choose]-&gt;nthreads)</span><br><span class="line">                    choose = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first_null == narenas_auto) &#123;</span><br><span class="line">                first_null = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 若选定的arena绑定thread为0，或者当前arena数组中已满，则返回</span></span><br><span class="line">        <span class="comment">// 被选中的arena</span></span><br><span class="line">        <span class="keyword">if</span> (arenas[choose]-&gt;nthreads == <span class="number">0</span></span><br><span class="line">            || first_null == narenas_auto) &#123;</span><br><span class="line">            ret = arenas[choose];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// xf: 否则构造并初始化一个新的arena</span></span><br><span class="line">            ret = arenas_extend(first_null);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// xf: 若不存在多于一个arena(单核cpu或人为强制设定)，则返回唯一的</span></span><br><span class="line">        <span class="comment">// 0号arena</span></span><br><span class="line">        ret = arenas[<span class="number">0</span>];</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 将已绑定的arena设置到tsd中</span></span><br><span class="line">    arenas_tsd_set(&amp;ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比早期的绑定方式，Je的算法显然更加公平，尽可能的让各个cpu核心平分当前线程，平衡负载。</p>
<h4 id="2-2-4-Arena结构"><a href="#2-2-4-Arena结构" class="headerlink" title="2.2.4 - Arena结构"></a>2.2.4 - Arena结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_s</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span>        ind;        </span><br><span class="line">    <span class="type">unsigned</span>        nthreads;   </span><br><span class="line">    <span class="type">malloc_mutex_t</span>        lock;</span><br><span class="line">    <span class="type">arena_stats_t</span>        stats;  </span><br><span class="line">    ql_head(<span class="type">tcache_t</span>)    tcache_ql;</span><br><span class="line">    <span class="type">uint64_t</span>        prof_accumbytes;</span><br><span class="line">    <span class="type">dss_prec_t</span>        dss_prec;   </span><br><span class="line">    <span class="type">arena_chunk_tree_t</span>    chunks_dirty;</span><br><span class="line">    <span class="type">arena_chunk_t</span>        *spare;</span><br><span class="line">    <span class="type">size_t</span>            nactive;</span><br><span class="line">    <span class="type">size_t</span>            ndirty;</span><br><span class="line">    <span class="type">size_t</span>            npurgatory;</span><br><span class="line">    <span class="type">arena_avail_tree_t</span>    runs_avail;</span><br><span class="line">    <span class="type">chunk_alloc_t</span>        *chunk_alloc;</span><br><span class="line">    <span class="type">chunk_dalloc_t</span>        *chunk_dalloc;</span><br><span class="line">    <span class="type">arena_bin_t</span>        bins[NBINS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ind</code>: 在arenas数组中的索引值。</li>
<li><code>nthreads</code>: 当前绑定的线程数。</li>
<li><code>lock</code>: 局部arena lock，取代传统分配器的global lock。一般地，如下操作需要arena lock同步，<ul>
<li>线程绑定，需要修改nthreads</li>
<li>new chunk alloc</li>
<li>new run alloc</li>
</ul>
</li>
<li><code>stats</code>: 全局统计，需要打开统计功能。</li>
<li><code>tcache_ql</code>: ring queue，注册所有绑定线程的tcache，作为统计用途，需要打开统计功能。</li>
<li><code>dss_prec</code>: 代表当前chunk alloc时对系统内存的使用策略，分为几种情况，　　　　　</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  dss_prec_disabled  = <span class="number">0</span>,</span><br><span class="line">  dss_prec_primary   = <span class="number">1</span>,</span><br><span class="line">  dss_prec_secondary = <span class="number">2</span>,</span><br><span class="line">  dss_prec_limit     = <span class="number">3</span></span><br><span class="line">&#125; <span class="type">dss_prec_t</span>;</span><br></pre></td></tr></table></figure>
<p>第一个代表禁止使用系统DSS，后两种代表是否优先选用DSS。如果使用<code>primary</code>，则本着先<code>dss-&gt;mmap</code>的顺序，否则按照先<code>mmap-&gt;dss</code>。默认使用<code>dss_prec_secondary</code>。</p>
<ul>
<li><code>chunks_dirty</code>: rb tree，代表所有包含dirty page的chunk集合。后面在chunk中会详细介绍。</li>
<li><code>spare</code>: 是一个缓存变量，记录最近一次被释放的chunk。当arena收到一个新的chunk alloc请求时，会优先从spare中开始查找，由此提高频繁分配释放时，可能导致内部chunk利用率下降的情况。</li>
<li><code>runs_avail</code>: rb tree，记录所有未被分配的runs，用来在分配new run时寻找合适的available run。一般作为alloc run时的仓库。</li>
<li><code>chunk_alloc</code>/<code>chunk_dalloc</code>: 用户可定制的chunk分配/释放函数，Je提供了默认的版本，<code>chunk_alloc_default</code>/<code>chunk_dalloc_default</code></li>
<li><code>bins</code>: bins数组，记录不同class size可用free regions的分配信息，后面会详细介绍。</li>
</ul>
<h3 id="2-3-Chunk-arena-chunk-t"><a href="#2-3-Chunk-arena-chunk-t" class="headerlink" title="2.3 - Chunk (arena_chunk_t)"></a>2.3 - Chunk (arena_chunk_t)</h3><p>chunk是仅次于arena的次级内存结构。如果有了解过Dlmalloc，就会知道在Dl中同样定义了名为’chunk’的基础结构。但这个概念在两个分配器中含义完全不同，Dl中的chunk指代最低级分配单元，而Je中则是一个较大的内存区域。</p>
<h4 id="2-3-1-overview"><a href="#2-3-1-overview" class="headerlink" title="2.3.1 - overview"></a>2.3.1 - overview</h4><p>从前面arena的数据结构可以发现，它是一个非常抽象的概念，其大小也不代表实际的内存分配量。原始的内存数据既非挂载在arena外部，也并没有通过内部指针引用，而是记录在chunk中。按照一般的思路，chunk包含原始内存数据，又从属于arena，因此后者应该会有一个数组之类的结构以记录所有chunk信息。但事实上同样找不到这样的记录。那Je又如何获得chunk指针呢?</p>
<p>所谓的chunk结构，只是整个chunk的一个header，bookkeeping以及user memory都挂在header外面。另外Je对chunk又做了规定，默认每个chunk大小为4MB，同时还必须对齐到4MB的边界上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    LG_CHUNK_DEFAULT    22</span></span><br></pre></td></tr></table></figure></p>
<p>这个宏定义了chunk的大小。注意到前缀<code>LG_</code>，代表log即指数部分。Je中所有该前缀的代码都是这个含义，便于通过bit操作进行快速的运算。</p>
<p>有了上述规定，获得chunk就变得几乎没有代价。因为返回给user程序的内存地址肯定属于某个chunk，而该chunk header对齐到4M边界上，且不可能超过4M大小，所以只需要对该地址做一个下对齐就得到chunk指针，如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    CHUNK_ADDR2BASE(a)                        \</span></span><br><span class="line"><span class="meta">    ((void *)((uintptr_t)(a) &amp; ~chunksize_mask))</span></span><br></pre></td></tr></table></figure></p>
<p>计算相对于chunk header的偏移量，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    CHUNK_ADDR2OFFSET(a)                        \</span></span><br><span class="line"><span class="meta">    ((size_t)((uintptr_t)(a) &amp; chunksize_mask))</span></span><br></pre></td></tr></table></figure></p>
<p>以及上对齐到chunk边界的计算，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    CHUNK_CEILING(s)                        \</span></span><br><span class="line"><span class="meta">    (((s) + chunksize_mask) &amp; ~chunksize_mask)</span></span><br></pre></td></tr></table></figure></p>
<p>用图来表示如下，  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chunk_ptr(4M aligned)                memory for user</span><br><span class="line"> |                                   |</span><br><span class="line"> v                                   v</span><br><span class="line"> +--------------+--------------------------------------------</span><br><span class="line"> | chunk header |        ... ...     | region |   ... ...     </span><br><span class="line"> +--------------+--------------------------------------------</span><br><span class="line"> |&lt;------------- offset ------------&gt;|</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-Chunk结构"><a href="#2-3-2-Chunk结构" class="headerlink" title="2.3.2 - Chunk结构"></a>2.3.2 - Chunk结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_chunk_s</span> &#123;</span></span><br><span class="line">    <span class="type">arena_t</span>            *arena;</span><br><span class="line">    rb_node(<span class="type">arena_chunk_t</span>)    dirty_link;</span><br><span class="line">    <span class="type">size_t</span>            ndirty;</span><br><span class="line">    <span class="type">size_t</span>            nruns_avail;</span><br><span class="line">    <span class="type">size_t</span>            nruns_adjac;</span><br><span class="line">    <span class="type">arena_chunk_map_t</span>    <span class="built_in">map</span>[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>arena</code>: chunk属于哪个arena</li>
<li><code>dirty_link</code>: 用于rb tree的链接节点。如果某个chunk内部含有任何dirty page，就会被挂载到arena中的chunks_dirty tree上。</li>
<li><code>ndirty</code>: 内部dirty page数量。</li>
<li><code>nruns_avail</code>: 内部available runs数量。</li>
<li><code>nruns_adjac</code>: available runs又分为dirty和clean两种，相邻的两种run是无法合并的，除非其中的dirty runs通过purge才可以。该数值记录的就是可以通过purge合并的run数量。</li>
<li><code>map</code>: 动态数组，每一项对应chunk中的一个page状态(不包含header即map本身的占用)。chunk(包括内部的run)都是由page组成的。<ul>
<li>page又分为unallocated，small，large三种。</li>
<li>unallocated指的那些还未建立run的page。</li>
<li>small/large分别指代该page所属run的类型是small/large run。</li>
<li>这些page的分配状态，属性，偏移量，及其他的标记信息等等，都记录在arena_chunk_map_t中。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|&lt;--------- map_bias -----------&gt;|</span><br><span class="line">| page | page |  ... ...  | page |</span><br><span class="line">+-----------------------------------------------------------------------+</span><br><span class="line">| chunk_header |    chunk <span class="built_in">map</span>    | page #<span class="number">0</span>  | page #<span class="number">1</span>  | ... | page <span class="meta">#n  |</span></span><br><span class="line">|    ... ...   | [<span class="number">0</span>] [<span class="number">1</span>] ... [n] |          |          |     |          |</span><br><span class="line">+-----------------|---|-------|-----------------------------------------+</span><br><span class="line">                  |   |       |       ^          ^                 ^</span><br><span class="line">                  +---|-------|-------+          |                 |</span><br><span class="line">                      +-------|------------------+                 |</span><br><span class="line">                              + -----------------------------------+</span><br></pre></td></tr></table></figure>
<p>至于由chunk header和chunk map占用的page数量，保存在map_bias变量中。该变量是Je在arena boot时通过迭代算法预先计算好的，所有chunk都是相同的。迭代方法如下，</p>
<ol>
<li>第一次迭代初始map_bias等于0，计算最大可能大小，即<code>header_size + chunk_npages * map_size</code>获得header+map需要的page数量，结果肯定高于最终的值。</li>
<li>第二次将之前计算的map_bias迭代回去，将最大page数减去map_bias数，重新计算header+map大小，由于第一次迭代map_bias过大，第二次迭代必定小于最终结果。</li>
<li>第三次再将map_bias迭代回去，得到最终大于第二次且小于第一次的计算结果。</li>
</ol>
<p>相关代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_boot</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    map_bias = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        header_size = offsetof(<span class="type">arena_chunk_t</span>, <span class="built_in">map</span>) +</span><br><span class="line">            (<span class="keyword">sizeof</span>(<span class="type">arena_chunk_map_t</span>) * (chunk_npages-map_bias));</span><br><span class="line">        map_bias = (header_size &gt;&gt; LG_PAGE) + ((header_size &amp; PAGE_MASK)</span><br><span class="line">            != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-chunk-map-arena-chunk-map-t"><a href="#2-3-3-chunk-map-arena-chunk-map-t" class="headerlink" title="2.3.3 - chunk map (arena_chunk_map_t)"></a>2.3.3 - chunk map (arena_chunk_map_t)</h4><p>chunk记录page状态的结构为<code>arena_chunk_map_t</code>，为了节省空间，使用了bit压缩存储信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_chunk_map_s</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JEMALLOC_PROF</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        rb_node(<span class="type">arena_chunk_map_t</span>)    rb_link;</span><br><span class="line">        ql_elm(<span class="type">arena_chunk_map_t</span>)    ql_link;</span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="type">prof_ctx_t</span>            *prof_ctx;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JEMALLOC_PROF</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">size_t</span>                bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chunk map内部包含两个link node，分别可以挂载到rb tree或环形队列上，同时为了节省空间又使用了union。由于run本身也是由连续page组成的，因此chunk map除了记录page状态之外，还负责run的基址检索。</p>
<p>举例来说，Je会把所有已分配run记录在内部rb tree上以快速检索，实际地操作是将该run中第一个page对应的chunk_map作为rb node挂载到tree上。检索时也是先找出将相应的chunk map，再进行地址转换得到run的基址。</p>
<p>按照通常的设计思路，我们可能会把run指针作为节点直接保存到rb tree中。但Je中的设计明显要更复杂。究其原因，如果把link node放到run中，后果是bookkeeping和user memory将混淆在一起，这对于分配器的安全性是很不利的。包括Dl在内的传统分配器都具有这样的缺陷。而如果单独用link node记录run，又会造成空间浪费。</p>
<p>正因为Je中无论是chunk还是run都是连续page组成，所以用首个page对应的chunk map就能同时代表该run的基址。</p>
<p>Je中通常用mapelm换算出pageind，再将<code>pageind &lt;&lt; LG_PAGE + chunk_base</code>，就能得到run指针，代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_chunk_t</span> *run_chunk = CHUNK_ADDR2BASE(mapelm);</span><br><span class="line"><span class="type">size_t</span> pageind = arena_mapelm_to_pageind(mapelm);</span><br><span class="line">run = (<span class="type">arena_run_t</span> *)((<span class="type">uintptr_t</span>)run_chunk + (pageind &lt;&lt;</span><br><span class="line">    LG_PAGE));</span><br><span class="line"></span><br><span class="line">JEMALLOC_INLINE_C <span class="type">size_t</span></span><br><span class="line"><span class="title function_">arena_mapelm_to_pageind</span><span class="params">(<span class="type">arena_chunk_map_t</span> *mapelm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uintptr_t</span> map_offset =</span><br><span class="line">        CHUNK_ADDR2OFFSET(mapelm) - offsetof(<span class="type">arena_chunk_t</span>, <span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((map_offset / <span class="keyword">sizeof</span>(<span class="type">arena_chunk_map_t</span>)) + map_bias);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chunk map对page状态描述都压缩记录到bits中，由于内容较多，直接引用Je代码中的注释，</p>
<ul>
<li>下面是一个假想的ILP32系统下的bits layout,</li>
<li>???????? ???????? ????nnnn nnnndula</li>
<li>“?”的部分分三种情况，分别对应unallocated, small和large.<ul>
<li>Unallocated: 首尾page写入该run的地址，而内部page则不做要求。</li>
<li>Small: 全部是page的偏移量。</li>
<li>Large: 首page是run size，后续的page不做要求。</li>
</ul>
</li>
<li>n : 对于small run指其所在bin的index，对large run写入BININD_INVALID.</li>
<li>d : dirty?</li>
<li>u : unzeroed?</li>
<li>l : large?</li>
<li><p>a : allocated?</p>
</li>
<li><p>下面是对三种类型的run page做的举例，</p>
<ul>
<li>p : run page offset</li>
<li>s : run size</li>
<li>n : binind for size class; large objects set these to BININD_INVALID</li>
<li>x : don’t care</li>
<li><ul>
<li>: 0</li>
</ul>
</li>
<li><ul>
<li>: 1</li>
</ul>
</li>
<li>[DULA] : bit set</li>
<li>[dula] : bit unset</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Unallocated (clean):</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++du-a</span><br><span class="line">  xxxxxxxx xxxxxxxx xxxxxxxx xxxx-Uxx</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++dU-a</span><br><span class="line"></span><br><span class="line">Unallocated (dirty):</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++D--a</span><br><span class="line">  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++D--a</span><br><span class="line"></span><br><span class="line">Small:      </span><br><span class="line">  pppppppp pppppppp ppppnnnn nnnnd--A</span><br><span class="line">  pppppppp pppppppp ppppnnnn nnnn---A</span><br><span class="line">  pppppppp pppppppp ppppnnnn nnnnd--A</span><br></pre></td></tr></table></figure>
<p>Small page需要注意的是，这里代表的p并非是一个固定值，而是该page相对于其所在run的第一个page的偏移量，比如可能是这样，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  00000000 00000000 0000nnnn nnnnd--A</span><br><span class="line">  00000000 00000000 0001nnnn nnnn---A</span><br><span class="line">  00000000 00000000 0010nnnn nnnn---A</span><br><span class="line">  00000000 00000000 0011nnnn nnnn---A</span><br><span class="line">  ...</span><br><span class="line">  00000000 00000001 1010nnnn nnnnd--A</span><br><span class="line"></span><br><span class="line">Large:</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++D-LA</span><br><span class="line">  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span><br><span class="line">  -------- -------- ----++++ ++++D-LA</span><br><span class="line"></span><br><span class="line">Large (sampled, size &lt;= PAGE):</span><br><span class="line">  ssssssss ssssssss ssssnnnn nnnnD-LA</span><br><span class="line"></span><br><span class="line">Large (not sampled, size == PAGE):</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++D-LA</span><br></pre></td></tr></table></figure></p>
<p>为了提取/设置map bits内部的信息，Je提供了一组函数，这里列举两个最基本的，剩下的都是读取mapbits后做一些位运算而已，</p>
<p>读取mapbits<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">size_t</span></span><br><span class="line"><span class="title function_">arena_mapbits_get</span><span class="params">(<span class="type">arena_chunk_t</span> *chunk, <span class="type">size_t</span> pageind)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (arena_mapbitsp_read(arena_mapbitsp_get(chunk, pageind)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据pageind获取对应的chunk map<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">arena_chunk_map_t</span> *</span><br><span class="line"><span class="title function_">arena_mapp_get</span><span class="params">(<span class="type">arena_chunk_t</span> *chunk, <span class="type">size_t</span> pageind)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (&amp;chunk-&gt;<span class="built_in">map</span>[pageind-map_bias]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-Run-arena-run-t"><a href="#2-4-Run-arena-run-t" class="headerlink" title="2.4 - Run (arena_run_t)"></a>2.4 - Run (arena_run_t)</h3><p>如同在2.1节所述，在Je中run才是真正负责分配的主体(前提是对small region来说)。run的大小对齐到page size上，并且在内部划分成大小相同的region。当有外部分配请求时，run就会从内部挑选一个free region返回。可以认为run就是small region仓库。</p>
<h4 id="2-4-1-Run结构"><a href="#2-4-1-Run结构" class="headerlink" title="2.4.1 - Run结构"></a>2.4.1 - Run结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_run_s</span> &#123;</span></span><br><span class="line">    <span class="type">arena_bin_t</span>    *bin;</span><br><span class="line">    <span class="type">uint32_t</span>    nextind;</span><br><span class="line">    <span class="type">unsigned</span>    nfree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>run的结构非常简单，但同chunk类似，所谓的arena_run_t不过是整个run的header部分。</p>
<ul>
<li><code>bin</code>:     与该run相关联的bin。每个run都有其所属的bin，详细内容在之后介绍。</li>
<li><code>nextind</code>: 记录下一个clean region的索引。</li>
<li><code>nfree</code>:   记录当前空闲region数量。</li>
</ul>
<p>除了header部分之外，run的真实layout如下，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">              /--------------------\</span><br><span class="line">              | arena_run_t header |</span><br><span class="line">              | ...                |</span><br><span class="line">bitmap_offset | bitmap             |</span><br><span class="line">              | ...                |</span><br><span class="line">              |--------------------|</span><br><span class="line">              | redzone            |</span><br><span class="line">  reg0_offset | region 0           |</span><br><span class="line">              | redzone            |</span><br><span class="line">              |--------------------| \</span><br><span class="line">              | redzone            |  |</span><br><span class="line">              | region 1           |  &gt; reg_interval</span><br><span class="line">              | redzone            | /</span><br><span class="line">              |--------------------|</span><br><span class="line">              | ...                |</span><br><span class="line">              | ...                |</span><br><span class="line">              | ...                |</span><br><span class="line">              |--------------------|</span><br><span class="line">              | redzone            |</span><br><span class="line">              | region nregs-1     |</span><br><span class="line">              | redzone            |</span><br><span class="line">              |--------------------|</span><br><span class="line">              | alignment pad?     |</span><br><span class="line">              \--------------------/</span><br></pre></td></tr></table></figure></p>
<p>正如chunk通过chunk map记录内部所有page状态一样，run通过在header后挂载bitmap来记录其内部的region状态。bitmap之后是regions区域。内部region大小相等，且在前后都有redzone保护(需要在设置里打开redzone选项)。</p>
<p>简单来说，run就是通过查询bitmap来找到可用的region。而传统分配器由于使用boundary tag，空闲region一般是被双向链表管理的。相比之下，传统方式查找速度更快，也更简单。缺点之前也提到过，安全和稳定性都存在缺陷。从这一点可以看到，Je在设计思路上将bookkeeping和user memory分离是贯穿始终的原则，更甚于对性能的影响(事实上这点影响在并发条件下被大大赚回来了).</p>
<h4 id="2-4-2-size-classes"><a href="#2-4-2-size-classes" class="headerlink" title="2.4.2 - size classes"></a>2.4.2 - size classes</h4><p>内存分配器对内部管理的region往往按照某种特殊规律来分配。比如Dl将内存划分成small和large两种类型。small类型从8字节开始每8个字节为一个分割直至256字节。而large类型则从256字节开始，挂载到dst上。这种划分方式有助于分配器对内存进行有效的管理和控制，让已分配的内存更加紧实(tightly packed)，以降低外部碎片率。</p>
<p>Je进一步优化了分配效率。采用了类似于”二分伙伴(Binary Buddy)算法”的分配方式。在Je中将不同大小的类型称为size class。</p>
<p>在Je源码的size_classes.h文件中，定义了不同体系架构下的region size。该文件实际是通过名为size_classes.sh的shell script自动生成的。script按照四种不同量纲定义来区分各个体系平台的区别，然后将它们做排列组合，就可以兼容各个体系。这四种量纲分别是，</p>
<ul>
<li><code>LG_SIZEOF_PTR</code>: 代表指针长度，ILP32下是2, LP64则是3.</li>
<li><code>LG_QUANTUM</code>: 量子，binary buddy分得的最小单位。除了tiny size，其他的size classes都是quantum的整数倍大小。</li>
<li><code>LG_TINY_MIN</code>: 是比quantum更小的size class，且必须对齐到2的指数倍上。它是Je可分配的最小的size class.</li>
<li><code>LG_PAGE</code>: 就是page大小</li>
</ul>
<p>根据binary buddy算法，Je会将内存不断的二平分，每一份称作一个group。同一个group内又做四等分。例如，一个典型的ILP32, tiny等于8byte, quantum为16byte，page为4096byte的系统，其size classes划分是这样的，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#if (LG_SIZEOF_PTR == 2 &amp;&amp; LG_TINY_MIN == 3 &amp;&amp; LG_QUANTUM == 4 &amp;&amp; LG_PAGE == 12)</span><br><span class="line">#define    SIZE_CLASSES \</span><br><span class="line">    index, lg_grp, lg_delta, ndelta,  bin, lg_delta_lookup  \</span><br><span class="line">    SC(  0,      3,        3,      0,   yes,        3) \        </span><br><span class="line">                                                       \</span><br><span class="line">    SC(  1,      3,        3,      1,   yes,        3) \        </span><br><span class="line">    SC(  2,      4,        4,      1,   yes,        4) \        </span><br><span class="line">    SC(  3,      4,        4,      2,   yes,        4) \        </span><br><span class="line">    SC(  4,      4,        4,      3,   yes,        4) \        </span><br><span class="line">                                                       \</span><br><span class="line">    SC(  5,      6,        4,      1,   yes,        4) \        </span><br><span class="line">    SC(  6,      6,        4,      2,   yes,        4) \        </span><br><span class="line">    SC(  7,      6,        4,      3,   yes,        4) \        </span><br><span class="line">    SC(  8,      6,        4,      4,   yes,        4) \        </span><br><span class="line">                                                       \</span><br><span class="line">    SC(  9,      7,        5,      1,   yes,        5) \        </span><br><span class="line">    SC( 10,      7,        5,      2,   yes,        5) \        </span><br><span class="line">    SC( 11,      7,        5,      3,   yes,        5) \        </span><br><span class="line">    SC( 12,      7,        5,      4,   yes,        5) \        </span><br><span class="line">                                                       </span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure>
<p>宏SIZE_CLASSES主要功能就是可以生成几种类型的table。而SC则根据不同的情况被定义成不同的含义。SC传入的6个参数的含义如下，</p>
<ul>
<li><code>index</code>:      在table中的位置</li>
<li><code>lg_grp</code>:     所在group的指数</li>
<li><code>lg_delta</code>:   group内偏移量指数</li>
<li><code>ndelta</code>:     group内偏移数</li>
<li><code>bin</code>:        是否由bin记录。small region是记录在bins中</li>
<li><code>lg_delta_lookup</code>:    在lookup table中的调用S2B_#的尾数后缀</li>
</ul>
<p>因此得到reg_size的计算公式，<code>reg_size = 1 &lt;&lt; lg_grp + ndelta &lt;&lt; lg_delta</code>根据该公式，可以得到region的范围，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌─────────┬─────────┬───────────────────────────────────────┐</span><br><span class="line">│Category │ Spacing │ Size                                  │</span><br><span class="line">├─────────┼─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │      lg │ [8]                                   │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │      16 │ [16, 32, 48, ..., 128]                │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │      32 │ [160, 192, 224, 256]                  │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│Small    │      64 │ [320, 384, 448, 512]                  │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │     128 │ [640, 768, 896, 1024]                 │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │     256 │ [1280, 1536, 1792, 2048]              │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │     512 │ [2560, 3072, 3584]                    │</span><br><span class="line">├─────────┼─────────┼───────────────────────────────────────┤</span><br><span class="line">│Large    │   4 KiB │ [4 KiB, 8 KiB, 12 KiB, ..., 4072 KiB] │</span><br><span class="line">├─────────┼─────────┼───────────────────────────────────────┤</span><br><span class="line">│Huge     │   4 MiB │ [4 MiB, 8 MiB, 12 MiB, ...]           │</span><br><span class="line">└─────────┴─────────┴───────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>除此之外，在<code>size_classes.h</code>中还定义了一些常量，</p>
<p>tiny bins的数量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    NTBINS            1</span></span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">可以通过lookup table查询的bins数量</span><br><span class="line">```C</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    NLBINS            29</span></span><br></pre></td></tr></table></figure></p>
<p>small bins的数量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    NBINS            28</span></span><br></pre></td></tr></table></figure></p>
<p>最大tiny size class的指数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    LG_TINY_MAXCLASS    3</span></span><br></pre></td></tr></table></figure></p>
<p>最大lookup size class，也就是NLBINS - 1个bins<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    LOOKUP_MAXCLASS        ((((size_t)1) &lt;&lt; 11) + (((size_t)4) &lt;&lt; 9))</span></span><br></pre></td></tr></table></figure></p>
<p>最大small size class，也就是NBINS - 1个bins<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    SMALL_MAXCLASS        ((((size_t)1) &lt;&lt; 11) + (((size_t)3) &lt;&lt; 9))</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-4-3-size2bin-bin2size"><a href="#2-4-3-size2bin-bin2size" class="headerlink" title="2.4.3 - size2bin/bin2size"></a>2.4.3 - size2bin/bin2size</h4><p>通过SIZE_CLASSES建立的table就是为了在O(1)的时间复杂度内快速进行size2bin或者bin2size切换。同样的技术在Dl中有所体现，来看Je是如何实现的。</p>
<p>size2bin切换提供了两种方式，较快的是通过查询lookup table，较慢的是计算得到。从原理上，只有small size class需要查找bins，但可通过lookup查询的size class数量要小于整个small size class数量。因此，部分size class只能计算得到。在原始Je中统一只采用查表法，但在android版本中可能是考虑减小lookup table size，而增加了直接计算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">size_t</span></span><br><span class="line"><span class="title function_">small_size2bin</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= LOOKUP_MAXCLASS)</span><br><span class="line">        <span class="keyword">return</span> (small_size2bin_lookup(size));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (small_size2bin_compute(size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小于LOOKUP_MAXCLASS的请求通过small_size2bin_lookup直接查表。查询的算法是这样的，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> ret = ((<span class="type">size_t</span>)(small_size2bin_tab[(size<span class="number">-1</span>) &gt;&gt; LG_TINY_MIN]));</span><br></pre></td></tr></table></figure></p>
<p>也就是说，Je通过一个<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x) = (x - <span class="number">1</span>) / <span class="number">2</span>^LG_TINY_MIN</span><br></pre></td></tr></table></figure></p>
<p>的变换将size映射到lookup table的相应区域。这个table在gdb中可能是这样的，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p  /d small_size2bin</span><br><span class="line">$6 = &#123;0, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10,</span><br><span class="line">      11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14,</span><br><span class="line">      14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16,</span><br><span class="line">      16, 16, 17 &lt;repeats 16 times&gt;, 18 &lt;repeats 16 times&gt;, 19 &lt;repeats 16 times&gt;,</span><br><span class="line">      20 &lt;repeats 16 times&gt;, 21 &lt;repeats 32 times&gt;, 22 &lt;repeats 32 times&gt;,</span><br><span class="line">      23 &lt;repeats 32 times&gt;, 24 &lt;repeats 32 times&gt;, 25 &lt;repeats 64 times&gt;,</span><br><span class="line">      26 &lt;repeats 64 times&gt;, 27 &lt;repeats 64 times&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>该数组的含义与binary buddy算法是一致的。对应的bin index越高，其在数组中占用的字节数就越多。除了0号bin之外，相邻的4个bin属于同一group，两个group之间相差二倍，因此在数组中占用的字节数也就相差2倍。所以，上面数组的group划分如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;, &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;, ...</span><br></pre></td></tr></table></figure></p>
<p>以bin#9为例，其所管辖的范围(128, 160]，由于其位于更高一级group，因此相比bin#8在lookup table中多一倍的字节数，假设我们需要查询132，经过映射，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">132</span> - <span class="number">1</span>) &gt;&gt; <span class="number">3</span> = <span class="number">16</span></span><br></pre></td></tr></table></figure></p>
<p>这样可以快速得到其所在的bin #9。如图，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    bin #1     bin #3          132 is HERE!</span><br><span class="line">       |          |                |</span><br><span class="line">       v          v                v</span><br><span class="line"> +----------------------------------------------------------------</span><br><span class="line"> | 0 | 1 | 2 2 | 3 3 | ... | 8 8 | 9 9 9 9 | ... | 16 ... 16 | ...</span><br><span class="line"> +----------------------------------------------------------------</span><br><span class="line">   ^        ^                 ^       ^                ^</span><br><span class="line">   |        |                 |       |                |</span><br><span class="line">bin #0    bin #2            bin #8  bin #9          bin #16 </span><br></pre></td></tr></table></figure>
<p>Je巧妙的通过前面介绍CLASS_SIZE宏生成了这个lookup table，代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALIGNED(CACHELINE)</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span>    small_size2bin_tab[] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_3(i)    i,</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_4(i)    S2B_3(i) S2B_3(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_5(i)    S2B_4(i) S2B_4(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_6(i)    S2B_5(i) S2B_5(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_7(i)    S2B_6(i) S2B_6(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_8(i)    S2B_7(i) S2B_7(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_9(i)    S2B_8(i) S2B_8(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    S2B_no(i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup) \</span></span><br><span class="line"><span class="meta">    S2B_##lg_delta_lookup(index)</span></span><br><span class="line">    SIZE_CLASSES</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_3</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_4</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_8</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> S2B_no</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> SC</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的S2B_xx是一系列宏的嵌套展开，最终对应的就是不同group在lookup table中占据的字节数以及bin索引。相信看懂了前面的介绍就不难理解。</p>
<p>另一方面，大于LOOKUP_MAXCLASS但小于SMALL_MAXCLASS的size class不能查表获得，需要进行计算。简言之，一个bin number是三部分组成的，</p>
<p><code>bin_number = NTBIN + group_number &lt;&lt; LG_SIZE_CLASS_GROUP + mod</code></p>
<p>即tiny bin数量加上其所在group再加上group中的偏移(0-2)。源码如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="type">size_t</span></span><br><span class="line"><span class="title function_">small_size2bin_compute</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// xf: lg_floor相当于ffs</span></span><br><span class="line">        <span class="type">size_t</span> x = lg_floor((size&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 计算size class所在group number</span></span><br><span class="line">        <span class="type">size_t</span> shift = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? <span class="number">0</span> :</span><br><span class="line">            x - (LG_SIZE_CLASS_GROUP + LG_QUANTUM);</span><br><span class="line">        <span class="type">size_t</span> grp = shift &lt;&lt; LG_SIZE_CLASS_GROUP;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> lg_delta = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM + <span class="number">1</span>)</span><br><span class="line">            ? LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> delta_inverse_mask = ZI(<span class="number">-1</span>) &lt;&lt; lg_delta;</span><br><span class="line">        <span class="comment">// xf: 计算剩余mod部分</span></span><br><span class="line">        <span class="type">size_t</span> mod = ((((size<span class="number">-1</span>) &amp; delta_inverse_mask) &gt;&gt; lg_delta)) &amp;</span><br><span class="line">            ((ZU(<span class="number">1</span>) &lt;&lt; LG_SIZE_CLASS_GROUP) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 组合计算bin number</span></span><br><span class="line">        <span class="type">size_t</span> bin = NTBINS + grp + mod;</span><br><span class="line">        <span class="keyword">return</span> (bin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中LG_SIZE_CLASS_GROUP是size_classes.h中的定值，代表一个group中包含的bin数量，根据binary buddy算法，该值通常情况下是2。而要找到size class所在的group，与其最高有效位相关。Je通过类似于ffs的函数<br>首先获得size的最高有效位x<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> x = lg_floor((size&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>);</span><br></pre></td></tr></table></figure></p>
<p>至于group number，则与quantum size有关。因为除了tiny class, quantum size位于group #0的第一个。因此不难推出，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group_number = <span class="number">2</span>^x / quantum_size / <span class="number">2</span>^LG_SIZE_CLASS_GROUP</span><br></pre></td></tr></table></figure></p>
<p>对应代码就是，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> shift = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? <span class="number">0</span> :</span><br><span class="line">        x - (LG_SIZE_CLASS_GROUP + LG_QUANTUM);</span><br></pre></td></tr></table></figure></p>
<p>而对应group起始位置就是，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> grp = shift &lt;&lt; LG_SIZE_CLASS_GROUP;</span><br></pre></td></tr></table></figure></p>
<p>至于mod部分，与之相关的是最高有效位之后的两个bit。Je在这里经过了复杂的位变换，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> lg_delta = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM + <span class="number">1</span>) ? LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - <span class="number">1</span>;</span><br><span class="line"><span class="type">size_t</span> delta_inverse_mask = ZI(<span class="number">-1</span>) &lt;&lt; lg_delta;</span><br><span class="line"><span class="type">size_t</span> mod = ((((size<span class="number">-1</span>) &amp; delta_inverse_mask) &gt;&gt; lg_delta)) &amp; ((ZU(<span class="number">1</span>) &lt;&lt; LG_SIZE_CLASS_GROUP) - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码直白的翻译，实际上就是要求得如下两个bit,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">                        1 0000</span><br><span class="line">                       10 0000</span><br><span class="line">                       11 0000</span><br><span class="line">group #0              100 0000</span><br><span class="line">-------------------------------------------------</span><br><span class="line">                                      +--+</span><br><span class="line">                      101 0000 - 1 = 1|00| 1111</span><br><span class="line">                      110 0000 - 1 = 1|01| 1111</span><br><span class="line">                      111 0000 - 1 = 1|10| 1111</span><br><span class="line">group #1             1000 0000 - 1 = 1|11| 1111</span><br><span class="line">                                      +--+</span><br><span class="line">--------------------------------------------------                                         </span><br><span class="line">                                      +--+</span><br><span class="line">                     1010 0000 - 1 = 1|00|1 1111    </span><br><span class="line">                     1100 0000 - 1 = 1|01|1 1111</span><br><span class="line">                     1110 0000 - 1 = 1|10|1 1111</span><br><span class="line">group #2            10000 0000 - 1 = 1|11|1 1111</span><br><span class="line">                                      +--+</span><br><span class="line">--------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>根据这个图示再去看Je的代码就不难理解了。mod的计算结果就是从0-3的数值。</p>
<p>而最终的结果是前面三部分的组合即，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> bin = NTBINS + grp + mod;</span><br></pre></td></tr></table></figure></p>
<p>而bin2size查询就简单得多。上一节介绍SIZE_CLASSES时提到过small region的计算公式，只需要根据该公式提前计算出所有bin对应的region size，直接查表即可。</p>
<h3 id="2-5-bins-arena-bin-t"><a href="#2-5-bins-arena-bin-t" class="headerlink" title="2.5 - bins (arena_bin_t)"></a>2.5 - bins (arena_bin_t)</h3><p>run是分配的执行者，而分配的调度者是bin。这个概念同Dl中的bin是类似的，但Je中bin要更复杂一些。直白地说，可以把bin看作non-full run的仓库，bin负责记录当前arena中某一个size class范围内所有non-full run的使用情况。当有分配请求时，arena查找相应size class的bin，找出可用于分配的run，再由run分配region。当然，因为只有small region分配需要run，所以bin也只对应small size class。</p>
<p>与bin相关的数据结构主要有两个，分别是arena_bin_t和arena_bin_info_t。在2.1.3中提到arena_t内部保存了一个bin数组，其中的成员就是arena_bin_t。其结构如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_bin_s</span> &#123;</span></span><br><span class="line">    <span class="type">malloc_mutex_t</span>        lock;    </span><br><span class="line">    <span class="type">arena_run_t</span>            *runcur;</span><br><span class="line">    <span class="type">arena_run_tree_t</span>    runs;</span><br><span class="line">    <span class="type">malloc_bin_stats_t</span>  stats;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>lock</code>: 该lock同arena内部的lock不同，主要负责保护current run。而对于run本身的分配和释放还是需要依赖arena lock。通常情况下，获得bin lock的前提是获得arena lock，但反之不成立。</li>
<li><code>runcur</code>: 当前可用于分配的run，一般情况下指向地址最低的non-full run，同一时间一个bin只有一个current run用于分配。</li>
<li><code>runs</code>: rb tree，记录当前arena中该bin对应size class的所有non-full runs。因为分配是通过current run完成的，所以也相当于current run的仓库。</li>
<li><code>stats</code>: 统计信息。</li>
</ul>
<p>另一个与bin相关的结构是arena_bin_info_t。与前者不同，bin_info保存的是arena_bin_t的静态信息，包括相对应size class run的bitmap offset，region size，region number，bitmap info等等(此类信息只要class size决定，就固定下来)。所有上述信息在Je中由全局数组arena_bin_info记录。因此与arena无关，全局仅保留一份。</p>
<p>arena_bin_info_t的定义如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_bin_info_s</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span>        reg_size;</span><br><span class="line">    <span class="type">size_t</span>        redzone_size;</span><br><span class="line">    <span class="type">size_t</span>        reg_interval;</span><br><span class="line">    <span class="type">size_t</span>        run_size;</span><br><span class="line">    <span class="type">uint32_t</span>    nregs;</span><br><span class="line">    <span class="type">uint32_t</span>    bitmap_offset;</span><br><span class="line">    <span class="type">bitmap_info_t</span>    bitmap_info;</span><br><span class="line">    <span class="type">uint32_t</span>    reg0_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>reg_size</code>: 与当前bin的size class相关联的region size.</li>
<li><code>reg_interval</code>: reg_size+redzone_size</li>
<li><code>run_size</code>: 当前bin的size class相关联的run size.</li>
<li><code>nregs</code>: 当前bin的size class相关联的run中region数量。</li>
<li><code>bitmap_offset</code>: 当前bin的size class相关联的run中bitmap偏移。</li>
<li><code>bitmap_info</code>: 记录当前bin的size class相关联的run中bitmap信息。</li>
<li><code>reg0_offset</code>: index为0的region在run中的偏移量。</li>
</ul>
<p>以上记录的静态信息中尤为重要的是bitmap_info和bitmap_offset.</p>
<p>其中bitmap_info_t定义如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap_info_s</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> nbits;</span><br><span class="line">    <span class="type">unsigned</span> nlevels;</span><br><span class="line">    <span class="type">bitmap_level_t</span> levels[BITMAP_MAX_LEVELS+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>nbits</code>: bitmap中逻辑bit位数量(特指level#0的bit数)</li>
<li><code>nlevels</code>: bitmap的level数量</li>
<li><code>levels</code>: level偏移量数组，每一项记录该级level在bitmap中的起始index</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap_level_s</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> group_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在2.3.1节中介绍arena_run_t时曾提到Je通过外挂bitmap将bookkeeping和user memory分离。但bitmap查询速度要慢于boundary tag。为了弥补这个缺陷，Je对此做了改进，通过多级level缓冲以替代线性查找。</p>
<p>Je为bitmap增加了多级level, bottom level同普通bitmap一致，每1bit代表一个region。而高一级level中1bit代表前一级level中一个byte。譬如说，若我们在当前run中存在128个region，则在ILP32系统上，需要128/32 = 4byte来表示这128个region。Je将这4个byte看作level #0。为了进一步表示这4个字节是否被占用，又额外需要1byte以缓存这4byte的内容(仅使用了4bit)，此为level#1。即整个bitmap，一共有2级level，共5byte来描述。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                  +--------------+              +--------+</span><br><span class="line">      +-----------|------------ +|   +----------|-------+|</span><br><span class="line">      v           v             ||   v          v       ||</span><br><span class="line">+--------------------------------------------------------------------------</span><br><span class="line">| 1101 0010 | 0000 0000 | ... | 10?? ???? | ???? ???? | 1??? ????    | ...</span><br><span class="line">+--------------------------------------------------------------------------</span><br><span class="line">|&lt;--------- level #0 --------&gt;|&lt;----- level #1 ------&gt;|&lt;- level #2 -&gt;|</span><br></pre></td></tr></table></figure>
<h3 id="2-6-Thread-caches-tcache-t"><a href="#2-6-Thread-caches-tcache-t" class="headerlink" title="2.6 - Thread caches (tcache_t)"></a>2.6 - Thread caches (tcache_t)</h3><p>TLS/TSD是另一种针对多线程优化使用的分配技术，Je中称为tcache。tcache解决的是同一cpu core下不同线程对heap的竞争。通过为每个线程指定专属分配区域，来减小线程间的干扰。但显然这种方法会增大整体内存消耗量。为了减小副作用，je将tcache设计成一个bookkeeping结构，在tcache中保存的仅仅是指向外部region的指针，region对象仍然位于各个run当中。换句话说，如果一个region被tcache记录了，那么从run的角度看，它就已经被分配了。</p>
<p>tcache的内容如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_s</span> &#123;</span></span><br><span class="line">    ql_elm(<span class="type">tcache_t</span>) link;        </span><br><span class="line">    <span class="type">uint64_t</span>         prof_accumbytes;</span><br><span class="line">    <span class="type">arena_t</span>             *arena;        </span><br><span class="line">    <span class="type">unsigned</span>         ev_cnt;        </span><br><span class="line">    <span class="type">unsigned</span>         next_gc_bin;    </span><br><span class="line">    <span class="type">tcache_bin_t</span>     tbins[<span class="number">1</span>];    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>link</code>: 链接节点，用于将同一个arena下的所有tcache链接起来。</li>
<li><code>prof_accumbytes</code>: memory profile相关。</li>
<li><code>arena</code>: 该tcache所属的arena指针。</li>
<li><code>ev_cnt</code>: 是tcache内部的一个周期计数器。每当tcache执行一次分配或释放时，ev_cnt会记录一次。直到周期到来，Je会执行一次incremental gc.这里的gc会清理tcache中多余的region，将它们释放掉。尽管这不意味着系统内存会获得释放，但可以解放更多的region交给其他更饥饿的线程以分配。</li>
<li><code>next_gc_bin</code>: 指向下一次gc的binidx。tcache gc按照一周期清理一个bin执行。</li>
<li><code>tbins</code>: tcache bin数组。同样外挂在tcache后面。</li>
</ul>
<p>同arena bin类似，tcache同样有tcache_bin_t和tcache_bin_info_t。tcache_bin_t作用类似于arena bin，但其结构要比后者更简单。准确的说，tcache bin并没有分配调度的功能，而仅起到记录作用。其内部通过一个stack记录指向外部arena run中的region指针。而一旦region被cache到tbins内，就不能再被其他任何线程所使用，尽管它可能甚至与其他线程tcache中记录的region位于同一个arena run中。</p>
<p>tcache bin结构如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_bin_s</span> &#123;</span></span><br><span class="line">    <span class="type">tcache_bin_stats_t</span> tstats;</span><br><span class="line">    <span class="type">int</span>     low_water;</span><br><span class="line">    <span class="type">unsigned</span>    lg_fill_div;</span><br><span class="line">    <span class="type">unsigned</span>    ncached;</span><br><span class="line">    <span class="type">void</span>        **avail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tstats</code>: tcache bin内部统计。</li>
<li><code>low_water</code>: 记录两次gc间tcache内部使用的最低水线。该数值与下一次gc时尝试释放的region数量有关。释放量相当于low water数值的3/4.</li>
<li><code>lg_fill_div</code>: 用作tcache refill时作为除数。当tcache耗尽时，会请求arena run进行refill。但refill不会一次性灌满tcache，而是依照其最大容量缩小2^lg_fill_div的倍数。该数值同low_water一样是动态的，两者互相配合确保tcache处于一个合理的充满度。</li>
<li><code>ncached</code>: 指当前缓存的region数量，同时也代表栈顶index.</li>
<li><code>avail</code>: 保存region指针的stack，称为avail-stack.</li>
</ul>
<p>tcache_bin_info_t保存tcache bin的静态信息。其本身只保存了tcache max容量。该数值是在tcache boot时根据相对应的arena bin的nregs决定的。通常等于nregs的二倍，但不得超过TCACHE_NSLOTS_SMALL_MAX。该数值默认为200，但在android中大大提升了该限制，small bins不得超过8, large bins则为16.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_bin_info_s</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span>    ncached_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>tcache layout如下，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">                +---------------+</span><br><span class="line">              / | link          |</span><br><span class="line">   tcache_t  &lt;  | next_gc_bin   |</span><br><span class="line">              \ | ...           |</span><br><span class="line">                |---------------|</span><br><span class="line">              / | tstats        |</span><br><span class="line">   tbins[0]  &lt;  | ...           |</span><br><span class="line">              | | ncached       |</span><br><span class="line">              \ | avail --------------+</span><br><span class="line">                |---------------|     |</span><br><span class="line">                | ...           |     |  </span><br><span class="line">                | ...           |     |  </span><br><span class="line">                | ...           |     |  </span><br><span class="line">                |---------------|     |</span><br><span class="line">              / | tstats        |     |</span><br><span class="line">  tbins[nhb  &lt;  | ...           |     |</span><br><span class="line">     ins]     | | ncached       |     |                   </span><br><span class="line">              \ | avail --------------|---+               </span><br><span class="line">                |---------------|     |   |               current arena run</span><br><span class="line">                | padding       |     |   |               +----------------+      </span><br><span class="line">                |---------------| &lt;---+   |               | run header     |</span><br><span class="line">              / | stack[0]      |         |               | ...            |</span><br><span class="line">avail-stack  &lt;  | stack[1]      |         |               | bitmap         |</span><br><span class="line">for tbins[0]  | | ...           |         |               | ...            |</span><br><span class="line">              | | ...           |         |               |----------------|</span><br><span class="line">              | | stack[ncached |         |               | region #0      |</span><br><span class="line">              \ | _max - 1]     |         |               | ...            |</span><br><span class="line">                |---------------|         |               |----------------|</span><br><span class="line">                | ...           |         |    +--------&gt; | region #1      |</span><br><span class="line">                | ...           |         |    |          | ...            |</span><br><span class="line">                | ...           |         |    |          |----------------|</span><br><span class="line">                |---------------| &lt;-------+    |          | ...            |</span><br><span class="line">avail-stack   / | stack[0]      |--------------|--+       | ...            |</span><br><span class="line">for tbins[   &lt;  | ...           |              |  |       |----------------|</span><br><span class="line"> nhbins]      | | stack[n]      |--------------|--|-----&gt; | region #n      |</span><br><span class="line">              | | ...           |              |  |       | ...            |</span><br><span class="line">              | | stack[ncached |              |  |       |----------------|</span><br><span class="line">              \ | _max - 1]     |--------------+  |       | ...            |</span><br><span class="line">                +---------------+                 |       | ...            |</span><br><span class="line">                                                  |       |----------------|</span><br><span class="line">                                                  +-----&gt; | region #nregs-1|</span><br><span class="line">                                                          | ...            |</span><br><span class="line">                                                          +----------------+</span><br></pre></td></tr></table></figure>
<h3 id="2-7-Extent-Node-extent-node-t"><a href="#2-7-Extent-Node-extent-node-t" class="headerlink" title="2.7 - Extent Node (extent_node_t)"></a>2.7 - Extent Node (extent_node_t)</h3><p>extent node代表huge region，即大于chunk大小的内存单元。同arena run不同，extent node并非是一个header构造，而是外挂的。因此其本身仍属small region。只不过并不通过bin分配，而由base_nodes直接动态创建。</p>
<p>Je中对所有huge region都是通过rb tree管理。因此extent node同时也是tree node。一个node节点被同时挂载到两棵rb tree上。一棵采用szad的查询方式，另一棵则采用纯ad的方式。作用是当执行chunk recycle时查询到可用region，后面会详述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">extent_node_s</span> &#123;</span></span><br><span class="line">    rb_node(<span class="type">extent_node_t</span>)    link_szad;</span><br><span class="line">    rb_node(<span class="type">extent_node_t</span>)    link_ad;</span><br><span class="line">    <span class="type">prof_ctx_t</span>        *prof_ctx;</span><br><span class="line">    <span class="type">void</span>            *addr;</span><br><span class="line">    <span class="type">size_t</span>            size;</span><br><span class="line">    <span class="type">arena_t</span>            *arena;</span><br><span class="line">    <span class="type">bool</span>            zeroed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>link_szad</code>: szad tree的link节点。</li>
<li><code>link_ad</code>: ad tree的link节点。</li>
<li><code>prof_ctx</code>: 用于memory profile.</li>
<li><code>addr</code>: 指向huge region的指针。</li>
<li><code>size</code>: region size.</li>
<li><code>arena</code>: huge region所属arena.</li>
<li><code>zeroed</code>: 代表是否zero-filled, chunk recycle时会用到。</li>
</ul>
<h3 id="2-8-Base"><a href="#2-8-Base" class="headerlink" title="2.8 - Base"></a>2.8 - Base</h3><p>base并不是数据类型，而是一块特殊区域，主要服务于内部meta data(例如arena_t，tcache_t，extent_node_t等等)的分配。base区域管理与如下变量相关，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">malloc_mutex_t</span>    base_mtx;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>        *base_pages;    </span><br><span class="line"><span class="type">static</span> <span class="type">void</span>        *base_next_addr;     </span><br><span class="line"><span class="type">static</span> <span class="type">void</span>        *base_past_addr;</span><br><span class="line"><span class="type">static</span> <span class="type">extent_node_t</span>    *base_nodes;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>base_mtx</code>:       base lock</li>
<li><code>base_pages</code>:     base page指针，代表整个区域的起始位置。</li>
<li><code>base_next_addr</code>: 当前base指针，类似于brk指针。</li>
<li><code>base_past_addr</code>: base page的上限指针。</li>
<li><code>base_nodes</code>:     指向extent_node_t链表的外挂头指针。</li>
</ul>
<p>base page源于arena中的空闲chunk，通常情况下，大小相当于chunk。当base耗尽时，会以chunk alloc的名义重新申请新的base pages。 </p>
<p>为了保证内部meta data的快速分配和访问。Je将内部请求大小都对齐到cache-line上，以避免在SMP下的false sharing。而分配方式上，采用了快速移动base_next_addr指针进行高速开采的方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">base_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 将内部分配请求对齐的cache-line上，阻止false sharing</span></span><br><span class="line">    csize = CACHELINE_CEILING(size);</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;base_mtx);</span><br><span class="line">    <span class="comment">// xf: 如果base耗尽，则重新分配base_pages。默认大小为chunksize.</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uintptr_t</span>)base_next_addr + csize &gt; (<span class="type">uintptr_t</span>)base_past_addr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (base_pages_alloc(csize)) &#123;</span><br><span class="line">            malloc_mutex_unlock(&amp;base_mtx);</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: 快速向前开采</span></span><br><span class="line">    ret = base_next_addr;</span><br><span class="line">    base_next_addr = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)base_next_addr + csize);</span><br><span class="line">    malloc_mutex_unlock(&amp;base_mtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与通常的base alloc有所不同，分配extent_node_t会优先从一个node链表中获取节点，而base_nodes则为该链表的外挂头指针。只有当其耗尽时，才使用前面的分配方式。这里区别对待extent_node_t与其他类型，主要与chunk recycle机制有关，后面会做详细说明。有意思的是，该链表实际上借用了extent node内部rb tree node的左子树节点指针作为其link指针。如2.7节所述，extent_node_t结构的起始位置存放一个rb node.但在这里，当base_nodes赋值给ret后，会强制将ret转型成(extent_node_t **),实际上就是指向extent_node_t结构体的第一个field的指针，并将其指向的node指针记录到base_nodes里，成为新的header节点。这里需要仔细体会这个强制类型转换的巧妙之处。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ret = base_nodes</span><br><span class="line">     |</span><br><span class="line">     v   +---- (extent_node_t**)ret</span><br><span class="line">     +---|------------------------------ +</span><br><span class="line">     |   |              extent_node      |</span><br><span class="line">     | +-|-------------------------+     |</span><br><span class="line">     | | v       rb_node           |     |</span><br><span class="line">     | | +----------+-----------+  |     |</span><br><span class="line">     | | | rbn_left | rbn_right |  | ... |</span><br><span class="line">     | | +----------+-----------+  |     |</span><br><span class="line">     | +-------|-------------------+     |</span><br><span class="line">     +---------|-------------------------+</span><br><span class="line">               v</span><br><span class="line">base_nodes---&gt; +---------------+</span><br><span class="line">               | extent_node   |</span><br><span class="line">               +---------------+</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">extent_node_t</span> *</span><br><span class="line"><span class="title function_">base_node_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">extent_node_t</span> *ret;</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;base_mtx);</span><br><span class="line">    <span class="keyword">if</span> (base_nodes != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = base_nodes;</span><br><span class="line">        <span class="comment">// xf: 这里也可以理解为，base_nodes = (extent_node_t*)(*ret);</span></span><br><span class="line">        base_nodes = *(<span class="type">extent_node_t</span> **)ret;</span><br><span class="line">        malloc_mutex_unlock(&amp;base_mtx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        malloc_mutex_unlock(&amp;base_mtx);</span><br><span class="line">        ret = (<span class="type">extent_node_t</span> *)base_alloc(<span class="keyword">sizeof</span>(<span class="type">extent_node_t</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Allocation"><a href="#3-Allocation" class="headerlink" title="3 - Allocation"></a>3 - Allocation</h2><h3 id="3-1-Overview"><a href="#3-1-Overview" class="headerlink" title="3.1 - Overview"></a>3.1 - Overview</h3><p>在2.3.2节中得知，Je将size class划分成small, large, huge三种类型。分配时这三种类型分别按照不同的算法执行。后面的章节也将按照这个类型顺序描述。</p>
<p>总体来说，Je分配函数从je_malloc入口开始，经过，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">je_malloc -&gt; imalloc_body -&gt; imalloc -&gt; imalloct ---&gt; arena_malloc</span><br><span class="line">                                                  |                  </span><br><span class="line">                                                  +-&gt; huge_malloc</span><br></pre></td></tr></table></figure>
<p>实际执行分配的分别是对应small/large的arena malloc和对应huge的huge malloc。分配算法可以概括如下，</p>
<ol>
<li>首先检查Je是否初始化，如果没有则初始化Je，并标记全局malloc_initialized标记。</li>
<li>检查请求size是否大于huge，如果是则执行8，否则进入下一步。</li>
<li>执行arena_malloc，首先检查size是否小于等于small maxclass，如果是则下一步，否则执行6.</li>
<li>如果允许且当前线程已绑定tcache，则从tcache分配small，并返回。否则下一步。</li>
<li>choose arena，并执行arena malloc small，返回。</li>
<li>如果允许且当前线程已绑定tcache，则从tcache分配large，并返回。否则下一步。</li>
<li>choose arena，并执行arena malloc large，返回。</li>
<li>执行huge malloc，并返回。</li>
</ol>
<h3 id="3-2-Initialize"><a href="#3-2-Initialize" class="headerlink" title="3.2 - Initialize"></a>3.2 - Initialize</h3><p>Je通过全局标记malloc_initialized指代是否初始化。在每次分配时，需要检查该标记，如果没有则执行malloc_init。</p>
<p>但通常条件下，malloc_init是在Je库被载入之前就调用的。通过gcc的编译扩展属性”constructor”实现，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ATTR(constructor)</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">jemalloc_constructor</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    malloc_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来由malloc_init_hard执行各项初始化工作。这里首先需要考虑的是多线程初始化导致的重入，Je通过malloc_initialized和malloc_initializer两个标记来识别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">malloc_mutex_lock(&amp;init_lock);</span><br><span class="line"><span class="comment">// xf: 如果在获得init_lock前已经有其他线程完成malloc_init,</span></span><br><span class="line"><span class="comment">// 或者当前线程在初始化过程中执行了malloc，导致递归初始化，则立即退出。</span></span><br><span class="line"><span class="keyword">if</span> (malloc_initialized || IS_INITIALIZER) &#123;</span><br><span class="line">    malloc_mutex_unlock(&amp;init_lock);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// xf: 如果开启多线程初始化，需要执行busy wait直到malloc_init在另外线程中</span></span><br><span class="line"><span class="comment">// 执行完毕后返回。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> JEMALLOC_THREADED_INIT</span></span><br><span class="line"><span class="keyword">if</span> (malloc_initializer != NO_INITIALIZER &amp;&amp; IS_INITIALIZER == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        malloc_mutex_unlock(&amp;init_lock);</span><br><span class="line">        CPU_SPINWAIT;</span><br><span class="line">        malloc_mutex_lock(&amp;init_lock);</span><br><span class="line">    &#125; <span class="keyword">while</span> (malloc_initialized == <span class="literal">false</span>);</span><br><span class="line">    malloc_mutex_unlock(&amp;init_lock);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// xf: 将当前线程注册为initializer</span></span><br><span class="line">malloc_initializer = INITIALIZER;</span><br></pre></td></tr></table></figure>
<p>初始化工作由各个xxx_boot函数完成。注意的是，boot函数返回false代表成功，否则代表失败。</p>
<ul>
<li><code>tsd boot</code>: Thread specific data初始化，主要负责tsd析构函数数组长度初始化。</li>
<li><code>base boot</code>: base是Je内部用于meta data分配的保留区域，使用内部独立的分配方式。base boot负责base node和base mutex的初始化。</li>
<li><code>chunk boot</code>: 主要有三件工作，<ul>
<li>确认chunk_size和chunk_npages</li>
<li>chunk_dss_boot，chunk dss指chunk分配的dss(Data Storage Segment)方式。其中涉及dss_base，dss_prev指针的初始化工作。</li>
<li>chunk tree的初始化，在chunk recycle时要用到。</li>
</ul>
</li>
<li><code>arena boot</code>: 主要是确认arena_maxclass，这个size代表arena管理的最大region，超过该值被认为huge region.在2.2.2小节中有过介绍，先通过多次迭代计算出map_bias，再用chunksize - (map_bias &lt;&lt; LG_PAGE)即可得到。另外还对另一个重要的静态数组arena_bin_info执行了初始化。可参考2.3.2介绍class size的部分。</li>
<li><code>tcache boot</code>: 分为tcache_boot0和tcache_boot1两个部分执行。前者负责tcache所有静态信息，包含tcache_bin_info，stack_nelms,nhbins等的初始化。后者负责tcache tsd数据的初始化(tcache保存到线程tsd中).</li>
<li><code>huge boot</code>: 负责huge mutex和huge tree的初始化。</li>
</ul>
<p>除此之外，其他重要的初始化还包括分配arenas数组。注意arenas是一个指向指针数组的指针，因此各个arena还需要动态创建。这里Je采取了lazy create的方式，只有当choose_arena时才可能由choose_arena_hard创建真实的arena实例。但在malloc_init中，首个arena还是会在此时创建，以保证基本的分配。</p>
<p>相关代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_t</span> *init_arenas[<span class="number">1</span>];</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 此时narenas_total只有1</span></span><br><span class="line">narenas_total = narenas_auto = <span class="number">1</span>;</span><br><span class="line">arenas = init_arenas;</span><br><span class="line"><span class="built_in">memset</span>(arenas, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">arena_t</span> *) * narenas_auto);</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 创建首个arena实例，保存到临时数组init_arenas中</span></span><br><span class="line">arenas_extend(<span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 获得当前系统核心数量</span></span><br><span class="line">ncpus = malloc_ncpus();</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 默认的narenas为核心数量的4倍</span></span><br><span class="line"><span class="keyword">if</span> (opt_narenas == <span class="number">0</span>) &#123;    </span><br><span class="line">    <span class="keyword">if</span> (ncpus &gt; <span class="number">1</span>)</span><br><span class="line">        opt_narenas = ncpus &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        opt_narenas = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: android中max arenas限制为2，参考mk文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ANDROID_MAX_ARENAS)</span></span><br><span class="line"><span class="keyword">if</span> (opt_narenas &gt; ANDROID_MAX_ARENAS)</span><br><span class="line">    opt_narenas = ANDROID_MAX_ARENAS;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">narenas_auto = opt_narenas;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 修正narenas_total</span></span><br><span class="line">narenas_total = narenas_auto;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 根据total数量，构造arenas数组，并置空</span></span><br><span class="line">arenas = (<span class="type">arena_t</span> **)base_alloc(<span class="keyword">sizeof</span>(<span class="type">arena_t</span> *) * narenas_total);</span><br><span class="line">......</span><br><span class="line"><span class="built_in">memset</span>(arenas, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">arena_t</span> *) * narenas_total);</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 将之前的首个arena实例指针保存到新构造的arenas数组中</span></span><br><span class="line">arenas[<span class="number">0</span>] = init_arenas[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h3 id="3-3-Small-allocation-Arena"><a href="#3-3-Small-allocation-Arena" class="headerlink" title="3.3 - Small allocation (Arena)"></a>3.3 - Small allocation (Arena)</h3><p>先介绍最复杂的arena malloc small.</p>
<ol>
<li>先通过small_size2bin查到bin index(2.4.3节有述).</li>
<li>若对应bin中current run可用则进入下一步，否则执行4.</li>
<li>由arena_run_reg_alloc在current run中直接分配，并返回。</li>
<li>current run耗尽或不存在，尝试从bin中获得可用run以填充current run，成功则执行9，否则进入下一步。</li>
<li>当前bin的run tree中没有可用run，转而从arena的avail-tree上尝试切割一个可用run，成功则执行9，否则进入下一步。</li>
<li>当前arena没有可用的空闲run，构造一个新的chunk以分配new run. 成功则执行9，否则进入下一步。</li>
<li>chunk分配失败，再次查询arena的avail-tree，查找可用run. 成功则执行9，否则进入下一步。</li>
<li>alloc run尝试彻底失败，则再次查询当前bin的run-tree，尝试获取run。</li>
<li>在使用新获得run之前，重新检查当前bin的current run，如果可用(这里有两种可能，其一是其他线程可能通过free释放了多余的region或run，另一种可能是抢在当前线程之前已经分配了新run)，则使用其分配，并返回。另外，如果当前手中的new run是空的，则将其释放掉。否则若其地址比current run更低，则交换二者，将旧的current run插回avail-tree。</li>
<li>在new run中分配region，并返回。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_malloc_small</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">size_t</span> size, <span class="type">bool</span> zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 根据size计算bin index</span></span><br><span class="line">    binind = small_size2bin(size);</span><br><span class="line">    assert(binind &lt; NBINS);</span><br><span class="line">    bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">    size = small_bin2size(binind);</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: 如果bin中current run不为空，且存在空闲region，则在current</span></span><br><span class="line">    <span class="comment">// run中分配。否则在其他run中分配。</span></span><br><span class="line">    <span class="keyword">if</span> ((run = bin-&gt;runcur) != <span class="literal">NULL</span> &amp;&amp; run-&gt;nfree &gt; <span class="number">0</span>)</span><br><span class="line">        ret = arena_run_reg_alloc(run, &amp;arena_bin_info[binind]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = arena_bin_malloc_hard(arena, bin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 若返回null，则分配失败。</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-arena-run-reg-alloc"><a href="#3-3-1-arena-run-reg-alloc" class="headerlink" title="3.3.1 - arena_run_reg_alloc"></a>3.3.1 - arena_run_reg_alloc</h4><ol>
<li>首先根据bin_info中的静态信息bitmap_offset计算bitmap基址。</li>
<li>扫描当前run的bitmap，获得第一个free region所在的位置。</li>
<li>region地址 = run基址 + 第一个region的偏移量 + free region索引 * region内部size</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_run_reg_alloc</span><span class="params">(<span class="type">arena_run_t</span> *run, <span class="type">arena_bin_info_t</span> *bin_info)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 计算bitmap基址</span></span><br><span class="line">    <span class="type">bitmap_t</span> *bitmap = (<span class="type">bitmap_t</span> *)((<span class="type">uintptr_t</span>)run +</span><br><span class="line">        (<span class="type">uintptr_t</span>)bin_info-&gt;bitmap_offset);</span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// xf: 获得当前run中第一个free region所在bitmap中的位置</span></span><br><span class="line">    regind = bitmap_sfu(bitmap, &amp;bin_info-&gt;bitmap_info);</span><br><span class="line">    <span class="comment">// xf: 计算返回值</span></span><br><span class="line">    ret = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)run + (<span class="type">uintptr_t</span>)bin_info-&gt;reg0_offset +</span><br><span class="line">        (<span class="type">uintptr_t</span>)(bin_info-&gt;reg_interval * regind));</span><br><span class="line">    <span class="comment">// xf: free减1</span></span><br><span class="line">    run-&gt;nfree--;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中bitmap_sfu是执行bitmap遍历并设置第一个unset bit。如2.5节所述，bitmap由多级组成，遍历由top level开始循环迭代，直至bottom level。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="type">size_t</span></span><br><span class="line"><span class="title function_">bitmap_sfu</span><span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">const</span> <span class="type">bitmap_info_t</span> *binfo)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 找到最高级level，并计算ffs</span></span><br><span class="line">    i = binfo-&gt;nlevels - <span class="number">1</span>;</span><br><span class="line">    g = bitmap[binfo-&gt;levels[i].group_offset];</span><br><span class="line">    bit = jemalloc_ffsl(g) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// xf: 循环迭代，直到level0</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="comment">// xf: 根据上一级level的结果，计算当前level的group</span></span><br><span class="line">        g = bitmap[binfo-&gt;levels[i].group_offset + bit];</span><br><span class="line">        <span class="comment">// xf: 根据当前level group，计算下一级需要的bit</span></span><br><span class="line">        bit = (bit &lt;&lt; LG_BITMAP_GROUP_NBITS) + (jemalloc_ffsl(g) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 得到level0的bit，设置bitmap</span></span><br><span class="line">    bitmap_set(bitmap, binfo, bit);</span><br><span class="line">    <span class="keyword">return</span> (bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bitmap_set同普通bitmap操作没有什么区别，只是在set/unset之后需要反向迭代更新各个高等级level对应的bit位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">bitmap_set</span><span class="params">(<span class="type">bitmap_t</span> *bitmap, <span class="type">const</span> <span class="type">bitmap_info_t</span> *binfo, <span class="type">size_t</span> bit)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 计算该bit所在level0中的group</span></span><br><span class="line">    goff = bit &gt;&gt; LG_BITMAP_GROUP_NBITS;</span><br><span class="line">    <span class="comment">// xf: 得到目标group的值g</span></span><br><span class="line">    gp = &amp;bitmap[goff];</span><br><span class="line">    g = *gp;</span><br><span class="line">    <span class="comment">// xf: 根据remainder，找到target bit，并反转</span></span><br><span class="line">    g ^= <span class="number">1LU</span> &lt;&lt; (bit &amp; BITMAP_GROUP_NBITS_MASK);</span><br><span class="line">    *gp = g;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 若target bit所在group为0，则需要更新highlevel的相应bit,</span></span><br><span class="line">    <span class="comment">// 是bitmap_sfu的反向操作。</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">unsigned</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; binfo-&gt;nlevels; i++) &#123;</span><br><span class="line">            bit = goff;</span><br><span class="line">            goff = bit &gt;&gt; LG_BITMAP_GROUP_NBITS;</span><br><span class="line">            gp = &amp;bitmap[binfo-&gt;levels[i].group_offset + goff];</span><br><span class="line">            g = *gp;</span><br><span class="line">            assert(g &amp; (<span class="number">1LU</span> &lt;&lt; (bit &amp; BITMAP_GROUP_NBITS_MASK)));</span><br><span class="line">            g ^= <span class="number">1LU</span> &lt;&lt; (bit &amp; BITMAP_GROUP_NBITS_MASK);</span><br><span class="line">            *gp = g;</span><br><span class="line">            <span class="keyword">if</span> (g != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-arena-bin-malloc-hard"><a href="#3-3-2-arena-bin-malloc-hard" class="headerlink" title="3.3.2 - arena_bin_malloc_hard"></a>3.3.2 - arena_bin_malloc_hard</h4><ol>
<li>从bin中获得可用的nonfull run，这个过程中bin-&gt;lock有可能被解锁。</li>
<li>暂不使用new run，返回检查bin-&gt;runcur是否重新可用。如果是，则直接在其中分配region(其他线程在bin lock解锁期间可能提前修改了runcur)。否则，执行4.</li>
<li>重新检查1中得到的new run，如果为空，则释放该run.否则与当前runcur作比较，若地址低于runcur，则与其做交换。将旧的runcur插回run tree。并返回new rigion.</li>
<li>用new run填充runcur，并在其中分配region，返回。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">arena_bin_malloc_hard</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_bin_t</span> *bin)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 获得bin对应的arena_bin_info，并将current run置空</span></span><br><span class="line">    binind = arena_bin_index(arena, bin);</span><br><span class="line">    bin_info = &amp;arena_bin_info[binind];</span><br><span class="line">    bin-&gt;runcur = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 从指定bin中获得一个可用的run</span></span><br><span class="line">    run = arena_bin_nonfull_run_get(arena, bin);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对bin-&gt;runcur做重新检查。如果可用且未耗尽，则直接分配。</span></span><br><span class="line">    <span class="keyword">if</span> (bin-&gt;runcur != <span class="literal">NULL</span> &amp;&amp; bin-&gt;runcur-&gt;nfree &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = arena_run_reg_alloc(bin-&gt;runcur, bin_info);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 若new run为空，则将其释放。否则重新插入run tree.</span></span><br><span class="line">        <span class="keyword">if</span> (run != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">arena_chunk_t</span> *chunk;</span><br><span class="line">            chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(run);</span><br><span class="line">            <span class="keyword">if</span> (run-&gt;nfree == bin_info-&gt;nregs)</span><br><span class="line">                arena_dalloc_bin_run(arena, chunk, run, bin);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                arena_bin_lower_run(arena, chunk, run, bin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (run == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 到这里在bin-&gt;runcur中分配失败，用当前新获得的run填充current run</span></span><br><span class="line">    bin-&gt;runcur = run;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 在new run中分配region</span></span><br><span class="line">    <span class="keyword">return</span> (arena_run_reg_alloc(bin-&gt;runcur, bin_info));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-arena-bin-nonfull-run-get"><a href="#3-3-3-arena-bin-nonfull-run-get" class="headerlink" title="3.3.3 - arena_bin_nonfull_run_get"></a>3.3.3 - arena_bin_nonfull_run_get</h4><ol>
<li>尝试在当前run tree中寻找可用run，成功则返回，否则进入下一步</li>
<li>解锁bin lock，并加锁arena lock，尝试在当前arena中分配new run。之后重新解锁arena lock，并加锁bin lock。如果成功则返回，否则进入下一步。</li>
<li>分配失败，重新在当前run tree中寻找一遍可用run.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">arena_run_t</span> *</span><br><span class="line"><span class="title function_">arena_bin_nonfull_run_get</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_bin_t</span> *bin)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 尝试从当前run tree中寻找一个可用run，如果存在就返回</span></span><br><span class="line">    run = arena_bin_nonfull_run_tryget(bin);</span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (run);    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 打开bin lock，让其他线程可以操作当前的bin tree</span></span><br><span class="line">    malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: 锁住arena lock，以分配new run</span></span><br><span class="line">    malloc_mutex_lock(&amp;arena-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 尝试分配new run</span></span><br><span class="line">    run = arena_run_alloc_small(arena, bin_info-&gt;run_size, binind);</span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化new run和bitmap</span></span><br><span class="line">        <span class="type">bitmap_t</span> *bitmap = (<span class="type">bitmap_t</span> *)((<span class="type">uintptr_t</span>)run +</span><br><span class="line">            (<span class="type">uintptr_t</span>)bin_info-&gt;bitmap_offset);</span><br><span class="line"></span><br><span class="line">        run-&gt;bin = bin;</span><br><span class="line">        run-&gt;nextind = <span class="number">0</span>;</span><br><span class="line">        run-&gt;nfree = bin_info-&gt;nregs;</span><br><span class="line">        bitmap_init(bitmap, &amp;bin_info-&gt;bitmap_info);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 解锁arena lock</span></span><br><span class="line">    malloc_mutex_unlock(&amp;arena-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: 重新加锁bin lock</span></span><br><span class="line">    malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 如果run alloc失败，则回过头重新try get一次(前面解锁bin lock</span></span><br><span class="line">    <span class="comment">// 给了其他线程机会).</span></span><br><span class="line">    run = arena_bin_nonfull_run_tryget(bin);</span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-4-Small-Run-Alloc"><a href="#3-3-4-Small-Run-Alloc" class="headerlink" title="3.3.4 - Small Run Alloc"></a>3.3.4 - Small Run Alloc</h4><ol>
<li>从arena avail tree上获得一个可用run，并对其切割。失败进入下一步。</li>
<li>尝试给arena分配新的chunk，以构造new run。此过程可能会解锁arena lock.失败进入下一步。</li>
<li>其他线程可能在此过程中释放了某些run，重新检查avail-tree，尝试获取run。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">arena_run_t</span> *</span><br><span class="line"><span class="title function_">arena_run_alloc_small</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">size_t</span> size, <span class="type">size_t</span> binind)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 从available tree上尝试寻找并切割一个合适的run，并对其初始化</span></span><br><span class="line">    run = arena_run_alloc_small_helper(arena, size, binind);</span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 当前arena内没有可用的空闲run，构造一个新的chunk以分配new run.</span></span><br><span class="line">    chunk = arena_chunk_alloc(arena);</span><br><span class="line">    <span class="keyword">if</span> (chunk != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        run = (<span class="type">arena_run_t</span> *)((<span class="type">uintptr_t</span>)chunk + (map_bias &lt;&lt; LG_PAGE));</span><br><span class="line">        arena_run_split_small(arena, run, size, binind);</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 重新检查arena avail-tree.</span></span><br><span class="line">    <span class="keyword">return</span> (arena_run_alloc_small_helper(arena, size, binind));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">arena_run_t</span> *</span><br><span class="line"><span class="title function_">arena_run_alloc_small_helper</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">size_t</span> size, <span class="type">size_t</span> binind)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 在arena的available tree中寻找一个大于等于size大小的最小run</span></span><br><span class="line">    key = (<span class="type">arena_chunk_map_t</span> *)(size | CHUNK_MAP_KEY);</span><br><span class="line">    mapelm = arena_avail_tree_nsearch(&amp;arena-&gt;runs_avail, key);</span><br><span class="line">    <span class="keyword">if</span> (mapelm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">arena_chunk_t</span> *run_chunk = CHUNK_ADDR2BASE(mapelm);</span><br><span class="line">        <span class="type">size_t</span> pageind = arena_mapelm_to_pageind(mapelm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 计算候选run的地址</span></span><br><span class="line">        run = (<span class="type">arena_run_t</span> *)((<span class="type">uintptr_t</span>)run_chunk + (pageind &lt;&lt;</span><br><span class="line">            LG_PAGE));</span><br><span class="line">        <span class="comment">// xf: 根据分配需求，切割候选run</span></span><br><span class="line">        arena_run_split_small(arena, run, size, binind);</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切割small run主要分为4步，</p>
<ol>
<li>将候选run的arena_chunk_map_t节点从avail-tree上摘除。</li>
<li>根据节点储存的原始page信息，以及need pages信息，切割该run.</li>
<li>更新remainder节点信息(只需更新首尾page)，重新插入avail-tree.</li>
<li>设置切割后new run所有page对应的map节点信息(根据2.3.3节所述).</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_run_split_small</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_run_t</span> *run, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> binind)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 获取目标run的dirty flag</span></span><br><span class="line">    chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(run);</span><br><span class="line">    run_ind = (<span class="type">unsigned</span>)(((<span class="type">uintptr_t</span>)run - (<span class="type">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE);</span><br><span class="line">    flag_dirty = arena_mapbits_dirty_get(chunk, run_ind);</span><br><span class="line">    need_pages = (size &gt;&gt; LG_PAGE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 1. 将候选run从available tree上摘除</span></span><br><span class="line">    <span class="comment">//     2. 根据need pages对候选run进行切割</span></span><br><span class="line">    <span class="comment">//     3. 将remainder重新插入available tree    </span></span><br><span class="line">    arena_run_split_remove(arena, chunk, run_ind, flag_dirty, need_pages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 设置刚刚被split后的run的第一个page</span></span><br><span class="line">    arena_mapbits_small_set(chunk, run_ind, <span class="number">0</span>, binind, flag_dirty);</span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// xf: 依次设置run中的其他page, run index依次递增</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; need_pages - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arena_mapbits_small_set(chunk, run_ind+i, i, binind, <span class="number">0</span>);</span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 设置run中的最后一个page</span></span><br><span class="line">    arena_mapbits_small_set(chunk, run_ind+need_pages<span class="number">-1</span>, need_pages<span class="number">-1</span>,</span><br><span class="line">        binind, flag_dirty);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-5-Chunk-Alloc"><a href="#3-3-5-Chunk-Alloc" class="headerlink" title="3.3.5 - Chunk Alloc"></a>3.3.5 - Chunk Alloc</h4><p>arena获取chunk一般有两个途径。其一是通过内部的spare指针。该指针缓存了最近一次chunk被释放的记录。因此该方式速度很快。另一种更加常规，通过内部分配函数分配，最终将由chunk_alloc_core执行。但在Je的设计中，执行arena chunk的分配器是可定制的，你可以替换任何第三方chunk分配器。这里仅讨论默认情况。</p>
<p>Je在chunk_alloc_core中同传统分配器如Dl有较大区别。通常情况下，从系统获取内存无非是morecore或mmap两种方式。Dl中按照先morecore-&gt;mmap的顺序，而Je更为灵活，具体的顺序由dss_prec_t决定。</p>
<p>该类型是一个枚举，定义如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    dss_prec_disabled  = <span class="number">0</span>,</span><br><span class="line">    dss_prec_primary   = <span class="number">1</span>,</span><br><span class="line">    dss_prec_secondary = <span class="number">2</span>,</span><br><span class="line">    dss_prec_limit     = <span class="number">3</span></span><br><span class="line">&#125; <span class="type">dss_prec_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里dss和morecore含义是相同的。primary表示优先dss，secondary则优先mmap。Je默认使用后者。</p>
<p>实际分配时，无论采用哪种策略，都会优先执行chunk_recycle，再执行chunk alloc，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">chunk_alloc_core</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> alignment, <span class="type">bool</span> base, <span class="type">bool</span> *zero,</span></span><br><span class="line"><span class="params">    <span class="type">dss_prec_t</span> dss_prec)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (have_dss &amp;&amp; dss_prec == dss_prec_primary) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = chunk_recycle(&amp;chunks_szad_dss, &amp;chunks_ad_dss, size,</span><br><span class="line">            alignment, base, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (ret);</span><br><span class="line">        <span class="keyword">if</span> ((ret = chunk_alloc_dss(size, alignment, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = chunk_recycle(&amp;chunks_szad_mmap, &amp;chunks_ad_mmap, size,</span><br><span class="line">        alignment, base, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">    <span class="keyword">if</span> ((ret = chunk_alloc_mmap(size, alignment, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (have_dss &amp;&amp; dss_prec == dss_prec_secondary) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = chunk_recycle(&amp;chunks_szad_dss, &amp;chunks_ad_dss, size,</span><br><span class="line">            alignment, base, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (ret);</span><br><span class="line">        <span class="keyword">if</span> ((ret = chunk_alloc_dss(size, alignment, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓chunk recycle是在alloc chunk之前，优先在废弃的chunk tree上搜索可用chunk，并分配base node以储存meta data的过程。好处是其一可以加快分配速度，其二是使空间分配更加紧凑，并节省内存。</p>
<p>在Je中存在4棵全局的rb tree，分别为，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">extent_tree_t</span>    chunks_szad_mmap;</span><br><span class="line"><span class="type">static</span> <span class="type">extent_tree_t</span>    chunks_ad_mmap;</span><br><span class="line"><span class="type">static</span> <span class="type">extent_tree_t</span>    chunks_szad_dss;</span><br><span class="line"><span class="type">static</span> <span class="type">extent_tree_t</span>    chunks_ad_dss;</span><br></pre></td></tr></table></figure>
<p>它们分别对应mmap和dss方式。当一个chunk或huge region被释放后，将收集到这4棵tree中。szad和ad在内容上并无本质区别，只是检索方式不一样。前者采用先size后address的方式，后者则是纯address的检索。</p>
<p>recycle算法概括如下，</p>
<ol>
<li>检查base标志，如果为真则直接返回，否则进入下一步。开始的检查是必要的，因为recycle过程中可能会创建新的extent node，要求调用base allocator分配。另一方面，base alloc可能因为耗尽的原因而反过来调用chunk alloc。如此将导致dead loop.</li>
<li>根据alignment计算分配大小，并在szad tree(mmap还是dss需要上一级决定)上寻找一个大于等于alloc size的最小node.</li>
<li>chunk tree上的node未必对齐到alignment上，将地址对齐，之后将得到leadsize和trailsize.</li>
<li>将原node从chunk tree上remove。若leadsize不为0，则将其作为新的chunk重新insert回chunk tree。trailsize不为0的情况亦然。若leadsize和trailsize同时不为0，则通过base_node_alloc为trailsize生成新的node并插入。若base alloc失败，则整个新分配的region都要销毁。</li>
<li>若leadsize和trailsize都为0，则将node(注意仅仅是节点)释放。返回对齐后的chunk地址。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">chunk_recycle</span><span class="params">(<span class="type">extent_tree_t</span> *chunks_szad, <span class="type">extent_tree_t</span> *chunks_ad, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> alignment, <span class="type">bool</span> base, <span class="type">bool</span> *zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 由于构造extent_node时可能因为内存不足的原因，同样需要构造chunk,</span></span><br><span class="line">    <span class="comment">// 这样就导致recursively dead loop。因此依靠base标志，区分普通alloc和</span></span><br><span class="line">    <span class="comment">// base node alloc。如果是base alloc，则立即返回。</span></span><br><span class="line">    <span class="keyword">if</span> (base) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 计算分配大小</span></span><br><span class="line">    alloc_size = size + alignment - chunksize;</span><br><span class="line">    ......</span><br><span class="line">    key.addr = <span class="literal">NULL</span>;</span><br><span class="line">    key.size = alloc_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 在指定的szad tree上寻找大于等于alloc size的最小可用node</span></span><br><span class="line">    malloc_mutex_lock(&amp;chunks_mtx);</span><br><span class="line">    node = extent_tree_szad_nsearch(chunks_szad, &amp;key);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 将候选节点基址对齐到分配边界上，并计算leadsize, trailsize</span></span><br><span class="line">    <span class="comment">// 以及返回地址。</span></span><br><span class="line">    leadsize = ALIGNMENT_CEILING((<span class="type">uintptr_t</span>)node-&gt;addr, alignment) -</span><br><span class="line">        (<span class="type">uintptr_t</span>)node-&gt;addr;</span><br><span class="line">    trailsize = node-&gt;size - leadsize - size;</span><br><span class="line">    ret = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)node-&gt;addr + leadsize);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 将原node从szad/ad tree上移除</span></span><br><span class="line">    extent_tree_szad_remove(chunks_szad, node);</span><br><span class="line">    extent_tree_ad_remove(chunks_ad, node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 如果存在leadsize，则将前面多余部分作为一个chunk重新插入</span></span><br><span class="line">    <span class="comment">// szad/ad tree上。</span></span><br><span class="line">    <span class="keyword">if</span> (leadsize != <span class="number">0</span>) &#123;</span><br><span class="line">        node-&gt;size = leadsize;</span><br><span class="line">        extent_tree_szad_insert(chunks_szad, node);</span><br><span class="line">        extent_tree_ad_insert(chunks_ad, node);</span><br><span class="line">        node = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 同样如果存在trailsize，也将后面的多余部分插入。</span></span><br><span class="line">    <span class="keyword">if</span> (trailsize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// xf: 如果leadsize不为0，这时原来的extent_node已经被用过了，</span></span><br><span class="line">        <span class="comment">// 则必须为trailsize部分重新分配新的extent_node</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            malloc_mutex_unlock(&amp;chunks_mtx);</span><br><span class="line">            node = base_node_alloc();</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// xf: 计算trail chunk，并插入</span></span><br><span class="line">        node-&gt;addr = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)(ret) + size);</span><br><span class="line">        node-&gt;size = trailsize;</span><br><span class="line">        node-&gt;zeroed = zeroed;</span><br><span class="line">        extent_tree_szad_insert(chunks_szad, node);</span><br><span class="line">        extent_tree_ad_insert(chunks_ad, node);</span><br><span class="line">        node = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    malloc_mutex_unlock(&amp;chunks_mtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: leadsize &amp; basesize都不存在，将node释放。</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        base_node_dalloc(node);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常规分配方式先来看dss。由于dss是与当前进程的brk指针相关的，任何线程(包括可能不通过Je执行分配的线程)都有权修改该指针值。因此，首先要把dss指针调整到对齐在chunksize边界的位置，否则很多与chunk相关的计算都会失效。接下来，还要做第二次调整对齐到外界请求的alignment边界。在此基础上再进行分配。</p>
<p>与dss分配相关的变量如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">malloc_mutex_t</span>    dss_mtx;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>        *dss_base;      </span><br><span class="line"><span class="type">static</span> <span class="type">void</span>        *dss_prev;      </span><br><span class="line"><span class="type">static</span> <span class="type">void</span>        *dss_max;       </span><br></pre></td></tr></table></figure>
<ul>
<li><code>dss_mtx</code>:  dss lock。注意其并不能起到保护dss指针的作用，因为brk是一个系统资源。该lock保护的是dss_prev, dss_max指针。</li>
<li><code>dss_base</code>: 只在chunk_dss_boot时更新一次。主要用作识别chunk在线性地址空间中所处的位置，与mmap作出区别。</li>
<li><code>dss_prev</code>: 当前dss指针，是系统brk指针的副本，值等于-1代表dss耗尽。</li>
<li><code>dss_max</code>:  当前dss区域上限。</li>
</ul>
<p>dss alloc算法如下，</p>
<ol>
<li>获取brk指针，更新到dss_max.</li>
<li>将dss_max对齐到chunksize边界上，计算padding大小gap_size</li>
<li>再将dss_max对齐到aligment边界上，得到cpad_size</li>
<li>计算需要分配的大小，并尝试sbrk。<code>incr = gap_size + cpad_size + size</code></li>
<li>分配成功，检查cpad是否非0，是则将这部分重新回收。而gap_size部分因为不可用则被废弃。</li>
<li>如果分配失败，则检查dss是否耗尽，如果没有则返回1重新尝试。否则返回。</li>
</ol>
<p>示意图，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chunk_base             cpad        ret        dss_next</span><br><span class="line">    |                   |           |            |</span><br><span class="line">    v                   v           v            v</span><br><span class="line">    +--------+----------+-----------+------   ---+</span><br><span class="line">    |  used  | gap_size | cpad_size | size ...   |</span><br><span class="line">    +--------+----------+-----------+------   ---+</span><br><span class="line">             |&lt;------------- incr --------------&gt;|            </span><br><span class="line">             ^          ^           ^  </span><br><span class="line">             |          |           |</span><br><span class="line">          dss_max  chunk_base +     +-- chunk_base +</span><br><span class="line">                     chunk_size          alignment</span><br></pre></td></tr></table></figure>
<p>源码注释，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">chunk_alloc_dss</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> alignment, <span class="type">bool</span> *zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">// xf: dss是否耗尽</span></span><br><span class="line">    malloc_mutex_lock(&amp;dss_mtx);</span><br><span class="line">    <span class="keyword">if</span> (dss_prev != (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// xf: 获取当前dss指针</span></span><br><span class="line">            dss_max = chunk_dss_sbrk(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// xf: 计算对齐到chunk size边界需要的padding大小</span></span><br><span class="line">            gap_size = (chunksize - CHUNK_ADDR2OFFSET(dss_max)) &amp;</span><br><span class="line">                chunksize_mask;</span><br><span class="line">            <span class="comment">// xf: 对齐到chunk边界的chunk起始地址</span></span><br><span class="line">            cpad = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)dss_max + gap_size);</span><br><span class="line">            <span class="comment">// xf: 对齐到alignment边界的起始地址</span></span><br><span class="line">            ret = (<span class="type">void</span> *)ALIGNMENT_CEILING((<span class="type">uintptr_t</span>)dss_max,</span><br><span class="line">                alignment);</span><br><span class="line">            cpad_size = (<span class="type">uintptr_t</span>)ret - (<span class="type">uintptr_t</span>)cpad;</span><br><span class="line">            <span class="comment">// xf: dss_max分配后的更新地址</span></span><br><span class="line">            dss_next = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)ret + size);</span><br><span class="line">            ......</span><br><span class="line">            incr = gap_size + cpad_size + size;</span><br><span class="line">            <span class="comment">// xf: 从dss分配</span></span><br><span class="line">            dss_prev = chunk_dss_sbrk(incr);</span><br><span class="line">            <span class="keyword">if</span> (dss_prev == dss_max) &#123;</span><br><span class="line">                dss_max = dss_next;</span><br><span class="line">                malloc_mutex_unlock(&amp;dss_mtx);</span><br><span class="line">                <span class="comment">// xf: 如果ret和cpad对齐不在同一个位置，则将cpad开始</span></span><br><span class="line">                <span class="comment">// cpad_size大小的内存回收到szad/ad tree中。而以之前</span></span><br><span class="line">                <span class="comment">// dss起始的gap_size大小内存由于本身并非对齐到</span></span><br><span class="line">                <span class="comment">// chunk_size，则被废弃。</span></span><br><span class="line">                <span class="keyword">if</span> (cpad_size != <span class="number">0</span>)</span><br><span class="line">                    chunk_unmap(cpad, cpad_size);</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">return</span> (ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (dss_prev != (<span class="type">void</span> *)<span class="number">-1</span>);   <span class="comment">// xf: 反复尝试直至dss耗尽</span></span><br><span class="line">    &#125;</span><br><span class="line">    malloc_mutex_unlock(&amp;dss_mtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后介绍chunk_alloc_mmap。同dss方式类似，mmap也存在对齐的问题。由于系统mmap调用无法指定alignment，因此Je实现了一个可以实现对齐但速度更慢的mmap slow方式。作为弥补，在chunk alloc mmap时先尝试依照普通方式mmap，如果返回值恰好满足对齐要求则直接返回(多数情况下是可行的)。否则将返回值munmap，再调用mmap slow.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">chunk_alloc_mmap</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> alignment, <span class="type">bool</span> *zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    ret = pages_map(<span class="literal">NULL</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    offset = ALIGNMENT_ADDR2OFFSET(ret, alignment);</span><br><span class="line">    <span class="keyword">if</span> (offset != <span class="number">0</span>) &#123;</span><br><span class="line">        pages_unmap(ret, size);</span><br><span class="line">        <span class="keyword">return</span> (chunk_alloc_mmap_slow(size, alignment, zero));</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mmap slow通过事先分配超量size，对齐后再执行trim，去掉前后余量实现mmap对齐。page trim通过两次munmap将leadsize和trailsize部分分别释放。因此理论上，mmap slow需要最多三次munmap.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|&lt;-------------alloc_size----------&gt;|</span><br><span class="line">+-----------+-----   --+------------+</span><br><span class="line">| lead_size | size...  | trail_size |</span><br><span class="line">+-----------+-----   --+------------+</span><br><span class="line">^           ^</span><br><span class="line">|           |</span><br><span class="line">pages      ret(alignment)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">chunk_alloc_mmap_slow</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> alignment, <span class="type">bool</span> *zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    alloc_size = size + alignment - PAGE;</span><br><span class="line">    <span class="keyword">if</span> (alloc_size &lt; size)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        pages = pages_map(<span class="literal">NULL</span>, alloc_size);</span><br><span class="line">        <span class="keyword">if</span> (pages == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">        leadsize = ALIGNMENT_CEILING((<span class="type">uintptr_t</span>)pages, alignment) -</span><br><span class="line">            (<span class="type">uintptr_t</span>)pages;</span><br><span class="line">        ret = pages_trim(pages, alloc_size, leadsize, size);</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret == <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">pages_trim</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> alloc_size, <span class="type">size_t</span> leadsize, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)addr + leadsize);</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> trailsize = alloc_size - leadsize - size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leadsize != <span class="number">0</span>)</span><br><span class="line">            pages_unmap(addr, leadsize);</span><br><span class="line">        <span class="keyword">if</span> (trailsize != <span class="number">0</span>)</span><br><span class="line">            pages_unmap((<span class="type">void</span> *)((<span class="type">uintptr_t</span>)ret + size), trailsize);</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-Small-allocation-tcache"><a href="#3-4-Small-allocation-tcache" class="headerlink" title="3.4 - Small allocation (tcache)"></a>3.4 - Small allocation (tcache)</h3><p>tcache内分配按照先easy后hard的方式。easy方式直接从tcache bin的avail-stack中获得可用region。如果tbin耗尽，使用hard方式，先refill avail-stack，再执行easy分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_alloc_small</span><span class="params">(<span class="type">tcache_t</span> *tcache, <span class="type">size_t</span> size, <span class="type">bool</span> zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 先从tcache bin尝试分配</span></span><br><span class="line">    ret = tcache_alloc_easy(tbin);</span><br><span class="line">    <span class="comment">// xf: 如果尝试失败，则refill tcache bin，并尝试分配</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = tcache_alloc_small_hard(tcache, tbin, binind);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 执行tcache event</span></span><br><span class="line">    tcache_event(tcache);</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_alloc_easy</span><span class="params">(<span class="type">tcache_bin_t</span> *tbin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 如果tcache bin耗尽，更新水线为-1</span></span><br><span class="line">    <span class="keyword">if</span> (tbin-&gt;ncached == <span class="number">0</span>) &#123;</span><br><span class="line">        tbin-&gt;low_water = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: pop栈顶的region，如果需要更新水线</span></span><br><span class="line">    tbin-&gt;ncached--;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">int</span>)tbin-&gt;ncached &lt; tbin-&gt;low_water)</span><br><span class="line">        tbin-&gt;low_water = tbin-&gt;ncached;</span><br><span class="line">    ret = tbin-&gt;avail[tbin-&gt;ncached];</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_alloc_small_hard</span><span class="params">(<span class="type">tcache_t</span> *tcache, <span class="type">tcache_bin_t</span> *tbin, <span class="type">size_t</span> binind)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    arena_tcache_fill_small(tcache-&gt;arena, tbin, binind,</span><br><span class="line">        config_prof ? tcache-&gt;prof_accumbytes : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (config_prof)</span><br><span class="line">        tcache-&gt;prof_accumbytes = <span class="number">0</span>;</span><br><span class="line">    ret = tcache_alloc_easy(tbin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcache fill同普通的arena bin分配类似。首先，获得与tbin相同index的arena bin。之后确定fill值，该数值与2.7节介绍的lg_fill_div有关。如果arena run的runcur可用则直接分配并push stack，否则arena_bin_malloc_hard分配region。push后的顺序按照从低到高排列，低地址的region更靠近栈顶位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_tcache_fill_small</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">tcache_bin_t</span> *tbin, <span class="type">size_t</span> binind,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> prof_accumbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 得到与tbin同index的arena bin</span></span><br><span class="line">    bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">    malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: tbin的充满度与lg_fill_div相关</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, nfill = (tcache_bin_info[binind].ncached_max &gt;&gt;</span><br><span class="line">        tbin-&gt;lg_fill_div); i &lt; nfill; i++) &#123;</span><br><span class="line">        <span class="comment">// xf: 如果current run可用，则从中分配</span></span><br><span class="line">        <span class="keyword">if</span> ((run = bin-&gt;runcur) != <span class="literal">NULL</span> &amp;&amp; run-&gt;nfree &gt; <span class="number">0</span>)</span><br><span class="line">            ptr = arena_run_reg_alloc(run, &amp;arena_bin_info[binind]);</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// xf: current run耗尽，则从bin中查找其他run分配</span></span><br><span class="line">            ptr = arena_bin_malloc_hard(arena, bin);</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: 低地址region优先放入栈顶</span></span><br><span class="line">        tbin-&gt;avail[nfill - <span class="number">1</span> - i] = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: 更新ncached</span></span><br><span class="line">    tbin-&gt;ncached = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如2.7节所述，tcache在每次分配和释放后都会更新ev_cnt计数器。当计数周期达到TCACHE_GC_INCR时，就会启动tcache gc。gc过程中会清理相当于low_water 3/4数量的region，并根据当前的low_water和lg_fill_div动态调整下一次refill时，tbin的充满度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_bin_flush_small</span><span class="params">(<span class="type">tcache_bin_t</span> *tbin, <span class="type">size_t</span> binind, <span class="type">unsigned</span> rem,</span></span><br><span class="line"><span class="params">    <span class="type">tcache_t</span> *tcache)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......   </span><br><span class="line">    <span class="comment">// xf: 循环scan，直到nflush为空。</span></span><br><span class="line">    <span class="comment">// 因为avail-stack中的region可能来自不同arena，因此需要多次scan.</span></span><br><span class="line">    <span class="comment">// 每次scan将不同arena的region移动到栈顶，留到下一轮scan时清理。</span></span><br><span class="line">    <span class="keyword">for</span> (nflush = tbin-&gt;ncached - rem; nflush &gt; <span class="number">0</span>; nflush = ndeferred) &#123;</span><br><span class="line">        <span class="comment">// xf: 获得栈顶region所属的arena和arena bin</span></span><br><span class="line">        <span class="type">arena_chunk_t</span> *chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(</span><br><span class="line">            tbin-&gt;avail[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">arena_t</span> *arena = chunk-&gt;arena;</span><br><span class="line">        <span class="type">arena_bin_t</span> *bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: 锁住栈顶region的arena bin</span></span><br><span class="line">        malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: ndefered代表所属不同arena的region被搬移的位置，默认从0开始。</span></span><br><span class="line">        <span class="comment">// 本意是随着scan进行，nflush逐渐递增，nflush之前的位置空缺出来。</span></span><br><span class="line">        <span class="comment">// 当scan到不同arena region时，将其指针移动到nflush前面的空缺中，</span></span><br><span class="line">        <span class="comment">// 留到下一轮scan, nflush重新开始。直到ndefered和nflush重新为0.</span></span><br><span class="line">        ndeferred = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nflush; i++) &#123;</span><br><span class="line">            ptr = tbin-&gt;avail[i];</span><br><span class="line">            chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(ptr);</span><br><span class="line">            <span class="comment">// xf: 如果scan的region与栈顶region位于同一arena，则释放，</span></span><br><span class="line">            <span class="comment">// 否则移动到ndefered标注的位置，留到后面scan.</span></span><br><span class="line">            <span class="keyword">if</span> (chunk-&gt;arena == arena) &#123;</span><br><span class="line">                <span class="type">size_t</span> pageind = ((<span class="type">uintptr_t</span>)ptr -</span><br><span class="line">                    (<span class="type">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE;</span><br><span class="line">                <span class="type">arena_chunk_map_t</span> *mapelm =</span><br><span class="line">                    arena_mapp_get(chunk, pageind);</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// xf: 释放多余region</span></span><br><span class="line">                arena_dalloc_bin_locked(arena, chunk, ptr,</span><br><span class="line">                    mapelm);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tbin-&gt;avail[ndeferred] = ptr;</span><br><span class="line">                ndeferred++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 将remainder regions指针移动到栈顶位置，完成gc过程</span></span><br><span class="line">    memmove(tbin-&gt;avail, &amp;tbin-&gt;avail[tbin-&gt;ncached - rem],</span><br><span class="line">        rem * <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">    <span class="comment">// xf: 修正ncached以及low_water</span></span><br><span class="line">    tbin-&gt;ncached = rem;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">int</span>)tbin-&gt;ncached &lt; tbin-&gt;low_water)</span><br><span class="line">        tbin-&gt;low_water = tbin-&gt;ncached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-Large-allocation"><a href="#3-5-Large-allocation" class="headerlink" title="3.5 - Large allocation"></a>3.5 - Large allocation</h3><p>Arena上的large alloc同small相比除了省去arena bin的部分之外，并无本质区别。基本算法如下，</p>
<ol>
<li>把请求大小对齐到page size上，直接从avail-tree上寻找first-best-fit runs.如果成功，则根据请求大小切割内存。切割过程也同切割small run类似，区别在之后对chunk map的初始化不同。chunk map细节可回顾2.3.3。如果失败，则进入下一步。</li>
<li>没有可用runs，尝试创建new chunk，成功同样切割run，失败进入下一步。</li>
<li>再次尝试从avail-tree上寻找可用runs，并返回。</li>
</ol>
<p>同上面的过程可以看出，所谓large region分配相当于small run的分配。区别仅在于chunk map信息不同。</p>
<p>Tcache上的large alloc同样按照先easy后hard的顺序。尽管常规arena上的分配不存在large bin，但在tcache中却存在large tbin，因此仍然是先查找avail-stack.如果tbin中找不到，就会向arena申请large runs。这里与small alloc的区别在不执行tbin refill，因为考虑到过多large region的占用量问题。large tbin仅在tcache_dalloc_large的时候才负责收集region。当tcache已满或GC周期到时执行tcache gc.</p>
<h3 id="3-6-Huge-allocation"><a href="#3-6-Huge-allocation" class="headerlink" title="3.6 - Huge allocation"></a>3.6 - Huge allocation</h3><p>Huge alloc相对于前面就更加简单。因为对于Je而言，huge region和chunk是等同的，这在前面有过叙述。Huge alloc就是调用chunk alloc，并将extent_node记录在huge tree上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">huge_palloc</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">size_t</span> size, <span class="type">size_t</span> alignment, <span class="type">bool</span> zero)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line">    <span class="type">size_t</span> csize;</span><br><span class="line">    <span class="type">extent_node_t</span> *node;</span><br><span class="line">    <span class="type">bool</span> is_zeroed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: huge alloc对齐到chunksize</span></span><br><span class="line">    csize = CHUNK_CEILING(size);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: create extent node以记录huge region</span></span><br><span class="line">    node = base_node_alloc();</span><br><span class="line">    ......</span><br><span class="line">    arena = choose_arena(arena);</span><br><span class="line">    <span class="comment">// xf: 调用chunk alloc分配</span></span><br><span class="line">    ret = arena_chunk_alloc_huge(arena, csize, alignment, &amp;is_zeroed);</span><br><span class="line">    <span class="comment">// xf: 失败则清除extent node</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        base_node_dalloc(node);</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node-&gt;addr = ret;</span><br><span class="line">    node-&gt;size = csize;</span><br><span class="line">    node-&gt;arena = arena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 插入huge tree上</span></span><br><span class="line">    malloc_mutex_lock(&amp;huge_mtx);</span><br><span class="line">    extent_tree_ad_insert(&amp;huge, node);</span><br><span class="line">    malloc_mutex_unlock(&amp;huge_mtx);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="4-Deallocation"><a href="#4-Deallocation" class="headerlink" title="4 - Deallocation"></a>4 - Deallocation</h2><h3 id="4-1-Overview"><a href="#4-1-Overview" class="headerlink" title="4.1 - Overview"></a>4.1 - Overview</h3><p>释放同分配过程相反，按照一个从ptr -&gt; run -&gt; bin -&gt; chunk -&gt; arena的路径。但因为涉及page合并和purge，实现更为复杂。dalloc的入口从je_free -&gt; ifree -&gt; iqalloc -&gt; iqalloct -&gt; idalloct.对dalloc的分析从idalloct开始。代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">idalloct</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">bool</span> try_tcache)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 获得被释放地址所在的chunk</span></span><br><span class="line">    chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(ptr);</span><br><span class="line">    <span class="keyword">if</span> (chunk != ptr)</span><br><span class="line">        arena_dalloc(chunk, ptr, try_tcache);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        huge_dalloc(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会检测被释放指针ptr所在chunk的首地址与ptr是否一致，如果是，则一定为huge region，否则为small/large。从这里分为arena和huge两条线。</p>
<p>再看一下arena_dalloc，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_dalloc</span><span class="params">(<span class="type">arena_chunk_t</span> *chunk, <span class="type">void</span> *ptr, <span class="type">bool</span> try_tcache)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 得到页面mapbits</span></span><br><span class="line">    mapbits = arena_mapbits_get(chunk, pageind);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> ((mapbits &amp; CHUNK_MAP_LARGE) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (try_tcache &amp;&amp; (tcache = tcache_get(<span class="literal">false</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// xf: ptr所在tcache的index</span></span><br><span class="line">            binind = arena_ptr_small_binind_get(ptr, mapbits);</span><br><span class="line">            tcache_dalloc_small(tcache, ptr, binind);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            arena_dalloc_small(chunk-&gt;arena, chunk, ptr, pageind);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> size = arena_mapbits_large_size_get(chunk, pageind);</span><br><span class="line">        <span class="keyword">if</span> (try_tcache &amp;&amp; size &lt;= tcache_maxclass &amp;&amp; (tcache =</span><br><span class="line">            tcache_get(<span class="literal">false</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tcache_dalloc_large(tcache, ptr, size);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            arena_dalloc_large(chunk-&gt;arena, chunk, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过得到ptr所在page的mapbits，判断其来自于small还是large。然后再分别作处理。</p>
<p>因此，在dalloc一开始基本上分成了small/large/huge三条路线执行。事实上，结合前面的知识，large/huge可以看作run和chunk的特例。所以，这三条dalloc路线最终会汇到一起，只需要搞清楚其中最为复杂的small region dalloc就可以了。</p>
<p>无论small/large region，都会先尝试释放回tcache，不管其是否从tache中分配而来。所谓tcache dalloc只不过是将region记录在tbin中，并不算真正的释放。除非两种情况，一是如果当前线程tbin已满，会直接执行一次tbin flush，释放出部分tbin空间。二是如果tcache_event触发发了tache gc，也会执行flush。两者的区别在于，前者会回收指定tbin 1/2的空间，而后者则释放next_gc_bin相当于3/4low water数量的空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_dalloc_small</span><span class="params">(<span class="type">tcache_t</span> *tcache, <span class="type">void</span> *ptr, <span class="type">size_t</span> binind)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    tbin = &amp;tcache-&gt;tbins[binind];</span><br><span class="line">    tbin_info = &amp;tcache_bin_info[binind];</span><br><span class="line">    <span class="comment">// xf: 如果当前tbin已满，则执行flush清理tbin</span></span><br><span class="line">    <span class="keyword">if</span> (tbin-&gt;ncached == tbin_info-&gt;ncached_max) &#123;</span><br><span class="line">        tcache_bin_flush_small(tbin, binind, (tbin_info-&gt;ncached_max &gt;&gt;</span><br><span class="line">            <span class="number">1</span>), tcache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: 将被释放的ptr重新push进tbin</span></span><br><span class="line">    tbin-&gt;avail[tbin-&gt;ncached] = ptr;</span><br><span class="line">    tbin-&gt;ncached++;</span><br><span class="line"></span><br><span class="line">    tcache_event(tcache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcache gc和tcache flush在2.7和3.4节中已经介绍，不再赘述。</p>
<h3 id="4-2-arena-dalloc-bin"><a href="#4-2-arena-dalloc-bin" class="headerlink" title="4.2 - arena_dalloc_bin"></a>4.2 - arena_dalloc_bin</h3><p>small region dalloc的第一步是尝试将region返还给所属的bin。首要的步骤就是根据用户传入的ptr推算出其所在run的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run addr = chunk base + run page offset &lt;&lt; LG_PAGE</span><br></pre></td></tr></table></figure>
<p>而run page offset根据2.3.3小节的说明，可以通过ptr所在page的mapbits获得。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run page offset = ptr page index - ptr page offset</span><br></pre></td></tr></table></figure>
<p>得到run后就进一步拿到所属的bin，接着对bin加锁并回收，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_dalloc_bin</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">void</span> *ptr,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> pageind, <span class="type">arena_chunk_map_t</span> *mapelm)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 计算ptr所在run地址。    </span></span><br><span class="line">    run = (<span class="type">arena_run_t</span> *)((<span class="type">uintptr_t</span>)chunk + (<span class="type">uintptr_t</span>)((pageind -</span><br><span class="line">        arena_mapbits_small_runind_get(chunk, pageind)) &lt;&lt; LG_PAGE));</span><br><span class="line">    bin = run-&gt;bin;</span><br><span class="line"> </span><br><span class="line">    malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">    arena_dalloc_bin_locked(arena, chunk, ptr, mapelm);</span><br><span class="line">    malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock的内容无非是将region在run内部的bitmap上标记为可用。bitmap unset的过程此处省略，请参考3.3.1小节中分配算法的解释。与tcache dalloc类似，通常情况下region并不会真正释放。但如果run内部全部为空闲region，则会进一步触发run的释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_dalloc_bin_locked</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">void</span> *ptr,</span></span><br><span class="line"><span class="params">    <span class="type">arena_chunk_map_t</span> *mapelm)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">// xf: 通过run回收region，在bitmap上重新标记region可用。</span></span><br><span class="line">    arena_run_reg_dalloc(run, ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 如果其所在run完全free，则尝试释放该run.</span></span><br><span class="line">    <span class="comment">// 如果所在run处在将满状态(因为刚刚的释放腾出一个region的空间),</span></span><br><span class="line">    <span class="comment">// 则根据地址高低优先将其交换到current run的位置(MRU).</span></span><br><span class="line">    <span class="keyword">if</span> (run-&gt;nfree == bin_info-&gt;nregs) &#123;</span><br><span class="line">        arena_dissociate_bin_run(chunk, run, bin);</span><br><span class="line">        arena_dalloc_bin_run(arena, chunk, run, bin);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (run-&gt;nfree == <span class="number">1</span> &amp;&amp; run != bin-&gt;runcur)</span><br><span class="line">        arena_bin_lower_run(arena, chunk, run, bin);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外还有一种情况是，如果原先run本来是满的，因为前面的释放多出一个空闲位置，就会尝试与current run交换位置。若当前run比current run地址更低，会替代后者并成为新的current run，这样的好处显然可以保证低地址的内存更紧实。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_bin_lower_run</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">arena_run_t</span> *run,</span></span><br><span class="line"><span class="params">    <span class="type">arena_bin_t</span> *bin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uintptr_t</span>)run &lt; (<span class="type">uintptr_t</span>)bin-&gt;runcur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bin-&gt;runcur-&gt;nfree &gt; <span class="number">0</span>)</span><br><span class="line">            arena_bin_runs_insert(bin, bin-&gt;runcur);</span><br><span class="line">        bin-&gt;runcur = run;</span><br><span class="line">        <span class="keyword">if</span> (config_stats)</span><br><span class="line">            bin-&gt;stats.reruns++;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        arena_bin_runs_insert(bin, run);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下，至此一个small region就释放完毕了，准确的说是回收了。但如前面所说，若整个run都为空闲region，则进入run dalloc。这是一个比较复杂的过程。</p>
<h3 id="4-3-small-run-dalloc"><a href="#4-3-small-run-dalloc" class="headerlink" title="4.3 - small run dalloc"></a>4.3 - small run dalloc</h3><p>一个non-full的small run被记录在bin内的run tree上，因此要移除它，首先要移除其在run tree中的信息，即arena_dissociate_bin_run.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_dissociate_bin_run</span><span class="params">(<span class="type">arena_chunk_t</span> *chunk, <span class="type">arena_run_t</span> *run,</span></span><br><span class="line"><span class="params">    <span class="type">arena_bin_t</span> *bin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// xf: 如果当前run为current run，清除runcur。否则，从run tree上remove.</span></span><br><span class="line">    <span class="keyword">if</span> (run == bin-&gt;runcur)</span><br><span class="line">        bin-&gt;runcur = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (bin_info-&gt;nregs != <span class="number">1</span>) &#123;</span><br><span class="line">            arena_bin_runs_remove(bin, run);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来要通过arena_dalloc_bin_run()正式释放run，由于过程稍复杂，这里先给出整个算法的梗概，</p>
<ol>
<li>计算nextind region所在page的index。所谓nextind是run内部clean-dirty region的边界。如果内部存在clean pages则执行下一步，否则执行3.</li>
<li>将原始的small run转化成large run，之后根据上一步得到的nextind将run切割成dirty和clean两部分，且单独释放掉clean部分。  </li>
<li>将待remove的run pages标记为unalloc。且根据传入的dirty和cleaned两个hint决定标记后的page mapbits的dirty flag.</li>
<li>检查unalloc后的run pages是否可以前后合并。合并的标准是，<ol>
<li>不超过chunk范围</li>
<li>前后毗邻的page同样为unalloc</li>
<li>前后毗邻page的dirty flag与run pages相同。</li>
</ol>
</li>
<li>将合并后(也可能没合并)的unalloc run插入avail-tree.</li>
<li>检查如果unalloc run的大小等于chunk size，则将chunk释放掉。</li>
<li>如果之前释放run pages为dirty，则检查当前arena内部的dirty-active pages比例。若dirty数量超过了active的1/8(Android这里的标准有所不同)，则启动arena purge.否则直接返回。</li>
<li>计算当前arena可以清理的dirty pages数量npurgatory.</li>
<li>从dirty tree上依次取出dirty chunk，并检查内部的unalloc dirty pages，将其重新分配为large pages，并插入到临时的queue中。</li>
<li>对临时队列中的dirty pages执行purge，返回值为unzeroed标记。再将purged pages的unzeroed标记设置一遍。</li>
<li>最后对所有purged pages重新执行一遍dalloc run操作，将其重新释放回avail-tree.</li>
</ol>
<p>可以看到，释放run本质上是将其回收至avail-tree。但额外的dirty page机制却增加了整个算法的复杂程度。原因就在于，Je使用了不同以往的内存释放方式。</p>
<p>在Dl这样的经典分配器中，系统内存回收方式更加”古板”。比如在heap区需要top-most space存在大于某个threshold的连续free空间时才能进行auto-trimming。而mmap区则更要等到某个segment全部空闲才能执行munmap。这对于回收系统内存是极为不利的，因为条件过于严格。</p>
<p>而Je使用了更为聪明的方式，并不会直接交还系统内存，而是通过madvise暂时释放掉页面与物理页面之间的映射。本质上这同sbrk/munmap之类的调用要达到的目的是类似的，只不过从进程内部的角度看，该地址仍然被占用。但Je对这些使用过的地址都详细做了记录，因此再分配时可以recycle，并不会导致对线性地址无休止的开采。</p>
<p>另外，为了提高对已释放page的利用率，Je将unalloc pages用dirty flag(注意，这里同page replacement中的含义不同)做了标记。所有pages被分成active, dirty和clean三种。dirty pages表示曾经使用过，且仍可能关联着物理页面，recycle速度较快。而clean则代表尚未使用，或已经通过purge释放了物理页面，较前者速度慢。显然，需要一种内置算法来保持三种page的动态平衡，以兼顾分配速度和内存占用量。如果当前dirty pages数量超过了active pages数量的1/2^opt_lg_dirty_mult，就会启动arena_purge()。这个值默认是1/8，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_maybe_purge</span><span class="params">(<span class="type">arena_t</span> *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 如果当前dirty pages全部在执行purging，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (arena-&gt;ndirty &lt;= arena-&gt;npurgatory)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// xf: 检查purageable pages是否超出active-dirty比率，超出则</span></span><br><span class="line">    <span class="comment">// 执行purge。google在这里增加了ANDROID_ALWAYS_PURGE开关，</span></span><br><span class="line">    <span class="comment">// 打开则总会执行arena_purge(默认是打开的).</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(ANDROID_ALWAYS_PURGE)</span></span><br><span class="line">    npurgeable = arena-&gt;ndirty - arena-&gt;npurgatory;</span><br><span class="line">    threshold = (arena-&gt;nactive &gt;&gt; opt_lg_dirty_mult);</span><br><span class="line">    <span class="keyword">if</span> (npurgeable &lt;= threshold)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 执行purge</span></span><br><span class="line">    arena_purge(arena, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但google显然希望对dirty pages管理更严格一些，以适应移动设备上内存偏小的问题。这里增加了一个ALWAYS_PURGE的开关，打开后会强制每次释放时都执行arena_purge.</p>
<p>arena_run_dalloc代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_run_dalloc</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_run_t</span> *run, <span class="type">bool</span> dirty, <span class="type">bool</span> cleaned)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 如果run pages的dirty flag实际读取为true，且cleaned不为true,</span></span><br><span class="line">    <span class="comment">// 则同样认为该pages在dalloc后是dirty的，否则被视为clean(该情况适用于</span></span><br><span class="line">    <span class="comment">// chunk purge后，重新dalloc时，此时的run pages虽然dirty flag可能为ture,</span></span><br><span class="line">    <span class="comment">// 但经过purge后应该修改为clean).</span></span><br><span class="line">    <span class="keyword">if</span> (cleaned == <span class="literal">false</span> &amp;&amp; arena_mapbits_dirty_get(chunk, run_ind) != <span class="number">0</span>)</span><br><span class="line">        dirty = <span class="literal">true</span>;</span><br><span class="line">    flag_dirty = dirty ? CHUNK_MAP_DIRTY : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 将被remove的run标记为unalloc pages。前面的判断如果是dirty，则pages</span></span><br><span class="line">    <span class="comment">// mapbits将带有dirty flag，否则将不带有dirty flag.</span></span><br><span class="line">    <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        arena_mapbits_unallocated_set(chunk, run_ind, size,</span><br><span class="line">            CHUNK_MAP_DIRTY);</span><br><span class="line">        arena_mapbits_unallocated_set(chunk, run_ind+run_pages<span class="number">-1</span>, size,</span><br><span class="line">            CHUNK_MAP_DIRTY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arena_mapbits_unallocated_set(chunk, run_ind, size,</span><br><span class="line">            arena_mapbits_unzeroed_get(chunk, run_ind));</span><br><span class="line">        arena_mapbits_unallocated_set(chunk, run_ind+run_pages<span class="number">-1</span>, size,</span><br><span class="line">            arena_mapbits_unzeroed_get(chunk, run_ind+run_pages<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 尝试将被remove run与前后unalloc pages 合并。</span></span><br><span class="line">    arena_run_coalesce(arena, chunk, &amp;size, &amp;run_ind, &amp;run_pages,</span><br><span class="line">        flag_dirty);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 将执行过合并后的run重新insert到avail-tree</span></span><br><span class="line">    arena_avail_insert(arena, chunk, run_ind, run_pages, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 检查如果合并后的size已经完全unallocated，则dalloc整个chunk</span></span><br><span class="line">    <span class="keyword">if</span> (size == arena_maxclass) &#123;</span><br><span class="line">        ......</span><br><span class="line">        arena_chunk_dalloc(arena, chunk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dirty)</span><br><span class="line">        arena_maybe_purge(arena);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>coalesce代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_run_coalesce</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">size_t</span> *p_size,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> *p_run_ind, <span class="type">size_t</span> *p_run_pages, <span class="type">size_t</span> flag_dirty)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 尝试与后面的pages合并</span></span><br><span class="line">    <span class="keyword">if</span> (run_ind + run_pages &lt; chunk_npages &amp;&amp;</span><br><span class="line">        arena_mapbits_allocated_get(chunk, run_ind+run_pages) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        arena_mapbits_dirty_get(chunk, run_ind+run_pages) == flag_dirty) &#123;</span><br><span class="line">        <span class="type">size_t</span> nrun_size = arena_mapbits_unallocated_size_get(chunk,</span><br><span class="line">            run_ind+run_pages);</span><br><span class="line">        <span class="type">size_t</span> nrun_pages = nrun_size &gt;&gt; LG_PAGE;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: 如果与后面的unalloc pages合并，remove page时后方的adjacent</span></span><br><span class="line">        <span class="comment">// hint应为true</span></span><br><span class="line">        arena_avail_remove(arena, chunk, run_ind+run_pages, nrun_pages,</span><br><span class="line">            <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        size += nrun_size;</span><br><span class="line">        run_pages += nrun_pages;</span><br><span class="line"></span><br><span class="line">        arena_mapbits_unallocated_size_set(chunk, run_ind, size);</span><br><span class="line">        arena_mapbits_unallocated_size_set(chunk, run_ind+run_pages<span class="number">-1</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 尝试与前面的pages合并</span></span><br><span class="line">    <span class="keyword">if</span> (run_ind &gt; map_bias &amp;&amp; arena_mapbits_allocated_get(chunk,</span><br><span class="line">        run_ind<span class="number">-1</span>) == <span class="number">0</span> &amp;&amp; arena_mapbits_dirty_get(chunk, run_ind<span class="number">-1</span>) ==</span><br><span class="line">        flag_dirty) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p_size = size;</span><br><span class="line">    *p_run_ind = run_ind;</span><br><span class="line">    *p_run_pages = run_pages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>avail-tree remove代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_avail_remove</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">size_t</span> pageind,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> npages, <span class="type">bool</span> maybe_adjac_pred, <span class="type">bool</span> maybe_adjac_succ)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 该调用可能将导致chunk内部的碎片化率改变，从而影响其在dirty tree</span></span><br><span class="line">    <span class="comment">// 中的排序。因此，在正式remove之前需要将chunk首先从dirty tree中remove,</span></span><br><span class="line">    <span class="comment">// 待更新内部ndirty后，再将其重新insert回dirty tree.</span></span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;ndirty != <span class="number">0</span>)</span><br><span class="line">        arena_chunk_dirty_remove(&amp;arena-&gt;chunks_dirty, chunk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: maybe_adjac_pred/succ是外界传入的hint，根据该值检查前后是否存在</span></span><br><span class="line">    <span class="comment">// clean-dirty边界。若存在边界，则remove avail pages后边界将减1.</span></span><br><span class="line">    <span class="keyword">if</span> (maybe_adjac_pred &amp;&amp; arena_avail_adjac_pred(chunk, pageind))</span><br><span class="line">        chunk-&gt;nruns_adjac--;</span><br><span class="line">    <span class="keyword">if</span> (maybe_adjac_succ &amp;&amp; arena_avail_adjac_succ(chunk, pageind, npages))</span><br><span class="line">        chunk-&gt;nruns_adjac--;</span><br><span class="line">    chunk-&gt;nruns_avail--;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 更新arena及chunk中dirty pages统计。</span></span><br><span class="line">    <span class="keyword">if</span> (arena_mapbits_dirty_get(chunk, pageind) != <span class="number">0</span>) &#123;</span><br><span class="line">        arena-&gt;ndirty -= npages;</span><br><span class="line">        chunk-&gt;ndirty -= npages;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: 如果chunk内部dirty不为0，将其重新insert到arena dirty tree.</span></span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;ndirty != <span class="number">0</span>)</span><br><span class="line">        arena_chunk_dirty_insert(&amp;arena-&gt;chunks_dirty, chunk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 从chunk avail-tree中remove掉unalloc pages.</span></span><br><span class="line">    arena_avail_tree_remove(&amp;arena-&gt;runs_avail, arena_mapp_get(chunk,</span><br><span class="line">        pageind));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从avail-tree上remove pages可能会改变当前chunk内部clean-dirty碎片率，因此一开始要将其所在chunk从dirty tree上remove，再从avail-tree上remove pages。另外，arena_avail_insert()的算法同remove是一样的，只是方向相反，不再赘述。</p>
<h3 id="4-4-arena-purge"><a href="#4-4-arena-purge" class="headerlink" title="4.4 - arena purge"></a>4.4 - arena purge</h3><p>清理arena的方式是按照从小到大的顺序遍历一棵dirty tree，直到将dirty pages降低到threshold以下。dirty tree挂载所有dirty chunks，同其他tree的区别在于它的cmp函数较特殊，决定了最终的purging order，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">arena_chunk_dirty_comp</span><span class="params">(<span class="type">arena_chunk_t</span> *a, <span class="type">arena_chunk_t</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> a_val = (a-&gt;nruns_avail - a-&gt;nruns_adjac) *</span><br><span class="line">            b-&gt;nruns_avail;</span><br><span class="line">        <span class="type">size_t</span> b_val = (b-&gt;nruns_avail - b-&gt;nruns_adjac) *</span><br><span class="line">            a-&gt;nruns_avail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_val &lt; b_val)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a_val &gt; b_val)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> a_chunk = (<span class="type">uintptr_t</span>)a;</span><br><span class="line">        <span class="type">uintptr_t</span> b_chunk = (<span class="type">uintptr_t</span>)b;</span><br><span class="line">        <span class="type">int</span> ret = ((a_chunk &gt; b_chunk) - (a_chunk &lt; b_chunk));</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;nruns_adjac == <span class="number">0</span>) &#123;</span><br><span class="line">            assert(b-&gt;nruns_adjac == <span class="number">0</span>);</span><br><span class="line">            ret = -ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Je在这里给出的算法是这样的，</p>
<ol>
<li>首先排除short cut，即a和b相同的特例。</li>
<li>计算a, b的fragmentation，该数值越高，相应的在dirty tree上就越靠前。<br> 其计算方法为，</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前平均avail run大小    所有avail run数量 - 边界数量</span><br><span class="line">--------------------- =  -----------------------------</span><br><span class="line"> 去碎片后的平均大小           所有avail run数量</span><br></pre></td></tr></table></figure>
<p>注意，这个fragment不是通常意义理解的碎片。这里指由于clean-dirty边界形成的所谓碎片，并且是可以通过purge清除掉的，如图，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nruns_adjac = <span class="number">2</span>    </span><br><span class="line">+--------+----------+--------+-------+---------+----------+--------+-----</span><br><span class="line">| dirty  |  clean   |        | clean |  dirty  |          | dirty  | ...</span><br><span class="line">+--------+----------+--------+-------+---------+----------+--------+-----</span><br><span class="line">         ^                           ^</span><br><span class="line">         |                           |</span><br><span class="line">         +--adjac #<span class="number">0</span>                 +--adjac #<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ol>
<li>当a, b的fragmentation相同时，同通常的方法类似，按地址大小排序。但若nruns_adjac为0，即不存在clean-dirty边界时，反而会将低地址chunk排到后面。因为adjac为0的chunk再利用价值是比较高的，所以放到后面可以增加其在purge中的幸存几率，从而提升recycle效率。</li>
</ol>
<p>purge代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_purge</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">bool</span> all)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 计算purgeable pages，结果加入到npurgatory信息中。</span></span><br><span class="line">    npurgatory = arena_compute_npurgatory(arena, all);</span><br><span class="line">    arena-&gt;npurgatory += npurgatory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 从dirty chunk tree上逐chunk执行purge，直到期望值npurgatory为0</span></span><br><span class="line">    <span class="keyword">while</span> (npurgatory &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        chunk = arena_chunk_dirty_first(&amp;arena-&gt;chunks_dirty);</span><br><span class="line">        <span class="comment">// xf: traversal结束，当前线程无法完成purge任务，返回。</span></span><br><span class="line">        <span class="keyword">if</span> (chunk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            arena-&gt;npurgatory -= npurgatory;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        npurgeable = chunk-&gt;ndirty;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf:  如果当前chunk中purgeable大于前期计算的purgatory,</span></span><br><span class="line">        <span class="comment">// 且其clean-dirty碎片为0，则让当前线程负责purge所有prgeable pages.</span></span><br><span class="line">        <span class="comment">// 原因是为了尽可能避免避免多个线程对该chunk的purge竞争。</span></span><br><span class="line">        <span class="keyword">if</span> (npurgeable &gt; npurgatory &amp;&amp; chunk-&gt;nruns_adjac == <span class="number">0</span>) &#123;</span><br><span class="line">            arena-&gt;npurgatory += npurgeable - npurgatory;</span><br><span class="line">            npurgatory = npurgeable;</span><br><span class="line">        &#125;</span><br><span class="line">        arena-&gt;npurgatory -= npurgeable;</span><br><span class="line">        npurgatory -= npurgeable;</span><br><span class="line">        npurged = arena_chunk_purge(arena, chunk, all);</span><br><span class="line">        <span class="comment">// xf: 计算purge期望值npurgatory和实际purge值npurged差值</span></span><br><span class="line">        nunpurged = npurgeable - npurged;</span><br><span class="line">        arena-&gt;npurgatory += nunpurged;</span><br><span class="line">        npurgatory += nunpurged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chunk purge如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">arena_chunk_purge</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">bool</span> all)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (chunk == arena-&gt;spare) &#123;</span><br><span class="line">        ......</span><br><span class="line">        arena_chunk_alloc(arena);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 为了减小arena purge时arena lock的暂停时间，先将所有满足</span></span><br><span class="line">    <span class="comment">// 需求的unalloc dirty pages重新&quot;alloc&quot;并保存，待purge结束再重新</span></span><br><span class="line">    <span class="comment">// 释放回avail-tree.</span></span><br><span class="line">    arena_chunk_stash_dirty(arena, chunk, all, &amp;mapelms);</span><br><span class="line">    npurged = arena_chunk_purge_stashed(arena, chunk, &amp;mapelms);</span><br><span class="line">    arena_chunk_unstash_purged(arena, chunk, &amp;mapelms);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (npurged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chunk purge重点在于这是一个线性查找dirty pages过程，Je在这里会导致性能下降。更糟糕的是，之前和之后都是在arena lock被锁定的条件下被执行，绑定同一arena的线程不得不停下工作。因此，在正式purge前需要先把unalloc dirtypages全部临时分配出来，当purging时解锁arena lock，而结束后再一次将它们全部释放。</p>
<p>stash dirty代码，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_chunk_stash_dirty</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">bool</span> all,</span></span><br><span class="line"><span class="params">    <span class="type">arena_chunk_mapelms_t</span> *mapelms)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (pageind = map_bias; pageind &lt; chunk_npages; pageind += npages) &#123;</span><br><span class="line">        <span class="type">arena_chunk_map_t</span> *mapelm = arena_mapp_get(chunk, pageind);</span><br><span class="line">        <span class="keyword">if</span> (arena_mapbits_allocated_get(chunk, pageind) == <span class="number">0</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (arena_mapbits_dirty_get(chunk, pageind) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (all || arena_avail_adjac(chunk, pageind,</span><br><span class="line">                npages))) &#123;</span><br><span class="line">                <span class="type">arena_run_t</span> *run = (<span class="type">arena_run_t</span> *)((<span class="type">uintptr_t</span>)</span><br><span class="line">                    chunk + (<span class="type">uintptr_t</span>)(pageind &lt;&lt; LG_PAGE));</span><br><span class="line">                <span class="comment">// xf: 暂时将这些unalloc dirty pages通过split large</span></span><br><span class="line">                <span class="comment">// 重新分配出来。                   </span></span><br><span class="line">                arena_run_split_large(arena, run, run_size,</span><br><span class="line">                    <span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 加入临时列表，留待后用。   </span></span><br><span class="line">                ql_elm_new(mapelm, u.ql_link);</span><br><span class="line">                ql_tail_insert(mapelms, mapelm, u.ql_link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">            <span class="comment">//xf: 跳过allocated pages</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stash时会根据传入的hint all判断，如果为false，只会stash存在clean-dirty adjac的pages，否则会全部加入列表。</p>
<p>purge stashed pages代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">arena_chunk_purge_stashed</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk,</span></span><br><span class="line"><span class="params">    <span class="type">arena_chunk_mapelms_t</span> *mapelms)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 暂时解锁arena lock，前面已经realloc过，这里不考虑contention问题。</span></span><br><span class="line">    malloc_mutex_unlock(&amp;arena-&gt;lock);</span><br><span class="line">    ......</span><br><span class="line">    ql_foreach(mapelm, mapelms, u.ql_link) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: 逐个purge dirty page，返回pages是否unzeroed.</span></span><br><span class="line">        unzeroed = pages_purge((<span class="type">void</span> *)((<span class="type">uintptr_t</span>)chunk + (pageind &lt;&lt;</span><br><span class="line">            LG_PAGE)), (npages &lt;&lt; LG_PAGE));</span><br><span class="line">        flag_unzeroed = unzeroed ? CHUNK_MAP_UNZEROED : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// xf: 逐pages设置unzeroed标志。</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;</span><br><span class="line">            arena_mapbits_unzeroed_set(chunk, pageind+i,</span><br><span class="line">                flag_unzeroed);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: purging结束重新lock arena</span></span><br><span class="line">    malloc_mutex_lock(&amp;arena-&gt;lock);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (npurged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，在page purge过后，会逐一设置unzero flag。这是因为有些操作系统在demand page后会有一步zero-fill-on-demand。因此，被purge过的clean page当再一次申请到物理页面时会全部填充为0.</p>
<p>unstash代码，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_chunk_unstash_purged</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk,</span></span><br><span class="line"><span class="params">    <span class="type">arena_chunk_mapelms_t</span> *mapelms)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (mapelm = ql_first(mapelms); mapelm != <span class="literal">NULL</span>;</span><br><span class="line">        mapelm = ql_first(mapelms)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        run = (<span class="type">arena_run_t</span> *)((<span class="type">uintptr_t</span>)chunk + (<span class="type">uintptr_t</span>)(pageind &lt;&lt;</span><br><span class="line">            LG_PAGE));</span><br><span class="line">        ql_remove(mapelms, mapelm, u.ql_link);</span><br><span class="line">        arena_run_dalloc(arena, run, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unstash需要再一次调用arena_run_dalloc()以释放临时分配的pages。要注意此时我们已经位于arena_run_dalloc调用栈中，而避免无限递归重入依靠参数cleaned flag.</p>
<h3 id="4-5-arena-chunk-dalloc"><a href="#4-5-arena-chunk-dalloc" class="headerlink" title="4.5 - arena chunk dalloc"></a>4.5 - arena chunk dalloc</h3><p>当free chunk被Je释放时，根据局部性原理，会成为下一个spare chunk而保存起来，其真身并未消散。而原先的spare则会根据内部dalloc方法被处理掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">arena_chunk_dalloc</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 将chunk从avail-tree上remove</span></span><br><span class="line">    arena_avail_remove(arena, chunk, map_bias, chunk_npages-map_bias,</span><br><span class="line">        <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 如果spare不为空，则将被释放的chunk替换原spare chunk.</span></span><br><span class="line">    <span class="keyword">if</span> (arena-&gt;spare != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">arena_chunk_t</span> *spare = arena-&gt;spare;</span><br><span class="line"></span><br><span class="line">        arena-&gt;spare = chunk;</span><br><span class="line">        arena_chunk_dalloc_internal(arena, spare);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        arena-&gt;spare = chunk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同chunk alloc一样，chunk dalloc算法也是可定制的。Je提供的默认算法chunk_dalloc_default最终会调用chunk_unmap，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">chunk_unmap</span><span class="params">(<span class="type">void</span> *chunk, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 如果启用dss，且当前chunk在dss内，将其record在dss tree上。</span></span><br><span class="line">    <span class="comment">// 否则如果就记录在mmap tree上，或者直接munmap释放掉。</span></span><br><span class="line">    <span class="keyword">if</span> (have_dss &amp;&amp; chunk_in_dss(chunk))</span><br><span class="line">        chunk_record(&amp;chunks_szad_dss, &amp;chunks_ad_dss, chunk, size);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (chunk_dalloc_mmap(chunk, size))</span><br><span class="line">        chunk_record(&amp;chunks_szad_mmap, &amp;chunks_ad_mmap, chunk, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在3.3.5小节中alloc时会根据dss和mmap优先执行recycle。源自在dalloc时record在四棵chunk tree上的记录。但同spare记录的不同，这里的记录仅仅只剩下躯壳，record时会强行释放物理页面，因此recycle速度相比spare较慢。</p>
<p>chunk record算法如下，</p>
<ol>
<li>先purge chunk内部所有pages</li>
<li>预分配base node，以记录释放后的chunk。这里分配的node到后面可能没有用，提前分配是因为接下来要加锁chunks_mtx。而如果在临界段内再分配base node,则可能因为base pages不足而申请新的chunk，这样一来就会导致dead lock.</li>
<li>寻找与要插入chunk的毗邻地址。首先尝试与后面的地址合并，成功则用后者的base node记录，之后执行5.</li>
<li>合并失败，用预分配的base node记录chunk.</li>
<li>尝试与前面的地址合并。</li>
<li>如果预分配的base node没有使用，释放掉。</li>
</ol>
<p>代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">chunk_record</span><span class="params">(<span class="type">extent_tree_t</span> *chunks_szad, <span class="type">extent_tree_t</span> *chunks_ad, <span class="type">void</span> *chunk,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: purge all chunk pages</span></span><br><span class="line">    unzeroed = pages_purge(chunk, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 预先分配extent_node以记录chunk。如果该chunk可以进行合并，该node</span></span><br><span class="line">    <span class="comment">// 可能并不会使用。这里预先分配主要是避免dead lock。因为某些情况</span></span><br><span class="line">    <span class="comment">// base_node_alloc同样可能会alloc base chunk，由于后面chunk mutex被lock,</span></span><br><span class="line">    <span class="comment">// 那样将导致dead lock.</span></span><br><span class="line">    xnode = base_node_alloc();</span><br><span class="line">    xprev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;chunks_mtx);</span><br><span class="line">    <span class="comment">// xf: 首先尝试与后面的chunk合并。</span></span><br><span class="line">    key.addr = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)chunk + size);</span><br><span class="line">    node = extent_tree_ad_nsearch(chunks_ad, &amp;key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span> &amp;&amp; node-&gt;addr == key.addr) &#123;</span><br><span class="line">        extent_tree_szad_remove(chunks_szad, node);</span><br><span class="line">        node-&gt;addr = chunk;</span><br><span class="line">        node-&gt;size += size;</span><br><span class="line">        node-&gt;zeroed = (node-&gt;zeroed &amp;&amp; (unzeroed == <span class="literal">false</span>));</span><br><span class="line">        extent_tree_szad_insert(chunks_szad, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="comment">// xf: 合并失败，用提前分配好的xnode保存当前chunk信息。</span></span><br><span class="line">        <span class="keyword">if</span> (xnode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> label_return;</span><br><span class="line">        &#125;</span><br><span class="line">        node = xnode;</span><br><span class="line">        xnode = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;addr = chunk;</span><br><span class="line">        node-&gt;size = size;</span><br><span class="line">        node-&gt;zeroed = (unzeroed == <span class="literal">false</span>);</span><br><span class="line">        extent_tree_ad_insert(chunks_ad, node);</span><br><span class="line">        extent_tree_szad_insert(chunks_szad, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 再尝试与前面的chunk合并</span></span><br><span class="line">    prev = extent_tree_ad_prev(chunks_ad, node);</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span> &amp;&amp; (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)prev-&gt;addr + prev-&gt;size) ==</span><br><span class="line">        chunk) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">label_return:</span><br><span class="line">    malloc_mutex_unlock(&amp;chunks_mtx);</span><br><span class="line">    <span class="comment">// xf: 如果预先分配的node没有使用，则在此将之销毁</span></span><br><span class="line">    <span class="keyword">if</span> (xnode != <span class="literal">NULL</span>)</span><br><span class="line">        base_node_dalloc(xnode);</span><br><span class="line">    <span class="keyword">if</span> (xprev != <span class="literal">NULL</span>)</span><br><span class="line">        base_node_dalloc(xprev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后顺带一提，对于mmap区的pages, Je也可以直接munmap，前提是需要在jemalloc_internal_defs.h中开启JEMALLOC_MUNMAP，这样就不会执行pages purge.默认该选项是不开启的。但源自dss区中的分配则不存在反向释放一说，默认Je也不会优先选择dss就是了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">chunk_dalloc_mmap</span><span class="params">(<span class="type">void</span> *chunk, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config_munmap)</span><br><span class="line">        pages_unmap(chunk, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (config_munmap == <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-large-huge-dalloc"><a href="#4-6-large-huge-dalloc" class="headerlink" title="4.6 - large/huge dalloc"></a>4.6 - large/huge dalloc</h3><p>前面说过large/huge相当于以run和chunk为粒度的特例。因此对于arena dalloc large来说，最终就是arena_run_dalloc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_dalloc_large_locked</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">arena_chunk_t</span> *chunk, <span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config_fill || config_stats) &#123;</span><br><span class="line">        <span class="type">size_t</span> pageind = ((<span class="type">uintptr_t</span>)ptr - (<span class="type">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE;</span><br><span class="line">        <span class="type">size_t</span> usize = arena_mapbits_large_size_get(chunk, pageind);</span><br><span class="line"></span><br><span class="line">        arena_dalloc_junk_large(ptr, usize);</span><br><span class="line">        <span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">            arena-&gt;stats.ndalloc_large++;</span><br><span class="line">            arena-&gt;stats.allocated_large -= usize;</span><br><span class="line">            arena-&gt;stats.lstats[(usize &gt;&gt; LG_PAGE) - <span class="number">1</span>].ndalloc++;</span><br><span class="line">            arena-&gt;stats.lstats[(usize &gt;&gt; LG_PAGE) - <span class="number">1</span>].curruns--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arena_run_dalloc(arena, (<span class="type">arena_run_t</span> *)ptr, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而huge dalloc，则是在huge tree上搜寻，最终执行chunk_dalloc,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">huge_dalloc</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    malloc_mutex_lock(&amp;huge_mtx);</span><br><span class="line"></span><br><span class="line">    key.addr = ptr;</span><br><span class="line">    node = extent_tree_ad_search(&amp;huge, &amp;key);</span><br><span class="line">    assert(node != <span class="literal">NULL</span>);</span><br><span class="line">    assert(node-&gt;addr == ptr);</span><br><span class="line">    extent_tree_ad_remove(&amp;huge, node);</span><br><span class="line"></span><br><span class="line">    malloc_mutex_unlock(&amp;huge_mtx);</span><br><span class="line"></span><br><span class="line">    huge_dalloc_junk(node-&gt;addr, node-&gt;size);</span><br><span class="line">    arena_chunk_dalloc_huge(node-&gt;arena, node-&gt;addr, node-&gt;size);</span><br><span class="line">    base_node_dalloc(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_chunk_dalloc_huge</span><span class="params">(<span class="type">arena_t</span> *arena, <span class="type">void</span> *chunk, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">chunk_dalloc_t</span> *chunk_dalloc;</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;arena-&gt;lock);</span><br><span class="line">    chunk_dalloc = arena-&gt;chunk_dalloc;</span><br><span class="line">    <span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">        arena-&gt;stats.mapped -= size;</span><br><span class="line">        arena-&gt;stats.allocated_huge -= size;</span><br><span class="line">        arena-&gt;stats.ndalloc_huge++;</span><br><span class="line">        stats_cactive_sub(size);</span><br><span class="line">    &#125;</span><br><span class="line">    arena-&gt;nactive -= (size &gt;&gt; LG_PAGE);</span><br><span class="line">    malloc_mutex_unlock(&amp;arena-&gt;lock);</span><br><span class="line">    chunk_dalloc(chunk, size, arena-&gt;ind);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-总结-与Dl的对比"><a href="#5-总结-与Dl的对比" class="headerlink" title="5 - 总结: 与Dl的对比"></a>5 - 总结: 与Dl的对比</h2><ol>
<li>单核单线程分配能力上两者不相上下，甚至小块内存分配速度理论上Dl还略占优势。原因是Dl利用双向链表组织free chunk可以做到O(1)，而尽管Je在bitmap上做了一定优化，但不能做到常数时间。</li>
<li>多核多线程下，Je可以秒杀Dl。arena的加入既可以避免false sharing，又可以减少线程间lock contention。另外，tcache也是可以大幅加快多线程分配速度的技术。这些Dl完全不具备竞争力。</li>
<li>系统内存交换效率上也是Je占明显优势。Je使用mmap/madvise的组合要比Dl使用sbrk/mmap/munmap灵活的多。实际对系统的压力也更小。另外，Dl使用dss-&gt;mmap,追求的是速度，而Je相反mmap-&gt;dss，为的是灵活性。</li>
<li>小块内存的碎片抑制上双方做的都不错，但总体上个人觉得Je更好一些。首先dalloc时，两者对空闲内存都可以实时coalesce。alloc时Dl依靠dv约束外部碎片，Je更简单暴力，直接在固定的small runs里分配。   <ol>
<li>两相比较，dv的候选者是随机的，大小不固定，如果选择比较小的chunk，效果其实有限。更甚者，当找不到dv时，Dl会随意切割top-most space，通常这不利于heap trim.</li>
<li>而small runs则是固定大小，同时是页面的整数倍，对外部碎片的约束力和规整度上都更好。</li>
<li>但Dl的优势在算法更简单，速度更快。无论是coalesce还是split代价都很低。在Je中有可能因为分配8byte的内存而实际去分配并初始化4k甚至4M的空间。</li>
</ol>
</li>
<li>大块内存分配能力上，Dl使用dst管理，而Je采用rb tree。原理上，据说rb tree的cache亲和力较差，不适合memory allocator。我没有仔细研究Je的rb tree实现有何过人之处，暂且认为各有千秋吧。可以肯定的是Je的large/huge region具有比Dl更高的内部碎片，皆因为其更规整的size class划分导致的。</li>
<li>说到size class，可以看到Je的划分明显比Dl更细致，tiny/small/large/huge四种分类能兼顾更多的内存使用模型。且根据不同架构和配置，可以灵活改变划分方式，具有更好的兼容性。Dl划分的相对粗糙很多且比较固定。一方面可能在当时256byte以上就可以算作大块的分配了吧。另一方面某种程度是碍于算法的限制。比如在boundary tag中为了容纳更多的信息，就不能小于8byte(实际有效的最小chunk是16byte), bin数量不得多余31个也是基于位运算的方式。</li>
<li>bookkeeping占用上Dl因为算法简单，本应该占用更少内存。但由于boundary tag本身导致的占用，chunk数量越多，bookkeeping就越大。再考虑到系统回收效率上的劣势，应该说，应用内存占用越大，尤其是小内存使用量越多，运行时间越长，Dl相对于Je内存使用量倾向越大。</li>
<li>安全健壮性。只说一点，boundary tag是原罪，其他的可以免谈了。</li>
</ol>
<h1 id="常量时间获取-metadata"><a href="#常量时间获取-metadata" class="headerlink" title="常量时间获取 metadata"></a>常量时间获取 metadata</h1><p>有了上面的铺垫，现在可以来看一下<code>jemalloc</code>中的地址运算操作及如何在常量时间获取<code>metadata</code>。</p>
<h2 id="从-run-到-region"><a href="#从-run-到-region" class="headerlink" title="从 run 到 region"></a>从 run 到 region</h2><p><code>arena_run_t</code>中只记录了<code>run</code>的分配情况，并没有地址，需要快速的获取到需要分配的<code>region</code>的地址:</p>
<p>先获取到<code>misc</code>的地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_chunk_map_misc_t</span> *miscelm = (<span class="type">arena_chunk_map_misc_t</span></span><br><span class="line"> *)((<span class="type">uintptr_t</span>)run - offsetof(<span class="type">arena_chunk_map_misc_t</span>, run));</span><br></pre></td></tr></table></figure></p>
<p>获取包含该<code>misc</code>的<code>chunk</code>起始地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 因为内存申请以chunk为单位，且按照chunk size对齐，所以只要将低位置零即可获取chunk起始地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	CHUNK_ADDR2BASE(a)						\</span></span><br><span class="line"><span class="meta"> ((void *)((uintptr_t)(a) &amp; ~chunksize_mask))</span></span><br><span class="line"><span class="type">arena_chunk_t</span> *chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(miscelm);</span><br></pre></td></tr></table></figure></p>
<p>获取该<code>misc</code>的<code>page id</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">arena_chunk_t</span> *chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(miscelm);</span><br><span class="line"><span class="comment">/* (该 misc 在数组中的地址偏移 / misc 大小) 即可获取是数组中第几个元素 */</span></span><br><span class="line"><span class="type">size_t</span> pageind = ((<span class="type">uintptr_t</span>)miscelm - ((<span class="type">uintptr_t</span>)chunk +</span><br><span class="line"> map_misc_offset)) / <span class="keyword">sizeof</span>(<span class="type">arena_chunk_map_misc_t</span>) + map_bias;</span><br></pre></td></tr></table></figure></p>
<p>获取<code>misc</code>对应的<code>page</code>地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((<span class="type">void</span> *)((<span class="type">uintptr_t</span>)chunk + (pageind &lt;&lt; LG_PAGE)));</span><br></pre></td></tr></table></figure></p>
<p>获取对应的<code>region</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page 起始地址 + region0 的偏移 + (region id * region size) */</span></span><br><span class="line">ret = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)rpages + (<span class="type">uintptr_t</span>)bin_info-&gt;reg0_offset +</span><br><span class="line"> (<span class="type">uintptr_t</span>)(bin_info-&gt;reg_interval * regind));</span><br></pre></td></tr></table></figure></p>
<h2 id="从-region-到-run"><a href="#从-region-到-run" class="headerlink" title="从 region 到 run"></a>从 region 到 run</h2><p>当释放<code>region</code>时，需要快速查找<code>region</code>对应的<code>run</code>及<code>region id</code>:</p>
<p>先获取到<code>chunk</code>起始地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk = (<span class="type">arena_chunk_t</span> *)CHUNK_ADDR2BASE(ptr);</span><br></pre></td></tr></table></figure></p>
<p>获取<code>region</code>的<code>page id</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pageind = ((<span class="type">uintptr_t</span>)ptr - (<span class="type">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE;</span><br></pre></td></tr></table></figure></p>
<p>获取<code>page</code>对应的<code>map_bits</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (&amp;chunk-&gt;map_bits[pageind-map_bias]);</span><br></pre></td></tr></table></figure></p>
<p>根据<code>map_bits</code>中设置的<code>run page offset</code>获取<code>run</code>的起始<code>page id</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rpages_ind = pageind - arena_mapbits_small_runind_get(chunk, pageind);</span><br><span class="line"></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">size_t</span></span><br><span class="line"><span class="title function_">arena_mapbits_small_runind_get</span><span class="params">(<span class="type">arena_chunk_t</span> *chunk, <span class="type">size_t</span> pageind)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> mapbits;</span><br><span class="line">    mapbits = arena_mapbits_get(chunk, pageind);</span><br><span class="line">    assert((mapbits &amp; (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) ==</span><br><span class="line">        CHUNK_MAP_ALLOCATED);</span><br><span class="line">    <span class="keyword">return</span> (mapbits &gt;&gt; CHUNK_MAP_RUNIND_SHIFT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取管理该<code>region</code>的<code>run</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run = &amp;arena_miscelm_get(chunk, rpages_ind)-&gt;run;</span><br></pre></td></tr></table></figure></p>
<p>从<code>run</code>中得到<code>bin_info</code>，再根据<code>bin_info</code>获取<code>region id</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* diff 为 region 在 run 中的偏移 */</span></span><br><span class="line">diff = (<span class="type">unsigned</span>)((<span class="type">uintptr_t</span>)ptr - (<span class="type">uintptr_t</span>)rpages -</span><br><span class="line">    bin_info-&gt;reg0_offset);</span><br><span class="line"><span class="comment">/* region id 可以通过 diff / bin_info-&gt;reg_interval 得到，但是 jemalloc 使用了复杂的运算为了提高性能，下面是它的注释 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Avoid doing division with a variable divisor if possible.  Using</span></span><br><span class="line"><span class="comment"> * actual division here can reduce allocator throughput by over 20%!</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>之后就可以设置<code>region</code>对应的<code>bitmap</code>进行释放了</p>
<h2 id="run-的合并"><a href="#run-的合并" class="headerlink" title="run 的合并"></a>run 的合并</h2><p>前面看到<code>run</code>释放时会前后进行合并:</p>
<ol>
<li>查看<code>run</code>相邻的后面的<code>page</code>是不是空闲的:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 根据后面 page 的 map_bits 获取分配状态</span></span><br><span class="line"><span class="comment">arena_mapbits_allocated_get(chunk, run_ind+run_pages) == 0</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>根据<code>map_bits</code>获取空闲<code>page</code>的大小:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> nrun_size = arena_mapbits_unallocated_size_get(chunk, run_ind+run_pages);</span><br><span class="line"><span class="type">size_t</span> nrun_pages = nrun_size &gt;&gt; LG_PAGE;</span><br></pre></td></tr></table></figure></p>
<p>然后将大小合并，在设置首尾<code>page</code>的<code>map_bits</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size += nrun_size;</span><br><span class="line">run_pages += nrun_pages;</span><br><span class="line"></span><br><span class="line">arena_mapbits_unallocated_size_set(chunk, run_ind, size);</span><br><span class="line">arena_mapbits_unallocated_size_set(chunk, run_ind+run_pages<span class="number">-1</span>, size);</span><br></pre></td></tr></table></figure></p>
<p>查看<code>run</code>相邻的前面的<code>page</code>是不是空闲的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arena_mapbits_allocated_get(chunk, run_ind<span class="number">-1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>根据<code>map_bits</code>获取空闲<code>page</code>的大小:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> prun_size = arena_mapbits_unallocated_size_get(chunk, run_ind<span class="number">-1</span>);</span><br><span class="line"><span class="type">size_t</span> prun_pages = prun_size &gt;&gt; LG_PAGE;</span><br></pre></td></tr></table></figure></p>
<p>然后将大小合并，再设置首尾<code>page</code>的<code>map_bits</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size += prun_size;</span><br><span class="line">run_pages += prun_pages;</span><br><span class="line"></span><br><span class="line">arena_mapbits_unallocated_size_set(chunk, run_ind, size);</span><br><span class="line">arena_mapbits_unallocated_size_set(chunk, run_ind+run_pages<span class="number">-1</span>, size);</span><br></pre></td></tr></table></figure></p>
<p>由此得知，因为前后都需要进行合并，所以首尾<code>page</code>对应的<code>map_bits</code>都会设置大小。</p>
<h1 id="size-classes"><a href="#size-classes" class="headerlink" title="size classes"></a>size classes</h1><p><code>jemalloc</code>将对象按大小分为3类，不同大小类别的分配算法不同:</p>
<ul>
<li><code>small</code>:从对应<code>bin</code>管理的<code>run</code>中返回一个<code>region</code></li>
<li><code>large</code>:大小比<code>chunk</code>小，比<code>page</code>大，会单独返回一个<code>run</code></li>
<li><code>huge</code>:大小为<code>chunk</code>倍数，会分配<code>chunk</code></li>
</ul>
<p>在 2MiB chunk，4KiB page 的64位系统上，<code>size classes</code>如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+---------+---------+--------------------------------------+</span><br><span class="line">|Category | Spacing | Size                                 |</span><br><span class="line">+---------+---------+--------------------------------------+</span><br><span class="line">|         |      lg | [<span class="number">8</span>]                                  |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |      <span class="number">16</span> | [<span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>]   |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |      <span class="number">32</span> | [<span class="number">160</span>, <span class="number">192</span>, <span class="number">224</span>, <span class="number">256</span>]                 |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |      <span class="number">64</span> | [<span class="number">320</span>, <span class="number">384</span>, <span class="number">448</span>, <span class="number">512</span>]                 |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|Small    |     <span class="number">128</span> | [<span class="number">640</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>]                |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |     <span class="number">256</span> | [<span class="number">1280</span>, <span class="number">1536</span>, <span class="number">1792</span>, <span class="number">2048</span>]             |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |     <span class="number">512</span> | [<span class="number">2560</span>, <span class="number">3072</span>, <span class="number">3584</span>, <span class="number">4096</span>]             |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">1</span> KiB | [<span class="number">5</span> KiB, <span class="number">6</span> KiB, <span class="number">7</span> KiB, <span class="number">8</span> KiB]         |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">2</span> KiB | [<span class="number">10</span> KiB, <span class="number">12</span> KiB, <span class="number">14</span> KiB]             |</span><br><span class="line">+---------+---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">2</span> KiB | [<span class="number">16</span> KiB]                             |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">4</span> KiB | [<span class="number">20</span> KiB, <span class="number">24</span> KiB, <span class="number">28</span> KiB, <span class="number">32</span> KiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">8</span> KiB | [<span class="number">40</span> KiB, <span class="number">48</span> KiB, <span class="number">54</span> KiB, <span class="number">64</span> KiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |  <span class="number">16</span> KiB | [<span class="number">80</span> KiB, <span class="number">96</span> KiB, <span class="number">112</span> KiB, <span class="number">128</span> KiB]   |</span><br><span class="line">|Large    +---------+--------------------------------------+</span><br><span class="line">|         |  <span class="number">32</span> KiB | [<span class="number">160</span> KiB, <span class="number">192</span> KiB, <span class="number">224</span> KiB, <span class="number">256</span> KiB] |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |  <span class="number">64</span> KiB | [<span class="number">320</span> KiB, <span class="number">384</span> KiB, <span class="number">448</span> KiB, <span class="number">512</span> KiB] |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         | <span class="number">128</span> KiB | [<span class="number">640</span> KiB, <span class="number">768</span> KiB, <span class="number">896</span> KiB, <span class="number">1</span> MiB]   |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         | <span class="number">256</span> KiB | [<span class="number">1280</span> KiB, <span class="number">1536</span> KiB, <span class="number">1792</span> KiB]       |</span><br><span class="line">+---------+---------+--------------------------------------+</span><br><span class="line">|         | <span class="number">256</span> KiB | [<span class="number">2</span> MiB]                              |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         | <span class="number">512</span> KiB | [<span class="number">2560</span> KiB, <span class="number">3</span> MiB, <span class="number">3584</span> KiB, <span class="number">4</span> MiB]   |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">1</span> MiB | [<span class="number">5</span> MiB, <span class="number">6</span> MiB, <span class="number">7</span> MiB, <span class="number">8</span> MiB]         |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|Huge     |   <span class="number">2</span> MiB | [<span class="number">10</span> MiB, <span class="number">12</span> MiB, <span class="number">14</span> MiB, <span class="number">16</span> MiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">4</span> MiB | [<span class="number">20</span> MiB, <span class="number">24</span> MiB, <span class="number">28</span> MiB, <span class="number">32</span> MiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">8</span> MiB | [<span class="number">40</span> MiB, <span class="number">48</span> MiB, <span class="number">56</span> MiB, <span class="number">64</span> MiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |     ... | ...                                  |</span><br><span class="line">+---------+---------+--------------------------------------+</span><br></pre></td></tr></table></figure></p>
<h2 id="small"><a href="#small" class="headerlink" title="small"></a>small</h2><p><code>small</code>的分配流程如下：</p>
<ul>
<li>查找对应<code>size classes</code>的<code>bin</code></li>
<li>从<code>bin</code>中获取<code>run</code>:<ul>
<li><code>bin-&gt;runcur</code></li>
<li>从<code>bin-&gt;runs</code>查找未满的<code>run</code></li>
</ul>
</li>
<li>从<code>arena</code>中获取<code>run</code>:<ul>
<li>从<code>arena-&gt;avail_runs</code>中查找空闲<code>run</code></li>
<li>当没有合适<code>run</code>时，从<code>chunk</code>中分配<code>run</code>:<ul>
<li><code>arena-&gt;spare</code></li>
<li><code>arena-&gt;cached_tree</code></li>
<li><code>arena-&gt;retained_tree</code></li>
<li>调用<code>mmap()</code>新分配一块<code>chunk</code></li>
</ul>
</li>
</ul>
</li>
<li>从<code>run</code>中返回一个空闲<code>region</code></li>
</ul>
<p><code>small</code>的释放流程如下：</p>
<ul>
<li>将该<code>region</code>返回给对应的<code>run</code>，即设置<code>bitmap</code>为空闲，增加<code>nfree</code></li>
<li>将<code>run</code>还给<code>bin</code>:<ul>
<li>如果<code>run-&gt;nfree == 1</code>，则设置为<code>bin-&gt;runcur</code>或者插入到<code>bin-&gt;runs</code>中</li>
</ul>
</li>
<li>如果<code>run-&gt;nfree == bin_info-&gt;nregs</code>，则将该<code>run</code>与<code>bin</code>分离，再将<code>run</code>还给<code>arena</code>:<ul>
<li>尝试与相同<code>chunk</code>中前后相邻的空闲<code>run</code>进行合并，然后插入到<code>arena-&gt;avail_runs</code>中</li>
<li>若合并完后，整个<code>chunk</code>为空，则尝试与连续地址空间的空闲<code>chunk</code>进行合并，然后插入到<code>arena-&gt;cached_tree</code>中</li>
</ul>
</li>
</ul>
<h2 id="large"><a href="#large" class="headerlink" title="large"></a>large</h2><p>分配<code>large</code>和分配<code>small</code>类似:</p>
<ul>
<li>先从<code>arena-&gt;avail_runs</code>中查找，因为<code>large object</code>不由<code>bin</code>管理，所以与<code>small object</code>相比，少了从<code>bin-&gt;runs</code>中查找的一步</li>
<li>分配<code>chunk</code>，步骤和<code>small</code>一样，然后从<code>chunk</code>中分配需要的<code>run</code>大小，此时<code>run</code>的大小为单个<code>object</code>的大小，而<code>small run</code>的大小会从<code>bin_info[]</code>中获取</li>
</ul>
<p>因为<code>large</code>大小是<code>page</code>的倍数，且会按照<code>page size</code>地址对齐，有可能造成<code>cache line</code>颠簸， 所以会根据配置多分配一个<code>page</code>，用于内存着色，防止<code>cache line</code>的颠簸<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config_cache_oblivious) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Compute a uniformly distributed offset within the first page</span></span><br><span class="line"><span class="comment">     * that is a multiple of the cacheline size, e.g. [0 .. 63) * 64</span></span><br><span class="line"><span class="comment">     * for 4 KiB pages and 64-byte cachelines.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    prng64(r, LG_PAGE - LG_CACHELINE, arena-&gt;offset_state,</span><br><span class="line">        UINT64_C(<span class="number">6364136223846793009</span>),</span><br><span class="line">        UINT64_C(<span class="number">1442695040888963409</span>));</span><br><span class="line">    random_offset = ((<span class="type">uintptr_t</span>)r) &lt;&lt; LG_CACHELINE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>large</code>和<code>small</code>的<code>arena_chunk_map_misc_t</code>格式也不同，<code>large</code>只在首个<code>page</code>设置<code>run</code>的大小。释放流程和<code>small</code>一样，只是缺少了<code>run</code>在<code>bin</code>中的处理，直接将<code>run</code>还给<code>arena</code>。</p>
<h2 id="huge"><a href="#huge" class="headerlink" title="huge"></a>huge</h2><p><code>huge object</code>大小比<code>chunk</code>大。分配策略和上面分配<code>chunk</code>一样:</p>
<ul>
<li>从<code>arena</code>中分配<code>extent_node_t</code></li>
<li>从<code>arena</code>中分配<code>chunk</code>:<ul>
<li>从<code>arena-&gt;cached_tree</code>中分配<code>chunk</code></li>
<li>从<code>arena-&gt;retained_tree</code>中分配</li>
<li>调用<code>mmap()</code>新分配一块<code>chunk</code></li>
</ul>
</li>
<li>将<code>chunk</code>和<code>node</code>插入到<code>chunks_rtree</code>中</li>
<li>插入到<code>arena-&gt;huge</code>链表中</li>
</ul>
<p>释放和分配过程相反:</p>
<ul>
<li>从<code>chunks_rtree</code>中获取<code>chunk</code>对应的<code>node</code>，从而获取对应的<code>arena</code></li>
<li>移出<code>arena-&gt;huge</code></li>
<li>释放<code>chunk</code>，插入到<code>arena-&gt;cached_tree</code>中</li>
<li>释放<code>node</code></li>
</ul>
<p><code>huge</code>使用了线程间共享的<code>chunks_rtree</code>来保存信息，这会导致锁的竞争，但是应用程序很少会分配如此大的内存，所以带来的影响很小。</p>
<h2 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h2><p>前面的释放只是将之前分配的缓存起来，备用，现在来看一下真正的释放操作。</p>
<p><code>arena</code>中会统计<code>dirty</code>和<code>active</code>的数目：</p>
<ul>
<li><code>nactive</code>：已经分配出去的<code>page</code>数目</li>
<li><code>ndirty</code>：分配出去又被释放的<code>page</code>数目</li>
<li><code>arena</code>中会保存最多<code>nactive &gt;&gt; lg_dirty_mult</code>的<code>dirty pages</code>暂存使用，当超出时，就会释放掉多余的部分。</li>
</ul>
<p><code>purge</code>按照<code>page</code>维度进行回收。<code>arena</code>中<code>runs_dirty</code>和<code>chunks_cache</code>存放着<code>dirty pages</code>，当<code>run</code>和<code>chunk</code>被释放时，会插入到这里(<code>chunk</code>也会插入到<code>runs_dirty</code>中，同时也插入到<code>chunks_cache</code>)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">* Unused dirty memory this arena manages.  Dirty memory is conceptually</span><br><span class="line">* tracked as an arbitrarily interleaved LRU of dirty runs and cached</span><br><span class="line">* chunks, but the <span class="built_in">list</span> linkage is actually semi-duplicated in order to</span><br><span class="line">* avoid extra <span class="type">arena_chunk_map_misc_t</span> space overhead.</span><br><span class="line">*</span><br><span class="line">*   LRU-----------------------------------------------------------MRU</span><br><span class="line">*</span><br><span class="line">*        /-- arena ---\</span><br><span class="line">*        |            |</span><br><span class="line">*        |            |</span><br><span class="line">*        |------------|                             /- chunk -\</span><br><span class="line">*   ...-&gt;|chunks_cache|&lt;---------------------------&gt;|  /----\ |&lt;--...</span><br><span class="line">*        |------------|                             |  |node| |</span><br><span class="line">*        |            |                             |  |    | |</span><br><span class="line">*        |            |    /- run -\    /- run -\   |  |    | |</span><br><span class="line">*        |            |    |       |    |       |   |  |    | |</span><br><span class="line">*        |            |    |       |    |       |   |  |    | |</span><br><span class="line">*        |------------|    |-------|    |-------|   |  |----| |</span><br><span class="line">*   ...-&gt;|runs_dirty  |&lt;--&gt;|rd     |&lt;--&gt;|rd     |&lt;----&gt;|rd  |&lt;----...</span><br><span class="line">*        |------------|    |-------|    |-------|   |  |----| |</span><br><span class="line">*        |            |    |       |    |       |   |  |    | |</span><br><span class="line">*        |            |    |       |    |       |   |  \----/ |</span><br><span class="line">*        |            |    \-------/    \-------/   |         |</span><br><span class="line">*        |            |                             |         |</span><br><span class="line">*        |            |                             |         |</span><br><span class="line">*        \------------/                             \---------/</span><br><span class="line">*</span><br></pre></td></tr></table></figure></p>
<p>在每次<code>dalloc run/chunk</code>时都会调用<code>arena_maybe_purge()</code>尝试<code>purge</code>。<code>arena</code>根据<code>lg_dirty_mult</code>判断是否需要<code>purge</code>，当<code>(nactive &gt;&gt; lg_dirty_mult) &lt;= ndirty</code>时进行<code>purge</code>，默认配置为<code>8 ： 1</code>。</p>
<p><code>purge</code>分为4步：</p>
<ul>
<li><code>arena_compute_npurge()</code>：返回需要<code>purge</code>的<code>page</code>数目，为超出<code>nactive &gt;&gt; lg_dirty_mult</code>的<code>page</code>数。</li>
<li><code>arena_stash_dirty()</code>：将需要<code>purge</code>的部分从<code>arena-&gt;cached_tree</code>或<code>arena-&gt;avail_runs</code>中移除，防止<code>purge</code>过程中被其他线程分配出去，并插入到需要<code>purge</code>的循环链表中。</li>
<li><code>arena_purge_stashed()</code>：将循环链表中的<code>run</code>进行<code>purge</code></li>
<li><code>arena_unstash_purged()</code>：将<code>chunk</code>进行<code>purge</code>。将<code>purged</code>插入到<code>arena-&gt;cached_tree</code>或<code>arena-&gt;avail_runs</code>，留待后面分配。</li>
</ul>
<p>对<code>chunk</code>和<code>run</code>采取不同的<code>purge</code>：</p>
<ul>
<li>对于<code>run</code>而言，并不是真正的释放，根据操作系统的不同，会使用不同的方式，在<code>linux</code>中会调用<code>madvise(addr, size, MADV_DONTNEED)</code>。</li>
<li><code>jemalloc</code>以<code>chunk</code>为单位向操作系统申请内存，在释放<code>chunk</code>时，会尽量调用<code>munmap()</code>(因为根据操作系统和配置的不同，<code>chunk</code>的来源也不同)，否则会类似<code>run</code>，调用<code>madvise()</code>然后再插入到<code>chunk_retained_tree</code>中，留待后续分配。</li>
</ul>
<p><code>jemalloc</code>中单线程的部分就到此结束了，下面开始看<code>jemalloc</code>是如何提升多线程性能的。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><code>jemalloc</code>的一个目标就是提高多线程的性能，多线程的分配思路和单线程是一样的，每个线程还是从<code>arena</code>中分配内存，不过会多了线程间的同步和竞争。想要提高多线程性能，主要通过下面 2 个方式:</p>
<ul>
<li>减少锁的竞争：缩小临界区，更细粒度的锁</li>
<li>避免锁的竞争：线程间不共享数据，使用局部变量、线程特有数据(tsd)、线程局部存储(tls)等</li>
</ul>
<h2 id="arena-1"><a href="#arena-1" class="headerlink" title="arena"></a>arena</h2><p><code>jemalloc</code>会创建多个<code>arena</code>，每个线程由一个<code>arena</code>负责。在<code>malloc_init_hard_finish()</code>中会设置<code>arena</code>的相关配置，<code>narenas_auto</code>和<code>narenas_total</code>都设置为<code>cpu核数*4</code>，默认最多创建那么多<code>arena</code>。<code>arena-&gt;nthreads</code>记录负责的线程数量。</p>
<p>每个线程分配时会首先调用<code>arena_choose()</code>选择一个<code>arena</code>来负责该线程的分配。选择<code>arena</code>的逻辑如下:</p>
<ol>
<li>若有空闲的(<code>nthreads==0</code>)已创建的<code>arena</code>，则选择该<code>arena</code></li>
<li>若还有未创建的<code>arena</code>，则选择新创建一个<code>arena</code></li>
<li>选择负载最低的<code>arena</code>(<code>nthreads</code>最小)</li>
</ol>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><code>mutex</code>尽量使用<code>spinlock</code>，减少线程间的上下文切换:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_mutex_lock</span><span class="params">(<span class="type">malloc_mutex_t</span> *mutex)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isthreaded) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#  <span class="keyword">if</span> _WIN32_WINNT &gt;= 0x0600</span></span><br><span class="line">		AcquireSRWLockExclusive(&amp;mutex-&gt;lock);</span><br><span class="line"><span class="meta">#  <span class="keyword">else</span></span></span><br><span class="line">		EnterCriticalSection(&amp;mutex-&gt;lock);</span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (defined(JEMALLOC_OSSPIN))</span></span><br><span class="line">		OSSpinLockLock(&amp;mutex-&gt;lock);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		pthread_mutex_lock(&amp;mutex-&gt;lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了缩小临界区，<code>arena</code>中有多个锁管理不同的部分:</p>
<ul>
<li><code>arenas_lock</code>：<code>arena</code>的初始化、分配等</li>
<li><code>arena-&gt;lock</code>：<code>run</code>和<code>chunk</code>的管理</li>
<li><code>arena-&gt;huge_mtx</code>：<code>huge object</code>的管理</li>
<li><code>bin-&gt;lock</code>：<code>bin</code>中的操作</li>
</ul>
<h2 id="tsd"><a href="#tsd" class="headerlink" title="tsd"></a>tsd</h2><p>当选择完<code>arena</code>后，会将<code>arena</code>绑定到<code>tsd</code>中，之后会直接从<code>tsd</code>中获取<code>arena</code>。</p>
<p><code>tsd</code>用于保存每个线程特有的数据，主要是<code>arena</code>和<code>tcache</code>，避免锁的竞争。<code>tsd_t</code>中的数据会在第一次访问时延迟初始化(调用相应的<code>get_hard()</code>)，<code>tsd</code>中各元素使用宏生成对应的<code>get/set</code>函数来获取/设置，在线程退出时，会调用相应的<code>cleanup</code>函数清理。下面只介绍<code>linux</code>平台中的实现。</p>
<p>在<code>linux</code>中会使用<code>tls(__thread)</code>和<code>tsd(pthread_key_create(), pthread_setspecific())</code>来实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> (defined(JEMALLOC_TLS))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	malloc_tsd_data(a_attr, a_name, a_type, a_initializer)		\</span></span><br><span class="line"><span class="meta">a_attr __thread a_type JEMALLOC_TLS_MODEL				\</span></span><br><span class="line"><span class="meta">    a_name##tsd_tls = a_initializer;					\</span></span><br><span class="line"><span class="meta">a_attr pthread_key_t	a_name##tsd_tsd;				\</span></span><br><span class="line"><span class="meta">a_attr bool		a_name##tsd_booted = false;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>__thread</code>保存需要线程局部存储的数据<code>tsd_t</code></li>
<li><code>pthread_key_t</code>将<code>key</code>与<code>__thread</code>联系起来，用于注册<code>destructor，</code>在线程退出时清理<code>tsd_t</code></li>
</ul>
<p>其实可以只用<code>pthread_key_t</code>来实现，但使用<code>__thread</code>可以直接获取数据，不用再调用<code>pthread_getspecific()</code>。</p>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><p><code>tcache</code>用于<code>small</code>和<code>large</code>的分配，避免多线程的同步。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;opt.tcache&quot;</span> (<span class="type">bool</span>) r- [--enable-tcache]</span><br><span class="line">        Thread-specific <span class="title function_">caching</span> <span class="params">(tcache)</span> enabled/disabled. When there are multiple threads, each thread uses a tcache <span class="keyword">for</span> objects up to a certain size. Thread-specific caching allows many allocations to be satisfied without performing any</span><br><span class="line">        thread synchronization, at the cost of increased memory use. See the &quot;opt.lg_tcache_max&quot; option <span class="keyword">for</span> related tuning information. This option is enabled by <span class="keyword">default</span> unless running inside Valgrind[2], in which <span class="keyword">case</span> it is forcefully</span><br><span class="line">        disabled.</span><br><span class="line"></span><br><span class="line">&quot;opt.lg_tcache_max&quot; <span class="params">(<span class="type">size_t</span>)</span> r- [--enable-tcache]</span><br><span class="line">    Maximum size <span class="title function_">class</span> <span class="params">(<span class="built_in">log</span> base <span class="number">2</span>)</span> to cache in the thread-specific <span class="title function_">cache</span> <span class="params">(tcache)</span>. At a minimum, all small size classes are cached, and at a maximum all large size classes are cached. The <span class="keyword">default</span> maximum is 32 <span class="title function_">KiB</span> <span class="params">(<span class="number">2</span>^<span class="number">15</span>)</span>.</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_s</span> &#123;</span></span><br><span class="line">	ql_elm(<span class="type">tcache_t</span>) link;		<span class="comment">/* Used for aggregating stats. */</span></span><br><span class="line">	<span class="type">uint64_t</span>	prof_accumbytes;<span class="comment">/* Cleared after arena_prof_accum(). */</span></span><br><span class="line">	<span class="type">unsigned</span>	ev_cnt;		<span class="comment">/* Event count since incremental GC. */</span></span><br><span class="line">	<span class="type">szind_t</span>		next_gc_bin;	<span class="comment">/* Next bin to GC. */</span></span><br><span class="line">	<span class="type">tcache_bin_t</span>	tbins[<span class="number">1</span>];	<span class="comment">/* Dynamically sized. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The pointer stacks associated with tbins follow as a contiguous</span></span><br><span class="line"><span class="comment">	 * array.  During tcache initialization, the avail pointer in each</span></span><br><span class="line"><span class="comment">	 * element of tbins is initialized to point to the proper offset within</span></span><br><span class="line"><span class="comment">	 * this array.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_bin_s</span> &#123;</span></span><br><span class="line">	<span class="type">tcache_bin_stats_t</span> tstats;</span><br><span class="line">	<span class="type">int</span>		low_water;	<span class="comment">/* Min # cached since last GC. */</span></span><br><span class="line">	<span class="type">unsigned</span>	lg_fill_div;	<span class="comment">/* Fill (ncached_max &gt;&gt; lg_fill_div). */</span></span><br><span class="line">	<span class="type">unsigned</span>	ncached;	<span class="comment">/* # of cached objects. */</span></span><br><span class="line">	<span class="type">void</span>		**avail;	<span class="comment">/* Stack of available objects. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>tcache</code>同样使用<code>slab</code>算法分配:</p>
<ul>
<li><code>tcache</code>中有多种<code>bin</code>，每个<code>bin</code>管理一个<code>size class</code></li>
<li>当分配时，从对应<code>bin</code>中返回一个<code>cache slot</code></li>
<li>当释放时，将<code>cache slot</code>返回给对应的<code>bin</code></li>
</ul>
<p><code>tcache</code>中<code>avail</code>是指针数组，每个数组元素指向对应的<code>cache slot</code>，<code>cache slot</code>是从<code>arena</code>中分配的，缓存在<code>tcache</code>中。</p>
<p><code>tcache_boot()</code>：根据配置<code>opt.lg_tcache_max</code>设置<code>tcache</code>中<code>bin</code>的范围(<code>nhbins</code>)。设置<code>tcache_bin_info</code>，保存每种<code>bin</code>的<code>cache slots</code>个数(类似<code>arena_bin_info</code>中<code>nregs</code>)，<code>small</code>在<code>TCACHE_NSLOTS_SMALL_MIN</code>到<code>TCACHE_NSLOTS_SMALL_MAX</code>间，<code>large</code>固定为<code>TCACHE_NSLOTS_LARGE</code>。</p>
<p><code>tcache_create()</code>：<code>tcache_t</code>中保存着<code>tbins[]</code>信息，<code>tcache_bin_t</code>中<code>avail</code>指向每一个<code>cache slot</code>(类似<code>arena-&gt;bin</code>中<code>region</code>)，<code>tcache_create()</code>根据<code>tcache_boot()</code>设置的配置分配<code>tcache_t</code>和<code>tcache_bin_t</code>的内存，<code>tcache_t</code>和<code>tbins[]</code>为连续内存，<code>tbins[]</code>中<code>avail</code>使用后面连续空间的内存。</p>
<p><img src="/img/20211102100904.png" alt=""></p>
<h2 id="small-1"><a href="#small-1" class="headerlink" title="small"></a>small</h2><p><code>small</code>分配流程如下:</p>
<ol>
<li><code>tcache_alloc_small()</code>：先获取对应的<code>tbin</code>，调用<code>tcache_alloc_easy()</code>，若<code>tbin</code>中还有剩余的元素，返回<code>tbin-&gt;avail[tbin-&gt;ncached]</code>(从后往前分配，<code>ncached</code>既是剩余数量也是索引)，<code>tbin-&gt;low_water</code>保存着<code>tbin-&gt;ncached</code>的最小值。</li>
<li><code>tcache_alloc_small_hard()</code>：<code>tbin</code>已空，先调用<code>arena_tcache_fill_small()</code>重新装载<code>tbin</code>，再调用<code>tcache_alloc_easy()</code>分配。</li>
<li><code>arena_tcache_fill_small()</code>：从<code>arena</code>中对应的<code>bin</code>分配<code>region</code>保存在<code>tbin-&gt;avail</code>中，只会填充<code>ncached_max &gt;&gt; lg_fill_div</code>个。</li>
</ol>
<p><code>small</code>释放流程如下:</p>
<ol>
<li><code>tcache_dalloc_small()</code>：通过<code>ptr</code>对应的<code>map_bits</code>获取<code>binind</code>，然后将<code>ptr</code>释放(保存在<code>tbin-&gt;avail[tbin-&gt;ncached]</code>，同时<code>tbin-&gt;ncached++</code>)。若该<code>tbin</code>已满(<code>tbin-&gt;ncached == tbin_info-&gt;ncached_max</code>)，会调用<code>tcache_bin_flush_small()</code>，释放一半<code>cache slots</code>给<code>arena</code>。</li>
<li><code>tcache_bin_flush_small()</code>：会释放<code>tbin</code>中部分<code>avail</code>返回给<code>arena</code>中对应的<code>bin</code>，这里为了减少锁的调用，会在一次加锁中，释放所有对应该锁(bin)的<code>cache slot</code>。</li>
</ol>
<h2 id="large-1"><a href="#large-1" class="headerlink" title="large"></a>large</h2><p>分配和<code>small</code>类似，先调用<code>tcache_alloc_easy()</code>，不过若<code>tbin</code>为空时，不会像<code>small</code>一样分配所有的<code>avail</code>，而是调用<code>arena_malloc_large()</code>从<code>arena</code>中分配一个<code>run</code>。因为创建多个<code>large object</code>太过昂贵，并且有可能会用不到，浪费空间。</p>
<p>释放和<code>small</code>类似，先释放到<code>tbin-&gt;avail[tbin-&gt;ncached]</code>中，备用。若该<code>tbin</code>已满，调用<code>arena_bin_flush_large()</code>释放一半到<code>arena</code>中。</p>
<h2 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h2><p>前面注意到，当从<code>arena</code>分配<code>small</code>时， 会分配<code>ncached_max &gt;&gt; lg_fill_div</code>个，若每次均分配固定数目，有可能会造成内存浪费，<code>jemalloc</code>对<code>tcache</code>中的<code>bin</code>采用渐进式<code>GC</code>，动态的调整分配数目。有 2 个宏控制着<code>GC</code>的进行:</p>
<ul>
<li><code>TCACHE_GC_SWEEP</code>：可以近似认为每发生该数量的分配或释放操作，所有的<code>bin</code>都被<code>GC</code></li>
<li><code>TCACHE_GC_INCR</code>：每发生该数量的分配或释放操作，单个<code>bin</code>进行一次<code>GC</code></li>
</ul>
<p><code>tcache</code>中每个<code>bin</code>会有如下2个字段:</p>
<ul>
<li><code>low_water</code>：保存着一次<code>GC</code>时间间隔内，<code>ncached</code>的最小值，也就意味着在这之下的<code>avail</code>都没被分配</li>
<li><code>lg_fill_div</code>：用于控制每次分配的数量(<code>ncached_max &gt;&gt; lg_fill_div</code>)，初始为 1</li>
</ul>
<p>在每次分配和释放时，都会调用<code>tcache_event()</code>，增加<code>tcache-&gt;ev_cnt</code>，若和<code>TCACHE_GC_INCR</code>相等，则调用<code>tcache_event_hard()</code>对单个<code>bin</code>进行<code>GC</code>(只对<code>small object</code>有效)。<code>tcache_event_hard()</code>：对单个<code>bin</code>(<code>next_gc_bin</code>)进行<code>GC</code>:</p>
<ol>
<li>若<code>tbin-&gt;low_water &gt; 0</code>：说明<code>tbin-&gt;avail</code>中有些未被用到，可以尝试减少分配。对应的操作就是释放掉<code>3/4 low_water</code>，<code>lg_fill_div++</code>(下次分配时会减少一半)</li>
<li>若<code>tbin-&gt;low_water &lt; 0</code>：只有在该<code>tbin-&gt;avail</code>全部分配完才会置<code>low_water = -1</code>，说明不够用，所以会<code>lg_fill_div--</code>(下次分配时加倍)</li>
</ol>
<p><code>tcache</code>中的<code>tbin</code>分配数量就会一直动态调整。</p>
<h2 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h2><p>线程退出时，会调用<code>tsd_cleanup()</code>对<code>tsd</code>中数据进行清理:</p>
<ul>
<li><code>arena</code>：降低<code>arena</code>负载(<code>arena-&gt;nthreads--</code>)</li>
<li><code>tcache</code>：调用<code>tcache_bin_flush_small/large()</code>释放<code>tcache-&gt;tbins[]</code>所有元素，释放<code>tcache</code>本身</li>
</ul>
<p>当从一个线程分配的内存由另一个线程释放时，该内存还是由原先的<code>arena</code>来管理，通过<code>chunk</code>的<code>extent_node_t</code>来获取对应的<code>arena</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>jemalloc</code>中大量使用了宏生成代码，比较晦涩，不过其他部分还是比较清楚的，只要理解了它的思路就容易看懂，一层一层的。现在来总结一下<code>jemalloc</code>的思路：</p>
<ul>
<li>通过避免<code>false cache line sharing</code>，使用内存着色等，提高<code>cache line</code>效率</li>
<li>使用<code>slab</code>分配不同大小的对象，精心选择<code>size classes</code>，减少内存碎片</li>
<li>使用多层缓存，内存的释放和分配会经历很多阶段，提升速度</li>
<li><code>metadata</code>存放在连续内存，降低<code>metadata</code>的<code>overhead</code>，同时能减少<code>active pages</code></li>
<li>地址对齐从而在常量时间内获取<code>metadata</code></li>
<li>首先复用低地址的内存，减少<code>active pages</code></li>
<li>使用多个<code>arena</code>管理、更细粒度的锁、<code>tsd</code>、<code>tcache</code>等，最小化锁竞争</li>
</ul>
<h1 id="JeMalloc-5-1-0-版本"><a href="#JeMalloc-5-1-0-版本" class="headerlink" title="JeMalloc-5.1.0 版本"></a>JeMalloc-5.1.0 版本</h1><p>这篇文章介绍JeMalloc-5.1.0 版本（release 日期：2018年5月9日）的实现细节。</p>
<p>对于对老版本比较熟悉的人来说，有几点需要说明：</p>
<ul>
<li><code>chunk</code>这一概念被替换成了 extent</li>
<li><code>dirty page</code>的<code>decay</code>（或者说 gc） 变成了两阶段，dirty -&gt; muzzy -&gt; retained</li>
<li><code>huge class</code>这一概念不再存在</li>
<li>红黑树不再使用，取而代之的是 pairing heap</li>
</ul>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>以下内容介绍 JeMalloc 中比较重要的概念以及数据结构。</p>
<h3 id="size-class"><a href="#size-class" class="headerlink" title="size_class"></a>size_class</h3><p>每个<code>size_class</code>代表<code>jemalloc</code>分配的内存大小，共有<code>NSIZES</code>（232）个小类（如果用户申请的大小位于两个小类之间，会取较大的，比如申请14字节，位于8和16字节之间，按16字节分配），分为2大类：</p>
<ul>
<li><code>small_class</code>（小内存） : 对于64位机器来说，通常区间是 [8, 14kb]，常见的有 8, 16, 32, 48, 64, …, 2kb, 4kb, 8kb，注意为了减少内存碎片并不都是2的次幂，比如如果没有48字节，那当申请33字节时，分配64字节显然会造成约50%的外部碎片</li>
<li><code>large_class</code>（大内存）: 对于64位机器来说，通常区间是 [16kb, 7EiB]，从 4 * page_size 开始，常见的比如 16kb, 32kb, …, 1mb, 2mb, 4mb，最大是<code>2^63 + 3^60</code></li>
<li><code>size_index</code>: size 位于 size_class 中的索引号，区间为 [0，231]，比如8字节则为0，14字节（按16计算）为1，4kb字节为28，当<code>size</code>是<code>small_class</code>时，<code>size_index</code>也称作<code>binind</code></li>
</ul>
<h3 id="base-1"><a href="#base-1" class="headerlink" title="base"></a>base</h3><p>用于分配 jemalloc 元数据内存的结构，通常一个 base 大小为 2mb， 所有 base 组成一个链表。</p>
<ul>
<li><code>base.extents[NSIZES]</code>: 存放每个<code>size_class</code>的<code>extent</code>元数据</li>
</ul>
<h3 id="bin-1"><a href="#bin-1" class="headerlink" title="bin"></a>bin</h3><p>管理正在使用中的<code>slab</code>（即用于小内存分配的 extent） 的集合，每个<code>bin</code>对应一个<code>size_class</code></p>
<ul>
<li><code>bin.slabcur</code>: 当前使用中的 slab</li>
<li><code>bin.slabs_nonfull</code>: 有空闲内存块的 slab</li>
</ul>
<h3 id="extent"><a href="#extent" class="headerlink" title="extent"></a>extent</h3><p>管理 jemalloc 内存块（即用于用户分配的内存）的结构，每一个内存块大小可以是<code>N * page_size(4kb)</code>（N &gt;= 1）。每个<code>extent</code>有一个序列号（serial number）。</p>
<p>一个<code>extent</code>可以用来分配一次<code>large_class</code>的内存申请，但可以用来分配多次<code>small_class</code>的内存申请。</p>
<ul>
<li><code>extent.e_bits</code>: 8字节长，记录多种信息</li>
<li><code>extent.e_addr</code>: 管理的内存块的起始地址</li>
<li><code>extent.e_slab_data</code>: 位图，当此<code>extent</code>用于分配<code>small_class</code>内存时，用来记录这个<code>extent</code>的分配情况，此时每个<code>extent</code>的内的小内存称为<code>region</code></li>
</ul>
<h3 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h3><p>当<code>extent</code>用于分配<code>small_class</code>内存时，称其为<code>slab</code>。一个<code>extent</code>可以被用来处理多个同一<code>size_class</code>的内存申请。</p>
<h3 id="extents"><a href="#extents" class="headerlink" title="extents"></a>extents</h3><p>管理<code>extent</code>的集合。</p>
<ul>
<li><code>extents.heaps[NPSIZES+1]</code>: 各种 page(4kb) 倍数大小的 extent</li>
<li><code>extents.lru</code>: 存放所有<code>extent</code>的双向链表</li>
<li><code>extents.delay_coalesce</code>: 是否延迟<code>extent</code>的合并</li>
</ul>
<h3 id="arena-2"><a href="#arena-2" class="headerlink" title="arena"></a>arena</h3><p>用于分配&amp;回收<code>extent</code>的结构，每个用户线程会被绑定到一个<code>arena</code>上，默认每个逻辑 CPU 会有 4 个<code>arena</code>来减少锁的竞争，各个<code>arena</code>所管理的内存相互独立。</p>
<ul>
<li><code>arena.extents_dirty</code>：刚被释放后空闲<code>extent</code>位于的地方</li>
<li><code>arena.extents_muzzy</code>：<code>extents_dirty</code>进行<code>lazy purge</code>后位于的地方，dirty -&gt; muzzy</li>
<li><code>arena.extents_retained</code>：<code>extents_muzzy</code>进行<code>decommit</code>或<code>force purge</code>后<code>extent</code>位于的地方，muzzy -&gt; retained</li>
<li><code>arena.large</code>：存放<code>large extent</code>的 extents</li>
<li><code>arena.extent_avail</code>：<code>heap</code>，存放可用的<code>extent</code>元数据</li>
<li><code>arena.bins[NBINS]</code>：所以用于分配小内存的<code>bin</code></li>
<li><code>arena.base</code>：用于分配元数据的<code>base</code></li>
</ul>
<h3 id="rtree"><a href="#rtree" class="headerlink" title="rtree"></a>rtree</h3><p>全局唯一的存放每个<code>extent</code>信息的 Radix Tree，以<code>extent-&gt;e_addr</code>即<code>uintptr_t</code>为<code>key</code>，以我的机器为例，<code>uintptr_t</code>为64位（8字节），<code>rtree</code>的高度为3，由于<code>extent-&gt;e_addr</code>是<code>page(1 &lt;&lt; 12)</code>对齐的，也就是说需要 64 - 12 = 52 位即可确定在树中的位置，每一层分别通过第0-16位，17-33位，34-51位来进行访问。</p>
<p><img src="/img/v2-92f9c4741a626e4a48a9ca987d36b82c_1440w.jpg" alt=""></p>
<h3 id="cache-bin"><a href="#cache-bin" class="headerlink" title="cache_bin"></a>cache_bin</h3><p>每个线程独有的用于分配小内存的缓存</p>
<ul>
<li><code>low_water</code>：上一次 gc 后剩余的缓存数量</li>
<li><code>cache_bin.ncached</code>：当前 cache_bin 存放的缓存数量</li>
<li><code>cache_bin.avail</code>：可直接用于分配的内存，从左往右依次分配（注意这里的寻址方式）</li>
</ul>
<p><img src="/img/v2-4ce3efe4b89f927df4b4c0cfbd588558_1440w.jpg" alt=""></p>
<h3 id="tcache-1"><a href="#tcache-1" class="headerlink" title="tcache"></a>tcache</h3><p>每个线程独有的缓存（Thread Cache），大多数内存申请都可以在 tcache 中直接得到，从而避免加锁</p>
<ul>
<li><code>tcache.bins_small[NBINS]</code>：小内存的<code>cache_bin</code></li>
</ul>
<h3 id="tsd-1"><a href="#tsd-1" class="headerlink" title="tsd"></a>tsd</h3><p>Thread Specific Data，每个线程独有，用于存放与这个线程相关的结构</p>
<ul>
<li><code>tsd.rtree_ctx</code>：当前线程的<code>rtree context</code>，用于快速访问<code>extent</code>信息</li>
<li><code>tsd.arena</code>：当前线程绑定的<code>arena</code></li>
<li><code>tsd.tcache</code>：当前线程的<code>tcache</code></li>
</ul>
<h2 id="内存分配（malloc）"><a href="#内存分配（malloc）" class="headerlink" title="内存分配（malloc）"></a>内存分配（malloc）</h2><h3 id="小内存-small-class-分配"><a href="#小内存-small-class-分配" class="headerlink" title="小内存(small_class)分配"></a>小内存(small_class)分配</h3><p>首先从<code>tsd-&gt;tcache-&gt;bins_small[binind]</code>中获取对应<code>size_class</code>的内存，有的话将内存直接返回给用户，如果<code>bins_small[binind]</code>中没有的话，需要通过<code>slab(extent)</code>对<code>tsd-&gt;tcache-&gt;bins_small[binind]</code>进行填充，一次填充多个以备后续分配，填充方式如下（当前步骤无法成功则进行下一步）：</p>
<ol>
<li>通过<code>bin-&gt;slabcur</code>分配</li>
<li>从<code>bin-&gt;slabs_nonfull</code>中获取可使用的<code>extent</code></li>
<li>从<code>arena-&gt;extents_dirty</code>中回收<code>extent</code>，回收方式为<code>best-fit</code>，即满足大小要求的最小<code>extent</code>，在<code>arena-&gt;extents_dirty-&gt;bitmap</code>中找到满足大小要求并且第一个非空<code>heap</code>的索引<code>i</code>，然后从<code>extents-&gt;heaps[i]</code>中获取第一个<code>extent</code>。由于<code>extent</code>可能较大，为了防止产生内存碎片，需要对<code>extent</code>进行分裂（伙伴算法），然后将分裂后不使用的<code>extent</code>放回<code>extents_dirty</code>中</li>
<li>从<code>arena-&gt;extents_muzzy</code>中回收<code>extent</code>，回收方式为<code>first-fit</code>，即满足大小要求且序列号最小地址最低（最旧）的<code>extent</code>，遍历每个满足大小要求并且非空的<code>arena-&gt;extents_dirty-&gt;bitmap</code>，获取其对应<code>extents-&gt;heaps</code>中第一个<code>extent</code>，然后进行比较，找到最旧的<code>extent</code>，之后仍然需要分裂</li>
<li>从<code>arena-&gt;extents_retained</code>中回收<code>extent</code>，回收方式与<code>extents_muzzy</code>相同</li>
<li>尝试通过<code>mmap</code>向内核获取所需的<code>extent</code>内存，并且在<code>rtree</code>中注册新<code>extent</code>的信息</li>
<li>再次尝试从<code>bin-&gt;slabs_nonfull</code>中获取可使用的<code>extent</code></li>
</ol>
<p>简单来说，这个流程是这样的，<code>cache_bin -&gt; slab -&gt; slabs_nonfull -&gt; extents_dirty -&gt; extents_muzzy -&gt; extents_retained -&gt; kernal</code>。</p>
<p><img src="/img/v2-07d44c859efbc6ac177b27793acb96e8_1440w.jpg" alt=""></p>
<h3 id="大内存-large-class-分配"><a href="#大内存-large-class-分配" class="headerlink" title="大内存(large_class)分配"></a>大内存(large_class)分配</h3><p>大内存不存放在<code>tsd-&gt;tcache</code>中，因为这样可能会浪费内存，所以每次申请都需要重新分配一个<code>extent</code>，申请的流程和小内存申请<code>extent</code>流程中的3, 4, 5, 6是一样的。</p>
<h2 id="内存释放（free）"><a href="#内存释放（free）" class="headerlink" title="内存释放（free）"></a>内存释放（free）</h2><h3 id="小内存释放"><a href="#小内存释放" class="headerlink" title="小内存释放"></a>小内存释放</h3><p>在<code>rtree</code>中找到需要被释放内存所属的<code>extent</code>信息，将要被释放的内存还给<code>tsd-&gt;tcache-&gt;bins_small[binind]</code>，如果<code>tsd-&gt;tcache-&gt;bins_small[binind]</code>已满，需要对其进行<code>flush</code>，流程如下：</p>
<ol>
<li>将这块内存返还给所属<code>extent</code>，如果这个<code>extent</code>中空闲的内存块变成了最大（即没有一份内存被分配），跳到2；如果这个<code>extent</code>中的空闲块变成了1并且这个<code>extent</code>不是<code>arena-&gt;bins[binind]-&gt;slabcur</code>，跳到3</li>
<li>将这个<code>extent</code>释放，即插入<code>arena-&gt;extents_dirty</code>中</li>
<li>将<code>arena-&gt;bins[binind]-&gt;slabcur</code>切换为这个<code>extent</code>，前提是这个<code>extent</code>“更旧”（序列号更小地址更低），并且将替换后的<code>extent</code>移入<code>arena-&gt;bins[binind]-&gt;slabs_nonfull</code></li>
</ol>
<h3 id="大内存释放"><a href="#大内存释放" class="headerlink" title="大内存释放"></a>大内存释放</h3><p>因为大内存不存放在<code>tsd-&gt;tcache</code>中，所以大内存释放只进行小内存释放的步骤2，即将<code>extent</code>插入<code>arena-&gt;extents_dirty</code>中。</p>
<h2 id="内存再分配（realloc）"><a href="#内存再分配（realloc）" class="headerlink" title="内存再分配（realloc）"></a>内存再分配（realloc）</h2><h3 id="小内存再分配"><a href="#小内存再分配" class="headerlink" title="小内存再分配"></a>小内存再分配</h3><ol>
<li>尝试进行 no move 分配，如果之前的实际分配满足条件的话，可以不做任何事情，直接返回。比如第一次申请了12字节，但实际上 jemalloc 会实际分配16字节，然后第二次申请将12扩大到15字节或者缩小到9字节，那这时候16字节就已经满足需求了，所以不做任何事情，如果无法满足，跳到2</li>
<li>重新分配，申请新内存大小（参考内存分配），然后将旧内存内容拷贝到新地址，之后释放旧内存（参考内存释放），最后返回新内存</li>
</ol>
<h3 id="大内存再分配"><a href="#大内存再分配" class="headerlink" title="大内存再分配"></a>大内存再分配</h3><ol>
<li>尝试进行 no move 分配，如果两次申请位于同一 size class 的话就可以不做任何事情，直接返回。</li>
<li>尝试进行 no move resize 分配，如果第二次申请的大小大于第一次，则尝试对当前地址所属<code>extent</code>的下一地址查看是否可以分配，比如当前<code>extent</code>地址是 0x1000，大小是 0x1000，那么我们查看地址 0x2000 开始的<code>extent</code>是否存在（通过 rtree）并且是否满足要求，如果满足要求那两个<code>extent</code>可以进行合并，成为一个新的<code>extent</code>而不需要重新分配；如果第二次申请的大小小于第一次，那么尝试对当前<code>extent</code>进行<code>split</code>，移除不需要的后半部分，以减少内存碎片；如果无法进行 no move resize 分配，跳到3</li>
<li>重新分配，申请新内存大小（参考内存分配），然后将旧内存内容拷贝到新地址，之后释放旧内存（参考内存释放），最后返回新内存</li>
</ol>
<h2 id="内存-GC"><a href="#内存-GC" class="headerlink" title="内存 GC"></a>内存 GC</h2><p>分为2种， tcache 和 extent GC。其实更准确来说是 decay，为了方便还是用 gc 吧。</p>
<h3 id="tcache-GC"><a href="#tcache-GC" class="headerlink" title="tcache GC"></a>tcache GC</h3><p>针对 small_class，防止某个线程预先分配了内存但是却没有实际分配给用户，会定期将缓存 flush 到 extent。</p>
<p>GC 策略：每次对于 tcache 进行 malloc 或者 free 操作都会执行一次计数，默认情况下达到228次就会触发 gc，每次 gc 一个<code>cache_bin</code>。</p>
<p>如何 GC：</p>
<ol>
<li><code>cache_bin.low_water &gt; 0</code>: gc 掉 low_water 的 3/4，同时，将<code>cache_bin</code>能缓存的最大数量缩小一倍</li>
<li><code>cache_bin.low_water &lt; 0</code>: 将<code>cache_bin</code>能缓存的最大数量增大一倍</li>
</ol>
<p>总的来说保证当前<code>cache_bin</code>分配越频繁，则会缓存更多的内存，否则则会减少。</p>
<h3 id="extent-GC"><a href="#extent-GC" class="headerlink" title="extent GC"></a>extent GC</h3><p>调用<code>free</code>时，内存并没有归还给内核。<code>jemalloc</code>内部会不定期地将没有用于分配的<code>extent</code>逐步GC，流程和内存申请是反向的，<code>free -&gt; extents_dirty -&gt; extents_muzzy -&gt; extents_retained -&gt; kernal</code>。</p>
<p>GC 策略：默认10s为<code>extents_dirty</code>和<code>extents_muzzy</code>的一个 gc 周期，每次对于<code>arena</code>进行<code>malloc</code>或者<code>free</code>操作都会执行一次计数，达到1000次会检测有没有达到<code>gc</code>的<code>deadline</code>，如果是的话进行 gc。</p>
<p>注意并不是每隔10s一次性 gc，实际上 jemalloc 会将10s划分成200份，即每隔0.05s进行一次 gc，这样一来如果<code>t</code>时刻有<code>N</code>个<code>page</code>需要<code>gc</code>，那么<code>jemalloc</code>尽力保证在<code>t+10</code>时刻这<code>N</code>个<code>page</code>会被<code>gc</code>完成。</p>
<p>对于<code>N</code>个需要<code>gc</code>的<code>page</code>来说，并不是简单地每0.05s处理<code>N/200</code>个<code>page</code>，<code>jemalloc</code>引入了<code>Smoothstep</code>（主要用于计算机图形学）来获得更加平滑的<code>gc</code>机制，这也是 jemalloc 非常有意思的一个点。</p>
<p>jemalloc 内部维护了一个长度为200的数组，用来计算在10s的 gc 周期内每个时间点应该对多少 page 进行 gc。这样保证两次 gc 的时间段内产生的需要 gc 的 page 都会以图中绿色线条（默认使用 smootherstep）的变化曲线在10s的周期内从 N 减为 0（从右往左）。</p>
<p>如何 GC：先进行<code>extents_dirty</code>的 gc，后进行<code>extents_muzzy</code>。</p>
<ol>
<li>将<code>extents_dirty</code>中的<code>extent</code>移入<code>extents_muzzy</code>：<ol>
<li>在<code>extents_dirty</code>中的<code>LRU</code>链表中，获得要进行<code>gc</code>的<code>extent</code>，尝试对<code>extent</code>进行前后合并（前提是两个<code>extent</code>位于同一<code>arena</code>并且位于同一<code>extents</code>中），获得新的<code>extent</code>，然后将其移除</li>
<li>对当前<code>extent</code>管理的地址进行<code>lazy purge</code>，即通过<code>madvise</code>使用<code>MADV_FREE</code>参数告诉内核当前<code>extent</code>管理的内存可能不会再被访问</li>
<li>在<code>extents_muzzy</code>中尝试对当前<code>extent</code>进行前后合并，获得新的<code>extent</code>，最后将其插入<code>extents_muzzy</code></li>
</ol>
</li>
<li>将<code>extents_muzzy</code>中的<code>extent</code>移入<code>extents_retained</code>:<ol>
<li>在<code>extents_muzzy</code>中的<code>LRU</code>链表中，获得要进行<code>gc</code>的<code>extent</code>，尝试对<code>extent</code>进行前后合并，获得新的<code>extent</code>，然后将其移除</li>
<li>对当前<code>extent</code>管理的地址进行<code>decommit</code>，即调用<code>mmap</code>带上<code>PROT_NONE</code>告诉内核当前<code>extent</code>管理的地址可能不会再被访问，如果<code>decommit</code>失败，会进行<code>force purge</code>，即通过<code>madvise</code>使用<code>MADV_DONTNEED</code>参数告诉内核当前<code>extent</code>管理的内存可能不会再被访问</li>
<li>在<code>extents_retained</code>中尝试对当前<code>extent</code>进行前后合并，获得新的<code>extent</code>，最后将其插入<code>extents_retained</code></li>
</ol>
</li>
<li>jemalloc 默认不会将内存归还给内核，只有进程结束时，所有内存才会<code>munmap</code>，从而归还给内核。不过可以手动进行<code>arena</code>的销毁，从而将<code>extents_retained</code>中的内存进行<code>munmap</code></li>
</ol>
<h2 id="附-快速调试Jemalloc"><a href="#附-快速调试Jemalloc" class="headerlink" title="附: 快速调试Jemalloc"></a>附: 快速调试Jemalloc</h2><p>一个简单的调试Je的方法是以静态库的方式将其编译到你的应用程序中。先编译Je的静态库，在源码目录下执行，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>就可以编译并安装Je到系统路径。调试还必须打开一些选项，例如，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-debug  --with-jemalloc-prefix=&lt;prefix&gt;</span><br></pre></td></tr></table></figure>
<p>这些选项的意义可以参考INSTALL文档。比如，</p>
<ul>
<li><code>--disable-tcache</code> 是否禁用tcache，对调试非tcache流程有用。</li>
<li><code>--disable-prof</code>   是否禁用heap profile.</li>
<li><code>--enable-debug</code>   打开调试模式，启动assert并关闭优化。</li>
<li><code>--with-jemalloc-prefix</code>  将编译出的malloc加上设定的前缀，以区别c库的调用。</li>
</ul>
<p>之后就可以将其编译到你的代码中，如，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c /usr/local/lib/libjemalloc.a -std=c99 -O0 -g3 -pthread -o jhello</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/15/ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="glibc内存管理ptmalloc源代码分析1">
      <i class="fa fa-chevron-left"></i> glibc内存管理ptmalloc源代码分析1
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/09/%E9%A2%91%E7%B9%81%E9%A1%B9%E9%9B%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%AE%97%E6%B3%95/" rel="next" title="频繁项集的两个算法">
      频繁项集的两个算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">背景知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="nav-number">1.1.</span> <span class="nav-text">内存的来源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#False-cache-line-sharing"><span class="nav-number">1.2.</span> <span class="nav-text">False cache line sharing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9D%80%E8%89%B2"><span class="nav-number">1.3.</span> <span class="nav-text">内存着色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">1.4.</span> <span class="nav-text">为什么需要内存分配器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">1.5.</span> <span class="nav-text">内存分配器的目标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">常用内存分配器算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Dynamic-memory-allocation"><span class="nav-number">2.1.</span> <span class="nav-text">Dynamic memory allocation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buddy-memory-allocation"><span class="nav-number">2.2.</span> <span class="nav-text">Buddy memory allocation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slab-allocation"><span class="nav-number">2.3.</span> <span class="nav-text">Slab allocation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jemalloc-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">jemalloc 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Some-structures"><span class="nav-number">3.1.</span> <span class="nav-text">1 - Some structures</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#page"><span class="nav-number">3.1.1.</span> <span class="nav-text">page</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chunk"><span class="nav-number">3.1.2.</span> <span class="nav-text">chunk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#base"><span class="nav-number">3.1.3.</span> <span class="nav-text">base</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arena"><span class="nav-number">3.1.4.</span> <span class="nav-text">arena</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#run"><span class="nav-number">3.1.5.</span> <span class="nav-text">run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bin"><span class="nav-number">3.1.6.</span> <span class="nav-text">bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chunk-1"><span class="nav-number">3.1.7.</span> <span class="nav-text">chunk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arena-chunk-t"><span class="nav-number">3.1.8.</span> <span class="nav-text">arena_chunk_t</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Basic-structures"><span class="nav-number">3.2.</span> <span class="nav-text">2 - Basic structures</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Overview"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.1 - Overview</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Arena-arena-t"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2 - Arena (arena_t)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-CPU-Cache-Line"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">2.2.1 - CPU Cache-Line</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-Arena%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">2.2.2 - Arena原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-choose-arena"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">2.2.3 - choose_arena</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-Arena%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">2.2.4 - Arena结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Chunk-arena-chunk-t"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.3 - Chunk (arena_chunk_t)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-overview"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">2.3.1 - overview</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-Chunk%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">2.3.2 - Chunk结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-chunk-map-arena-chunk-map-t"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">2.3.3 - chunk map (arena_chunk_map_t)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Run-arena-run-t"><span class="nav-number">3.2.4.</span> <span class="nav-text">2.4 - Run (arena_run_t)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-Run%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">2.4.1 - Run结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-size-classes"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">2.4.2 - size classes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-size2bin-bin2size"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">2.4.3 - size2bin&#x2F;bin2size</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-bins-arena-bin-t"><span class="nav-number">3.2.5.</span> <span class="nav-text">2.5 - bins (arena_bin_t)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-Thread-caches-tcache-t"><span class="nav-number">3.2.6.</span> <span class="nav-text">2.6 - Thread caches (tcache_t)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-Extent-Node-extent-node-t"><span class="nav-number">3.2.7.</span> <span class="nav-text">2.7 - Extent Node (extent_node_t)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-Base"><span class="nav-number">3.2.8.</span> <span class="nav-text">2.8 - Base</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Allocation"><span class="nav-number">3.3.</span> <span class="nav-text">3 - Allocation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Overview"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.1 - Overview</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Initialize"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.2 - Initialize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Small-allocation-Arena"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3 - Small allocation (Arena)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-arena-run-reg-alloc"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">3.3.1 - arena_run_reg_alloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-arena-bin-malloc-hard"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">3.3.2 - arena_bin_malloc_hard</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-arena-bin-nonfull-run-get"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">3.3.3 - arena_bin_nonfull_run_get</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-Small-Run-Alloc"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">3.3.4 - Small Run Alloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-Chunk-Alloc"><span class="nav-number">3.3.3.5.</span> <span class="nav-text">3.3.5 - Chunk Alloc</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Small-allocation-tcache"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.4 - Small allocation (tcache)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Large-allocation"><span class="nav-number">3.3.5.</span> <span class="nav-text">3.5 - Large allocation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-Huge-allocation"><span class="nav-number">3.3.6.</span> <span class="nav-text">3.6 - Huge allocation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.4.</span> <span class="nav-text"> </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Deallocation"><span class="nav-number">3.5.</span> <span class="nav-text">4 - Deallocation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Overview"><span class="nav-number">3.5.1.</span> <span class="nav-text">4.1 - Overview</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-arena-dalloc-bin"><span class="nav-number">3.5.2.</span> <span class="nav-text">4.2 - arena_dalloc_bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-small-run-dalloc"><span class="nav-number">3.5.3.</span> <span class="nav-text">4.3 - small run dalloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-arena-purge"><span class="nav-number">3.5.4.</span> <span class="nav-text">4.4 - arena purge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-arena-chunk-dalloc"><span class="nav-number">3.5.5.</span> <span class="nav-text">4.5 - arena chunk dalloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-large-huge-dalloc"><span class="nav-number">3.5.6.</span> <span class="nav-text">4.6 - large&#x2F;huge dalloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93-%E4%B8%8EDl%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">3.6.</span> <span class="nav-text">5 - 总结: 与Dl的对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96-metadata"><span class="nav-number">4.</span> <span class="nav-text">常量时间获取 metadata</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E-run-%E5%88%B0-region"><span class="nav-number">4.1.</span> <span class="nav-text">从 run 到 region</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E-region-%E5%88%B0-run"><span class="nav-number">4.2.</span> <span class="nav-text">从 region 到 run</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#run-%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number">4.3.</span> <span class="nav-text">run 的合并</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#size-classes"><span class="nav-number">5.</span> <span class="nav-text">size classes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#small"><span class="nav-number">5.1.</span> <span class="nav-text">small</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#large"><span class="nav-number">5.2.</span> <span class="nav-text">large</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#huge"><span class="nav-number">5.3.</span> <span class="nav-text">huge</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#purge"><span class="nav-number">5.4.</span> <span class="nav-text">purge</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#arena-1"><span class="nav-number">6.1.</span> <span class="nav-text">arena</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">6.2.</span> <span class="nav-text">锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tsd"><span class="nav-number">6.3.</span> <span class="nav-text">tsd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache"><span class="nav-number">6.4.</span> <span class="nav-text">tcache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#small-1"><span class="nav-number">6.5.</span> <span class="nav-text">small</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#large-1"><span class="nav-number">6.6.</span> <span class="nav-text">large</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gc"><span class="nav-number">6.7.</span> <span class="nav-text">gc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-number">6.8.</span> <span class="nav-text">线程退出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JeMalloc-5-1-0-%E7%89%88%E6%9C%AC"><span class="nav-number">8.</span> <span class="nav-text">JeMalloc-5.1.0 版本</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">8.1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#size-class"><span class="nav-number">8.1.1.</span> <span class="nav-text">size_class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#base-1"><span class="nav-number">8.1.2.</span> <span class="nav-text">base</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bin-1"><span class="nav-number">8.1.3.</span> <span class="nav-text">bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extent"><span class="nav-number">8.1.4.</span> <span class="nav-text">extent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slab"><span class="nav-number">8.1.5.</span> <span class="nav-text">slab</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extents"><span class="nav-number">8.1.6.</span> <span class="nav-text">extents</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arena-2"><span class="nav-number">8.1.7.</span> <span class="nav-text">arena</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rtree"><span class="nav-number">8.1.8.</span> <span class="nav-text">rtree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache-bin"><span class="nav-number">8.1.9.</span> <span class="nav-text">cache_bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-1"><span class="nav-number">8.1.10.</span> <span class="nav-text">tcache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tsd-1"><span class="nav-number">8.1.11.</span> <span class="nav-text">tsd</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%88malloc%EF%BC%89"><span class="nav-number">8.2.</span> <span class="nav-text">内存分配（malloc）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E5%86%85%E5%AD%98-small-class-%E5%88%86%E9%85%8D"><span class="nav-number">8.2.1.</span> <span class="nav-text">小内存(small_class)分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%86%85%E5%AD%98-large-class-%E5%88%86%E9%85%8D"><span class="nav-number">8.2.2.</span> <span class="nav-text">大内存(large_class)分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%EF%BC%88free%EF%BC%89"><span class="nav-number">8.3.</span> <span class="nav-text">内存释放（free）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE"><span class="nav-number">8.3.1.</span> <span class="nav-text">小内存释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE"><span class="nav-number">8.3.2.</span> <span class="nav-text">大内存释放</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%86%8D%E5%88%86%E9%85%8D%EF%BC%88realloc%EF%BC%89"><span class="nav-number">8.4.</span> <span class="nav-text">内存再分配（realloc）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E5%86%85%E5%AD%98%E5%86%8D%E5%88%86%E9%85%8D"><span class="nav-number">8.4.1.</span> <span class="nav-text">小内存再分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%86%85%E5%AD%98%E5%86%8D%E5%88%86%E9%85%8D"><span class="nav-number">8.4.2.</span> <span class="nav-text">大内存再分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98-GC"><span class="nav-number">8.5.</span> <span class="nav-text">内存 GC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-GC"><span class="nav-number">8.5.1.</span> <span class="nav-text">tcache GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extent-GC"><span class="nav-number">8.5.2.</span> <span class="nav-text">extent GC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84-%E5%BF%AB%E9%80%9F%E8%B0%83%E8%AF%95Jemalloc"><span class="nav-number">8.6.</span> <span class="nav-text">附: 快速调试Jemalloc</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
