<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="来源：https:&#x2F;&#x2F;blog.csdn.net&#x2F;maokelong95&#x2F;article&#x2F;details&#x2F;51989081 前言堆内存（Heap Memory）是一个很有意思的领域。你可能和我一样，也困惑于下述问题很久了：  如何从内核申请堆内存？ 谁管理它？内核、库函数，还是应用本身？ 内存管理效率怎么这么高？！ 堆内存的管理效率可以进一步提高吗？最近，我终于有时间去深入了解这些问题。下面就让我">
<meta property="og:type" content="article">
<meta property="og:title" content="理解 glibc malloc：主流用户态内存分配器实现原理">
<meta property="og:url" content="http://yoursite.com/2019/04/24/%E7%90%86%E8%A7%A3glibc_malloc_%E4%B8%BB%E6%B5%81%E7%94%A8%E6%88%B7%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="来源：https:&#x2F;&#x2F;blog.csdn.net&#x2F;maokelong95&#x2F;article&#x2F;details&#x2F;51989081 前言堆内存（Heap Memory）是一个很有意思的领域。你可能和我一样，也困惑于下述问题很久了：  如何从内核申请堆内存？ 谁管理它？内核、库函数，还是应用本身？ 内存管理效率怎么这么高？！ 堆内存的管理效率可以进一步提高吗？最近，我终于有时间去深入了解这些问题。下面就让我">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/20160722093242640.jpg">
<meta property="og:image" content="http://yoursite.com/img/20160721184928041.jpg">
<meta property="og:image" content="http://yoursite.com/img/20160721185023152.jpg">
<meta property="og:image" content="http://yoursite.com/img/20160721185357845.jpg">
<meta property="og:image" content="http://yoursite.com/img/20160721192333308.jpg">
<meta property="og:image" content="http://yoursite.com/img/20160721213038334.jpg">
<meta property="og:image" content="http://yoursite.com/img/20160721213935918.jpg">
<meta property="og:image" content="http://yoursite.com/img/20190411301.png">
<meta property="og:image" content="http://yoursite.com/img/20190411302.png">
<meta property="og:image" content="http://yoursite.com/img/20190411303.png">
<meta property="og:image" content="http://yoursite.com/img/20190411304.png">
<meta property="og:image" content="http://yoursite.com/img/20161022102340793.png">
<meta property="og:image" content="http://yoursite.com/img/20161022102359935.png">
<meta property="og:image" content="http://yoursite.com/img/20161022102859452.png">
<meta property="og:image" content="http://yoursite.com/img/20161022102915426.png">
<meta property="og:image" content="http://yoursite.com/img/20161022103100584.png">
<meta property="og:image" content="http://yoursite.com/img/20161022103142257.png">
<meta property="og:image" content="http://yoursite.com/img/20161022103757266.png">
<meta property="og:image" content="http://yoursite.com/img/20161022104539161.png">
<meta property="og:image" content="http://yoursite.com/img/20161022104819952.png">
<meta property="og:image" content="http://yoursite.com/img/20161022111651504.png">
<meta property="og:image" content="http://yoursite.com/img/20211220142105.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211220142323.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211220142350.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211220142552.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211220142913.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211220142950.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211220143104.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211220144136.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211220144402.jpg">
<meta property="og:image" content="http://yoursite.com/img/051536255466644.png">
<meta property="og:image" content="http://yoursite.com/img/051536281096429.png">
<meta property="og:image" content="http://yoursite.com/img/051536262965015.png">
<meta property="og:image" content="http://yoursite.com/img/051536255788401.png">
<meta property="og:image" content="http://yoursite.com/img/051536261875516.png">
<meta property="og:image" content="http://yoursite.com/img/051536258592317.png">
<meta property="og:image" content="http://yoursite.com/img/051536268121159.png">
<meta property="article:published_time" content="2019-04-24T05:41:39.000Z">
<meta property="article:modified_time" content="2022-12-26T12:30:45.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/20160722093242640.jpg">

<link rel="canonical" href="http://yoursite.com/2019/04/24/%E7%90%86%E8%A7%A3glibc_malloc_%E4%B8%BB%E6%B5%81%E7%94%A8%E6%88%B7%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>理解 glibc malloc：主流用户态内存分配器实现原理 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/24/%E7%90%86%E8%A7%A3glibc_malloc_%E4%B8%BB%E6%B5%81%E7%94%A8%E6%88%B7%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          理解 glibc malloc：主流用户态内存分配器实现原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-24 13:41:39" itemprop="dateCreated datePublished" datetime="2019-04-24T13:41:39+08:00">2019-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 20:30:45" itemprop="dateModified" datetime="2022-12-26T20:30:45+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>来源：<a href="https://blog.csdn.net/maokelong95/article/details/51989081">https://blog.csdn.net/maokelong95/article/details/51989081</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>堆内存（Heap Memory）是一个很有意思的领域。你可能和我一样，也困惑于下述问题很久了：</p>
<ul>
<li>如何从内核申请堆内存？</li>
<li>谁管理它？内核、库函数，还是应用本身？</li>
<li>内存管理效率怎么这么高？！</li>
<li>堆内存的管理效率可以进一步提高吗？<br>最近，我终于有时间去深入了解这些问题。下面就让我来谈谈我的调研成果。</li>
</ul>
<p>开源社区公开了很多现成的内存分配器（Memory Allocators，以下简称为分配器）：</p>
<ul>
<li>dlmalloc – 第一个被广泛使用的通用动态内存分配器；</li>
<li>ptmalloc2 – glibc 内置分配器的原型；</li>
<li>jemalloc – FreeBSD ＆ Firefox 所用分配器；</li>
<li>tcmalloc – Google 贡献的分配器；</li>
<li>libumem – Solaris 所用分配器；<br>…</li>
</ul>
<p>每一种分配器都宣称自己快（fast）、可拓展（scalable）、效率高（memory efficient）！但是并非所有的分配器都适用于我们的应用。内存吞吐量大（memory hungry）的应用程序，其性能很大程度上取决于分配器的性能。</p>
<blockquote>
<p>历史：ptmalloc2 基于 dlmalloc 开发，其引入了多线程支持，于 2006 年发布。发布之后，ptmalloc2 整合进了 glibc 源码，此后其所有修改都直接提交到了 glibc malloc 里。因此，ptmalloc2 的源码和 glibc malloc 的源码有很多不一致的地方。（译者注：1996 年出现的 dlmalloc 只有一个主分配区，该分配区为所有线程所争用，1997 年发布的 ptmalloc 在 dlmalloc 的基础上引入了非主分配区的概念。）</p>
</blockquote>
<h1 id="申请堆的系统调用"><a href="#申请堆的系统调用" class="headerlink" title="申请堆的系统调用"></a>申请堆的系统调用</h1><p>我在之前的文章中提到过，malloc 内部通过 brk 或 mmap 系统调用向内核申请堆区。</p>
<p>在内存管理领域，我们一般用「堆」指代用于分配动态内存的虚拟地址空间，而用「栈」指代用于分配静态内存的虚拟地址空间。具体到虚拟内存布局（Memory Layout），堆维护在通过 brk 系统调用申请的「Heap」及通过 mmap 系统调用申请的「Memory Mapping Segment」中；而栈维护在通过汇编栈指令动态调整的「Stack」中。在 Glibc 里，「Heap」用于分配较小的内存及主线程使用的内存。</p>
<p>下图为 Linux 内核 v2.6.7 之后，32 位模式下的虚拟内存布局方式。<br><img src="/img/20160722093242640.jpg" alt=""></p>
<h1 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h1><p>Linux 的早期版本采用 dlmalloc 作为它的默认分配器，但是因为 ptmalloc2 提供了多线程支持，所以 后来 Linux 就转而采用 ptmalloc2 了。多线程支持可以提升分配器的性能，进而间接提升应用的性能。</p>
<p>在 dlmalloc 中，当两个线程同时 malloc 时，只有一个线程能够访问临界区（critical section）——这是因为所有线程共享用以缓存已释放内存的「空闲列表数据结构」（freelist data structure），所以使用 dlmalloc 的多线程应用会在 malloc 上耗费过多时间，从而导致整个应用性能的下降。</p>
<p>在 ptmalloc2 中，当两个线程同时调用 malloc 时，内存均会得以立即分配——每个线程都维护着单独的堆，各个堆被独立的空闲列表数据结构管理，因此各个线程可以并发地从空闲列表数据结构中申请内存。这种为每个线程维护独立堆与空闲列表数据结构的行为就「per thread arena」。</p>
<h2 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/* Per thread arena example. */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">void* threadFunc(void* arg) &#123;</span><br><span class="line">    printf(&quot;Before malloc in thread 1\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">    char* addr = (char*) malloc(1000);</span><br><span class="line">    printf(&quot;After malloc and before free in thread 1\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">    free(addr);</span><br><span class="line">    printf(&quot;After free in thread 1\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    pthread_t t1;</span><br><span class="line">    void* s;</span><br><span class="line">    int ret;</span><br><span class="line">    char* addr;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Welcome to per thread arena example::%d\n&quot;,getpid());</span><br><span class="line">    printf(&quot;Before malloc in main thread\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">    addr = (char*) malloc(1000);</span><br><span class="line">    printf(&quot;After malloc and before free in main thread\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">    free(addr);</span><br><span class="line">    printf(&quot;After free in main thread\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">    ret = pthread_create(&amp;t1, NULL, threadFunc, NULL);</span><br><span class="line">    if(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Thread creation error\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_join(t1, &amp;s);</span><br><span class="line">    if(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Thread join error\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="案例输出"><a href="#案例输出" class="headerlink" title="案例输出"></a>案例输出</h2><h3 id="在主线程-malloc-之前"><a href="#在主线程-malloc-之前" class="headerlink" title="在主线程 malloc 之前"></a>在主线程 malloc 之前</h3><p>从如下的输出结果中我们可以看到，这里还没有堆段也没有每个线程的栈，因为 thread1 还没有创建！<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread </span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0 </span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure></p>
<h3 id="在主线程-malloc-之后"><a href="#在主线程-malloc-之后" class="headerlink" title="在主线程 malloc 之后"></a>在主线程 malloc 之后</h3><p>从如下的输出结果中我们可以看到，堆段已经产生，并且其地址区间正好在数据段（0x0804b000 - 0x0806c000）上面，这表明堆内存是移动「Program Break」的位置产生的（也即通过 brk 中断）。此外，请注意，尽管用户只申请了 1000 字节的内存，但是实际产生了 132KB 的堆。这个连续的堆区域被称为「arena」。因为这个 arena 是被主线程建立的，因此其被称为「main arena」。接下来的申请会继续分配这个 arena 的 132KB 中剩余的部分。当分配完毕时，它可以通过继续移动 Program Break 的位置扩容。扩容后，「top chunk」的大小也随之调整，以将这块新增的空间圈进去；相应地，arena 也可以在 top chunk 过大时缩小。</p>
<blockquote>
<p>注意：top chunk 是一个 arena 位于最顶层的 chunk。有关 top chunk 的更多信息详见后续章节「top chunk」部分。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread </span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0 </span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="在主线程-free-之后"><a href="#在主线程-free-之后" class="headerlink" title="在主线程 free 之后"></a>在主线程 free 之后</h3><p>从如下的输出结果中我们可以看到，当分配的内存区域 free 掉时，其并不会立即归还给操作系统，而仅仅是移交给了作为库函数的分配器。这块 free 掉的内存添加在了「main arenas bin」中（在 glibc malloc 中，空闲列表数据结构被称为「bin」）。随后当用户请求内存时，分配器就不再向内核申请新堆了，而是先试着各个「bin」中查找空闲内存。只有当 bin 中不存在空闲内存时，分配器才会继续向内核申请内存。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread </span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0 </span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure></p>
<h3 id="在-thread1-malloc-之前"><a href="#在-thread1-malloc-之前" class="headerlink" title="在 thread1 malloc 之前"></a>在 thread1 malloc 之前</h3><p>从如下的输出结果中我们可以看到，此时 thread1 的堆尚不存在，但其栈已产生。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread </span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0 </span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure></p>
<h3 id="在-thread1-malloc-之后"><a href="#在-thread1-malloc-之后" class="headerlink" title="在 thread1 malloc 之后"></a>在 thread1 malloc 之后</h3><p>从如下的输出结果中我们可以看到，thread1 的堆段(b7500000 - b7521000，132KB)建立在了内存映射段中，这也表明了堆内存是使用 mmap 系统调用产生的，而非同主线程一样使用 sbrk 系统调用。类似地，尽管用户只请求了 1000B，但是映射到程地址空间的堆内存足有 1MB。这 1MB 中，只有 132KB 被设置了读写权限，并成为该线程的堆内存。这段连续内存（132KB）被称为「thread arena」。</p>
<blockquote>
<p>注意：当用户请求超过 128KB(比如 malloc(132*1024)) 大小并且此时 arena 中没有足够的空间来满足用户的请求时，内存将通过 mmap 系统调用（不再是 sbrk）分配，而不论请求是发自 main arena 还是 thread arena。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread </span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">After malloc and before free in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0 </span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0 </span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0 </span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="在-thread1-free-之后"><a href="#在-thread1-free-之后" class="headerlink" title="在 thread1 free 之后"></a>在 thread1 free 之后</h3><p>从如下的输出结果中我们可以看到，free 不会把内存归还给操作系统，而是移交给分配器，然后添加在了「thread arenas bin」中。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread </span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">After malloc and before free in thread 1</span><br><span class="line">After free in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0 </span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0 </span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0 </span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure></p>
<h1 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h1><h2 id="Arena-的数量"><a href="#Arena-的数量" class="headerlink" title="Arena 的数量"></a>Arena 的数量</h2><p>在以上的例子中我们可以看到，主线程包含 main arena 而 thread 1 包含它自己的 thread arena。所以线程和 arena 之间是否存在一一映射关系，而不论线程的数量有多大？当然不是，部分极端的应用甚至运行比处理器核数还多的线程，在这种情况下，每个线程都拥有一个 arena 开销过高且意义不大。所以，arena 数量其实是限于系统核数的。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 32 bit systems:</span><br><span class="line">Number of arena = 2 * number of cores + 1.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">Number of arena = 8 * number of cores + 1.</span><br></pre></td></tr></table></figure></p>
<h2 id="Multiple-Arena"><a href="#Multiple-Arena" class="headerlink" title="Multiple Arena"></a>Multiple Arena</h2><p>举例而言：让我们来看一个运行在单核计算机上的 32 位操作系统上的多线程应用（4 线程，主线程 + 3 个线程）的例子。这里线程数量（4）&gt; 2 * 核心数（1） + 1，所以分配器中至少有一个 Arena（也即标题所称「multiple arenas」）会被所有线程共享。那么是如何共享的呢？</p>
<ul>
<li>当主线程第一次调用 malloc 时，已经建立的 main arena 会被没有任何竞争地使用；</li>
<li>当 thread 1 和 thread 2 第一次调用 malloc 时，一块新的 arena 将被创建，且将被没有任何竞争地使用。此时线程和 arena 之间存在一一映射关系；</li>
<li>当 thread3 第一次调用 malloc 时，arena 的数量限制被计算出来，结果显示已超出，因此尝试复用已经存在的 arena（也即 Main arena 或 Arena 1 或 Arena 2）；</li>
<li>复用：<br>一旦遍历到可用 arena，就开始自旋申请该 arena 的锁；<br>如果上锁成功（比如说 main arena 上锁成功），就将该 arena 返回用户；<br>如果没找到可用 arena，thread 3 的 malloc 将被阻塞，直到有可用的 arena 为止。</li>
<li><p>当thread 3 调用 malloc 时(第二次了)，分配器会尝试使用上一次使用的 arena（也即，main arena），从而尽量提高缓存命中率。当 main arena 可用时就用，否则 thread 3 就一直阻塞，直至 main arena 空闲。因此现在 main arena 实际上是被 main thread 和 thread 3 所共享。</p>
<h2 id="Multiple-Heaps"><a href="#Multiple-Heaps" class="headerlink" title="Multiple Heaps"></a>Multiple Heaps</h2><p>在「glibc malloc」中主要有 3 种数据结构：</p>
</li>
<li><p>heap_info ——Heap Header—— 一个 thread arena 可以维护多个堆。每个堆都有自己的堆 Header（注：也即头部元数据）。什么时候 Thread Arena 会维护多个堆呢？ 一般情况下，每个 thread arena 都只维护一个堆，但是当这个堆的空间耗尽时，新的堆（而非连续内存区域）就会被 mmap 到这个 aerna 里；</p>
</li>
<li>malloc_state ——Arena header—— 一个 thread arena 可以维护多个堆，这些堆另外共享同一个 arena header。Arena header 描述的信息包括：bins、top chunk、last remainder chunk 等；</li>
<li>malloc_chunk ——Chunk header—— 根据用户请求，每个堆被分为若干 chunk。每个 chunk 都有自己的 chunk header。</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>Main arena 无需维护多个堆，因此也无需 heap_info。当空间耗尽时，与 thread arena 不同，main arena 可以通过 sbrk 拓展堆段，直至堆段「碰」到内存映射段；</li>
<li>与 thread arena 不同，main arena 的 arena header 不是保存在通过 sbrk 申请的堆段里，而是作为一个全局变量，可以在 libc.so 的数据段中找到。</li>
</ul>
</blockquote>
<p>main arena 和 thread arena 的图示如下（单堆段）：<br><img src="/img/20160721184928041.jpg" alt=""></p>
<p>thread arena 的图示如下（多堆段）：<br><img src="/img/20160721185023152.jpg" alt=""></p>
<h1 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h1><p>堆段中存在的 chunk 类型如下：</p>
<ul>
<li>Allocated chunk;</li>
<li>Free chunk;</li>
<li>Top chunk;</li>
<li>Last Remainder chunk.</li>
</ul>
<h2 id="Allocated-chunk"><a href="#Allocated-chunk" class="headerlink" title="Allocated chunk"></a>Allocated chunk</h2><p>「Allocated chunck」就是已经分配给用户的 chunk，其图示如下：<br><img src="/img/20160721185357845.jpg" alt=""></p>
<p>图中左方三个箭头依次表示：</p>
<ul>
<li>chunk：该 Allocated chunk 的起始地址；</li>
<li>mem：该 Allocated chunk 中用户可用区域的起始地址（= chunk + sizeof(malloc_chunk)）；</li>
<li>next_chunk：下一个 chunck（无论类型）的起始地址。</li>
</ul>
<p>图中结构体内部各字段的含义依次为：</p>
<ul>
<li>prev_size：若上一个 chunk 可用，则此字段赋值为上一个 chunk 的大小；否则，此字段被用来存储上一个 chunk 的用户数据；</li>
<li>size：此字段赋值本 chunk 的大小，其最后三位包含标志信息：</li>
<li>PREV_INUSE § – 置「1」表示上个 chunk 被分配；</li>
<li>IS_MMAPPED (M) – 置「1」表示这个 chunk 是通过 mmap 申请的（较大的内存）；</li>
<li>NON_MAIN_ARENA (N) – 置「1」表示这个 chunk 属于一个 thread arena。</li>
</ul>
<p>注意：</p>
<p>malloc_chunk 中的其余结构成员，如 fd、 bk，没有使用的必要而拿来存储用户数据；<br>用户请求的大小被转换为内部实际大小，因为需要额外空间存储 malloc_chunk，此外还需要考虑对齐。</p>
<h2 id="Free-chunk"><a href="#Free-chunk" class="headerlink" title="Free chunk"></a>Free chunk</h2><p>「Free chunck」就是用户已释放的 chunk，其图示如下：<br><img src="/img/20160721192333308.jpg" alt=""></p>
<p>图中结构体内部各字段的含义依次为：</p>
<ul>
<li>prev_size: 两个相邻 free chunk 会被合并成一个，因此该字段总是保存前一个 allocated chunk 的用户数据；</li>
<li>size: 该字段保存本 free chunk 的大小；</li>
<li>fd: Forward pointer —— 本字段指向同一 bin 中的下个 free chunk（free chunk 链表的前驱指针）；</li>
<li>bk: Backward pointer —— 本字段指向同一 bin 中的上个 free chunk（free chunk 链表的后继指针）。</li>
</ul>
<h1 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h1><p>「bins」 就是空闲列表数据结构。它们用以保存 free chunks。根据其中 chunk 的大小，bins 被分为如下几种类型：</p>
<ul>
<li>Fast bin;</li>
<li>Unsorted bin;</li>
<li>Small bin;</li>
<li>Large bin.</li>
</ul>
<p>保存这些 bins 的字段为：</p>
<ul>
<li>fastbinsY: 这个数组用以保存 fast bins；</li>
<li>bins: 这个数组用于保存 unsorted bin、small bins 以及 large bins，共计可容纳 126 个，其中：</li>
<li>Bin 1: unsorted bin;</li>
<li>Bin 2 - 63: small bins;</li>
<li>Bin 64 - 126: large bins.</li>
</ul>
<h2 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h2><p>大小为 16 ~ 80 字节的 chunk 被称为「fast chunk」。在所有的 bins 中，fast bins 路径享有最快的内存分配及释放速度。</p>
<ul>
<li>数量：10</li>
<li>每个 fast bin 都维护着一条 free chunk 的单链表，采用单链表是因为链表中所有 chunk 的大小相等，增删 chunk 发生在链表顶端即可；—— LIFO</li>
<li>chunk 大小：8 字节递增</li>
<li>fast bins 由一系列所维护 chunk 大小以 8 字节递增的 bins 组成。也即，fast bin[0] 维护大小为 16 字节的 chunk、fast bin[1] 维护大小为 24 字节的 chunk。依此类推……</li>
<li>指定 fast bin 中所有 chunk 大小相同；</li>
<li>在 malloc 初始化过程中，最大的 fast bin 的大小被设置为 64 而非 80 字节。因为默认情况下只有大小 16 ~ 64 的 chunk 被归为 fast chunk 。</li>
<li>无需合并 —— 两个相邻 chunk 不会被合并。虽然这可能会加剧内存碎片化，但也大大加速了内存释放的速度！</li>
<li>malloc(fast chunk)</li>
<li>初始情况下 fast chunck 最大尺寸以及 fast bin 相应数据结构均未初始化，因此即使用户请求内存大小落在 fast chunk 相应区间，服务用户请求的也将是 small bin 路径而非 fast bin 路径；</li>
<li>初始化后，将在计算 fast bin 索引后检索相应 bin；</li>
<li>相应 bin 中被检索的第一个 chunk 将被摘除并返回给用户。</li>
<li>free(fast chunk)</li>
<li>计算 fast bin 索引以索引相应 bin；</li>
<li>free 掉的 chunk 将被添加到上述 bin 的顶端。</li>
</ul>
<p><img src="/img/20160721213038334.jpg" alt=""></p>
<h2 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h2><p>当 small chunk 和 large chunk 被 free 掉时，它们并非被添加到各自的 bin 中，而是被添加在 「unsorted bin」 中。这使得分配器可以重新使用最近 free 掉的 chunk，从而消除了寻找合适 bin 的时间开销，进而加速了内存分配及释放的效率。</p>
<ul>
<li>数量：1</li>
<li>unsorted bin 包括一个用于保存 free chunk 的双向循环链表（又名 binlist）；</li>
<li>chunk 大小：无限制，任何大小的 chunk 均可添加到这里。<br><img src="/img/20160721213935918.jpg" alt=""></li>
</ul>
<h2 id="Small-Bin"><a href="#Small-Bin" class="headerlink" title="Small Bin"></a>Small Bin</h2><p>大小小于 512 字节的 chunk 被称为 「small chunk」，而保存 small chunks 的 bin 被称为 「small bin」。在内存分配回收的速度上，small bin 比 large bin 更快。</p>
<ul>
<li>数量：62</li>
<li>每个 small bin 都维护着一条 free chunk 的双向循环链表。free 掉的 chunk 添加在链表的顶端，而 malloc 的 chunk 从链表尾端摘除。—— FIFO</li>
<li>chunk 大小：8 字节递增</li>
<li>Small bins 由一系列所维护 chunk 大小以 8 字节递增的 bins 组成。举例而言，small bin[0] （Bin 2）维护着大小为 16 字节的 chunks、small bin[1]（Bin 3）维护着大小为 24 字节的 chunks ，依此类推……</li>
<li>指定 small bin 中所有 chunk 大小均相同，因此无需排序；</li>
<li>合并 —— 相邻的 free chunk 将被合并，这减缓了内存碎片化，但是减慢了 free 的速度；</li>
<li>malloc(small chunk)</li>
<li>初始情况下，small bins 都是 NULL，因此尽管用户请求 small chunk ，提供服务的将是 unsorted bin 路径而不是 small bin 路径；</li>
<li>第一次调用 malloc 时，维护在 malloc_state 中的 small bins 和 large bins 将被初始化，它们都会指向自身以表示其为空；</li>
<li>此后当 small bin 非空，相应的 bin 会摘除其中最后一个 chunk 并返回给用户；</li>
<li>free(small chunk)</li>
<li><p>free chunk 的时候，检查其前后的 chunk 是否空闲，若是则合并，也即把它们从所属的链表中摘除并合并成一个新的 chunk，新 chunk 会添加在unsorted bin 的前端。</p>
<h2 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h2><p>大小大于等于 512 字节的 chunk 被称为「large chunk」，而保存 large chunks 的 bin 被称为 「large bin」。在内存分配回收的速度上，large bin 比 small bin 慢。</p>
</li>
<li><p>数量：63</p>
</li>
<li>每个 large bin 都维护着一条 free chunk 的双向循环链表。free 掉的 chunk 添加在链表的顶端，而 malloc 的 chunk 从链表尾端摘除。——FIFO</li>
<li>这 63 个 bins</li>
<li>32 个 bins 所维护的 chunk 大小以 64B 递增，也即 <code>large chunk[0](Bin 65)</code> 维护着大小为 512B ~ 568B 的 chunk 、<code>large chunk[1](Bin 66)</code> 维护着大小为 576B ~ 632B 的 chunk，依此类推……</li>
<li>16 个 bins 所维护的 chunk 大小以 512 字节递增；</li>
<li>8 个 bins 所维护的 chunk 大小以 4096 字节递增；</li>
<li>4 个 bins 所维护的 chunk 大小以 32768 字节递增；</li>
<li>2 个 bins 所维护的 chunk 大小以 262144 字节递增；</li>
<li>1 个 bin 维护所有剩余 chunk 大小；</li>
<li>不像 small bin ，large bin 中所有 chunk 大小不一定相同，各 chunk 大小递减保存。最大的 chunk 保存顶端，而最小的 chunk 保存在尾端；</li>
<li>合并 —— 两个相邻的空闲 chunk 会被合并；</li>
<li><code>malloc(large chunk)</code></li>
<li>初始情况下，large bin 都会是 NULL，因此尽管用户请求 large chunk ，提供服务的将是 next largetst bin 路径而不是 large bin 路劲 。</li>
<li>第一次调用 malloc 时，维护在 malloc_state 中的 small bin 和 large bin 将被初始化，它们都会指向自身以表示其为空；</li>
<li>此后当 large bin 非空，如果相应 bin 中的最大 chunk 大小大于用户请求大小，分配器就从该 bin 顶端遍历到尾端，以找到一个大小最接近用户请求的 chunk。一旦找到，相应 chunk 就会被切分成两块：</li>
<li>User chunk（用户请求大小）—— 返回给用户；</li>
<li>Remainder chunk （剩余大小）—— 添加到 unsorted bin。</li>
<li>如果相应 bin 中的最大 chunk 大小小于用户请求大小，分配器就会扫描 binmaps，从而查找最小非空 bin。如果找到了这样的 - bin，就从中选择合适的 chunk 并切割给用户；反之就使用 top chunk 响应用户请求。</li>
<li>free(large chunk) —— 类似于 small chunk 。</li>
</ul>
<h2 id="Top-Chunk"><a href="#Top-Chunk" class="headerlink" title="Top Chunk"></a>Top Chunk</h2><p>一个 arena 中最顶部的 chunk 被称为「top chunk」。它不属于任何 bin 。当所有 bin 中都没有合适空闲内存时，就会使用 top chunk 来响应用户请求。</p>
<p>当 top chunk 的大小比用户请求的大小大的时候，top chunk 会分割为两个部分：</p>
<ul>
<li>User chunk，返回给用户；</li>
<li>Remainder chunk，剩余部分，将成为新的 top chunk。<br>当 top chunk 的大小比用户请求的大小小的时候，top chunk 就通过 sbrk（main arena）或 mmap（ thread arena）系统调用扩容。</li>
</ul>
<h2 id="Last-Remainder-Chunk"><a href="#Last-Remainder-Chunk" class="headerlink" title="Last Remainder Chunk"></a>Last Remainder Chunk</h2><p>「last remainder chunk」即最后一次 small request 中因分割而得到的剩余部分，它有利于改进引用局部性，也即后续对 small chunk 的 malloc 请求可能最终被分配得彼此靠近。</p>
<p>那么 arena 中的若干 chunks，哪个有资格成为 last remainder chunk 呢？</p>
<p>当用户请求 small chunk 而无法从 small bin 和 unsorted bin 得到服务时，分配器就会通过扫描 binmaps 找到最小非空 bin。正如前文所提及的，如果这样的 bin 找到了，其中最合适的 chunk 就会分割为两部分：返回给用户的 User chunk 、添加到 unsorted bin 中的 Remainder chunk。这一 Remainder chunk 就将成为 last remainder chunk。</p>
<p>那么引用局部性是如何达成的呢？</p>
<p>当用户的后续请求 small chunk，并且 last remainder chunk 是 unsorted bin 中唯一的 chunk，该 last remainder chunk 就将分割成两部分：返回给用户的 User chunk、添加到 unsorted bin 中的 Remainder chunk（也是 last remainder chunk）。因此后续的请求的 chunk 最终将被分配得彼此靠近。</p>
<h1 id="内存管理器ptmalloc"><a href="#内存管理器ptmalloc" class="headerlink" title="内存管理器ptmalloc"></a>内存管理器ptmalloc</h1><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>了解ptmalloc内存管理器，就必须得先了解操作系统的内存布局方式。通过下面这个图，我很很清晰的可以看到堆、栈等的内存分布。</p>
<p>X86平台LINUX进程内存布局：<br><img src="/img/20190411301.png" alt=""></p>
<p>上图就是linux操作系统的内存布局。内存从低到高分别展示了操作系统各个模块的内存分布。</p>
<ul>
<li>Test Segment：存放程序代码，只读，编译的时候确定</li>
<li>Data Segment：存放程序运行的时候就能确定的数据，可读可写</li>
<li>BBS Segment：定义而没有初始化的全局变量和静态变量</li>
<li>Heap：堆。堆的内存地址由低到高。</li>
<li>Mmap：映射区域。</li>
<li>Stack：栈。编译器自动分配和释放。内存地址由高到低</li>
</ul>
<h2 id="ptmalloc内存管理器"><a href="#ptmalloc内存管理器" class="headerlink" title="ptmalloc内存管理器"></a>ptmalloc内存管理器</h2><p>ptmalloc是glibc默认的内存管理器。我们常用的malloc和free就是由ptmalloc内存管理器提供的基础内存分配函数。ptmalloc有点像我们自己写的内存池，当我们通过malloc或者free函数来申请和释放内存的时候，ptmalloc会将这些内存管理起来，并且通过一些策略来判断是否需要回收给操作系统。这样做的最大好处就是：让用户申请内存和释放内存的时候更加高效。</p>
<p>为了内存分配函数malloc的高效性，ptmalloc会预先向操作系统申请一块内存供用户使用，并且ptmalloc会将已经使用的和空闲的内存管理起来；当用户需要销毁内存free的时候，ptmalloc又会将回收的内存管理起来，根据实际情况是否回收给操作系统。</p>
<h2 id="设计假设"><a href="#设计假设" class="headerlink" title="设计假设"></a>设计假设</h2><p>ptmalloc在设计时折中了高效率，高空间利用率，高可用性等设计目标。所以有了下面一些设计上的假设条件：</p>
<ol>
<li>具有长生命周期的大内存分配使用mmap。</li>
<li>特别大的内存分配总是使用mmap。</li>
<li>具有短生命周期的内存分配使用brk。</li>
<li>尽量只缓存临时使用的空闲小内存块，对大内存块或是长生命周期的大内存块在释放时都直接归还给操作系统。</li>
<li>对空闲的小内存块只会在malloc和free的时候进行合并，free时空闲内存块可能放入pool中，不一定归还给操作系统。</li>
<li>收缩堆的条件是当前free的块大小加上前后能合并chunk的大小大于64KB、，并且堆顶的大小达到阈值，才有可能收缩堆，把堆最顶端的空闲内存返回给操作系统。</li>
<li>需要保持长期存储的程序不适合用ptmalloc来管理内存。</li>
<li>不停的内存分配ptmalloc会对内存进行切割和合并，会导致一定的内存碎片</li>
</ol>
<h2 id="主分配区和非主分配区"><a href="#主分配区和非主分配区" class="headerlink" title="主分配区和非主分配区"></a>主分配区和非主分配区</h2><p>ptmalloc的内存分配器中，为了解决多线程锁争夺问题，分为主分配区main_area和非主分配区no_main_area。</p>
<ol>
<li>每个进程有一个主分配区，也可以允许有多个非主分配区。</li>
<li>主分配区可以使用brk和mmap来分配，而非主分配区只能使用mmap来映射内存块</li>
<li>非主分配区的数量一旦增加，则不会减少。</li>
<li>主分配区和非主分配区形成一个环形链表进行管理。</li>
</ol>
<h2 id="chunk-内存块的基本组织单元"><a href="#chunk-内存块的基本组织单元" class="headerlink" title="chunk 内存块的基本组织单元"></a>chunk 内存块的基本组织单元</h2><p>ptmalloc通过chunk的数据结构来组织每个内存单元。当我们使用malloc分配得到一块内存的时候，这块内存就会通过chunk的形式被记录到glibc上并且管理起来。你可以把它想象成自己写内存池的时候的一个内存数据结构。chunk的结构可以分为使用中的chunk和空闲的chunk。使用中的chunk和空闲的chunk数据结构基本项同，但是会有一些设计上的小技巧，巧妙的节省了内存。</p>
<p>使用中的chunk：<br><img src="/img/20190411302.png" alt=""></p>
<ol>
<li>chunk指针指向chunk开始的地址；mem指针指向用户内存块开始的地址。</li>
<li>p=0时，表示前一个chunk为空闲，prev_size才有效</li>
<li>p=1时，表示前一个chunk正在使用，prev_size无效    p主要用于内存块的合并操作</li>
<li>ptmalloc 分配的第一个块总是将p设为1, 以防止程序引用到不存在的区域</li>
<li>M=1 为mmap映射区域分配；M=0为heap区域分配</li>
<li>A=1 为非主分区分配；A=0 为主分区分配</li>
</ol>
<p>空闲的chunk：<br><img src="/img/20190411303.png" alt=""></p>
<ol>
<li>空闲的chunk会被放置到空闲的链表bins上。当用户申请内存malloc的时候，会先去查找空闲链表bins上是否有合适的内存。</li>
<li>fp和bp分别指向前一个和后一个空闲链表上的chunk</li>
<li>fp_nextsize和bp_nextsize分别指向前一个空闲chunk和后一个空闲chunk的大小，主要用于在空闲链表上快速查找合适大小的chunk。</li>
<li>fp、bp、fp_nextsize、bp_nextsize的值都会存在原本的用户区域，这样就不需要专门为每个chunk准备单独的内存存储指针了。</li>
</ol>
<h2 id="空闲链表bins"><a href="#空闲链表bins" class="headerlink" title="空闲链表bins"></a>空闲链表bins</h2><p>当用户使用free函数释放掉的内存，ptmalloc并不会马上交还给操作系统（这边很多时候我们明明执行了free函数，但是进程内存并没有回收就是这个原因），而是被ptmalloc本身的空闲链表bins管理起来了，这样当下次进程需要malloc一块内存的时候，ptmalloc就会从空闲的bins上寻找一块合适大小的内存块分配给用户使用。这样的好处可以避免频繁的系统调用，降低内存分配的开销。<br><img src="/img/20190411304.png" alt=""></p>
<p>ptmalloc一共维护了128bin。每个bins都维护了大小相近的双向链表的chunk。</p>
<p>通过上图这个bins的列表就能看出，当用户调用malloc的时候，能很快找到用户需要分配的内存大小是否在维护的bin上，如果在某一个bin上，就可以通过双向链表去查找合适的chunk内存块给用户使用。</p>
<ol>
<li><p>fast bins。fast bins是bins的高速缓冲区，大约有10个定长队列。当用户释放一块不大于max_fast（默认值64）的chunk（一般小内存）的时候，会默认会被放到fast bins上。当用户下次需要申请内存的时候首先会到fast bins上寻找是否有合适的chunk，然后才会到bins上空闲的chunk。ptmalloc会遍历fast bin，看是否有合适的chunk需要合并到bins上。</p>
</li>
<li><p>unsorted bin。是bins的一个缓冲区。当用户释放的内存大于max_fast或者fast bins合并后的chunk都会进入unsorted bin上。当用户malloc的时候，先会到unsorted bin上查找是否有合适的bin，如果没有合适的bin，ptmalloc会将unsorted bin上的chunk放入bins上，然后到bins上查找合适的空闲chunk。</p>
</li>
<li><p>small bins和large bins。small bins和large bins是真正用来放置chunk双向链表的。每个bin之间相差8个字节，并且通过上面的这个列表，可以快速定位到合适大小的空闲chunk。前64个为small bins，定长；后64个为large bins，非定长。</p>
</li>
<li><p>Top chunk。并不是所有的chunk都会被放到bins上。top chunk相当于分配区的顶部空闲内存，当bins上都不能满足内存分配要求的时候，就会来top chunk上分配。</p>
</li>
<li><p>mmaped chunk。当分配的内存非常大（大于分配阀值，默认128K）的时候，需要被mmap映射，则会放到mmaped chunk上，当释放mmaped chunk上的内存的时候会直接交还给操作系统。</p>
</li>
</ol>
<h2 id="内存分配malloc流程"><a href="#内存分配malloc流程" class="headerlink" title="内存分配malloc流程"></a>内存分配malloc流程</h2><ol>
<li>获取分配区的锁，防止多线程冲突。</li>
<li>计算出需要分配的内存的chunk实际大小。</li>
<li>判断chunk的大小，如果小于max_fast（64b），则取fast bins上去查询是否有适合的chunk，如果有则分配结束。</li>
<li>chunk大小是否小于512B，如果是，则从small bins上去查找chunk，如果有合适的，则分配结束。</li>
<li>继续从 unsorted bins上查找。如果unsorted bins上只有一个chunk并且大于待分配的chunk，则进行切割，并且剩余的chunk继续扔回unsorted bins；如果unsorted bins上有大小和待分配chunk相等的，则返回，并从unsorted bins删除；如果unsorted bins中的某一chunk大小 属于small bins的范围，则放入small bins的头部；如果unsorted bins中的某一chunk大小 属于large bins的范围，则找到合适的位置放入。</li>
<li>从large bins中查找，找到链表头后，反向遍历此链表，直到找到第一个大小 大于待分配的chunk，然后进行切割，如果有余下的，则放入unsorted bin中去，分配则结束。</li>
<li>如果搜索fast bins和bins都没有找到合适的chunk，那么就需要操作top chunk来进行分配了（top chunk相当于分配区的剩余内存空间）。判断top chunk大小是否满足所需chunk的大小，如果是，则从top chunk中分出一块来。</li>
<li>如果top chunk也不能满足需求，则需要扩大top chunk。主分区上，如果分配的内存小于分配阀值（默认128k），则直接使用brk()分配一块内存；如果分配的内存大于分配阀值，则需要mmap来分配；非主分区上，则直接使用mmap来分配一块内存。通过mmap分配的内存，就会放入mmap chunk上，mmap chunk上的内存会直接回收给操作系统。</li>
</ol>
<h2 id="内存释放free流程"><a href="#内存释放free流程" class="headerlink" title="内存释放free流程"></a>内存释放free流程</h2><ol>
<li>获取分配区的锁，保证线程安全。</li>
<li>如果free的是空指针，则返回，什么都不做。</li>
<li>判断当前chunk是否是mmap映射区域映射的内存，如果是，则直接munmap()释放这块内存。前面的已使用chunk的数据结构中，我们可以看到有M来标识是否是mmap映射的内存。</li>
<li>判断chunk是否与top chunk相邻，如果相邻，则直接和top chunk合并（和top chunk相邻相当于和分配区中的空闲内存块相邻）。转到步骤8</li>
<li>如果chunk的大小大于max_fast（64b），则放入unsorted bin，并且检查是否有合并，有合并情况并且和top chunk相邻，则转到步骤8；没有合并情况则free。</li>
<li>如果chunk的大小小于 max_fast（64b），则直接放入fast bin，fast bin并没有改变chunk的状态。没有合并情况，则free；有合并情况，转到步骤7</li>
<li>在fast bin，如果当前chunk的下一个chunk也是空闲的，则将这两个chunk合并，放入unsorted bin上面。合并后的大小如果大于64KB，会触发进行fast bins的合并操作，fast bins中的chunk将被遍历，并与相邻的空闲chunk进行合并，合并后的chunk会被放到unsorted bin中，fast bin会变为空。合并后的chunk和topchunk相邻，则会合并到topchunk中。转到步骤8</li>
<li>判断top chunk的大小是否大于mmap收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还top chunk中的一部分给操作系统。free结束。</li>
</ol>
<h2 id="mallopt-参数调优"><a href="#mallopt-参数调优" class="headerlink" title="mallopt 参数调优"></a>mallopt 参数调优</h2><ol>
<li>M_MXFAST：用于设置fast bins中保存的chunk的最大大小，默认值为64B。最大80B</li>
<li>M_TRIM_THRESHOLD：用于设置mmap收缩阈值，默认值为128KB。</li>
<li>M_MMAP_THRESHOLD：M_MMAP_THRESHOLD用于设置mmap分配阈值，默认值为128KB。当用户需要分配的内存大于mmap分配阈值，ptmalloc的malloc()函数其实相当于mmap()的简单封装，free函数相当于munmap()的简单封装。</li>
<li>M_MMAP_MAX：M_MMAP_MAX用于设置进程中用mmap分配的内存块的地址段数量，默认值为65536</li>
<li>M_TOP_PAD：该参数决定了，当libc内存管理器调用brk释放内存时，堆顶还需要保留的空闲内存数量。该值缺省为 0.</li>
</ol>
<h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><p>为了避免Glibc内存暴增，需要注意：</p>
<ol>
<li>后分配的内存先释放，因为ptmalloc收缩内存是从top chunk开始，如果与top chunk相邻的chunk不能释放，top chunk以下的chunk都无法释放。</li>
<li>Ptmalloc不适合用于管理长生命周期的内存，特别是持续不定期分配和释放长生命周期的内存，这将导致ptmalloc内存暴增。</li>
<li>多线程分阶段执行的程序不适合用ptmalloc，这种程序的内存更适合用内存池管理</li>
<li>尽量减少程序的线程数量和避免频繁分配/释放内存。频繁分配，会导致锁的竞争，最终导致非主分配区增加，内存碎片增高，并且性能降低。</li>
<li>防止内存泄露，ptmalloc对内存泄露是相当敏感的，根据它的内存收缩机制，如果与top chunk相邻的那个chunk没有回收，将导致top chunk一下很多的空闲内存都无法返回给操作系统。</li>
<li>防止程序分配过多内存，或是由于Glibc内存暴增，导致系统内存耗尽，程序因OOM被系统杀掉。预估程序可以使用的最大物理内存大小，配置系统的/proc/sys/vm/overcommit_memory，/proc/sys/vm/overcommit_ratio，以及使用ulimt –v限制程序能使用虚拟内存空间大小，防止程序因OOM被杀掉。</li>
</ol>
<h1 id="TCMalloc内存分配与管理简述"><a href="#TCMalloc内存分配与管理简述" class="headerlink" title="TCMalloc内存分配与管理简述"></a>TCMalloc内存分配与管理简述</h1><p>TCMalloc给每个线程分配了一个线程局部缓存,小对象的分配是直接由线程局部缓存来完成的，这样就避免了多线程程序中的锁竞争情况。当线程局部缓存中的内存不够时，会将对象从中央数据结构移动到线程局部缓存中，同时定期的用垃圾收集器把内存从线程局部缓存迁移回中央数据结构中。</p>
<p>TCMalloc将尺寸小于等于256 * 1024字节的对象（“小”对象）和大对象区分开来。大对象直接使用页级分配器从中央页堆直接分配。即，一个大对象总是页对齐的并占据了整数个数的页。</p>
<h2 id="小对象的分配"><a href="#小对象的分配" class="headerlink" title="小对象的分配"></a>小对象的分配</h2><p>每个小对象的大小都会被映射到与之接近的可分配的class中的一个。例如，所有大小在833到1024字节之间的小对象时，都会归整到1024字节。60个可分配的尺寸类别这样隔开：较小的尺寸相差8字节，较大的尺寸相差16字节，再大一点的尺寸差32字节，如此等等。最大的间隔是控制的，这样刚超过上一个级别被分配到下一个级别就不会有太多的内存被浪费。</p>
<p>一个线程缓存包含了由各个尺寸内存的对象组成的单链表，如图所示：<br><img src="/img/20161022102340793.png" alt=""></p>
<p>当分配一个小对象时：</p>
<ol>
<li>我们将其大小映射到对应的尺寸中。</li>
<li>查找当前线程的线程缓存中相应的尺寸的内存链表。</li>
<li>如果当前尺寸内存链表非空，那么从链表中移除的第一个对象并返回它。</li>
</ol>
<p>当我们按照这种方式分配时，TCMalloc不需要任何锁。这就可以极大提高分配的速度，因为锁/解锁操作在一个2.8GHzXeon上大约需要100纳秒的时间。</p>
<p>如果当前尺寸内存链表为空：</p>
<ol>
<li>从Central Cache中取得一系列这种尺寸的对象（CentralCache是被所有线程共享的）。</li>
<li>将他们放入该线程线程的缓冲区。</li>
<li>返回一个新获取的对象给应用程序。</li>
</ol>
<p>如果CentralCache也为空：</p>
<ol>
<li>我们从中央页堆中分配一系列页面。</li>
<li>将他们分割成该尺寸的一系列对象。</li>
<li>将新分配的对象放入CentralCache的链表上 </li>
<li>像前面一样，将部分对象移入线程局部的链表中。</li>
</ol>
<p>如果中央页堆也为空，那么就从系统中分配一系列的页面(使用sbrk、mmap或者通过在/dev/mem中进行映射)，把页面给中央页堆，然后继续上面的操作</p>
<h2 id="大对象的分配"><a href="#大对象的分配" class="headerlink" title="大对象的分配"></a>大对象的分配</h2><p>一个大对象的尺寸会被中央页堆直接处理，被圆整到一个页面尺寸（4K）。中央页堆是由空闲内存列表组成的数组。对于i &lt; 256而言，数组的第k个元素是一个由每个单元是由k个页面组成的空闲内存链表。第256个条目则是一个包含了长度&gt;= 256个页面的空闲内存链表：<br><img src="/img/20161022102359935.png" alt=""></p>
<p>k个页面的一次分配通过在第k个空闲内存链表中查找来完成。如果该空闲内存链表为空，那么我们则在下一个空闲内存链表中查找，如此继续。最终，如果必要的话，我们将在最后空闲内存链表中查找。如果这个动作也失败了，我们将向系统获取内存（使用sbrk、mmap或者通过在/dev/mem中进行映射）</p>
<p>如果k个页面的分配是由连续的&gt; k个页面的空闲内存链表完成的，剩下的连续页面将被重新插回到与之页面大小接近的空闲内存链表中去。</p>
<h1 id="TCMalloc的内存分配的主要层次"><a href="#TCMalloc的内存分配的主要层次" class="headerlink" title="TCMalloc的内存分配的主要层次"></a>TCMalloc的内存分配的主要层次</h1><h2 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h2><p>线程局部分配，ThreadCache包含了一个不同对象大小的空闲链表数组，其实现采用操作系统的线程局部存储功能。分配时几乎不需要用锁，除非触发CentralCache的操作。</p>
<p>ThreadCache中的重要数据结构:<br><img src="/img/20161022102859452.png" alt=""></p>
<ul>
<li><code>pthread_t     tid_;</code>   绑定线程，达到每个线程有个缓冲池的目的</li>
<li><code>FreeList      list_[kNumClasses];</code>  这个数组就是上图中的第一列，如下图</li>
</ul>
<p><img src="/img/20161022102915426.png" alt=""><br>数组中的每一个节点就是代表上图中的每一行，如下图</p>
<p><img src="/img/20161022103100584.png" alt=""></p>
<p>每个class对应多大的内存空间?这个表示每组的大小的变量在哪里？</p>
<p>不存在这样的变量，但是通过映射关系可以达到一个class管一类size的作用，</p>
<p>如下图所示，由<code>cl</code>得到<code>list_[cl]</code>，这也即是一个class。<br><img src="/img/20161022103142257.png" alt=""></p>
<p>至于<code>cl</code>，是由<code>class_array_</code>得到的。</p>
<p>若申请的内存是13字节，但分配的却是15字节，那么便会有2个字节的内存碎片（内部碎片）。</p>
<h2 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h2><p>中心分配，Centralcache</p>
<p>该层的分配需要锁。<code>CentralCache</code>和<code>ThreadCache</code>之间的空闲链表是一一对应的，以子链表为单位（<code>obj</code>个数很可能为<code>num_objects_to_move</code>（<code>cl</code>），见do_malloc与do_free流程图）进行互相交换。</p>
<p><code>CentralCache</code>的内存从<code>PageHeap</code>里获得。从<code>PageHeap</code>获得的内存叫<code>Span</code>。一个<code>Span</code>在使用时只能用于同一大小的空闲链表，一但<code>CentralCache</code>从<code>PageHeap</code>中获取新的<code>Span</code>，这个<code>Span</code>就是一个串好的相同大小内存的空闲链表。</p>
<p><code>Centralcache</code>中有几个重要数据结构:</p>
<ul>
<li><code>TCEntry  tc_slots_[kMaxNumTransferEntries];</code><ul>
<li><code>tc_slots_</code>每个节点存放的是一组<code>obj</code>链表，这一组<code>obj</code>的个数为<code>num_objects_to_move</code>，TCEntry结构体有两指针，分别指向这个链表的头和尾。</li>
<li><code>tc_slots_</code>存放的是<code>threadCache</code>向<code>CentralCache</code>归还的<code>obj</code>链表，并且只有当个数满足<code>num_objects_to_move</code>时，才会放入<code>tc_slots_</code>。否则归还的<code>obj</code>根据其所处的<code>span</code>，进行归还，若对应的<code>span</code>是<code>empty</code>，那么由于此时被归还内存了，所以其有空闲<code>obj</code>了，便把该<code>span</code>从<code>empty</code>队列清除，把其加入<code>nonempty</code>队列。</li>
</ul>
</li>
<li><code>span empty</code><ul>
<li><code>FetchFromSpans</code>函数把一个<code>obj</code>从<code>nonempty</code>队列中的一个<code>span</code>中切出，准备给<code>threadCache</code>。当切完这个<code>obj</code>后，如果该<code>span</code>已经没有内存空间了，那么便把该<code>span</code>从<code>nonempty</code>队列移除，并加入<code>empty</code>队列。</li>
</ul>
</li>
<li><code>span nonempty</code><ul>
<li><code>CentralCache</code>从中央页堆申请页面，中央页堆以<code>span</code>的形式返回。在<code>CentralCache</code>中会把该<code>span</code>切成大小为<code>class_to_size</code>的<code>obj</code>，并把所有的<code>obj</code>链接起来，链表头为<code>span-&gt;objects</code>。再把该链表加入<code>nonempty</code>队列。</li>
<li><code>nonempty</code>队列另外一个被加入<code>span</code>的地方在内存从<code>threadCache</code>归还给<code>CentralCache</code>时，具体情况见上面<code>tc_slots_</code>这一数据结构的描述。</li>
</ul>
</li>
</ul>
<h2 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h2><p>中央页堆，PageHeap</p>
<p>PageHeap以一定数量连续页面内存的形式提供内存。这组连续的页面由一个Span对象描述，Span对象和它描述的页面内存是独立的。Span对象保存了页面的id序列，页面id左移一个page就是内存的地址。由于页面和Span内存独立，需要用page id反向映射查找Span对象就需要单独的映射表。这个表用radix tree实现，兼顾效率和内存。PageHeap还负责合并和拆分相邻的Span。</p>
<p>PageHeap重要数据结构:</p>
<ul>
<li><code>SpanList   large_;</code></li>
<li><code>SpanList   free_[kMaxPages];</code></li>
</ul>
<p>中央页堆是由空闲内存列表组成的数组。对于i&lt; 256而言，数组的第k个元素是一个由每个单元是由k个页面组成的空闲内存链表(这也即是free_)。第256个条目（这即是large_）则是一个包含了长度&gt;= 256个页面的空闲内存链表：<br><img src="/img/20161022103757266.png" alt=""></p>
<p>而<code>SpanList</code>为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpanList</span> &#123;</span></span><br><span class="line">    Span       normal;</span><br><span class="line">    Span       returned;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>Returned</code>代表的是已经归还给系统的<code>span</code></p>
<h2 id="第四层"><a href="#第四层" class="headerlink" title="第四层"></a>第四层</h2><p>系统页面分配，这就是调用系统函数了。</p>
<h1 id="内存在各层之间的传递"><a href="#内存在各层之间的传递" class="headerlink" title="内存在各层之间的传递"></a>内存在各层之间的传递</h1><h2 id="ThreadCache与CentralCache内存传递"><a href="#ThreadCache与CentralCache内存传递" class="headerlink" title="ThreadCache与CentralCache内存传递"></a>ThreadCache与CentralCache内存传递</h2><ol>
<li><code>ThreadCache</code>内存不够时，要从<code>CentralCache</code>拿（<code>RemoveRange</code>），再把拿到的内存加入<code>ThreadCache</code>的<code>list_[cl]</code>链表队列。（PushRange）</li>
<li><code>ThreadCache</code>从<code>CentralCache</code>拿或者返还给<code>CentralCache</code>的内存，是一种什么逻辑?</li>
</ol>
<p>当拿内存时，如果申请的内存大小是0.23kb，先是找到<code>ThreadCache</code>中对应给0.23kb的内存组的大小是多少，这里假设是0.3kb。然后根据<code>num_objects_to_move(0.3)</code>函数获得每次应该传递的obj的个数。<code>ThreadCache</code>还内存给<code>CentralCache</code>（<code>ReleaseToCentralCache</code>），一次也是还<code>num_objects_to_move(0.3)</code>个，把该<code>obj</code>全部放到<code>tc_slots</code>，但如果实在是不满足该条件，就把内存还给<code>Span</code>（<code>ReleaseListToSpans</code>）。</p>
<p>正常情况肯定是申请<code>num_objects_to_move(cl)</code>个<code>obj</code>，除非<code>FreeList</code>本身能容纳的<code>obj</code>个数不够<code>num_objects_to_move(cl)</code>。</p>
<p>当要归还的<code>obj</code>个数大于<code>num_objects_to_move(cl)</code>时，一次还<code>Static::sizemap()-&gt;num_objects_to_move(cl)</code>个<code>obj</code>，归还给<code>tc_slots_</code>数组。最后多余的不够<code>num_objects_to_move(cl)</code>个<code>obj</code>通过<code>ReleaseListToSpans</code>函数归还。</p>
<h2 id="CentralCache与中央页堆的内存传递"><a href="#CentralCache与中央页堆的内存传递" class="headerlink" title="CentralCache与中央页堆的内存传递"></a>CentralCache与中央页堆的内存传递</h2><p><code>FetchFromSpansSafe()</code>首先会调用<code>FetchFromSpans</code>（从<code>Span</code>中切一个<code>obj</code>对应的内存片），当<code>FetchFromSpans</code>调用失败，也即<code>nonempty</code>队列中对应的<code>span</code>连一个<code>obj</code>的内存都切不出来时，便会调用<code>populate</code>函数从中央页堆中获取内存。倘若<code>FetchFromSpansSafe</code>中的<code>FetchFromSpans</code>能切除一个<code>obj</code>，就不从中央页堆申请内存，<code>RemoveRange</code>函数后续继续用<code>FetchFromSpans</code>切另外<code>N-1</code>个<code>obj</code>，倘若此时<code>nonempty</code>中内存只够<code>m</code>个<code>obj</code>的(<code>m&lt;N-1</code>)，那么此时就返回<code>m</code>个<code>obj</code>给<code>ThreadCache</code>。</p>
<p>中央页堆每次传递给<code>CentralCache</code>的内存也是固定的，每次传递<code>class_to_pages(size_class_)</code>个页面。这<code>n</code>个页面就是一个<code>Span</code>，该<code>span</code>会被切成<code>obj</code>链接起来，然后把该<code>Span</code>插入<code>CentralCache</code>的<code>nonempty</code>中。</p>
<p>从中央页堆拿<code>class_to_pages(size_class_)</code>个页面利用的是<code>New</code>函数，该函数首先是在中央页堆的<code>free_</code>或者<code>large_</code>队列中拿内存，如果这两都不符合条件，那么就要从系统内存拿啦(GrowHeap)</p>
<h2 id="中央页堆与系统内存的内存传递"><a href="#中央页堆与系统内存的内存传递" class="headerlink" title="中央页堆与系统内存的内存传递"></a>中央页堆与系统内存的内存传递</h2><p>系统内存每次传递给中央页堆的页面数，与<code>populate</code>函数中传进来的页面数<code>n</code>以及系统参数<code>kMinSystemAlloc</code>有关，如下面的语句:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Length ask =(n&gt;kMinSystemAlloc) ? n : static_cast&lt;Length&gt;(kMinSystemAlloc)  (GrowHeap函数里)</span><br></pre></td></tr></table></figure></p>
<p><code>GrowHeap</code>中利用<code>TCMalloc_SystemAlloc</code>向系统申请内存(其底层会调用<code>mmap</code>或者是<code>sbrk</code>)。把系统分配来的内存弄成<code>Span</code>，把生成的<code>Span</code>的信息记录进<code>radix tree</code>，日后通过页面ID便可通过get函数查找到其对应的<code>Span</code>对象，再通过<code>Delete</code>函数把新生成的<code>Span</code>加入中央页堆的<code>free_</code>或者<code>large_</code>的<code>normal</code>或者<code>returned</code>队列（在Delete函数里面，会合并相邻的Span）</p>
<h1 id="TCMalloc中涉及到的几个重要的数据结构"><a href="#TCMalloc中涉及到的几个重要的数据结构" class="headerlink" title="TCMalloc中涉及到的几个重要的数据结构"></a>TCMalloc中涉及到的几个重要的数据结构</h1><p>在<code>initStaticVars()</code>里面首先会调用<code>SizeMap.init</code>。<code>SizeMap</code>是一个非常关键的数据结构，<code>SizeMap</code>里面涉及到几个关键的数据结构<code>class_array_</code>，<code>class_to_size_</code>，<code>class_to_pages_</code>，<code>num_objects_to_move_</code>。</p>
<p>其中<code>class_array</code>将一个<code>size</code>映射成为一个<code>class num</code>，被映射的<code>class num</code>一共有<code>kNumClasses</code>个<code>num</code>，而<code>class_to_size_</code>，<code>class_to_pages_</code>，<code>num_objects_to_move_</code>这三个数组都是拥有<code>kNumClasses</code>个<code>num</code>的数组。所以根据<code>class_array</code>映射得到的<code>class num</code>，也即另外3个数组的索引号，就可以使用另外3个数组。</p>
<p>根据这个索引号可以从<code>class_to_size</code>数组中得到基于这个索引(也即最开始的<code>size</code>)的可分配<code>obj</code>的最大<code>size</code>，假设这个大小的<code>size</code>叫做<code>Asize</code>；</p>
<p>可以从<code>num_objects_to_move</code>数组中得到基于这个索引(也即最开始的<code>size</code>)的在<code>ThreadCache</code>和<code>CentralCache</code>之间移动的<code>obj</code>的数量，该<code>obj</code>的大小就是<code>Asize</code>。</p>
<p>可以从<code>class_to_pages_</code>数组中得到基于这个索引(也即最开始的<code>size</code>)的在<code>CentralCache</code>和中央页堆之间移动的页面数量。</p>
<p><code>class_to_size</code>数组，<code>num_objects_to_move</code>数组，<code>class_to_pages_</code>数组均是在<code>SizeMap::Init()</code>函数中被初始化。<code>class_to_size_</code>数组最终会被初始化为8,16,32,48(16递增，直到128字节)，128字节后，是另外一直形式的递增，一直到<code>kMaxSize</code>。到了<code>kMaxSize</code>后，又换一种形式的递增</p>
<h1 id="TCMalloc中内存分配流程"><a href="#TCMalloc中内存分配流程" class="headerlink" title="TCMalloc中内存分配流程"></a>TCMalloc中内存分配流程</h1><p><img src="/img/20161022104539161.png" alt=""></p>
<p>内存分配流程图如上图,具体流程如下：</p>
<p>1、<code>Tcmalloc</code>首先判断<code>malloc</code>的<code>size</code>是否大于<code>kMaxSize</code>，如果小于这个值，那么将<code>size</code>转换为想的<code>obj class</code>，然后从当前<code>thread</code>私有的<code>cache</code>中<code>Allocate</code>，转至第2步。如果请求的<code>size</code>大于<code>kMaxSize</code>那么跳至第10。</p>
<p>2、首先判断当前的<code>threadcache</code>中<code>obj calss</code>对应的<code>freelist</code>中是否包含有空闲的<code>obj</code>，如果有直接<code>pop</code>出来，否则从<code>CentralCache</code>中拿，转下一步。</p>
<p>3、<code>CentralCache</code>和<code>ThreadCache</code>之间<code>obj</code>的转移采用<code>batch</code>方式，每次转移固定数量的<code>obj</code>，这个数量通过<code>Static::sizemap()-&gt;num_objects_to_move</code>定义，当然在决定最终转移数量时还是需要不能超过<code>ThreadCache</code>相应<code>list</code>的<code>maxlength</code>。然后通过<code>CentralCache</code>对应<code>freelist</code>的<code>RemoveRange</code>函数将确定大小的<code>obj</code>转移出来，并通过对应<code>list</code>的<code>PushRange</code>函数将这些<code>obj</code>插入<code>ThreadCache</code>对应的<code>freelist</code>。</p>
<p>4、<code>CentralCache</code>通过<code>RemoveRange</code>将特定数量的<code>obj</code>移出，<code>CentralCache</code>将连续的内存看做一个<code>Span</code>，<code>Span</code>是<code>CentralCache</code>管理内存的一个主要数据结构。而<code>Span</code>又被切分成<code>N</code>个统一大小的<code>obj</code>。</p>
<p>5、在<code>Allocate</code>的过程中，首先判断需要<code>Allocate</code>的<code>obj</code>数量是不是正好符合<code>num_objects_to_move</code>，如果是而且<code>CentralCache</code>用来存放<code>span</code>的<code>slots</code>不为空，那么直接从<code>slots</code>里面拿，否则从<code>nonempty</code>队列中的<code>Span</code>拿。</p>
<p>6、<code>Nonempty</code>队列存放了所有可用的<code>Span</code>，那么从头开始一个个拿，如果拿光了还是不能满足要求，那么只能通过向<code>pageheap</code>要求一个<code>span</code>，这个<code>span</code>的<code>size</code>由<code>class_to_pages</code>决定，然后再将这个<code>Span</code>切成<code>obj</code>返回给<code>CentralCache</code>。然后再次尝试从<code>Span</code>分配。</p>
<p>7、<code>Pageheap</code>管理整个系统<code>page</code>级别的<code>allocate</code>，他通过两个数据结构管理所有的<code>Span</code>（<code>free_</code>数组和<code>large_</code>列表），<code>free_</code>数组存放<code>size</code>小于<code>kMaxPages</code>的<code>Span</code>，而<code>large_</code>列表存放大于等于<code>kMaxPages</code>的<code>Span</code>。<code>PageHeap</code>首先判断要求的<code>pages</code>是否大于等于<code>kMaxPages</code>，如果小于那么先从<code>free</code>数组中找，从要求大小的位置开始往后找，先找<code>normal</code>队列再找<code>return</code>对队列。如果在<code>normal</code>队列中找到且找到的<code>Span</code>状态为<code>Span::ON_NORMAL_FREELIST</code>，那么直接从里面切出需要的<code>Span</code>返回给<code>CentralCache</code>。如果在<code>return</code>队列中找到且找到的<code>Span</code>状态为<code>Span::ON_RETURNED_FREELIST</code>那么直接从里面切出需要的<code>Span</code>返回给<code>CentralCache</code>。</p>
<p>8、如果需要的<code>size</code>不符合上述要求或者在上述队列中没有找到那么将从<code>large_</code>队列中找。从<code>large_</code>队列中查找时，首先从<code>normal</code>队列入手，然后再从<code>return</code>队列找，他将找到<code>size</code>最符合且地址在空闲<code>Span</code>中最小的<code>Span</code>，然后切出来返回。</p>
<p>9、如果<code>large_</code>队列中都没有找到合适的<code>Span</code>，那么将通过<code>GrowHeap</code>增长<code>Heap</code>的方式，通过<code>TCMalloc_SystemAlloc</code>向系统申请内存。并包装成<code>Span</code>，并插入<code>heap</code>中，然后再次进行分配。</p>
<p>10、来到此处代表分配的内存是大于32k的，那么将向<code>heap</code>直接请求跳到第7步。</p>
<h1 id="TCMalloc中内存释放流程"><a href="#TCMalloc中内存释放流程" class="headerlink" title="TCMalloc中内存释放流程"></a>TCMalloc中内存释放流程</h1><p><img src="/img/20161022104819952.png" alt=""></p>
<h1 id="一些未解决的问题"><a href="#一些未解决的问题" class="headerlink" title="一些未解决的问题"></a>一些未解决的问题</h1><h2 id="线程缓冲区的大小的确定"><a href="#线程缓冲区的大小的确定" class="headerlink" title="线程缓冲区的大小的确定"></a>线程缓冲区的大小的确定</h2><p>Tcmallloc官方文档上说线程缓冲区的大小是慢启动的，在源码中找到了它的慢启动代码，但是还没有研究明白这个慢启动到底是一个什么逻辑。</p>
<p>程序里有三处地方与该缓冲区大小确定有关，三处地方分别是FetchFromCentralCache，ListTooLong以及Scavenge。具体怎么确定的还没有研究，先做个备忘录而已。</p>
<p>恰当线程缓冲区大小至关重要，如果缓冲区太小，我们需要经常去CentralHeap分配；如果线程缓冲区太大，又致使大量对象闲置而浪费内存。</p>
<p>注意到恰当的线程缓冲区的大小对内存的释放一样重要。如果没有线程缓冲，每次内存释放都需要把内存移回到Central Heap。同样，一些线程有不对称的内存分配和释放行为（例如：生产者和消费者线程），所以确定恰当的缓冲区大小也很棘手。</p>
<p>确定缓冲区大小，我们采用“慢开始”算法来确定每一个尺寸内存链表的最大长度。当某个链表使用更频繁，我们就扩大他的长度。如果我们某个链表上释放的操作比分配操作更多，它的最大长度将被增长到整个链表可以一次性有效的移动到Central Heap的长度。</p>
<p>下面的伪代码说明了这种慢开始算法。注意到<code>num_objects_to_move</code>对每一个尺寸是不同的。通过移动特定长度的对象链表，中央缓冲可以高效的将链表在线程中传递。如果线程缓冲区的需要小于<code>num_objects_to_move</code>，在中央缓冲区上的这种操作具有线性的时间复杂度。使用<code>num_objects_to_move</code>作为从中央缓冲区传递的对象数量的缺点是，它将不需要的那部分对象浪费在线程缓冲区。</p>
<p><img src="/img/20161022111651504.png" alt=""></p>
<h1 id="TCMalloc与APR，ptmalloc的分析比较"><a href="#TCMalloc与APR，ptmalloc的分析比较" class="headerlink" title="TCMalloc与APR，ptmalloc的分析比较"></a>TCMalloc与APR，ptmalloc的分析比较</h1><h2 id="tcmalloc与APR，ptmalloc的不同点"><a href="#tcmalloc与APR，ptmalloc的不同点" class="headerlink" title="tcmalloc与APR，ptmalloc的不同点"></a>tcmalloc与APR，ptmalloc的不同点</h2><p>tcmalloc与APR初始化时都不会预先分配内存。但是tcmalloc申请一个小对象后(最开始时的申请，此时threadCache，CentralCache等结构中还没内存)，便会向系统申请几个页面的内存，中央页堆，CentralCache，threadCache会分别标记属于他们的内存。然后再从threadCache中分配一个obj给申请者。 </p>
<p>而APR不一样，申请者申请内存(最开始时的申请)， 新分配的内存并不挂接到内存分配器链表中，而是在调用allocator_free进行内存释放的时候，内存才可能挂到内存分配器链表上。新分配的内存在内存池节点的active链表中。</p>
<p>这也即是APR的一大缺点:apr_pool的一个大缺点就是从池中申请的内存不能归还给内存池，只能等pool销毁的时候才能归还。为了弥补这个缺点，apr_pool的实际使用中，可以申请拥有不同生命周期的内存池。</p>
<p>Ptmalloc：在使用malloc之前，heap大小为0.若请求空间小于mmap分配阈值，主分配区会调用sbrk()增加一块大小为(128kb+chunk_size)align4KB的空间作为heap。非主分配区会调用一块大小为HEAP_MAX_SIZE(32位系统上默认为1M，64位系统上默认为64M)的空间作为sub_heap（3.2.3.4小节）,这就是ptmalloc维护的分配空间。</p>
<p>当用户释放了heap中的chunk时，ptmalloc又会使用fastbins和bins来组织空闲chunk，以备下一次分配。</p>
<p>所以三者对内存的维护处理各不相同，初始化时三者都不会预分配空间。但一旦有了malloc，tcmalloc与ptmalloc便会预先分配一块大内存加入内存池(应该可以称为内存池吧)，tcmalloc把内存分到各级，但是ptmalloc只是放在heap中。</p>
<p>tcmalloc应该是只有一个内存池的概念，而APR则是多内存池概念。</p>
<h2 id="各内存池的优缺点"><a href="#各内存池的优缺点" class="headerlink" title="各内存池的优缺点"></a>各内存池的优缺点</h2><p>Ptmalloc缺点:</p>
<ol>
<li>多线程由于锁冲突，所以慢</li>
<li>容易造成内存暴增:因为ptmalloc的内存收缩是从topchunk开始，如果与topchunk相邻的那个chunk没有被释放，topchunk以下的空闲内存都无法返回给系统，即是这些空闲内存有几十个G也不行。（ptmalloc文档第4节）</li>
<li>容易造成内存碎片(ptmalloc文档第4节第5点)，ptmalloc就不会存在这种大块内存碎片的问题，由于其内存管理机制。不过ptmalloc也会引起小的内存碎片，比如我申请的是13字节，对应的size是15字节，那么便会有2个自己的内存碎片。不过</li>
</ol>
<p>APR缺点：APR从系统申请来的内存先是放在内存池节点的active链表中链起来，并不会加入内存分配器的free链表数组。所以当内存中一直是在malloc，但是却没有free时，active链表链接了大量内存，而free链表数组一直没值，这样容易把系统内存耗尽</p>
<p>APR优点：可以建立子内存池，这样建立不同周期的内存池。  比如连接内存池与请求内存池</p>
<p>看这些个分配器的分配机制，可见这些内存管理机制都是针对小内存分配和管理。对大块内存还是直接用了系统调用。所以在程序中应该尽量避免大内存的malloc/new、free/delete操作。另外这个分配器的最小粒度都是以8字节为单位的，所以频繁分配小内存，像int啊bool啊什么的，仍然会浪费空间。经过测试无论是对bool、int、short进行new的时候，实际消耗的内存在ptmalloc和tcmalloc下64位系统地址间距都是32个字节。大量new测试的时候，ptmalloc平均每次new消耗32字节，tcmalloc消耗8字节（我想说ptmalloc弱爆啦，而且tcmalloc）。所以大量使用这些数据的时候不妨用数组自己维护一个内存池，可以减少很多的内存浪费。（原来STL的map和set一个节点要消耗近80个字节有这么多浪费在这里了啊）</p>
<p>而多线程下对于比较大的数据结构，为了减少分配时的锁争用，最好是自己维护内存池。单线程的话无所谓了，呵呵。不过自己维护内存池是增加代码复杂度，减少 内存管理复杂度。但是我觉得，255个分页以下（1MB）的内存话，tcmalloc的分配和管理机制已经相当nice，没太大必要自己另写一个。</p>
<h1 id="内存池的一个实践"><a href="#内存池的一个实践" class="headerlink" title="内存池的一个实践"></a>内存池的一个实践</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>首先，我们介绍下什么是内存池？</p>
<p>❝预先在内存中申请一定数量的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存返回，在释放的时候，将内存返回给内存池而不是OS，在下次申请的时候，重新进行分配❞</p>
<p>那么为什么要有内存池呢？这就需要从传统内存分配的特点来进行分析，传统内存分配释放的优点无非就是通用性强，应用广泛，但是传统的内存分配、释放在某些特定的项目中，其不一定是最优、效率最高的方案。</p>
<p>传统内存分配、释放的缺点总结如下：</p>
<ol>
<li>调用malloc/new,系统需要根据“最先匹配”、“最优匹配”或其他算法在内存空闲块表中查找一块空闲内存，调用free/delete,系统可能需要合并空闲内存块，这些会产生额外开销</li>
<li>频繁的在堆上申请和释放内存必然需要大量时间，降低了程序的运行效率。对于一个需要频繁申请和释放内存的程序来说，频繁调用new/malloc申请内存，delete/free释放内存都需要花费系统时间，频繁的调用必然会降低程序的运行效率。</li>
<li>经常申请小块内存，会将物理内存“切”得很碎，导致内存碎片。申请内存的顺序并不是释放内存的顺序，因此频繁申请小块内存必然会导致内存碎片，造成“有内存但是申请不到大块内存”的现象。</li>
</ol>
<p><img src="/img/20211220142105.jpg" alt=""></p>
<p>从上图中，可以看出，应用程序会调用glibc运行时库的malloc函数进行内存申请，而malloc函数则会根据具体申请的内存块大小，根据实际情况最终从sys_brk或者sys_mmap_pgoff系统调用申请内存，而大家都知道，跟os打交道，_性能损失_是毋庸置疑的。</p>
<p>其次，glibc作为通用的运行时库，malloc/free需要满足各种场景需求，比如申请的字节大小不一，多线程访问等。有没有比传统malloc/free性能更优的方案呢？答案是：有。</p>
<p>在程序启动的时候，我们预分配特定数量的固定大小的块，这样每次申请的时候，就从预分配的块中获取，释放的时候，将其放入预分配块中以备下次复用，这就是所谓的_内存池技术_，每个内存池对应特定场景，这样的话，较传统的传统的malloc/free少了很多复杂逻辑，性能显然会提升不少。结合传统malloc/free的缺点，我们总结下使用内存池方案的优点：</p>
<ol>
<li>比malloc/free进行内存申请/释放的方式快</li>
<li>不会产生或很少产生堆碎片</li>
<li>可避免内存泄漏</li>
</ol>
<p>根据分配出去的字节大小是否固定，分为固定大小内存池和可变大小内存池两类。而可变大小内存池，可分配任意大小的内存池，比如ptmalloc、jemalloc以及google的tcmalloc。固定大小内存池，顾名思义，每次申请和释放的内存大小都是固定的。每次分配出去的内存块大小都是程序预先定义的值，而在释放内存块时候，则简单的挂回内存池链表即可。</p>
<h1 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h1><p>内存池，重点在”池“字上，之所以称之为内存池，是在真正使用之前，先预分配一定数量、大小预设的块，如果有新的内存需求时候，就从内存池中根据申请的内存大小，分配一个内存块，若当前内存块已经被完全分配出去，则继续申请一大块，然后进行分配。</p>
<p>当进行内存块释放的时候，则将其归还内存池，后面如果再有申请的话，则将其重新分配出去。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>创建并初始化头结点MemoryPool</li>
<li>通过MemoryPool进行内存分配，如果发现MemoryPool所指向的第一块MemoryBlock或者现有MemoryPool没有空闲内存块，则创建一个新的MemoryBlock初始化之后将其插入MemoryPool的头</li>
<li>在内存分配的时候，遍历MemoryPool中的单链表MemoryBlock，根据地址判断所要释放的内存属于哪个MemoryBlock，然后根据偏移设置MemoryBlock的第一块空闲块索引，同时将空闲块个数+1</li>
</ul>
<p>上述只是一个简单的逻辑讲解，比较宏观，下面我们将通过图解和代码的方式来进行讲解。</p>
<p><img src="/img/20211220142323.jpg" alt=""><br>在上图中，我们画出了内存池的结构图，从图中，可以看出，有两个结构变量，分别为MemoryPool和MemoryBlock。</p>
<p>下面我们将从数据结构和接口两个部分出发，详细讲解内存池的设计。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="MemoryBlock"><a href="#MemoryBlock" class="headerlink" title="MemoryBlock"></a>MemoryBlock</h3><p>本文中所讲述的内存块的分配和释放都是通过该结构进行操作，下面是MemoryBlock的示例图：<br><img src="/img/20211220142350.jpg" alt=""></p>
<p>在上图中，Header存储该MemoryBlock的内存块情况，比如可用的内存块索引、当前MemoryBlock中可用内存块的个数等等。</p>
<p>定义如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryBlock</span> &#123;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> free_size;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> first_free;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">MemoryBlock</span> *<span class="title">next</span>;</span></span><br><span class="line"> <span class="type">char</span> a_data[<span class="number">0</span>]; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li><code>size</code>为MemoryBlock下内存块的个数</li>
<li><code>free_size</code>为MemoryBlock下空闲内存块的个数</li>
<li><code>first_free</code>为MemoryBlock中第一个空闲块的索引</li>
<li><code>next</code>指向下一个MemoryBlock</li>
<li><code>a_data</code>是一个柔性数组</li>
</ul>
<p>柔性数组即数组大小待定的数组， C语言中结构体的最后一个元素可以是大小未知的数组，也就是所谓的0长度，所以我们可以用结构体来创建柔性数组。它的主要用途是为了满足需要变长度的结构体，为了解决使用数组时内存的冗余和数组的越界问题。</p>
<h3 id="MemoryPool"><a href="#MemoryPool" class="headerlink" title="MemoryPool"></a>MemoryPool</h3><p>MemoryPool为内存池的头，里面定义了该内存池的信息，比如本内存池分配的固定对象的大小，第一个MemoryBlock等<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryPool</span> &#123;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> obj_size;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> init_size;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> grow_size;</span><br><span class="line"></span><br><span class="line"> MemoryBlock *first_block;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>obj_size为内存池分配的固定内存块的大小</li>
<li>init_size初始化内存池时候创建的内存块的个数</li>
<li>grow_size当初始化内存块使用完后，再次申请内存块时候的个数</li>
<li>first_block指向第一个MemoryBlock</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>memory_pool_create<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MemoryPool *<span class="title function_">memory_pool_create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> init_size, </span></span><br><span class="line"><span class="params">                               <span class="type">unsigned</span> <span class="type">int</span> grow_size, </span></span><br><span class="line"><span class="params">                               <span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure></p>
<p>本函数用来创建一个MemoryPool，并对其进行初始化，下面是参数说明：</p>
<ul>
<li>init_size 表示第一个MemoryBlock中创建块的个数</li>
<li>grow_size 表示当MemoryPool中没有空闲块可用，则创建一个新的MemoryBlock时其块的个数</li>
<li>size 为块的大小(即每次分配相同大小的固定size)</li>
</ul>
<h3 id="memory-alloc"><a href="#memory-alloc" class="headerlink" title="memory_alloc"></a>memory_alloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memory_alloc</span><span class="params">(MemoryPool *mp)</span>;</span><br></pre></td></tr></table></figure>
<p>本函数用了从mp中申请一块内存返回</p>
<ul>
<li>mp 为MemoryPool类型指针，即内存池的头</li>
<li>如果内存分配失败，则返回NULL</li>
</ul>
<h3 id="memory-free"><a href="#memory-free" class="headerlink" title="memory_free"></a>memory_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memory_free</span><span class="params">(MemoryPool *mp, <span class="type">void</span> *pfree)</span>;</span><br></pre></td></tr></table></figure>
<p>本函数用来释放内存</p>
<ul>
<li>mp 为MemoryPool类型指针，即内存池的头</li>
<li>pfree 为要释放的内存</li>
</ul>
<h3 id="free-memory-pool"><a href="#free-memory-pool" class="headerlink" title="free_memory_pool"></a>free_memory_pool</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_memory_pool</span><span class="params">(MemoryPool *mp)</span>;</span><br></pre></td></tr></table></figure>
<p>本函数用来释放内存池</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在讲解整个实现之前，我们先看先内存池的详细结构图。<br><img src="/img/20211220142552.jpg" alt=""></p>
<h3 id="初始化内存池"><a href="#初始化内存池" class="headerlink" title="初始化内存池"></a>初始化内存池</h3><p>MemoryPool是整个内存池的入口结构，该函数主要是用来创建MemoryPool对象，并使用参数对其内部的成员变量进行初始化。</p>
<p>函数定义如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MemoryPool *<span class="title">memory_pool_create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> init_size, <span class="type">unsigned</span> <span class="type">int</span> grow_size, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MemoryPool *mp;</span><br><span class="line">    mp = (MemoryPool*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(MemoryPool));</span><br><span class="line">    mp-&gt;first_block = <span class="literal">NULL</span>;</span><br><span class="line">    mp-&gt;init_size = init_size;</span><br><span class="line">    mp-&gt;grow_size = grow_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>))</span><br><span class="line">        mp-&gt;obj_size = <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    mp-&gt;obj_size = (size + (MEMPOOL_ALIGNMENT<span class="number">-1</span>)) &amp; ~(MEMPOOL_ALIGNMENT<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memory_alloc</span><span class="params">(MemoryPool *mp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mp-&gt;first_block == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        MemoryBlock *mb;</span><br><span class="line">        length = (mp-&gt;init_size)*(mp-&gt;obj_size) + <span class="built_in">sizeof</span>(MemoryBlock);</span><br><span class="line">        mb = <span class="built_in">malloc</span>(length);</span><br><span class="line">        <span class="keyword">if</span>(mb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;memory allocate failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* init the first block */</span></span><br><span class="line">        mb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        mb-&gt;free_size = mp-&gt;init_size - <span class="number">1</span>;</span><br><span class="line">        mb-&gt;first_free = <span class="number">1</span>;</span><br><span class="line">        mb-&gt;size = mp-&gt;init_size*mp-&gt;obj_size;</span><br><span class="line"></span><br><span class="line">        mp-&gt;first_block = mb;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> *data = mb-&gt;a_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set the mark */</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;mp-&gt;init_size; ++i) &#123;</span><br><span class="line">            *(<span class="type">unsigned</span> <span class="type">long</span> *)data = i;</span><br><span class="line">            data += mp-&gt;obj_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)mb-&gt;a_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MemoryBlock *pm_block = mp-&gt;first_block;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pm_block != <span class="literal">NULL</span>) &amp;&amp; (pm_block-&gt;free_size == <span class="number">0</span>)) &#123;</span><br><span class="line">        pm_block = pm_block-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pm_block != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *pfree = pm_block-&gt;a_data + pm_block-&gt;first_free * mp-&gt;obj_size;</span><br><span class="line"></span><br><span class="line">        pm_block-&gt;first_free = *((<span class="type">unsigned</span> <span class="type">long</span> *)pfree);</span><br><span class="line">        pm_block-&gt;free_size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)pfree;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp-&gt;grow_size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        MemoryBlock *new_block = (MemoryBlock *)<span class="built_in">malloc</span>((mp-&gt;grow_size)*(mp-&gt;obj_size) + <span class="built_in">sizeof</span>(MemoryBlock));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(new_block == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *data = new_block-&gt;a_data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;mp-&gt;grow_size; ++i) &#123;</span><br><span class="line">            *(<span class="type">unsigned</span> <span class="type">long</span> *)data = i;</span><br><span class="line">            data += mp-&gt;obj_size;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        new_block-&gt;size = mp-&gt;grow_size*mp-&gt;obj_size;</span><br><span class="line">        new_block-&gt;free_size = mp-&gt;grow_size<span class="number">-1</span>;</span><br><span class="line">        new_block-&gt;first_free = <span class="number">1</span>;</span><br><span class="line">        new_block-&gt;next = mp-&gt;first_block;</span><br><span class="line">        mp-&gt;first_block = new_block;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)new_block-&gt;a_data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存块主要在MemoryBlock结构中，也就是说申请的内存，都是从MemoryBlock中进行获取，流程如下：</p>
<ul>
<li>获取MemoryPool中的first_block指针</li>
<li>如果该指针为空，则创建一个MemoryBlock，first_block指向新建的MemoryBlock，并返回</li>
<li>否则，从first_block进行单链表遍历，查找第一个free_size不为0的MemoryBlock，如果找到，则对该MemoryBlock的相关参数进行设置，然后返回内存块</li>
<li>否则，创建一个新的MemoryBlock，进行初始化分配之后，将其插入到链表的头部(这样做的目的是为了方便下次分配效率，即减小了链表的遍历)</li>
</ul>
<p>在上述代码中，需要注意的是第30-33行或者67-70行，这两行的功能一样，都是对新申请的内存块进行初始化，这几行的意思，是要将空闲块连接起来，但是，并没有使用传统意义上的链表方式，而是通过index方式进行连接，具体如下图所示：</p>
<p><img src="/img/20211220142913.jpg" alt=""></p>
<p>在上图中，第0块空闲块的下一个空闲块索引为1，而第1块空闲块的索引为2，依次类推，形成了如下链表方式</p>
<p>1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>内存分配流程图如下所示：</p>
<p><img src="/img/20211220142950.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memory_free</span><span class="params">(MemoryPool *mp, <span class="type">void</span> *pfree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp-&gt;first_block == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MemoryBlock *pm_block = mp-&gt;first_block;</span><br><span class="line">    MemoryBlock *pm_pre_block = mp-&gt;first_block;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* research the MemoryBlock which the pfree in */</span></span><br><span class="line">    <span class="keyword">while</span>(pm_block &amp;&amp; ((<span class="type">unsigned</span> <span class="type">long</span>)pfree &lt; (<span class="type">unsigned</span> <span class="type">long</span>)pm_block-&gt;a_data || </span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">long</span>)pfree&gt;((<span class="type">unsigned</span> <span class="type">long</span>)pm_block-&gt;a_data+pm_block-&gt;size))) &#123;</span><br><span class="line">        <span class="comment">//pm_pre_block = pm_block;</span></span><br><span class="line">        pm_block = pm_block-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pm_block == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pfree;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = pfree -(<span class="type">void</span>*) pm_block-&gt;a_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((offset&amp;(mp-&gt;obj_size <span class="number">-1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pfree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm_block-&gt;free_size++;</span><br><span class="line">    *((<span class="type">unsigned</span> <span class="type">int</span> *)pfree) = pm_block-&gt;first_free;</span><br><span class="line"></span><br><span class="line">    pm_block-&gt;first_free=(<span class="type">unsigned</span> <span class="type">int</span>)(offset/mp-&gt;obj_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存释放过程如下：</p>
<ul>
<li>判断当前MemoryPool的first_block指针是否为空，如果为空，则返回</li>
<li>否则，遍历MemoryBlock链表，根据所释放的指针参数判断是否在某一个MemoryBlock中</li>
<li>如果找到，则对MemoryBlock中的各个参数进行操作，然后返回</li>
<li>否则，没有合适的MemoryBlock，则表明该被释放的指针不在内存池中，返回</li>
</ul>
<p>在上述代码中，需要注意第20-29行。</p>
<ul>
<li>第20行，求出被释放的内存块在MemoryBlock中的偏移</li>
<li>第22行，判断是否能被整除，即是否在这个内存块中，算是个double check</li>
<li>第26行，将该MemoryBlock中的空闲块个数加1</li>
<li>第27-29行，类似于链表的插入，将新释放的内存块的索引放入链表头，而其内部的指向下一个可用内存块</li>
</ul>
<p>现在举个例子，以便于理解，假设在一开始有5个空闲块，其中前三个空闲块都分配出去了，那么此时，空闲块链表如下:</p>
<p>4-&gt;5，其中first_free = 4</p>
<p>然后在某一个时刻，第1块释放了，那么释放归还之后，如下:</p>
<p>1-&gt;4-&gt;5，其中first_free = 1</p>
<p>内存释放流程图如下：</p>
<p><img src="/img/20211220143104.jpg" alt=""></p>
<h2 id="释放内存池"><a href="#释放内存池" class="headerlink" title="释放内存池"></a>释放内存池</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">free_memory_pool</span><span class="params">(MemoryPool *mp)</span> </span>&#123;</span><br><span class="line">    MemoryBlock *mb = mp-&gt;first_block;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(mb-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s_memory_block *delete_block = mb;</span><br><span class="line">            mb = mb-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">free</span>(delete_block);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(mb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20211220144136.jpg" alt=""></p>
<p>上图是一个完整的分配和释放示意图，下面，我结合代码来分析：</p>
<ul>
<li>(a)步，创建了一个MemoryPool结构体<ul>
<li>obj_size = 4代表本内存池分配的内存块大小为4</li>
<li>init_size = 5代表创建内存池的时候，第一块MemoryBlock的空闲内存块个数为5</li>
<li>grow_size = 5代表当申请内存的时候，如果没有空闲内存，则创建的新的MemoryBlock的空闲内存块个数为5</li>
</ul>
</li>
<li>(b)步，分配出去一块内存<ul>
<li>此时，free_size即该MemoryBlock中可用空闲块个数为4</li>
<li>first_free = 1，代表将内存块分配出去之后，下一个可用的内存块的index为1</li>
</ul>
</li>
<li>(c)步，分配出去一块内存<ul>
<li>此时，free_size即该MemoryBlock中可用空闲块个数为3</li>
<li>first_free = 2，代表将内存块分配出去之后，下一个可用的内存块的index为2</li>
</ul>
</li>
<li>(d)步，分配出去一块内存<ul>
<li>此时，free_size即该MemoryBlock中可用空闲块个数为2</li>
<li>first_free = 3，代表将内存块分配出去之后，下一个可用的内存块的index为3</li>
</ul>
</li>
<li>(e)步，分配出去一块内存<ul>
<li>此时，free_size即该MemoryBlock中可用空闲块个数为1</li>
<li>first_free = 4，代表将内存块分配出去之后，下一个可用的内存块的index为4</li>
</ul>
</li>
<li>(f)步，释放第1个内存块<ul>
<li>将free_size进行+1操作</li>
<li>fire_free值为此次释放的内存块的索引，而释放的内存块的索引里面的值则为之前first_free的值(此处释放用的前差法)</li>
</ul>
</li>
<li>(g)步，释放第3个内存块<ul>
<li>将free_size进行+1操作</li>
<li>fire_free值为此次释放的内存块的索引，而释放的内存块的索引里面的值则为之前first_free的值(此处释放用的前差法)</li>
</ul>
</li>
<li>(h)步，释放第3个内存块<ul>
<li>将free_size进行+1操作</li>
<li>fire_free值为此次释放的内存块的索引，而释放的内存块的索引里面的值则为之前first_free的值(此处释放用的前差法)</li>
</ul>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memory_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MemoryPool *mp = <span class="built_in">memory_pool_create</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> start;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t[] = &#123;<span class="number">20000</span>, <span class="number">40000</span>, <span class="number">80000</span>, <span class="number">100000</span>, <span class="number">120000</span>, <span class="number">140000</span>, <span class="number">160000</span>, <span class="number">180000</span>, <span class="number">200000</span>&#125;;</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">sizeof</span>(t)/<span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t[i]; ++j) &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="type">void</span> *p = <span class="built_in">memory_alloc</span>(mp);</span><br><span class="line">            <span class="built_in">memory_free</span>(mp, p);</span><br><span class="line">            <span class="comment">//void *p = malloc(8);</span></span><br><span class="line">            <span class="comment">//free(p);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">long</span> cost = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) +</span><br><span class="line">                      end.tv_usec - start.tv_usec;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,cost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free_memory_pool</span>(mp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据对比如下：<br><img src="/img/20211220144402.jpg" alt=""></p>
<p>从上图可以看出，pool的分配效率高于传统的malloc方式，性能提高接近100%</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在文章前面，我们有提过本内存池是<strong>单线程、固定大小的</strong>，但是往往这种还是不能满足要求，如下几个场景</p>
<ul>
<li>单线程多固定大小</li>
<li>多线程固定大小</li>
<li>多线程多固定大小</li>
</ul>
<p>多固定大小，指的是提前预支需要申请的内存大小。</p>
<p>单线程多固定大小: 针对此场景，由于已经预知了所申请的size，所以可以针对每个size创建一个内存池。</p>
<p>多线程固定大小：针对此场景，有以下两个方案</p>
<ul>
<li>使用ThreadLocalCache</li>
<li>每个线程创建一个内存池</li>
<li>使用加锁，操作全局唯一内存池(每次加锁解锁耗时100ns左右)</li>
</ul>
<p>多线程多固定大小：针对此场景，可以结合上述两个方案，即</p>
<ul>
<li>使用ThreadCache，每个线程内创建多固定大小的内存池</li>
<li>每个线程内创建一个多固定大小的内存池</li>
<li>使用加锁，操作全局唯一内存池(每次加锁解锁耗时100ns左右)</li>
</ul>
<p>上述几种方案，仅仅是在使用固定大小内存池基础上进行的扩展，具体的方案，需要根据具体情况来具体分析</p>
<h1 id="malloc-函数详解"><a href="#malloc-函数详解" class="headerlink" title="malloc 函数详解"></a>malloc 函数详解</h1><p>原文：<a href="https://www.cnblogs.com/Commence/p/5785912.html">https://www.cnblogs.com/Commence/p/5785912.html</a></p>
<p>malloc只是C标准库中提供的一个普通函数</p>
<p>而且很多很多人都对malloc的具体实现机制不是很了解。</p>
<ol>
<li>关于malloc以及相关的几个函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;(Linux下)</span><br><span class="line"></span><br><span class="line">void *malloc(size_t size);</span><br><span class="line">void free(void *ptr);</span><br><span class="line">void *calloc(size_t nmemb, size_t size);</span><br><span class="line">void *realloc(void *ptr, size_t size);</span><br></pre></td></tr></table></figure>
也可以这样认为（window下）原型：extern void *malloc(unsigned int num_bytes);<br>头文件：#include <malloc.h>或者#include <alloc.h>两者的内容是完全一样的。</li>
</ol>
<p>如果分配成功：则返回指向被分配内存空间的指针，不然，返回空指针NULL。当内存不再使用的时候，应使用free（）函数将内存块释放掉。void <em>,表示未确定类型的指针。C，C++规定，void </em>类型可以强转为任何其他类型的的指针。</p>
<p>malloc returns a void pointer to the allocated space, or NULL if there is insufficient memory available. To return a pointer to a type other than void, use a type cast on the return value. The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. If size is 0, malloc allocates a zero-length item in the heap and returns a valid pointer to that item. Always check the return from malloc, even if the amount of memory requested is small.</p>
<p>关于void *的其他说法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void * p1;</span><br><span class="line">int *p2;</span><br><span class="line">p1 = p2;</span><br></pre></td></tr></table></figure><br>就是说其他任意类型都可以直接赋值给它，无需进行强转，但是反过来不可以。</p>
<p>malloc：</p>
<ul>
<li>malloc分配的内存大小至少为size参数所指定的字节数</li>
<li>malloc的返回值是一个指针，指向一段可用内存的起始地址</li>
<li>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</li>
<li>malloc应该尽快完成内存分配并返回（不能使用NP-hard的内存分配算法）</li>
<li>实现malloc时应同时实现内存大小调整和内存释放函数（realloc和free）</li>
</ul>
<p>malloc和free函数是配对的，如果申请后不释放就是内存泄露;如果无故释放那就是什么都没有做，释放只能释放一次，如果释放两次及两次以上会出现错误（但是释放空指针例外，释放空指针其实也等于什么都没有做，所以，释放多少次都是可以的）</p>
<ol>
<li>malloc和new </li>
</ol>
<p>new返回指定类型的指针，并且可以自动计算所需要的大小。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">p = new int;   //返回类型为int *类型，分配的大小为sizeof(int)</span><br><span class="line">p = new int[100];    //返回类型为int *类型，分配的大小为sizeof(int) * 100</span><br></pre></td></tr></table></figure></p>
<p>而malloc则必须由我们计算字节数，并且在返回的时候强转成实际指定类型的指针。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">p = (int *)malloc(sizeof(int));</span><br></pre></td></tr></table></figure></p>
<ol>
<li>malloc的返回是void <em>,如果我们写成了: p = malloc(sizeof(int));间接的说明了（将void </em>转化给了int *,这不合理）</li>
<li>malloc的实参是sizeof(int),用于指明一个整形数据需要的大小，如果我们写成：<code>p =  （int *）malloc(1)</code>,那么可以看出：只是申请了一个字节的空间，如果向里面存放了一个整数的话，将会占用额外的3个字节，可能会改变原有内存空间中的数据；</li>
<li>malloc只管分配内存，并不能对其进行初始化，所以得到的一片新内存中，其值将是随机的。一般意义上：我们习惯性的将其初始化为NULL。当然,也可以用memset函数的。</li>
</ol>
<p>简单的说：</p>
<p>malloc 函数其实就是在内存中：找一片指定大小的空间，然后将这个空间的首地址给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址， 这要看malloc函数中参数size的具体内容。我们这里malloc分配的内存空间在逻辑上是连续的，而在物理上可以不连续。我们作为程序员，关注的 是逻辑上的连续，其它的，操作系统会帮着我们处理的。</p>
<p>下面我们聊聊malloc的具体实现机制：</p>
<h1 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h1><h2 id="虚拟内存地址与物理内存地址"><a href="#虚拟内存地址与物理内存地址" class="headerlink" title="虚拟内存地址与物理内存地址"></a>虚拟内存地址与物理内存地址</h2><p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时， 都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片2N字节的内存，其中N是机器位数。例如在64位CPU和64位操作系统下，每个进程的 虚拟地址空间为264Byte。</p>
<p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p>
<p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫MMU（Memory Management Unit）的硬件完成。</p>
<h2 id="页与地址构成"><a href="#页与地址构成" class="headerlink" title="页与地址构成"></a>页与地址构成</h2><p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p>
<p>所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：<br><img src="/img/051536255466644.png" alt=""></p>
<p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内便宜都是用低12位表示，而剩下的高地址表示页号。</p>
<p>MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构页表来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如TLB等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。<br><img src="/img/051536281096429.png" alt=""></p>
<h2 id="内存页与磁盘页"><a href="#内存页与磁盘页" class="headerlink" title="内存页与磁盘页"></a>内存页与磁盘页</h2><p>我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异 常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现 是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。<br>附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程。<br><img src="/img/051536262965015.png" alt=""></p>
<h1 id="Linux进程级内存管理"><a href="#Linux进程级内存管理" class="headerlink" title="Linux进程级内存管理"></a>Linux进程级内存管理</h1><h2 id="内存排布"><a href="#内存排布" class="headerlink" title="内存排布"></a>内存排布</h2><p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p>
<p>以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p>
<p>根据Linux内核相关文档描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：<br><img src="/img/051536255788401.png" alt=""></p>
<p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p>
<ul>
<li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li>
<li>Data：这里存放的是初始化过的全局变量</li>
<li>BSS：这里存放的是未初始化的全局变量</li>
<li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li>
<li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li>
<li>Stack：这是栈区域，自高地址向低地址增长</li>
</ul>
<h2 id="Heap内存模型"><a href="#Heap内存模型" class="headerlink" title="Heap内存模型"></a>Heap内存模型</h2><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p>
<p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：<br><img src="/img/051536261875516.png" alt=""></p>
<p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p>
<h2 id="brk与sbrk"><a href="#brk与sbrk" class="headerlink" title="brk与sbrk"></a>brk与sbrk</h2><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int brk(void *addr);</span><br><span class="line">void *sbrk(intptr_t increment);</span><br></pre></td></tr></table></figure></p>
<p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk 在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p>
<p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p>
<p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最 后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有 一小块可用内存地址）。</p>
<h2 id="资源限制与rlimit"><a href="#资源限制与rlimit" class="headerlink" title="资源限制与rlimit"></a>资源限制与rlimit</h2><p>　　系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    struct rlimit *limit = (struct rlimit *)malloc(sizeof(struct rlimit));</span><br><span class="line">    getrlimit(RLIMIT_AS, limit);</span><br><span class="line">    printf(&quot;soft limit: %ld, hard limit: %ld\n&quot;, limit-&gt;rlim_cur, limit-&gt;rlim_max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中rlimit是一个结构体：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct rlimit &#123;</span><br><span class="line">rlim_t rlim_cur; /* Soft limit */</span><br><span class="line">rlim_t rlim_max; /* Hard limit (ceiling for rlim_cur) */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p>
<h1 id="实现malloc"><a href="#实现malloc" class="headerlink" title="实现malloc"></a>实现malloc</h1><h2 id="玩具实现"><a href="#玩具实现" class="headerlink" title="玩具实现"></a>玩具实现</h2><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 一个玩具malloc */</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *malloc(size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    void *p;</span><br><span class="line">    p = sbrk(0);</span><br><span class="line">    if (sbrk(size) == (void *)-1)</span><br><span class="line">        return NULL;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p>
<h2 id="正式实现"><a href="#正式实现" class="headerlink" title="正式实现"></a>正式实现</h2><p>下面严肃点讨论malloc的实现方案。</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和 数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为 malloc返回的地址。</p>
<p>可以用如下结构体定义一个block：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct s_block *t_block;</span><br><span class="line">struct s_block &#123;</span><br><span class="line">    size_t size; /* 数据区大小 */</span><br><span class="line">    t_block next; /* 指向下个块的指针 */</span><br><span class="line">    int free; /* 是否是空闲块 */</span><br><span class="line">    int padding; /* 填充4字节，保证meta块长度为8的倍数 */</span><br><span class="line">    char data[1] /* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>　　由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：<br><img src="/img/051536258592317.png" alt=""></p>
<h3 id="寻找合适的block"><a href="#寻找合适的block" class="headerlink" title="寻找合适的block"></a>寻找合适的block</h3><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p>
<p>First fit：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块<br>Best fit：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块<br>　　两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* First fit */</span><br><span class="line">t_block find_block(t_block *last, size_t size) &#123;</span><br><span class="line">t_block b = first_block;</span><br><span class="line">while(b &amp;&amp; !(b-&gt;free &amp;&amp; b-&gt;size &gt;= size)) &#123;</span><br><span class="line">    *last = b;</span><br><span class="line">    b = b-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到 这返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新 block使用的，具体会在接下来的一节用到。</p>
<h3 id="开辟新的block"><a href="#开辟新的block" class="headerlink" title="开辟新的block"></a>开辟新的block</h3><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define BLOCK_SIZE 24 /* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */</span><br><span class="line"> </span><br><span class="line">t_block extend_heap(t_block last, size_t s) &#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    b = sbrk(0);</span><br><span class="line">    if(sbrk(BLOCK_SIZE + s) == (void *)-1)</span><br><span class="line">        return NULL;  </span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = NULL;</span><br><span class="line">    if(last)</span><br><span class="line">        last-&gt;next = b;</span><br><span class="line">    b-&gt;free = 0;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="分裂block"><a href="#分裂block" class="headerlink" title="分裂block"></a>分裂block</h3><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：<br><img src="/img/051536268121159.png" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void split_block(t_block b, size_t s) &#123;</span><br><span class="line">    t_block new;</span><br><span class="line">    new = b-&gt;data + s;</span><br><span class="line">    new-&gt;size = b-&gt;size - s - BLOCK_SIZE ;</span><br><span class="line">    new-&gt;next = b-&gt;next;</span><br><span class="line">    new-&gt;free = 1;</span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="malloc的实现"><a href="#malloc的实现" class="headerlink" title="malloc的实现"></a>malloc的实现</h3><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p>
<p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">size_t align8(size_t s) &#123;</span><br><span class="line">    if(s &amp; 0x7 == 0)</span><br><span class="line">        return s;</span><br><span class="line">    return ((s &gt;&gt; 3) + 1) &lt;&lt; 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define BLOCK_SIZE 24</span><br><span class="line">void *first_block=NULL;</span><br><span class="line"> </span><br><span class="line">/* other functions... */</span><br><span class="line"> </span><br><span class="line">void *malloc(size_t size) &#123;</span><br><span class="line">    t_block b, last;</span><br><span class="line">    size_t s;</span><br><span class="line">    /* 对齐地址 */</span><br><span class="line">    s = align8(size);</span><br><span class="line">    if(first_block) &#123;</span><br><span class="line">        /* 查找合适的block */</span><br><span class="line">        last = first_block;</span><br><span class="line">        b = find_block(&amp;last, s);</span><br><span class="line">    if(b) &#123;</span><br><span class="line">        /* 如果可以，则分裂 */</span><br><span class="line">        if ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + 8))</span><br><span class="line">            split_block(b, s);</span><br><span class="line">        b-&gt;free = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* 没有合适的block，开辟一个新的 */</span><br><span class="line">        b = extend_heap(last, s);</span><br><span class="line">        if(!b)</span><br><span class="line">            return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        b = extend_heap(NULL, s);</span><br><span class="line">        if(!b)</span><br><span class="line">            return NULL;</span><br><span class="line">        first_block = b;</span><br><span class="line">    &#125;</span><br><span class="line">    return b-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="calloc的实现"><a href="#calloc的实现" class="headerlink" title="calloc的实现"></a>calloc的实现</h3><p>有了malloc，实现calloc只要两步：</p>
<ol>
<li>malloc一段内存</li>
<li><p>将数据区内容置为0<br>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void *calloc(size_t number, size_t size) &#123;</span><br><span class="line">    size_t *new;</span><br><span class="line">    size_t s8, i;</span><br><span class="line">    new = malloc(number * size);</span><br><span class="line">    if(new) &#123;</span><br><span class="line">        s8 = align8(number * size) &gt;&gt; 3;</span><br><span class="line">        for(i = 0; i &lt; s8; i++)</span><br><span class="line">        new[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="free的实现"><a href="#free的实现" class="headerlink" title="free的实现"></a>free的实现</h3><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p>
</li>
<li><p>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</p>
</li>
<li>如何解决碎片问题<br>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</li>
</ol>
<ul>
<li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li>
<li>这个地址确实是之前通过我们自己的malloc分配的</li>
</ul>
<p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p>
<p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct s_block *t_block;</span><br><span class="line">struct s_block &#123;</span><br><span class="line">    size_t size; /* 数据区大小 */</span><br><span class="line">    t_block next; /* 指向下个块的指针 */</span><br><span class="line">    int free; /* 是否是空闲块 */</span><br><span class="line">    int padding; /* 填充4字节，保证meta块长度为8的倍数 */</span><br><span class="line">    void *ptr; /* Magic pointer，指向data */</span><br><span class="line">    char data[1] /* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后我们定义检查地址合法性的函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t_block get_block(void *p) &#123;</span><br><span class="line">    char *tmp;</span><br><span class="line">    tmp = p;</span><br><span class="line">    return (p = tmp -= BLOCK_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int valid_addr(void *p) &#123;</span><br><span class="line">    if(first_block) &#123;</span><br><span class="line">        if(p &gt; first_block &amp;&amp; p &lt; sbrk(0)) &#123;</span><br><span class="line">            return p == (get_block(p))-&gt;ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p>
<p>　　一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct s_block *t_block;</span><br><span class="line">struct s_block &#123;</span><br><span class="line">    size_t size; /* 数据区大小 */</span><br><span class="line">    t_block prev; /* 指向上个块的指针 */</span><br><span class="line">    t_block next; /* 指向下个块的指针 */</span><br><span class="line">    int free; /* 是否是空闲块 */</span><br><span class="line">    int padding; /* 填充4字节，保证meta块长度为8的倍数 */</span><br><span class="line">    void *ptr; /* Magic pointer，指向data */</span><br><span class="line">    char data[1] /* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>合并方法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t_block fusion(t_block b) &#123;</span><br><span class="line">    if (b-&gt;next &amp;&amp; b-&gt;next-&gt;free) &#123;</span><br><span class="line">        b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size;</span><br><span class="line">        b-&gt;next = b-&gt;next-&gt;next;</span><br><span class="line">        if(b-&gt;next)</span><br><span class="line">            b-&gt;next-&gt;prev = b;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block 的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前 block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void free(void *p) &#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    if(valid_addr(p)) &#123;</span><br><span class="line">        b = get_block(p);</span><br><span class="line">        b-&gt;free = 1;</span><br><span class="line">        if(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;free)</span><br><span class="line">            b = fusion(b-&gt;prev);</span><br><span class="line">        if(b-&gt;next)</span><br><span class="line">            fusion(b);</span><br><span class="line">        else &#123;</span><br><span class="line">            if(b-&gt;prev)</span><br><span class="line">                b-&gt;prev-&gt;prev = NULL;</span><br><span class="line">            else</span><br><span class="line">                first_block = NULL;</span><br><span class="line">            brk(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="realloc的实现"><a href="#realloc的实现" class="headerlink" title="realloc的实现"></a>realloc的实现</h3><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void copy_block(t_block src, t_block dst) &#123;</span><br><span class="line">    size_t *sdata, *ddata;</span><br><span class="line">    size_t i;</span><br><span class="line">    sdata = src-&gt;ptr;</span><br><span class="line">    ddata = dst-&gt;ptr;</span><br><span class="line">    for(i = 0; (i * 8) &lt; src-&gt;size &amp;&amp; (i * 8) &lt; dst-&gt;size; i++)</span><br><span class="line">        ddata[i] = sdata[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p>
<ul>
<li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li>
<li>如果新的size变小了，考虑split</li>
<li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li>
</ul>
<p>下面是realloc的实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void *realloc(void *p, size_t size) &#123;</span><br><span class="line">    size_t s;</span><br><span class="line">    t_block b, new;</span><br><span class="line">    void *newp;</span><br><span class="line">    if (!p)</span><br><span class="line">        /* 根据标准库文档，当p传入NULL时，相当于调用malloc */</span><br><span class="line">        return malloc(size);</span><br><span class="line">    if(valid_addr(p)) &#123;</span><br><span class="line">        s = align8(size);</span><br><span class="line">        b = get_block(p);</span><br><span class="line">        if(b-&gt;size &gt;= s) &#123;</span><br><span class="line">            if(b-&gt;size - s &gt;= (BLOCK_SIZE + 8))</span><br><span class="line">                split_block(b,s);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* 看是否可进行合并 */</span><br><span class="line">            if(b-&gt;next &amp;&amp; b-&gt;next-&gt;free</span><br><span class="line">            &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) &#123;</span><br><span class="line">                fusion(b);</span><br><span class="line">                if(b-&gt;size - s &gt;= (BLOCK_SIZE + 8))</span><br><span class="line">                    split_block(b, s);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* 新malloc */</span><br><span class="line">                newp = malloc (s);</span><br><span class="line">                if (!newp)</span><br><span class="line">                    return NULL;</span><br><span class="line">                new = get_block(newp);</span><br><span class="line">                copy_block(b, new);</span><br><span class="line">                free(p);</span><br><span class="line">                return(newp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (p);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="遗留问题和优化"><a href="#遗留问题和优化" class="headerlink" title="遗留问题和优化"></a>遗留问题和优化</h2><p>以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p>
<ul>
<li>同时兼容32位和64位系统</li>
<li>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效</li>
<li>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度</li>
<li>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/04/19/Linux%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/" rel="prev" title="Linux系统相关">
      <i class="fa fa-chevron-left"></i> Linux系统相关
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/04/26/Leetcode901_1000/" rel="next" title="Leetcode901 - 1000">
      Leetcode901 - 1000 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%B3%E8%AF%B7%E5%A0%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">申请堆的系统调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81"><span class="nav-number">3.</span> <span class="nav-text">多线程支持</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">3.1.</span> <span class="nav-text">案例代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E8%BE%93%E5%87%BA"><span class="nav-number">3.2.</span> <span class="nav-text">案例输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B-malloc-%E4%B9%8B%E5%89%8D"><span class="nav-number">3.2.1.</span> <span class="nav-text">在主线程 malloc 之前</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B-malloc-%E4%B9%8B%E5%90%8E"><span class="nav-number">3.2.2.</span> <span class="nav-text">在主线程 malloc 之后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B-free-%E4%B9%8B%E5%90%8E"><span class="nav-number">3.2.3.</span> <span class="nav-text">在主线程 free 之后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-thread1-malloc-%E4%B9%8B%E5%89%8D"><span class="nav-number">3.2.4.</span> <span class="nav-text">在 thread1 malloc 之前</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-thread1-malloc-%E4%B9%8B%E5%90%8E"><span class="nav-number">3.2.5.</span> <span class="nav-text">在 thread1 malloc 之后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-thread1-free-%E4%B9%8B%E5%90%8E"><span class="nav-number">3.2.6.</span> <span class="nav-text">在 thread1 free 之后</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Arena"><span class="nav-number">4.</span> <span class="nav-text">Arena</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Arena-%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">4.1.</span> <span class="nav-text">Arena 的数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Multiple-Arena"><span class="nav-number">4.2.</span> <span class="nav-text">Multiple Arena</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Multiple-Heaps"><span class="nav-number">4.3.</span> <span class="nav-text">Multiple Heaps</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chunk"><span class="nav-number">5.</span> <span class="nav-text">Chunk</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Allocated-chunk"><span class="nav-number">5.1.</span> <span class="nav-text">Allocated chunk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Free-chunk"><span class="nav-number">5.2.</span> <span class="nav-text">Free chunk</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bins"><span class="nav-number">6.</span> <span class="nav-text">Bins</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Fast-Bin"><span class="nav-number">6.1.</span> <span class="nav-text">Fast Bin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsorted-Bin"><span class="nav-number">6.2.</span> <span class="nav-text">Unsorted Bin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Small-Bin"><span class="nav-number">6.3.</span> <span class="nav-text">Small Bin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Large-Bin"><span class="nav-number">6.4.</span> <span class="nav-text">Large Bin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Top-Chunk"><span class="nav-number">6.5.</span> <span class="nav-text">Top Chunk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Last-Remainder-Chunk"><span class="nav-number">6.6.</span> <span class="nav-text">Last Remainder Chunk</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8ptmalloc"><span class="nav-number">7.</span> <span class="nav-text">内存管理器ptmalloc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">7.1.</span> <span class="nav-text">内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ptmalloc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">7.2.</span> <span class="nav-text">ptmalloc内存管理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%81%87%E8%AE%BE"><span class="nav-number">7.3.</span> <span class="nav-text">设计假设</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%88%86%E9%85%8D%E5%8C%BA%E5%92%8C%E9%9D%9E%E4%B8%BB%E5%88%86%E9%85%8D%E5%8C%BA"><span class="nav-number">7.4.</span> <span class="nav-text">主分配区和非主分配区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chunk-%E5%86%85%E5%AD%98%E5%9D%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E7%BB%87%E5%8D%95%E5%85%83"><span class="nav-number">7.5.</span> <span class="nav-text">chunk 内存块的基本组织单元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8bins"><span class="nav-number">7.6.</span> <span class="nav-text">空闲链表bins</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Dmalloc%E6%B5%81%E7%A8%8B"><span class="nav-number">7.7.</span> <span class="nav-text">内存分配malloc流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BEfree%E6%B5%81%E7%A8%8B"><span class="nav-number">7.8.</span> <span class="nav-text">内存释放free流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mallopt-%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="nav-number">7.9.</span> <span class="nav-text">mallopt 参数调优</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">7.10.</span> <span class="nav-text">使用注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCMalloc%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E7%AE%A1%E7%90%86%E7%AE%80%E8%BF%B0"><span class="nav-number">8.</span> <span class="nav-text">TCMalloc内存分配与管理简述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">8.1.</span> <span class="nav-text">小对象的分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">8.2.</span> <span class="nav-text">大对象的分配</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCMalloc%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B1%82%E6%AC%A1"><span class="nav-number">9.</span> <span class="nav-text">TCMalloc的内存分配的主要层次</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E5%B1%82"><span class="nav-number">9.1.</span> <span class="nav-text">第一层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%B1%82"><span class="nav-number">9.2.</span> <span class="nav-text">第二层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%B1%82"><span class="nav-number">9.3.</span> <span class="nav-text">第三层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%B1%82"><span class="nav-number">9.4.</span> <span class="nav-text">第四层</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92"><span class="nav-number">10.</span> <span class="nav-text">内存在各层之间的传递</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadCache%E4%B8%8ECentralCache%E5%86%85%E5%AD%98%E4%BC%A0%E9%80%92"><span class="nav-number">10.1.</span> <span class="nav-text">ThreadCache与CentralCache内存传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CentralCache%E4%B8%8E%E4%B8%AD%E5%A4%AE%E9%A1%B5%E5%A0%86%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%A0%E9%80%92"><span class="nav-number">10.2.</span> <span class="nav-text">CentralCache与中央页堆的内存传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E5%A4%AE%E9%A1%B5%E5%A0%86%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%A0%E9%80%92"><span class="nav-number">10.3.</span> <span class="nav-text">中央页堆与系统内存的内存传递</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCMalloc%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">11.</span> <span class="nav-text">TCMalloc中涉及到的几个重要的数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCMalloc%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="nav-number">12.</span> <span class="nav-text">TCMalloc中内存分配流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCMalloc%E4%B8%AD%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E6%B5%81%E7%A8%8B"><span class="nav-number">13.</span> <span class="nav-text">TCMalloc中内存释放流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%9C%AA%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">14.</span> <span class="nav-text">一些未解决的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="nav-number">14.1.</span> <span class="nav-text">线程缓冲区的大小的确定</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCMalloc%E4%B8%8EAPR%EF%BC%8Cptmalloc%E7%9A%84%E5%88%86%E6%9E%90%E6%AF%94%E8%BE%83"><span class="nav-number">15.</span> <span class="nav-text">TCMalloc与APR，ptmalloc的分析比较</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcmalloc%E4%B8%8EAPR%EF%BC%8Cptmalloc%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="nav-number">15.1.</span> <span class="nav-text">tcmalloc与APR，ptmalloc的不同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%84%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">15.2.</span> <span class="nav-text">各内存池的优缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E8%B7%B5"><span class="nav-number">16.</span> <span class="nav-text">内存池的一个实践</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">17.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="nav-number">18.</span> <span class="nav-text">内存池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">18.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">18.2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MemoryBlock"><span class="nav-number">18.2.1.</span> <span class="nav-text">MemoryBlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MemoryPool"><span class="nav-number">18.2.2.</span> <span class="nav-text">MemoryPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">18.2.3.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memory-alloc"><span class="nav-number">18.2.4.</span> <span class="nav-text">memory_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memory-free"><span class="nav-number">18.2.5.</span> <span class="nav-text">memory_free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-memory-pool"><span class="nav-number">18.2.6.</span> <span class="nav-text">free_memory_pool</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">18.3.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%AD%98%E6%B1%A0"><span class="nav-number">18.3.1.</span> <span class="nav-text">初始化内存池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">18.3.2.</span> <span class="nav-text">内存分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E6%B1%A0"><span class="nav-number">18.4.</span> <span class="nav-text">释放内存池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">18.5.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">18.6.</span> <span class="nav-text">扩展</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#malloc-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="nav-number">19.</span> <span class="nav-text">malloc 函数详解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">20.</span> <span class="nav-text">Linux内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="nav-number">20.1.</span> <span class="nav-text">虚拟内存地址与物理内存地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E4%B8%8E%E5%9C%B0%E5%9D%80%E6%9E%84%E6%88%90"><span class="nav-number">20.2.</span> <span class="nav-text">页与地址构成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%A1%B5%E4%B8%8E%E7%A3%81%E7%9B%98%E9%A1%B5"><span class="nav-number">20.3.</span> <span class="nav-text">内存页与磁盘页</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E7%BA%A7%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">21.</span> <span class="nav-text">Linux进程级内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%8E%92%E5%B8%83"><span class="nav-number">21.1.</span> <span class="nav-text">内存排布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">21.2.</span> <span class="nav-text">Heap内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#brk%E4%B8%8Esbrk"><span class="nav-number">21.3.</span> <span class="nav-text">brk与sbrk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E4%B8%8Erlimit"><span class="nav-number">21.4.</span> <span class="nav-text">资源限制与rlimit</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0malloc"><span class="nav-number">22.</span> <span class="nav-text">实现malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%A9%E5%85%B7%E5%AE%9E%E7%8E%B0"><span class="nav-number">22.1.</span> <span class="nav-text">玩具实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">22.2.</span> <span class="nav-text">正式实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">22.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E5%90%88%E9%80%82%E7%9A%84block"><span class="nav-number">22.2.2.</span> <span class="nav-text">寻找合适的block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E8%BE%9F%E6%96%B0%E7%9A%84block"><span class="nav-number">22.2.3.</span> <span class="nav-text">开辟新的block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E8%A3%82block"><span class="nav-number">22.2.4.</span> <span class="nav-text">分裂block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">22.2.5.</span> <span class="nav-text">malloc的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#calloc%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">22.2.6.</span> <span class="nav-text">calloc的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">22.2.7.</span> <span class="nav-text">free的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#realloc%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">22.2.8.</span> <span class="nav-text">realloc的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98%E5%92%8C%E4%BC%98%E5%8C%96"><span class="nav-number">22.3.</span> <span class="nav-text">遗留问题和优化</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
